"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/did-jwt-vc";
exports.ids = ["vendor-chunks/did-jwt-vc"];
exports.modules = {

/***/ "(rsc)/../../node_modules/did-jwt-vc/lib/index.module.js":
/*!*********************************************************!*\
  !*** ../../node_modules/did-jwt-vc/lib/index.module.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   VC_ERROR: () => (/* binding */ VC_ERROR),\n/* harmony export */   VC_JWT_ERROR: () => (/* binding */ VC_JWT_ERROR),\n/* harmony export */   createVerifiableCredentialJwt: () => (/* binding */ createVerifiableCredentialJwt),\n/* harmony export */   createVerifiablePresentationJwt: () => (/* binding */ createVerifiablePresentationJwt),\n/* harmony export */   normalizeCredential: () => (/* binding */ normalizeCredential),\n/* harmony export */   normalizePresentation: () => (/* binding */ normalizePresentation),\n/* harmony export */   transformCredentialInput: () => (/* binding */ transformCredentialInput),\n/* harmony export */   transformPresentationInput: () => (/* binding */ transformPresentationInput),\n/* harmony export */   validateCredentialPayload: () => (/* binding */ validateCredentialPayload),\n/* harmony export */   validateJwtCredentialPayload: () => (/* binding */ validateJwtCredentialPayload),\n/* harmony export */   validateJwtPresentationPayload: () => (/* binding */ validateJwtPresentationPayload),\n/* harmony export */   validatePresentationPayload: () => (/* binding */ validatePresentationPayload),\n/* harmony export */   verifyCredential: () => (/* binding */ verifyCredential),\n/* harmony export */   verifyPresentation: () => (/* binding */ verifyPresentation),\n/* harmony export */   verifyPresentationPayloadOptions: () => (/* binding */ verifyPresentationPayloadOptions)\n/* harmony export */ });\n/* harmony import */ var did_jwt__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! did-jwt */ \"(rsc)/../../node_modules/did-jwt/lib/index.module.js\");\n\n\nconst JWT_ALG = 'ES256K';\nconst JWT_FORMAT = /^[A-Za-z0-9-_=]+\\.[A-Za-z0-9-_=]+\\.?[A-Za-z0-9-_.+/=]*$/;\nconst DEFAULT_CONTEXT = 'https://www.w3.org/2018/credentials/v1';\nconst DEFAULT_VC_TYPE = 'VerifiableCredential';\nconst DEFAULT_VP_TYPE = 'VerifiablePresentation';\n/**\n * The `JwtProof2020` is a synthetic proof type, usable for differentiating credentials by proof type when representing\n * JWT credentials as W3C VC JSON. It is not a registered W3C VC Data Model algorithm and should not be treated as\n * such.\n *\n * This proof type is only intended as a convenience and does not actually prove the validity of a VC/VP in JSON\n * representation. The actual verifiable credential or presentation is represented in the `jwt` property.\n */\nconst DEFAULT_JWT_PROOF_TYPE = 'JwtProof2020';\n\n/**\n * Additional W3C VC fields:\n * These are defined as optional top-level properties in the W3C spec but are not mapped to top-level JWT names,\n * so they should be moved inside the \"vc\" object when transforming to a JWT.\n * Conversely, they should be moved out of the \"vc\" object when transforming from a JWT to W3C JSON.\n */\nconst additionalPropNames = ['evidence', 'termsOfUse', 'refreshService', 'credentialSchema', 'credentialStatus'];\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction asArray(arg) {\n  return Array.isArray(arg) ? arg : [arg];\n}\nfunction deepCopy(source) {\n  return Array.isArray(source) ? source.map(item => deepCopy(item)) : source instanceof Date ? new Date(source.getTime()) : source && typeof source === 'object' ? Object.getOwnPropertyNames(source).reduce((o, prop) => {\n    Object.defineProperty(o, prop, Object.getOwnPropertyDescriptor(source, prop));\n    o[prop] = deepCopy(source[prop]);\n    return o;\n  }, Object.create(Object.getPrototypeOf(source))) : source;\n}\nfunction notEmpty(value) {\n  return value !== null && value !== undefined;\n}\nfunction cleanUndefined(input) {\n  if (typeof input !== 'object' || input === null) {\n    return input;\n  }\n  const obj = {\n    ...input\n  };\n  Object.keys(obj).forEach(key => obj[key] === undefined && delete obj[key]);\n  return obj;\n}\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction isLegacyAttestationFormat(payload) {\n  // payload is an object and has all the required fields of old attestation format\n  return typeof payload === 'object' && payload.sub && payload.iss && payload.claim && payload.iat;\n}\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction attestationToVcFormat(payload) {\n  const {\n    iat,\n    nbf,\n    claim,\n    vc,\n    ...rest\n  } = payload;\n  const result = {\n    ...rest,\n    nbf: nbf ? nbf : iat,\n    vc: {\n      '@context': [DEFAULT_CONTEXT],\n      type: [DEFAULT_VC_TYPE],\n      credentialSubject: claim\n    }\n  };\n  if (vc) payload.issVc = vc;\n  return result;\n}\nfunction normalizeJwtCredentialPayload(input, removeOriginalFields = true) {\n  let result = deepCopy(input);\n  if (isLegacyAttestationFormat(input)) {\n    result = attestationToVcFormat(input);\n  }\n  // FIXME: handle case when credentialSubject(s) are not object types\n  result.credentialSubject = {\n    ...input.credentialSubject,\n    ...input.vc?.credentialSubject\n  };\n  if (input.sub && !input.credentialSubject?.id && result.credentialSubject) {\n    result.credentialSubject.id = input.sub;\n    if (removeOriginalFields) {\n      delete result.sub;\n    }\n  }\n  if (removeOriginalFields) {\n    delete result.vc?.credentialSubject;\n  }\n  if (typeof input.issuer === 'undefined' || typeof input.issuer === 'object') {\n    result.issuer = cleanUndefined({\n      id: input.iss,\n      ...input.issuer\n    });\n    if (removeOriginalFields && !input.issuer?.id) {\n      delete result.iss;\n    }\n  }\n  if (!input.id && input.jti) {\n    result.id = result.id || result.jti;\n    if (removeOriginalFields) {\n      delete result.jti;\n    }\n  }\n  const types = [...asArray(result.type), ...asArray(result.vc?.type)].filter(notEmpty);\n  result.type = [...new Set(types)];\n  if (removeOriginalFields) {\n    delete result.vc?.type;\n  }\n  for (const prop of additionalPropNames) {\n    if (input.vc && input.vc[prop]) {\n      if (!result[prop]) {\n        result[prop] = input.vc[prop];\n      }\n      if (removeOriginalFields) {\n        delete result.vc[prop];\n      }\n    }\n  }\n  const contextArray = [...asArray(input.context), ...asArray(input['@context']), ...asArray(input.vc?.['@context'])].filter(notEmpty);\n  result['@context'] = [...new Set(contextArray)];\n  if (removeOriginalFields) {\n    delete result.context;\n    delete result.vc?.['@context'];\n  }\n  if (!input.issuanceDate && (input.iat || input.nbf)) {\n    result.issuanceDate = new Date((input.nbf || input.iat) * 1000).toISOString();\n    if (removeOriginalFields) {\n      if (input.nbf) {\n        delete result.nbf;\n      } else {\n        delete result.iat;\n      }\n    }\n  }\n  if (!input.expirationDate && input.exp) {\n    result.expirationDate = new Date(input.exp * 1000).toISOString();\n    if (removeOriginalFields) {\n      delete result.exp;\n    }\n  }\n  if (removeOriginalFields) {\n    if (result.vc && Object.keys(result.vc).length === 0) {\n      delete result.vc;\n    }\n  }\n  // FIXME: interpret `aud` property as `verifier`\n  return result;\n}\nfunction normalizeJwtCredential(input, removeOriginalFields = true) {\n  let decoded;\n  try {\n    decoded = (0,did_jwt__WEBPACK_IMPORTED_MODULE_0__.decodeJWT)(input);\n  } catch {\n    throw new TypeError('unknown credential format');\n  }\n  return {\n    ...normalizeJwtCredentialPayload(decoded.payload, removeOriginalFields),\n    proof: {\n      type: DEFAULT_JWT_PROOF_TYPE,\n      jwt: input\n    }\n  };\n}\n/**\n * Normalizes a credential payload into an unambiguous W3C credential data type In case of conflict, existing W3C\n * Credential specific properties take precedence, except for arrays and object types which get merged.\n *\n * @param input - either a JWT or JWT payload, or a VerifiableCredential\n * @param removeOriginalFields - if true, removes all fields that were transformed according to the W3C mapping\n *\n * @see {@link https://www.w3.org/TR/vc-data-model/#jwt-encoding | VC JWT encoding }\n */\nfunction normalizeCredential(input, removeOriginalFields = true) {\n  if (typeof input === 'string') {\n    if (JWT_FORMAT.test(input)) {\n      return normalizeJwtCredential(input, removeOriginalFields);\n    } else {\n      let parsed;\n      try {\n        parsed = JSON.parse(input);\n      } catch {\n        throw new TypeError('unknown credential format');\n      }\n      return normalizeCredential(parsed, removeOriginalFields);\n    }\n  } else if (input.proof?.jwt) {\n    // TODO: test that it correctly propagates app specific proof properties\n    return deepCopy({\n      ...normalizeJwtCredential(input.proof.jwt, removeOriginalFields),\n      proof: input.proof\n    });\n  } else {\n    // TODO: test that it accepts JWT payload, CredentialPayload, VerifiableCredential\n    // TODO: test that it correctly propagates proof, if any\n    return {\n      proof: {},\n      ...normalizeJwtCredentialPayload(input, removeOriginalFields)\n    };\n  }\n}\n/**\n * Transforms a W3C Credential payload into a JWT compatible encoding.\n * The method accepts app specific fields and in case of collision, existing JWT properties will take precedence.\n * Also, `nbf`, `exp` and `jti` properties can be explicitly set to `undefined` and they will be kept intact.\n * @param input - either a JWT payload or a CredentialPayloadInput\n * @param removeOriginalFields - if true, removes original W3C fields from the resulting object\n *\n * @see {@link https://www.w3.org/TR/vc-data-model/#jwt-encoding | VC JWT encoding }\n */\nfunction transformCredentialInput(input, removeOriginalFields = true) {\n  if (Array.isArray(input.credentialSubject)) throw Error('credentialSubject of type array not supported');\n  const result = deepCopy({\n    vc: {\n      ...input.vc\n    },\n    ...input\n  });\n  result.vc = result.vc;\n  const credentialSubject = {\n    ...input.credentialSubject,\n    ...input.vc?.credentialSubject\n  };\n  if (!input.sub) {\n    result.sub = input.credentialSubject?.id;\n    if (removeOriginalFields) {\n      delete credentialSubject.id;\n    }\n  }\n  const contextEntries = [...asArray(input.context), ...asArray(input['@context']), ...asArray(input.vc?.['@context'])].filter(notEmpty);\n  result.vc['@context'] = [...new Set(contextEntries)];\n  if (removeOriginalFields) {\n    delete result.context;\n    delete result['@context'];\n  }\n  const types = [...asArray(input.type), ...asArray(input.vc?.type)].filter(notEmpty);\n  result.vc.type = [...new Set(types)];\n  if (removeOriginalFields) {\n    delete result.type;\n  }\n  if (input.id && Object.getOwnPropertyNames(input).indexOf('jti') === -1) {\n    result.jti = input.id;\n    if (removeOriginalFields) {\n      delete result.id;\n    }\n  }\n  if (input.issuanceDate && Object.getOwnPropertyNames(input).indexOf('nbf') === -1) {\n    const converted = Date.parse(input.issuanceDate);\n    if (!isNaN(converted)) {\n      result.nbf = Math.floor(converted / 1000);\n      if (removeOriginalFields) {\n        delete result.issuanceDate;\n      }\n    }\n  }\n  if (input.expirationDate && Object.getOwnPropertyNames(input).indexOf('exp') === -1) {\n    const converted = Date.parse(input.expirationDate);\n    if (!isNaN(converted)) {\n      result.exp = Math.floor(converted / 1000);\n      if (removeOriginalFields) {\n        delete result.expirationDate;\n      }\n    }\n  }\n  if (input.issuer && Object.getOwnPropertyNames(input).indexOf('iss') === -1) {\n    if (typeof input.issuer === 'object') {\n      result.iss = input.issuer?.id;\n      if (removeOriginalFields) {\n        delete result.issuer.id;\n        if (Object.keys(result.issuer).length === 0) {\n          delete result.issuer;\n        }\n      }\n    } else if (typeof input.issuer === 'string') {\n      result.iss = input.iss || '' + input.issuer;\n      if (removeOriginalFields) {\n        delete result.issuer;\n      }\n    } else ;\n  }\n  result.vc.credentialSubject = credentialSubject;\n  if (removeOriginalFields) {\n    delete result.credentialSubject;\n  }\n  for (const prop of additionalPropNames) {\n    if (input[prop]) {\n      if (!result.vc[prop]) {\n        result.vc[prop] = input[prop];\n      }\n      if (removeOriginalFields) {\n        delete result[prop];\n      }\n    }\n  }\n  return result;\n}\nfunction normalizeJwtPresentationPayload(input, removeOriginalFields = true) {\n  const result = deepCopy(input);\n  result.verifiableCredential = [...asArray(input.verifiableCredential), ...asArray(input.vp?.verifiableCredential)].filter(notEmpty);\n  result.verifiableCredential = result.verifiableCredential.map(cred => {\n    return normalizeCredential(cred, removeOriginalFields);\n  });\n  if (removeOriginalFields) {\n    delete result.vp?.verifiableCredential;\n  }\n  if (input.iss && !input.holder) {\n    result.holder = input.iss;\n    if (removeOriginalFields) {\n      delete result.iss;\n    }\n  }\n  if (input.aud) {\n    result.verifier = [...asArray(input.verifier), ...asArray(input.aud)].filter(notEmpty);\n    result.verifier = [...new Set(result.verifier)];\n    if (removeOriginalFields) {\n      delete result.aud;\n    }\n  }\n  if (input.jti && Object.getOwnPropertyNames(input).indexOf('id') === -1) {\n    result.id = input.id || input.jti;\n    if (removeOriginalFields) {\n      delete result.jti;\n    }\n  }\n  const types = [...asArray(input.type), ...asArray(input.vp?.type)].filter(notEmpty);\n  result.type = [...new Set(types)];\n  if (removeOriginalFields) {\n    delete result.vp?.type;\n  }\n  const contexts = [...asArray(input.context), ...asArray(input['@context']), ...asArray(input.vp?.['@context'])].filter(notEmpty);\n  result['@context'] = [...new Set(contexts)];\n  if (removeOriginalFields) {\n    delete result.context;\n    delete result.vp?.['@context'];\n  }\n  if (!input.issuanceDate && (input.iat || input.nbf)) {\n    result.issuanceDate = new Date((input.nbf || input.iat) * 1000).toISOString();\n    if (removeOriginalFields) {\n      if (input.nbf) {\n        delete result.nbf;\n      } else {\n        delete result.iat;\n      }\n    }\n  }\n  if (!input.expirationDate && input.exp) {\n    result.expirationDate = new Date(input.exp * 1000).toISOString();\n    if (removeOriginalFields) {\n      delete result.exp;\n    }\n  }\n  if (result.vp && Object.keys(result.vp).length === 0) {\n    if (removeOriginalFields) {\n      delete result.vp;\n    }\n  }\n  return result;\n}\nfunction normalizeJwtPresentation(input, removeOriginalFields = true) {\n  let decoded;\n  try {\n    decoded = (0,did_jwt__WEBPACK_IMPORTED_MODULE_0__.decodeJWT)(input);\n  } catch {\n    throw new TypeError('unknown presentation format');\n  }\n  return {\n    ...normalizeJwtPresentationPayload(decoded.payload, removeOriginalFields),\n    proof: {\n      type: DEFAULT_JWT_PROOF_TYPE,\n      jwt: input\n    }\n  };\n}\n/**\n * Normalizes a presentation payload into an unambiguous W3C Presentation data type.\n *\n * @see {@link https://www.w3.org/TR/vc-data-model/#jwt-encoding | VP JWT encoding }\n *\n * @param input - either a JWT or JWT payload, or a VerifiablePresentation\n * @param removeOriginalFields - if true, removes all fields that were transformed according to the W3C mapping\n */\nfunction normalizePresentation(input, removeOriginalFields = true) {\n  if (typeof input === 'string') {\n    if (JWT_FORMAT.test(input)) {\n      return normalizeJwtPresentation(input, removeOriginalFields);\n    } else {\n      let parsed;\n      try {\n        parsed = JSON.parse(input);\n      } catch {\n        throw new TypeError('unknown presentation format');\n      }\n      return normalizePresentation(parsed, removeOriginalFields);\n    }\n  } else if (input.proof?.jwt) {\n    // TODO: test that it correctly propagates app specific proof properties\n    return {\n      ...normalizeJwtPresentation(input.proof.jwt, removeOriginalFields),\n      proof: input.proof\n    };\n  } else {\n    // TODO: test that it accepts JWT payload, PresentationPayload, VerifiablePresentation\n    // TODO: test that it correctly propagates proof, if any\n    return {\n      proof: {},\n      ...normalizeJwtPresentationPayload(input, removeOriginalFields)\n    };\n  }\n}\n/**\n * Transforms a W3C Presentation payload into a JWT compatible encoding.\n * The method accepts app specific fields and in case of collision, existing JWT properties will take precedence.\n * Also, `nbf`, `exp` and `jti` properties can be explicitly set to `undefined` and they will be kept intact.\n * @param input - either a JWT payload or a CredentialPayloadInput\n * @param removeOriginalFields - when true, removes the original W3C fields from the resulting object\n *\n * @see {@link https://www.w3.org/TR/vc-data-model/#jwt-encoding | VP JWT encoding }\n */\nfunction transformPresentationInput(input, removeOriginalFields = true) {\n  const result = deepCopy({\n    vp: {\n      ...input.vp\n    },\n    ...input\n  });\n  result.vp = result.vp;\n  const contextEntries = [...asArray(input.context), ...asArray(input['@context']), ...asArray(input.vp?.['@context'])].filter(notEmpty);\n  result.vp['@context'] = [...new Set(contextEntries)];\n  if (removeOriginalFields) {\n    delete result.context;\n    delete result['@context'];\n  }\n  const types = [...asArray(input.type), ...asArray(input.vp?.type)].filter(notEmpty);\n  result.vp.type = [...new Set(types)];\n  if (removeOriginalFields) {\n    delete result.type;\n  }\n  if (input.id && Object.getOwnPropertyNames(input).indexOf('jti') === -1) {\n    result.jti = input.id;\n    if (removeOriginalFields) {\n      delete result.id;\n    }\n  }\n  if (input.issuanceDate && Object.getOwnPropertyNames(input).indexOf('nbf') === -1) {\n    const converted = Date.parse(input.issuanceDate);\n    if (!isNaN(converted)) {\n      result.nbf = Math.floor(converted / 1000);\n      if (removeOriginalFields) {\n        delete result.issuanceDate;\n      }\n    }\n  }\n  if (input.expirationDate && Object.getOwnPropertyNames(input).indexOf('exp') === -1) {\n    const converted = Date.parse(input.expirationDate);\n    if (!isNaN(converted)) {\n      result.exp = Math.floor(converted / 1000);\n      if (removeOriginalFields) {\n        delete result.expirationDate;\n      }\n    }\n  }\n  if (result.verifiableCredential || result.vp?.verifiableCredential) {\n    result.vp.verifiableCredential = [...asArray(result.verifiableCredential), ...asArray(result.vp?.verifiableCredential)].filter(notEmpty).map(credential => {\n      if (typeof credential === 'object' && credential.proof?.jwt) {\n        return credential.proof.jwt;\n      } else {\n        return credential;\n      }\n    });\n  }\n  if (removeOriginalFields) {\n    delete result.verifiableCredential;\n  }\n  if (input.holder && Object.getOwnPropertyNames(input).indexOf('iss') === -1) {\n    if (typeof input.holder === 'string') {\n      result.iss = input.holder;\n      if (removeOriginalFields) {\n        delete result.holder;\n      }\n    }\n  }\n  if (input.verifier) {\n    const audience = [...asArray(input.verifier), ...asArray(input.aud)].filter(notEmpty);\n    result.aud = [...new Set(audience)];\n    if (removeOriginalFields) {\n      delete result.verifier;\n    }\n  }\n  return result;\n}\n\n/**\n * Error prefixes used for known verification failure cases related to the\n * {@link https://www.w3.org/TR/vc-data-model/ | Verifiable Credential data model }\n */\nconst VC_ERROR = {\n  /**\n   * Thrown when the credential or presentation being verified does not conform to the data model defined by\n   * {@link https://www.w3.org/TR/vc-data-model/ | the spec}\n   */\n  SCHEMA_ERROR: 'schema_error',\n  /**\n   * Thrown when the input is not a JWT string\n   */\n  FORMAT_ERROR: 'format_error',\n  /**\n   * Thrown when verifying a presentation where `challenge` and/or `domain` don't match the expected values.\n   */\n  AUTH_ERROR: 'auth_error'\n};\n/**\n * Known validation or verification error prefixes.\n */\nconst VC_JWT_ERROR = {\n  ...VC_ERROR,\n  ...did_jwt__WEBPACK_IMPORTED_MODULE_0__.JWT_ERROR\n};\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction isDateObject(input) {\n  return input && !isNaN(input) && Object.prototype.toString.call(input) === '[object Date]';\n}\nfunction validateJwtFormat(value) {\n  if (typeof value === 'string' && !value.match(JWT_FORMAT)) {\n    throw new TypeError(`${VC_ERROR.FORMAT_ERROR}: \"${value}\" is not a valid JWT format`);\n  }\n}\n// The main scenario we want to guard against is having a timestamp in milliseconds\n// instead of seconds (ex: from new Date().getTime()).\n// We will check the number of digits and assume that any number with 12 or more\n// digits is a millisecond timestamp.\n// 10 digits max is 9999999999 -> 11/20/2286 @ 5:46pm (UTC)\n// 11 digits max is 99999999999 -> 11/16/5138 @ 9:46am (UTC)\n// 12 digits max is 999999999999 -> 09/27/33658 @ 1:46am (UTC)\nfunction validateTimestamp(value) {\n  if (typeof value === 'number') {\n    if (!(Number.isInteger(value) && value < 100000000000)) {\n      throw new TypeError(`${VC_ERROR.SCHEMA_ERROR}: \"${value}\" is not a unix timestamp in seconds`);\n    }\n  } else if (typeof value === 'string') {\n    validateTimestamp(Math.floor(new Date(value).valueOf() / 1000));\n  } else if (!isDateObject(value)) {\n    throw new TypeError(`${VC_ERROR.SCHEMA_ERROR}: \"${value}\" is not a valid time`);\n  }\n}\nfunction validateContext(value) {\n  const input = asArray(value);\n  if (input.length < 1 || input.indexOf(DEFAULT_CONTEXT) === -1) {\n    throw new TypeError(`${VC_ERROR.SCHEMA_ERROR}: @context is missing default context \"${DEFAULT_CONTEXT}\"`);\n  }\n}\nfunction validateVcType(value) {\n  const input = asArray(value);\n  if (input.length < 1 || input.indexOf(DEFAULT_VC_TYPE) === -1) {\n    throw new TypeError(`${VC_ERROR.SCHEMA_ERROR}: type is missing default \"${DEFAULT_VC_TYPE}\"`);\n  }\n}\nfunction validateVpType(value) {\n  const input = asArray(value);\n  if (input.length < 1 || input.indexOf(DEFAULT_VP_TYPE) === -1) {\n    throw new TypeError(`${VC_ERROR.SCHEMA_ERROR}: type is missing default \"${DEFAULT_VP_TYPE}\"`);\n  }\n}\nfunction validateCredentialSubject(value) {\n  if (Object.keys(value).length === 0) {\n    throw new TypeError(`${VC_ERROR.SCHEMA_ERROR}: credentialSubject must not be empty`);\n  }\n}\n\n/**\n * Verifies and validates a VerifiablePresentation that is encoded as a JWT according to the W3C spec.\n *\n * @return a `Promise` that resolves to a `VerifiedPresentation` or rejects with `TypeError` if the input is\n * not W3C compliant or the VerifyPresentationOptions are not satisfied.\n * @param presentation - the presentation to be verified. Currently only the JWT encoding is supported by this library\n * @param resolver - a configured `Resolver` or an implementation of `Resolvable` that can provide the DID document of\n *   the JWT issuer (presentation holder)\n * @param options - optional verification options that need to be satisfied. These are also forwarded to did-jwt.\n */\nconst verifyPresentation = function (presentation, resolver, options = {}) {\n  try {\n    const nbf = options?.policies?.issuanceDate === false ? false : undefined;\n    const exp = options?.policies?.expirationDate === false ? false : undefined;\n    options = {\n      audience: options.domain,\n      ...options,\n      policies: {\n        ...options?.policies,\n        nbf,\n        exp,\n        iat: nbf\n      }\n    };\n    return Promise.resolve((0,did_jwt__WEBPACK_IMPORTED_MODULE_0__.verifyJWT)(presentation, {\n      resolver,\n      ...options\n    })).then(function (verified) {\n      verifyPresentationPayloadOptions(verified.payload, options);\n      verified.verifiablePresentation = normalizePresentation(verified.jwt, options?.removeOriginalFields);\n      if (options?.policies?.format !== false) {\n        validatePresentationPayload(verified.verifiablePresentation);\n      }\n      return verified;\n    });\n  } catch (e) {\n    return Promise.reject(e);\n  }\n};\n/**\n * Verifies and validates a VerifiableCredential that is encoded as a JWT according to the W3C spec.\n *\n * @return a `Promise` that resolves to a `VerifiedCredential` or rejects with `TypeError` if the input is not\n * W3C compliant\n * @param vc - the credential to be verified. Currently only the JWT encoding is supported by this library\n * @param resolver - a configured `Resolver` (or an implementation of `Resolvable`) that can provide the DID document\n *   of the JWT issuer\n * @param options - optional tweaks to the verification process. These are forwarded to did-jwt.\n */\nconst verifyCredential = function (vc, resolver, options = {}) {\n  try {\n    const nbf = options?.policies?.issuanceDate === false ? false : undefined;\n    const exp = options?.policies?.expirationDate === false ? false : undefined;\n    options = {\n      ...options,\n      policies: {\n        ...options?.policies,\n        nbf,\n        exp,\n        iat: nbf\n      }\n    };\n    return Promise.resolve((0,did_jwt__WEBPACK_IMPORTED_MODULE_0__.verifyJWT)(vc, {\n      resolver,\n      ...options\n    })).then(function (verified) {\n      verified.verifiableCredential = normalizeCredential(verified.jwt, options?.removeOriginalFields);\n      if (options?.policies?.format !== false) {\n        validateCredentialPayload(verified.verifiableCredential);\n      }\n      return verified;\n    });\n  } catch (e) {\n    return Promise.reject(e);\n  }\n};\n/**\n * Verifies that the given JwtPresentationPayload contains the appropriate options from VerifyPresentationOptions\n *\n * @param payload - the JwtPresentationPayload to verify against\n * @param options - the VerifyPresentationOptions that contain the optional values to verify.\n * @throws {Error} If VerifyPresentationOptions are not satisfied\n */\n/**\n * Creates a VerifiablePresentation JWT given a `PresentationPayload` or `JwtPresentationPayload` and an `Issuer`.\n *\n * This method transforms the payload into the [JWT encoding](https://www.w3.org/TR/vc-data-model/#jwt-encoding)\n * described in the [W3C VC spec](https://www.w3.org/TR/vc-data-model) and then validated to conform to the minimum\n * spec\n * required spec.\n *\n * The `holder` is then used to assign an algorithm, override the `iss` field of the payload and then sign the JWT.\n *\n * @param payload - `PresentationPayload` or `JwtPresentationPayload`\n * @param holder - `Issuer` of the Presentation JWT (holder of the VC), signer and algorithm that will sign the token\n * @param options - `CreatePresentationOptions` allows to pass additional values to the resulting JWT payload. These\n *   options are forwarded to did-jwt.\n * @return a `Promise` that resolves to the JWT encoded verifiable presentation or rejects with `TypeError` if the\n * `payload` is not W3C compliant\n */\nconst createVerifiablePresentationJwt = function (payload, holder, options = {}) {\n  try {\n    const parsedPayload = {\n      iat: undefined,\n      ...transformPresentationInput(payload, options?.removeOriginalFields)\n    };\n    // add challenge to nonce\n    if (options.challenge && Object.getOwnPropertyNames(parsedPayload).indexOf('nonce') === -1) {\n      parsedPayload.nonce = options.challenge;\n    }\n    // add domain to audience.\n    if (options.domain) {\n      const audience = [...asArray(options.domain), ...asArray(parsedPayload.aud)].filter(notEmpty);\n      parsedPayload.aud = [...new Set(audience)];\n    }\n    validateJwtPresentationPayload(parsedPayload);\n    return Promise.resolve((0,did_jwt__WEBPACK_IMPORTED_MODULE_0__.createJWT)(parsedPayload, {\n      ...options,\n      issuer: holder.did || parsedPayload.iss || '',\n      signer: holder.signer\n    }, {\n      ...options.header,\n      alg: holder.alg || options.header?.alg || JWT_ALG\n    }));\n  } catch (e) {\n    return Promise.reject(e);\n  }\n};\n/**\n * Creates a VerifiableCredential given a `CredentialPayload` or `JwtCredentialPayload` and an `Issuer`.\n *\n * This method transforms the payload into the [JWT encoding](https://www.w3.org/TR/vc-data-model/#jwt-encoding)\n * described in the [W3C VC spec](https://www.w3.org/TR/vc-data-model) and then validated to conform to the minimum\n * spec\n * required spec.\n *\n * The `issuer` is then used to assign an algorithm, override the `iss` field of the payload and then sign the JWT.\n *\n * @param payload - `CredentialPayload` or `JwtCredentialPayload`\n * @param issuer - `Issuer` the DID, signer and algorithm that will sign the token\n * @param options - Use these options to tweak the creation of the JWT Credential. These are forwarded to did-jwt.\n * @return a `Promise` that resolves to the JWT encoded verifiable credential or rejects with `TypeError` if the\n * `payload` is not W3C compliant\n */\nconst createVerifiableCredentialJwt = function (payload, issuer, options = {}) {\n  try {\n    const parsedPayload = {\n      iat: undefined,\n      ...transformCredentialInput(payload, options.removeOriginalFields)\n    };\n    validateJwtCredentialPayload(parsedPayload);\n    if (!Array.isArray(issuer)) {\n      return Promise.resolve((0,did_jwt__WEBPACK_IMPORTED_MODULE_0__.createJWT)(parsedPayload, {\n        ...options,\n        issuer: issuer.did || parsedPayload.iss || '',\n        signer: issuer.signer\n      }, {\n        ...options.header,\n        alg: issuer.alg || options.header?.alg || JWT_ALG\n      }));\n    } else {\n      const did = issuer[0].did;\n      const issuers = [];\n      for (const iss of issuer) {\n        if (iss.did !== did) {\n          throw new Error('All issuers must be the same did to comply with the Verifiable Conditions spec');\n        }\n        issuers.push({\n          issuer: iss.did || parsedPayload.iss || '',\n          signer: iss.signer,\n          alg: iss.alg || options.header?.alg || JWT_ALG\n        });\n      }\n      return Promise.resolve((0,did_jwt__WEBPACK_IMPORTED_MODULE_0__.createMultisignatureJWT)(parsedPayload, {\n        ...options\n      }, issuers));\n    }\n  } catch (e) {\n    return Promise.reject(e);\n  }\n};\nfunction validateJwtCredentialPayload(payload) {\n  validateContext(payload.vc['@context']);\n  validateVcType(payload.vc.type);\n  validateCredentialSubject(payload.vc.credentialSubject);\n  if (payload.nbf) validateTimestamp(payload.nbf);\n  if (payload.exp) validateTimestamp(payload.exp);\n}\nfunction validateCredentialPayload(payload) {\n  validateContext(payload['@context']);\n  validateVcType(payload.type);\n  validateCredentialSubject(payload.credentialSubject);\n  if (payload.issuanceDate) validateTimestamp(payload.issuanceDate);\n  if (payload.expirationDate) validateTimestamp(payload.expirationDate);\n}\nfunction validateJwtPresentationPayload(payload) {\n  validateContext(payload.vp['@context']);\n  validateVpType(payload.vp.type);\n  // empty credential array is allowed\n  if (payload.vp.verifiableCredential && payload.vp.verifiableCredential.length >= 1) {\n    for (const vc of asArray(payload.vp.verifiableCredential)) {\n      if (typeof vc === 'string') {\n        validateJwtFormat(vc);\n      } else {\n        validateCredentialPayload(vc);\n      }\n    }\n  }\n  if (payload.exp) validateTimestamp(payload.exp);\n}\nfunction validatePresentationPayload(payload) {\n  validateContext(payload['@context']);\n  validateVpType(payload.type);\n  // empty credential array is allowed\n  if (payload.verifiableCredential && payload.verifiableCredential.length >= 1) {\n    for (const vc of payload.verifiableCredential) {\n      if (typeof vc === 'string') {\n        validateJwtFormat(vc);\n      } else {\n        validateCredentialPayload(vc);\n      }\n    }\n  }\n  if (payload.expirationDate) validateTimestamp(payload.expirationDate);\n}\nfunction verifyPresentationPayloadOptions(payload, options) {\n  if (options.challenge && options.challenge !== payload.nonce) {\n    throw new Error(`${VC_ERROR.AUTH_ERROR}: Presentation does not contain the mandatory challenge (JWT: nonce) for : ${options.challenge}`);\n  }\n  if (options.domain) {\n    // aud might be an array\n    let matchedAudience;\n    if (payload.aud) {\n      const audArray = Array.isArray(payload.aud) ? payload.aud : [payload.aud];\n      matchedAudience = audArray.find(item => options.domain === item);\n    }\n    if (typeof matchedAudience === 'undefined') {\n      throw new Error(`${VC_ERROR.AUTH_ERROR}: Presentation does not contain the mandatory domain (JWT: aud) for : ${options.domain}`);\n    }\n  }\n}\n\n\n//# sourceMappingURL=index.module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2RpZC1qd3QtdmMvbGliL2luZGV4Lm1vZHVsZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQThGOztBQUU5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGtEQUFTO0FBQ3ZCLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxrREFBUztBQUN2QixJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLDhDQUFTO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsc0JBQXNCLEtBQUssTUFBTTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsc0JBQXNCLEtBQUssTUFBTTtBQUM5RDtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSiwyQkFBMkIsc0JBQXNCLEtBQUssTUFBTTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHNCQUFzQix5Q0FBeUMsZ0JBQWdCO0FBQzFHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsc0JBQXNCLDZCQUE2QixnQkFBZ0I7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixzQkFBc0IsNkJBQTZCLGdCQUFnQjtBQUM5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixzQkFBc0I7QUFDakQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RTtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixrREFBUztBQUNwQztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGtEQUFTO0FBQ3BDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRUFBK0U7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGtEQUFTO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RTtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixrREFBUztBQUN0QztBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSw2QkFBNkIsZ0VBQXVCO0FBQ3BEO0FBQ0EsT0FBTztBQUNQO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixvQkFBb0IsNkVBQTZFLGtCQUFrQjtBQUMxSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsb0JBQW9CLHdFQUF3RSxlQUFlO0FBQ3BJO0FBQ0E7QUFDQTs7QUFFa1k7QUFDbFkiLCJzb3VyY2VzIjpbIi9ob21lL2JhcmIvYWEvQXNzb2NpYXRlZEFjY291bnRzL25vZGVfbW9kdWxlcy9kaWQtand0LXZjL2xpYi9pbmRleC5tb2R1bGUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZGVjb2RlSldULCBKV1RfRVJST1IsIHZlcmlmeUpXVCwgY3JlYXRlSldULCBjcmVhdGVNdWx0aXNpZ25hdHVyZUpXVCB9IGZyb20gJ2RpZC1qd3QnO1xuXG5jb25zdCBKV1RfQUxHID0gJ0VTMjU2Syc7XG5jb25zdCBKV1RfRk9STUFUID0gL15bQS1aYS16MC05LV89XStcXC5bQS1aYS16MC05LV89XStcXC4/W0EtWmEtejAtOS1fLisvPV0qJC87XG5jb25zdCBERUZBVUxUX0NPTlRFWFQgPSAnaHR0cHM6Ly93d3cudzMub3JnLzIwMTgvY3JlZGVudGlhbHMvdjEnO1xuY29uc3QgREVGQVVMVF9WQ19UWVBFID0gJ1ZlcmlmaWFibGVDcmVkZW50aWFsJztcbmNvbnN0IERFRkFVTFRfVlBfVFlQRSA9ICdWZXJpZmlhYmxlUHJlc2VudGF0aW9uJztcbi8qKlxuICogVGhlIGBKd3RQcm9vZjIwMjBgIGlzIGEgc3ludGhldGljIHByb29mIHR5cGUsIHVzYWJsZSBmb3IgZGlmZmVyZW50aWF0aW5nIGNyZWRlbnRpYWxzIGJ5IHByb29mIHR5cGUgd2hlbiByZXByZXNlbnRpbmdcbiAqIEpXVCBjcmVkZW50aWFscyBhcyBXM0MgVkMgSlNPTi4gSXQgaXMgbm90IGEgcmVnaXN0ZXJlZCBXM0MgVkMgRGF0YSBNb2RlbCBhbGdvcml0aG0gYW5kIHNob3VsZCBub3QgYmUgdHJlYXRlZCBhc1xuICogc3VjaC5cbiAqXG4gKiBUaGlzIHByb29mIHR5cGUgaXMgb25seSBpbnRlbmRlZCBhcyBhIGNvbnZlbmllbmNlIGFuZCBkb2VzIG5vdCBhY3R1YWxseSBwcm92ZSB0aGUgdmFsaWRpdHkgb2YgYSBWQy9WUCBpbiBKU09OXG4gKiByZXByZXNlbnRhdGlvbi4gVGhlIGFjdHVhbCB2ZXJpZmlhYmxlIGNyZWRlbnRpYWwgb3IgcHJlc2VudGF0aW9uIGlzIHJlcHJlc2VudGVkIGluIHRoZSBgand0YCBwcm9wZXJ0eS5cbiAqL1xuY29uc3QgREVGQVVMVF9KV1RfUFJPT0ZfVFlQRSA9ICdKd3RQcm9vZjIwMjAnO1xuXG4vKipcbiAqIEFkZGl0aW9uYWwgVzNDIFZDIGZpZWxkczpcbiAqIFRoZXNlIGFyZSBkZWZpbmVkIGFzIG9wdGlvbmFsIHRvcC1sZXZlbCBwcm9wZXJ0aWVzIGluIHRoZSBXM0Mgc3BlYyBidXQgYXJlIG5vdCBtYXBwZWQgdG8gdG9wLWxldmVsIEpXVCBuYW1lcyxcbiAqIHNvIHRoZXkgc2hvdWxkIGJlIG1vdmVkIGluc2lkZSB0aGUgXCJ2Y1wiIG9iamVjdCB3aGVuIHRyYW5zZm9ybWluZyB0byBhIEpXVC5cbiAqIENvbnZlcnNlbHksIHRoZXkgc2hvdWxkIGJlIG1vdmVkIG91dCBvZiB0aGUgXCJ2Y1wiIG9iamVjdCB3aGVuIHRyYW5zZm9ybWluZyBmcm9tIGEgSldUIHRvIFczQyBKU09OLlxuICovXG5jb25zdCBhZGRpdGlvbmFsUHJvcE5hbWVzID0gWydldmlkZW5jZScsICd0ZXJtc09mVXNlJywgJ3JlZnJlc2hTZXJ2aWNlJywgJ2NyZWRlbnRpYWxTY2hlbWEnLCAnY3JlZGVudGlhbFN0YXR1cyddO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmZ1bmN0aW9uIGFzQXJyYXkoYXJnKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KGFyZykgPyBhcmcgOiBbYXJnXTtcbn1cbmZ1bmN0aW9uIGRlZXBDb3B5KHNvdXJjZSkge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShzb3VyY2UpID8gc291cmNlLm1hcChpdGVtID0+IGRlZXBDb3B5KGl0ZW0pKSA6IHNvdXJjZSBpbnN0YW5jZW9mIERhdGUgPyBuZXcgRGF0ZShzb3VyY2UuZ2V0VGltZSgpKSA6IHNvdXJjZSAmJiB0eXBlb2Ygc291cmNlID09PSAnb2JqZWN0JyA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHNvdXJjZSkucmVkdWNlKChvLCBwcm9wKSA9PiB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIHByb3AsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBwcm9wKSk7XG4gICAgb1twcm9wXSA9IGRlZXBDb3B5KHNvdXJjZVtwcm9wXSk7XG4gICAgcmV0dXJuIG87XG4gIH0sIE9iamVjdC5jcmVhdGUoT2JqZWN0LmdldFByb3RvdHlwZU9mKHNvdXJjZSkpKSA6IHNvdXJjZTtcbn1cbmZ1bmN0aW9uIG5vdEVtcHR5KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gY2xlYW5VbmRlZmluZWQoaW5wdXQpIHtcbiAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gJ29iamVjdCcgfHwgaW5wdXQgPT09IG51bGwpIHtcbiAgICByZXR1cm4gaW5wdXQ7XG4gIH1cbiAgY29uc3Qgb2JqID0ge1xuICAgIC4uLmlucHV0XG4gIH07XG4gIE9iamVjdC5rZXlzKG9iaikuZm9yRWFjaChrZXkgPT4gb2JqW2tleV0gPT09IHVuZGVmaW5lZCAmJiBkZWxldGUgb2JqW2tleV0pO1xuICByZXR1cm4gb2JqO1xufVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmZ1bmN0aW9uIGlzTGVnYWN5QXR0ZXN0YXRpb25Gb3JtYXQocGF5bG9hZCkge1xuICAvLyBwYXlsb2FkIGlzIGFuIG9iamVjdCBhbmQgaGFzIGFsbCB0aGUgcmVxdWlyZWQgZmllbGRzIG9mIG9sZCBhdHRlc3RhdGlvbiBmb3JtYXRcbiAgcmV0dXJuIHR5cGVvZiBwYXlsb2FkID09PSAnb2JqZWN0JyAmJiBwYXlsb2FkLnN1YiAmJiBwYXlsb2FkLmlzcyAmJiBwYXlsb2FkLmNsYWltICYmIHBheWxvYWQuaWF0O1xufVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmZ1bmN0aW9uIGF0dGVzdGF0aW9uVG9WY0Zvcm1hdChwYXlsb2FkKSB7XG4gIGNvbnN0IHtcbiAgICBpYXQsXG4gICAgbmJmLFxuICAgIGNsYWltLFxuICAgIHZjLFxuICAgIC4uLnJlc3RcbiAgfSA9IHBheWxvYWQ7XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAuLi5yZXN0LFxuICAgIG5iZjogbmJmID8gbmJmIDogaWF0LFxuICAgIHZjOiB7XG4gICAgICAnQGNvbnRleHQnOiBbREVGQVVMVF9DT05URVhUXSxcbiAgICAgIHR5cGU6IFtERUZBVUxUX1ZDX1RZUEVdLFxuICAgICAgY3JlZGVudGlhbFN1YmplY3Q6IGNsYWltXG4gICAgfVxuICB9O1xuICBpZiAodmMpIHBheWxvYWQuaXNzVmMgPSB2YztcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZUp3dENyZWRlbnRpYWxQYXlsb2FkKGlucHV0LCByZW1vdmVPcmlnaW5hbEZpZWxkcyA9IHRydWUpIHtcbiAgbGV0IHJlc3VsdCA9IGRlZXBDb3B5KGlucHV0KTtcbiAgaWYgKGlzTGVnYWN5QXR0ZXN0YXRpb25Gb3JtYXQoaW5wdXQpKSB7XG4gICAgcmVzdWx0ID0gYXR0ZXN0YXRpb25Ub1ZjRm9ybWF0KGlucHV0KTtcbiAgfVxuICAvLyBGSVhNRTogaGFuZGxlIGNhc2Ugd2hlbiBjcmVkZW50aWFsU3ViamVjdChzKSBhcmUgbm90IG9iamVjdCB0eXBlc1xuICByZXN1bHQuY3JlZGVudGlhbFN1YmplY3QgPSB7XG4gICAgLi4uaW5wdXQuY3JlZGVudGlhbFN1YmplY3QsXG4gICAgLi4uaW5wdXQudmM/LmNyZWRlbnRpYWxTdWJqZWN0XG4gIH07XG4gIGlmIChpbnB1dC5zdWIgJiYgIWlucHV0LmNyZWRlbnRpYWxTdWJqZWN0Py5pZCAmJiByZXN1bHQuY3JlZGVudGlhbFN1YmplY3QpIHtcbiAgICByZXN1bHQuY3JlZGVudGlhbFN1YmplY3QuaWQgPSBpbnB1dC5zdWI7XG4gICAgaWYgKHJlbW92ZU9yaWdpbmFsRmllbGRzKSB7XG4gICAgICBkZWxldGUgcmVzdWx0LnN1YjtcbiAgICB9XG4gIH1cbiAgaWYgKHJlbW92ZU9yaWdpbmFsRmllbGRzKSB7XG4gICAgZGVsZXRlIHJlc3VsdC52Yz8uY3JlZGVudGlhbFN1YmplY3Q7XG4gIH1cbiAgaWYgKHR5cGVvZiBpbnB1dC5pc3N1ZXIgPT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiBpbnB1dC5pc3N1ZXIgPT09ICdvYmplY3QnKSB7XG4gICAgcmVzdWx0Lmlzc3VlciA9IGNsZWFuVW5kZWZpbmVkKHtcbiAgICAgIGlkOiBpbnB1dC5pc3MsXG4gICAgICAuLi5pbnB1dC5pc3N1ZXJcbiAgICB9KTtcbiAgICBpZiAocmVtb3ZlT3JpZ2luYWxGaWVsZHMgJiYgIWlucHV0Lmlzc3Vlcj8uaWQpIHtcbiAgICAgIGRlbGV0ZSByZXN1bHQuaXNzO1xuICAgIH1cbiAgfVxuICBpZiAoIWlucHV0LmlkICYmIGlucHV0Lmp0aSkge1xuICAgIHJlc3VsdC5pZCA9IHJlc3VsdC5pZCB8fCByZXN1bHQuanRpO1xuICAgIGlmIChyZW1vdmVPcmlnaW5hbEZpZWxkcykge1xuICAgICAgZGVsZXRlIHJlc3VsdC5qdGk7XG4gICAgfVxuICB9XG4gIGNvbnN0IHR5cGVzID0gWy4uLmFzQXJyYXkocmVzdWx0LnR5cGUpLCAuLi5hc0FycmF5KHJlc3VsdC52Yz8udHlwZSldLmZpbHRlcihub3RFbXB0eSk7XG4gIHJlc3VsdC50eXBlID0gWy4uLm5ldyBTZXQodHlwZXMpXTtcbiAgaWYgKHJlbW92ZU9yaWdpbmFsRmllbGRzKSB7XG4gICAgZGVsZXRlIHJlc3VsdC52Yz8udHlwZTtcbiAgfVxuICBmb3IgKGNvbnN0IHByb3Agb2YgYWRkaXRpb25hbFByb3BOYW1lcykge1xuICAgIGlmIChpbnB1dC52YyAmJiBpbnB1dC52Y1twcm9wXSkge1xuICAgICAgaWYgKCFyZXN1bHRbcHJvcF0pIHtcbiAgICAgICAgcmVzdWx0W3Byb3BdID0gaW5wdXQudmNbcHJvcF07XG4gICAgICB9XG4gICAgICBpZiAocmVtb3ZlT3JpZ2luYWxGaWVsZHMpIHtcbiAgICAgICAgZGVsZXRlIHJlc3VsdC52Y1twcm9wXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY29uc3QgY29udGV4dEFycmF5ID0gWy4uLmFzQXJyYXkoaW5wdXQuY29udGV4dCksIC4uLmFzQXJyYXkoaW5wdXRbJ0Bjb250ZXh0J10pLCAuLi5hc0FycmF5KGlucHV0LnZjPy5bJ0Bjb250ZXh0J10pXS5maWx0ZXIobm90RW1wdHkpO1xuICByZXN1bHRbJ0Bjb250ZXh0J10gPSBbLi4ubmV3IFNldChjb250ZXh0QXJyYXkpXTtcbiAgaWYgKHJlbW92ZU9yaWdpbmFsRmllbGRzKSB7XG4gICAgZGVsZXRlIHJlc3VsdC5jb250ZXh0O1xuICAgIGRlbGV0ZSByZXN1bHQudmM/LlsnQGNvbnRleHQnXTtcbiAgfVxuICBpZiAoIWlucHV0Lmlzc3VhbmNlRGF0ZSAmJiAoaW5wdXQuaWF0IHx8IGlucHV0Lm5iZikpIHtcbiAgICByZXN1bHQuaXNzdWFuY2VEYXRlID0gbmV3IERhdGUoKGlucHV0Lm5iZiB8fCBpbnB1dC5pYXQpICogMTAwMCkudG9JU09TdHJpbmcoKTtcbiAgICBpZiAocmVtb3ZlT3JpZ2luYWxGaWVsZHMpIHtcbiAgICAgIGlmIChpbnB1dC5uYmYpIHtcbiAgICAgICAgZGVsZXRlIHJlc3VsdC5uYmY7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWxldGUgcmVzdWx0LmlhdDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKCFpbnB1dC5leHBpcmF0aW9uRGF0ZSAmJiBpbnB1dC5leHApIHtcbiAgICByZXN1bHQuZXhwaXJhdGlvbkRhdGUgPSBuZXcgRGF0ZShpbnB1dC5leHAgKiAxMDAwKS50b0lTT1N0cmluZygpO1xuICAgIGlmIChyZW1vdmVPcmlnaW5hbEZpZWxkcykge1xuICAgICAgZGVsZXRlIHJlc3VsdC5leHA7XG4gICAgfVxuICB9XG4gIGlmIChyZW1vdmVPcmlnaW5hbEZpZWxkcykge1xuICAgIGlmIChyZXN1bHQudmMgJiYgT2JqZWN0LmtleXMocmVzdWx0LnZjKS5sZW5ndGggPT09IDApIHtcbiAgICAgIGRlbGV0ZSByZXN1bHQudmM7XG4gICAgfVxuICB9XG4gIC8vIEZJWE1FOiBpbnRlcnByZXQgYGF1ZGAgcHJvcGVydHkgYXMgYHZlcmlmaWVyYFxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gbm9ybWFsaXplSnd0Q3JlZGVudGlhbChpbnB1dCwgcmVtb3ZlT3JpZ2luYWxGaWVsZHMgPSB0cnVlKSB7XG4gIGxldCBkZWNvZGVkO1xuICB0cnkge1xuICAgIGRlY29kZWQgPSBkZWNvZGVKV1QoaW5wdXQpO1xuICB9IGNhdGNoIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd1bmtub3duIGNyZWRlbnRpYWwgZm9ybWF0Jyk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICAuLi5ub3JtYWxpemVKd3RDcmVkZW50aWFsUGF5bG9hZChkZWNvZGVkLnBheWxvYWQsIHJlbW92ZU9yaWdpbmFsRmllbGRzKSxcbiAgICBwcm9vZjoge1xuICAgICAgdHlwZTogREVGQVVMVF9KV1RfUFJPT0ZfVFlQRSxcbiAgICAgIGp3dDogaW5wdXRcbiAgICB9XG4gIH07XG59XG4vKipcbiAqIE5vcm1hbGl6ZXMgYSBjcmVkZW50aWFsIHBheWxvYWQgaW50byBhbiB1bmFtYmlndW91cyBXM0MgY3JlZGVudGlhbCBkYXRhIHR5cGUgSW4gY2FzZSBvZiBjb25mbGljdCwgZXhpc3RpbmcgVzNDXG4gKiBDcmVkZW50aWFsIHNwZWNpZmljIHByb3BlcnRpZXMgdGFrZSBwcmVjZWRlbmNlLCBleGNlcHQgZm9yIGFycmF5cyBhbmQgb2JqZWN0IHR5cGVzIHdoaWNoIGdldCBtZXJnZWQuXG4gKlxuICogQHBhcmFtIGlucHV0IC0gZWl0aGVyIGEgSldUIG9yIEpXVCBwYXlsb2FkLCBvciBhIFZlcmlmaWFibGVDcmVkZW50aWFsXG4gKiBAcGFyYW0gcmVtb3ZlT3JpZ2luYWxGaWVsZHMgLSBpZiB0cnVlLCByZW1vdmVzIGFsbCBmaWVsZHMgdGhhdCB3ZXJlIHRyYW5zZm9ybWVkIGFjY29yZGluZyB0byB0aGUgVzNDIG1hcHBpbmdcbiAqXG4gKiBAc2VlIHtAbGluayBodHRwczovL3d3dy53My5vcmcvVFIvdmMtZGF0YS1tb2RlbC8jand0LWVuY29kaW5nIHwgVkMgSldUIGVuY29kaW5nIH1cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplQ3JlZGVudGlhbChpbnB1dCwgcmVtb3ZlT3JpZ2luYWxGaWVsZHMgPSB0cnVlKSB7XG4gIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKEpXVF9GT1JNQVQudGVzdChpbnB1dCkpIHtcbiAgICAgIHJldHVybiBub3JtYWxpemVKd3RDcmVkZW50aWFsKGlucHV0LCByZW1vdmVPcmlnaW5hbEZpZWxkcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBwYXJzZWQ7XG4gICAgICB0cnkge1xuICAgICAgICBwYXJzZWQgPSBKU09OLnBhcnNlKGlucHV0KTtcbiAgICAgIH0gY2F0Y2gge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd1bmtub3duIGNyZWRlbnRpYWwgZm9ybWF0Jyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbm9ybWFsaXplQ3JlZGVudGlhbChwYXJzZWQsIHJlbW92ZU9yaWdpbmFsRmllbGRzKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaW5wdXQucHJvb2Y/Lmp3dCkge1xuICAgIC8vIFRPRE86IHRlc3QgdGhhdCBpdCBjb3JyZWN0bHkgcHJvcGFnYXRlcyBhcHAgc3BlY2lmaWMgcHJvb2YgcHJvcGVydGllc1xuICAgIHJldHVybiBkZWVwQ29weSh7XG4gICAgICAuLi5ub3JtYWxpemVKd3RDcmVkZW50aWFsKGlucHV0LnByb29mLmp3dCwgcmVtb3ZlT3JpZ2luYWxGaWVsZHMpLFxuICAgICAgcHJvb2Y6IGlucHV0LnByb29mXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gVE9ETzogdGVzdCB0aGF0IGl0IGFjY2VwdHMgSldUIHBheWxvYWQsIENyZWRlbnRpYWxQYXlsb2FkLCBWZXJpZmlhYmxlQ3JlZGVudGlhbFxuICAgIC8vIFRPRE86IHRlc3QgdGhhdCBpdCBjb3JyZWN0bHkgcHJvcGFnYXRlcyBwcm9vZiwgaWYgYW55XG4gICAgcmV0dXJuIHtcbiAgICAgIHByb29mOiB7fSxcbiAgICAgIC4uLm5vcm1hbGl6ZUp3dENyZWRlbnRpYWxQYXlsb2FkKGlucHV0LCByZW1vdmVPcmlnaW5hbEZpZWxkcylcbiAgICB9O1xuICB9XG59XG4vKipcbiAqIFRyYW5zZm9ybXMgYSBXM0MgQ3JlZGVudGlhbCBwYXlsb2FkIGludG8gYSBKV1QgY29tcGF0aWJsZSBlbmNvZGluZy5cbiAqIFRoZSBtZXRob2QgYWNjZXB0cyBhcHAgc3BlY2lmaWMgZmllbGRzIGFuZCBpbiBjYXNlIG9mIGNvbGxpc2lvbiwgZXhpc3RpbmcgSldUIHByb3BlcnRpZXMgd2lsbCB0YWtlIHByZWNlZGVuY2UuXG4gKiBBbHNvLCBgbmJmYCwgYGV4cGAgYW5kIGBqdGlgIHByb3BlcnRpZXMgY2FuIGJlIGV4cGxpY2l0bHkgc2V0IHRvIGB1bmRlZmluZWRgIGFuZCB0aGV5IHdpbGwgYmUga2VwdCBpbnRhY3QuXG4gKiBAcGFyYW0gaW5wdXQgLSBlaXRoZXIgYSBKV1QgcGF5bG9hZCBvciBhIENyZWRlbnRpYWxQYXlsb2FkSW5wdXRcbiAqIEBwYXJhbSByZW1vdmVPcmlnaW5hbEZpZWxkcyAtIGlmIHRydWUsIHJlbW92ZXMgb3JpZ2luYWwgVzNDIGZpZWxkcyBmcm9tIHRoZSByZXN1bHRpbmcgb2JqZWN0XG4gKlxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly93d3cudzMub3JnL1RSL3ZjLWRhdGEtbW9kZWwvI2p3dC1lbmNvZGluZyB8IFZDIEpXVCBlbmNvZGluZyB9XG4gKi9cbmZ1bmN0aW9uIHRyYW5zZm9ybUNyZWRlbnRpYWxJbnB1dChpbnB1dCwgcmVtb3ZlT3JpZ2luYWxGaWVsZHMgPSB0cnVlKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGlucHV0LmNyZWRlbnRpYWxTdWJqZWN0KSkgdGhyb3cgRXJyb3IoJ2NyZWRlbnRpYWxTdWJqZWN0IG9mIHR5cGUgYXJyYXkgbm90IHN1cHBvcnRlZCcpO1xuICBjb25zdCByZXN1bHQgPSBkZWVwQ29weSh7XG4gICAgdmM6IHtcbiAgICAgIC4uLmlucHV0LnZjXG4gICAgfSxcbiAgICAuLi5pbnB1dFxuICB9KTtcbiAgcmVzdWx0LnZjID0gcmVzdWx0LnZjO1xuICBjb25zdCBjcmVkZW50aWFsU3ViamVjdCA9IHtcbiAgICAuLi5pbnB1dC5jcmVkZW50aWFsU3ViamVjdCxcbiAgICAuLi5pbnB1dC52Yz8uY3JlZGVudGlhbFN1YmplY3RcbiAgfTtcbiAgaWYgKCFpbnB1dC5zdWIpIHtcbiAgICByZXN1bHQuc3ViID0gaW5wdXQuY3JlZGVudGlhbFN1YmplY3Q/LmlkO1xuICAgIGlmIChyZW1vdmVPcmlnaW5hbEZpZWxkcykge1xuICAgICAgZGVsZXRlIGNyZWRlbnRpYWxTdWJqZWN0LmlkO1xuICAgIH1cbiAgfVxuICBjb25zdCBjb250ZXh0RW50cmllcyA9IFsuLi5hc0FycmF5KGlucHV0LmNvbnRleHQpLCAuLi5hc0FycmF5KGlucHV0WydAY29udGV4dCddKSwgLi4uYXNBcnJheShpbnB1dC52Yz8uWydAY29udGV4dCddKV0uZmlsdGVyKG5vdEVtcHR5KTtcbiAgcmVzdWx0LnZjWydAY29udGV4dCddID0gWy4uLm5ldyBTZXQoY29udGV4dEVudHJpZXMpXTtcbiAgaWYgKHJlbW92ZU9yaWdpbmFsRmllbGRzKSB7XG4gICAgZGVsZXRlIHJlc3VsdC5jb250ZXh0O1xuICAgIGRlbGV0ZSByZXN1bHRbJ0Bjb250ZXh0J107XG4gIH1cbiAgY29uc3QgdHlwZXMgPSBbLi4uYXNBcnJheShpbnB1dC50eXBlKSwgLi4uYXNBcnJheShpbnB1dC52Yz8udHlwZSldLmZpbHRlcihub3RFbXB0eSk7XG4gIHJlc3VsdC52Yy50eXBlID0gWy4uLm5ldyBTZXQodHlwZXMpXTtcbiAgaWYgKHJlbW92ZU9yaWdpbmFsRmllbGRzKSB7XG4gICAgZGVsZXRlIHJlc3VsdC50eXBlO1xuICB9XG4gIGlmIChpbnB1dC5pZCAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhpbnB1dCkuaW5kZXhPZignanRpJykgPT09IC0xKSB7XG4gICAgcmVzdWx0Lmp0aSA9IGlucHV0LmlkO1xuICAgIGlmIChyZW1vdmVPcmlnaW5hbEZpZWxkcykge1xuICAgICAgZGVsZXRlIHJlc3VsdC5pZDtcbiAgICB9XG4gIH1cbiAgaWYgKGlucHV0Lmlzc3VhbmNlRGF0ZSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhpbnB1dCkuaW5kZXhPZignbmJmJykgPT09IC0xKSB7XG4gICAgY29uc3QgY29udmVydGVkID0gRGF0ZS5wYXJzZShpbnB1dC5pc3N1YW5jZURhdGUpO1xuICAgIGlmICghaXNOYU4oY29udmVydGVkKSkge1xuICAgICAgcmVzdWx0Lm5iZiA9IE1hdGguZmxvb3IoY29udmVydGVkIC8gMTAwMCk7XG4gICAgICBpZiAocmVtb3ZlT3JpZ2luYWxGaWVsZHMpIHtcbiAgICAgICAgZGVsZXRlIHJlc3VsdC5pc3N1YW5jZURhdGU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChpbnB1dC5leHBpcmF0aW9uRGF0ZSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhpbnB1dCkuaW5kZXhPZignZXhwJykgPT09IC0xKSB7XG4gICAgY29uc3QgY29udmVydGVkID0gRGF0ZS5wYXJzZShpbnB1dC5leHBpcmF0aW9uRGF0ZSk7XG4gICAgaWYgKCFpc05hTihjb252ZXJ0ZWQpKSB7XG4gICAgICByZXN1bHQuZXhwID0gTWF0aC5mbG9vcihjb252ZXJ0ZWQgLyAxMDAwKTtcbiAgICAgIGlmIChyZW1vdmVPcmlnaW5hbEZpZWxkcykge1xuICAgICAgICBkZWxldGUgcmVzdWx0LmV4cGlyYXRpb25EYXRlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoaW5wdXQuaXNzdWVyICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGlucHV0KS5pbmRleE9mKCdpc3MnKSA9PT0gLTEpIHtcbiAgICBpZiAodHlwZW9mIGlucHV0Lmlzc3VlciA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHJlc3VsdC5pc3MgPSBpbnB1dC5pc3N1ZXI/LmlkO1xuICAgICAgaWYgKHJlbW92ZU9yaWdpbmFsRmllbGRzKSB7XG4gICAgICAgIGRlbGV0ZSByZXN1bHQuaXNzdWVyLmlkO1xuICAgICAgICBpZiAoT2JqZWN0LmtleXMocmVzdWx0Lmlzc3VlcikubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgZGVsZXRlIHJlc3VsdC5pc3N1ZXI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBpbnB1dC5pc3N1ZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXN1bHQuaXNzID0gaW5wdXQuaXNzIHx8ICcnICsgaW5wdXQuaXNzdWVyO1xuICAgICAgaWYgKHJlbW92ZU9yaWdpbmFsRmllbGRzKSB7XG4gICAgICAgIGRlbGV0ZSByZXN1bHQuaXNzdWVyO1xuICAgICAgfVxuICAgIH0gZWxzZSA7XG4gIH1cbiAgcmVzdWx0LnZjLmNyZWRlbnRpYWxTdWJqZWN0ID0gY3JlZGVudGlhbFN1YmplY3Q7XG4gIGlmIChyZW1vdmVPcmlnaW5hbEZpZWxkcykge1xuICAgIGRlbGV0ZSByZXN1bHQuY3JlZGVudGlhbFN1YmplY3Q7XG4gIH1cbiAgZm9yIChjb25zdCBwcm9wIG9mIGFkZGl0aW9uYWxQcm9wTmFtZXMpIHtcbiAgICBpZiAoaW5wdXRbcHJvcF0pIHtcbiAgICAgIGlmICghcmVzdWx0LnZjW3Byb3BdKSB7XG4gICAgICAgIHJlc3VsdC52Y1twcm9wXSA9IGlucHV0W3Byb3BdO1xuICAgICAgfVxuICAgICAgaWYgKHJlbW92ZU9yaWdpbmFsRmllbGRzKSB7XG4gICAgICAgIGRlbGV0ZSByZXN1bHRbcHJvcF07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBub3JtYWxpemVKd3RQcmVzZW50YXRpb25QYXlsb2FkKGlucHV0LCByZW1vdmVPcmlnaW5hbEZpZWxkcyA9IHRydWUpIHtcbiAgY29uc3QgcmVzdWx0ID0gZGVlcENvcHkoaW5wdXQpO1xuICByZXN1bHQudmVyaWZpYWJsZUNyZWRlbnRpYWwgPSBbLi4uYXNBcnJheShpbnB1dC52ZXJpZmlhYmxlQ3JlZGVudGlhbCksIC4uLmFzQXJyYXkoaW5wdXQudnA/LnZlcmlmaWFibGVDcmVkZW50aWFsKV0uZmlsdGVyKG5vdEVtcHR5KTtcbiAgcmVzdWx0LnZlcmlmaWFibGVDcmVkZW50aWFsID0gcmVzdWx0LnZlcmlmaWFibGVDcmVkZW50aWFsLm1hcChjcmVkID0+IHtcbiAgICByZXR1cm4gbm9ybWFsaXplQ3JlZGVudGlhbChjcmVkLCByZW1vdmVPcmlnaW5hbEZpZWxkcyk7XG4gIH0pO1xuICBpZiAocmVtb3ZlT3JpZ2luYWxGaWVsZHMpIHtcbiAgICBkZWxldGUgcmVzdWx0LnZwPy52ZXJpZmlhYmxlQ3JlZGVudGlhbDtcbiAgfVxuICBpZiAoaW5wdXQuaXNzICYmICFpbnB1dC5ob2xkZXIpIHtcbiAgICByZXN1bHQuaG9sZGVyID0gaW5wdXQuaXNzO1xuICAgIGlmIChyZW1vdmVPcmlnaW5hbEZpZWxkcykge1xuICAgICAgZGVsZXRlIHJlc3VsdC5pc3M7XG4gICAgfVxuICB9XG4gIGlmIChpbnB1dC5hdWQpIHtcbiAgICByZXN1bHQudmVyaWZpZXIgPSBbLi4uYXNBcnJheShpbnB1dC52ZXJpZmllciksIC4uLmFzQXJyYXkoaW5wdXQuYXVkKV0uZmlsdGVyKG5vdEVtcHR5KTtcbiAgICByZXN1bHQudmVyaWZpZXIgPSBbLi4ubmV3IFNldChyZXN1bHQudmVyaWZpZXIpXTtcbiAgICBpZiAocmVtb3ZlT3JpZ2luYWxGaWVsZHMpIHtcbiAgICAgIGRlbGV0ZSByZXN1bHQuYXVkO1xuICAgIH1cbiAgfVxuICBpZiAoaW5wdXQuanRpICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGlucHV0KS5pbmRleE9mKCdpZCcpID09PSAtMSkge1xuICAgIHJlc3VsdC5pZCA9IGlucHV0LmlkIHx8IGlucHV0Lmp0aTtcbiAgICBpZiAocmVtb3ZlT3JpZ2luYWxGaWVsZHMpIHtcbiAgICAgIGRlbGV0ZSByZXN1bHQuanRpO1xuICAgIH1cbiAgfVxuICBjb25zdCB0eXBlcyA9IFsuLi5hc0FycmF5KGlucHV0LnR5cGUpLCAuLi5hc0FycmF5KGlucHV0LnZwPy50eXBlKV0uZmlsdGVyKG5vdEVtcHR5KTtcbiAgcmVzdWx0LnR5cGUgPSBbLi4ubmV3IFNldCh0eXBlcyldO1xuICBpZiAocmVtb3ZlT3JpZ2luYWxGaWVsZHMpIHtcbiAgICBkZWxldGUgcmVzdWx0LnZwPy50eXBlO1xuICB9XG4gIGNvbnN0IGNvbnRleHRzID0gWy4uLmFzQXJyYXkoaW5wdXQuY29udGV4dCksIC4uLmFzQXJyYXkoaW5wdXRbJ0Bjb250ZXh0J10pLCAuLi5hc0FycmF5KGlucHV0LnZwPy5bJ0Bjb250ZXh0J10pXS5maWx0ZXIobm90RW1wdHkpO1xuICByZXN1bHRbJ0Bjb250ZXh0J10gPSBbLi4ubmV3IFNldChjb250ZXh0cyldO1xuICBpZiAocmVtb3ZlT3JpZ2luYWxGaWVsZHMpIHtcbiAgICBkZWxldGUgcmVzdWx0LmNvbnRleHQ7XG4gICAgZGVsZXRlIHJlc3VsdC52cD8uWydAY29udGV4dCddO1xuICB9XG4gIGlmICghaW5wdXQuaXNzdWFuY2VEYXRlICYmIChpbnB1dC5pYXQgfHwgaW5wdXQubmJmKSkge1xuICAgIHJlc3VsdC5pc3N1YW5jZURhdGUgPSBuZXcgRGF0ZSgoaW5wdXQubmJmIHx8IGlucHV0LmlhdCkgKiAxMDAwKS50b0lTT1N0cmluZygpO1xuICAgIGlmIChyZW1vdmVPcmlnaW5hbEZpZWxkcykge1xuICAgICAgaWYgKGlucHV0Lm5iZikge1xuICAgICAgICBkZWxldGUgcmVzdWx0Lm5iZjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbGV0ZSByZXN1bHQuaWF0O1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoIWlucHV0LmV4cGlyYXRpb25EYXRlICYmIGlucHV0LmV4cCkge1xuICAgIHJlc3VsdC5leHBpcmF0aW9uRGF0ZSA9IG5ldyBEYXRlKGlucHV0LmV4cCAqIDEwMDApLnRvSVNPU3RyaW5nKCk7XG4gICAgaWYgKHJlbW92ZU9yaWdpbmFsRmllbGRzKSB7XG4gICAgICBkZWxldGUgcmVzdWx0LmV4cDtcbiAgICB9XG4gIH1cbiAgaWYgKHJlc3VsdC52cCAmJiBPYmplY3Qua2V5cyhyZXN1bHQudnApLmxlbmd0aCA9PT0gMCkge1xuICAgIGlmIChyZW1vdmVPcmlnaW5hbEZpZWxkcykge1xuICAgICAgZGVsZXRlIHJlc3VsdC52cDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZUp3dFByZXNlbnRhdGlvbihpbnB1dCwgcmVtb3ZlT3JpZ2luYWxGaWVsZHMgPSB0cnVlKSB7XG4gIGxldCBkZWNvZGVkO1xuICB0cnkge1xuICAgIGRlY29kZWQgPSBkZWNvZGVKV1QoaW5wdXQpO1xuICB9IGNhdGNoIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd1bmtub3duIHByZXNlbnRhdGlvbiBmb3JtYXQnKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIC4uLm5vcm1hbGl6ZUp3dFByZXNlbnRhdGlvblBheWxvYWQoZGVjb2RlZC5wYXlsb2FkLCByZW1vdmVPcmlnaW5hbEZpZWxkcyksXG4gICAgcHJvb2Y6IHtcbiAgICAgIHR5cGU6IERFRkFVTFRfSldUX1BST09GX1RZUEUsXG4gICAgICBqd3Q6IGlucHV0XG4gICAgfVxuICB9O1xufVxuLyoqXG4gKiBOb3JtYWxpemVzIGEgcHJlc2VudGF0aW9uIHBheWxvYWQgaW50byBhbiB1bmFtYmlndW91cyBXM0MgUHJlc2VudGF0aW9uIGRhdGEgdHlwZS5cbiAqXG4gKiBAc2VlIHtAbGluayBodHRwczovL3d3dy53My5vcmcvVFIvdmMtZGF0YS1tb2RlbC8jand0LWVuY29kaW5nIHwgVlAgSldUIGVuY29kaW5nIH1cbiAqXG4gKiBAcGFyYW0gaW5wdXQgLSBlaXRoZXIgYSBKV1Qgb3IgSldUIHBheWxvYWQsIG9yIGEgVmVyaWZpYWJsZVByZXNlbnRhdGlvblxuICogQHBhcmFtIHJlbW92ZU9yaWdpbmFsRmllbGRzIC0gaWYgdHJ1ZSwgcmVtb3ZlcyBhbGwgZmllbGRzIHRoYXQgd2VyZSB0cmFuc2Zvcm1lZCBhY2NvcmRpbmcgdG8gdGhlIFczQyBtYXBwaW5nXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZVByZXNlbnRhdGlvbihpbnB1dCwgcmVtb3ZlT3JpZ2luYWxGaWVsZHMgPSB0cnVlKSB7XG4gIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKEpXVF9GT1JNQVQudGVzdChpbnB1dCkpIHtcbiAgICAgIHJldHVybiBub3JtYWxpemVKd3RQcmVzZW50YXRpb24oaW5wdXQsIHJlbW92ZU9yaWdpbmFsRmllbGRzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IHBhcnNlZDtcbiAgICAgIHRyeSB7XG4gICAgICAgIHBhcnNlZCA9IEpTT04ucGFyc2UoaW5wdXQpO1xuICAgICAgfSBjYXRjaCB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3Vua25vd24gcHJlc2VudGF0aW9uIGZvcm1hdCcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5vcm1hbGl6ZVByZXNlbnRhdGlvbihwYXJzZWQsIHJlbW92ZU9yaWdpbmFsRmllbGRzKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaW5wdXQucHJvb2Y/Lmp3dCkge1xuICAgIC8vIFRPRE86IHRlc3QgdGhhdCBpdCBjb3JyZWN0bHkgcHJvcGFnYXRlcyBhcHAgc3BlY2lmaWMgcHJvb2YgcHJvcGVydGllc1xuICAgIHJldHVybiB7XG4gICAgICAuLi5ub3JtYWxpemVKd3RQcmVzZW50YXRpb24oaW5wdXQucHJvb2Yuand0LCByZW1vdmVPcmlnaW5hbEZpZWxkcyksXG4gICAgICBwcm9vZjogaW5wdXQucHJvb2ZcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIC8vIFRPRE86IHRlc3QgdGhhdCBpdCBhY2NlcHRzIEpXVCBwYXlsb2FkLCBQcmVzZW50YXRpb25QYXlsb2FkLCBWZXJpZmlhYmxlUHJlc2VudGF0aW9uXG4gICAgLy8gVE9ETzogdGVzdCB0aGF0IGl0IGNvcnJlY3RseSBwcm9wYWdhdGVzIHByb29mLCBpZiBhbnlcbiAgICByZXR1cm4ge1xuICAgICAgcHJvb2Y6IHt9LFxuICAgICAgLi4ubm9ybWFsaXplSnd0UHJlc2VudGF0aW9uUGF5bG9hZChpbnB1dCwgcmVtb3ZlT3JpZ2luYWxGaWVsZHMpXG4gICAgfTtcbiAgfVxufVxuLyoqXG4gKiBUcmFuc2Zvcm1zIGEgVzNDIFByZXNlbnRhdGlvbiBwYXlsb2FkIGludG8gYSBKV1QgY29tcGF0aWJsZSBlbmNvZGluZy5cbiAqIFRoZSBtZXRob2QgYWNjZXB0cyBhcHAgc3BlY2lmaWMgZmllbGRzIGFuZCBpbiBjYXNlIG9mIGNvbGxpc2lvbiwgZXhpc3RpbmcgSldUIHByb3BlcnRpZXMgd2lsbCB0YWtlIHByZWNlZGVuY2UuXG4gKiBBbHNvLCBgbmJmYCwgYGV4cGAgYW5kIGBqdGlgIHByb3BlcnRpZXMgY2FuIGJlIGV4cGxpY2l0bHkgc2V0IHRvIGB1bmRlZmluZWRgIGFuZCB0aGV5IHdpbGwgYmUga2VwdCBpbnRhY3QuXG4gKiBAcGFyYW0gaW5wdXQgLSBlaXRoZXIgYSBKV1QgcGF5bG9hZCBvciBhIENyZWRlbnRpYWxQYXlsb2FkSW5wdXRcbiAqIEBwYXJhbSByZW1vdmVPcmlnaW5hbEZpZWxkcyAtIHdoZW4gdHJ1ZSwgcmVtb3ZlcyB0aGUgb3JpZ2luYWwgVzNDIGZpZWxkcyBmcm9tIHRoZSByZXN1bHRpbmcgb2JqZWN0XG4gKlxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly93d3cudzMub3JnL1RSL3ZjLWRhdGEtbW9kZWwvI2p3dC1lbmNvZGluZyB8IFZQIEpXVCBlbmNvZGluZyB9XG4gKi9cbmZ1bmN0aW9uIHRyYW5zZm9ybVByZXNlbnRhdGlvbklucHV0KGlucHV0LCByZW1vdmVPcmlnaW5hbEZpZWxkcyA9IHRydWUpIHtcbiAgY29uc3QgcmVzdWx0ID0gZGVlcENvcHkoe1xuICAgIHZwOiB7XG4gICAgICAuLi5pbnB1dC52cFxuICAgIH0sXG4gICAgLi4uaW5wdXRcbiAgfSk7XG4gIHJlc3VsdC52cCA9IHJlc3VsdC52cDtcbiAgY29uc3QgY29udGV4dEVudHJpZXMgPSBbLi4uYXNBcnJheShpbnB1dC5jb250ZXh0KSwgLi4uYXNBcnJheShpbnB1dFsnQGNvbnRleHQnXSksIC4uLmFzQXJyYXkoaW5wdXQudnA/LlsnQGNvbnRleHQnXSldLmZpbHRlcihub3RFbXB0eSk7XG4gIHJlc3VsdC52cFsnQGNvbnRleHQnXSA9IFsuLi5uZXcgU2V0KGNvbnRleHRFbnRyaWVzKV07XG4gIGlmIChyZW1vdmVPcmlnaW5hbEZpZWxkcykge1xuICAgIGRlbGV0ZSByZXN1bHQuY29udGV4dDtcbiAgICBkZWxldGUgcmVzdWx0WydAY29udGV4dCddO1xuICB9XG4gIGNvbnN0IHR5cGVzID0gWy4uLmFzQXJyYXkoaW5wdXQudHlwZSksIC4uLmFzQXJyYXkoaW5wdXQudnA/LnR5cGUpXS5maWx0ZXIobm90RW1wdHkpO1xuICByZXN1bHQudnAudHlwZSA9IFsuLi5uZXcgU2V0KHR5cGVzKV07XG4gIGlmIChyZW1vdmVPcmlnaW5hbEZpZWxkcykge1xuICAgIGRlbGV0ZSByZXN1bHQudHlwZTtcbiAgfVxuICBpZiAoaW5wdXQuaWQgJiYgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoaW5wdXQpLmluZGV4T2YoJ2p0aScpID09PSAtMSkge1xuICAgIHJlc3VsdC5qdGkgPSBpbnB1dC5pZDtcbiAgICBpZiAocmVtb3ZlT3JpZ2luYWxGaWVsZHMpIHtcbiAgICAgIGRlbGV0ZSByZXN1bHQuaWQ7XG4gICAgfVxuICB9XG4gIGlmIChpbnB1dC5pc3N1YW5jZURhdGUgJiYgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoaW5wdXQpLmluZGV4T2YoJ25iZicpID09PSAtMSkge1xuICAgIGNvbnN0IGNvbnZlcnRlZCA9IERhdGUucGFyc2UoaW5wdXQuaXNzdWFuY2VEYXRlKTtcbiAgICBpZiAoIWlzTmFOKGNvbnZlcnRlZCkpIHtcbiAgICAgIHJlc3VsdC5uYmYgPSBNYXRoLmZsb29yKGNvbnZlcnRlZCAvIDEwMDApO1xuICAgICAgaWYgKHJlbW92ZU9yaWdpbmFsRmllbGRzKSB7XG4gICAgICAgIGRlbGV0ZSByZXN1bHQuaXNzdWFuY2VEYXRlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoaW5wdXQuZXhwaXJhdGlvbkRhdGUgJiYgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoaW5wdXQpLmluZGV4T2YoJ2V4cCcpID09PSAtMSkge1xuICAgIGNvbnN0IGNvbnZlcnRlZCA9IERhdGUucGFyc2UoaW5wdXQuZXhwaXJhdGlvbkRhdGUpO1xuICAgIGlmICghaXNOYU4oY29udmVydGVkKSkge1xuICAgICAgcmVzdWx0LmV4cCA9IE1hdGguZmxvb3IoY29udmVydGVkIC8gMTAwMCk7XG4gICAgICBpZiAocmVtb3ZlT3JpZ2luYWxGaWVsZHMpIHtcbiAgICAgICAgZGVsZXRlIHJlc3VsdC5leHBpcmF0aW9uRGF0ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKHJlc3VsdC52ZXJpZmlhYmxlQ3JlZGVudGlhbCB8fCByZXN1bHQudnA/LnZlcmlmaWFibGVDcmVkZW50aWFsKSB7XG4gICAgcmVzdWx0LnZwLnZlcmlmaWFibGVDcmVkZW50aWFsID0gWy4uLmFzQXJyYXkocmVzdWx0LnZlcmlmaWFibGVDcmVkZW50aWFsKSwgLi4uYXNBcnJheShyZXN1bHQudnA/LnZlcmlmaWFibGVDcmVkZW50aWFsKV0uZmlsdGVyKG5vdEVtcHR5KS5tYXAoY3JlZGVudGlhbCA9PiB7XG4gICAgICBpZiAodHlwZW9mIGNyZWRlbnRpYWwgPT09ICdvYmplY3QnICYmIGNyZWRlbnRpYWwucHJvb2Y/Lmp3dCkge1xuICAgICAgICByZXR1cm4gY3JlZGVudGlhbC5wcm9vZi5qd3Q7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gY3JlZGVudGlhbDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBpZiAocmVtb3ZlT3JpZ2luYWxGaWVsZHMpIHtcbiAgICBkZWxldGUgcmVzdWx0LnZlcmlmaWFibGVDcmVkZW50aWFsO1xuICB9XG4gIGlmIChpbnB1dC5ob2xkZXIgJiYgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoaW5wdXQpLmluZGV4T2YoJ2lzcycpID09PSAtMSkge1xuICAgIGlmICh0eXBlb2YgaW5wdXQuaG9sZGVyID09PSAnc3RyaW5nJykge1xuICAgICAgcmVzdWx0LmlzcyA9IGlucHV0LmhvbGRlcjtcbiAgICAgIGlmIChyZW1vdmVPcmlnaW5hbEZpZWxkcykge1xuICAgICAgICBkZWxldGUgcmVzdWx0LmhvbGRlcjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKGlucHV0LnZlcmlmaWVyKSB7XG4gICAgY29uc3QgYXVkaWVuY2UgPSBbLi4uYXNBcnJheShpbnB1dC52ZXJpZmllciksIC4uLmFzQXJyYXkoaW5wdXQuYXVkKV0uZmlsdGVyKG5vdEVtcHR5KTtcbiAgICByZXN1bHQuYXVkID0gWy4uLm5ldyBTZXQoYXVkaWVuY2UpXTtcbiAgICBpZiAocmVtb3ZlT3JpZ2luYWxGaWVsZHMpIHtcbiAgICAgIGRlbGV0ZSByZXN1bHQudmVyaWZpZXI7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogRXJyb3IgcHJlZml4ZXMgdXNlZCBmb3Iga25vd24gdmVyaWZpY2F0aW9uIGZhaWx1cmUgY2FzZXMgcmVsYXRlZCB0byB0aGVcbiAqIHtAbGluayBodHRwczovL3d3dy53My5vcmcvVFIvdmMtZGF0YS1tb2RlbC8gfCBWZXJpZmlhYmxlIENyZWRlbnRpYWwgZGF0YSBtb2RlbCB9XG4gKi9cbmNvbnN0IFZDX0VSUk9SID0ge1xuICAvKipcbiAgICogVGhyb3duIHdoZW4gdGhlIGNyZWRlbnRpYWwgb3IgcHJlc2VudGF0aW9uIGJlaW5nIHZlcmlmaWVkIGRvZXMgbm90IGNvbmZvcm0gdG8gdGhlIGRhdGEgbW9kZWwgZGVmaW5lZCBieVxuICAgKiB7QGxpbmsgaHR0cHM6Ly93d3cudzMub3JnL1RSL3ZjLWRhdGEtbW9kZWwvIHwgdGhlIHNwZWN9XG4gICAqL1xuICBTQ0hFTUFfRVJST1I6ICdzY2hlbWFfZXJyb3InLFxuICAvKipcbiAgICogVGhyb3duIHdoZW4gdGhlIGlucHV0IGlzIG5vdCBhIEpXVCBzdHJpbmdcbiAgICovXG4gIEZPUk1BVF9FUlJPUjogJ2Zvcm1hdF9lcnJvcicsXG4gIC8qKlxuICAgKiBUaHJvd24gd2hlbiB2ZXJpZnlpbmcgYSBwcmVzZW50YXRpb24gd2hlcmUgYGNoYWxsZW5nZWAgYW5kL29yIGBkb21haW5gIGRvbid0IG1hdGNoIHRoZSBleHBlY3RlZCB2YWx1ZXMuXG4gICAqL1xuICBBVVRIX0VSUk9SOiAnYXV0aF9lcnJvcidcbn07XG4vKipcbiAqIEtub3duIHZhbGlkYXRpb24gb3IgdmVyaWZpY2F0aW9uIGVycm9yIHByZWZpeGVzLlxuICovXG5jb25zdCBWQ19KV1RfRVJST1IgPSB7XG4gIC4uLlZDX0VSUk9SLFxuICAuLi5KV1RfRVJST1Jcbn07XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuZnVuY3Rpb24gaXNEYXRlT2JqZWN0KGlucHV0KSB7XG4gIHJldHVybiBpbnB1dCAmJiAhaXNOYU4oaW5wdXQpICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpbnB1dCkgPT09ICdbb2JqZWN0IERhdGVdJztcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlSnd0Rm9ybWF0KHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmICF2YWx1ZS5tYXRjaChKV1RfRk9STUFUKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYCR7VkNfRVJST1IuRk9STUFUX0VSUk9SfTogXCIke3ZhbHVlfVwiIGlzIG5vdCBhIHZhbGlkIEpXVCBmb3JtYXRgKTtcbiAgfVxufVxuLy8gVGhlIG1haW4gc2NlbmFyaW8gd2Ugd2FudCB0byBndWFyZCBhZ2FpbnN0IGlzIGhhdmluZyBhIHRpbWVzdGFtcCBpbiBtaWxsaXNlY29uZHNcbi8vIGluc3RlYWQgb2Ygc2Vjb25kcyAoZXg6IGZyb20gbmV3IERhdGUoKS5nZXRUaW1lKCkpLlxuLy8gV2Ugd2lsbCBjaGVjayB0aGUgbnVtYmVyIG9mIGRpZ2l0cyBhbmQgYXNzdW1lIHRoYXQgYW55IG51bWJlciB3aXRoIDEyIG9yIG1vcmVcbi8vIGRpZ2l0cyBpcyBhIG1pbGxpc2Vjb25kIHRpbWVzdGFtcC5cbi8vIDEwIGRpZ2l0cyBtYXggaXMgOTk5OTk5OTk5OSAtPiAxMS8yMC8yMjg2IEAgNTo0NnBtIChVVEMpXG4vLyAxMSBkaWdpdHMgbWF4IGlzIDk5OTk5OTk5OTk5IC0+IDExLzE2LzUxMzggQCA5OjQ2YW0gKFVUQylcbi8vIDEyIGRpZ2l0cyBtYXggaXMgOTk5OTk5OTk5OTk5IC0+IDA5LzI3LzMzNjU4IEAgMTo0NmFtIChVVEMpXG5mdW5jdGlvbiB2YWxpZGF0ZVRpbWVzdGFtcCh2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIGlmICghKE51bWJlci5pc0ludGVnZXIodmFsdWUpICYmIHZhbHVlIDwgMTAwMDAwMDAwMDAwKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgJHtWQ19FUlJPUi5TQ0hFTUFfRVJST1J9OiBcIiR7dmFsdWV9XCIgaXMgbm90IGEgdW5peCB0aW1lc3RhbXAgaW4gc2Vjb25kc2ApO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFsaWRhdGVUaW1lc3RhbXAoTWF0aC5mbG9vcihuZXcgRGF0ZSh2YWx1ZSkudmFsdWVPZigpIC8gMTAwMCkpO1xuICB9IGVsc2UgaWYgKCFpc0RhdGVPYmplY3QodmFsdWUpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgJHtWQ19FUlJPUi5TQ0hFTUFfRVJST1J9OiBcIiR7dmFsdWV9XCIgaXMgbm90IGEgdmFsaWQgdGltZWApO1xuICB9XG59XG5mdW5jdGlvbiB2YWxpZGF0ZUNvbnRleHQodmFsdWUpIHtcbiAgY29uc3QgaW5wdXQgPSBhc0FycmF5KHZhbHVlKTtcbiAgaWYgKGlucHV0Lmxlbmd0aCA8IDEgfHwgaW5wdXQuaW5kZXhPZihERUZBVUxUX0NPTlRFWFQpID09PSAtMSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYCR7VkNfRVJST1IuU0NIRU1BX0VSUk9SfTogQGNvbnRleHQgaXMgbWlzc2luZyBkZWZhdWx0IGNvbnRleHQgXCIke0RFRkFVTFRfQ09OVEVYVH1cImApO1xuICB9XG59XG5mdW5jdGlvbiB2YWxpZGF0ZVZjVHlwZSh2YWx1ZSkge1xuICBjb25zdCBpbnB1dCA9IGFzQXJyYXkodmFsdWUpO1xuICBpZiAoaW5wdXQubGVuZ3RoIDwgMSB8fCBpbnB1dC5pbmRleE9mKERFRkFVTFRfVkNfVFlQRSkgPT09IC0xKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgJHtWQ19FUlJPUi5TQ0hFTUFfRVJST1J9OiB0eXBlIGlzIG1pc3NpbmcgZGVmYXVsdCBcIiR7REVGQVVMVF9WQ19UWVBFfVwiYCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHZhbGlkYXRlVnBUeXBlKHZhbHVlKSB7XG4gIGNvbnN0IGlucHV0ID0gYXNBcnJheSh2YWx1ZSk7XG4gIGlmIChpbnB1dC5sZW5ndGggPCAxIHx8IGlucHV0LmluZGV4T2YoREVGQVVMVF9WUF9UWVBFKSA9PT0gLTEpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGAke1ZDX0VSUk9SLlNDSEVNQV9FUlJPUn06IHR5cGUgaXMgbWlzc2luZyBkZWZhdWx0IFwiJHtERUZBVUxUX1ZQX1RZUEV9XCJgKTtcbiAgfVxufVxuZnVuY3Rpb24gdmFsaWRhdGVDcmVkZW50aWFsU3ViamVjdCh2YWx1ZSkge1xuICBpZiAoT2JqZWN0LmtleXModmFsdWUpLmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYCR7VkNfRVJST1IuU0NIRU1BX0VSUk9SfTogY3JlZGVudGlhbFN1YmplY3QgbXVzdCBub3QgYmUgZW1wdHlgKTtcbiAgfVxufVxuXG4vKipcbiAqIFZlcmlmaWVzIGFuZCB2YWxpZGF0ZXMgYSBWZXJpZmlhYmxlUHJlc2VudGF0aW9uIHRoYXQgaXMgZW5jb2RlZCBhcyBhIEpXVCBhY2NvcmRpbmcgdG8gdGhlIFczQyBzcGVjLlxuICpcbiAqIEByZXR1cm4gYSBgUHJvbWlzZWAgdGhhdCByZXNvbHZlcyB0byBhIGBWZXJpZmllZFByZXNlbnRhdGlvbmAgb3IgcmVqZWN0cyB3aXRoIGBUeXBlRXJyb3JgIGlmIHRoZSBpbnB1dCBpc1xuICogbm90IFczQyBjb21wbGlhbnQgb3IgdGhlIFZlcmlmeVByZXNlbnRhdGlvbk9wdGlvbnMgYXJlIG5vdCBzYXRpc2ZpZWQuXG4gKiBAcGFyYW0gcHJlc2VudGF0aW9uIC0gdGhlIHByZXNlbnRhdGlvbiB0byBiZSB2ZXJpZmllZC4gQ3VycmVudGx5IG9ubHkgdGhlIEpXVCBlbmNvZGluZyBpcyBzdXBwb3J0ZWQgYnkgdGhpcyBsaWJyYXJ5XG4gKiBAcGFyYW0gcmVzb2x2ZXIgLSBhIGNvbmZpZ3VyZWQgYFJlc29sdmVyYCBvciBhbiBpbXBsZW1lbnRhdGlvbiBvZiBgUmVzb2x2YWJsZWAgdGhhdCBjYW4gcHJvdmlkZSB0aGUgRElEIGRvY3VtZW50IG9mXG4gKiAgIHRoZSBKV1QgaXNzdWVyIChwcmVzZW50YXRpb24gaG9sZGVyKVxuICogQHBhcmFtIG9wdGlvbnMgLSBvcHRpb25hbCB2ZXJpZmljYXRpb24gb3B0aW9ucyB0aGF0IG5lZWQgdG8gYmUgc2F0aXNmaWVkLiBUaGVzZSBhcmUgYWxzbyBmb3J3YXJkZWQgdG8gZGlkLWp3dC5cbiAqL1xuY29uc3QgdmVyaWZ5UHJlc2VudGF0aW9uID0gZnVuY3Rpb24gKHByZXNlbnRhdGlvbiwgcmVzb2x2ZXIsIG9wdGlvbnMgPSB7fSkge1xuICB0cnkge1xuICAgIGNvbnN0IG5iZiA9IG9wdGlvbnM/LnBvbGljaWVzPy5pc3N1YW5jZURhdGUgPT09IGZhbHNlID8gZmFsc2UgOiB1bmRlZmluZWQ7XG4gICAgY29uc3QgZXhwID0gb3B0aW9ucz8ucG9saWNpZXM/LmV4cGlyYXRpb25EYXRlID09PSBmYWxzZSA/IGZhbHNlIDogdW5kZWZpbmVkO1xuICAgIG9wdGlvbnMgPSB7XG4gICAgICBhdWRpZW5jZTogb3B0aW9ucy5kb21haW4sXG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgcG9saWNpZXM6IHtcbiAgICAgICAgLi4ub3B0aW9ucz8ucG9saWNpZXMsXG4gICAgICAgIG5iZixcbiAgICAgICAgZXhwLFxuICAgICAgICBpYXQ6IG5iZlxuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2ZXJpZnlKV1QocHJlc2VudGF0aW9uLCB7XG4gICAgICByZXNvbHZlcixcbiAgICAgIC4uLm9wdGlvbnNcbiAgICB9KSkudGhlbihmdW5jdGlvbiAodmVyaWZpZWQpIHtcbiAgICAgIHZlcmlmeVByZXNlbnRhdGlvblBheWxvYWRPcHRpb25zKHZlcmlmaWVkLnBheWxvYWQsIG9wdGlvbnMpO1xuICAgICAgdmVyaWZpZWQudmVyaWZpYWJsZVByZXNlbnRhdGlvbiA9IG5vcm1hbGl6ZVByZXNlbnRhdGlvbih2ZXJpZmllZC5qd3QsIG9wdGlvbnM/LnJlbW92ZU9yaWdpbmFsRmllbGRzKTtcbiAgICAgIGlmIChvcHRpb25zPy5wb2xpY2llcz8uZm9ybWF0ICE9PSBmYWxzZSkge1xuICAgICAgICB2YWxpZGF0ZVByZXNlbnRhdGlvblBheWxvYWQodmVyaWZpZWQudmVyaWZpYWJsZVByZXNlbnRhdGlvbik7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmVyaWZpZWQ7XG4gICAgfSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZSk7XG4gIH1cbn07XG4vKipcbiAqIFZlcmlmaWVzIGFuZCB2YWxpZGF0ZXMgYSBWZXJpZmlhYmxlQ3JlZGVudGlhbCB0aGF0IGlzIGVuY29kZWQgYXMgYSBKV1QgYWNjb3JkaW5nIHRvIHRoZSBXM0Mgc3BlYy5cbiAqXG4gKiBAcmV0dXJuIGEgYFByb21pc2VgIHRoYXQgcmVzb2x2ZXMgdG8gYSBgVmVyaWZpZWRDcmVkZW50aWFsYCBvciByZWplY3RzIHdpdGggYFR5cGVFcnJvcmAgaWYgdGhlIGlucHV0IGlzIG5vdFxuICogVzNDIGNvbXBsaWFudFxuICogQHBhcmFtIHZjIC0gdGhlIGNyZWRlbnRpYWwgdG8gYmUgdmVyaWZpZWQuIEN1cnJlbnRseSBvbmx5IHRoZSBKV1QgZW5jb2RpbmcgaXMgc3VwcG9ydGVkIGJ5IHRoaXMgbGlicmFyeVxuICogQHBhcmFtIHJlc29sdmVyIC0gYSBjb25maWd1cmVkIGBSZXNvbHZlcmAgKG9yIGFuIGltcGxlbWVudGF0aW9uIG9mIGBSZXNvbHZhYmxlYCkgdGhhdCBjYW4gcHJvdmlkZSB0aGUgRElEIGRvY3VtZW50XG4gKiAgIG9mIHRoZSBKV1QgaXNzdWVyXG4gKiBAcGFyYW0gb3B0aW9ucyAtIG9wdGlvbmFsIHR3ZWFrcyB0byB0aGUgdmVyaWZpY2F0aW9uIHByb2Nlc3MuIFRoZXNlIGFyZSBmb3J3YXJkZWQgdG8gZGlkLWp3dC5cbiAqL1xuY29uc3QgdmVyaWZ5Q3JlZGVudGlhbCA9IGZ1bmN0aW9uICh2YywgcmVzb2x2ZXIsIG9wdGlvbnMgPSB7fSkge1xuICB0cnkge1xuICAgIGNvbnN0IG5iZiA9IG9wdGlvbnM/LnBvbGljaWVzPy5pc3N1YW5jZURhdGUgPT09IGZhbHNlID8gZmFsc2UgOiB1bmRlZmluZWQ7XG4gICAgY29uc3QgZXhwID0gb3B0aW9ucz8ucG9saWNpZXM/LmV4cGlyYXRpb25EYXRlID09PSBmYWxzZSA/IGZhbHNlIDogdW5kZWZpbmVkO1xuICAgIG9wdGlvbnMgPSB7XG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgcG9saWNpZXM6IHtcbiAgICAgICAgLi4ub3B0aW9ucz8ucG9saWNpZXMsXG4gICAgICAgIG5iZixcbiAgICAgICAgZXhwLFxuICAgICAgICBpYXQ6IG5iZlxuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2ZXJpZnlKV1QodmMsIHtcbiAgICAgIHJlc29sdmVyLFxuICAgICAgLi4ub3B0aW9uc1xuICAgIH0pKS50aGVuKGZ1bmN0aW9uICh2ZXJpZmllZCkge1xuICAgICAgdmVyaWZpZWQudmVyaWZpYWJsZUNyZWRlbnRpYWwgPSBub3JtYWxpemVDcmVkZW50aWFsKHZlcmlmaWVkLmp3dCwgb3B0aW9ucz8ucmVtb3ZlT3JpZ2luYWxGaWVsZHMpO1xuICAgICAgaWYgKG9wdGlvbnM/LnBvbGljaWVzPy5mb3JtYXQgIT09IGZhbHNlKSB7XG4gICAgICAgIHZhbGlkYXRlQ3JlZGVudGlhbFBheWxvYWQodmVyaWZpZWQudmVyaWZpYWJsZUNyZWRlbnRpYWwpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZlcmlmaWVkO1xuICAgIH0pO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGUpO1xuICB9XG59O1xuLyoqXG4gKiBWZXJpZmllcyB0aGF0IHRoZSBnaXZlbiBKd3RQcmVzZW50YXRpb25QYXlsb2FkIGNvbnRhaW5zIHRoZSBhcHByb3ByaWF0ZSBvcHRpb25zIGZyb20gVmVyaWZ5UHJlc2VudGF0aW9uT3B0aW9uc1xuICpcbiAqIEBwYXJhbSBwYXlsb2FkIC0gdGhlIEp3dFByZXNlbnRhdGlvblBheWxvYWQgdG8gdmVyaWZ5IGFnYWluc3RcbiAqIEBwYXJhbSBvcHRpb25zIC0gdGhlIFZlcmlmeVByZXNlbnRhdGlvbk9wdGlvbnMgdGhhdCBjb250YWluIHRoZSBvcHRpb25hbCB2YWx1ZXMgdG8gdmVyaWZ5LlxuICogQHRocm93cyB7RXJyb3J9IElmIFZlcmlmeVByZXNlbnRhdGlvbk9wdGlvbnMgYXJlIG5vdCBzYXRpc2ZpZWRcbiAqL1xuLyoqXG4gKiBDcmVhdGVzIGEgVmVyaWZpYWJsZVByZXNlbnRhdGlvbiBKV1QgZ2l2ZW4gYSBgUHJlc2VudGF0aW9uUGF5bG9hZGAgb3IgYEp3dFByZXNlbnRhdGlvblBheWxvYWRgIGFuZCBhbiBgSXNzdWVyYC5cbiAqXG4gKiBUaGlzIG1ldGhvZCB0cmFuc2Zvcm1zIHRoZSBwYXlsb2FkIGludG8gdGhlIFtKV1QgZW5jb2RpbmddKGh0dHBzOi8vd3d3LnczLm9yZy9UUi92Yy1kYXRhLW1vZGVsLyNqd3QtZW5jb2RpbmcpXG4gKiBkZXNjcmliZWQgaW4gdGhlIFtXM0MgVkMgc3BlY10oaHR0cHM6Ly93d3cudzMub3JnL1RSL3ZjLWRhdGEtbW9kZWwpIGFuZCB0aGVuIHZhbGlkYXRlZCB0byBjb25mb3JtIHRvIHRoZSBtaW5pbXVtXG4gKiBzcGVjXG4gKiByZXF1aXJlZCBzcGVjLlxuICpcbiAqIFRoZSBgaG9sZGVyYCBpcyB0aGVuIHVzZWQgdG8gYXNzaWduIGFuIGFsZ29yaXRobSwgb3ZlcnJpZGUgdGhlIGBpc3NgIGZpZWxkIG9mIHRoZSBwYXlsb2FkIGFuZCB0aGVuIHNpZ24gdGhlIEpXVC5cbiAqXG4gKiBAcGFyYW0gcGF5bG9hZCAtIGBQcmVzZW50YXRpb25QYXlsb2FkYCBvciBgSnd0UHJlc2VudGF0aW9uUGF5bG9hZGBcbiAqIEBwYXJhbSBob2xkZXIgLSBgSXNzdWVyYCBvZiB0aGUgUHJlc2VudGF0aW9uIEpXVCAoaG9sZGVyIG9mIHRoZSBWQyksIHNpZ25lciBhbmQgYWxnb3JpdGhtIHRoYXQgd2lsbCBzaWduIHRoZSB0b2tlblxuICogQHBhcmFtIG9wdGlvbnMgLSBgQ3JlYXRlUHJlc2VudGF0aW9uT3B0aW9uc2AgYWxsb3dzIHRvIHBhc3MgYWRkaXRpb25hbCB2YWx1ZXMgdG8gdGhlIHJlc3VsdGluZyBKV1QgcGF5bG9hZC4gVGhlc2VcbiAqICAgb3B0aW9ucyBhcmUgZm9yd2FyZGVkIHRvIGRpZC1qd3QuXG4gKiBAcmV0dXJuIGEgYFByb21pc2VgIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIEpXVCBlbmNvZGVkIHZlcmlmaWFibGUgcHJlc2VudGF0aW9uIG9yIHJlamVjdHMgd2l0aCBgVHlwZUVycm9yYCBpZiB0aGVcbiAqIGBwYXlsb2FkYCBpcyBub3QgVzNDIGNvbXBsaWFudFxuICovXG5jb25zdCBjcmVhdGVWZXJpZmlhYmxlUHJlc2VudGF0aW9uSnd0ID0gZnVuY3Rpb24gKHBheWxvYWQsIGhvbGRlciwgb3B0aW9ucyA9IHt9KSB7XG4gIHRyeSB7XG4gICAgY29uc3QgcGFyc2VkUGF5bG9hZCA9IHtcbiAgICAgIGlhdDogdW5kZWZpbmVkLFxuICAgICAgLi4udHJhbnNmb3JtUHJlc2VudGF0aW9uSW5wdXQocGF5bG9hZCwgb3B0aW9ucz8ucmVtb3ZlT3JpZ2luYWxGaWVsZHMpXG4gICAgfTtcbiAgICAvLyBhZGQgY2hhbGxlbmdlIHRvIG5vbmNlXG4gICAgaWYgKG9wdGlvbnMuY2hhbGxlbmdlICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHBhcnNlZFBheWxvYWQpLmluZGV4T2YoJ25vbmNlJykgPT09IC0xKSB7XG4gICAgICBwYXJzZWRQYXlsb2FkLm5vbmNlID0gb3B0aW9ucy5jaGFsbGVuZ2U7XG4gICAgfVxuICAgIC8vIGFkZCBkb21haW4gdG8gYXVkaWVuY2UuXG4gICAgaWYgKG9wdGlvbnMuZG9tYWluKSB7XG4gICAgICBjb25zdCBhdWRpZW5jZSA9IFsuLi5hc0FycmF5KG9wdGlvbnMuZG9tYWluKSwgLi4uYXNBcnJheShwYXJzZWRQYXlsb2FkLmF1ZCldLmZpbHRlcihub3RFbXB0eSk7XG4gICAgICBwYXJzZWRQYXlsb2FkLmF1ZCA9IFsuLi5uZXcgU2V0KGF1ZGllbmNlKV07XG4gICAgfVxuICAgIHZhbGlkYXRlSnd0UHJlc2VudGF0aW9uUGF5bG9hZChwYXJzZWRQYXlsb2FkKTtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGNyZWF0ZUpXVChwYXJzZWRQYXlsb2FkLCB7XG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgaXNzdWVyOiBob2xkZXIuZGlkIHx8IHBhcnNlZFBheWxvYWQuaXNzIHx8ICcnLFxuICAgICAgc2lnbmVyOiBob2xkZXIuc2lnbmVyXG4gICAgfSwge1xuICAgICAgLi4ub3B0aW9ucy5oZWFkZXIsXG4gICAgICBhbGc6IGhvbGRlci5hbGcgfHwgb3B0aW9ucy5oZWFkZXI/LmFsZyB8fCBKV1RfQUxHXG4gICAgfSkpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGUpO1xuICB9XG59O1xuLyoqXG4gKiBDcmVhdGVzIGEgVmVyaWZpYWJsZUNyZWRlbnRpYWwgZ2l2ZW4gYSBgQ3JlZGVudGlhbFBheWxvYWRgIG9yIGBKd3RDcmVkZW50aWFsUGF5bG9hZGAgYW5kIGFuIGBJc3N1ZXJgLlxuICpcbiAqIFRoaXMgbWV0aG9kIHRyYW5zZm9ybXMgdGhlIHBheWxvYWQgaW50byB0aGUgW0pXVCBlbmNvZGluZ10oaHR0cHM6Ly93d3cudzMub3JnL1RSL3ZjLWRhdGEtbW9kZWwvI2p3dC1lbmNvZGluZylcbiAqIGRlc2NyaWJlZCBpbiB0aGUgW1czQyBWQyBzcGVjXShodHRwczovL3d3dy53My5vcmcvVFIvdmMtZGF0YS1tb2RlbCkgYW5kIHRoZW4gdmFsaWRhdGVkIHRvIGNvbmZvcm0gdG8gdGhlIG1pbmltdW1cbiAqIHNwZWNcbiAqIHJlcXVpcmVkIHNwZWMuXG4gKlxuICogVGhlIGBpc3N1ZXJgIGlzIHRoZW4gdXNlZCB0byBhc3NpZ24gYW4gYWxnb3JpdGhtLCBvdmVycmlkZSB0aGUgYGlzc2AgZmllbGQgb2YgdGhlIHBheWxvYWQgYW5kIHRoZW4gc2lnbiB0aGUgSldULlxuICpcbiAqIEBwYXJhbSBwYXlsb2FkIC0gYENyZWRlbnRpYWxQYXlsb2FkYCBvciBgSnd0Q3JlZGVudGlhbFBheWxvYWRgXG4gKiBAcGFyYW0gaXNzdWVyIC0gYElzc3VlcmAgdGhlIERJRCwgc2lnbmVyIGFuZCBhbGdvcml0aG0gdGhhdCB3aWxsIHNpZ24gdGhlIHRva2VuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIFVzZSB0aGVzZSBvcHRpb25zIHRvIHR3ZWFrIHRoZSBjcmVhdGlvbiBvZiB0aGUgSldUIENyZWRlbnRpYWwuIFRoZXNlIGFyZSBmb3J3YXJkZWQgdG8gZGlkLWp3dC5cbiAqIEByZXR1cm4gYSBgUHJvbWlzZWAgdGhhdCByZXNvbHZlcyB0byB0aGUgSldUIGVuY29kZWQgdmVyaWZpYWJsZSBjcmVkZW50aWFsIG9yIHJlamVjdHMgd2l0aCBgVHlwZUVycm9yYCBpZiB0aGVcbiAqIGBwYXlsb2FkYCBpcyBub3QgVzNDIGNvbXBsaWFudFxuICovXG5jb25zdCBjcmVhdGVWZXJpZmlhYmxlQ3JlZGVudGlhbEp3dCA9IGZ1bmN0aW9uIChwYXlsb2FkLCBpc3N1ZXIsIG9wdGlvbnMgPSB7fSkge1xuICB0cnkge1xuICAgIGNvbnN0IHBhcnNlZFBheWxvYWQgPSB7XG4gICAgICBpYXQ6IHVuZGVmaW5lZCxcbiAgICAgIC4uLnRyYW5zZm9ybUNyZWRlbnRpYWxJbnB1dChwYXlsb2FkLCBvcHRpb25zLnJlbW92ZU9yaWdpbmFsRmllbGRzKVxuICAgIH07XG4gICAgdmFsaWRhdGVKd3RDcmVkZW50aWFsUGF5bG9hZChwYXJzZWRQYXlsb2FkKTtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoaXNzdWVyKSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShjcmVhdGVKV1QocGFyc2VkUGF5bG9hZCwge1xuICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICBpc3N1ZXI6IGlzc3Vlci5kaWQgfHwgcGFyc2VkUGF5bG9hZC5pc3MgfHwgJycsXG4gICAgICAgIHNpZ25lcjogaXNzdWVyLnNpZ25lclxuICAgICAgfSwge1xuICAgICAgICAuLi5vcHRpb25zLmhlYWRlcixcbiAgICAgICAgYWxnOiBpc3N1ZXIuYWxnIHx8IG9wdGlvbnMuaGVhZGVyPy5hbGcgfHwgSldUX0FMR1xuICAgICAgfSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBkaWQgPSBpc3N1ZXJbMF0uZGlkO1xuICAgICAgY29uc3QgaXNzdWVycyA9IFtdO1xuICAgICAgZm9yIChjb25zdCBpc3Mgb2YgaXNzdWVyKSB7XG4gICAgICAgIGlmIChpc3MuZGlkICE9PSBkaWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FsbCBpc3N1ZXJzIG11c3QgYmUgdGhlIHNhbWUgZGlkIHRvIGNvbXBseSB3aXRoIHRoZSBWZXJpZmlhYmxlIENvbmRpdGlvbnMgc3BlYycpO1xuICAgICAgICB9XG4gICAgICAgIGlzc3VlcnMucHVzaCh7XG4gICAgICAgICAgaXNzdWVyOiBpc3MuZGlkIHx8IHBhcnNlZFBheWxvYWQuaXNzIHx8ICcnLFxuICAgICAgICAgIHNpZ25lcjogaXNzLnNpZ25lcixcbiAgICAgICAgICBhbGc6IGlzcy5hbGcgfHwgb3B0aW9ucy5oZWFkZXI/LmFsZyB8fCBKV1RfQUxHXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShjcmVhdGVNdWx0aXNpZ25hdHVyZUpXVChwYXJzZWRQYXlsb2FkLCB7XG4gICAgICAgIC4uLm9wdGlvbnNcbiAgICAgIH0sIGlzc3VlcnMpKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZSk7XG4gIH1cbn07XG5mdW5jdGlvbiB2YWxpZGF0ZUp3dENyZWRlbnRpYWxQYXlsb2FkKHBheWxvYWQpIHtcbiAgdmFsaWRhdGVDb250ZXh0KHBheWxvYWQudmNbJ0Bjb250ZXh0J10pO1xuICB2YWxpZGF0ZVZjVHlwZShwYXlsb2FkLnZjLnR5cGUpO1xuICB2YWxpZGF0ZUNyZWRlbnRpYWxTdWJqZWN0KHBheWxvYWQudmMuY3JlZGVudGlhbFN1YmplY3QpO1xuICBpZiAocGF5bG9hZC5uYmYpIHZhbGlkYXRlVGltZXN0YW1wKHBheWxvYWQubmJmKTtcbiAgaWYgKHBheWxvYWQuZXhwKSB2YWxpZGF0ZVRpbWVzdGFtcChwYXlsb2FkLmV4cCk7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZUNyZWRlbnRpYWxQYXlsb2FkKHBheWxvYWQpIHtcbiAgdmFsaWRhdGVDb250ZXh0KHBheWxvYWRbJ0Bjb250ZXh0J10pO1xuICB2YWxpZGF0ZVZjVHlwZShwYXlsb2FkLnR5cGUpO1xuICB2YWxpZGF0ZUNyZWRlbnRpYWxTdWJqZWN0KHBheWxvYWQuY3JlZGVudGlhbFN1YmplY3QpO1xuICBpZiAocGF5bG9hZC5pc3N1YW5jZURhdGUpIHZhbGlkYXRlVGltZXN0YW1wKHBheWxvYWQuaXNzdWFuY2VEYXRlKTtcbiAgaWYgKHBheWxvYWQuZXhwaXJhdGlvbkRhdGUpIHZhbGlkYXRlVGltZXN0YW1wKHBheWxvYWQuZXhwaXJhdGlvbkRhdGUpO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVKd3RQcmVzZW50YXRpb25QYXlsb2FkKHBheWxvYWQpIHtcbiAgdmFsaWRhdGVDb250ZXh0KHBheWxvYWQudnBbJ0Bjb250ZXh0J10pO1xuICB2YWxpZGF0ZVZwVHlwZShwYXlsb2FkLnZwLnR5cGUpO1xuICAvLyBlbXB0eSBjcmVkZW50aWFsIGFycmF5IGlzIGFsbG93ZWRcbiAgaWYgKHBheWxvYWQudnAudmVyaWZpYWJsZUNyZWRlbnRpYWwgJiYgcGF5bG9hZC52cC52ZXJpZmlhYmxlQ3JlZGVudGlhbC5sZW5ndGggPj0gMSkge1xuICAgIGZvciAoY29uc3QgdmMgb2YgYXNBcnJheShwYXlsb2FkLnZwLnZlcmlmaWFibGVDcmVkZW50aWFsKSkge1xuICAgICAgaWYgKHR5cGVvZiB2YyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdmFsaWRhdGVKd3RGb3JtYXQodmMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsaWRhdGVDcmVkZW50aWFsUGF5bG9hZCh2Yyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChwYXlsb2FkLmV4cCkgdmFsaWRhdGVUaW1lc3RhbXAocGF5bG9hZC5leHApO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVQcmVzZW50YXRpb25QYXlsb2FkKHBheWxvYWQpIHtcbiAgdmFsaWRhdGVDb250ZXh0KHBheWxvYWRbJ0Bjb250ZXh0J10pO1xuICB2YWxpZGF0ZVZwVHlwZShwYXlsb2FkLnR5cGUpO1xuICAvLyBlbXB0eSBjcmVkZW50aWFsIGFycmF5IGlzIGFsbG93ZWRcbiAgaWYgKHBheWxvYWQudmVyaWZpYWJsZUNyZWRlbnRpYWwgJiYgcGF5bG9hZC52ZXJpZmlhYmxlQ3JlZGVudGlhbC5sZW5ndGggPj0gMSkge1xuICAgIGZvciAoY29uc3QgdmMgb2YgcGF5bG9hZC52ZXJpZmlhYmxlQ3JlZGVudGlhbCkge1xuICAgICAgaWYgKHR5cGVvZiB2YyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdmFsaWRhdGVKd3RGb3JtYXQodmMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsaWRhdGVDcmVkZW50aWFsUGF5bG9hZCh2Yyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChwYXlsb2FkLmV4cGlyYXRpb25EYXRlKSB2YWxpZGF0ZVRpbWVzdGFtcChwYXlsb2FkLmV4cGlyYXRpb25EYXRlKTtcbn1cbmZ1bmN0aW9uIHZlcmlmeVByZXNlbnRhdGlvblBheWxvYWRPcHRpb25zKHBheWxvYWQsIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMuY2hhbGxlbmdlICYmIG9wdGlvbnMuY2hhbGxlbmdlICE9PSBwYXlsb2FkLm5vbmNlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGAke1ZDX0VSUk9SLkFVVEhfRVJST1J9OiBQcmVzZW50YXRpb24gZG9lcyBub3QgY29udGFpbiB0aGUgbWFuZGF0b3J5IGNoYWxsZW5nZSAoSldUOiBub25jZSkgZm9yIDogJHtvcHRpb25zLmNoYWxsZW5nZX1gKTtcbiAgfVxuICBpZiAob3B0aW9ucy5kb21haW4pIHtcbiAgICAvLyBhdWQgbWlnaHQgYmUgYW4gYXJyYXlcbiAgICBsZXQgbWF0Y2hlZEF1ZGllbmNlO1xuICAgIGlmIChwYXlsb2FkLmF1ZCkge1xuICAgICAgY29uc3QgYXVkQXJyYXkgPSBBcnJheS5pc0FycmF5KHBheWxvYWQuYXVkKSA/IHBheWxvYWQuYXVkIDogW3BheWxvYWQuYXVkXTtcbiAgICAgIG1hdGNoZWRBdWRpZW5jZSA9IGF1ZEFycmF5LmZpbmQoaXRlbSA9PiBvcHRpb25zLmRvbWFpbiA9PT0gaXRlbSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgbWF0Y2hlZEF1ZGllbmNlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke1ZDX0VSUk9SLkFVVEhfRVJST1J9OiBQcmVzZW50YXRpb24gZG9lcyBub3QgY29udGFpbiB0aGUgbWFuZGF0b3J5IGRvbWFpbiAoSldUOiBhdWQpIGZvciA6ICR7b3B0aW9ucy5kb21haW59YCk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCB7IFZDX0VSUk9SLCBWQ19KV1RfRVJST1IsIGNyZWF0ZVZlcmlmaWFibGVDcmVkZW50aWFsSnd0LCBjcmVhdGVWZXJpZmlhYmxlUHJlc2VudGF0aW9uSnd0LCBub3JtYWxpemVDcmVkZW50aWFsLCBub3JtYWxpemVQcmVzZW50YXRpb24sIHRyYW5zZm9ybUNyZWRlbnRpYWxJbnB1dCwgdHJhbnNmb3JtUHJlc2VudGF0aW9uSW5wdXQsIHZhbGlkYXRlQ3JlZGVudGlhbFBheWxvYWQsIHZhbGlkYXRlSnd0Q3JlZGVudGlhbFBheWxvYWQsIHZhbGlkYXRlSnd0UHJlc2VudGF0aW9uUGF5bG9hZCwgdmFsaWRhdGVQcmVzZW50YXRpb25QYXlsb2FkLCB2ZXJpZnlDcmVkZW50aWFsLCB2ZXJpZnlQcmVzZW50YXRpb24sIHZlcmlmeVByZXNlbnRhdGlvblBheWxvYWRPcHRpb25zIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tb2R1bGUuanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/did-jwt-vc/lib/index.module.js\n");

/***/ })

};
;