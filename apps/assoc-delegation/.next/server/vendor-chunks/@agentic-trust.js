"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@agentic-trust";
exports.ids = ["vendor-chunks/@agentic-trust"];
exports.modules = {

/***/ "(rsc)/../../node_modules/@agentic-trust/8004-ext-sdk/abis/IdentityRegistry.json":
/*!*********************************************************************************!*\
  !*** ../../node_modules/@agentic-trust/8004-ext-sdk/abis/IdentityRegistry.json ***!
  \*********************************************************************************/
/***/ ((module) => {

module.exports = /*#__PURE__*/JSON.parse('[{"inputs":[],"stateMutability":"nonpayable","type":"constructor"},{"inputs":[{"internalType":"address","name":"target","type":"address"}],"name":"AddressEmptyCode","type":"error"},{"inputs":[],"name":"ECDSAInvalidSignature","type":"error"},{"inputs":[{"internalType":"uint256","name":"length","type":"uint256"}],"name":"ECDSAInvalidSignatureLength","type":"error"},{"inputs":[{"internalType":"bytes32","name":"s","type":"bytes32"}],"name":"ECDSAInvalidSignatureS","type":"error"},{"inputs":[{"internalType":"address","name":"implementation","type":"address"}],"name":"ERC1967InvalidImplementation","type":"error"},{"inputs":[],"name":"ERC1967NonPayable","type":"error"},{"inputs":[{"internalType":"address","name":"sender","type":"address"},{"internalType":"uint256","name":"tokenId","type":"uint256"},{"internalType":"address","name":"owner","type":"address"}],"name":"ERC721IncorrectOwner","type":"error"},{"inputs":[{"internalType":"address","name":"operator","type":"address"},{"internalType":"uint256","name":"tokenId","type":"uint256"}],"name":"ERC721InsufficientApproval","type":"error"},{"inputs":[{"internalType":"address","name":"approver","type":"address"}],"name":"ERC721InvalidApprover","type":"error"},{"inputs":[{"internalType":"address","name":"operator","type":"address"}],"name":"ERC721InvalidOperator","type":"error"},{"inputs":[{"internalType":"address","name":"owner","type":"address"}],"name":"ERC721InvalidOwner","type":"error"},{"inputs":[{"internalType":"address","name":"receiver","type":"address"}],"name":"ERC721InvalidReceiver","type":"error"},{"inputs":[{"internalType":"address","name":"sender","type":"address"}],"name":"ERC721InvalidSender","type":"error"},{"inputs":[{"internalType":"uint256","name":"tokenId","type":"uint256"}],"name":"ERC721NonexistentToken","type":"error"},{"inputs":[],"name":"FailedCall","type":"error"},{"inputs":[],"name":"InvalidInitialization","type":"error"},{"inputs":[],"name":"NotInitializing","type":"error"},{"inputs":[{"internalType":"address","name":"owner","type":"address"}],"name":"OwnableInvalidOwner","type":"error"},{"inputs":[{"internalType":"address","name":"account","type":"address"}],"name":"OwnableUnauthorizedAccount","type":"error"},{"inputs":[],"name":"UUPSUnauthorizedCallContext","type":"error"},{"inputs":[{"internalType":"bytes32","name":"slot","type":"bytes32"}],"name":"UUPSUnsupportedProxiableUUID","type":"error"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"owner","type":"address"},{"indexed":true,"internalType":"address","name":"approved","type":"address"},{"indexed":true,"internalType":"uint256","name":"tokenId","type":"uint256"}],"name":"Approval","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"owner","type":"address"},{"indexed":true,"internalType":"address","name":"operator","type":"address"},{"indexed":false,"internalType":"bool","name":"approved","type":"bool"}],"name":"ApprovalForAll","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"_fromTokenId","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"_toTokenId","type":"uint256"}],"name":"BatchMetadataUpdate","type":"event"},{"anonymous":false,"inputs":[],"name":"EIP712DomainChanged","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint64","name":"version","type":"uint64"}],"name":"Initialized","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"uint256","name":"agentId","type":"uint256"},{"indexed":true,"internalType":"string","name":"indexedMetadataKey","type":"string"},{"indexed":false,"internalType":"string","name":"metadataKey","type":"string"},{"indexed":false,"internalType":"bytes","name":"metadataValue","type":"bytes"}],"name":"MetadataSet","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"_tokenId","type":"uint256"}],"name":"MetadataUpdate","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"previousOwner","type":"address"},{"indexed":true,"internalType":"address","name":"newOwner","type":"address"}],"name":"OwnershipTransferred","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"uint256","name":"agentId","type":"uint256"},{"indexed":false,"internalType":"string","name":"agentURI","type":"string"},{"indexed":true,"internalType":"address","name":"owner","type":"address"}],"name":"Registered","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"from","type":"address"},{"indexed":true,"internalType":"address","name":"to","type":"address"},{"indexed":true,"internalType":"uint256","name":"tokenId","type":"uint256"}],"name":"Transfer","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"uint256","name":"agentId","type":"uint256"},{"indexed":false,"internalType":"string","name":"newURI","type":"string"},{"indexed":true,"internalType":"address","name":"updatedBy","type":"address"}],"name":"URIUpdated","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"implementation","type":"address"}],"name":"Upgraded","type":"event"},{"inputs":[],"name":"UPGRADE_INTERFACE_VERSION","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"tokenId","type":"uint256"}],"name":"approve","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"owner","type":"address"}],"name":"balanceOf","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"eip712Domain","outputs":[{"internalType":"bytes1","name":"fields","type":"bytes1"},{"internalType":"string","name":"name","type":"string"},{"internalType":"string","name":"version","type":"string"},{"internalType":"uint256","name":"chainId","type":"uint256"},{"internalType":"address","name":"verifyingContract","type":"address"},{"internalType":"bytes32","name":"salt","type":"bytes32"},{"internalType":"uint256[]","name":"extensions","type":"uint256[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"agentId","type":"uint256"}],"name":"getAgentWallet","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"tokenId","type":"uint256"}],"name":"getApproved","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"agentId","type":"uint256"},{"internalType":"string","name":"metadataKey","type":"string"}],"name":"getMetadata","outputs":[{"internalType":"bytes","name":"","type":"bytes"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getVersion","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"pure","type":"function"},{"inputs":[],"name":"initialize","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"owner","type":"address"},{"internalType":"address","name":"operator","type":"address"}],"name":"isApprovedForAll","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"name","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"owner","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"tokenId","type":"uint256"}],"name":"ownerOf","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"proxiableUUID","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"register","outputs":[{"internalType":"uint256","name":"agentId","type":"uint256"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"string","name":"agentURI","type":"string"},{"components":[{"internalType":"string","name":"metadataKey","type":"string"},{"internalType":"bytes","name":"metadataValue","type":"bytes"}],"internalType":"struct IdentityRegistryUpgradeable.MetadataEntry[]","name":"metadata","type":"tuple[]"}],"name":"register","outputs":[{"internalType":"uint256","name":"agentId","type":"uint256"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"string","name":"agentURI","type":"string"}],"name":"register","outputs":[{"internalType":"uint256","name":"agentId","type":"uint256"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"renounceOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"from","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"tokenId","type":"uint256"}],"name":"safeTransferFrom","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"from","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"tokenId","type":"uint256"},{"internalType":"bytes","name":"data","type":"bytes"}],"name":"safeTransferFrom","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"agentId","type":"uint256"},{"internalType":"string","name":"newURI","type":"string"}],"name":"setAgentURI","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"agentId","type":"uint256"},{"internalType":"address","name":"newWallet","type":"address"},{"internalType":"uint256","name":"deadline","type":"uint256"},{"internalType":"bytes","name":"signature","type":"bytes"}],"name":"setAgentWallet","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"operator","type":"address"},{"internalType":"bool","name":"approved","type":"bool"}],"name":"setApprovalForAll","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"agentId","type":"uint256"},{"internalType":"string","name":"metadataKey","type":"string"},{"internalType":"bytes","name":"metadataValue","type":"bytes"}],"name":"setMetadata","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes4","name":"interfaceId","type":"bytes4"}],"name":"supportsInterface","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"symbol","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"tokenId","type":"uint256"}],"name":"tokenURI","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"from","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"tokenId","type":"uint256"}],"name":"transferFrom","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"newOwner","type":"address"}],"name":"transferOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"newImplementation","type":"address"},{"internalType":"bytes","name":"data","type":"bytes"}],"name":"upgradeToAndCall","outputs":[],"stateMutability":"payable","type":"function"}]');

/***/ }),

/***/ "(rsc)/../../node_modules/@agentic-trust/8004-ext-sdk/abis/ValidationRegistry.json":
/*!***********************************************************************************!*\
  !*** ../../node_modules/@agentic-trust/8004-ext-sdk/abis/ValidationRegistry.json ***!
  \***********************************************************************************/
/***/ ((module) => {

module.exports = /*#__PURE__*/JSON.parse('[{"inputs":[],"stateMutability":"nonpayable","type":"constructor"},{"inputs":[{"internalType":"address","name":"target","type":"address"}],"name":"AddressEmptyCode","type":"error"},{"inputs":[{"internalType":"address","name":"implementation","type":"address"}],"name":"ERC1967InvalidImplementation","type":"error"},{"inputs":[],"name":"ERC1967NonPayable","type":"error"},{"inputs":[],"name":"FailedCall","type":"error"},{"inputs":[],"name":"InvalidInitialization","type":"error"},{"inputs":[],"name":"NotInitializing","type":"error"},{"inputs":[{"internalType":"address","name":"owner","type":"address"}],"name":"OwnableInvalidOwner","type":"error"},{"inputs":[{"internalType":"address","name":"account","type":"address"}],"name":"OwnableUnauthorizedAccount","type":"error"},{"inputs":[],"name":"UUPSUnauthorizedCallContext","type":"error"},{"inputs":[{"internalType":"bytes32","name":"slot","type":"bytes32"}],"name":"UUPSUnsupportedProxiableUUID","type":"error"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint64","name":"version","type":"uint64"}],"name":"Initialized","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"previousOwner","type":"address"},{"indexed":true,"internalType":"address","name":"newOwner","type":"address"}],"name":"OwnershipTransferred","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"implementation","type":"address"}],"name":"Upgraded","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"validatorAddress","type":"address"},{"indexed":true,"internalType":"uint256","name":"agentId","type":"uint256"},{"indexed":false,"internalType":"string","name":"requestURI","type":"string"},{"indexed":true,"internalType":"bytes32","name":"requestHash","type":"bytes32"}],"name":"ValidationRequest","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"validatorAddress","type":"address"},{"indexed":true,"internalType":"uint256","name":"agentId","type":"uint256"},{"indexed":true,"internalType":"bytes32","name":"requestHash","type":"bytes32"},{"indexed":false,"internalType":"uint8","name":"response","type":"uint8"},{"indexed":false,"internalType":"string","name":"responseURI","type":"string"},{"indexed":false,"internalType":"bytes32","name":"responseHash","type":"bytes32"},{"indexed":false,"internalType":"string","name":"tag","type":"string"}],"name":"ValidationResponse","type":"event"},{"inputs":[],"name":"UPGRADE_INTERFACE_VERSION","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"agentId","type":"uint256"}],"name":"getAgentValidations","outputs":[{"internalType":"bytes32[]","name":"","type":"bytes32[]"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getIdentityRegistry","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"agentId","type":"uint256"},{"internalType":"address[]","name":"validatorAddresses","type":"address[]"},{"internalType":"string","name":"tag","type":"string"}],"name":"getSummary","outputs":[{"internalType":"uint64","name":"count","type":"uint64"},{"internalType":"uint8","name":"avgResponse","type":"uint8"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"requestHash","type":"bytes32"}],"name":"getValidationStatus","outputs":[{"internalType":"address","name":"validatorAddress","type":"address"},{"internalType":"uint256","name":"agentId","type":"uint256"},{"internalType":"uint8","name":"response","type":"uint8"},{"internalType":"bytes32","name":"responseHash","type":"bytes32"},{"internalType":"string","name":"tag","type":"string"},{"internalType":"uint256","name":"lastUpdate","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"validatorAddress","type":"address"}],"name":"getValidatorRequests","outputs":[{"internalType":"bytes32[]","name":"","type":"bytes32[]"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getVersion","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"address","name":"identityRegistry_","type":"address"}],"name":"initialize","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"owner","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"proxiableUUID","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"renounceOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"newOwner","type":"address"}],"name":"transferOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"newImplementation","type":"address"},{"internalType":"bytes","name":"data","type":"bytes"}],"name":"upgradeToAndCall","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"address","name":"validatorAddress","type":"address"},{"internalType":"uint256","name":"agentId","type":"uint256"},{"internalType":"string","name":"requestURI","type":"string"},{"internalType":"bytes32","name":"requestHash","type":"bytes32"}],"name":"validationRequest","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"requestHash","type":"bytes32"},{"internalType":"uint8","name":"response","type":"uint8"},{"internalType":"string","name":"responseURI","type":"string"},{"internalType":"bytes32","name":"responseHash","type":"bytes32"},{"internalType":"string","name":"tag","type":"string"}],"name":"validationResponse","outputs":[],"stateMutability":"nonpayable","type":"function"}]');

/***/ }),

/***/ "(rsc)/../../node_modules/@agentic-trust/8004-ext-sdk/dist/AIAgentAssociationClient.js":
/*!***************************************************************************************!*\
  !*** ../../node_modules/@agentic-trust/8004-ext-sdk/dist/AIAgentAssociationClient.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AIAgentAssociationClient: () => (/* binding */ AIAgentAssociationClient)\n/* harmony export */ });\n/* harmony import */ var viem_chains__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! viem/chains */ \"(rsc)/../../node_modules/viem/_esm/chains/definitions/sepolia.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! viem */ \"(rsc)/../../node_modules/abitype/dist/esm/human-readable/parseAbi.js\");\n/* harmony import */ var _associatedaccounts_erc8092_sdk__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @associatedaccounts/erc8092-sdk */ \"(rsc)/../../packages/erc8092-sdk/dist/index.js\");\n/**\n * Agentic Trust SDK - Association Client\n * Extends AssociationsStoreClient with AccountProvider support.\n * Uses AccountProvider (Ports & Adapters pattern) for chain I/O.\n */\n\n\n\n// Import ABI - need to handle the export structure\n// The abi.ts file exports ASSOCIATIONS_STORE_ABI as const array\nconst ASSOCIATIONS_STORE_ABI = (0,viem__WEBPACK_IMPORTED_MODULE_1__.parseAbi)([\n    \"function storeAssociation((uint40 revokedAt,bytes2 initiatorKeyType,bytes2 approverKeyType,bytes initiatorSignature,bytes approverSignature,(bytes initiator,bytes approver,uint40 validAt,uint40 validUntil,bytes4 interfaceId,bytes data) record) sar)\",\n    \"function revokeAssociation(bytes32 associationId, uint40 revokedAt)\",\n    \"function getAssociationsForAccount(bytes account) view returns ((uint40 revokedAt,bytes2 initiatorKeyType,bytes2 approverKeyType,bytes initiatorSignature,bytes approverSignature,(bytes initiator,bytes approver,uint40 validAt,uint40 validUntil,bytes4 interfaceId,bytes data) record)[] sars)\",\n]);\nclass AIAgentAssociationClient {\n    chain;\n    accountProvider;\n    associationsProxyAddress;\n    baseClient;\n    constructor(accountProvider, associationsProxyAddress) {\n        this.accountProvider = accountProvider;\n        this.associationsProxyAddress = associationsProxyAddress;\n        this.chain = viem_chains__WEBPACK_IMPORTED_MODULE_2__.sepolia; // Default, can be overridden based on chainId\n        // Create base client for read operations using ethers provider\n        // Note: For write operations, we'll use AccountProvider via prepareStoreAssociationTx\n        // We'll initialize baseClient lazily when needed since we can't use await in constructor\n        this.baseClient = null; // Will be initialized in getAssociationsForEvmAccount\n    }\n    async getBaseClient() {\n        if (this.baseClient)\n            return this.baseClient;\n        const chainConfig = this.accountProvider.chain();\n        const rpcUrl = chainConfig.rpcUrl;\n        // Use dynamic import for ethers\n        const ethers = await __webpack_require__.e(/*! import() */ \"vendor-chunks/ethers\").then(__webpack_require__.bind(__webpack_require__, /*! ethers */ \"(rsc)/../../node_modules/ethers/lib.esm/index.js\"));\n        const provider = new ethers.JsonRpcProvider(rpcUrl);\n        this.baseClient = new _associatedaccounts_erc8092_sdk__WEBPACK_IMPORTED_MODULE_0__.AssociationsStoreClient(this.associationsProxyAddress, provider);\n        return this.baseClient;\n    }\n    // Factory helper to mirror other client create-style APIs\n    static async create(accountProvider, associationsProxyAddress) {\n        return new AIAgentAssociationClient(accountProvider, associationsProxyAddress);\n    }\n    /**\n     * Get associations for an account (read-only, uses base client)\n     */\n    async getAssociationsForEvmAccount(params) {\n        const client = await this.getBaseClient();\n        return client.getAssociationsForEvmAccount(params);\n    }\n    /**\n     * Get the full SignedAssociationRecords (SARs) for an account (read-only).\n     * This exposes initiator/approver key types, signatures, interfaceId, and data.\n     */\n    async getSignedAssociationsForEvmAccount(params) {\n        const client = await this.getBaseClient();\n        // Method is provided by @associatedaccounts/erc8092-sdk AssociationsStoreClient\n        return client.getSignedAssociationsForEvmAccount(params);\n    }\n    /**\n     * Prepare the storeAssociation transaction data without sending it.\n     * This encodes the transaction that can be sent via a bundler using account abstraction.\n     */\n    async prepareStoreAssociationTx(params) {\n        if (!params.sar) {\n            throw new Error('sar (SignedAssociationRecord) is required');\n        }\n        // Encode the storeAssociation call\n        const data = await this.accountProvider?.encodeFunctionData({\n            abi: ASSOCIATIONS_STORE_ABI,\n            functionName: 'storeAssociation',\n            args: [params.sar],\n        });\n        return {\n            txRequest: {\n                to: this.associationsProxyAddress,\n                data: data || '0x',\n                value: 0n,\n            },\n        };\n    }\n    /**\n     * Store association (write operation - requires wallet)\n     * This is a convenience method, but for AA we should use prepareStoreAssociationTx + client-side execution\n     */\n    async storeAssociation(sar) {\n        const { txRequest } = await this.prepareStoreAssociationTx({ sar });\n        const result = await this.accountProvider?.send({\n            to: txRequest.to,\n            data: txRequest.data,\n            value: txRequest.value,\n        });\n        return {\n            hash: result?.hash || '',\n            txHash: result?.hash || '',\n        };\n    }\n}\n//# sourceMappingURL=AIAgentAssociationClient.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BhZ2VudGljLXRydXN0LzgwMDQtZXh0LXNkay9kaXN0L0FJQWdlbnRBc3NvY2lhdGlvbkNsaWVudC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNzQztBQUNOO0FBQzBDO0FBQzFFO0FBQ0E7QUFDQSwrQkFBK0IsOENBQVE7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGdEQUFPLEVBQUU7QUFDOUI7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLG1MQUFnQjtBQUM3QztBQUNBLDhCQUE4QixvRkFBdUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFlBQVkseUNBQXlDLEtBQUs7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL2JhcmIvYWEvQXNzb2NpYXRlZEFjY291bnRzL25vZGVfbW9kdWxlcy9AYWdlbnRpYy10cnVzdC84MDA0LWV4dC1zZGsvZGlzdC9BSUFnZW50QXNzb2NpYXRpb25DbGllbnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBBZ2VudGljIFRydXN0IFNESyAtIEFzc29jaWF0aW9uIENsaWVudFxuICogRXh0ZW5kcyBBc3NvY2lhdGlvbnNTdG9yZUNsaWVudCB3aXRoIEFjY291bnRQcm92aWRlciBzdXBwb3J0LlxuICogVXNlcyBBY2NvdW50UHJvdmlkZXIgKFBvcnRzICYgQWRhcHRlcnMgcGF0dGVybikgZm9yIGNoYWluIEkvTy5cbiAqL1xuaW1wb3J0IHsgc2Vwb2xpYSB9IGZyb20gJ3ZpZW0vY2hhaW5zJztcbmltcG9ydCB7IHBhcnNlQWJpIH0gZnJvbSAndmllbSc7XG5pbXBvcnQgeyBBc3NvY2lhdGlvbnNTdG9yZUNsaWVudCB9IGZyb20gJ0Bhc3NvY2lhdGVkYWNjb3VudHMvZXJjODA5Mi1zZGsnO1xuLy8gSW1wb3J0IEFCSSAtIG5lZWQgdG8gaGFuZGxlIHRoZSBleHBvcnQgc3RydWN0dXJlXG4vLyBUaGUgYWJpLnRzIGZpbGUgZXhwb3J0cyBBU1NPQ0lBVElPTlNfU1RPUkVfQUJJIGFzIGNvbnN0IGFycmF5XG5jb25zdCBBU1NPQ0lBVElPTlNfU1RPUkVfQUJJID0gcGFyc2VBYmkoW1xuICAgIFwiZnVuY3Rpb24gc3RvcmVBc3NvY2lhdGlvbigodWludDQwIHJldm9rZWRBdCxieXRlczIgaW5pdGlhdG9yS2V5VHlwZSxieXRlczIgYXBwcm92ZXJLZXlUeXBlLGJ5dGVzIGluaXRpYXRvclNpZ25hdHVyZSxieXRlcyBhcHByb3ZlclNpZ25hdHVyZSwoYnl0ZXMgaW5pdGlhdG9yLGJ5dGVzIGFwcHJvdmVyLHVpbnQ0MCB2YWxpZEF0LHVpbnQ0MCB2YWxpZFVudGlsLGJ5dGVzNCBpbnRlcmZhY2VJZCxieXRlcyBkYXRhKSByZWNvcmQpIHNhcilcIixcbiAgICBcImZ1bmN0aW9uIHJldm9rZUFzc29jaWF0aW9uKGJ5dGVzMzIgYXNzb2NpYXRpb25JZCwgdWludDQwIHJldm9rZWRBdClcIixcbiAgICBcImZ1bmN0aW9uIGdldEFzc29jaWF0aW9uc0ZvckFjY291bnQoYnl0ZXMgYWNjb3VudCkgdmlldyByZXR1cm5zICgodWludDQwIHJldm9rZWRBdCxieXRlczIgaW5pdGlhdG9yS2V5VHlwZSxieXRlczIgYXBwcm92ZXJLZXlUeXBlLGJ5dGVzIGluaXRpYXRvclNpZ25hdHVyZSxieXRlcyBhcHByb3ZlclNpZ25hdHVyZSwoYnl0ZXMgaW5pdGlhdG9yLGJ5dGVzIGFwcHJvdmVyLHVpbnQ0MCB2YWxpZEF0LHVpbnQ0MCB2YWxpZFVudGlsLGJ5dGVzNCBpbnRlcmZhY2VJZCxieXRlcyBkYXRhKSByZWNvcmQpW10gc2FycylcIixcbl0pO1xuZXhwb3J0IGNsYXNzIEFJQWdlbnRBc3NvY2lhdGlvbkNsaWVudCB7XG4gICAgY2hhaW47XG4gICAgYWNjb3VudFByb3ZpZGVyO1xuICAgIGFzc29jaWF0aW9uc1Byb3h5QWRkcmVzcztcbiAgICBiYXNlQ2xpZW50O1xuICAgIGNvbnN0cnVjdG9yKGFjY291bnRQcm92aWRlciwgYXNzb2NpYXRpb25zUHJveHlBZGRyZXNzKSB7XG4gICAgICAgIHRoaXMuYWNjb3VudFByb3ZpZGVyID0gYWNjb3VudFByb3ZpZGVyO1xuICAgICAgICB0aGlzLmFzc29jaWF0aW9uc1Byb3h5QWRkcmVzcyA9IGFzc29jaWF0aW9uc1Byb3h5QWRkcmVzcztcbiAgICAgICAgdGhpcy5jaGFpbiA9IHNlcG9saWE7IC8vIERlZmF1bHQsIGNhbiBiZSBvdmVycmlkZGVuIGJhc2VkIG9uIGNoYWluSWRcbiAgICAgICAgLy8gQ3JlYXRlIGJhc2UgY2xpZW50IGZvciByZWFkIG9wZXJhdGlvbnMgdXNpbmcgZXRoZXJzIHByb3ZpZGVyXG4gICAgICAgIC8vIE5vdGU6IEZvciB3cml0ZSBvcGVyYXRpb25zLCB3ZSdsbCB1c2UgQWNjb3VudFByb3ZpZGVyIHZpYSBwcmVwYXJlU3RvcmVBc3NvY2lhdGlvblR4XG4gICAgICAgIC8vIFdlJ2xsIGluaXRpYWxpemUgYmFzZUNsaWVudCBsYXppbHkgd2hlbiBuZWVkZWQgc2luY2Ugd2UgY2FuJ3QgdXNlIGF3YWl0IGluIGNvbnN0cnVjdG9yXG4gICAgICAgIHRoaXMuYmFzZUNsaWVudCA9IG51bGw7IC8vIFdpbGwgYmUgaW5pdGlhbGl6ZWQgaW4gZ2V0QXNzb2NpYXRpb25zRm9yRXZtQWNjb3VudFxuICAgIH1cbiAgICBhc3luYyBnZXRCYXNlQ2xpZW50KCkge1xuICAgICAgICBpZiAodGhpcy5iYXNlQ2xpZW50KVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYmFzZUNsaWVudDtcbiAgICAgICAgY29uc3QgY2hhaW5Db25maWcgPSB0aGlzLmFjY291bnRQcm92aWRlci5jaGFpbigpO1xuICAgICAgICBjb25zdCBycGNVcmwgPSBjaGFpbkNvbmZpZy5ycGNVcmw7XG4gICAgICAgIC8vIFVzZSBkeW5hbWljIGltcG9ydCBmb3IgZXRoZXJzXG4gICAgICAgIGNvbnN0IGV0aGVycyA9IGF3YWl0IGltcG9ydCgnZXRoZXJzJyk7XG4gICAgICAgIGNvbnN0IHByb3ZpZGVyID0gbmV3IGV0aGVycy5Kc29uUnBjUHJvdmlkZXIocnBjVXJsKTtcbiAgICAgICAgdGhpcy5iYXNlQ2xpZW50ID0gbmV3IEFzc29jaWF0aW9uc1N0b3JlQ2xpZW50KHRoaXMuYXNzb2NpYXRpb25zUHJveHlBZGRyZXNzLCBwcm92aWRlcik7XG4gICAgICAgIHJldHVybiB0aGlzLmJhc2VDbGllbnQ7XG4gICAgfVxuICAgIC8vIEZhY3RvcnkgaGVscGVyIHRvIG1pcnJvciBvdGhlciBjbGllbnQgY3JlYXRlLXN0eWxlIEFQSXNcbiAgICBzdGF0aWMgYXN5bmMgY3JlYXRlKGFjY291bnRQcm92aWRlciwgYXNzb2NpYXRpb25zUHJveHlBZGRyZXNzKSB7XG4gICAgICAgIHJldHVybiBuZXcgQUlBZ2VudEFzc29jaWF0aW9uQ2xpZW50KGFjY291bnRQcm92aWRlciwgYXNzb2NpYXRpb25zUHJveHlBZGRyZXNzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGFzc29jaWF0aW9ucyBmb3IgYW4gYWNjb3VudCAocmVhZC1vbmx5LCB1c2VzIGJhc2UgY2xpZW50KVxuICAgICAqL1xuICAgIGFzeW5jIGdldEFzc29jaWF0aW9uc0ZvckV2bUFjY291bnQocGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IGNsaWVudCA9IGF3YWl0IHRoaXMuZ2V0QmFzZUNsaWVudCgpO1xuICAgICAgICByZXR1cm4gY2xpZW50LmdldEFzc29jaWF0aW9uc0ZvckV2bUFjY291bnQocGFyYW1zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBmdWxsIFNpZ25lZEFzc29jaWF0aW9uUmVjb3JkcyAoU0FScykgZm9yIGFuIGFjY291bnQgKHJlYWQtb25seSkuXG4gICAgICogVGhpcyBleHBvc2VzIGluaXRpYXRvci9hcHByb3ZlciBrZXkgdHlwZXMsIHNpZ25hdHVyZXMsIGludGVyZmFjZUlkLCBhbmQgZGF0YS5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRTaWduZWRBc3NvY2lhdGlvbnNGb3JFdm1BY2NvdW50KHBhcmFtcykge1xuICAgICAgICBjb25zdCBjbGllbnQgPSBhd2FpdCB0aGlzLmdldEJhc2VDbGllbnQoKTtcbiAgICAgICAgLy8gTWV0aG9kIGlzIHByb3ZpZGVkIGJ5IEBhc3NvY2lhdGVkYWNjb3VudHMvZXJjODA5Mi1zZGsgQXNzb2NpYXRpb25zU3RvcmVDbGllbnRcbiAgICAgICAgcmV0dXJuIGNsaWVudC5nZXRTaWduZWRBc3NvY2lhdGlvbnNGb3JFdm1BY2NvdW50KHBhcmFtcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByZXBhcmUgdGhlIHN0b3JlQXNzb2NpYXRpb24gdHJhbnNhY3Rpb24gZGF0YSB3aXRob3V0IHNlbmRpbmcgaXQuXG4gICAgICogVGhpcyBlbmNvZGVzIHRoZSB0cmFuc2FjdGlvbiB0aGF0IGNhbiBiZSBzZW50IHZpYSBhIGJ1bmRsZXIgdXNpbmcgYWNjb3VudCBhYnN0cmFjdGlvbi5cbiAgICAgKi9cbiAgICBhc3luYyBwcmVwYXJlU3RvcmVBc3NvY2lhdGlvblR4KHBhcmFtcykge1xuICAgICAgICBpZiAoIXBhcmFtcy5zYXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc2FyIChTaWduZWRBc3NvY2lhdGlvblJlY29yZCkgaXMgcmVxdWlyZWQnKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBFbmNvZGUgdGhlIHN0b3JlQXNzb2NpYXRpb24gY2FsbFxuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy5hY2NvdW50UHJvdmlkZXI/LmVuY29kZUZ1bmN0aW9uRGF0YSh7XG4gICAgICAgICAgICBhYmk6IEFTU09DSUFUSU9OU19TVE9SRV9BQkksXG4gICAgICAgICAgICBmdW5jdGlvbk5hbWU6ICdzdG9yZUFzc29jaWF0aW9uJyxcbiAgICAgICAgICAgIGFyZ3M6IFtwYXJhbXMuc2FyXSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eFJlcXVlc3Q6IHtcbiAgICAgICAgICAgICAgICB0bzogdGhpcy5hc3NvY2lhdGlvbnNQcm94eUFkZHJlc3MsXG4gICAgICAgICAgICAgICAgZGF0YTogZGF0YSB8fCAnMHgnLFxuICAgICAgICAgICAgICAgIHZhbHVlOiAwbixcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0b3JlIGFzc29jaWF0aW9uICh3cml0ZSBvcGVyYXRpb24gLSByZXF1aXJlcyB3YWxsZXQpXG4gICAgICogVGhpcyBpcyBhIGNvbnZlbmllbmNlIG1ldGhvZCwgYnV0IGZvciBBQSB3ZSBzaG91bGQgdXNlIHByZXBhcmVTdG9yZUFzc29jaWF0aW9uVHggKyBjbGllbnQtc2lkZSBleGVjdXRpb25cbiAgICAgKi9cbiAgICBhc3luYyBzdG9yZUFzc29jaWF0aW9uKHNhcikge1xuICAgICAgICBjb25zdCB7IHR4UmVxdWVzdCB9ID0gYXdhaXQgdGhpcy5wcmVwYXJlU3RvcmVBc3NvY2lhdGlvblR4KHsgc2FyIH0pO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmFjY291bnRQcm92aWRlcj8uc2VuZCh7XG4gICAgICAgICAgICB0bzogdHhSZXF1ZXN0LnRvLFxuICAgICAgICAgICAgZGF0YTogdHhSZXF1ZXN0LmRhdGEsXG4gICAgICAgICAgICB2YWx1ZTogdHhSZXF1ZXN0LnZhbHVlLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGhhc2g6IHJlc3VsdD8uaGFzaCB8fCAnJyxcbiAgICAgICAgICAgIHR4SGFzaDogcmVzdWx0Py5oYXNoIHx8ICcnLFxuICAgICAgICB9O1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFJQWdlbnRBc3NvY2lhdGlvbkNsaWVudC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@agentic-trust/8004-ext-sdk/dist/AIAgentAssociationClient.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@agentic-trust/8004-ext-sdk/dist/AIAgentDiscoveryClient.js":
/*!*************************************************************************************!*\
  !*** ../../node_modules/@agentic-trust/8004-ext-sdk/dist/AIAgentDiscoveryClient.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AIAgentDiscoveryClient: () => (/* binding */ AIAgentDiscoveryClient)\n/* harmony export */ });\n/* harmony import */ var graphql_request__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! graphql-request */ \"(rsc)/../../node_modules/graphql-request/build/esm/index.js\");\n/**\n * AI Agent Discovery Client\n *\n * Fronts for discovery-index GraphQL requests to the indexer\n * Provides a clean interface for querying agent data\n */\n\nconst INTROSPECTION_QUERY = `\r\n  query SearchCapabilities {\r\n    __schema {\r\n      queryType {\r\n        fields {\r\n          name\r\n          args {\r\n            name\r\n            type {\r\n              ...TypeRef\r\n            }\r\n          }\r\n          type {\r\n            ...TypeRef\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n  fragment TypeRef on __Type {\r\n    kind\r\n    name\r\n    ofType {\r\n      kind\r\n      name\r\n      ofType {\r\n        kind\r\n        name\r\n        ofType {\r\n          kind\r\n          name\r\n        }\r\n      }\r\n    }\r\n  }\r\n`;\nconst TYPE_FIELDS_QUERY = `\r\n  query TypeFields($name: String!) {\r\n    __type(name: $name) {\r\n      fields {\r\n        name\r\n        type {\r\n          ...TypeRef\r\n        }\r\n      }\r\n    }\r\n  }\r\n  fragment TypeRef on __Type {\r\n    kind\r\n    name\r\n    ofType {\r\n      kind\r\n      name\r\n      ofType {\r\n        kind\r\n        name\r\n        ofType {\r\n          kind\r\n          name\r\n        }\r\n      }\r\n    }\r\n  }\r\n`;\nfunction unwrapType(type) {\n    let current = type;\n    while (current && (current.kind === 'NON_NULL' || current.kind === 'LIST')) {\n        current = current.ofType ?? null;\n    }\n    return current ?? null;\n}\nfunction unwrapToTypeName(type) {\n    const named = unwrapType(type);\n    return named?.name ?? null;\n}\nfunction isNonNull(type) {\n    return type?.kind === 'NON_NULL';\n}\nfunction isListOf(type, expectedName) {\n    if (!type)\n        return false;\n    if (type.kind === 'NON_NULL')\n        return isListOf(type.ofType, expectedName);\n    if (type.kind === 'LIST') {\n        const inner = type.ofType || null;\n        if (!inner)\n            return false;\n        if (inner.kind === 'NON_NULL') {\n            return isListOf(inner.ofType, expectedName);\n        }\n        return inner.kind === 'OBJECT' && inner.name === expectedName;\n    }\n    return false;\n}\n/**\n * AI Agent Discovery Client\n *\n * Provides methods for querying agent data from the indexer\n */\nclass AIAgentDiscoveryClient {\n    client;\n    config;\n    searchStrategy;\n    searchStrategyPromise;\n    typeFieldsCache = new Map();\n    tokenMetadataCollectionSupported;\n    agentMetadataValueField;\n    queryFieldsCache;\n    queryFieldsPromise;\n    constructor(config) {\n        this.config = config;\n        const headers = {\n            'Content-Type': 'application/json',\n            ...(config.headers || {}),\n        };\n        if (config.apiKey) {\n            headers['Authorization'] = `Bearer ${config.apiKey}`;\n            // Also support API key in header\n            headers['X-API-Key'] = config.apiKey;\n        }\n        this.client = new graphql_request__WEBPACK_IMPORTED_MODULE_0__.GraphQLClient(config.endpoint, {\n            headers,\n        });\n    }\n    async getQueryFields() {\n        if (this.queryFieldsCache !== undefined) {\n            return this.queryFieldsCache;\n        }\n        if (this.queryFieldsPromise) {\n            return this.queryFieldsPromise;\n        }\n        this.queryFieldsPromise = (async () => {\n            try {\n                const data = await this.client.request(INTROSPECTION_QUERY);\n                const fields = data.__schema?.queryType?.fields ?? [];\n                this.queryFieldsCache = fields;\n                return fields;\n            }\n            catch (error) {\n                console.warn('[AIAgentDiscoveryClient] Failed to introspect query fields:', error);\n                this.queryFieldsCache = null;\n                return null;\n            }\n            finally {\n                this.queryFieldsPromise = undefined;\n            }\n        })();\n        return this.queryFieldsPromise;\n    }\n    async supportsQueryField(fieldName) {\n        const fields = await this.getQueryFields();\n        if (!fields)\n            return false;\n        return fields.some((f) => f.name === fieldName);\n    }\n    normalizeAgent(agent) {\n        const record = (agent ?? {});\n        const toOptionalString = (value) => {\n            if (value === undefined || value === null) {\n                return undefined;\n            }\n            return String(value);\n        };\n        const toOptionalStringOrNull = (value) => {\n            if (value === undefined) {\n                return undefined;\n            }\n            if (value === null) {\n                return null;\n            }\n            return String(value);\n        };\n        const toOptionalNumber = (value) => {\n            if (value === undefined || value === null) {\n                return undefined;\n            }\n            const numeric = typeof value === 'number' ? value : Number(value);\n            return Number.isFinite(numeric) ? numeric : undefined;\n        };\n        const toOptionalNumberOrNull = (value) => {\n            if (value === undefined) {\n                return undefined;\n            }\n            if (value === null) {\n                return null;\n            }\n            const numeric = typeof value === 'number' ? value : Number(value);\n            return Number.isFinite(numeric) ? numeric : null;\n        };\n        // Parse rawJson to extract all metadata fields\n        let parsedMetadata = {};\n        if (record.rawJson && typeof record.rawJson === 'string') {\n            try {\n                const parsed = JSON.parse(record.rawJson);\n                if (parsed && typeof parsed === 'object') {\n                    // Extract all fields from the registration JSON\n                    parsedMetadata = parsed;\n                }\n            }\n            catch (error) {\n                // Silently ignore JSON parse errors\n            }\n        }\n        const normalized = {\n            ...record,\n            // Merge all metadata from parsed rawJson\n            ...parsedMetadata,\n        };\n        const agentAccount = toOptionalString(record.agentAccount);\n        if (agentAccount !== undefined) {\n            normalized.agentAccount = agentAccount;\n        }\n        const agentIdentityOwnerAccount = toOptionalString(record.agentIdentityOwnerAccount);\n        if (agentIdentityOwnerAccount !== undefined) {\n            normalized.agentIdentityOwnerAccount = agentIdentityOwnerAccount;\n        }\n        const eoaAgentIdentityOwnerAccount = toOptionalStringOrNull(record.eoaAgentIdentityOwnerAccount);\n        if (eoaAgentIdentityOwnerAccount !== undefined) {\n            normalized.eoaAgentIdentityOwnerAccount = eoaAgentIdentityOwnerAccount;\n        }\n        const eoaAgentAccount = toOptionalStringOrNull(record.eoaAgentAccount);\n        if (eoaAgentAccount !== undefined) {\n            normalized.eoaAgentAccount = eoaAgentAccount;\n        }\n        const agentCategory = toOptionalStringOrNull(record.agentCategory);\n        if (agentCategory !== undefined) {\n            normalized.agentCategory = agentCategory;\n        }\n        const didIdentity = toOptionalStringOrNull(record.didIdentity);\n        if (didIdentity !== undefined) {\n            normalized.didIdentity = didIdentity;\n        }\n        const didAccount = toOptionalStringOrNull(record.didAccount);\n        if (didAccount !== undefined) {\n            normalized.didAccount = didAccount;\n        }\n        const didName = toOptionalStringOrNull(record.didName);\n        if (didName !== undefined) {\n            normalized.didName = didName;\n        }\n        const agentUri = toOptionalStringOrNull(record.agentUri);\n        if (agentUri !== undefined) {\n            normalized.agentUri = agentUri;\n        }\n        const validationPendingCount = toOptionalNumberOrNull(record.validationPendingCount);\n        if (validationPendingCount !== undefined) {\n            normalized.validationPendingCount = validationPendingCount;\n        }\n        const validationCompletedCount = toOptionalNumberOrNull(record.validationCompletedCount);\n        if (validationCompletedCount !== undefined) {\n            normalized.validationCompletedCount = validationCompletedCount;\n        }\n        const validationRequestedCount = toOptionalNumberOrNull(record.validationRequestedCount);\n        if (validationRequestedCount !== undefined) {\n            normalized.validationRequestedCount = validationRequestedCount;\n        }\n        const initiatedAssociationCount = toOptionalNumberOrNull(record.initiatedAssociationCount);\n        if (initiatedAssociationCount !== undefined) {\n            normalized.initiatedAssociationCount = initiatedAssociationCount;\n        }\n        const approvedAssociationCount = toOptionalNumberOrNull(record.approvedAssociationCount);\n        if (approvedAssociationCount !== undefined) {\n            normalized.approvedAssociationCount = approvedAssociationCount;\n        }\n        const atiOverallScore = toOptionalNumberOrNull(record.atiOverallScore);\n        if (atiOverallScore !== undefined) {\n            normalized.atiOverallScore = atiOverallScore;\n        }\n        const atiOverallConfidence = toOptionalNumberOrNull(record.atiOverallConfidence);\n        if (atiOverallConfidence !== undefined) {\n            normalized.atiOverallConfidence = atiOverallConfidence;\n        }\n        const atiVersion = toOptionalStringOrNull(record.atiVersion);\n        if (atiVersion !== undefined) {\n            normalized.atiVersion = atiVersion;\n        }\n        const atiComputedAt = toOptionalNumberOrNull(record.atiComputedAt);\n        if (atiComputedAt !== undefined) {\n            normalized.atiComputedAt = atiComputedAt;\n        }\n        const atiBundleJson = toOptionalStringOrNull(record.atiBundleJson);\n        if (atiBundleJson !== undefined) {\n            normalized.atiBundleJson = atiBundleJson;\n        }\n        const trustLedgerScore = toOptionalNumberOrNull(record.trustLedgerScore);\n        if (trustLedgerScore !== undefined) {\n            normalized.trustLedgerScore = trustLedgerScore;\n        }\n        const trustLedgerBadgeCount = toOptionalNumberOrNull(record.trustLedgerBadgeCount);\n        if (trustLedgerBadgeCount !== undefined) {\n            normalized.trustLedgerBadgeCount = trustLedgerBadgeCount;\n        }\n        const trustLedgerOverallRank = toOptionalNumberOrNull(record.trustLedgerOverallRank);\n        if (trustLedgerOverallRank !== undefined) {\n            normalized.trustLedgerOverallRank = trustLedgerOverallRank;\n        }\n        const trustLedgerCapabilityRank = toOptionalNumberOrNull(record.trustLedgerCapabilityRank);\n        if (trustLedgerCapabilityRank !== undefined) {\n            normalized.trustLedgerCapabilityRank = trustLedgerCapabilityRank;\n        }\n        const description = toOptionalStringOrNull(record.description);\n        if (description !== undefined) {\n            normalized.description = description;\n        }\n        const image = toOptionalStringOrNull(record.image);\n        if (image !== undefined) {\n            normalized.image = image;\n        }\n        const a2aEndpoint = toOptionalStringOrNull(record.a2aEndpoint);\n        if (a2aEndpoint !== undefined) {\n            normalized.a2aEndpoint = a2aEndpoint;\n        }\n        const agentCardJson = toOptionalStringOrNull(record.agentCardJson);\n        if (agentCardJson !== undefined) {\n            normalized.agentCardJson = agentCardJson;\n        }\n        const agentCardReadAt = toOptionalNumberOrNull(record.agentCardReadAt);\n        if (agentCardReadAt !== undefined) {\n            normalized.agentCardReadAt = agentCardReadAt;\n        }\n        const supportedTrust = toOptionalString(record.supportedTrust);\n        if (supportedTrust !== undefined) {\n            normalized.supportedTrust = supportedTrust;\n        }\n        const did = toOptionalStringOrNull(record.did);\n        if (did !== undefined) {\n            normalized.did = did;\n        }\n        // Handle agentName: prefer non-empty values from multiple sources\n        // Priority: 1) direct agentName field, 2) name from parsedMetadata, 3) agentName from parsedMetadata\n        let agentName = undefined;\n        // Check direct agentName field (must be non-empty after trim)\n        const rawAgentName = record.agentName;\n        const directAgentName = typeof rawAgentName === 'string' && rawAgentName.trim().length > 0\n            ? rawAgentName.trim()\n            : undefined;\n        if (directAgentName) {\n            agentName = directAgentName;\n        }\n        else {\n            // Check parsedMetadata for name or agentName\n            const metadataName = typeof parsedMetadata.name === 'string' && parsedMetadata.name.trim().length > 0\n                ? parsedMetadata.name.trim()\n                : undefined;\n            const metadataAgentName = typeof parsedMetadata.agentName === 'string' && parsedMetadata.agentName.trim().length > 0\n                ? parsedMetadata.agentName.trim()\n                : undefined;\n            agentName = metadataAgentName || metadataName;\n            if (agentName) {\n                console.log('[AIAgentDiscoveryClient.normalizeAgent] Using metadata name:', {\n                    fromMetadataAgentName: !!metadataAgentName,\n                    fromMetadataName: !!metadataName,\n                    agentName,\n                });\n            }\n            else {\n                console.log('[AIAgentDiscoveryClient.normalizeAgent] No valid agentName found in direct field or metadata');\n            }\n        }\n        // Set agentName: use found value, or undefined if original was empty and no replacement found\n        // This ensures empty strings are converted to undefined\n        if (agentName && agentName.length > 0) {\n            normalized.agentName = agentName;\n        }\n        else if (typeof rawAgentName === 'string' && rawAgentName.trim().length === 0) {\n            // Original was empty string, and we didn't find a replacement - set to undefined\n            normalized.agentName = undefined;\n            console.log('[AIAgentDiscoveryClient.normalizeAgent] Original was empty string, set to undefined');\n        }\n        else {\n            console.log('[AIAgentDiscoveryClient.normalizeAgent] Leaving agentName as-is:', normalized.agentName);\n        }\n        // If rawAgentName was undefined/null, leave it as-is (don't overwrite)\n        return normalized;\n    }\n    /**\n     * List agents with a deterministic default ordering (agentId DESC).\n     *\n     * @param limit - Maximum number of agents to return per page\n     * @param offset - Number of agents to skip\n     * @returns List of agents\n     */\n    async listAgents(limit, offset) {\n        let allAgents = [];\n        const effectiveLimit = limit ?? 100;\n        const effectiveOffset = offset ?? 0;\n        const query = `\r\n      query ListAgents($limit: Int, $offset: Int) {\r\n        agents(limit: $limit, offset: $offset) {\r\n          chainId\r\n          agentId\r\n          agentName\r\n          agentAccount\r\n          agentIdentityOwnerAccount\r\n          eoaAgentIdentityOwnerAccount\r\n          eoaAgentAccount\r\n          agentCategory\r\n          didIdentity\r\n          didAccount\r\n          didName\r\n          agentUri\r\n          createdAtBlock\r\n          createdAtTime\r\n          updatedAtTime\r\n          type\r\n          description\r\n          image\r\n          a2aEndpoint\r\n          did\r\n          mcp\r\n          x402support\r\n          active\r\n          supportedTrust\r\n          rawJson\r\n          agentCardJson\r\n          agentCardReadAt\r\n          feedbackCount\r\n          feedbackAverageScore\r\n          validationPendingCount\r\n          validationCompletedCount\r\n          validationRequestedCount\r\n          initiatedAssociationCount\r\n          approvedAssociationCount\r\n          atiOverallScore\r\n          atiOverallConfidence\r\n          atiVersion\r\n          atiComputedAt\r\n          atiBundleJson\r\n          trustLedgerScore\r\n          trustLedgerBadgeCount\r\n          trustLedgerOverallRank\r\n          trustLedgerCapabilityRank\r\n        }\r\n      }\r\n    `;\n        try {\n            const data = await this.client.request(query, {\n                limit: effectiveLimit,\n                offset: effectiveOffset,\n            });\n            const pageAgents = (data.agents || []).map((agent) => {\n                const normalized = this.normalizeAgent(agent);\n                console.log('[AIAgentDiscoveryClient.listAgents] Normalized agent:', {\n                    agentId: normalized.agentId,\n                    rawAgentName: agent.agentName,\n                    normalizedAgentName: normalized.agentName,\n                    agentNameType: typeof normalized.agentName,\n                    hasRawJson: !!normalized.rawJson,\n                });\n                return normalized;\n            });\n            allAgents = allAgents.concat(pageAgents);\n            // Apply client-side ordering to ensure deterministic results,\n            // since the base agents query may not support orderBy/orderDirection\n            // arguments. Default is agentId DESC for \"newest first\".\n            // Default to newest agents first by agentId DESC\n            allAgents.sort((a, b) => {\n                const idA = typeof a.agentId === 'number' ? a.agentId : Number(a.agentId ?? 0) || 0;\n                const idB = typeof b.agentId === 'number' ? b.agentId : Number(b.agentId ?? 0) || 0;\n                return idB - idA;\n            });\n        }\n        catch (error) {\n            console.warn('[AIAgentDiscoveryClient.listAgents] Error fetching agents with pagination:', error);\n        }\n        return allAgents;\n    }\n    /**\n     * Run a semantic search over agents using the discovery indexer's\n     * `semanticAgentSearch` GraphQL field.\n     *\n     * NOTE: This API is best-effort. If the backend does not expose\n     * `semanticAgentSearch`, this will return an empty result instead of\n     * throwing, so callers can fall back gracefully.\n     */\n    async semanticAgentSearch(params) {\n        const rawText = typeof params?.text === 'string' ? params.text : '';\n        const text = rawText.trim();\n        const rawIntentJson = typeof params?.intentJson === 'string' ? params.intentJson : '';\n        const intentJson = rawIntentJson.trim();\n        const topK = typeof params?.topK === 'number' && Number.isFinite(params.topK) && params.topK > 0\n            ? Math.floor(params.topK)\n            : undefined;\n        // Nothing to search.\n        if (!text && !intentJson) {\n            return { total: 0, matches: [] };\n        }\n        const selection = `\r\n      total\r\n      matches {\r\n        score\r\n        matchReasons\r\n        agent {\r\n          chainId\r\n          agentId\r\n          agentName\r\n          agentAccount\r\n          agentIdentityOwnerAccount\r\n          eoaAgentIdentityOwnerAccount\r\n          eoaAgentAccount\r\n          agentCategory\r\n          didIdentity\r\n          didAccount\r\n          didName\r\n          agentUri\r\n          createdAtBlock\r\n          createdAtTime\r\n          updatedAtTime\r\n          type\r\n          description\r\n          image\r\n          a2aEndpoint\r\n          supportedTrust\r\n          rawJson\r\n          agentCardJson\r\n          agentCardReadAt\r\n          did\r\n          mcp\r\n          x402support\r\n          active\r\n          feedbackCount\r\n          feedbackAverageScore\r\n          validationPendingCount\r\n          validationCompletedCount\r\n          validationRequestedCount\r\n          initiatedAssociationCount\r\n          approvedAssociationCount\r\n          atiOverallScore\r\n          atiOverallConfidence\r\n          atiVersion\r\n          atiComputedAt\r\n          atiBundleJson\r\n          trustLedgerScore\r\n          trustLedgerBadgeCount\r\n          trustLedgerOverallRank\r\n          trustLedgerCapabilityRank\r\n          metadata {\r\n            key\r\n            valueText\r\n          }\r\n        }\r\n      }\r\n    `;\n        const query = intentJson\n            ? `\r\n        query SearchByIntent($intentJson: String!, $topK: Int) {\r\n          semanticAgentSearch(input: { intentJson: $intentJson, topK: $topK }) {\r\n            ${selection}\r\n          }\r\n        }\r\n      `\n            : `\r\n        query SearchByText($text: String!) {\r\n          semanticAgentSearch(input: { text: $text }) {\r\n            ${selection}\r\n          }\r\n        }\r\n      `;\n        try {\n            const data = await this.client.request(query, intentJson ? { intentJson, topK } : { text });\n            const root = data.semanticAgentSearch;\n            if (!root) {\n                return { total: 0, matches: [] };\n            }\n            const total = typeof root.total === 'number' && Number.isFinite(root.total) && root.total >= 0\n                ? root.total\n                : Array.isArray(root.matches)\n                    ? root.matches.length\n                    : 0;\n            const matches = [];\n            const rawMatches = Array.isArray(root.matches) ? root.matches : [];\n            for (const item of rawMatches) {\n                if (!item || !item.agent) {\n                    continue;\n                }\n                const normalizedAgent = this.normalizeAgent(item.agent);\n                // Extract metadata entries (if present) into a strongly-typed array.\n                const metadataRaw = item.agent.metadata;\n                let metadata = null;\n                if (Array.isArray(metadataRaw)) {\n                    const entries = [];\n                    for (const entry of metadataRaw) {\n                        if (!entry || typeof entry.key !== 'string')\n                            continue;\n                        entries.push({\n                            key: entry.key,\n                            valueText: entry.valueText === null || entry.valueText === undefined\n                                ? null\n                                : String(entry.valueText),\n                        });\n                    }\n                    if (entries.length > 0) {\n                        metadata = entries;\n                    }\n                }\n                if (metadata) {\n                    normalizedAgent.metadata = metadata;\n                }\n                matches.push({\n                    score: typeof item.score === 'number' && Number.isFinite(item.score)\n                        ? item.score\n                        : null,\n                    matchReasons: Array.isArray(item.matchReasons)\n                        ? item.matchReasons.map((reason) => String(reason))\n                        : null,\n                    agent: normalizedAgent,\n                });\n            }\n            return {\n                total,\n                matches,\n            };\n        }\n        catch (error) {\n            console.warn('[AIAgentDiscoveryClient.semanticAgentSearch] Error performing semantic search:', error);\n            return { total: 0, matches: [] };\n        }\n    }\n    /**\n     * Fetch OASF skills taxonomy from the discovery GraphQL endpoint (best-effort).\n     * Returns [] if the backend does not expose `oasfSkills`.\n     */\n    async oasfSkills(params) {\n        const query = `\r\n      query OasfSkills(\r\n        $key: String\r\n        $nameKey: String\r\n        $category: String\r\n        $extendsKey: String\r\n        $limit: Int\r\n        $offset: Int\r\n        $orderBy: String\r\n        $orderDirection: String\r\n      ) {\r\n        oasfSkills(\r\n          key: $key\r\n          nameKey: $nameKey\r\n          category: $category\r\n          extendsKey: $extendsKey\r\n          limit: $limit\r\n          offset: $offset\r\n          orderBy: $orderBy\r\n          orderDirection: $orderDirection\r\n        ) {\r\n          key\r\n          nameKey\r\n          uid\r\n          caption\r\n          extendsKey\r\n          category\r\n        }\r\n      }\r\n    `;\n        try {\n            const data = await this.client.request(query, {\n                key: params?.key ?? null,\n                nameKey: params?.nameKey ?? null,\n                category: params?.category ?? null,\n                extendsKey: params?.extendsKey ?? null,\n                limit: typeof params?.limit === 'number' ? params.limit : 10000,\n                offset: typeof params?.offset === 'number' ? params.offset : 0,\n                orderBy: params?.orderBy ?? 'category',\n                orderDirection: params?.orderDirection ?? 'ASC',\n            });\n            return Array.isArray(data?.oasfSkills) ? data.oasfSkills : [];\n        }\n        catch (error) {\n            const message = error instanceof Error ? error.message : String(error);\n            // If the backend schema doesn't expose the field, treat it as \"unsupported\".\n            if (message.includes('Cannot query field \"oasfSkills\"')) {\n                return [];\n            }\n            // Some deployments expose the field but error due to resolver returning null for a non-null list.\n            // Treat this as \"taxonomy unavailable\" rather than failing the caller.\n            if (/Cannot return null for non-nullable field\\s+Query\\.oasfSkills\\b/i.test(message)) {\n                return [];\n            }\n            console.warn('[AIAgentDiscoveryClient] oasfSkills query failed:', error);\n            throw error;\n        }\n    }\n    /**\n     * Fetch OASF domains taxonomy from the discovery GraphQL endpoint (best-effort).\n     * Returns [] if the backend does not expose `oasfDomains`.\n     */\n    async oasfDomains(params) {\n        const query = `\r\n      query OasfDomains(\r\n        $key: String\r\n        $nameKey: String\r\n        $category: String\r\n        $extendsKey: String\r\n        $limit: Int\r\n        $offset: Int\r\n        $orderBy: String\r\n        $orderDirection: String\r\n      ) {\r\n        oasfDomains(\r\n          key: $key\r\n          nameKey: $nameKey\r\n          category: $category\r\n          extendsKey: $extendsKey\r\n          limit: $limit\r\n          offset: $offset\r\n          orderBy: $orderBy\r\n          orderDirection: $orderDirection\r\n        ) {\r\n          key\r\n          nameKey\r\n          uid\r\n          caption\r\n          extendsKey\r\n          category\r\n        }\r\n      }\r\n    `;\n        try {\n            const data = await this.client.request(query, {\n                key: params?.key ?? null,\n                nameKey: params?.nameKey ?? null,\n                category: params?.category ?? null,\n                extendsKey: params?.extendsKey ?? null,\n                limit: typeof params?.limit === 'number' ? params.limit : 10000,\n                offset: typeof params?.offset === 'number' ? params.offset : 0,\n                orderBy: params?.orderBy ?? 'category',\n                orderDirection: params?.orderDirection ?? 'ASC',\n            });\n            return Array.isArray(data?.oasfDomains) ? data.oasfDomains : [];\n        }\n        catch (error) {\n            const message = error instanceof Error ? error.message : String(error);\n            if (message.includes('Cannot query field \"oasfDomains\"')) {\n                return [];\n            }\n            if (/Cannot return null for non-nullable field\\s+Query\\.oasfDomains\\b/i.test(message)) {\n                return [];\n            }\n            console.warn('[AIAgentDiscoveryClient] oasfDomains query failed:', error);\n            throw error;\n        }\n    }\n    async searchAgentsAdvanced(options) {\n        console.log('>>>>>>>>>>>>>>>>>> searchAgentsAdvanced', options);\n        const strategy = await this.detectSearchStrategy();\n        const { query, params, limit, offset } = options;\n        const trimmedQuery = typeof query === 'string' ? query.trim() : '';\n        const hasQuery = trimmedQuery.length > 0;\n        const hasParams = params && Object.keys(params).length > 0;\n        if (!hasQuery && !hasParams) {\n            return null;\n        }\n        // If no detected strategy (introspection disabled), attempt a direct list-form searchAgents call.\n        // Only use this fallback if we have a query string, since the GraphQL query requires a non-null query parameter.\n        // If we only have params but no query, return null to trigger local filtering fallback.\n        console.log('>>>>>>>>>>>>>>>>>> 012 strategy', strategy);\n        if (!strategy) {\n            console.log('>>>>>>>>>>>>>>>>>> 012 hasQuery', hasQuery);\n            if (hasQuery) {\n                try {\n                    console.log('>>>>>>>>>>>>>>>>>> 012 trimmedQuery', trimmedQuery);\n                    console.log('>>>>>>>>>>>>>>>>>> 012 limit', limit);\n                    console.log('>>>>>>>>>>>>>>>>>> 012 offset', offset);\n                    console.log('>>>>>>>>>>>>>>>>>> 012 options.orderBy', options.orderBy);\n                    console.log('>>>>>>>>>>>>>>>>>> 012 options.orderDirection', options.orderDirection);\n                    const queryText = `\r\n            query SearchAgentsFallback($query: String!, $limit: Int, $offset: Int, $orderBy: String, $orderDirection: String) {\r\n              searchAgents(query: $query, limit: $limit, offset: $offset, orderBy: $orderBy, orderDirection: $orderDirection) {\r\n                chainId\r\n                agentId\r\n                agentName\r\n                agentAccount\r\n                agentIdentityOwnerAccount\r\n                eoaAgentIdentityOwnerAccount\r\n                eoaAgentAccount\r\n                agentCategory\r\n                didIdentity\r\n                didAccount\r\n                didName\r\n                agentUri\r\n                createdAtBlock\r\n                createdAtTime\r\n                updatedAtTime\r\n                type\r\n                description\r\n                image\r\n                a2aEndpoint\r\n                did\r\n                mcp\r\n                x402support\r\n                active\r\n                supportedTrust\r\n                rawJson\r\n                agentCardJson\r\n                agentCardReadAt\r\n                feedbackCount\r\n                feedbackAverageScore\r\n                validationPendingCount\r\n                validationCompletedCount\r\n                validationRequestedCount\r\n                initiatedAssociationCount\r\n                approvedAssociationCount\r\n                atiOverallScore\r\n                atiOverallConfidence\r\n                atiVersion\r\n                atiComputedAt\r\n                atiBundleJson\r\n                trustLedgerScore\r\n                trustLedgerBadgeCount\r\n                trustLedgerOverallRank\r\n                trustLedgerCapabilityRank\r\n              }\r\n            }\r\n          `;\n                    const variables = {\n                        query: trimmedQuery,\n                        limit: typeof limit === 'number' ? limit : undefined,\n                        offset: typeof offset === 'number' ? offset : undefined,\n                        orderBy: options.orderBy,\n                        orderDirection: options.orderDirection,\n                    };\n                    const data = await this.client.request(queryText, variables);\n                    const list = data?.searchAgents;\n                    console.log('>>>>>>>>>>>>>>>>>> 012 list.length', list?.length);\n                    if (list && list.length > 0) {\n                        console.log('>>>>>>>>>>>>>>>>>> 012 First raw agent sample:', JSON.stringify(list[0], null, 2));\n                    }\n                    if (Array.isArray(list)) {\n                        const normalizedList = list\n                            .filter(Boolean)\n                            .map((item) => {\n                            const rawAgent = item;\n                            const normalized = this.normalizeAgent(rawAgent);\n                            console.log('[AIAgentDiscoveryClient.searchAgentsAdvanced] Normalized agent (fallback):', {\n                                agentId: normalized.agentId,\n                                rawAgentName: rawAgent.agentName,\n                                normalizedAgentName: normalized.agentName,\n                                agentNameType: typeof normalized.agentName,\n                                hasRawJson: !!normalized.rawJson,\n                            });\n                            return normalized;\n                        });\n                        console.log('[AIAgentDiscoveryClient.searchAgentsAdvanced] Returning normalized agents (fallback):', {\n                            count: normalizedList.length,\n                            agentNames: normalizedList.map(a => ({\n                                agentId: a.agentId,\n                                agentName: a.agentName,\n                                agentNameType: typeof a.agentName,\n                            })),\n                        });\n                        // Ensure fallback respects the requested ordering, even if the\n                        // underlying searchAgents resolver uses its own default order.\n                        const orderBy = typeof options.orderBy === 'string' ? options.orderBy.trim() : undefined;\n                        const orderDirectionRaw = typeof options.orderDirection === 'string'\n                            ? options.orderDirection.toUpperCase()\n                            : 'DESC';\n                        const orderDirection = orderDirectionRaw === 'DESC' ? 'DESC' : 'ASC';\n                        if (orderBy === 'agentName') {\n                            normalizedList.sort((a, b) => {\n                                const aName = (a.agentName ?? '').toLowerCase();\n                                const bName = (b.agentName ?? '').toLowerCase();\n                                return orderDirection === 'ASC'\n                                    ? aName.localeCompare(bName)\n                                    : bName.localeCompare(aName);\n                            });\n                        }\n                        else if (orderBy === 'agentId') {\n                            normalizedList.sort((a, b) => {\n                                const idA = typeof a.agentId === 'number'\n                                    ? a.agentId\n                                    : Number(a.agentId ?? 0) || 0;\n                                const idB = typeof b.agentId === 'number'\n                                    ? b.agentId\n                                    : Number(b.agentId ?? 0) || 0;\n                                return orderDirection === 'ASC' ? idA - idB : idB - idA;\n                            });\n                        }\n                        else if (orderBy === 'createdAtTime') {\n                            normalizedList.sort((a, b) => {\n                                const tA = typeof a.createdAtTime === 'number'\n                                    ? a.createdAtTime\n                                    : Number(a.createdAtTime ?? 0) || 0;\n                                const tB = typeof b.createdAtTime === 'number'\n                                    ? b.createdAtTime\n                                    : Number(b.createdAtTime ?? 0) || 0;\n                                return orderDirection === 'ASC' ? tA - tB : tB - tA;\n                            });\n                        }\n                        else if (orderBy === 'createdAtBlock') {\n                            normalizedList.sort((a, b) => {\n                                const bA = typeof a.createdAtBlock === 'number'\n                                    ? a.createdAtBlock\n                                    : Number(a.createdAtBlock ?? 0) || 0;\n                                const bB = typeof b.createdAtBlock === 'number'\n                                    ? b.createdAtBlock\n                                    : Number(b.createdAtBlock ?? 0) || 0;\n                                return orderDirection === 'ASC' ? bA - bB : bB - bA;\n                            });\n                        }\n                        console.log('>>>>>>>>>>>>>>>>>> 345 AdvancedSearch', normalizedList);\n                        return { agents: normalizedList, total: undefined };\n                    }\n                }\n                catch (error) {\n                    console.warn('[AIAgentDiscoveryClient] Fallback searchAgents call failed:', error);\n                }\n            }\n            // If no strategy and no query (only params), return null to trigger local filtering fallback\n            return null;\n        }\n        const variables = {};\n        const variableDefinitions = [];\n        const argumentAssignments = [];\n        const agentSelection = `\r\n      chainId\r\n      agentId\r\n      agentName\r\n      agentAccount\r\n      agentIdentityOwnerAccount\r\n      eoaAgentIdentityOwnerAccount\r\n      eoaAgentAccount\r\n      agentCategory\r\n      didIdentity\r\n      didAccount\r\n      didName\r\n      agentUri\r\n      createdAtBlock\r\n      createdAtTime\r\n      updatedAtTime\r\n      type\r\n      description\r\n      image\r\n      a2aEndpoint\r\n      did\r\n      mcp\r\n      x402support\r\n      active\r\n      supportedTrust\r\n      rawJson\r\n      feedbackCount\r\n      feedbackAverageScore\r\n      validationPendingCount\r\n      validationCompletedCount\r\n      validationRequestedCount\r\n    `;\n        const addStringArg = (arg, value) => {\n            if (!arg)\n                return !value;\n            if (!value) {\n                return arg.isNonNull ? false : true;\n            }\n            const typeName = arg.typeName ?? 'String';\n            variableDefinitions.push(`$${arg.name}: ${typeName}${arg.isNonNull ? '!' : ''}`);\n            argumentAssignments.push(`${arg.name}: $${arg.name}`);\n            variables[arg.name] = value;\n            return true;\n        };\n        const addInputArg = (arg, value) => {\n            if (!arg)\n                return !value;\n            if (!value || Object.keys(value).length === 0) {\n                return arg.isNonNull ? false : true;\n            }\n            const typeName = arg.typeName ?? 'JSON';\n            variableDefinitions.push(`$${arg.name}: ${typeName}${arg.isNonNull ? '!' : ''}`);\n            argumentAssignments.push(`${arg.name}: $${arg.name}`);\n            variables[arg.name] = value;\n            return true;\n        };\n        const addIntArg = (arg, value) => {\n            if (!arg)\n                return;\n            if (value === undefined || value === null) {\n                if (arg.isNonNull) {\n                    return;\n                }\n                return;\n            }\n            const typeName = arg.typeName ?? 'Int';\n            variableDefinitions.push(`$${arg.name}: ${typeName}${arg.isNonNull ? '!' : ''}`);\n            argumentAssignments.push(`${arg.name}: $${arg.name}`);\n            variables[arg.name] = value;\n        };\n        if (strategy.kind === 'connection') {\n            // Add query arg only if we have a query, or if queryArg is optional\n            // If queryArg is required (non-null) but we don't have a query, only proceed if we have params\n            const queryArgAdded = addStringArg(strategy.queryArg, hasQuery ? trimmedQuery : undefined);\n            if (!queryArgAdded && strategy.queryArg?.isNonNull && !hasParams) {\n                // Required query arg but no query and no params - can't proceed\n                return null;\n            }\n            // Add filter arg if we have params\n            const filterArgAdded = addInputArg(strategy.filterArg, hasParams ? params : undefined);\n            if (!filterArgAdded && strategy.filterArg?.isNonNull && !hasQuery) {\n                // Required filter arg but no params and no query - can't proceed\n                return null;\n            }\n            // If neither query nor params were added, and both are optional, we need at least one\n            if (!queryArgAdded && !filterArgAdded && (!strategy.queryArg || !strategy.filterArg)) {\n                return null;\n            }\n            addIntArg(strategy.limitArg, typeof limit === 'number' ? limit : undefined);\n            addIntArg(strategy.offsetArg, typeof offset === 'number' ? offset : undefined);\n            addStringArg(strategy.orderByArg, options.orderBy);\n            addStringArg(strategy.orderDirectionArg, options.orderDirection);\n            if (argumentAssignments.length === 0) {\n                return null;\n            }\n            console.log('>>>>>>>>>>>>>>>>>> AdvancedSearch', variableDefinitions, argumentAssignments);\n            const queryText = `\r\n        query AdvancedSearch(${variableDefinitions.join(', ')}) {\r\n          ${strategy.fieldName}(${argumentAssignments.join(', ')}) {\r\n            ${strategy.totalFieldName ? `${strategy.totalFieldName}` : ''}\r\n            ${strategy.listFieldName} {\r\n              chainId\r\n              agentId\r\n              agentAccount\r\n              agentName\r\n              agentIdentityOwnerAccount\r\n              eoaAgentIdentityOwnerAccount\r\n              eoaAgentAccount\r\n              agentCategory\r\n              didIdentity\r\n              didAccount\r\n              didName\r\n              agentUri\r\n              createdAtBlock\r\n              createdAtTime\r\n              updatedAtTime\r\n              type\r\n              description\r\n              image\r\n              a2aEndpoint\r\n              did\r\n              mcp\r\n              x402support\r\n              active\r\n              supportedTrust\r\n              rawJson\r\n              agentCardJson\r\n              agentCardReadAt\r\n            }\r\n          }\r\n        }\r\n      `;\n            try {\n                const data = await this.client.request(queryText, variables);\n                const node = data?.[strategy.fieldName];\n                if (!node)\n                    return null;\n                const list = node?.[strategy.listFieldName];\n                if (!Array.isArray(list))\n                    return null;\n                const totalValue = typeof strategy.totalFieldName === 'string' ? node?.[strategy.totalFieldName] : undefined;\n                console.log('>>>>>>>>>>>>>>>>>> 123 AdvancedSearch', list);\n                return {\n                    agents: list.filter(Boolean),\n                    total: typeof totalValue === 'number' ? totalValue : undefined,\n                };\n            }\n            catch (error) {\n                console.warn('[AIAgentDiscoveryClient] Advanced connection search failed:', error);\n                this.searchStrategy = null;\n                return null;\n            }\n        }\n        if (strategy.kind === 'list') {\n            console.log('>>>>>>>>>>>>>>>>>> AdvancedSearchList', variableDefinitions, argumentAssignments);\n            if (!addStringArg(strategy.queryArg, hasQuery ? trimmedQuery : undefined)) {\n                return null;\n            }\n            addIntArg(strategy.limitArg, typeof limit === 'number' ? limit : undefined);\n            addIntArg(strategy.offsetArg, typeof offset === 'number' ? offset : undefined);\n            addStringArg(strategy.orderByArg, options.orderBy);\n            addStringArg(strategy.orderDirectionArg, options.orderDirection);\n            if (argumentAssignments.length === 0) {\n                return null;\n            }\n            const queryText = `\r\n        query AdvancedSearchList(${variableDefinitions.join(', ')}) {\r\n          ${strategy.fieldName}(${argumentAssignments.join(', ')}) {\r\n            ${agentSelection}\r\n          }\r\n        }\r\n      `;\n            try {\n                const data = await this.client.request(queryText, variables);\n                const list = data?.[strategy.fieldName];\n                if (!Array.isArray(list))\n                    return null;\n                const agents = list\n                    .filter(Boolean)\n                    .map((item) => {\n                    const rawAgent = item;\n                    const normalized = this.normalizeAgent(rawAgent);\n                    console.log('[AIAgentDiscoveryClient.searchAgentsAdvanced] Normalized agent (strategy):', {\n                        agentId: normalized.agentId,\n                        rawAgentName: rawAgent.agentName,\n                        normalizedAgentName: normalized.agentName,\n                        agentNameType: typeof normalized.agentName,\n                        hasRawJson: !!normalized.rawJson,\n                    });\n                    return normalized;\n                });\n                console.log('[AIAgentDiscoveryClient.searchAgentsAdvanced] Returning normalized agents (strategy):', {\n                    count: agents.length,\n                    agentNames: agents.map(a => ({\n                        agentId: a.agentId,\n                        agentName: a.agentName,\n                        agentNameType: typeof a.agentName,\n                    })),\n                });\n                return {\n                    agents,\n                    total: undefined,\n                };\n            }\n            catch (error) {\n                console.warn('[AIAgentDiscoveryClient] Advanced list search failed:', error);\n                this.searchStrategy = null;\n                return null;\n            }\n        }\n        return null;\n    }\n    /**\n     * Search agents using the strongly-typed AgentWhereInput / searchAgentsGraph API.\n     * This is tailored to the indexer schema that exposes AgentWhereInput and\n     * searchAgentsGraph(where:, first:, skip:, orderBy:, orderDirection:).\n     */\n    async searchAgentsGraph(options) {\n        const query = `\r\n      query SearchAgentsGraph(\r\n        $where: AgentWhereInput\r\n        $first: Int\r\n        $skip: Int\r\n        $orderBy: AgentOrderBy\r\n        $orderDirection: OrderDirection\r\n      ) {\r\n        searchAgentsGraph(\r\n          where: $where\r\n          first: $first\r\n          skip: $skip\r\n          orderBy: $orderBy\r\n          orderDirection: $orderDirection\r\n        ) {\r\n          agents {\r\n            chainId\r\n            agentId\r\n            agentAccount\r\n            agentName\r\n            agentIdentityOwnerAccount\r\n            eoaAgentIdentityOwnerAccount\r\n            eoaAgentAccount\r\n            agentCategory\r\n            didIdentity\r\n            didAccount\r\n            didName\r\n            agentUri\r\n            createdAtBlock\r\n            createdAtTime\r\n            updatedAtTime\r\n            type\r\n            description\r\n            image\r\n            a2aEndpoint\r\n            supportedTrust\r\n            rawJson\r\n            agentCardJson\r\n            agentCardReadAt\r\n            did\r\n            mcp\r\n            x402support\r\n            active\r\n            feedbackCount\r\n            feedbackAverageScore\r\n            validationPendingCount\r\n            validationCompletedCount\r\n            validationRequestedCount\r\n            initiatedAssociationCount\r\n            approvedAssociationCount\r\n            atiOverallScore\r\n            atiOverallConfidence\r\n            atiVersion\r\n            atiComputedAt\r\n            atiBundleJson\r\n            trustLedgerScore\r\n            trustLedgerBadgeCount\r\n            trustLedgerOverallRank\r\n            trustLedgerCapabilityRank\r\n          }\r\n          total\r\n          hasMore\r\n        }\r\n      }\r\n    `;\n        // Default ordering when not explicitly provided: newest agents first\n        // by agentId DESC.\n        const effectiveOrderBy = options.orderBy ?? 'agentId';\n        const effectiveOrderDirection = (options.orderDirection ?? 'DESC').toUpperCase() === 'ASC' ? 'ASC' : 'DESC';\n        const variables = {\n            where: options.where,\n            first: typeof options.first === 'number' ? options.first : undefined,\n            skip: typeof options.skip === 'number' ? options.skip : undefined,\n            orderBy: effectiveOrderBy,\n            orderDirection: effectiveOrderDirection,\n        };\n        const data = await this.client.request(query, variables);\n        const result = data.searchAgentsGraph ?? { agents: [], total: 0, hasMore: false };\n        const agents = (result.agents ?? []).map((agent) => {\n            const rawAgent = agent;\n            const normalized = this.normalizeAgent(rawAgent);\n            return normalized;\n        });\n        return {\n            agents,\n            total: typeof result.total === 'number' ? result.total : agents.length,\n            hasMore: Boolean(result.hasMore),\n        };\n    }\n    async detectSearchStrategy() {\n        if (this.searchStrategy !== undefined) {\n            return this.searchStrategy;\n        }\n        if (this.searchStrategyPromise) {\n            return this.searchStrategyPromise;\n        }\n        this.searchStrategyPromise = (async () => {\n            try {\n                const data = await this.client.request(INTROSPECTION_QUERY);\n                const fields = data.__schema?.queryType?.fields ?? [];\n                const candidateNames = ['searchAgentsAdvanced', 'searchAgents'];\n                for (const candidate of candidateNames) {\n                    const field = fields.find((f) => f.name === candidate);\n                    if (!field)\n                        continue;\n                    const strategy = await this.buildStrategyFromField(field);\n                    if (strategy) {\n                        this.searchStrategy = strategy;\n                        return strategy;\n                    }\n                }\n            }\n            catch (error) {\n                console.warn('[AIAgentDiscoveryClient] Failed to introspect search capabilities:', error);\n            }\n            finally {\n                this.searchStrategyPromise = undefined;\n            }\n            this.searchStrategy = null;\n            return null;\n        })();\n        return this.searchStrategyPromise;\n    }\n    async buildStrategyFromField(field) {\n        const baseReturn = unwrapType(field.type);\n        if (!baseReturn)\n            return null;\n        const limitArg = field.args.find((arg) => arg.name === 'limit') ??\n            field.args.find((arg) => arg.name === 'first');\n        const offsetArg = field.args.find((arg) => arg.name === 'offset') ??\n            field.args.find((arg) => arg.name === 'skip');\n        const queryArg = field.args.find((arg) => arg.name === 'query') ??\n            field.args.find((arg) => arg.name === 'term') ??\n            field.args.find((arg) => arg.name === 'search');\n        const filterArg = field.args.find((arg) => arg.name === 'params') ??\n            field.args.find((arg) => arg.name === 'filters');\n        const orderByArg = field.args.find((arg) => arg.name === 'orderBy');\n        const orderDirectionArg = field.args.find((arg) => arg.name === 'orderDirection');\n        if (baseReturn.kind === 'OBJECT' && baseReturn.name) {\n            const connectionFields = await this.getTypeFields(baseReturn.name);\n            if (!connectionFields) {\n                return null;\n            }\n            const listField = connectionFields.find((f) => isListOf(f.type, 'Agent'));\n            if (!listField) {\n                return null;\n            }\n            const totalField = connectionFields.find((f) => f.name === 'total') ??\n                connectionFields.find((f) => f.name === 'totalCount') ??\n                connectionFields.find((f) => f.name === 'count');\n            return {\n                kind: 'connection',\n                fieldName: field.name,\n                listFieldName: listField.name,\n                totalFieldName: totalField?.name,\n                queryArg: queryArg\n                    ? {\n                        name: queryArg.name,\n                        typeName: unwrapToTypeName(queryArg.type),\n                        isNonNull: isNonNull(queryArg.type),\n                    }\n                    : undefined,\n                filterArg: filterArg\n                    ? {\n                        name: filterArg.name,\n                        typeName: unwrapToTypeName(filterArg.type),\n                        isNonNull: isNonNull(filterArg.type),\n                    }\n                    : undefined,\n                limitArg: limitArg\n                    ? {\n                        name: limitArg.name,\n                        typeName: unwrapToTypeName(limitArg.type),\n                        isNonNull: isNonNull(limitArg.type),\n                    }\n                    : undefined,\n                offsetArg: offsetArg\n                    ? {\n                        name: offsetArg.name,\n                        typeName: unwrapToTypeName(offsetArg.type),\n                        isNonNull: isNonNull(offsetArg.type),\n                    }\n                    : undefined,\n                orderByArg: orderByArg\n                    ? {\n                        name: orderByArg.name,\n                        typeName: unwrapToTypeName(orderByArg.type),\n                        isNonNull: isNonNull(orderByArg.type),\n                    }\n                    : undefined,\n                orderDirectionArg: orderDirectionArg\n                    ? {\n                        name: orderDirectionArg.name,\n                        typeName: unwrapToTypeName(orderDirectionArg.type),\n                        isNonNull: isNonNull(orderDirectionArg.type),\n                    }\n                    : undefined,\n            };\n        }\n        if (isListOf(field.type, 'Agent')) {\n            return {\n                kind: 'list',\n                fieldName: field.name,\n                queryArg: queryArg\n                    ? {\n                        name: queryArg.name,\n                        typeName: unwrapToTypeName(queryArg.type),\n                        isNonNull: isNonNull(queryArg.type),\n                    }\n                    : undefined,\n                limitArg: limitArg\n                    ? {\n                        name: limitArg.name,\n                        typeName: unwrapToTypeName(limitArg.type),\n                        isNonNull: isNonNull(limitArg.type),\n                    }\n                    : undefined,\n                offsetArg: offsetArg\n                    ? {\n                        name: offsetArg.name,\n                        typeName: unwrapToTypeName(offsetArg.type),\n                        isNonNull: isNonNull(offsetArg.type),\n                    }\n                    : undefined,\n                orderByArg: orderByArg\n                    ? {\n                        name: orderByArg.name,\n                        typeName: unwrapToTypeName(orderByArg.type),\n                        isNonNull: isNonNull(orderByArg.type),\n                    }\n                    : undefined,\n                orderDirectionArg: orderDirectionArg\n                    ? {\n                        name: orderDirectionArg.name,\n                        typeName: unwrapToTypeName(orderDirectionArg.type),\n                        isNonNull: isNonNull(orderDirectionArg.type),\n                    }\n                    : undefined,\n            };\n        }\n        return null;\n    }\n    async getTypeFields(typeName) {\n        if (this.typeFieldsCache.has(typeName)) {\n            return this.typeFieldsCache.get(typeName) ?? null;\n        }\n        try {\n            const data = await this.client.request(TYPE_FIELDS_QUERY, { name: typeName });\n            const fields = data.__type?.fields ?? null;\n            this.typeFieldsCache.set(typeName, fields ?? null);\n            return fields ?? null;\n        }\n        catch (error) {\n            console.warn(`[AIAgentDiscoveryClient] Failed to introspect type fields for ${typeName}:`, error);\n            this.typeFieldsCache.set(typeName, null);\n            return null;\n        }\n    }\n    /**\n     * Some indexers expose `metadata { key valueText }`, others expose `metadata { key value }`.\n     * Introspect once and cache so we can query metadata reliably.\n     */\n    async getAgentMetadataValueField() {\n        if (this.agentMetadataValueField !== undefined) {\n            return this.agentMetadataValueField;\n        }\n        try {\n            const agentFields = await this.getTypeFields('Agent');\n            const metadataField = agentFields?.find((f) => f?.name === 'metadata');\n            const metadataType = unwrapType(metadataField?.type);\n            const metadataTypeName = metadataType?.name ?? null;\n            if (!metadataTypeName) {\n                this.agentMetadataValueField = null;\n                return null;\n            }\n            const metadataFields = await this.getTypeFields(metadataTypeName);\n            const fieldNames = new Set((metadataFields ?? [])\n                .map((f) => f?.name)\n                .filter((name) => typeof name === 'string' && name.length > 0));\n            if (fieldNames.has('valueText')) {\n                this.agentMetadataValueField = 'valueText';\n                return 'valueText';\n            }\n            if (fieldNames.has('value')) {\n                this.agentMetadataValueField = 'value';\n                return 'value';\n            }\n            this.agentMetadataValueField = null;\n            return null;\n        }\n        catch {\n            // If schema blocks introspection, fall back to historical `valueText`.\n            this.agentMetadataValueField = 'valueText';\n            return 'valueText';\n        }\n    }\n    /**\n     * Get all token metadata from The Graph indexer for an agent\n     * Uses tokenMetadata_collection query to get all metadata key-value pairs\n     * Handles pagination if an agent has more than 1000 metadata entries\n     * @param chainId - Chain ID\n     * @param agentId - Agent ID\n     * @returns Record of all metadata key-value pairs, or null if not available\n     */\n    async getTokenMetadata(chainId, agentId) {\n        // If we already learned the GraphQL schema doesn't support this query field,\n        // skip to avoid repeated GRAPHQL_VALIDATION_FAILED warnings.\n        if (this.tokenMetadataCollectionSupported === false) {\n            return null;\n        }\n        // Newer indexer schemas may not expose tokenMetadata_collection anymore.\n        // Avoid spamming logs / failing requests by introspecting once and bailing out if unsupported.\n        try {\n            const queryFields = await this.getTypeFields('Query');\n            const hasTokenMetadataCollection = Boolean(queryFields?.some((f) => f?.name === 'tokenMetadata_collection'));\n            if (!hasTokenMetadataCollection) {\n                this.tokenMetadataCollectionSupported = false;\n                // tokenMetadataById may exist, but it doesn't help us enumerate all metadata pairs.\n                // We only use this method as a best-effort fallback, so return null when unsupported.\n                return null;\n            }\n            this.tokenMetadataCollectionSupported = true;\n        }\n        catch (e) {\n            // If introspection fails, keep existing behavior (attempt the query; it will be caught below).\n        }\n        const metadata = {};\n        const pageSize = 1000; // The Graph's default page size\n        let skip = 0;\n        let hasMore = true;\n        while (hasMore) {\n            const query = `\r\n        query GetTokenMetadata($chainId: Int!, $agentId: String!, $first: Int!, $skip: Int!) {\r\n          tokenMetadata_collection(\r\n            chainId: $chainId\r\n            agentId: $agentId\r\n            first: $first\r\n            skip: $skip\r\n          ) {\r\n            key\r\n            value\r\n            id\r\n            indexedKey\r\n          }\r\n        }\r\n      `;\n            try {\n                const data = await this.client.request(query, {\n                    chainId,\n                    agentId: String(agentId),\n                    first: pageSize,\n                    skip: skip,\n                });\n                if (!data.tokenMetadata_collection || !Array.isArray(data.tokenMetadata_collection)) {\n                    hasMore = false;\n                    break;\n                }\n                // Add entries from this page\n                for (const entry of data.tokenMetadata_collection) {\n                    if (entry.key && entry.value) {\n                        metadata[entry.key] = entry.value;\n                    }\n                }\n                // Check if we got a full page (might have more)\n                hasMore = data.tokenMetadata_collection.length === pageSize;\n                skip += pageSize;\n                // Safety check: The Graph has a max skip of 5000\n                // If we've reached that, we can't fetch more (unlikely for a single agent)\n                if (skip >= 5000) {\n                    console.warn(`[AIAgentDiscoveryClient.getTokenMetadata] Reached The Graph skip limit (5000) for agent ${agentId}`);\n                    hasMore = false;\n                }\n            }\n            catch (error) {\n                // Some indexers have evolved schema and removed `tokenMetadata_collection`.\n                // graphql-request surfaces this as GRAPHQL_VALIDATION_FAILED; treat it as \"not supported\"\n                // and disable future attempts for this client instance.\n                const responseErrors = error?.response?.errors;\n                const schemaDoesNotSupportCollection = Array.isArray(responseErrors) &&\n                    responseErrors.some((e) => typeof e?.message === 'string' &&\n                        e.message.includes('tokenMetadata_collection') &&\n                        (e?.extensions?.code === 'GRAPHQL_VALIDATION_FAILED' ||\n                            e.message.includes('Cannot query field')));\n                if (schemaDoesNotSupportCollection) {\n                    this.tokenMetadataCollectionSupported = false;\n                    if (Object.keys(metadata).length > 0) {\n                        return metadata;\n                    }\n                    return null;\n                }\n                console.warn('[AIAgentDiscoveryClient.getTokenMetadata] Error fetching token metadata from GraphQL:', error);\n                // If we got some metadata before the error, return what we have\n                if (Object.keys(metadata).length > 0) {\n                    return metadata;\n                }\n                return null;\n            }\n        }\n        return Object.keys(metadata).length > 0 ? metadata : null;\n    }\n    /**\n     * Get a single agent by ID with metadata\n     * @param chainId - Chain ID (required by schema)\n     * @param agentId - Agent ID to fetch\n     * @returns Agent data with metadata or null if not found\n     */\n    async getAgent(chainId, agentId) {\n        const metadataValueField = await this.getAgentMetadataValueField();\n        const metadataSelection = metadataValueField === 'valueText'\n            ? `\r\n            metadata {\r\n              key\r\n              valueText\r\n            }`\n            : metadataValueField === 'value'\n                ? `\r\n            metadata {\r\n              key\r\n              valueText: value\r\n            }`\n                : '';\n        // Try searchAgentsGraph first to get metadata\n        const graphQuery = `\r\n      query GetAgentWithMetadata($where: AgentWhereInput, $first: Int) {\r\n        searchAgentsGraph(\r\n          where: $where\r\n          first: $first\r\n        ) {\r\n          agents {\r\n            chainId\r\n            agentId\r\n            agentAccount\r\n            agentName\r\n            agentIdentityOwnerAccount\r\n            eoaAgentIdentityOwnerAccount\r\n            eoaAgentAccount\r\n            agentCategory\r\n            didIdentity\r\n            didAccount\r\n            didName\r\n            agentUri\r\n            createdAtBlock\r\n            createdAtTime\r\n            updatedAtTime\r\n            type\r\n            description\r\n            image\r\n            a2aEndpoint\r\n            did\r\n            mcp\r\n            x402support\r\n            active\r\n            supportedTrust\r\n            rawJson\r\n            agentCardJson\r\n            agentCardReadAt\r\n            feedbackCount\r\n            feedbackAverageScore\r\n            validationPendingCount\r\n            validationCompletedCount\r\n            validationRequestedCount\r\n            initiatedAssociationCount\r\n            approvedAssociationCount\r\n            atiOverallScore\r\n            atiOverallConfidence\r\n            atiVersion\r\n            atiComputedAt\r\n            atiBundleJson\r\n            trustLedgerScore\r\n            trustLedgerBadgeCount\r\n            trustLedgerOverallRank\r\n            trustLedgerCapabilityRank\r\n${metadataSelection}\r\n          }\r\n        }\r\n      }\r\n    `;\n        try {\n            const graphData = await this.client.request(graphQuery, {\n                where: {\n                    chainId,\n                    agentId: String(agentId),\n                },\n                first: 1,\n            });\n            if (graphData.searchAgentsGraph?.agents && graphData.searchAgentsGraph.agents.length > 0) {\n                const agentData = graphData.searchAgentsGraph.agents[0];\n                if (!agentData) {\n                    return null;\n                }\n                // Convert metadata array to record and add to agent data\n                const normalized = this.normalizeAgent(agentData);\n                if (agentData.metadata && Array.isArray(agentData.metadata)) {\n                    // Add metadata as a flat object on the agent data\n                    for (const meta of agentData.metadata) {\n                        if (meta.key && meta.valueText) {\n                            normalized[meta.key] = meta.valueText;\n                        }\n                    }\n                    // Also store as metadata property for easy access\n                    normalized.metadata = agentData.metadata.reduce((acc, meta) => {\n                        if (meta.key && meta.valueText) {\n                            acc[meta.key] = meta.valueText;\n                        }\n                        return acc;\n                    }, {});\n                }\n                return normalized;\n            }\n        }\n        catch (error) {\n            console.warn('[AIAgentDiscoveryClient.getAgent] GraphQL searchAgentsGraph failed, trying fallback:', error);\n        }\n        // Fallback to original agent query if searchAgentsGraph doesn't work\n        const query = `\r\n      query GetAgent($chainId: Int!, $agentId: String!) {\r\n        agent(chainId: $chainId, agentId: $agentId) {\r\n          chainId\r\n          agentId\r\n          agentAccount\r\n          agentName\r\n          agentIdentityOwnerAccount\r\n          eoaAgentIdentityOwnerAccount\r\n          eoaAgentAccount\r\n          agentCategory\r\n          didIdentity\r\n          didAccount\r\n          didName\r\n          agentUri\r\n          createdAtBlock\r\n          createdAtTime\r\n          updatedAtTime\r\n          type\r\n          description\r\n          image\r\n          a2aEndpoint\r\n          did\r\n          mcp\r\n          x402support\r\n          active\r\n          supportedTrust\r\n          rawJson\r\n          agentCardJson\r\n          agentCardReadAt\r\n          atiOverallScore\r\n          atiOverallConfidence\r\n          atiVersion\r\n          atiComputedAt\r\n          atiBundleJson\r\n          trustLedgerScore\r\n          trustLedgerBadgeCount\r\n          trustLedgerOverallRank\r\n          trustLedgerCapabilityRank\r\n        }\r\n      }\r\n    `;\n        try {\n            const data = await this.client.request(query, {\n                chainId,\n                agentId: String(agentId),\n            });\n            if (!data.agent) {\n                return null;\n            }\n            return this.normalizeAgent(data.agent);\n        }\n        catch (error) {\n            console.error('[AIAgentDiscoveryClient.getAgent] Error fetching agent:', error);\n            return null;\n        }\n    }\n    async getAgentByName(agentName) {\n        const query = `\r\n      query GetAgentByName($agentName: String!) {\r\n        agentByName(agentName: $agentName) {\r\n          chainId\r\n          agentId\r\n          agentAccount\r\n          agentName\r\n          agentIdentityOwnerAccount\r\n          eoaAgentIdentityOwnerAccount\r\n          eoaAgentAccount\r\n          agentCategory\r\n          didIdentity\r\n      didAccount\r\n      didName\r\n      agentUri\r\n          createdAtBlock\r\n          createdAtTime\r\n          updatedAtTime\r\n          type\r\n          description\r\n          image\r\n          a2aEndpoint\r\n          did\r\n          mcp\r\n          x402support\r\n          active\r\n          supportedTrust\r\n          rawJson\r\n          agentCardJson\r\n          agentCardReadAt\r\n          atiOverallScore\r\n          atiOverallConfidence\r\n          atiVersion\r\n          atiComputedAt\r\n          atiBundleJson\r\n          trustLedgerScore\r\n          trustLedgerBadgeCount\r\n          trustLedgerOverallRank\r\n          trustLedgerCapabilityRank\r\n        }\r\n      }\r\n    `;\n        try {\n            const data = await this.client.request(query, {\n                agentName,\n            });\n            console.log(\"*********** AIAgentDiscoveryClient.getAgentByName: data\", data);\n            if (!data.agentByName) {\n                return null;\n            }\n            return this.normalizeAgent(data.agentByName);\n        }\n        catch (error) {\n            console.error('[AIAgentDiscoveryClient.getAgentByName] Error fetching agent:', error);\n            return null;\n        }\n    }\n    /**\n     * Search agents by name\n     * @param searchTerm - Search term to match against agent names\n     * @param limit - Maximum number of results\n     * @returns List of matching agents\n     */\n    async searchAgents(searchTerm, limit) {\n        const query = `\r\n      query SearchAgents($query: String!, $limit: Int) {\r\n        searchAgents(query: $query, limit: $limit) {\r\n          chainId\r\n          agentId\r\n          agentAccount\r\n          agentName\r\n          agentIdentityOwnerAccount\r\n          eoaAgentIdentityOwnerAccount\r\n          eoaAgentAccount\r\n          agentCategory\r\n          didIdentity\r\n          didAccount\r\n          didName\r\n          agentUri\r\n          createdAtBlock\r\n          createdAtTime\r\n          updatedAtTime\r\n          type\r\n          description\r\n          image\r\n          a2aEndpoint\r\n          did\r\n          mcp\r\n          x402support\r\n          active\r\n          supportedTrust\r\n          rawJson\r\n          agentCardJson\r\n          agentCardReadAt\r\n          atiOverallScore\r\n          atiOverallConfidence\r\n          atiVersion\r\n          atiComputedAt\r\n          atiBundleJson\r\n          trustLedgerScore\r\n          trustLedgerBadgeCount\r\n          trustLedgerOverallRank\r\n          trustLedgerCapabilityRank\r\n        }\r\n      }\r\n    `;\n        try {\n            const data = await this.client.request(query, {\n                query: searchTerm,\n                limit: limit || 100,\n            });\n            const agents = data.searchAgents || [];\n            return agents.map((agent) => this.normalizeAgent(agent));\n        }\n        catch (error) {\n            console.error('[AIAgentDiscoveryClient.searchAgents] Error searching agents:', error);\n            throw error;\n        }\n    }\n    /**\n     * Refresh/Index an agent in the indexer\n     * Triggers the indexer to re-index the specified agent\n     * @param agentId - Agent ID to refresh (required)\n     * @param chainId - Optional chain ID (if not provided, indexer may use default)\n     * @param apiKey - Optional API key override (uses config API key if not provided)\n     * @returns Refresh result with success status and processed chains\n     */\n    async refreshAgent(agentId, chainId, apiKey) {\n        const mutation = `\r\n      mutation IndexAgent($agentId: String!, $chainId: Int) {\r\n        indexAgent(agentId: $agentId, chainId: $chainId) {\r\n          success\r\n          message\r\n          processedChains\r\n        }\r\n      }\r\n    `;\n        const variables = {\n            agentId: String(agentId),\n        };\n        if (chainId !== undefined) {\n            variables.chainId = chainId;\n        }\n        // If API key override is provided, create a temporary client with that key\n        let clientToUse = this.client;\n        if (apiKey) {\n            const headers = {\n                'Content-Type': 'application/json',\n                ...(this.config.headers || {}),\n                'Authorization': `Bearer ${apiKey}`,\n            };\n            clientToUse = new graphql_request__WEBPACK_IMPORTED_MODULE_0__.GraphQLClient(this.config.endpoint, {\n                headers,\n            });\n        }\n        try {\n            const data = await clientToUse.request(mutation, variables);\n            return data.indexAgent;\n        }\n        catch (error) {\n            console.error('[AIAgentDiscoveryClient.refreshAgent] Error refreshing agent:', error);\n            throw new Error(`Failed to refresh agent: ${error instanceof Error ? error.message : 'Unknown error'}`);\n        }\n    }\n    /**\n     * Search validation requests for an agent using GraphQL\n     */\n    async searchValidationRequestsAdvanced(options) {\n        const { chainId, agentId, limit = 10, offset = 0, orderBy = 'blockNumber', orderDirection = 'DESC' } = options;\n        const agentIdString = typeof agentId === 'number' ? agentId.toString() : agentId;\n        const queryText = `\r\n      query ValidationRequestsForAgent(\r\n        $agentId: String!\r\n        $limit: Int\r\n        $offset: Int\r\n        $orderBy: String\r\n        $orderDirection: String\r\n      ) {\r\n        validationRequests(\r\n          agentId: $agentId\r\n          limit: $limit\r\n          offset: $offset\r\n          orderBy: $orderBy\r\n          orderDirection: $orderDirection\r\n        ) {\r\n          id\r\n          agentId\r\n          validatorAddress\r\n          requestUri\r\n          requestJson\r\n          requestHash\r\n          txHash\r\n          blockNumber\r\n          timestamp\r\n          createdAt\r\n          updatedAt\r\n        }\r\n      }\r\n    `;\n        const variables = {\n            agentId: agentIdString,\n            limit: typeof limit === 'number' ? limit : undefined,\n            offset: typeof offset === 'number' ? offset : undefined,\n            orderBy: typeof orderBy === 'string' ? orderBy : undefined,\n            orderDirection: typeof orderDirection === 'string' ? orderDirection : undefined,\n        };\n        try {\n            const data = await this.client.request(queryText, variables);\n            const requests = data?.validationRequests;\n            if (!Array.isArray(requests)) {\n                return null;\n            }\n            return {\n                validationRequests: requests.filter(Boolean),\n            };\n        }\n        catch (error) {\n            console.warn('[AIAgentDiscoveryClient] searchValidationRequestsAdvanced failed:', error);\n            return null;\n        }\n    }\n    /**\n     * Search feedback for an agent using GraphQL\n     */\n    async searchFeedbackAdvanced(options) {\n        const { chainId, agentId, limit = 10, offset = 0, orderBy = 'timestamp', orderDirection = 'DESC' } = options;\n        const agentIdString = typeof agentId === 'number' ? agentId.toString() : agentId;\n        const queryText = `\r\n      query FeedbackForAgent(\r\n        $chainId: Int!\r\n        $agentId: String!\r\n        $limit: Int\r\n        $offset: Int\r\n        $orderBy: String\r\n        $orderDirection: String\r\n      ) {\r\n        feedbacks(\r\n          chainId: $chainId\r\n          agentId: $agentId\r\n          limit: $limit\r\n          offset: $offset\r\n          orderBy: $orderBy\r\n          orderDirection: $orderDirection\r\n        ) {\r\n          id\r\n          agentId\r\n          clientAddress\r\n          score\r\n          feedbackUri\r\n          feedbackJson\r\n          comment\r\n          ratingPct\r\n          txHash\r\n          blockNumber\r\n          timestamp\r\n          isRevoked\r\n          responseCount\r\n        }\r\n      }\r\n    `;\n        const variables = {\n            chainId,\n            agentId: agentIdString,\n            limit: typeof limit === 'number' ? limit : undefined,\n            offset: typeof offset === 'number' ? offset : undefined,\n            orderBy: typeof orderBy === 'string' ? orderBy : undefined,\n            orderDirection: typeof orderDirection === 'string' ? orderDirection : undefined,\n        };\n        try {\n            const data = await this.client.request(queryText, variables);\n            const feedbacks = data?.feedbacks;\n            if (!Array.isArray(feedbacks)) {\n                return null;\n            }\n            return {\n                feedbacks: feedbacks.filter(Boolean),\n            };\n        }\n        catch (error) {\n            console.warn('[AIAgentDiscoveryClient] searchFeedbackAdvanced failed:', error);\n            return null;\n        }\n    }\n    /**\n     * Execute a raw GraphQL query\n     * @param query - GraphQL query string\n     * @param variables - Query variables\n     * @returns Query response\n     */\n    async request(query, variables) {\n        return this.client.request(query, variables);\n    }\n    /**\n     * Execute a raw GraphQL mutation\n     * @param mutation - GraphQL mutation string\n     * @param variables - Mutation variables\n     * @returns Mutation response\n     */\n    async mutate(mutation, variables) {\n        return this.client.request(mutation, variables);\n    }\n    /**\n     * Get the underlying GraphQLClient instance\n     * @returns The GraphQLClient instance\n     */\n    getClient() {\n        return this.client;\n    }\n    /**\n     * Get agents owned by a specific EOA address\n     * @param eoaAddress - The EOA (Externally Owned Account) address to search for\n     * @param options - Optional search options (limit, offset, orderBy, orderDirection)\n     * @returns List of agents owned by the EOA address\n     */\n    async getOwnedAgents(eoaAddress, options) {\n        if (!eoaAddress || typeof eoaAddress !== 'string' || !eoaAddress.startsWith('0x')) {\n            throw new Error('Invalid EOA address. Must be a valid Ethereum address starting with 0x');\n        }\n        // Indexer/storage can vary: some deployments store checksum addresses as strings; others store lowercased hex.\n        // Query defensively in a case-safe way.\n        const addrLower = eoaAddress.toLowerCase();\n        const addrCandidates = [];\n        addrCandidates.push(eoaAddress);\n        if (addrLower !== eoaAddress)\n            addrCandidates.push(addrLower);\n        const limit = options?.limit ?? 100;\n        const offset = options?.offset ?? 0;\n        const orderBy = options?.orderBy ?? 'agentId';\n        const orderDirection = options?.orderDirection ?? 'DESC';\n        const query = `\r\n      query GetOwnedAgents(\r\n        $where: AgentWhereInput\r\n        $first: Int\r\n        $skip: Int\r\n        $orderBy: AgentOrderBy\r\n        $orderDirection: OrderDirection\r\n      ) {\r\n        searchAgentsGraph(\r\n          where: $where\r\n          first: $first\r\n          skip: $skip\r\n          orderBy: $orderBy\r\n          orderDirection: $orderDirection\r\n        ) {\r\n          agents {\r\n            chainId\r\n            agentId\r\n            agentAccount\r\n            agentName\r\n            agentCategory\r\n            didIdentity\r\n            didAccount\r\n            didName\r\n            agentIdentityOwnerAccount\r\n            eoaAgentIdentityOwnerAccount\r\n            eoaAgentAccount\r\n            agentUri\r\n            createdAtBlock\r\n            createdAtTime\r\n            updatedAtTime\r\n            type\r\n            description\r\n            image\r\n            a2aEndpoint\r\n            supportedTrust\r\n            rawJson\r\n            agentCardJson\r\n            agentCardReadAt\r\n            did\r\n            mcp\r\n            x402support\r\n            active\r\n            feedbackCount\r\n            feedbackAverageScore\r\n            validationPendingCount\r\n            validationCompletedCount\r\n            validationRequestedCount\r\n            initiatedAssociationCount\r\n            approvedAssociationCount\r\n            atiOverallScore\r\n            atiOverallConfidence\r\n            atiVersion\r\n            atiComputedAt\r\n            atiBundleJson\r\n            trustLedgerScore\r\n            trustLedgerBadgeCount\r\n            trustLedgerOverallRank\r\n            trustLedgerCapabilityRank\r\n          }\r\n          total\r\n          hasMore\r\n        }\r\n      }\r\n    `;\n        try {\n            // Prefer _in filter (works for string fields and some bytes fields). If schema doesn't support it,\n            // fall back to exact-match attempts across candidates.\n            const tryQuery = async (where) => {\n                const variables = {\n                    where,\n                    first: limit,\n                    skip: offset,\n                    orderBy,\n                    orderDirection,\n                };\n                const data = await this.client.request(query, variables);\n                const result = data.searchAgentsGraph ?? { agents: [], total: 0, hasMore: false };\n                return (result.agents ?? []).map((agent) => this.normalizeAgent(agent));\n            };\n            // 1) Try eoaAgentIdentityOwnerAccount_in: [candidates]\n            try {\n                const owned = await tryQuery({ eoaAgentIdentityOwnerAccount_in: addrCandidates });\n                if (owned.length > 0)\n                    return owned;\n            }\n            catch (e) {\n                const responseErrors = e?.response?.errors;\n                const inNotSupported = Array.isArray(responseErrors) &&\n                    responseErrors.some((err) => typeof err?.message === 'string' &&\n                        (err.message.includes('eoaAgentIdentityOwnerAccount_in') ||\n                            err.message.includes('Field \"eoaAgentIdentityOwnerAccount_in\"') ||\n                            err.message.includes('Unknown argument') ||\n                            err.message.includes('Cannot query field')));\n                if (!inNotSupported) {\n                    throw e;\n                }\n            }\n            // 2) Exact match attempts\n            for (const candidate of addrCandidates) {\n                const owned = await tryQuery({ eoaAgentIdentityOwnerAccount: candidate });\n                if (owned.length > 0)\n                    return owned;\n            }\n            return [];\n        }\n        catch (error) {\n            console.error('[AIAgentDiscoveryClient.getOwnedAgents] Error fetching owned agents:', error);\n            throw error;\n        }\n    }\n}\n//# sourceMappingURL=AIAgentDiscoveryClient.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BhZ2VudGljLXRydXN0LzgwMDQtZXh0LXNkay9kaXN0L0FJQWdlbnREaXNjb3ZlcnlDbGllbnQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0EsaURBQWlELGNBQWM7QUFDL0Q7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDBEQUFhO0FBQ3ZDO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsc0NBQXNDO0FBQzdFLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGFBQWE7QUFDcEQsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFLG1CQUFtQixJQUFJLE1BQU07QUFDdEc7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsK0JBQStCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0IseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsU0FBUyxJQUFJLFNBQVMsRUFBRSx5QkFBeUI7QUFDMUYsd0NBQXdDLFNBQVMsS0FBSyxTQUFTO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFNBQVMsSUFBSSxTQUFTLEVBQUUseUJBQXlCO0FBQzFGLHdDQUF3QyxTQUFTLEtBQUssU0FBUztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxTQUFTLElBQUksU0FBUyxFQUFFLHlCQUF5QjtBQUMxRix3Q0FBd0MsU0FBUyxLQUFLLFNBQVM7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQiwrQkFBK0I7QUFDOUQsWUFBWSxtQkFBbUIsR0FBRywrQkFBK0I7QUFDakUsY0FBYyw2QkFBNkIsd0JBQXdCO0FBQ25FLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLCtCQUErQjtBQUNsRSxZQUFZLG1CQUFtQixHQUFHLCtCQUErQjtBQUNqRSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFLGdCQUFnQjtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEZBQTBGLFNBQVM7QUFDbkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxlQUFlLDZCQUE2QixXQUFXO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0ZBQWtGO0FBQ2xGO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEhBQTRILFFBQVE7QUFDcEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRTtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLElBQUk7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0MsMkNBQTJDLE9BQU87QUFDbEQ7QUFDQSw4QkFBOEIsMERBQWE7QUFDM0M7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QseURBQXlEO0FBQ2pIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw2RkFBNkY7QUFDN0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwyRkFBMkY7QUFDM0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJGQUEyRjtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsaURBQWlEO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MseUNBQXlDO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvYmFyYi9hYS9Bc3NvY2lhdGVkQWNjb3VudHMvbm9kZV9tb2R1bGVzL0BhZ2VudGljLXRydXN0LzgwMDQtZXh0LXNkay9kaXN0L0FJQWdlbnREaXNjb3ZlcnlDbGllbnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBBSSBBZ2VudCBEaXNjb3ZlcnkgQ2xpZW50XG4gKlxuICogRnJvbnRzIGZvciBkaXNjb3ZlcnktaW5kZXggR3JhcGhRTCByZXF1ZXN0cyB0byB0aGUgaW5kZXhlclxuICogUHJvdmlkZXMgYSBjbGVhbiBpbnRlcmZhY2UgZm9yIHF1ZXJ5aW5nIGFnZW50IGRhdGFcbiAqL1xuaW1wb3J0IHsgR3JhcGhRTENsaWVudCB9IGZyb20gJ2dyYXBocWwtcmVxdWVzdCc7XG5jb25zdCBJTlRST1NQRUNUSU9OX1FVRVJZID0gYFxyXG4gIHF1ZXJ5IFNlYXJjaENhcGFiaWxpdGllcyB7XHJcbiAgICBfX3NjaGVtYSB7XHJcbiAgICAgIHF1ZXJ5VHlwZSB7XHJcbiAgICAgICAgZmllbGRzIHtcclxuICAgICAgICAgIG5hbWVcclxuICAgICAgICAgIGFyZ3Mge1xyXG4gICAgICAgICAgICBuYW1lXHJcbiAgICAgICAgICAgIHR5cGUge1xyXG4gICAgICAgICAgICAgIC4uLlR5cGVSZWZcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgdHlwZSB7XHJcbiAgICAgICAgICAgIC4uLlR5cGVSZWZcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbiAgZnJhZ21lbnQgVHlwZVJlZiBvbiBfX1R5cGUge1xyXG4gICAga2luZFxyXG4gICAgbmFtZVxyXG4gICAgb2ZUeXBlIHtcclxuICAgICAga2luZFxyXG4gICAgICBuYW1lXHJcbiAgICAgIG9mVHlwZSB7XHJcbiAgICAgICAga2luZFxyXG4gICAgICAgIG5hbWVcclxuICAgICAgICBvZlR5cGUge1xyXG4gICAgICAgICAga2luZFxyXG4gICAgICAgICAgbmFtZVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuYDtcbmNvbnN0IFRZUEVfRklFTERTX1FVRVJZID0gYFxyXG4gIHF1ZXJ5IFR5cGVGaWVsZHMoJG5hbWU6IFN0cmluZyEpIHtcclxuICAgIF9fdHlwZShuYW1lOiAkbmFtZSkge1xyXG4gICAgICBmaWVsZHMge1xyXG4gICAgICAgIG5hbWVcclxuICAgICAgICB0eXBlIHtcclxuICAgICAgICAgIC4uLlR5cGVSZWZcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbiAgZnJhZ21lbnQgVHlwZVJlZiBvbiBfX1R5cGUge1xyXG4gICAga2luZFxyXG4gICAgbmFtZVxyXG4gICAgb2ZUeXBlIHtcclxuICAgICAga2luZFxyXG4gICAgICBuYW1lXHJcbiAgICAgIG9mVHlwZSB7XHJcbiAgICAgICAga2luZFxyXG4gICAgICAgIG5hbWVcclxuICAgICAgICBvZlR5cGUge1xyXG4gICAgICAgICAga2luZFxyXG4gICAgICAgICAgbmFtZVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuYDtcbmZ1bmN0aW9uIHVud3JhcFR5cGUodHlwZSkge1xuICAgIGxldCBjdXJyZW50ID0gdHlwZTtcbiAgICB3aGlsZSAoY3VycmVudCAmJiAoY3VycmVudC5raW5kID09PSAnTk9OX05VTEwnIHx8IGN1cnJlbnQua2luZCA9PT0gJ0xJU1QnKSkge1xuICAgICAgICBjdXJyZW50ID0gY3VycmVudC5vZlR5cGUgPz8gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGN1cnJlbnQgPz8gbnVsbDtcbn1cbmZ1bmN0aW9uIHVud3JhcFRvVHlwZU5hbWUodHlwZSkge1xuICAgIGNvbnN0IG5hbWVkID0gdW53cmFwVHlwZSh0eXBlKTtcbiAgICByZXR1cm4gbmFtZWQ/Lm5hbWUgPz8gbnVsbDtcbn1cbmZ1bmN0aW9uIGlzTm9uTnVsbCh0eXBlKSB7XG4gICAgcmV0dXJuIHR5cGU/LmtpbmQgPT09ICdOT05fTlVMTCc7XG59XG5mdW5jdGlvbiBpc0xpc3RPZih0eXBlLCBleHBlY3RlZE5hbWUpIHtcbiAgICBpZiAoIXR5cGUpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAodHlwZS5raW5kID09PSAnTk9OX05VTEwnKVxuICAgICAgICByZXR1cm4gaXNMaXN0T2YodHlwZS5vZlR5cGUsIGV4cGVjdGVkTmFtZSk7XG4gICAgaWYgKHR5cGUua2luZCA9PT0gJ0xJU1QnKSB7XG4gICAgICAgIGNvbnN0IGlubmVyID0gdHlwZS5vZlR5cGUgfHwgbnVsbDtcbiAgICAgICAgaWYgKCFpbm5lcilcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKGlubmVyLmtpbmQgPT09ICdOT05fTlVMTCcpIHtcbiAgICAgICAgICAgIHJldHVybiBpc0xpc3RPZihpbm5lci5vZlR5cGUsIGV4cGVjdGVkTmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlubmVyLmtpbmQgPT09ICdPQkpFQ1QnICYmIGlubmVyLm5hbWUgPT09IGV4cGVjdGVkTmFtZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuLyoqXG4gKiBBSSBBZ2VudCBEaXNjb3ZlcnkgQ2xpZW50XG4gKlxuICogUHJvdmlkZXMgbWV0aG9kcyBmb3IgcXVlcnlpbmcgYWdlbnQgZGF0YSBmcm9tIHRoZSBpbmRleGVyXG4gKi9cbmV4cG9ydCBjbGFzcyBBSUFnZW50RGlzY292ZXJ5Q2xpZW50IHtcbiAgICBjbGllbnQ7XG4gICAgY29uZmlnO1xuICAgIHNlYXJjaFN0cmF0ZWd5O1xuICAgIHNlYXJjaFN0cmF0ZWd5UHJvbWlzZTtcbiAgICB0eXBlRmllbGRzQ2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgdG9rZW5NZXRhZGF0YUNvbGxlY3Rpb25TdXBwb3J0ZWQ7XG4gICAgYWdlbnRNZXRhZGF0YVZhbHVlRmllbGQ7XG4gICAgcXVlcnlGaWVsZHNDYWNoZTtcbiAgICBxdWVyeUZpZWxkc1Byb21pc2U7XG4gICAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgICAgICBjb25zdCBoZWFkZXJzID0ge1xuICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgIC4uLihjb25maWcuaGVhZGVycyB8fCB7fSksXG4gICAgICAgIH07XG4gICAgICAgIGlmIChjb25maWcuYXBpS2V5KSB7XG4gICAgICAgICAgICBoZWFkZXJzWydBdXRob3JpemF0aW9uJ10gPSBgQmVhcmVyICR7Y29uZmlnLmFwaUtleX1gO1xuICAgICAgICAgICAgLy8gQWxzbyBzdXBwb3J0IEFQSSBrZXkgaW4gaGVhZGVyXG4gICAgICAgICAgICBoZWFkZXJzWydYLUFQSS1LZXknXSA9IGNvbmZpZy5hcGlLZXk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jbGllbnQgPSBuZXcgR3JhcGhRTENsaWVudChjb25maWcuZW5kcG9pbnQsIHtcbiAgICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBnZXRRdWVyeUZpZWxkcygpIHtcbiAgICAgICAgaWYgKHRoaXMucXVlcnlGaWVsZHNDYWNoZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5xdWVyeUZpZWxkc0NhY2hlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnF1ZXJ5RmllbGRzUHJvbWlzZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucXVlcnlGaWVsZHNQcm9taXNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucXVlcnlGaWVsZHNQcm9taXNlID0gKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHRoaXMuY2xpZW50LnJlcXVlc3QoSU5UUk9TUEVDVElPTl9RVUVSWSk7XG4gICAgICAgICAgICAgICAgY29uc3QgZmllbGRzID0gZGF0YS5fX3NjaGVtYT8ucXVlcnlUeXBlPy5maWVsZHMgPz8gW107XG4gICAgICAgICAgICAgICAgdGhpcy5xdWVyeUZpZWxkc0NhY2hlID0gZmllbGRzO1xuICAgICAgICAgICAgICAgIHJldHVybiBmaWVsZHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1tBSUFnZW50RGlzY292ZXJ5Q2xpZW50XSBGYWlsZWQgdG8gaW50cm9zcGVjdCBxdWVyeSBmaWVsZHM6JywgZXJyb3IpO1xuICAgICAgICAgICAgICAgIHRoaXMucXVlcnlGaWVsZHNDYWNoZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICB0aGlzLnF1ZXJ5RmllbGRzUHJvbWlzZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucXVlcnlGaWVsZHNQcm9taXNlO1xuICAgIH1cbiAgICBhc3luYyBzdXBwb3J0c1F1ZXJ5RmllbGQoZmllbGROYW1lKSB7XG4gICAgICAgIGNvbnN0IGZpZWxkcyA9IGF3YWl0IHRoaXMuZ2V0UXVlcnlGaWVsZHMoKTtcbiAgICAgICAgaWYgKCFmaWVsZHMpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiBmaWVsZHMuc29tZSgoZikgPT4gZi5uYW1lID09PSBmaWVsZE5hbWUpO1xuICAgIH1cbiAgICBub3JtYWxpemVBZ2VudChhZ2VudCkge1xuICAgICAgICBjb25zdCByZWNvcmQgPSAoYWdlbnQgPz8ge30pO1xuICAgICAgICBjb25zdCB0b09wdGlvbmFsU3RyaW5nID0gKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgdG9PcHRpb25hbFN0cmluZ09yTnVsbCA9ICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgdG9PcHRpb25hbE51bWJlciA9ICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbnVtZXJpYyA9IHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgPyB2YWx1ZSA6IE51bWJlcih2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gTnVtYmVyLmlzRmluaXRlKG51bWVyaWMpID8gbnVtZXJpYyA6IHVuZGVmaW5lZDtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgdG9PcHRpb25hbE51bWJlck9yTnVsbCA9ICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBudW1lcmljID0gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyA/IHZhbHVlIDogTnVtYmVyKHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiBOdW1iZXIuaXNGaW5pdGUobnVtZXJpYykgPyBudW1lcmljIDogbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gUGFyc2UgcmF3SnNvbiB0byBleHRyYWN0IGFsbCBtZXRhZGF0YSBmaWVsZHNcbiAgICAgICAgbGV0IHBhcnNlZE1ldGFkYXRhID0ge307XG4gICAgICAgIGlmIChyZWNvcmQucmF3SnNvbiAmJiB0eXBlb2YgcmVjb3JkLnJhd0pzb24gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcnNlZCA9IEpTT04ucGFyc2UocmVjb3JkLnJhd0pzb24pO1xuICAgICAgICAgICAgICAgIGlmIChwYXJzZWQgJiYgdHlwZW9mIHBhcnNlZCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRXh0cmFjdCBhbGwgZmllbGRzIGZyb20gdGhlIHJlZ2lzdHJhdGlvbiBKU09OXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZE1ldGFkYXRhID0gcGFyc2VkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIC8vIFNpbGVudGx5IGlnbm9yZSBKU09OIHBhcnNlIGVycm9yc1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSB7XG4gICAgICAgICAgICAuLi5yZWNvcmQsXG4gICAgICAgICAgICAvLyBNZXJnZSBhbGwgbWV0YWRhdGEgZnJvbSBwYXJzZWQgcmF3SnNvblxuICAgICAgICAgICAgLi4ucGFyc2VkTWV0YWRhdGEsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGFnZW50QWNjb3VudCA9IHRvT3B0aW9uYWxTdHJpbmcocmVjb3JkLmFnZW50QWNjb3VudCk7XG4gICAgICAgIGlmIChhZ2VudEFjY291bnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbm9ybWFsaXplZC5hZ2VudEFjY291bnQgPSBhZ2VudEFjY291bnQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYWdlbnRJZGVudGl0eU93bmVyQWNjb3VudCA9IHRvT3B0aW9uYWxTdHJpbmcocmVjb3JkLmFnZW50SWRlbnRpdHlPd25lckFjY291bnQpO1xuICAgICAgICBpZiAoYWdlbnRJZGVudGl0eU93bmVyQWNjb3VudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBub3JtYWxpemVkLmFnZW50SWRlbnRpdHlPd25lckFjY291bnQgPSBhZ2VudElkZW50aXR5T3duZXJBY2NvdW50O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVvYUFnZW50SWRlbnRpdHlPd25lckFjY291bnQgPSB0b09wdGlvbmFsU3RyaW5nT3JOdWxsKHJlY29yZC5lb2FBZ2VudElkZW50aXR5T3duZXJBY2NvdW50KTtcbiAgICAgICAgaWYgKGVvYUFnZW50SWRlbnRpdHlPd25lckFjY291bnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbm9ybWFsaXplZC5lb2FBZ2VudElkZW50aXR5T3duZXJBY2NvdW50ID0gZW9hQWdlbnRJZGVudGl0eU93bmVyQWNjb3VudDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlb2FBZ2VudEFjY291bnQgPSB0b09wdGlvbmFsU3RyaW5nT3JOdWxsKHJlY29yZC5lb2FBZ2VudEFjY291bnQpO1xuICAgICAgICBpZiAoZW9hQWdlbnRBY2NvdW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQuZW9hQWdlbnRBY2NvdW50ID0gZW9hQWdlbnRBY2NvdW50O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFnZW50Q2F0ZWdvcnkgPSB0b09wdGlvbmFsU3RyaW5nT3JOdWxsKHJlY29yZC5hZ2VudENhdGVnb3J5KTtcbiAgICAgICAgaWYgKGFnZW50Q2F0ZWdvcnkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbm9ybWFsaXplZC5hZ2VudENhdGVnb3J5ID0gYWdlbnRDYXRlZ29yeTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkaWRJZGVudGl0eSA9IHRvT3B0aW9uYWxTdHJpbmdPck51bGwocmVjb3JkLmRpZElkZW50aXR5KTtcbiAgICAgICAgaWYgKGRpZElkZW50aXR5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQuZGlkSWRlbnRpdHkgPSBkaWRJZGVudGl0eTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkaWRBY2NvdW50ID0gdG9PcHRpb25hbFN0cmluZ09yTnVsbChyZWNvcmQuZGlkQWNjb3VudCk7XG4gICAgICAgIGlmIChkaWRBY2NvdW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQuZGlkQWNjb3VudCA9IGRpZEFjY291bnQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGlkTmFtZSA9IHRvT3B0aW9uYWxTdHJpbmdPck51bGwocmVjb3JkLmRpZE5hbWUpO1xuICAgICAgICBpZiAoZGlkTmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBub3JtYWxpemVkLmRpZE5hbWUgPSBkaWROYW1lO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFnZW50VXJpID0gdG9PcHRpb25hbFN0cmluZ09yTnVsbChyZWNvcmQuYWdlbnRVcmkpO1xuICAgICAgICBpZiAoYWdlbnRVcmkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbm9ybWFsaXplZC5hZ2VudFVyaSA9IGFnZW50VXJpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZhbGlkYXRpb25QZW5kaW5nQ291bnQgPSB0b09wdGlvbmFsTnVtYmVyT3JOdWxsKHJlY29yZC52YWxpZGF0aW9uUGVuZGluZ0NvdW50KTtcbiAgICAgICAgaWYgKHZhbGlkYXRpb25QZW5kaW5nQ291bnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbm9ybWFsaXplZC52YWxpZGF0aW9uUGVuZGluZ0NvdW50ID0gdmFsaWRhdGlvblBlbmRpbmdDb3VudDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2YWxpZGF0aW9uQ29tcGxldGVkQ291bnQgPSB0b09wdGlvbmFsTnVtYmVyT3JOdWxsKHJlY29yZC52YWxpZGF0aW9uQ29tcGxldGVkQ291bnQpO1xuICAgICAgICBpZiAodmFsaWRhdGlvbkNvbXBsZXRlZENvdW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQudmFsaWRhdGlvbkNvbXBsZXRlZENvdW50ID0gdmFsaWRhdGlvbkNvbXBsZXRlZENvdW50O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZhbGlkYXRpb25SZXF1ZXN0ZWRDb3VudCA9IHRvT3B0aW9uYWxOdW1iZXJPck51bGwocmVjb3JkLnZhbGlkYXRpb25SZXF1ZXN0ZWRDb3VudCk7XG4gICAgICAgIGlmICh2YWxpZGF0aW9uUmVxdWVzdGVkQ291bnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbm9ybWFsaXplZC52YWxpZGF0aW9uUmVxdWVzdGVkQ291bnQgPSB2YWxpZGF0aW9uUmVxdWVzdGVkQ291bnQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaW5pdGlhdGVkQXNzb2NpYXRpb25Db3VudCA9IHRvT3B0aW9uYWxOdW1iZXJPck51bGwocmVjb3JkLmluaXRpYXRlZEFzc29jaWF0aW9uQ291bnQpO1xuICAgICAgICBpZiAoaW5pdGlhdGVkQXNzb2NpYXRpb25Db3VudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBub3JtYWxpemVkLmluaXRpYXRlZEFzc29jaWF0aW9uQ291bnQgPSBpbml0aWF0ZWRBc3NvY2lhdGlvbkNvdW50O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFwcHJvdmVkQXNzb2NpYXRpb25Db3VudCA9IHRvT3B0aW9uYWxOdW1iZXJPck51bGwocmVjb3JkLmFwcHJvdmVkQXNzb2NpYXRpb25Db3VudCk7XG4gICAgICAgIGlmIChhcHByb3ZlZEFzc29jaWF0aW9uQ291bnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbm9ybWFsaXplZC5hcHByb3ZlZEFzc29jaWF0aW9uQ291bnQgPSBhcHByb3ZlZEFzc29jaWF0aW9uQ291bnQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXRpT3ZlcmFsbFNjb3JlID0gdG9PcHRpb25hbE51bWJlck9yTnVsbChyZWNvcmQuYXRpT3ZlcmFsbFNjb3JlKTtcbiAgICAgICAgaWYgKGF0aU92ZXJhbGxTY29yZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBub3JtYWxpemVkLmF0aU92ZXJhbGxTY29yZSA9IGF0aU92ZXJhbGxTY29yZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhdGlPdmVyYWxsQ29uZmlkZW5jZSA9IHRvT3B0aW9uYWxOdW1iZXJPck51bGwocmVjb3JkLmF0aU92ZXJhbGxDb25maWRlbmNlKTtcbiAgICAgICAgaWYgKGF0aU92ZXJhbGxDb25maWRlbmNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQuYXRpT3ZlcmFsbENvbmZpZGVuY2UgPSBhdGlPdmVyYWxsQ29uZmlkZW5jZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhdGlWZXJzaW9uID0gdG9PcHRpb25hbFN0cmluZ09yTnVsbChyZWNvcmQuYXRpVmVyc2lvbik7XG4gICAgICAgIGlmIChhdGlWZXJzaW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQuYXRpVmVyc2lvbiA9IGF0aVZlcnNpb247XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXRpQ29tcHV0ZWRBdCA9IHRvT3B0aW9uYWxOdW1iZXJPck51bGwocmVjb3JkLmF0aUNvbXB1dGVkQXQpO1xuICAgICAgICBpZiAoYXRpQ29tcHV0ZWRBdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBub3JtYWxpemVkLmF0aUNvbXB1dGVkQXQgPSBhdGlDb21wdXRlZEF0O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGF0aUJ1bmRsZUpzb24gPSB0b09wdGlvbmFsU3RyaW5nT3JOdWxsKHJlY29yZC5hdGlCdW5kbGVKc29uKTtcbiAgICAgICAgaWYgKGF0aUJ1bmRsZUpzb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbm9ybWFsaXplZC5hdGlCdW5kbGVKc29uID0gYXRpQnVuZGxlSnNvbjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0cnVzdExlZGdlclNjb3JlID0gdG9PcHRpb25hbE51bWJlck9yTnVsbChyZWNvcmQudHJ1c3RMZWRnZXJTY29yZSk7XG4gICAgICAgIGlmICh0cnVzdExlZGdlclNjb3JlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQudHJ1c3RMZWRnZXJTY29yZSA9IHRydXN0TGVkZ2VyU2NvcmU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdHJ1c3RMZWRnZXJCYWRnZUNvdW50ID0gdG9PcHRpb25hbE51bWJlck9yTnVsbChyZWNvcmQudHJ1c3RMZWRnZXJCYWRnZUNvdW50KTtcbiAgICAgICAgaWYgKHRydXN0TGVkZ2VyQmFkZ2VDb3VudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBub3JtYWxpemVkLnRydXN0TGVkZ2VyQmFkZ2VDb3VudCA9IHRydXN0TGVkZ2VyQmFkZ2VDb3VudDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0cnVzdExlZGdlck92ZXJhbGxSYW5rID0gdG9PcHRpb25hbE51bWJlck9yTnVsbChyZWNvcmQudHJ1c3RMZWRnZXJPdmVyYWxsUmFuayk7XG4gICAgICAgIGlmICh0cnVzdExlZGdlck92ZXJhbGxSYW5rICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQudHJ1c3RMZWRnZXJPdmVyYWxsUmFuayA9IHRydXN0TGVkZ2VyT3ZlcmFsbFJhbms7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdHJ1c3RMZWRnZXJDYXBhYmlsaXR5UmFuayA9IHRvT3B0aW9uYWxOdW1iZXJPck51bGwocmVjb3JkLnRydXN0TGVkZ2VyQ2FwYWJpbGl0eVJhbmspO1xuICAgICAgICBpZiAodHJ1c3RMZWRnZXJDYXBhYmlsaXR5UmFuayAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBub3JtYWxpemVkLnRydXN0TGVkZ2VyQ2FwYWJpbGl0eVJhbmsgPSB0cnVzdExlZGdlckNhcGFiaWxpdHlSYW5rO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRlc2NyaXB0aW9uID0gdG9PcHRpb25hbFN0cmluZ09yTnVsbChyZWNvcmQuZGVzY3JpcHRpb24pO1xuICAgICAgICBpZiAoZGVzY3JpcHRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbm9ybWFsaXplZC5kZXNjcmlwdGlvbiA9IGRlc2NyaXB0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGltYWdlID0gdG9PcHRpb25hbFN0cmluZ09yTnVsbChyZWNvcmQuaW1hZ2UpO1xuICAgICAgICBpZiAoaW1hZ2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbm9ybWFsaXplZC5pbWFnZSA9IGltYWdlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGEyYUVuZHBvaW50ID0gdG9PcHRpb25hbFN0cmluZ09yTnVsbChyZWNvcmQuYTJhRW5kcG9pbnQpO1xuICAgICAgICBpZiAoYTJhRW5kcG9pbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbm9ybWFsaXplZC5hMmFFbmRwb2ludCA9IGEyYUVuZHBvaW50O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFnZW50Q2FyZEpzb24gPSB0b09wdGlvbmFsU3RyaW5nT3JOdWxsKHJlY29yZC5hZ2VudENhcmRKc29uKTtcbiAgICAgICAgaWYgKGFnZW50Q2FyZEpzb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbm9ybWFsaXplZC5hZ2VudENhcmRKc29uID0gYWdlbnRDYXJkSnNvbjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhZ2VudENhcmRSZWFkQXQgPSB0b09wdGlvbmFsTnVtYmVyT3JOdWxsKHJlY29yZC5hZ2VudENhcmRSZWFkQXQpO1xuICAgICAgICBpZiAoYWdlbnRDYXJkUmVhZEF0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQuYWdlbnRDYXJkUmVhZEF0ID0gYWdlbnRDYXJkUmVhZEF0O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN1cHBvcnRlZFRydXN0ID0gdG9PcHRpb25hbFN0cmluZyhyZWNvcmQuc3VwcG9ydGVkVHJ1c3QpO1xuICAgICAgICBpZiAoc3VwcG9ydGVkVHJ1c3QgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbm9ybWFsaXplZC5zdXBwb3J0ZWRUcnVzdCA9IHN1cHBvcnRlZFRydXN0O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRpZCA9IHRvT3B0aW9uYWxTdHJpbmdPck51bGwocmVjb3JkLmRpZCk7XG4gICAgICAgIGlmIChkaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbm9ybWFsaXplZC5kaWQgPSBkaWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSGFuZGxlIGFnZW50TmFtZTogcHJlZmVyIG5vbi1lbXB0eSB2YWx1ZXMgZnJvbSBtdWx0aXBsZSBzb3VyY2VzXG4gICAgICAgIC8vIFByaW9yaXR5OiAxKSBkaXJlY3QgYWdlbnROYW1lIGZpZWxkLCAyKSBuYW1lIGZyb20gcGFyc2VkTWV0YWRhdGEsIDMpIGFnZW50TmFtZSBmcm9tIHBhcnNlZE1ldGFkYXRhXG4gICAgICAgIGxldCBhZ2VudE5hbWUgPSB1bmRlZmluZWQ7XG4gICAgICAgIC8vIENoZWNrIGRpcmVjdCBhZ2VudE5hbWUgZmllbGQgKG11c3QgYmUgbm9uLWVtcHR5IGFmdGVyIHRyaW0pXG4gICAgICAgIGNvbnN0IHJhd0FnZW50TmFtZSA9IHJlY29yZC5hZ2VudE5hbWU7XG4gICAgICAgIGNvbnN0IGRpcmVjdEFnZW50TmFtZSA9IHR5cGVvZiByYXdBZ2VudE5hbWUgPT09ICdzdHJpbmcnICYmIHJhd0FnZW50TmFtZS50cmltKCkubGVuZ3RoID4gMFxuICAgICAgICAgICAgPyByYXdBZ2VudE5hbWUudHJpbSgpXG4gICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKGRpcmVjdEFnZW50TmFtZSkge1xuICAgICAgICAgICAgYWdlbnROYW1lID0gZGlyZWN0QWdlbnROYW1lO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gQ2hlY2sgcGFyc2VkTWV0YWRhdGEgZm9yIG5hbWUgb3IgYWdlbnROYW1lXG4gICAgICAgICAgICBjb25zdCBtZXRhZGF0YU5hbWUgPSB0eXBlb2YgcGFyc2VkTWV0YWRhdGEubmFtZSA9PT0gJ3N0cmluZycgJiYgcGFyc2VkTWV0YWRhdGEubmFtZS50cmltKCkubGVuZ3RoID4gMFxuICAgICAgICAgICAgICAgID8gcGFyc2VkTWV0YWRhdGEubmFtZS50cmltKClcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGNvbnN0IG1ldGFkYXRhQWdlbnROYW1lID0gdHlwZW9mIHBhcnNlZE1ldGFkYXRhLmFnZW50TmFtZSA9PT0gJ3N0cmluZycgJiYgcGFyc2VkTWV0YWRhdGEuYWdlbnROYW1lLnRyaW0oKS5sZW5ndGggPiAwXG4gICAgICAgICAgICAgICAgPyBwYXJzZWRNZXRhZGF0YS5hZ2VudE5hbWUudHJpbSgpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBhZ2VudE5hbWUgPSBtZXRhZGF0YUFnZW50TmFtZSB8fCBtZXRhZGF0YU5hbWU7XG4gICAgICAgICAgICBpZiAoYWdlbnROYW1lKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1tBSUFnZW50RGlzY292ZXJ5Q2xpZW50Lm5vcm1hbGl6ZUFnZW50XSBVc2luZyBtZXRhZGF0YSBuYW1lOicsIHtcbiAgICAgICAgICAgICAgICAgICAgZnJvbU1ldGFkYXRhQWdlbnROYW1lOiAhIW1ldGFkYXRhQWdlbnROYW1lLFxuICAgICAgICAgICAgICAgICAgICBmcm9tTWV0YWRhdGFOYW1lOiAhIW1ldGFkYXRhTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgYWdlbnROYW1lLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1tBSUFnZW50RGlzY292ZXJ5Q2xpZW50Lm5vcm1hbGl6ZUFnZW50XSBObyB2YWxpZCBhZ2VudE5hbWUgZm91bmQgaW4gZGlyZWN0IGZpZWxkIG9yIG1ldGFkYXRhJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2V0IGFnZW50TmFtZTogdXNlIGZvdW5kIHZhbHVlLCBvciB1bmRlZmluZWQgaWYgb3JpZ2luYWwgd2FzIGVtcHR5IGFuZCBubyByZXBsYWNlbWVudCBmb3VuZFxuICAgICAgICAvLyBUaGlzIGVuc3VyZXMgZW1wdHkgc3RyaW5ncyBhcmUgY29udmVydGVkIHRvIHVuZGVmaW5lZFxuICAgICAgICBpZiAoYWdlbnROYW1lICYmIGFnZW50TmFtZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBub3JtYWxpemVkLmFnZW50TmFtZSA9IGFnZW50TmFtZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgcmF3QWdlbnROYW1lID09PSAnc3RyaW5nJyAmJiByYXdBZ2VudE5hbWUudHJpbSgpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgLy8gT3JpZ2luYWwgd2FzIGVtcHR5IHN0cmluZywgYW5kIHdlIGRpZG4ndCBmaW5kIGEgcmVwbGFjZW1lbnQgLSBzZXQgdG8gdW5kZWZpbmVkXG4gICAgICAgICAgICBub3JtYWxpemVkLmFnZW50TmFtZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdbQUlBZ2VudERpc2NvdmVyeUNsaWVudC5ub3JtYWxpemVBZ2VudF0gT3JpZ2luYWwgd2FzIGVtcHR5IHN0cmluZywgc2V0IHRvIHVuZGVmaW5lZCcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ1tBSUFnZW50RGlzY292ZXJ5Q2xpZW50Lm5vcm1hbGl6ZUFnZW50XSBMZWF2aW5nIGFnZW50TmFtZSBhcy1pczonLCBub3JtYWxpemVkLmFnZW50TmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgcmF3QWdlbnROYW1lIHdhcyB1bmRlZmluZWQvbnVsbCwgbGVhdmUgaXQgYXMtaXMgKGRvbid0IG92ZXJ3cml0ZSlcbiAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExpc3QgYWdlbnRzIHdpdGggYSBkZXRlcm1pbmlzdGljIGRlZmF1bHQgb3JkZXJpbmcgKGFnZW50SWQgREVTQykuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbGltaXQgLSBNYXhpbXVtIG51bWJlciBvZiBhZ2VudHMgdG8gcmV0dXJuIHBlciBwYWdlXG4gICAgICogQHBhcmFtIG9mZnNldCAtIE51bWJlciBvZiBhZ2VudHMgdG8gc2tpcFxuICAgICAqIEByZXR1cm5zIExpc3Qgb2YgYWdlbnRzXG4gICAgICovXG4gICAgYXN5bmMgbGlzdEFnZW50cyhsaW1pdCwgb2Zmc2V0KSB7XG4gICAgICAgIGxldCBhbGxBZ2VudHMgPSBbXTtcbiAgICAgICAgY29uc3QgZWZmZWN0aXZlTGltaXQgPSBsaW1pdCA/PyAxMDA7XG4gICAgICAgIGNvbnN0IGVmZmVjdGl2ZU9mZnNldCA9IG9mZnNldCA/PyAwO1xuICAgICAgICBjb25zdCBxdWVyeSA9IGBcclxuICAgICAgcXVlcnkgTGlzdEFnZW50cygkbGltaXQ6IEludCwgJG9mZnNldDogSW50KSB7XHJcbiAgICAgICAgYWdlbnRzKGxpbWl0OiAkbGltaXQsIG9mZnNldDogJG9mZnNldCkge1xyXG4gICAgICAgICAgY2hhaW5JZFxyXG4gICAgICAgICAgYWdlbnRJZFxyXG4gICAgICAgICAgYWdlbnROYW1lXHJcbiAgICAgICAgICBhZ2VudEFjY291bnRcclxuICAgICAgICAgIGFnZW50SWRlbnRpdHlPd25lckFjY291bnRcclxuICAgICAgICAgIGVvYUFnZW50SWRlbnRpdHlPd25lckFjY291bnRcclxuICAgICAgICAgIGVvYUFnZW50QWNjb3VudFxyXG4gICAgICAgICAgYWdlbnRDYXRlZ29yeVxyXG4gICAgICAgICAgZGlkSWRlbnRpdHlcclxuICAgICAgICAgIGRpZEFjY291bnRcclxuICAgICAgICAgIGRpZE5hbWVcclxuICAgICAgICAgIGFnZW50VXJpXHJcbiAgICAgICAgICBjcmVhdGVkQXRCbG9ja1xyXG4gICAgICAgICAgY3JlYXRlZEF0VGltZVxyXG4gICAgICAgICAgdXBkYXRlZEF0VGltZVxyXG4gICAgICAgICAgdHlwZVxyXG4gICAgICAgICAgZGVzY3JpcHRpb25cclxuICAgICAgICAgIGltYWdlXHJcbiAgICAgICAgICBhMmFFbmRwb2ludFxyXG4gICAgICAgICAgZGlkXHJcbiAgICAgICAgICBtY3BcclxuICAgICAgICAgIHg0MDJzdXBwb3J0XHJcbiAgICAgICAgICBhY3RpdmVcclxuICAgICAgICAgIHN1cHBvcnRlZFRydXN0XHJcbiAgICAgICAgICByYXdKc29uXHJcbiAgICAgICAgICBhZ2VudENhcmRKc29uXHJcbiAgICAgICAgICBhZ2VudENhcmRSZWFkQXRcclxuICAgICAgICAgIGZlZWRiYWNrQ291bnRcclxuICAgICAgICAgIGZlZWRiYWNrQXZlcmFnZVNjb3JlXHJcbiAgICAgICAgICB2YWxpZGF0aW9uUGVuZGluZ0NvdW50XHJcbiAgICAgICAgICB2YWxpZGF0aW9uQ29tcGxldGVkQ291bnRcclxuICAgICAgICAgIHZhbGlkYXRpb25SZXF1ZXN0ZWRDb3VudFxyXG4gICAgICAgICAgaW5pdGlhdGVkQXNzb2NpYXRpb25Db3VudFxyXG4gICAgICAgICAgYXBwcm92ZWRBc3NvY2lhdGlvbkNvdW50XHJcbiAgICAgICAgICBhdGlPdmVyYWxsU2NvcmVcclxuICAgICAgICAgIGF0aU92ZXJhbGxDb25maWRlbmNlXHJcbiAgICAgICAgICBhdGlWZXJzaW9uXHJcbiAgICAgICAgICBhdGlDb21wdXRlZEF0XHJcbiAgICAgICAgICBhdGlCdW5kbGVKc29uXHJcbiAgICAgICAgICB0cnVzdExlZGdlclNjb3JlXHJcbiAgICAgICAgICB0cnVzdExlZGdlckJhZGdlQ291bnRcclxuICAgICAgICAgIHRydXN0TGVkZ2VyT3ZlcmFsbFJhbmtcclxuICAgICAgICAgIHRydXN0TGVkZ2VyQ2FwYWJpbGl0eVJhbmtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIGA7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy5jbGllbnQucmVxdWVzdChxdWVyeSwge1xuICAgICAgICAgICAgICAgIGxpbWl0OiBlZmZlY3RpdmVMaW1pdCxcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IGVmZmVjdGl2ZU9mZnNldCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgcGFnZUFnZW50cyA9IChkYXRhLmFnZW50cyB8fCBbXSkubWFwKChhZ2VudCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSB0aGlzLm5vcm1hbGl6ZUFnZW50KGFnZW50KTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnW0FJQWdlbnREaXNjb3ZlcnlDbGllbnQubGlzdEFnZW50c10gTm9ybWFsaXplZCBhZ2VudDonLCB7XG4gICAgICAgICAgICAgICAgICAgIGFnZW50SWQ6IG5vcm1hbGl6ZWQuYWdlbnRJZCxcbiAgICAgICAgICAgICAgICAgICAgcmF3QWdlbnROYW1lOiBhZ2VudC5hZ2VudE5hbWUsXG4gICAgICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWRBZ2VudE5hbWU6IG5vcm1hbGl6ZWQuYWdlbnROYW1lLFxuICAgICAgICAgICAgICAgICAgICBhZ2VudE5hbWVUeXBlOiB0eXBlb2Ygbm9ybWFsaXplZC5hZ2VudE5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGhhc1Jhd0pzb246ICEhbm9ybWFsaXplZC5yYXdKc29uLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBub3JtYWxpemVkO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhbGxBZ2VudHMgPSBhbGxBZ2VudHMuY29uY2F0KHBhZ2VBZ2VudHMpO1xuICAgICAgICAgICAgLy8gQXBwbHkgY2xpZW50LXNpZGUgb3JkZXJpbmcgdG8gZW5zdXJlIGRldGVybWluaXN0aWMgcmVzdWx0cyxcbiAgICAgICAgICAgIC8vIHNpbmNlIHRoZSBiYXNlIGFnZW50cyBxdWVyeSBtYXkgbm90IHN1cHBvcnQgb3JkZXJCeS9vcmRlckRpcmVjdGlvblxuICAgICAgICAgICAgLy8gYXJndW1lbnRzLiBEZWZhdWx0IGlzIGFnZW50SWQgREVTQyBmb3IgXCJuZXdlc3QgZmlyc3RcIi5cbiAgICAgICAgICAgIC8vIERlZmF1bHQgdG8gbmV3ZXN0IGFnZW50cyBmaXJzdCBieSBhZ2VudElkIERFU0NcbiAgICAgICAgICAgIGFsbEFnZW50cy5zb3J0KChhLCBiKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgaWRBID0gdHlwZW9mIGEuYWdlbnRJZCA9PT0gJ251bWJlcicgPyBhLmFnZW50SWQgOiBOdW1iZXIoYS5hZ2VudElkID8/IDApIHx8IDA7XG4gICAgICAgICAgICAgICAgY29uc3QgaWRCID0gdHlwZW9mIGIuYWdlbnRJZCA9PT0gJ251bWJlcicgPyBiLmFnZW50SWQgOiBOdW1iZXIoYi5hZ2VudElkID8/IDApIHx8IDA7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlkQiAtIGlkQTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdbQUlBZ2VudERpc2NvdmVyeUNsaWVudC5saXN0QWdlbnRzXSBFcnJvciBmZXRjaGluZyBhZ2VudHMgd2l0aCBwYWdpbmF0aW9uOicsIGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWxsQWdlbnRzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSdW4gYSBzZW1hbnRpYyBzZWFyY2ggb3ZlciBhZ2VudHMgdXNpbmcgdGhlIGRpc2NvdmVyeSBpbmRleGVyJ3NcbiAgICAgKiBgc2VtYW50aWNBZ2VudFNlYXJjaGAgR3JhcGhRTCBmaWVsZC5cbiAgICAgKlxuICAgICAqIE5PVEU6IFRoaXMgQVBJIGlzIGJlc3QtZWZmb3J0LiBJZiB0aGUgYmFja2VuZCBkb2VzIG5vdCBleHBvc2VcbiAgICAgKiBgc2VtYW50aWNBZ2VudFNlYXJjaGAsIHRoaXMgd2lsbCByZXR1cm4gYW4gZW1wdHkgcmVzdWx0IGluc3RlYWQgb2ZcbiAgICAgKiB0aHJvd2luZywgc28gY2FsbGVycyBjYW4gZmFsbCBiYWNrIGdyYWNlZnVsbHkuXG4gICAgICovXG4gICAgYXN5bmMgc2VtYW50aWNBZ2VudFNlYXJjaChwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgcmF3VGV4dCA9IHR5cGVvZiBwYXJhbXM/LnRleHQgPT09ICdzdHJpbmcnID8gcGFyYW1zLnRleHQgOiAnJztcbiAgICAgICAgY29uc3QgdGV4dCA9IHJhd1RleHQudHJpbSgpO1xuICAgICAgICBjb25zdCByYXdJbnRlbnRKc29uID0gdHlwZW9mIHBhcmFtcz8uaW50ZW50SnNvbiA9PT0gJ3N0cmluZycgPyBwYXJhbXMuaW50ZW50SnNvbiA6ICcnO1xuICAgICAgICBjb25zdCBpbnRlbnRKc29uID0gcmF3SW50ZW50SnNvbi50cmltKCk7XG4gICAgICAgIGNvbnN0IHRvcEsgPSB0eXBlb2YgcGFyYW1zPy50b3BLID09PSAnbnVtYmVyJyAmJiBOdW1iZXIuaXNGaW5pdGUocGFyYW1zLnRvcEspICYmIHBhcmFtcy50b3BLID4gMFxuICAgICAgICAgICAgPyBNYXRoLmZsb29yKHBhcmFtcy50b3BLKVxuICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIC8vIE5vdGhpbmcgdG8gc2VhcmNoLlxuICAgICAgICBpZiAoIXRleHQgJiYgIWludGVudEpzb24pIHtcbiAgICAgICAgICAgIHJldHVybiB7IHRvdGFsOiAwLCBtYXRjaGVzOiBbXSB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNlbGVjdGlvbiA9IGBcclxuICAgICAgdG90YWxcclxuICAgICAgbWF0Y2hlcyB7XHJcbiAgICAgICAgc2NvcmVcclxuICAgICAgICBtYXRjaFJlYXNvbnNcclxuICAgICAgICBhZ2VudCB7XHJcbiAgICAgICAgICBjaGFpbklkXHJcbiAgICAgICAgICBhZ2VudElkXHJcbiAgICAgICAgICBhZ2VudE5hbWVcclxuICAgICAgICAgIGFnZW50QWNjb3VudFxyXG4gICAgICAgICAgYWdlbnRJZGVudGl0eU93bmVyQWNjb3VudFxyXG4gICAgICAgICAgZW9hQWdlbnRJZGVudGl0eU93bmVyQWNjb3VudFxyXG4gICAgICAgICAgZW9hQWdlbnRBY2NvdW50XHJcbiAgICAgICAgICBhZ2VudENhdGVnb3J5XHJcbiAgICAgICAgICBkaWRJZGVudGl0eVxyXG4gICAgICAgICAgZGlkQWNjb3VudFxyXG4gICAgICAgICAgZGlkTmFtZVxyXG4gICAgICAgICAgYWdlbnRVcmlcclxuICAgICAgICAgIGNyZWF0ZWRBdEJsb2NrXHJcbiAgICAgICAgICBjcmVhdGVkQXRUaW1lXHJcbiAgICAgICAgICB1cGRhdGVkQXRUaW1lXHJcbiAgICAgICAgICB0eXBlXHJcbiAgICAgICAgICBkZXNjcmlwdGlvblxyXG4gICAgICAgICAgaW1hZ2VcclxuICAgICAgICAgIGEyYUVuZHBvaW50XHJcbiAgICAgICAgICBzdXBwb3J0ZWRUcnVzdFxyXG4gICAgICAgICAgcmF3SnNvblxyXG4gICAgICAgICAgYWdlbnRDYXJkSnNvblxyXG4gICAgICAgICAgYWdlbnRDYXJkUmVhZEF0XHJcbiAgICAgICAgICBkaWRcclxuICAgICAgICAgIG1jcFxyXG4gICAgICAgICAgeDQwMnN1cHBvcnRcclxuICAgICAgICAgIGFjdGl2ZVxyXG4gICAgICAgICAgZmVlZGJhY2tDb3VudFxyXG4gICAgICAgICAgZmVlZGJhY2tBdmVyYWdlU2NvcmVcclxuICAgICAgICAgIHZhbGlkYXRpb25QZW5kaW5nQ291bnRcclxuICAgICAgICAgIHZhbGlkYXRpb25Db21wbGV0ZWRDb3VudFxyXG4gICAgICAgICAgdmFsaWRhdGlvblJlcXVlc3RlZENvdW50XHJcbiAgICAgICAgICBpbml0aWF0ZWRBc3NvY2lhdGlvbkNvdW50XHJcbiAgICAgICAgICBhcHByb3ZlZEFzc29jaWF0aW9uQ291bnRcclxuICAgICAgICAgIGF0aU92ZXJhbGxTY29yZVxyXG4gICAgICAgICAgYXRpT3ZlcmFsbENvbmZpZGVuY2VcclxuICAgICAgICAgIGF0aVZlcnNpb25cclxuICAgICAgICAgIGF0aUNvbXB1dGVkQXRcclxuICAgICAgICAgIGF0aUJ1bmRsZUpzb25cclxuICAgICAgICAgIHRydXN0TGVkZ2VyU2NvcmVcclxuICAgICAgICAgIHRydXN0TGVkZ2VyQmFkZ2VDb3VudFxyXG4gICAgICAgICAgdHJ1c3RMZWRnZXJPdmVyYWxsUmFua1xyXG4gICAgICAgICAgdHJ1c3RMZWRnZXJDYXBhYmlsaXR5UmFua1xyXG4gICAgICAgICAgbWV0YWRhdGEge1xyXG4gICAgICAgICAgICBrZXlcclxuICAgICAgICAgICAgdmFsdWVUZXh0XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICBgO1xuICAgICAgICBjb25zdCBxdWVyeSA9IGludGVudEpzb25cbiAgICAgICAgICAgID8gYFxyXG4gICAgICAgIHF1ZXJ5IFNlYXJjaEJ5SW50ZW50KCRpbnRlbnRKc29uOiBTdHJpbmchLCAkdG9wSzogSW50KSB7XHJcbiAgICAgICAgICBzZW1hbnRpY0FnZW50U2VhcmNoKGlucHV0OiB7IGludGVudEpzb246ICRpbnRlbnRKc29uLCB0b3BLOiAkdG9wSyB9KSB7XHJcbiAgICAgICAgICAgICR7c2VsZWN0aW9ufVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgYFxuICAgICAgICAgICAgOiBgXHJcbiAgICAgICAgcXVlcnkgU2VhcmNoQnlUZXh0KCR0ZXh0OiBTdHJpbmchKSB7XHJcbiAgICAgICAgICBzZW1hbnRpY0FnZW50U2VhcmNoKGlucHV0OiB7IHRleHQ6ICR0ZXh0IH0pIHtcclxuICAgICAgICAgICAgJHtzZWxlY3Rpb259XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICBgO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHRoaXMuY2xpZW50LnJlcXVlc3QocXVlcnksIGludGVudEpzb24gPyB7IGludGVudEpzb24sIHRvcEsgfSA6IHsgdGV4dCB9KTtcbiAgICAgICAgICAgIGNvbnN0IHJvb3QgPSBkYXRhLnNlbWFudGljQWdlbnRTZWFyY2g7XG4gICAgICAgICAgICBpZiAoIXJvb3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB0b3RhbDogMCwgbWF0Y2hlczogW10gfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHRvdGFsID0gdHlwZW9mIHJvb3QudG90YWwgPT09ICdudW1iZXInICYmIE51bWJlci5pc0Zpbml0ZShyb290LnRvdGFsKSAmJiByb290LnRvdGFsID49IDBcbiAgICAgICAgICAgICAgICA/IHJvb3QudG90YWxcbiAgICAgICAgICAgICAgICA6IEFycmF5LmlzQXJyYXkocm9vdC5tYXRjaGVzKVxuICAgICAgICAgICAgICAgICAgICA/IHJvb3QubWF0Y2hlcy5sZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgOiAwO1xuICAgICAgICAgICAgY29uc3QgbWF0Y2hlcyA9IFtdO1xuICAgICAgICAgICAgY29uc3QgcmF3TWF0Y2hlcyA9IEFycmF5LmlzQXJyYXkocm9vdC5tYXRjaGVzKSA/IHJvb3QubWF0Y2hlcyA6IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIHJhd01hdGNoZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWl0ZW0gfHwgIWl0ZW0uYWdlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRBZ2VudCA9IHRoaXMubm9ybWFsaXplQWdlbnQoaXRlbS5hZ2VudCk7XG4gICAgICAgICAgICAgICAgLy8gRXh0cmFjdCBtZXRhZGF0YSBlbnRyaWVzIChpZiBwcmVzZW50KSBpbnRvIGEgc3Ryb25nbHktdHlwZWQgYXJyYXkuXG4gICAgICAgICAgICAgICAgY29uc3QgbWV0YWRhdGFSYXcgPSBpdGVtLmFnZW50Lm1ldGFkYXRhO1xuICAgICAgICAgICAgICAgIGxldCBtZXRhZGF0YSA9IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobWV0YWRhdGFSYXcpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVudHJpZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBlbnRyeSBvZiBtZXRhZGF0YVJhdykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFlbnRyeSB8fCB0eXBlb2YgZW50cnkua2V5ICE9PSAnc3RyaW5nJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVudHJpZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5OiBlbnRyeS5rZXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVUZXh0OiBlbnRyeS52YWx1ZVRleHQgPT09IG51bGwgfHwgZW50cnkudmFsdWVUZXh0ID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBudWxsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogU3RyaW5nKGVudHJ5LnZhbHVlVGV4dCksXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZW50cmllcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YSA9IGVudHJpZXM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG1ldGFkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWRBZ2VudC5tZXRhZGF0YSA9IG1ldGFkYXRhO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtYXRjaGVzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBzY29yZTogdHlwZW9mIGl0ZW0uc2NvcmUgPT09ICdudW1iZXInICYmIE51bWJlci5pc0Zpbml0ZShpdGVtLnNjb3JlKVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBpdGVtLnNjb3JlXG4gICAgICAgICAgICAgICAgICAgICAgICA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIG1hdGNoUmVhc29uczogQXJyYXkuaXNBcnJheShpdGVtLm1hdGNoUmVhc29ucylcbiAgICAgICAgICAgICAgICAgICAgICAgID8gaXRlbS5tYXRjaFJlYXNvbnMubWFwKChyZWFzb24pID0+IFN0cmluZyhyZWFzb24pKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBhZ2VudDogbm9ybWFsaXplZEFnZW50LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0b3RhbCxcbiAgICAgICAgICAgICAgICBtYXRjaGVzLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignW0FJQWdlbnREaXNjb3ZlcnlDbGllbnQuc2VtYW50aWNBZ2VudFNlYXJjaF0gRXJyb3IgcGVyZm9ybWluZyBzZW1hbnRpYyBzZWFyY2g6JywgZXJyb3IpO1xuICAgICAgICAgICAgcmV0dXJuIHsgdG90YWw6IDAsIG1hdGNoZXM6IFtdIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRmV0Y2ggT0FTRiBza2lsbHMgdGF4b25vbXkgZnJvbSB0aGUgZGlzY292ZXJ5IEdyYXBoUUwgZW5kcG9pbnQgKGJlc3QtZWZmb3J0KS5cbiAgICAgKiBSZXR1cm5zIFtdIGlmIHRoZSBiYWNrZW5kIGRvZXMgbm90IGV4cG9zZSBgb2FzZlNraWxsc2AuXG4gICAgICovXG4gICAgYXN5bmMgb2FzZlNraWxscyhwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgcXVlcnkgPSBgXHJcbiAgICAgIHF1ZXJ5IE9hc2ZTa2lsbHMoXHJcbiAgICAgICAgJGtleTogU3RyaW5nXHJcbiAgICAgICAgJG5hbWVLZXk6IFN0cmluZ1xyXG4gICAgICAgICRjYXRlZ29yeTogU3RyaW5nXHJcbiAgICAgICAgJGV4dGVuZHNLZXk6IFN0cmluZ1xyXG4gICAgICAgICRsaW1pdDogSW50XHJcbiAgICAgICAgJG9mZnNldDogSW50XHJcbiAgICAgICAgJG9yZGVyQnk6IFN0cmluZ1xyXG4gICAgICAgICRvcmRlckRpcmVjdGlvbjogU3RyaW5nXHJcbiAgICAgICkge1xyXG4gICAgICAgIG9hc2ZTa2lsbHMoXHJcbiAgICAgICAgICBrZXk6ICRrZXlcclxuICAgICAgICAgIG5hbWVLZXk6ICRuYW1lS2V5XHJcbiAgICAgICAgICBjYXRlZ29yeTogJGNhdGVnb3J5XHJcbiAgICAgICAgICBleHRlbmRzS2V5OiAkZXh0ZW5kc0tleVxyXG4gICAgICAgICAgbGltaXQ6ICRsaW1pdFxyXG4gICAgICAgICAgb2Zmc2V0OiAkb2Zmc2V0XHJcbiAgICAgICAgICBvcmRlckJ5OiAkb3JkZXJCeVxyXG4gICAgICAgICAgb3JkZXJEaXJlY3Rpb246ICRvcmRlckRpcmVjdGlvblxyXG4gICAgICAgICkge1xyXG4gICAgICAgICAga2V5XHJcbiAgICAgICAgICBuYW1lS2V5XHJcbiAgICAgICAgICB1aWRcclxuICAgICAgICAgIGNhcHRpb25cclxuICAgICAgICAgIGV4dGVuZHNLZXlcclxuICAgICAgICAgIGNhdGVnb3J5XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICBgO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHRoaXMuY2xpZW50LnJlcXVlc3QocXVlcnksIHtcbiAgICAgICAgICAgICAgICBrZXk6IHBhcmFtcz8ua2V5ID8/IG51bGwsXG4gICAgICAgICAgICAgICAgbmFtZUtleTogcGFyYW1zPy5uYW1lS2V5ID8/IG51bGwsXG4gICAgICAgICAgICAgICAgY2F0ZWdvcnk6IHBhcmFtcz8uY2F0ZWdvcnkgPz8gbnVsbCxcbiAgICAgICAgICAgICAgICBleHRlbmRzS2V5OiBwYXJhbXM/LmV4dGVuZHNLZXkgPz8gbnVsbCxcbiAgICAgICAgICAgICAgICBsaW1pdDogdHlwZW9mIHBhcmFtcz8ubGltaXQgPT09ICdudW1iZXInID8gcGFyYW1zLmxpbWl0IDogMTAwMDAsXG4gICAgICAgICAgICAgICAgb2Zmc2V0OiB0eXBlb2YgcGFyYW1zPy5vZmZzZXQgPT09ICdudW1iZXInID8gcGFyYW1zLm9mZnNldCA6IDAsXG4gICAgICAgICAgICAgICAgb3JkZXJCeTogcGFyYW1zPy5vcmRlckJ5ID8/ICdjYXRlZ29yeScsXG4gICAgICAgICAgICAgICAgb3JkZXJEaXJlY3Rpb246IHBhcmFtcz8ub3JkZXJEaXJlY3Rpb24gPz8gJ0FTQycsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KGRhdGE/Lm9hc2ZTa2lsbHMpID8gZGF0YS5vYXNmU2tpbGxzIDogW107XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpO1xuICAgICAgICAgICAgLy8gSWYgdGhlIGJhY2tlbmQgc2NoZW1hIGRvZXNuJ3QgZXhwb3NlIHRoZSBmaWVsZCwgdHJlYXQgaXQgYXMgXCJ1bnN1cHBvcnRlZFwiLlxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuaW5jbHVkZXMoJ0Nhbm5vdCBxdWVyeSBmaWVsZCBcIm9hc2ZTa2lsbHNcIicpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU29tZSBkZXBsb3ltZW50cyBleHBvc2UgdGhlIGZpZWxkIGJ1dCBlcnJvciBkdWUgdG8gcmVzb2x2ZXIgcmV0dXJuaW5nIG51bGwgZm9yIGEgbm9uLW51bGwgbGlzdC5cbiAgICAgICAgICAgIC8vIFRyZWF0IHRoaXMgYXMgXCJ0YXhvbm9teSB1bmF2YWlsYWJsZVwiIHJhdGhlciB0aGFuIGZhaWxpbmcgdGhlIGNhbGxlci5cbiAgICAgICAgICAgIGlmICgvQ2Fubm90IHJldHVybiBudWxsIGZvciBub24tbnVsbGFibGUgZmllbGRcXHMrUXVlcnlcXC5vYXNmU2tpbGxzXFxiL2kudGVzdChtZXNzYWdlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnNvbGUud2FybignW0FJQWdlbnREaXNjb3ZlcnlDbGllbnRdIG9hc2ZTa2lsbHMgcXVlcnkgZmFpbGVkOicsIGVycm9yKTtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZldGNoIE9BU0YgZG9tYWlucyB0YXhvbm9teSBmcm9tIHRoZSBkaXNjb3ZlcnkgR3JhcGhRTCBlbmRwb2ludCAoYmVzdC1lZmZvcnQpLlxuICAgICAqIFJldHVybnMgW10gaWYgdGhlIGJhY2tlbmQgZG9lcyBub3QgZXhwb3NlIGBvYXNmRG9tYWluc2AuXG4gICAgICovXG4gICAgYXN5bmMgb2FzZkRvbWFpbnMocGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IHF1ZXJ5ID0gYFxyXG4gICAgICBxdWVyeSBPYXNmRG9tYWlucyhcclxuICAgICAgICAka2V5OiBTdHJpbmdcclxuICAgICAgICAkbmFtZUtleTogU3RyaW5nXHJcbiAgICAgICAgJGNhdGVnb3J5OiBTdHJpbmdcclxuICAgICAgICAkZXh0ZW5kc0tleTogU3RyaW5nXHJcbiAgICAgICAgJGxpbWl0OiBJbnRcclxuICAgICAgICAkb2Zmc2V0OiBJbnRcclxuICAgICAgICAkb3JkZXJCeTogU3RyaW5nXHJcbiAgICAgICAgJG9yZGVyRGlyZWN0aW9uOiBTdHJpbmdcclxuICAgICAgKSB7XHJcbiAgICAgICAgb2FzZkRvbWFpbnMoXHJcbiAgICAgICAgICBrZXk6ICRrZXlcclxuICAgICAgICAgIG5hbWVLZXk6ICRuYW1lS2V5XHJcbiAgICAgICAgICBjYXRlZ29yeTogJGNhdGVnb3J5XHJcbiAgICAgICAgICBleHRlbmRzS2V5OiAkZXh0ZW5kc0tleVxyXG4gICAgICAgICAgbGltaXQ6ICRsaW1pdFxyXG4gICAgICAgICAgb2Zmc2V0OiAkb2Zmc2V0XHJcbiAgICAgICAgICBvcmRlckJ5OiAkb3JkZXJCeVxyXG4gICAgICAgICAgb3JkZXJEaXJlY3Rpb246ICRvcmRlckRpcmVjdGlvblxyXG4gICAgICAgICkge1xyXG4gICAgICAgICAga2V5XHJcbiAgICAgICAgICBuYW1lS2V5XHJcbiAgICAgICAgICB1aWRcclxuICAgICAgICAgIGNhcHRpb25cclxuICAgICAgICAgIGV4dGVuZHNLZXlcclxuICAgICAgICAgIGNhdGVnb3J5XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICBgO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHRoaXMuY2xpZW50LnJlcXVlc3QocXVlcnksIHtcbiAgICAgICAgICAgICAgICBrZXk6IHBhcmFtcz8ua2V5ID8/IG51bGwsXG4gICAgICAgICAgICAgICAgbmFtZUtleTogcGFyYW1zPy5uYW1lS2V5ID8/IG51bGwsXG4gICAgICAgICAgICAgICAgY2F0ZWdvcnk6IHBhcmFtcz8uY2F0ZWdvcnkgPz8gbnVsbCxcbiAgICAgICAgICAgICAgICBleHRlbmRzS2V5OiBwYXJhbXM/LmV4dGVuZHNLZXkgPz8gbnVsbCxcbiAgICAgICAgICAgICAgICBsaW1pdDogdHlwZW9mIHBhcmFtcz8ubGltaXQgPT09ICdudW1iZXInID8gcGFyYW1zLmxpbWl0IDogMTAwMDAsXG4gICAgICAgICAgICAgICAgb2Zmc2V0OiB0eXBlb2YgcGFyYW1zPy5vZmZzZXQgPT09ICdudW1iZXInID8gcGFyYW1zLm9mZnNldCA6IDAsXG4gICAgICAgICAgICAgICAgb3JkZXJCeTogcGFyYW1zPy5vcmRlckJ5ID8/ICdjYXRlZ29yeScsXG4gICAgICAgICAgICAgICAgb3JkZXJEaXJlY3Rpb246IHBhcmFtcz8ub3JkZXJEaXJlY3Rpb24gPz8gJ0FTQycsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KGRhdGE/Lm9hc2ZEb21haW5zKSA/IGRhdGEub2FzZkRvbWFpbnMgOiBbXTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvcik7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5pbmNsdWRlcygnQ2Fubm90IHF1ZXJ5IGZpZWxkIFwib2FzZkRvbWFpbnNcIicpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKC9DYW5ub3QgcmV0dXJuIG51bGwgZm9yIG5vbi1udWxsYWJsZSBmaWVsZFxccytRdWVyeVxcLm9hc2ZEb21haW5zXFxiL2kudGVzdChtZXNzYWdlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnNvbGUud2FybignW0FJQWdlbnREaXNjb3ZlcnlDbGllbnRdIG9hc2ZEb21haW5zIHF1ZXJ5IGZhaWxlZDonLCBlcnJvcik7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBzZWFyY2hBZ2VudHNBZHZhbmNlZChvcHRpb25zKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCc+Pj4+Pj4+Pj4+Pj4+Pj4+Pj4gc2VhcmNoQWdlbnRzQWR2YW5jZWQnLCBvcHRpb25zKTtcbiAgICAgICAgY29uc3Qgc3RyYXRlZ3kgPSBhd2FpdCB0aGlzLmRldGVjdFNlYXJjaFN0cmF0ZWd5KCk7XG4gICAgICAgIGNvbnN0IHsgcXVlcnksIHBhcmFtcywgbGltaXQsIG9mZnNldCB9ID0gb3B0aW9ucztcbiAgICAgICAgY29uc3QgdHJpbW1lZFF1ZXJ5ID0gdHlwZW9mIHF1ZXJ5ID09PSAnc3RyaW5nJyA/IHF1ZXJ5LnRyaW0oKSA6ICcnO1xuICAgICAgICBjb25zdCBoYXNRdWVyeSA9IHRyaW1tZWRRdWVyeS5sZW5ndGggPiAwO1xuICAgICAgICBjb25zdCBoYXNQYXJhbXMgPSBwYXJhbXMgJiYgT2JqZWN0LmtleXMocGFyYW1zKS5sZW5ndGggPiAwO1xuICAgICAgICBpZiAoIWhhc1F1ZXJ5ICYmICFoYXNQYXJhbXMpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIG5vIGRldGVjdGVkIHN0cmF0ZWd5IChpbnRyb3NwZWN0aW9uIGRpc2FibGVkKSwgYXR0ZW1wdCBhIGRpcmVjdCBsaXN0LWZvcm0gc2VhcmNoQWdlbnRzIGNhbGwuXG4gICAgICAgIC8vIE9ubHkgdXNlIHRoaXMgZmFsbGJhY2sgaWYgd2UgaGF2ZSBhIHF1ZXJ5IHN0cmluZywgc2luY2UgdGhlIEdyYXBoUUwgcXVlcnkgcmVxdWlyZXMgYSBub24tbnVsbCBxdWVyeSBwYXJhbWV0ZXIuXG4gICAgICAgIC8vIElmIHdlIG9ubHkgaGF2ZSBwYXJhbXMgYnV0IG5vIHF1ZXJ5LCByZXR1cm4gbnVsbCB0byB0cmlnZ2VyIGxvY2FsIGZpbHRlcmluZyBmYWxsYmFjay5cbiAgICAgICAgY29uc29sZS5sb2coJz4+Pj4+Pj4+Pj4+Pj4+Pj4+PiAwMTIgc3RyYXRlZ3knLCBzdHJhdGVneSk7XG4gICAgICAgIGlmICghc3RyYXRlZ3kpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCc+Pj4+Pj4+Pj4+Pj4+Pj4+Pj4gMDEyIGhhc1F1ZXJ5JywgaGFzUXVlcnkpO1xuICAgICAgICAgICAgaWYgKGhhc1F1ZXJ5KSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJz4+Pj4+Pj4+Pj4+Pj4+Pj4+PiAwMTIgdHJpbW1lZFF1ZXJ5JywgdHJpbW1lZFF1ZXJ5KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJz4+Pj4+Pj4+Pj4+Pj4+Pj4+PiAwMTIgbGltaXQnLCBsaW1pdCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCc+Pj4+Pj4+Pj4+Pj4+Pj4+Pj4gMDEyIG9mZnNldCcsIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCc+Pj4+Pj4+Pj4+Pj4+Pj4+Pj4gMDEyIG9wdGlvbnMub3JkZXJCeScsIG9wdGlvbnMub3JkZXJCeSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCc+Pj4+Pj4+Pj4+Pj4+Pj4+Pj4gMDEyIG9wdGlvbnMub3JkZXJEaXJlY3Rpb24nLCBvcHRpb25zLm9yZGVyRGlyZWN0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcXVlcnlUZXh0ID0gYFxyXG4gICAgICAgICAgICBxdWVyeSBTZWFyY2hBZ2VudHNGYWxsYmFjaygkcXVlcnk6IFN0cmluZyEsICRsaW1pdDogSW50LCAkb2Zmc2V0OiBJbnQsICRvcmRlckJ5OiBTdHJpbmcsICRvcmRlckRpcmVjdGlvbjogU3RyaW5nKSB7XHJcbiAgICAgICAgICAgICAgc2VhcmNoQWdlbnRzKHF1ZXJ5OiAkcXVlcnksIGxpbWl0OiAkbGltaXQsIG9mZnNldDogJG9mZnNldCwgb3JkZXJCeTogJG9yZGVyQnksIG9yZGVyRGlyZWN0aW9uOiAkb3JkZXJEaXJlY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgIGNoYWluSWRcclxuICAgICAgICAgICAgICAgIGFnZW50SWRcclxuICAgICAgICAgICAgICAgIGFnZW50TmFtZVxyXG4gICAgICAgICAgICAgICAgYWdlbnRBY2NvdW50XHJcbiAgICAgICAgICAgICAgICBhZ2VudElkZW50aXR5T3duZXJBY2NvdW50XHJcbiAgICAgICAgICAgICAgICBlb2FBZ2VudElkZW50aXR5T3duZXJBY2NvdW50XHJcbiAgICAgICAgICAgICAgICBlb2FBZ2VudEFjY291bnRcclxuICAgICAgICAgICAgICAgIGFnZW50Q2F0ZWdvcnlcclxuICAgICAgICAgICAgICAgIGRpZElkZW50aXR5XHJcbiAgICAgICAgICAgICAgICBkaWRBY2NvdW50XHJcbiAgICAgICAgICAgICAgICBkaWROYW1lXHJcbiAgICAgICAgICAgICAgICBhZ2VudFVyaVxyXG4gICAgICAgICAgICAgICAgY3JlYXRlZEF0QmxvY2tcclxuICAgICAgICAgICAgICAgIGNyZWF0ZWRBdFRpbWVcclxuICAgICAgICAgICAgICAgIHVwZGF0ZWRBdFRpbWVcclxuICAgICAgICAgICAgICAgIHR5cGVcclxuICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uXHJcbiAgICAgICAgICAgICAgICBpbWFnZVxyXG4gICAgICAgICAgICAgICAgYTJhRW5kcG9pbnRcclxuICAgICAgICAgICAgICAgIGRpZFxyXG4gICAgICAgICAgICAgICAgbWNwXHJcbiAgICAgICAgICAgICAgICB4NDAyc3VwcG9ydFxyXG4gICAgICAgICAgICAgICAgYWN0aXZlXHJcbiAgICAgICAgICAgICAgICBzdXBwb3J0ZWRUcnVzdFxyXG4gICAgICAgICAgICAgICAgcmF3SnNvblxyXG4gICAgICAgICAgICAgICAgYWdlbnRDYXJkSnNvblxyXG4gICAgICAgICAgICAgICAgYWdlbnRDYXJkUmVhZEF0XHJcbiAgICAgICAgICAgICAgICBmZWVkYmFja0NvdW50XHJcbiAgICAgICAgICAgICAgICBmZWVkYmFja0F2ZXJhZ2VTY29yZVxyXG4gICAgICAgICAgICAgICAgdmFsaWRhdGlvblBlbmRpbmdDb3VudFxyXG4gICAgICAgICAgICAgICAgdmFsaWRhdGlvbkNvbXBsZXRlZENvdW50XHJcbiAgICAgICAgICAgICAgICB2YWxpZGF0aW9uUmVxdWVzdGVkQ291bnRcclxuICAgICAgICAgICAgICAgIGluaXRpYXRlZEFzc29jaWF0aW9uQ291bnRcclxuICAgICAgICAgICAgICAgIGFwcHJvdmVkQXNzb2NpYXRpb25Db3VudFxyXG4gICAgICAgICAgICAgICAgYXRpT3ZlcmFsbFNjb3JlXHJcbiAgICAgICAgICAgICAgICBhdGlPdmVyYWxsQ29uZmlkZW5jZVxyXG4gICAgICAgICAgICAgICAgYXRpVmVyc2lvblxyXG4gICAgICAgICAgICAgICAgYXRpQ29tcHV0ZWRBdFxyXG4gICAgICAgICAgICAgICAgYXRpQnVuZGxlSnNvblxyXG4gICAgICAgICAgICAgICAgdHJ1c3RMZWRnZXJTY29yZVxyXG4gICAgICAgICAgICAgICAgdHJ1c3RMZWRnZXJCYWRnZUNvdW50XHJcbiAgICAgICAgICAgICAgICB0cnVzdExlZGdlck92ZXJhbGxSYW5rXHJcbiAgICAgICAgICAgICAgICB0cnVzdExlZGdlckNhcGFiaWxpdHlSYW5rXHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICBgO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB2YXJpYWJsZXMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBxdWVyeTogdHJpbW1lZFF1ZXJ5LFxuICAgICAgICAgICAgICAgICAgICAgICAgbGltaXQ6IHR5cGVvZiBsaW1pdCA9PT0gJ251bWJlcicgPyBsaW1pdCA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldDogdHlwZW9mIG9mZnNldCA9PT0gJ251bWJlcicgPyBvZmZzZXQgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBvcmRlckJ5OiBvcHRpb25zLm9yZGVyQnksXG4gICAgICAgICAgICAgICAgICAgICAgICBvcmRlckRpcmVjdGlvbjogb3B0aW9ucy5vcmRlckRpcmVjdGlvbixcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHRoaXMuY2xpZW50LnJlcXVlc3QocXVlcnlUZXh0LCB2YXJpYWJsZXMpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsaXN0ID0gZGF0YT8uc2VhcmNoQWdlbnRzO1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnPj4+Pj4+Pj4+Pj4+Pj4+Pj4+IDAxMiBsaXN0Lmxlbmd0aCcsIGxpc3Q/Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsaXN0ICYmIGxpc3QubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJz4+Pj4+Pj4+Pj4+Pj4+Pj4+PiAwMTIgRmlyc3QgcmF3IGFnZW50IHNhbXBsZTonLCBKU09OLnN0cmluZ2lmeShsaXN0WzBdLCBudWxsLCAyKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobGlzdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRMaXN0ID0gbGlzdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoQm9vbGVhbilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmF3QWdlbnQgPSBpdGVtO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSB0aGlzLm5vcm1hbGl6ZUFnZW50KHJhd0FnZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnW0FJQWdlbnREaXNjb3ZlcnlDbGllbnQuc2VhcmNoQWdlbnRzQWR2YW5jZWRdIE5vcm1hbGl6ZWQgYWdlbnQgKGZhbGxiYWNrKTonLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFnZW50SWQ6IG5vcm1hbGl6ZWQuYWdlbnRJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmF3QWdlbnROYW1lOiByYXdBZ2VudC5hZ2VudE5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWRBZ2VudE5hbWU6IG5vcm1hbGl6ZWQuYWdlbnROYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZ2VudE5hbWVUeXBlOiB0eXBlb2Ygbm9ybWFsaXplZC5hZ2VudE5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhc1Jhd0pzb246ICEhbm9ybWFsaXplZC5yYXdKc29uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBub3JtYWxpemVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnW0FJQWdlbnREaXNjb3ZlcnlDbGllbnQuc2VhcmNoQWdlbnRzQWR2YW5jZWRdIFJldHVybmluZyBub3JtYWxpemVkIGFnZW50cyAoZmFsbGJhY2spOicsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3VudDogbm9ybWFsaXplZExpc3QubGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFnZW50TmFtZXM6IG5vcm1hbGl6ZWRMaXN0Lm1hcChhID0+ICh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFnZW50SWQ6IGEuYWdlbnRJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWdlbnROYW1lOiBhLmFnZW50TmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWdlbnROYW1lVHlwZTogdHlwZW9mIGEuYWdlbnROYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRW5zdXJlIGZhbGxiYWNrIHJlc3BlY3RzIHRoZSByZXF1ZXN0ZWQgb3JkZXJpbmcsIGV2ZW4gaWYgdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB1bmRlcmx5aW5nIHNlYXJjaEFnZW50cyByZXNvbHZlciB1c2VzIGl0cyBvd24gZGVmYXVsdCBvcmRlci5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG9yZGVyQnkgPSB0eXBlb2Ygb3B0aW9ucy5vcmRlckJ5ID09PSAnc3RyaW5nJyA/IG9wdGlvbnMub3JkZXJCeS50cmltKCkgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvcmRlckRpcmVjdGlvblJhdyA9IHR5cGVvZiBvcHRpb25zLm9yZGVyRGlyZWN0aW9uID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gb3B0aW9ucy5vcmRlckRpcmVjdGlvbi50b1VwcGVyQ2FzZSgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAnREVTQyc7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvcmRlckRpcmVjdGlvbiA9IG9yZGVyRGlyZWN0aW9uUmF3ID09PSAnREVTQycgPyAnREVTQycgOiAnQVNDJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcmRlckJ5ID09PSAnYWdlbnROYW1lJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWRMaXN0LnNvcnQoKGEsIGIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYU5hbWUgPSAoYS5hZ2VudE5hbWUgPz8gJycpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGJOYW1lID0gKGIuYWdlbnROYW1lID8/ICcnKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3JkZXJEaXJlY3Rpb24gPT09ICdBU0MnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGFOYW1lLmxvY2FsZUNvbXBhcmUoYk5hbWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGJOYW1lLmxvY2FsZUNvbXBhcmUoYU5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAob3JkZXJCeSA9PT0gJ2FnZW50SWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9ybWFsaXplZExpc3Quc29ydCgoYSwgYikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpZEEgPSB0eXBlb2YgYS5hZ2VudElkID09PSAnbnVtYmVyJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBhLmFnZW50SWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogTnVtYmVyKGEuYWdlbnRJZCA/PyAwKSB8fCAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpZEIgPSB0eXBlb2YgYi5hZ2VudElkID09PSAnbnVtYmVyJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBiLmFnZW50SWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogTnVtYmVyKGIuYWdlbnRJZCA/PyAwKSB8fCAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3JkZXJEaXJlY3Rpb24gPT09ICdBU0MnID8gaWRBIC0gaWRCIDogaWRCIC0gaWRBO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAob3JkZXJCeSA9PT0gJ2NyZWF0ZWRBdFRpbWUnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9ybWFsaXplZExpc3Quc29ydCgoYSwgYikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0QSA9IHR5cGVvZiBhLmNyZWF0ZWRBdFRpbWUgPT09ICdudW1iZXInXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGEuY3JlYXRlZEF0VGltZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBOdW1iZXIoYS5jcmVhdGVkQXRUaW1lID8/IDApIHx8IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRCID0gdHlwZW9mIGIuY3JlYXRlZEF0VGltZSA9PT0gJ251bWJlcidcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gYi5jcmVhdGVkQXRUaW1lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IE51bWJlcihiLmNyZWF0ZWRBdFRpbWUgPz8gMCkgfHwgMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9yZGVyRGlyZWN0aW9uID09PSAnQVNDJyA/IHRBIC0gdEIgOiB0QiAtIHRBO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAob3JkZXJCeSA9PT0gJ2NyZWF0ZWRBdEJsb2NrJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWRMaXN0LnNvcnQoKGEsIGIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYkEgPSB0eXBlb2YgYS5jcmVhdGVkQXRCbG9jayA9PT0gJ251bWJlcidcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gYS5jcmVhdGVkQXRCbG9ja1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBOdW1iZXIoYS5jcmVhdGVkQXRCbG9jayA/PyAwKSB8fCAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBiQiA9IHR5cGVvZiBiLmNyZWF0ZWRBdEJsb2NrID09PSAnbnVtYmVyJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBiLmNyZWF0ZWRBdEJsb2NrXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IE51bWJlcihiLmNyZWF0ZWRBdEJsb2NrID8/IDApIHx8IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvcmRlckRpcmVjdGlvbiA9PT0gJ0FTQycgPyBiQSAtIGJCIDogYkIgLSBiQTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCc+Pj4+Pj4+Pj4+Pj4+Pj4+Pj4gMzQ1IEFkdmFuY2VkU2VhcmNoJywgbm9ybWFsaXplZExpc3QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgYWdlbnRzOiBub3JtYWxpemVkTGlzdCwgdG90YWw6IHVuZGVmaW5lZCB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1tBSUFnZW50RGlzY292ZXJ5Q2xpZW50XSBGYWxsYmFjayBzZWFyY2hBZ2VudHMgY2FsbCBmYWlsZWQ6JywgZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIG5vIHN0cmF0ZWd5IGFuZCBubyBxdWVyeSAob25seSBwYXJhbXMpLCByZXR1cm4gbnVsbCB0byB0cmlnZ2VyIGxvY2FsIGZpbHRlcmluZyBmYWxsYmFja1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmFyaWFibGVzID0ge307XG4gICAgICAgIGNvbnN0IHZhcmlhYmxlRGVmaW5pdGlvbnMgPSBbXTtcbiAgICAgICAgY29uc3QgYXJndW1lbnRBc3NpZ25tZW50cyA9IFtdO1xuICAgICAgICBjb25zdCBhZ2VudFNlbGVjdGlvbiA9IGBcclxuICAgICAgY2hhaW5JZFxyXG4gICAgICBhZ2VudElkXHJcbiAgICAgIGFnZW50TmFtZVxyXG4gICAgICBhZ2VudEFjY291bnRcclxuICAgICAgYWdlbnRJZGVudGl0eU93bmVyQWNjb3VudFxyXG4gICAgICBlb2FBZ2VudElkZW50aXR5T3duZXJBY2NvdW50XHJcbiAgICAgIGVvYUFnZW50QWNjb3VudFxyXG4gICAgICBhZ2VudENhdGVnb3J5XHJcbiAgICAgIGRpZElkZW50aXR5XHJcbiAgICAgIGRpZEFjY291bnRcclxuICAgICAgZGlkTmFtZVxyXG4gICAgICBhZ2VudFVyaVxyXG4gICAgICBjcmVhdGVkQXRCbG9ja1xyXG4gICAgICBjcmVhdGVkQXRUaW1lXHJcbiAgICAgIHVwZGF0ZWRBdFRpbWVcclxuICAgICAgdHlwZVxyXG4gICAgICBkZXNjcmlwdGlvblxyXG4gICAgICBpbWFnZVxyXG4gICAgICBhMmFFbmRwb2ludFxyXG4gICAgICBkaWRcclxuICAgICAgbWNwXHJcbiAgICAgIHg0MDJzdXBwb3J0XHJcbiAgICAgIGFjdGl2ZVxyXG4gICAgICBzdXBwb3J0ZWRUcnVzdFxyXG4gICAgICByYXdKc29uXHJcbiAgICAgIGZlZWRiYWNrQ291bnRcclxuICAgICAgZmVlZGJhY2tBdmVyYWdlU2NvcmVcclxuICAgICAgdmFsaWRhdGlvblBlbmRpbmdDb3VudFxyXG4gICAgICB2YWxpZGF0aW9uQ29tcGxldGVkQ291bnRcclxuICAgICAgdmFsaWRhdGlvblJlcXVlc3RlZENvdW50XHJcbiAgICBgO1xuICAgICAgICBjb25zdCBhZGRTdHJpbmdBcmcgPSAoYXJnLCB2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgaWYgKCFhcmcpXG4gICAgICAgICAgICAgICAgcmV0dXJuICF2YWx1ZTtcbiAgICAgICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJnLmlzTm9uTnVsbCA/IGZhbHNlIDogdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHR5cGVOYW1lID0gYXJnLnR5cGVOYW1lID8/ICdTdHJpbmcnO1xuICAgICAgICAgICAgdmFyaWFibGVEZWZpbml0aW9ucy5wdXNoKGAkJHthcmcubmFtZX06ICR7dHlwZU5hbWV9JHthcmcuaXNOb25OdWxsID8gJyEnIDogJyd9YCk7XG4gICAgICAgICAgICBhcmd1bWVudEFzc2lnbm1lbnRzLnB1c2goYCR7YXJnLm5hbWV9OiAkJHthcmcubmFtZX1gKTtcbiAgICAgICAgICAgIHZhcmlhYmxlc1thcmcubmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBhZGRJbnB1dEFyZyA9IChhcmcsIHZhbHVlKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWFyZylcbiAgICAgICAgICAgICAgICByZXR1cm4gIXZhbHVlO1xuICAgICAgICAgICAgaWYgKCF2YWx1ZSB8fCBPYmplY3Qua2V5cyh2YWx1ZSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFyZy5pc05vbk51bGwgPyBmYWxzZSA6IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0eXBlTmFtZSA9IGFyZy50eXBlTmFtZSA/PyAnSlNPTic7XG4gICAgICAgICAgICB2YXJpYWJsZURlZmluaXRpb25zLnB1c2goYCQke2FyZy5uYW1lfTogJHt0eXBlTmFtZX0ke2FyZy5pc05vbk51bGwgPyAnIScgOiAnJ31gKTtcbiAgICAgICAgICAgIGFyZ3VtZW50QXNzaWdubWVudHMucHVzaChgJHthcmcubmFtZX06ICQke2FyZy5uYW1lfWApO1xuICAgICAgICAgICAgdmFyaWFibGVzW2FyZy5uYW1lXSA9IHZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGFkZEludEFyZyA9IChhcmcsIHZhbHVlKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWFyZylcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChhcmcuaXNOb25OdWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdHlwZU5hbWUgPSBhcmcudHlwZU5hbWUgPz8gJ0ludCc7XG4gICAgICAgICAgICB2YXJpYWJsZURlZmluaXRpb25zLnB1c2goYCQke2FyZy5uYW1lfTogJHt0eXBlTmFtZX0ke2FyZy5pc05vbk51bGwgPyAnIScgOiAnJ31gKTtcbiAgICAgICAgICAgIGFyZ3VtZW50QXNzaWdubWVudHMucHVzaChgJHthcmcubmFtZX06ICQke2FyZy5uYW1lfWApO1xuICAgICAgICAgICAgdmFyaWFibGVzW2FyZy5uYW1lXSA9IHZhbHVlO1xuICAgICAgICB9O1xuICAgICAgICBpZiAoc3RyYXRlZ3kua2luZCA9PT0gJ2Nvbm5lY3Rpb24nKSB7XG4gICAgICAgICAgICAvLyBBZGQgcXVlcnkgYXJnIG9ubHkgaWYgd2UgaGF2ZSBhIHF1ZXJ5LCBvciBpZiBxdWVyeUFyZyBpcyBvcHRpb25hbFxuICAgICAgICAgICAgLy8gSWYgcXVlcnlBcmcgaXMgcmVxdWlyZWQgKG5vbi1udWxsKSBidXQgd2UgZG9uJ3QgaGF2ZSBhIHF1ZXJ5LCBvbmx5IHByb2NlZWQgaWYgd2UgaGF2ZSBwYXJhbXNcbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5QXJnQWRkZWQgPSBhZGRTdHJpbmdBcmcoc3RyYXRlZ3kucXVlcnlBcmcsIGhhc1F1ZXJ5ID8gdHJpbW1lZFF1ZXJ5IDogdW5kZWZpbmVkKTtcbiAgICAgICAgICAgIGlmICghcXVlcnlBcmdBZGRlZCAmJiBzdHJhdGVneS5xdWVyeUFyZz8uaXNOb25OdWxsICYmICFoYXNQYXJhbXMpIHtcbiAgICAgICAgICAgICAgICAvLyBSZXF1aXJlZCBxdWVyeSBhcmcgYnV0IG5vIHF1ZXJ5IGFuZCBubyBwYXJhbXMgLSBjYW4ndCBwcm9jZWVkXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBZGQgZmlsdGVyIGFyZyBpZiB3ZSBoYXZlIHBhcmFtc1xuICAgICAgICAgICAgY29uc3QgZmlsdGVyQXJnQWRkZWQgPSBhZGRJbnB1dEFyZyhzdHJhdGVneS5maWx0ZXJBcmcsIGhhc1BhcmFtcyA/IHBhcmFtcyA6IHVuZGVmaW5lZCk7XG4gICAgICAgICAgICBpZiAoIWZpbHRlckFyZ0FkZGVkICYmIHN0cmF0ZWd5LmZpbHRlckFyZz8uaXNOb25OdWxsICYmICFoYXNRdWVyeSkge1xuICAgICAgICAgICAgICAgIC8vIFJlcXVpcmVkIGZpbHRlciBhcmcgYnV0IG5vIHBhcmFtcyBhbmQgbm8gcXVlcnkgLSBjYW4ndCBwcm9jZWVkXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiBuZWl0aGVyIHF1ZXJ5IG5vciBwYXJhbXMgd2VyZSBhZGRlZCwgYW5kIGJvdGggYXJlIG9wdGlvbmFsLCB3ZSBuZWVkIGF0IGxlYXN0IG9uZVxuICAgICAgICAgICAgaWYgKCFxdWVyeUFyZ0FkZGVkICYmICFmaWx0ZXJBcmdBZGRlZCAmJiAoIXN0cmF0ZWd5LnF1ZXJ5QXJnIHx8ICFzdHJhdGVneS5maWx0ZXJBcmcpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhZGRJbnRBcmcoc3RyYXRlZ3kubGltaXRBcmcsIHR5cGVvZiBsaW1pdCA9PT0gJ251bWJlcicgPyBsaW1pdCA6IHVuZGVmaW5lZCk7XG4gICAgICAgICAgICBhZGRJbnRBcmcoc3RyYXRlZ3kub2Zmc2V0QXJnLCB0eXBlb2Ygb2Zmc2V0ID09PSAnbnVtYmVyJyA/IG9mZnNldCA6IHVuZGVmaW5lZCk7XG4gICAgICAgICAgICBhZGRTdHJpbmdBcmcoc3RyYXRlZ3kub3JkZXJCeUFyZywgb3B0aW9ucy5vcmRlckJ5KTtcbiAgICAgICAgICAgIGFkZFN0cmluZ0FyZyhzdHJhdGVneS5vcmRlckRpcmVjdGlvbkFyZywgb3B0aW9ucy5vcmRlckRpcmVjdGlvbik7XG4gICAgICAgICAgICBpZiAoYXJndW1lbnRBc3NpZ25tZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCc+Pj4+Pj4+Pj4+Pj4+Pj4+Pj4gQWR2YW5jZWRTZWFyY2gnLCB2YXJpYWJsZURlZmluaXRpb25zLCBhcmd1bWVudEFzc2lnbm1lbnRzKTtcbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5VGV4dCA9IGBcclxuICAgICAgICBxdWVyeSBBZHZhbmNlZFNlYXJjaCgke3ZhcmlhYmxlRGVmaW5pdGlvbnMuam9pbignLCAnKX0pIHtcclxuICAgICAgICAgICR7c3RyYXRlZ3kuZmllbGROYW1lfSgke2FyZ3VtZW50QXNzaWdubWVudHMuam9pbignLCAnKX0pIHtcclxuICAgICAgICAgICAgJHtzdHJhdGVneS50b3RhbEZpZWxkTmFtZSA/IGAke3N0cmF0ZWd5LnRvdGFsRmllbGROYW1lfWAgOiAnJ31cclxuICAgICAgICAgICAgJHtzdHJhdGVneS5saXN0RmllbGROYW1lfSB7XHJcbiAgICAgICAgICAgICAgY2hhaW5JZFxyXG4gICAgICAgICAgICAgIGFnZW50SWRcclxuICAgICAgICAgICAgICBhZ2VudEFjY291bnRcclxuICAgICAgICAgICAgICBhZ2VudE5hbWVcclxuICAgICAgICAgICAgICBhZ2VudElkZW50aXR5T3duZXJBY2NvdW50XHJcbiAgICAgICAgICAgICAgZW9hQWdlbnRJZGVudGl0eU93bmVyQWNjb3VudFxyXG4gICAgICAgICAgICAgIGVvYUFnZW50QWNjb3VudFxyXG4gICAgICAgICAgICAgIGFnZW50Q2F0ZWdvcnlcclxuICAgICAgICAgICAgICBkaWRJZGVudGl0eVxyXG4gICAgICAgICAgICAgIGRpZEFjY291bnRcclxuICAgICAgICAgICAgICBkaWROYW1lXHJcbiAgICAgICAgICAgICAgYWdlbnRVcmlcclxuICAgICAgICAgICAgICBjcmVhdGVkQXRCbG9ja1xyXG4gICAgICAgICAgICAgIGNyZWF0ZWRBdFRpbWVcclxuICAgICAgICAgICAgICB1cGRhdGVkQXRUaW1lXHJcbiAgICAgICAgICAgICAgdHlwZVxyXG4gICAgICAgICAgICAgIGRlc2NyaXB0aW9uXHJcbiAgICAgICAgICAgICAgaW1hZ2VcclxuICAgICAgICAgICAgICBhMmFFbmRwb2ludFxyXG4gICAgICAgICAgICAgIGRpZFxyXG4gICAgICAgICAgICAgIG1jcFxyXG4gICAgICAgICAgICAgIHg0MDJzdXBwb3J0XHJcbiAgICAgICAgICAgICAgYWN0aXZlXHJcbiAgICAgICAgICAgICAgc3VwcG9ydGVkVHJ1c3RcclxuICAgICAgICAgICAgICByYXdKc29uXHJcbiAgICAgICAgICAgICAgYWdlbnRDYXJkSnNvblxyXG4gICAgICAgICAgICAgIGFnZW50Q2FyZFJlYWRBdFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICBgO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy5jbGllbnQucmVxdWVzdChxdWVyeVRleHQsIHZhcmlhYmxlcyk7XG4gICAgICAgICAgICAgICAgY29uc3Qgbm9kZSA9IGRhdGE/LltzdHJhdGVneS5maWVsZE5hbWVdO1xuICAgICAgICAgICAgICAgIGlmICghbm9kZSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgY29uc3QgbGlzdCA9IG5vZGU/LltzdHJhdGVneS5saXN0RmllbGROYW1lXTtcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobGlzdCkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRvdGFsVmFsdWUgPSB0eXBlb2Ygc3RyYXRlZ3kudG90YWxGaWVsZE5hbWUgPT09ICdzdHJpbmcnID8gbm9kZT8uW3N0cmF0ZWd5LnRvdGFsRmllbGROYW1lXSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnPj4+Pj4+Pj4+Pj4+Pj4+Pj4+IDEyMyBBZHZhbmNlZFNlYXJjaCcsIGxpc3QpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGFnZW50czogbGlzdC5maWx0ZXIoQm9vbGVhbiksXG4gICAgICAgICAgICAgICAgICAgIHRvdGFsOiB0eXBlb2YgdG90YWxWYWx1ZSA9PT0gJ251bWJlcicgPyB0b3RhbFZhbHVlIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1tBSUFnZW50RGlzY292ZXJ5Q2xpZW50XSBBZHZhbmNlZCBjb25uZWN0aW9uIHNlYXJjaCBmYWlsZWQ6JywgZXJyb3IpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2VhcmNoU3RyYXRlZ3kgPSBudWxsO1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzdHJhdGVneS5raW5kID09PSAnbGlzdCcpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCc+Pj4+Pj4+Pj4+Pj4+Pj4+Pj4gQWR2YW5jZWRTZWFyY2hMaXN0JywgdmFyaWFibGVEZWZpbml0aW9ucywgYXJndW1lbnRBc3NpZ25tZW50cyk7XG4gICAgICAgICAgICBpZiAoIWFkZFN0cmluZ0FyZyhzdHJhdGVneS5xdWVyeUFyZywgaGFzUXVlcnkgPyB0cmltbWVkUXVlcnkgOiB1bmRlZmluZWQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhZGRJbnRBcmcoc3RyYXRlZ3kubGltaXRBcmcsIHR5cGVvZiBsaW1pdCA9PT0gJ251bWJlcicgPyBsaW1pdCA6IHVuZGVmaW5lZCk7XG4gICAgICAgICAgICBhZGRJbnRBcmcoc3RyYXRlZ3kub2Zmc2V0QXJnLCB0eXBlb2Ygb2Zmc2V0ID09PSAnbnVtYmVyJyA/IG9mZnNldCA6IHVuZGVmaW5lZCk7XG4gICAgICAgICAgICBhZGRTdHJpbmdBcmcoc3RyYXRlZ3kub3JkZXJCeUFyZywgb3B0aW9ucy5vcmRlckJ5KTtcbiAgICAgICAgICAgIGFkZFN0cmluZ0FyZyhzdHJhdGVneS5vcmRlckRpcmVjdGlvbkFyZywgb3B0aW9ucy5vcmRlckRpcmVjdGlvbik7XG4gICAgICAgICAgICBpZiAoYXJndW1lbnRBc3NpZ25tZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5VGV4dCA9IGBcclxuICAgICAgICBxdWVyeSBBZHZhbmNlZFNlYXJjaExpc3QoJHt2YXJpYWJsZURlZmluaXRpb25zLmpvaW4oJywgJyl9KSB7XHJcbiAgICAgICAgICAke3N0cmF0ZWd5LmZpZWxkTmFtZX0oJHthcmd1bWVudEFzc2lnbm1lbnRzLmpvaW4oJywgJyl9KSB7XHJcbiAgICAgICAgICAgICR7YWdlbnRTZWxlY3Rpb259XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICBgO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy5jbGllbnQucmVxdWVzdChxdWVyeVRleHQsIHZhcmlhYmxlcyk7XG4gICAgICAgICAgICAgICAgY29uc3QgbGlzdCA9IGRhdGE/LltzdHJhdGVneS5maWVsZE5hbWVdO1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShsaXN0KSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgY29uc3QgYWdlbnRzID0gbGlzdFxuICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKEJvb2xlYW4pXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmF3QWdlbnQgPSBpdGVtO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBub3JtYWxpemVkID0gdGhpcy5ub3JtYWxpemVBZ2VudChyYXdBZ2VudCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdbQUlBZ2VudERpc2NvdmVyeUNsaWVudC5zZWFyY2hBZ2VudHNBZHZhbmNlZF0gTm9ybWFsaXplZCBhZ2VudCAoc3RyYXRlZ3kpOicsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFnZW50SWQ6IG5vcm1hbGl6ZWQuYWdlbnRJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhd0FnZW50TmFtZTogcmF3QWdlbnQuYWdlbnROYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgbm9ybWFsaXplZEFnZW50TmFtZTogbm9ybWFsaXplZC5hZ2VudE5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBhZ2VudE5hbWVUeXBlOiB0eXBlb2Ygbm9ybWFsaXplZC5hZ2VudE5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNSYXdKc29uOiAhIW5vcm1hbGl6ZWQucmF3SnNvbixcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBub3JtYWxpemVkO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdbQUlBZ2VudERpc2NvdmVyeUNsaWVudC5zZWFyY2hBZ2VudHNBZHZhbmNlZF0gUmV0dXJuaW5nIG5vcm1hbGl6ZWQgYWdlbnRzIChzdHJhdGVneSk6Jywge1xuICAgICAgICAgICAgICAgICAgICBjb3VudDogYWdlbnRzLmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgYWdlbnROYW1lczogYWdlbnRzLm1hcChhID0+ICh7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZ2VudElkOiBhLmFnZW50SWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBhZ2VudE5hbWU6IGEuYWdlbnROYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWdlbnROYW1lVHlwZTogdHlwZW9mIGEuYWdlbnROYW1lLFxuICAgICAgICAgICAgICAgICAgICB9KSksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgYWdlbnRzLFxuICAgICAgICAgICAgICAgICAgICB0b3RhbDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1tBSUFnZW50RGlzY292ZXJ5Q2xpZW50XSBBZHZhbmNlZCBsaXN0IHNlYXJjaCBmYWlsZWQ6JywgZXJyb3IpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2VhcmNoU3RyYXRlZ3kgPSBudWxsO1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZWFyY2ggYWdlbnRzIHVzaW5nIHRoZSBzdHJvbmdseS10eXBlZCBBZ2VudFdoZXJlSW5wdXQgLyBzZWFyY2hBZ2VudHNHcmFwaCBBUEkuXG4gICAgICogVGhpcyBpcyB0YWlsb3JlZCB0byB0aGUgaW5kZXhlciBzY2hlbWEgdGhhdCBleHBvc2VzIEFnZW50V2hlcmVJbnB1dCBhbmRcbiAgICAgKiBzZWFyY2hBZ2VudHNHcmFwaCh3aGVyZTosIGZpcnN0Oiwgc2tpcDosIG9yZGVyQnk6LCBvcmRlckRpcmVjdGlvbjopLlxuICAgICAqL1xuICAgIGFzeW5jIHNlYXJjaEFnZW50c0dyYXBoKG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgcXVlcnkgPSBgXHJcbiAgICAgIHF1ZXJ5IFNlYXJjaEFnZW50c0dyYXBoKFxyXG4gICAgICAgICR3aGVyZTogQWdlbnRXaGVyZUlucHV0XHJcbiAgICAgICAgJGZpcnN0OiBJbnRcclxuICAgICAgICAkc2tpcDogSW50XHJcbiAgICAgICAgJG9yZGVyQnk6IEFnZW50T3JkZXJCeVxyXG4gICAgICAgICRvcmRlckRpcmVjdGlvbjogT3JkZXJEaXJlY3Rpb25cclxuICAgICAgKSB7XHJcbiAgICAgICAgc2VhcmNoQWdlbnRzR3JhcGgoXHJcbiAgICAgICAgICB3aGVyZTogJHdoZXJlXHJcbiAgICAgICAgICBmaXJzdDogJGZpcnN0XHJcbiAgICAgICAgICBza2lwOiAkc2tpcFxyXG4gICAgICAgICAgb3JkZXJCeTogJG9yZGVyQnlcclxuICAgICAgICAgIG9yZGVyRGlyZWN0aW9uOiAkb3JkZXJEaXJlY3Rpb25cclxuICAgICAgICApIHtcclxuICAgICAgICAgIGFnZW50cyB7XHJcbiAgICAgICAgICAgIGNoYWluSWRcclxuICAgICAgICAgICAgYWdlbnRJZFxyXG4gICAgICAgICAgICBhZ2VudEFjY291bnRcclxuICAgICAgICAgICAgYWdlbnROYW1lXHJcbiAgICAgICAgICAgIGFnZW50SWRlbnRpdHlPd25lckFjY291bnRcclxuICAgICAgICAgICAgZW9hQWdlbnRJZGVudGl0eU93bmVyQWNjb3VudFxyXG4gICAgICAgICAgICBlb2FBZ2VudEFjY291bnRcclxuICAgICAgICAgICAgYWdlbnRDYXRlZ29yeVxyXG4gICAgICAgICAgICBkaWRJZGVudGl0eVxyXG4gICAgICAgICAgICBkaWRBY2NvdW50XHJcbiAgICAgICAgICAgIGRpZE5hbWVcclxuICAgICAgICAgICAgYWdlbnRVcmlcclxuICAgICAgICAgICAgY3JlYXRlZEF0QmxvY2tcclxuICAgICAgICAgICAgY3JlYXRlZEF0VGltZVxyXG4gICAgICAgICAgICB1cGRhdGVkQXRUaW1lXHJcbiAgICAgICAgICAgIHR5cGVcclxuICAgICAgICAgICAgZGVzY3JpcHRpb25cclxuICAgICAgICAgICAgaW1hZ2VcclxuICAgICAgICAgICAgYTJhRW5kcG9pbnRcclxuICAgICAgICAgICAgc3VwcG9ydGVkVHJ1c3RcclxuICAgICAgICAgICAgcmF3SnNvblxyXG4gICAgICAgICAgICBhZ2VudENhcmRKc29uXHJcbiAgICAgICAgICAgIGFnZW50Q2FyZFJlYWRBdFxyXG4gICAgICAgICAgICBkaWRcclxuICAgICAgICAgICAgbWNwXHJcbiAgICAgICAgICAgIHg0MDJzdXBwb3J0XHJcbiAgICAgICAgICAgIGFjdGl2ZVxyXG4gICAgICAgICAgICBmZWVkYmFja0NvdW50XHJcbiAgICAgICAgICAgIGZlZWRiYWNrQXZlcmFnZVNjb3JlXHJcbiAgICAgICAgICAgIHZhbGlkYXRpb25QZW5kaW5nQ291bnRcclxuICAgICAgICAgICAgdmFsaWRhdGlvbkNvbXBsZXRlZENvdW50XHJcbiAgICAgICAgICAgIHZhbGlkYXRpb25SZXF1ZXN0ZWRDb3VudFxyXG4gICAgICAgICAgICBpbml0aWF0ZWRBc3NvY2lhdGlvbkNvdW50XHJcbiAgICAgICAgICAgIGFwcHJvdmVkQXNzb2NpYXRpb25Db3VudFxyXG4gICAgICAgICAgICBhdGlPdmVyYWxsU2NvcmVcclxuICAgICAgICAgICAgYXRpT3ZlcmFsbENvbmZpZGVuY2VcclxuICAgICAgICAgICAgYXRpVmVyc2lvblxyXG4gICAgICAgICAgICBhdGlDb21wdXRlZEF0XHJcbiAgICAgICAgICAgIGF0aUJ1bmRsZUpzb25cclxuICAgICAgICAgICAgdHJ1c3RMZWRnZXJTY29yZVxyXG4gICAgICAgICAgICB0cnVzdExlZGdlckJhZGdlQ291bnRcclxuICAgICAgICAgICAgdHJ1c3RMZWRnZXJPdmVyYWxsUmFua1xyXG4gICAgICAgICAgICB0cnVzdExlZGdlckNhcGFiaWxpdHlSYW5rXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICB0b3RhbFxyXG4gICAgICAgICAgaGFzTW9yZVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgYDtcbiAgICAgICAgLy8gRGVmYXVsdCBvcmRlcmluZyB3aGVuIG5vdCBleHBsaWNpdGx5IHByb3ZpZGVkOiBuZXdlc3QgYWdlbnRzIGZpcnN0XG4gICAgICAgIC8vIGJ5IGFnZW50SWQgREVTQy5cbiAgICAgICAgY29uc3QgZWZmZWN0aXZlT3JkZXJCeSA9IG9wdGlvbnMub3JkZXJCeSA/PyAnYWdlbnRJZCc7XG4gICAgICAgIGNvbnN0IGVmZmVjdGl2ZU9yZGVyRGlyZWN0aW9uID0gKG9wdGlvbnMub3JkZXJEaXJlY3Rpb24gPz8gJ0RFU0MnKS50b1VwcGVyQ2FzZSgpID09PSAnQVNDJyA/ICdBU0MnIDogJ0RFU0MnO1xuICAgICAgICBjb25zdCB2YXJpYWJsZXMgPSB7XG4gICAgICAgICAgICB3aGVyZTogb3B0aW9ucy53aGVyZSxcbiAgICAgICAgICAgIGZpcnN0OiB0eXBlb2Ygb3B0aW9ucy5maXJzdCA9PT0gJ251bWJlcicgPyBvcHRpb25zLmZpcnN0IDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgc2tpcDogdHlwZW9mIG9wdGlvbnMuc2tpcCA9PT0gJ251bWJlcicgPyBvcHRpb25zLnNraXAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBvcmRlckJ5OiBlZmZlY3RpdmVPcmRlckJ5LFxuICAgICAgICAgICAgb3JkZXJEaXJlY3Rpb246IGVmZmVjdGl2ZU9yZGVyRGlyZWN0aW9uLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy5jbGllbnQucmVxdWVzdChxdWVyeSwgdmFyaWFibGVzKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gZGF0YS5zZWFyY2hBZ2VudHNHcmFwaCA/PyB7IGFnZW50czogW10sIHRvdGFsOiAwLCBoYXNNb3JlOiBmYWxzZSB9O1xuICAgICAgICBjb25zdCBhZ2VudHMgPSAocmVzdWx0LmFnZW50cyA/PyBbXSkubWFwKChhZ2VudCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmF3QWdlbnQgPSBhZ2VudDtcbiAgICAgICAgICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSB0aGlzLm5vcm1hbGl6ZUFnZW50KHJhd0FnZW50KTtcbiAgICAgICAgICAgIHJldHVybiBub3JtYWxpemVkO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFnZW50cyxcbiAgICAgICAgICAgIHRvdGFsOiB0eXBlb2YgcmVzdWx0LnRvdGFsID09PSAnbnVtYmVyJyA/IHJlc3VsdC50b3RhbCA6IGFnZW50cy5sZW5ndGgsXG4gICAgICAgICAgICBoYXNNb3JlOiBCb29sZWFuKHJlc3VsdC5oYXNNb3JlKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYXN5bmMgZGV0ZWN0U2VhcmNoU3RyYXRlZ3koKSB7XG4gICAgICAgIGlmICh0aGlzLnNlYXJjaFN0cmF0ZWd5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNlYXJjaFN0cmF0ZWd5O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnNlYXJjaFN0cmF0ZWd5UHJvbWlzZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VhcmNoU3RyYXRlZ3lQcm9taXNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2VhcmNoU3RyYXRlZ3lQcm9taXNlID0gKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHRoaXMuY2xpZW50LnJlcXVlc3QoSU5UUk9TUEVDVElPTl9RVUVSWSk7XG4gICAgICAgICAgICAgICAgY29uc3QgZmllbGRzID0gZGF0YS5fX3NjaGVtYT8ucXVlcnlUeXBlPy5maWVsZHMgPz8gW107XG4gICAgICAgICAgICAgICAgY29uc3QgY2FuZGlkYXRlTmFtZXMgPSBbJ3NlYXJjaEFnZW50c0FkdmFuY2VkJywgJ3NlYXJjaEFnZW50cyddO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgY2FuZGlkYXRlIG9mIGNhbmRpZGF0ZU5hbWVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpZWxkID0gZmllbGRzLmZpbmQoKGYpID0+IGYubmFtZSA9PT0gY2FuZGlkYXRlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFmaWVsZClcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdHJhdGVneSA9IGF3YWl0IHRoaXMuYnVpbGRTdHJhdGVneUZyb21GaWVsZChmaWVsZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdHJhdGVneSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWFyY2hTdHJhdGVneSA9IHN0cmF0ZWd5O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0cmF0ZWd5O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdbQUlBZ2VudERpc2NvdmVyeUNsaWVudF0gRmFpbGVkIHRvIGludHJvc3BlY3Qgc2VhcmNoIGNhcGFiaWxpdGllczonLCBlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlYXJjaFN0cmF0ZWd5UHJvbWlzZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc2VhcmNoU3RyYXRlZ3kgPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0pKCk7XG4gICAgICAgIHJldHVybiB0aGlzLnNlYXJjaFN0cmF0ZWd5UHJvbWlzZTtcbiAgICB9XG4gICAgYXN5bmMgYnVpbGRTdHJhdGVneUZyb21GaWVsZChmaWVsZCkge1xuICAgICAgICBjb25zdCBiYXNlUmV0dXJuID0gdW53cmFwVHlwZShmaWVsZC50eXBlKTtcbiAgICAgICAgaWYgKCFiYXNlUmV0dXJuKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGNvbnN0IGxpbWl0QXJnID0gZmllbGQuYXJncy5maW5kKChhcmcpID0+IGFyZy5uYW1lID09PSAnbGltaXQnKSA/P1xuICAgICAgICAgICAgZmllbGQuYXJncy5maW5kKChhcmcpID0+IGFyZy5uYW1lID09PSAnZmlyc3QnKTtcbiAgICAgICAgY29uc3Qgb2Zmc2V0QXJnID0gZmllbGQuYXJncy5maW5kKChhcmcpID0+IGFyZy5uYW1lID09PSAnb2Zmc2V0JykgPz9cbiAgICAgICAgICAgIGZpZWxkLmFyZ3MuZmluZCgoYXJnKSA9PiBhcmcubmFtZSA9PT0gJ3NraXAnKTtcbiAgICAgICAgY29uc3QgcXVlcnlBcmcgPSBmaWVsZC5hcmdzLmZpbmQoKGFyZykgPT4gYXJnLm5hbWUgPT09ICdxdWVyeScpID8/XG4gICAgICAgICAgICBmaWVsZC5hcmdzLmZpbmQoKGFyZykgPT4gYXJnLm5hbWUgPT09ICd0ZXJtJykgPz9cbiAgICAgICAgICAgIGZpZWxkLmFyZ3MuZmluZCgoYXJnKSA9PiBhcmcubmFtZSA9PT0gJ3NlYXJjaCcpO1xuICAgICAgICBjb25zdCBmaWx0ZXJBcmcgPSBmaWVsZC5hcmdzLmZpbmQoKGFyZykgPT4gYXJnLm5hbWUgPT09ICdwYXJhbXMnKSA/P1xuICAgICAgICAgICAgZmllbGQuYXJncy5maW5kKChhcmcpID0+IGFyZy5uYW1lID09PSAnZmlsdGVycycpO1xuICAgICAgICBjb25zdCBvcmRlckJ5QXJnID0gZmllbGQuYXJncy5maW5kKChhcmcpID0+IGFyZy5uYW1lID09PSAnb3JkZXJCeScpO1xuICAgICAgICBjb25zdCBvcmRlckRpcmVjdGlvbkFyZyA9IGZpZWxkLmFyZ3MuZmluZCgoYXJnKSA9PiBhcmcubmFtZSA9PT0gJ29yZGVyRGlyZWN0aW9uJyk7XG4gICAgICAgIGlmIChiYXNlUmV0dXJuLmtpbmQgPT09ICdPQkpFQ1QnICYmIGJhc2VSZXR1cm4ubmFtZSkge1xuICAgICAgICAgICAgY29uc3QgY29ubmVjdGlvbkZpZWxkcyA9IGF3YWl0IHRoaXMuZ2V0VHlwZUZpZWxkcyhiYXNlUmV0dXJuLm5hbWUpO1xuICAgICAgICAgICAgaWYgKCFjb25uZWN0aW9uRmllbGRzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsaXN0RmllbGQgPSBjb25uZWN0aW9uRmllbGRzLmZpbmQoKGYpID0+IGlzTGlzdE9mKGYudHlwZSwgJ0FnZW50JykpO1xuICAgICAgICAgICAgaWYgKCFsaXN0RmllbGQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHRvdGFsRmllbGQgPSBjb25uZWN0aW9uRmllbGRzLmZpbmQoKGYpID0+IGYubmFtZSA9PT0gJ3RvdGFsJykgPz9cbiAgICAgICAgICAgICAgICBjb25uZWN0aW9uRmllbGRzLmZpbmQoKGYpID0+IGYubmFtZSA9PT0gJ3RvdGFsQ291bnQnKSA/P1xuICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25GaWVsZHMuZmluZCgoZikgPT4gZi5uYW1lID09PSAnY291bnQnKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAga2luZDogJ2Nvbm5lY3Rpb24nLFxuICAgICAgICAgICAgICAgIGZpZWxkTmFtZTogZmllbGQubmFtZSxcbiAgICAgICAgICAgICAgICBsaXN0RmllbGROYW1lOiBsaXN0RmllbGQubmFtZSxcbiAgICAgICAgICAgICAgICB0b3RhbEZpZWxkTmFtZTogdG90YWxGaWVsZD8ubmFtZSxcbiAgICAgICAgICAgICAgICBxdWVyeUFyZzogcXVlcnlBcmdcbiAgICAgICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBxdWVyeUFyZy5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZU5hbWU6IHVud3JhcFRvVHlwZU5hbWUocXVlcnlBcmcudHlwZSksXG4gICAgICAgICAgICAgICAgICAgICAgICBpc05vbk51bGw6IGlzTm9uTnVsbChxdWVyeUFyZy50eXBlKSxcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBmaWx0ZXJBcmc6IGZpbHRlckFyZ1xuICAgICAgICAgICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGZpbHRlckFyZy5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZU5hbWU6IHVud3JhcFRvVHlwZU5hbWUoZmlsdGVyQXJnLnR5cGUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNOb25OdWxsOiBpc05vbk51bGwoZmlsdGVyQXJnLnR5cGUpLFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIGxpbWl0QXJnOiBsaW1pdEFyZ1xuICAgICAgICAgICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGxpbWl0QXJnLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlTmFtZTogdW53cmFwVG9UeXBlTmFtZShsaW1pdEFyZy50eXBlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzTm9uTnVsbDogaXNOb25OdWxsKGxpbWl0QXJnLnR5cGUpLFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIG9mZnNldEFyZzogb2Zmc2V0QXJnXG4gICAgICAgICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogb2Zmc2V0QXJnLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlTmFtZTogdW53cmFwVG9UeXBlTmFtZShvZmZzZXRBcmcudHlwZSksXG4gICAgICAgICAgICAgICAgICAgICAgICBpc05vbk51bGw6IGlzTm9uTnVsbChvZmZzZXRBcmcudHlwZSksXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgb3JkZXJCeUFyZzogb3JkZXJCeUFyZ1xuICAgICAgICAgICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IG9yZGVyQnlBcmcubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVOYW1lOiB1bndyYXBUb1R5cGVOYW1lKG9yZGVyQnlBcmcudHlwZSksXG4gICAgICAgICAgICAgICAgICAgICAgICBpc05vbk51bGw6IGlzTm9uTnVsbChvcmRlckJ5QXJnLnR5cGUpLFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIG9yZGVyRGlyZWN0aW9uQXJnOiBvcmRlckRpcmVjdGlvbkFyZ1xuICAgICAgICAgICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IG9yZGVyRGlyZWN0aW9uQXJnLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlTmFtZTogdW53cmFwVG9UeXBlTmFtZShvcmRlckRpcmVjdGlvbkFyZy50eXBlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzTm9uTnVsbDogaXNOb25OdWxsKG9yZGVyRGlyZWN0aW9uQXJnLnR5cGUpLFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNMaXN0T2YoZmllbGQudHlwZSwgJ0FnZW50JykpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAga2luZDogJ2xpc3QnLFxuICAgICAgICAgICAgICAgIGZpZWxkTmFtZTogZmllbGQubmFtZSxcbiAgICAgICAgICAgICAgICBxdWVyeUFyZzogcXVlcnlBcmdcbiAgICAgICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBxdWVyeUFyZy5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZU5hbWU6IHVud3JhcFRvVHlwZU5hbWUocXVlcnlBcmcudHlwZSksXG4gICAgICAgICAgICAgICAgICAgICAgICBpc05vbk51bGw6IGlzTm9uTnVsbChxdWVyeUFyZy50eXBlKSxcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBsaW1pdEFyZzogbGltaXRBcmdcbiAgICAgICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBsaW1pdEFyZy5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZU5hbWU6IHVud3JhcFRvVHlwZU5hbWUobGltaXRBcmcudHlwZSksXG4gICAgICAgICAgICAgICAgICAgICAgICBpc05vbk51bGw6IGlzTm9uTnVsbChsaW1pdEFyZy50eXBlKSxcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBvZmZzZXRBcmc6IG9mZnNldEFyZ1xuICAgICAgICAgICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IG9mZnNldEFyZy5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZU5hbWU6IHVud3JhcFRvVHlwZU5hbWUob2Zmc2V0QXJnLnR5cGUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNOb25OdWxsOiBpc05vbk51bGwob2Zmc2V0QXJnLnR5cGUpLFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIG9yZGVyQnlBcmc6IG9yZGVyQnlBcmdcbiAgICAgICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBvcmRlckJ5QXJnLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlTmFtZTogdW53cmFwVG9UeXBlTmFtZShvcmRlckJ5QXJnLnR5cGUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNOb25OdWxsOiBpc05vbk51bGwob3JkZXJCeUFyZy50eXBlKSxcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBvcmRlckRpcmVjdGlvbkFyZzogb3JkZXJEaXJlY3Rpb25BcmdcbiAgICAgICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBvcmRlckRpcmVjdGlvbkFyZy5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZU5hbWU6IHVud3JhcFRvVHlwZU5hbWUob3JkZXJEaXJlY3Rpb25BcmcudHlwZSksXG4gICAgICAgICAgICAgICAgICAgICAgICBpc05vbk51bGw6IGlzTm9uTnVsbChvcmRlckRpcmVjdGlvbkFyZy50eXBlKSxcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGFzeW5jIGdldFR5cGVGaWVsZHModHlwZU5hbWUpIHtcbiAgICAgICAgaWYgKHRoaXMudHlwZUZpZWxkc0NhY2hlLmhhcyh0eXBlTmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnR5cGVGaWVsZHNDYWNoZS5nZXQodHlwZU5hbWUpID8/IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLmNsaWVudC5yZXF1ZXN0KFRZUEVfRklFTERTX1FVRVJZLCB7IG5hbWU6IHR5cGVOYW1lIH0pO1xuICAgICAgICAgICAgY29uc3QgZmllbGRzID0gZGF0YS5fX3R5cGU/LmZpZWxkcyA/PyBudWxsO1xuICAgICAgICAgICAgdGhpcy50eXBlRmllbGRzQ2FjaGUuc2V0KHR5cGVOYW1lLCBmaWVsZHMgPz8gbnVsbCk7XG4gICAgICAgICAgICByZXR1cm4gZmllbGRzID8/IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYFtBSUFnZW50RGlzY292ZXJ5Q2xpZW50XSBGYWlsZWQgdG8gaW50cm9zcGVjdCB0eXBlIGZpZWxkcyBmb3IgJHt0eXBlTmFtZX06YCwgZXJyb3IpO1xuICAgICAgICAgICAgdGhpcy50eXBlRmllbGRzQ2FjaGUuc2V0KHR5cGVOYW1lLCBudWxsKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNvbWUgaW5kZXhlcnMgZXhwb3NlIGBtZXRhZGF0YSB7IGtleSB2YWx1ZVRleHQgfWAsIG90aGVycyBleHBvc2UgYG1ldGFkYXRhIHsga2V5IHZhbHVlIH1gLlxuICAgICAqIEludHJvc3BlY3Qgb25jZSBhbmQgY2FjaGUgc28gd2UgY2FuIHF1ZXJ5IG1ldGFkYXRhIHJlbGlhYmx5LlxuICAgICAqL1xuICAgIGFzeW5jIGdldEFnZW50TWV0YWRhdGFWYWx1ZUZpZWxkKCkge1xuICAgICAgICBpZiAodGhpcy5hZ2VudE1ldGFkYXRhVmFsdWVGaWVsZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hZ2VudE1ldGFkYXRhVmFsdWVGaWVsZDtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgYWdlbnRGaWVsZHMgPSBhd2FpdCB0aGlzLmdldFR5cGVGaWVsZHMoJ0FnZW50Jyk7XG4gICAgICAgICAgICBjb25zdCBtZXRhZGF0YUZpZWxkID0gYWdlbnRGaWVsZHM/LmZpbmQoKGYpID0+IGY/Lm5hbWUgPT09ICdtZXRhZGF0YScpO1xuICAgICAgICAgICAgY29uc3QgbWV0YWRhdGFUeXBlID0gdW53cmFwVHlwZShtZXRhZGF0YUZpZWxkPy50eXBlKTtcbiAgICAgICAgICAgIGNvbnN0IG1ldGFkYXRhVHlwZU5hbWUgPSBtZXRhZGF0YVR5cGU/Lm5hbWUgPz8gbnVsbDtcbiAgICAgICAgICAgIGlmICghbWV0YWRhdGFUeXBlTmFtZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWdlbnRNZXRhZGF0YVZhbHVlRmllbGQgPSBudWxsO1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbWV0YWRhdGFGaWVsZHMgPSBhd2FpdCB0aGlzLmdldFR5cGVGaWVsZHMobWV0YWRhdGFUeXBlTmFtZSk7XG4gICAgICAgICAgICBjb25zdCBmaWVsZE5hbWVzID0gbmV3IFNldCgobWV0YWRhdGFGaWVsZHMgPz8gW10pXG4gICAgICAgICAgICAgICAgLm1hcCgoZikgPT4gZj8ubmFtZSlcbiAgICAgICAgICAgICAgICAuZmlsdGVyKChuYW1lKSA9PiB0eXBlb2YgbmFtZSA9PT0gJ3N0cmluZycgJiYgbmFtZS5sZW5ndGggPiAwKSk7XG4gICAgICAgICAgICBpZiAoZmllbGROYW1lcy5oYXMoJ3ZhbHVlVGV4dCcpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZ2VudE1ldGFkYXRhVmFsdWVGaWVsZCA9ICd2YWx1ZVRleHQnO1xuICAgICAgICAgICAgICAgIHJldHVybiAndmFsdWVUZXh0JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmaWVsZE5hbWVzLmhhcygndmFsdWUnKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWdlbnRNZXRhZGF0YVZhbHVlRmllbGQgPSAndmFsdWUnO1xuICAgICAgICAgICAgICAgIHJldHVybiAndmFsdWUnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5hZ2VudE1ldGFkYXRhVmFsdWVGaWVsZCA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCB7XG4gICAgICAgICAgICAvLyBJZiBzY2hlbWEgYmxvY2tzIGludHJvc3BlY3Rpb24sIGZhbGwgYmFjayB0byBoaXN0b3JpY2FsIGB2YWx1ZVRleHRgLlxuICAgICAgICAgICAgdGhpcy5hZ2VudE1ldGFkYXRhVmFsdWVGaWVsZCA9ICd2YWx1ZVRleHQnO1xuICAgICAgICAgICAgcmV0dXJuICd2YWx1ZVRleHQnO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhbGwgdG9rZW4gbWV0YWRhdGEgZnJvbSBUaGUgR3JhcGggaW5kZXhlciBmb3IgYW4gYWdlbnRcbiAgICAgKiBVc2VzIHRva2VuTWV0YWRhdGFfY29sbGVjdGlvbiBxdWVyeSB0byBnZXQgYWxsIG1ldGFkYXRhIGtleS12YWx1ZSBwYWlyc1xuICAgICAqIEhhbmRsZXMgcGFnaW5hdGlvbiBpZiBhbiBhZ2VudCBoYXMgbW9yZSB0aGFuIDEwMDAgbWV0YWRhdGEgZW50cmllc1xuICAgICAqIEBwYXJhbSBjaGFpbklkIC0gQ2hhaW4gSURcbiAgICAgKiBAcGFyYW0gYWdlbnRJZCAtIEFnZW50IElEXG4gICAgICogQHJldHVybnMgUmVjb3JkIG9mIGFsbCBtZXRhZGF0YSBrZXktdmFsdWUgcGFpcnMsIG9yIG51bGwgaWYgbm90IGF2YWlsYWJsZVxuICAgICAqL1xuICAgIGFzeW5jIGdldFRva2VuTWV0YWRhdGEoY2hhaW5JZCwgYWdlbnRJZCkge1xuICAgICAgICAvLyBJZiB3ZSBhbHJlYWR5IGxlYXJuZWQgdGhlIEdyYXBoUUwgc2NoZW1hIGRvZXNuJ3Qgc3VwcG9ydCB0aGlzIHF1ZXJ5IGZpZWxkLFxuICAgICAgICAvLyBza2lwIHRvIGF2b2lkIHJlcGVhdGVkIEdSQVBIUUxfVkFMSURBVElPTl9GQUlMRUQgd2FybmluZ3MuXG4gICAgICAgIGlmICh0aGlzLnRva2VuTWV0YWRhdGFDb2xsZWN0aW9uU3VwcG9ydGVkID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTmV3ZXIgaW5kZXhlciBzY2hlbWFzIG1heSBub3QgZXhwb3NlIHRva2VuTWV0YWRhdGFfY29sbGVjdGlvbiBhbnltb3JlLlxuICAgICAgICAvLyBBdm9pZCBzcGFtbWluZyBsb2dzIC8gZmFpbGluZyByZXF1ZXN0cyBieSBpbnRyb3NwZWN0aW5nIG9uY2UgYW5kIGJhaWxpbmcgb3V0IGlmIHVuc3VwcG9ydGVkLlxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcXVlcnlGaWVsZHMgPSBhd2FpdCB0aGlzLmdldFR5cGVGaWVsZHMoJ1F1ZXJ5Jyk7XG4gICAgICAgICAgICBjb25zdCBoYXNUb2tlbk1ldGFkYXRhQ29sbGVjdGlvbiA9IEJvb2xlYW4ocXVlcnlGaWVsZHM/LnNvbWUoKGYpID0+IGY/Lm5hbWUgPT09ICd0b2tlbk1ldGFkYXRhX2NvbGxlY3Rpb24nKSk7XG4gICAgICAgICAgICBpZiAoIWhhc1Rva2VuTWV0YWRhdGFDb2xsZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50b2tlbk1ldGFkYXRhQ29sbGVjdGlvblN1cHBvcnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIC8vIHRva2VuTWV0YWRhdGFCeUlkIG1heSBleGlzdCwgYnV0IGl0IGRvZXNuJ3QgaGVscCB1cyBlbnVtZXJhdGUgYWxsIG1ldGFkYXRhIHBhaXJzLlxuICAgICAgICAgICAgICAgIC8vIFdlIG9ubHkgdXNlIHRoaXMgbWV0aG9kIGFzIGEgYmVzdC1lZmZvcnQgZmFsbGJhY2ssIHNvIHJldHVybiBudWxsIHdoZW4gdW5zdXBwb3J0ZWQuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnRva2VuTWV0YWRhdGFDb2xsZWN0aW9uU3VwcG9ydGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy8gSWYgaW50cm9zcGVjdGlvbiBmYWlscywga2VlcCBleGlzdGluZyBiZWhhdmlvciAoYXR0ZW1wdCB0aGUgcXVlcnk7IGl0IHdpbGwgYmUgY2F1Z2h0IGJlbG93KS5cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRhZGF0YSA9IHt9O1xuICAgICAgICBjb25zdCBwYWdlU2l6ZSA9IDEwMDA7IC8vIFRoZSBHcmFwaCdzIGRlZmF1bHQgcGFnZSBzaXplXG4gICAgICAgIGxldCBza2lwID0gMDtcbiAgICAgICAgbGV0IGhhc01vcmUgPSB0cnVlO1xuICAgICAgICB3aGlsZSAoaGFzTW9yZSkge1xuICAgICAgICAgICAgY29uc3QgcXVlcnkgPSBgXHJcbiAgICAgICAgcXVlcnkgR2V0VG9rZW5NZXRhZGF0YSgkY2hhaW5JZDogSW50ISwgJGFnZW50SWQ6IFN0cmluZyEsICRmaXJzdDogSW50ISwgJHNraXA6IEludCEpIHtcclxuICAgICAgICAgIHRva2VuTWV0YWRhdGFfY29sbGVjdGlvbihcclxuICAgICAgICAgICAgY2hhaW5JZDogJGNoYWluSWRcclxuICAgICAgICAgICAgYWdlbnRJZDogJGFnZW50SWRcclxuICAgICAgICAgICAgZmlyc3Q6ICRmaXJzdFxyXG4gICAgICAgICAgICBza2lwOiAkc2tpcFxyXG4gICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgIGtleVxyXG4gICAgICAgICAgICB2YWx1ZVxyXG4gICAgICAgICAgICBpZFxyXG4gICAgICAgICAgICBpbmRleGVkS2V5XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICBgO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy5jbGllbnQucmVxdWVzdChxdWVyeSwge1xuICAgICAgICAgICAgICAgICAgICBjaGFpbklkLFxuICAgICAgICAgICAgICAgICAgICBhZ2VudElkOiBTdHJpbmcoYWdlbnRJZCksXG4gICAgICAgICAgICAgICAgICAgIGZpcnN0OiBwYWdlU2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgc2tpcDogc2tpcCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoIWRhdGEudG9rZW5NZXRhZGF0YV9jb2xsZWN0aW9uIHx8ICFBcnJheS5pc0FycmF5KGRhdGEudG9rZW5NZXRhZGF0YV9jb2xsZWN0aW9uKSkge1xuICAgICAgICAgICAgICAgICAgICBoYXNNb3JlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBBZGQgZW50cmllcyBmcm9tIHRoaXMgcGFnZVxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZW50cnkgb2YgZGF0YS50b2tlbk1ldGFkYXRhX2NvbGxlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVudHJ5LmtleSAmJiBlbnRyeS52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGFbZW50cnkua2V5XSA9IGVudHJ5LnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIHdlIGdvdCBhIGZ1bGwgcGFnZSAobWlnaHQgaGF2ZSBtb3JlKVxuICAgICAgICAgICAgICAgIGhhc01vcmUgPSBkYXRhLnRva2VuTWV0YWRhdGFfY29sbGVjdGlvbi5sZW5ndGggPT09IHBhZ2VTaXplO1xuICAgICAgICAgICAgICAgIHNraXAgKz0gcGFnZVNpemU7XG4gICAgICAgICAgICAgICAgLy8gU2FmZXR5IGNoZWNrOiBUaGUgR3JhcGggaGFzIGEgbWF4IHNraXAgb2YgNTAwMFxuICAgICAgICAgICAgICAgIC8vIElmIHdlJ3ZlIHJlYWNoZWQgdGhhdCwgd2UgY2FuJ3QgZmV0Y2ggbW9yZSAodW5saWtlbHkgZm9yIGEgc2luZ2xlIGFnZW50KVxuICAgICAgICAgICAgICAgIGlmIChza2lwID49IDUwMDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBbQUlBZ2VudERpc2NvdmVyeUNsaWVudC5nZXRUb2tlbk1ldGFkYXRhXSBSZWFjaGVkIFRoZSBHcmFwaCBza2lwIGxpbWl0ICg1MDAwKSBmb3IgYWdlbnQgJHthZ2VudElkfWApO1xuICAgICAgICAgICAgICAgICAgICBoYXNNb3JlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgLy8gU29tZSBpbmRleGVycyBoYXZlIGV2b2x2ZWQgc2NoZW1hIGFuZCByZW1vdmVkIGB0b2tlbk1ldGFkYXRhX2NvbGxlY3Rpb25gLlxuICAgICAgICAgICAgICAgIC8vIGdyYXBocWwtcmVxdWVzdCBzdXJmYWNlcyB0aGlzIGFzIEdSQVBIUUxfVkFMSURBVElPTl9GQUlMRUQ7IHRyZWF0IGl0IGFzIFwibm90IHN1cHBvcnRlZFwiXG4gICAgICAgICAgICAgICAgLy8gYW5kIGRpc2FibGUgZnV0dXJlIGF0dGVtcHRzIGZvciB0aGlzIGNsaWVudCBpbnN0YW5jZS5cbiAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZUVycm9ycyA9IGVycm9yPy5yZXNwb25zZT8uZXJyb3JzO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNjaGVtYURvZXNOb3RTdXBwb3J0Q29sbGVjdGlvbiA9IEFycmF5LmlzQXJyYXkocmVzcG9uc2VFcnJvcnMpICYmXG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlRXJyb3JzLnNvbWUoKGUpID0+IHR5cGVvZiBlPy5tZXNzYWdlID09PSAnc3RyaW5nJyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgZS5tZXNzYWdlLmluY2x1ZGVzKCd0b2tlbk1ldGFkYXRhX2NvbGxlY3Rpb24nKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKGU/LmV4dGVuc2lvbnM/LmNvZGUgPT09ICdHUkFQSFFMX1ZBTElEQVRJT05fRkFJTEVEJyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUubWVzc2FnZS5pbmNsdWRlcygnQ2Fubm90IHF1ZXJ5IGZpZWxkJykpKTtcbiAgICAgICAgICAgICAgICBpZiAoc2NoZW1hRG9lc05vdFN1cHBvcnRDb2xsZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudG9rZW5NZXRhZGF0YUNvbGxlY3Rpb25TdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKG1ldGFkYXRhKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWV0YWRhdGE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignW0FJQWdlbnREaXNjb3ZlcnlDbGllbnQuZ2V0VG9rZW5NZXRhZGF0YV0gRXJyb3IgZmV0Y2hpbmcgdG9rZW4gbWV0YWRhdGEgZnJvbSBHcmFwaFFMOicsIGVycm9yKTtcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSBnb3Qgc29tZSBtZXRhZGF0YSBiZWZvcmUgdGhlIGVycm9yLCByZXR1cm4gd2hhdCB3ZSBoYXZlXG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKG1ldGFkYXRhKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtZXRhZGF0YTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKG1ldGFkYXRhKS5sZW5ndGggPiAwID8gbWV0YWRhdGEgOiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgYSBzaW5nbGUgYWdlbnQgYnkgSUQgd2l0aCBtZXRhZGF0YVxuICAgICAqIEBwYXJhbSBjaGFpbklkIC0gQ2hhaW4gSUQgKHJlcXVpcmVkIGJ5IHNjaGVtYSlcbiAgICAgKiBAcGFyYW0gYWdlbnRJZCAtIEFnZW50IElEIHRvIGZldGNoXG4gICAgICogQHJldHVybnMgQWdlbnQgZGF0YSB3aXRoIG1ldGFkYXRhIG9yIG51bGwgaWYgbm90IGZvdW5kXG4gICAgICovXG4gICAgYXN5bmMgZ2V0QWdlbnQoY2hhaW5JZCwgYWdlbnRJZCkge1xuICAgICAgICBjb25zdCBtZXRhZGF0YVZhbHVlRmllbGQgPSBhd2FpdCB0aGlzLmdldEFnZW50TWV0YWRhdGFWYWx1ZUZpZWxkKCk7XG4gICAgICAgIGNvbnN0IG1ldGFkYXRhU2VsZWN0aW9uID0gbWV0YWRhdGFWYWx1ZUZpZWxkID09PSAndmFsdWVUZXh0J1xuICAgICAgICAgICAgPyBgXHJcbiAgICAgICAgICAgIG1ldGFkYXRhIHtcclxuICAgICAgICAgICAgICBrZXlcclxuICAgICAgICAgICAgICB2YWx1ZVRleHRcclxuICAgICAgICAgICAgfWBcbiAgICAgICAgICAgIDogbWV0YWRhdGFWYWx1ZUZpZWxkID09PSAndmFsdWUnXG4gICAgICAgICAgICAgICAgPyBgXHJcbiAgICAgICAgICAgIG1ldGFkYXRhIHtcclxuICAgICAgICAgICAgICBrZXlcclxuICAgICAgICAgICAgICB2YWx1ZVRleHQ6IHZhbHVlXHJcbiAgICAgICAgICAgIH1gXG4gICAgICAgICAgICAgICAgOiAnJztcbiAgICAgICAgLy8gVHJ5IHNlYXJjaEFnZW50c0dyYXBoIGZpcnN0IHRvIGdldCBtZXRhZGF0YVxuICAgICAgICBjb25zdCBncmFwaFF1ZXJ5ID0gYFxyXG4gICAgICBxdWVyeSBHZXRBZ2VudFdpdGhNZXRhZGF0YSgkd2hlcmU6IEFnZW50V2hlcmVJbnB1dCwgJGZpcnN0OiBJbnQpIHtcclxuICAgICAgICBzZWFyY2hBZ2VudHNHcmFwaChcclxuICAgICAgICAgIHdoZXJlOiAkd2hlcmVcclxuICAgICAgICAgIGZpcnN0OiAkZmlyc3RcclxuICAgICAgICApIHtcclxuICAgICAgICAgIGFnZW50cyB7XHJcbiAgICAgICAgICAgIGNoYWluSWRcclxuICAgICAgICAgICAgYWdlbnRJZFxyXG4gICAgICAgICAgICBhZ2VudEFjY291bnRcclxuICAgICAgICAgICAgYWdlbnROYW1lXHJcbiAgICAgICAgICAgIGFnZW50SWRlbnRpdHlPd25lckFjY291bnRcclxuICAgICAgICAgICAgZW9hQWdlbnRJZGVudGl0eU93bmVyQWNjb3VudFxyXG4gICAgICAgICAgICBlb2FBZ2VudEFjY291bnRcclxuICAgICAgICAgICAgYWdlbnRDYXRlZ29yeVxyXG4gICAgICAgICAgICBkaWRJZGVudGl0eVxyXG4gICAgICAgICAgICBkaWRBY2NvdW50XHJcbiAgICAgICAgICAgIGRpZE5hbWVcclxuICAgICAgICAgICAgYWdlbnRVcmlcclxuICAgICAgICAgICAgY3JlYXRlZEF0QmxvY2tcclxuICAgICAgICAgICAgY3JlYXRlZEF0VGltZVxyXG4gICAgICAgICAgICB1cGRhdGVkQXRUaW1lXHJcbiAgICAgICAgICAgIHR5cGVcclxuICAgICAgICAgICAgZGVzY3JpcHRpb25cclxuICAgICAgICAgICAgaW1hZ2VcclxuICAgICAgICAgICAgYTJhRW5kcG9pbnRcclxuICAgICAgICAgICAgZGlkXHJcbiAgICAgICAgICAgIG1jcFxyXG4gICAgICAgICAgICB4NDAyc3VwcG9ydFxyXG4gICAgICAgICAgICBhY3RpdmVcclxuICAgICAgICAgICAgc3VwcG9ydGVkVHJ1c3RcclxuICAgICAgICAgICAgcmF3SnNvblxyXG4gICAgICAgICAgICBhZ2VudENhcmRKc29uXHJcbiAgICAgICAgICAgIGFnZW50Q2FyZFJlYWRBdFxyXG4gICAgICAgICAgICBmZWVkYmFja0NvdW50XHJcbiAgICAgICAgICAgIGZlZWRiYWNrQXZlcmFnZVNjb3JlXHJcbiAgICAgICAgICAgIHZhbGlkYXRpb25QZW5kaW5nQ291bnRcclxuICAgICAgICAgICAgdmFsaWRhdGlvbkNvbXBsZXRlZENvdW50XHJcbiAgICAgICAgICAgIHZhbGlkYXRpb25SZXF1ZXN0ZWRDb3VudFxyXG4gICAgICAgICAgICBpbml0aWF0ZWRBc3NvY2lhdGlvbkNvdW50XHJcbiAgICAgICAgICAgIGFwcHJvdmVkQXNzb2NpYXRpb25Db3VudFxyXG4gICAgICAgICAgICBhdGlPdmVyYWxsU2NvcmVcclxuICAgICAgICAgICAgYXRpT3ZlcmFsbENvbmZpZGVuY2VcclxuICAgICAgICAgICAgYXRpVmVyc2lvblxyXG4gICAgICAgICAgICBhdGlDb21wdXRlZEF0XHJcbiAgICAgICAgICAgIGF0aUJ1bmRsZUpzb25cclxuICAgICAgICAgICAgdHJ1c3RMZWRnZXJTY29yZVxyXG4gICAgICAgICAgICB0cnVzdExlZGdlckJhZGdlQ291bnRcclxuICAgICAgICAgICAgdHJ1c3RMZWRnZXJPdmVyYWxsUmFua1xyXG4gICAgICAgICAgICB0cnVzdExlZGdlckNhcGFiaWxpdHlSYW5rXHJcbiR7bWV0YWRhdGFTZWxlY3Rpb259XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICBgO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgZ3JhcGhEYXRhID0gYXdhaXQgdGhpcy5jbGllbnQucmVxdWVzdChncmFwaFF1ZXJ5LCB7XG4gICAgICAgICAgICAgICAgd2hlcmU6IHtcbiAgICAgICAgICAgICAgICAgICAgY2hhaW5JZCxcbiAgICAgICAgICAgICAgICAgICAgYWdlbnRJZDogU3RyaW5nKGFnZW50SWQpLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZmlyc3Q6IDEsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChncmFwaERhdGEuc2VhcmNoQWdlbnRzR3JhcGg/LmFnZW50cyAmJiBncmFwaERhdGEuc2VhcmNoQWdlbnRzR3JhcGguYWdlbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhZ2VudERhdGEgPSBncmFwaERhdGEuc2VhcmNoQWdlbnRzR3JhcGguYWdlbnRzWzBdO1xuICAgICAgICAgICAgICAgIGlmICghYWdlbnREYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBDb252ZXJ0IG1ldGFkYXRhIGFycmF5IHRvIHJlY29yZCBhbmQgYWRkIHRvIGFnZW50IGRhdGFcbiAgICAgICAgICAgICAgICBjb25zdCBub3JtYWxpemVkID0gdGhpcy5ub3JtYWxpemVBZ2VudChhZ2VudERhdGEpO1xuICAgICAgICAgICAgICAgIGlmIChhZ2VudERhdGEubWV0YWRhdGEgJiYgQXJyYXkuaXNBcnJheShhZ2VudERhdGEubWV0YWRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFkZCBtZXRhZGF0YSBhcyBhIGZsYXQgb2JqZWN0IG9uIHRoZSBhZ2VudCBkYXRhXG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgbWV0YSBvZiBhZ2VudERhdGEubWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtZXRhLmtleSAmJiBtZXRhLnZhbHVlVGV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWRbbWV0YS5rZXldID0gbWV0YS52YWx1ZVRleHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gQWxzbyBzdG9yZSBhcyBtZXRhZGF0YSBwcm9wZXJ0eSBmb3IgZWFzeSBhY2Nlc3NcbiAgICAgICAgICAgICAgICAgICAgbm9ybWFsaXplZC5tZXRhZGF0YSA9IGFnZW50RGF0YS5tZXRhZGF0YS5yZWR1Y2UoKGFjYywgbWV0YSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1ldGEua2V5ICYmIG1ldGEudmFsdWVUZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWNjW21ldGEua2V5XSA9IG1ldGEudmFsdWVUZXh0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgICAgICAgICAgICAgfSwge30pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbm9ybWFsaXplZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignW0FJQWdlbnREaXNjb3ZlcnlDbGllbnQuZ2V0QWdlbnRdIEdyYXBoUUwgc2VhcmNoQWdlbnRzR3JhcGggZmFpbGVkLCB0cnlpbmcgZmFsbGJhY2s6JywgZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZhbGxiYWNrIHRvIG9yaWdpbmFsIGFnZW50IHF1ZXJ5IGlmIHNlYXJjaEFnZW50c0dyYXBoIGRvZXNuJ3Qgd29ya1xuICAgICAgICBjb25zdCBxdWVyeSA9IGBcclxuICAgICAgcXVlcnkgR2V0QWdlbnQoJGNoYWluSWQ6IEludCEsICRhZ2VudElkOiBTdHJpbmchKSB7XHJcbiAgICAgICAgYWdlbnQoY2hhaW5JZDogJGNoYWluSWQsIGFnZW50SWQ6ICRhZ2VudElkKSB7XHJcbiAgICAgICAgICBjaGFpbklkXHJcbiAgICAgICAgICBhZ2VudElkXHJcbiAgICAgICAgICBhZ2VudEFjY291bnRcclxuICAgICAgICAgIGFnZW50TmFtZVxyXG4gICAgICAgICAgYWdlbnRJZGVudGl0eU93bmVyQWNjb3VudFxyXG4gICAgICAgICAgZW9hQWdlbnRJZGVudGl0eU93bmVyQWNjb3VudFxyXG4gICAgICAgICAgZW9hQWdlbnRBY2NvdW50XHJcbiAgICAgICAgICBhZ2VudENhdGVnb3J5XHJcbiAgICAgICAgICBkaWRJZGVudGl0eVxyXG4gICAgICAgICAgZGlkQWNjb3VudFxyXG4gICAgICAgICAgZGlkTmFtZVxyXG4gICAgICAgICAgYWdlbnRVcmlcclxuICAgICAgICAgIGNyZWF0ZWRBdEJsb2NrXHJcbiAgICAgICAgICBjcmVhdGVkQXRUaW1lXHJcbiAgICAgICAgICB1cGRhdGVkQXRUaW1lXHJcbiAgICAgICAgICB0eXBlXHJcbiAgICAgICAgICBkZXNjcmlwdGlvblxyXG4gICAgICAgICAgaW1hZ2VcclxuICAgICAgICAgIGEyYUVuZHBvaW50XHJcbiAgICAgICAgICBkaWRcclxuICAgICAgICAgIG1jcFxyXG4gICAgICAgICAgeDQwMnN1cHBvcnRcclxuICAgICAgICAgIGFjdGl2ZVxyXG4gICAgICAgICAgc3VwcG9ydGVkVHJ1c3RcclxuICAgICAgICAgIHJhd0pzb25cclxuICAgICAgICAgIGFnZW50Q2FyZEpzb25cclxuICAgICAgICAgIGFnZW50Q2FyZFJlYWRBdFxyXG4gICAgICAgICAgYXRpT3ZlcmFsbFNjb3JlXHJcbiAgICAgICAgICBhdGlPdmVyYWxsQ29uZmlkZW5jZVxyXG4gICAgICAgICAgYXRpVmVyc2lvblxyXG4gICAgICAgICAgYXRpQ29tcHV0ZWRBdFxyXG4gICAgICAgICAgYXRpQnVuZGxlSnNvblxyXG4gICAgICAgICAgdHJ1c3RMZWRnZXJTY29yZVxyXG4gICAgICAgICAgdHJ1c3RMZWRnZXJCYWRnZUNvdW50XHJcbiAgICAgICAgICB0cnVzdExlZGdlck92ZXJhbGxSYW5rXHJcbiAgICAgICAgICB0cnVzdExlZGdlckNhcGFiaWxpdHlSYW5rXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICBgO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHRoaXMuY2xpZW50LnJlcXVlc3QocXVlcnksIHtcbiAgICAgICAgICAgICAgICBjaGFpbklkLFxuICAgICAgICAgICAgICAgIGFnZW50SWQ6IFN0cmluZyhhZ2VudElkKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKCFkYXRhLmFnZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ub3JtYWxpemVBZ2VudChkYXRhLmFnZW50KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1tBSUFnZW50RGlzY292ZXJ5Q2xpZW50LmdldEFnZW50XSBFcnJvciBmZXRjaGluZyBhZ2VudDonLCBlcnJvcik7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBnZXRBZ2VudEJ5TmFtZShhZ2VudE5hbWUpIHtcbiAgICAgICAgY29uc3QgcXVlcnkgPSBgXHJcbiAgICAgIHF1ZXJ5IEdldEFnZW50QnlOYW1lKCRhZ2VudE5hbWU6IFN0cmluZyEpIHtcclxuICAgICAgICBhZ2VudEJ5TmFtZShhZ2VudE5hbWU6ICRhZ2VudE5hbWUpIHtcclxuICAgICAgICAgIGNoYWluSWRcclxuICAgICAgICAgIGFnZW50SWRcclxuICAgICAgICAgIGFnZW50QWNjb3VudFxyXG4gICAgICAgICAgYWdlbnROYW1lXHJcbiAgICAgICAgICBhZ2VudElkZW50aXR5T3duZXJBY2NvdW50XHJcbiAgICAgICAgICBlb2FBZ2VudElkZW50aXR5T3duZXJBY2NvdW50XHJcbiAgICAgICAgICBlb2FBZ2VudEFjY291bnRcclxuICAgICAgICAgIGFnZW50Q2F0ZWdvcnlcclxuICAgICAgICAgIGRpZElkZW50aXR5XHJcbiAgICAgIGRpZEFjY291bnRcclxuICAgICAgZGlkTmFtZVxyXG4gICAgICBhZ2VudFVyaVxyXG4gICAgICAgICAgY3JlYXRlZEF0QmxvY2tcclxuICAgICAgICAgIGNyZWF0ZWRBdFRpbWVcclxuICAgICAgICAgIHVwZGF0ZWRBdFRpbWVcclxuICAgICAgICAgIHR5cGVcclxuICAgICAgICAgIGRlc2NyaXB0aW9uXHJcbiAgICAgICAgICBpbWFnZVxyXG4gICAgICAgICAgYTJhRW5kcG9pbnRcclxuICAgICAgICAgIGRpZFxyXG4gICAgICAgICAgbWNwXHJcbiAgICAgICAgICB4NDAyc3VwcG9ydFxyXG4gICAgICAgICAgYWN0aXZlXHJcbiAgICAgICAgICBzdXBwb3J0ZWRUcnVzdFxyXG4gICAgICAgICAgcmF3SnNvblxyXG4gICAgICAgICAgYWdlbnRDYXJkSnNvblxyXG4gICAgICAgICAgYWdlbnRDYXJkUmVhZEF0XHJcbiAgICAgICAgICBhdGlPdmVyYWxsU2NvcmVcclxuICAgICAgICAgIGF0aU92ZXJhbGxDb25maWRlbmNlXHJcbiAgICAgICAgICBhdGlWZXJzaW9uXHJcbiAgICAgICAgICBhdGlDb21wdXRlZEF0XHJcbiAgICAgICAgICBhdGlCdW5kbGVKc29uXHJcbiAgICAgICAgICB0cnVzdExlZGdlclNjb3JlXHJcbiAgICAgICAgICB0cnVzdExlZGdlckJhZGdlQ291bnRcclxuICAgICAgICAgIHRydXN0TGVkZ2VyT3ZlcmFsbFJhbmtcclxuICAgICAgICAgIHRydXN0TGVkZ2VyQ2FwYWJpbGl0eVJhbmtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIGA7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy5jbGllbnQucmVxdWVzdChxdWVyeSwge1xuICAgICAgICAgICAgICAgIGFnZW50TmFtZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCIqKioqKioqKioqKiBBSUFnZW50RGlzY292ZXJ5Q2xpZW50LmdldEFnZW50QnlOYW1lOiBkYXRhXCIsIGRhdGEpO1xuICAgICAgICAgICAgaWYgKCFkYXRhLmFnZW50QnlOYW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ub3JtYWxpemVBZ2VudChkYXRhLmFnZW50QnlOYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1tBSUFnZW50RGlzY292ZXJ5Q2xpZW50LmdldEFnZW50QnlOYW1lXSBFcnJvciBmZXRjaGluZyBhZ2VudDonLCBlcnJvcik7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZWFyY2ggYWdlbnRzIGJ5IG5hbWVcbiAgICAgKiBAcGFyYW0gc2VhcmNoVGVybSAtIFNlYXJjaCB0ZXJtIHRvIG1hdGNoIGFnYWluc3QgYWdlbnQgbmFtZXNcbiAgICAgKiBAcGFyYW0gbGltaXQgLSBNYXhpbXVtIG51bWJlciBvZiByZXN1bHRzXG4gICAgICogQHJldHVybnMgTGlzdCBvZiBtYXRjaGluZyBhZ2VudHNcbiAgICAgKi9cbiAgICBhc3luYyBzZWFyY2hBZ2VudHMoc2VhcmNoVGVybSwgbGltaXQpIHtcbiAgICAgICAgY29uc3QgcXVlcnkgPSBgXHJcbiAgICAgIHF1ZXJ5IFNlYXJjaEFnZW50cygkcXVlcnk6IFN0cmluZyEsICRsaW1pdDogSW50KSB7XHJcbiAgICAgICAgc2VhcmNoQWdlbnRzKHF1ZXJ5OiAkcXVlcnksIGxpbWl0OiAkbGltaXQpIHtcclxuICAgICAgICAgIGNoYWluSWRcclxuICAgICAgICAgIGFnZW50SWRcclxuICAgICAgICAgIGFnZW50QWNjb3VudFxyXG4gICAgICAgICAgYWdlbnROYW1lXHJcbiAgICAgICAgICBhZ2VudElkZW50aXR5T3duZXJBY2NvdW50XHJcbiAgICAgICAgICBlb2FBZ2VudElkZW50aXR5T3duZXJBY2NvdW50XHJcbiAgICAgICAgICBlb2FBZ2VudEFjY291bnRcclxuICAgICAgICAgIGFnZW50Q2F0ZWdvcnlcclxuICAgICAgICAgIGRpZElkZW50aXR5XHJcbiAgICAgICAgICBkaWRBY2NvdW50XHJcbiAgICAgICAgICBkaWROYW1lXHJcbiAgICAgICAgICBhZ2VudFVyaVxyXG4gICAgICAgICAgY3JlYXRlZEF0QmxvY2tcclxuICAgICAgICAgIGNyZWF0ZWRBdFRpbWVcclxuICAgICAgICAgIHVwZGF0ZWRBdFRpbWVcclxuICAgICAgICAgIHR5cGVcclxuICAgICAgICAgIGRlc2NyaXB0aW9uXHJcbiAgICAgICAgICBpbWFnZVxyXG4gICAgICAgICAgYTJhRW5kcG9pbnRcclxuICAgICAgICAgIGRpZFxyXG4gICAgICAgICAgbWNwXHJcbiAgICAgICAgICB4NDAyc3VwcG9ydFxyXG4gICAgICAgICAgYWN0aXZlXHJcbiAgICAgICAgICBzdXBwb3J0ZWRUcnVzdFxyXG4gICAgICAgICAgcmF3SnNvblxyXG4gICAgICAgICAgYWdlbnRDYXJkSnNvblxyXG4gICAgICAgICAgYWdlbnRDYXJkUmVhZEF0XHJcbiAgICAgICAgICBhdGlPdmVyYWxsU2NvcmVcclxuICAgICAgICAgIGF0aU92ZXJhbGxDb25maWRlbmNlXHJcbiAgICAgICAgICBhdGlWZXJzaW9uXHJcbiAgICAgICAgICBhdGlDb21wdXRlZEF0XHJcbiAgICAgICAgICBhdGlCdW5kbGVKc29uXHJcbiAgICAgICAgICB0cnVzdExlZGdlclNjb3JlXHJcbiAgICAgICAgICB0cnVzdExlZGdlckJhZGdlQ291bnRcclxuICAgICAgICAgIHRydXN0TGVkZ2VyT3ZlcmFsbFJhbmtcclxuICAgICAgICAgIHRydXN0TGVkZ2VyQ2FwYWJpbGl0eVJhbmtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIGA7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy5jbGllbnQucmVxdWVzdChxdWVyeSwge1xuICAgICAgICAgICAgICAgIHF1ZXJ5OiBzZWFyY2hUZXJtLFxuICAgICAgICAgICAgICAgIGxpbWl0OiBsaW1pdCB8fCAxMDAsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGFnZW50cyA9IGRhdGEuc2VhcmNoQWdlbnRzIHx8IFtdO1xuICAgICAgICAgICAgcmV0dXJuIGFnZW50cy5tYXAoKGFnZW50KSA9PiB0aGlzLm5vcm1hbGl6ZUFnZW50KGFnZW50KSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdbQUlBZ2VudERpc2NvdmVyeUNsaWVudC5zZWFyY2hBZ2VudHNdIEVycm9yIHNlYXJjaGluZyBhZ2VudHM6JywgZXJyb3IpO1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVmcmVzaC9JbmRleCBhbiBhZ2VudCBpbiB0aGUgaW5kZXhlclxuICAgICAqIFRyaWdnZXJzIHRoZSBpbmRleGVyIHRvIHJlLWluZGV4IHRoZSBzcGVjaWZpZWQgYWdlbnRcbiAgICAgKiBAcGFyYW0gYWdlbnRJZCAtIEFnZW50IElEIHRvIHJlZnJlc2ggKHJlcXVpcmVkKVxuICAgICAqIEBwYXJhbSBjaGFpbklkIC0gT3B0aW9uYWwgY2hhaW4gSUQgKGlmIG5vdCBwcm92aWRlZCwgaW5kZXhlciBtYXkgdXNlIGRlZmF1bHQpXG4gICAgICogQHBhcmFtIGFwaUtleSAtIE9wdGlvbmFsIEFQSSBrZXkgb3ZlcnJpZGUgKHVzZXMgY29uZmlnIEFQSSBrZXkgaWYgbm90IHByb3ZpZGVkKVxuICAgICAqIEByZXR1cm5zIFJlZnJlc2ggcmVzdWx0IHdpdGggc3VjY2VzcyBzdGF0dXMgYW5kIHByb2Nlc3NlZCBjaGFpbnNcbiAgICAgKi9cbiAgICBhc3luYyByZWZyZXNoQWdlbnQoYWdlbnRJZCwgY2hhaW5JZCwgYXBpS2V5KSB7XG4gICAgICAgIGNvbnN0IG11dGF0aW9uID0gYFxyXG4gICAgICBtdXRhdGlvbiBJbmRleEFnZW50KCRhZ2VudElkOiBTdHJpbmchLCAkY2hhaW5JZDogSW50KSB7XHJcbiAgICAgICAgaW5kZXhBZ2VudChhZ2VudElkOiAkYWdlbnRJZCwgY2hhaW5JZDogJGNoYWluSWQpIHtcclxuICAgICAgICAgIHN1Y2Nlc3NcclxuICAgICAgICAgIG1lc3NhZ2VcclxuICAgICAgICAgIHByb2Nlc3NlZENoYWluc1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgYDtcbiAgICAgICAgY29uc3QgdmFyaWFibGVzID0ge1xuICAgICAgICAgICAgYWdlbnRJZDogU3RyaW5nKGFnZW50SWQpLFxuICAgICAgICB9O1xuICAgICAgICBpZiAoY2hhaW5JZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2YXJpYWJsZXMuY2hhaW5JZCA9IGNoYWluSWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgQVBJIGtleSBvdmVycmlkZSBpcyBwcm92aWRlZCwgY3JlYXRlIGEgdGVtcG9yYXJ5IGNsaWVudCB3aXRoIHRoYXQga2V5XG4gICAgICAgIGxldCBjbGllbnRUb1VzZSA9IHRoaXMuY2xpZW50O1xuICAgICAgICBpZiAoYXBpS2V5KSB7XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJzID0ge1xuICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICAgICAgLi4uKHRoaXMuY29uZmlnLmhlYWRlcnMgfHwge30pLFxuICAgICAgICAgICAgICAgICdBdXRob3JpemF0aW9uJzogYEJlYXJlciAke2FwaUtleX1gLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNsaWVudFRvVXNlID0gbmV3IEdyYXBoUUxDbGllbnQodGhpcy5jb25maWcuZW5kcG9pbnQsIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBjbGllbnRUb1VzZS5yZXF1ZXN0KG11dGF0aW9uLCB2YXJpYWJsZXMpO1xuICAgICAgICAgICAgcmV0dXJuIGRhdGEuaW5kZXhBZ2VudDtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1tBSUFnZW50RGlzY292ZXJ5Q2xpZW50LnJlZnJlc2hBZ2VudF0gRXJyb3IgcmVmcmVzaGluZyBhZ2VudDonLCBlcnJvcik7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byByZWZyZXNoIGFnZW50OiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InfWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlYXJjaCB2YWxpZGF0aW9uIHJlcXVlc3RzIGZvciBhbiBhZ2VudCB1c2luZyBHcmFwaFFMXG4gICAgICovXG4gICAgYXN5bmMgc2VhcmNoVmFsaWRhdGlvblJlcXVlc3RzQWR2YW5jZWQob3B0aW9ucykge1xuICAgICAgICBjb25zdCB7IGNoYWluSWQsIGFnZW50SWQsIGxpbWl0ID0gMTAsIG9mZnNldCA9IDAsIG9yZGVyQnkgPSAnYmxvY2tOdW1iZXInLCBvcmRlckRpcmVjdGlvbiA9ICdERVNDJyB9ID0gb3B0aW9ucztcbiAgICAgICAgY29uc3QgYWdlbnRJZFN0cmluZyA9IHR5cGVvZiBhZ2VudElkID09PSAnbnVtYmVyJyA/IGFnZW50SWQudG9TdHJpbmcoKSA6IGFnZW50SWQ7XG4gICAgICAgIGNvbnN0IHF1ZXJ5VGV4dCA9IGBcclxuICAgICAgcXVlcnkgVmFsaWRhdGlvblJlcXVlc3RzRm9yQWdlbnQoXHJcbiAgICAgICAgJGFnZW50SWQ6IFN0cmluZyFcclxuICAgICAgICAkbGltaXQ6IEludFxyXG4gICAgICAgICRvZmZzZXQ6IEludFxyXG4gICAgICAgICRvcmRlckJ5OiBTdHJpbmdcclxuICAgICAgICAkb3JkZXJEaXJlY3Rpb246IFN0cmluZ1xyXG4gICAgICApIHtcclxuICAgICAgICB2YWxpZGF0aW9uUmVxdWVzdHMoXHJcbiAgICAgICAgICBhZ2VudElkOiAkYWdlbnRJZFxyXG4gICAgICAgICAgbGltaXQ6ICRsaW1pdFxyXG4gICAgICAgICAgb2Zmc2V0OiAkb2Zmc2V0XHJcbiAgICAgICAgICBvcmRlckJ5OiAkb3JkZXJCeVxyXG4gICAgICAgICAgb3JkZXJEaXJlY3Rpb246ICRvcmRlckRpcmVjdGlvblxyXG4gICAgICAgICkge1xyXG4gICAgICAgICAgaWRcclxuICAgICAgICAgIGFnZW50SWRcclxuICAgICAgICAgIHZhbGlkYXRvckFkZHJlc3NcclxuICAgICAgICAgIHJlcXVlc3RVcmlcclxuICAgICAgICAgIHJlcXVlc3RKc29uXHJcbiAgICAgICAgICByZXF1ZXN0SGFzaFxyXG4gICAgICAgICAgdHhIYXNoXHJcbiAgICAgICAgICBibG9ja051bWJlclxyXG4gICAgICAgICAgdGltZXN0YW1wXHJcbiAgICAgICAgICBjcmVhdGVkQXRcclxuICAgICAgICAgIHVwZGF0ZWRBdFxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgYDtcbiAgICAgICAgY29uc3QgdmFyaWFibGVzID0ge1xuICAgICAgICAgICAgYWdlbnRJZDogYWdlbnRJZFN0cmluZyxcbiAgICAgICAgICAgIGxpbWl0OiB0eXBlb2YgbGltaXQgPT09ICdudW1iZXInID8gbGltaXQgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBvZmZzZXQ6IHR5cGVvZiBvZmZzZXQgPT09ICdudW1iZXInID8gb2Zmc2V0IDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgb3JkZXJCeTogdHlwZW9mIG9yZGVyQnkgPT09ICdzdHJpbmcnID8gb3JkZXJCeSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIG9yZGVyRGlyZWN0aW9uOiB0eXBlb2Ygb3JkZXJEaXJlY3Rpb24gPT09ICdzdHJpbmcnID8gb3JkZXJEaXJlY3Rpb24gOiB1bmRlZmluZWQsXG4gICAgICAgIH07XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy5jbGllbnQucmVxdWVzdChxdWVyeVRleHQsIHZhcmlhYmxlcyk7XG4gICAgICAgICAgICBjb25zdCByZXF1ZXN0cyA9IGRhdGE/LnZhbGlkYXRpb25SZXF1ZXN0cztcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShyZXF1ZXN0cykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdmFsaWRhdGlvblJlcXVlc3RzOiByZXF1ZXN0cy5maWx0ZXIoQm9vbGVhbiksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdbQUlBZ2VudERpc2NvdmVyeUNsaWVudF0gc2VhcmNoVmFsaWRhdGlvblJlcXVlc3RzQWR2YW5jZWQgZmFpbGVkOicsIGVycm9yKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlYXJjaCBmZWVkYmFjayBmb3IgYW4gYWdlbnQgdXNpbmcgR3JhcGhRTFxuICAgICAqL1xuICAgIGFzeW5jIHNlYXJjaEZlZWRiYWNrQWR2YW5jZWQob3B0aW9ucykge1xuICAgICAgICBjb25zdCB7IGNoYWluSWQsIGFnZW50SWQsIGxpbWl0ID0gMTAsIG9mZnNldCA9IDAsIG9yZGVyQnkgPSAndGltZXN0YW1wJywgb3JkZXJEaXJlY3Rpb24gPSAnREVTQycgfSA9IG9wdGlvbnM7XG4gICAgICAgIGNvbnN0IGFnZW50SWRTdHJpbmcgPSB0eXBlb2YgYWdlbnRJZCA9PT0gJ251bWJlcicgPyBhZ2VudElkLnRvU3RyaW5nKCkgOiBhZ2VudElkO1xuICAgICAgICBjb25zdCBxdWVyeVRleHQgPSBgXHJcbiAgICAgIHF1ZXJ5IEZlZWRiYWNrRm9yQWdlbnQoXHJcbiAgICAgICAgJGNoYWluSWQ6IEludCFcclxuICAgICAgICAkYWdlbnRJZDogU3RyaW5nIVxyXG4gICAgICAgICRsaW1pdDogSW50XHJcbiAgICAgICAgJG9mZnNldDogSW50XHJcbiAgICAgICAgJG9yZGVyQnk6IFN0cmluZ1xyXG4gICAgICAgICRvcmRlckRpcmVjdGlvbjogU3RyaW5nXHJcbiAgICAgICkge1xyXG4gICAgICAgIGZlZWRiYWNrcyhcclxuICAgICAgICAgIGNoYWluSWQ6ICRjaGFpbklkXHJcbiAgICAgICAgICBhZ2VudElkOiAkYWdlbnRJZFxyXG4gICAgICAgICAgbGltaXQ6ICRsaW1pdFxyXG4gICAgICAgICAgb2Zmc2V0OiAkb2Zmc2V0XHJcbiAgICAgICAgICBvcmRlckJ5OiAkb3JkZXJCeVxyXG4gICAgICAgICAgb3JkZXJEaXJlY3Rpb246ICRvcmRlckRpcmVjdGlvblxyXG4gICAgICAgICkge1xyXG4gICAgICAgICAgaWRcclxuICAgICAgICAgIGFnZW50SWRcclxuICAgICAgICAgIGNsaWVudEFkZHJlc3NcclxuICAgICAgICAgIHNjb3JlXHJcbiAgICAgICAgICBmZWVkYmFja1VyaVxyXG4gICAgICAgICAgZmVlZGJhY2tKc29uXHJcbiAgICAgICAgICBjb21tZW50XHJcbiAgICAgICAgICByYXRpbmdQY3RcclxuICAgICAgICAgIHR4SGFzaFxyXG4gICAgICAgICAgYmxvY2tOdW1iZXJcclxuICAgICAgICAgIHRpbWVzdGFtcFxyXG4gICAgICAgICAgaXNSZXZva2VkXHJcbiAgICAgICAgICByZXNwb25zZUNvdW50XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICBgO1xuICAgICAgICBjb25zdCB2YXJpYWJsZXMgPSB7XG4gICAgICAgICAgICBjaGFpbklkLFxuICAgICAgICAgICAgYWdlbnRJZDogYWdlbnRJZFN0cmluZyxcbiAgICAgICAgICAgIGxpbWl0OiB0eXBlb2YgbGltaXQgPT09ICdudW1iZXInID8gbGltaXQgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBvZmZzZXQ6IHR5cGVvZiBvZmZzZXQgPT09ICdudW1iZXInID8gb2Zmc2V0IDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgb3JkZXJCeTogdHlwZW9mIG9yZGVyQnkgPT09ICdzdHJpbmcnID8gb3JkZXJCeSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIG9yZGVyRGlyZWN0aW9uOiB0eXBlb2Ygb3JkZXJEaXJlY3Rpb24gPT09ICdzdHJpbmcnID8gb3JkZXJEaXJlY3Rpb24gOiB1bmRlZmluZWQsXG4gICAgICAgIH07XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy5jbGllbnQucmVxdWVzdChxdWVyeVRleHQsIHZhcmlhYmxlcyk7XG4gICAgICAgICAgICBjb25zdCBmZWVkYmFja3MgPSBkYXRhPy5mZWVkYmFja3M7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoZmVlZGJhY2tzKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBmZWVkYmFja3M6IGZlZWRiYWNrcy5maWx0ZXIoQm9vbGVhbiksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdbQUlBZ2VudERpc2NvdmVyeUNsaWVudF0gc2VhcmNoRmVlZGJhY2tBZHZhbmNlZCBmYWlsZWQ6JywgZXJyb3IpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRXhlY3V0ZSBhIHJhdyBHcmFwaFFMIHF1ZXJ5XG4gICAgICogQHBhcmFtIHF1ZXJ5IC0gR3JhcGhRTCBxdWVyeSBzdHJpbmdcbiAgICAgKiBAcGFyYW0gdmFyaWFibGVzIC0gUXVlcnkgdmFyaWFibGVzXG4gICAgICogQHJldHVybnMgUXVlcnkgcmVzcG9uc2VcbiAgICAgKi9cbiAgICBhc3luYyByZXF1ZXN0KHF1ZXJ5LCB2YXJpYWJsZXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LnJlcXVlc3QocXVlcnksIHZhcmlhYmxlcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV4ZWN1dGUgYSByYXcgR3JhcGhRTCBtdXRhdGlvblxuICAgICAqIEBwYXJhbSBtdXRhdGlvbiAtIEdyYXBoUUwgbXV0YXRpb24gc3RyaW5nXG4gICAgICogQHBhcmFtIHZhcmlhYmxlcyAtIE11dGF0aW9uIHZhcmlhYmxlc1xuICAgICAqIEByZXR1cm5zIE11dGF0aW9uIHJlc3BvbnNlXG4gICAgICovXG4gICAgYXN5bmMgbXV0YXRlKG11dGF0aW9uLCB2YXJpYWJsZXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LnJlcXVlc3QobXV0YXRpb24sIHZhcmlhYmxlcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgdW5kZXJseWluZyBHcmFwaFFMQ2xpZW50IGluc3RhbmNlXG4gICAgICogQHJldHVybnMgVGhlIEdyYXBoUUxDbGllbnQgaW5zdGFuY2VcbiAgICAgKi9cbiAgICBnZXRDbGllbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGFnZW50cyBvd25lZCBieSBhIHNwZWNpZmljIEVPQSBhZGRyZXNzXG4gICAgICogQHBhcmFtIGVvYUFkZHJlc3MgLSBUaGUgRU9BIChFeHRlcm5hbGx5IE93bmVkIEFjY291bnQpIGFkZHJlc3MgdG8gc2VhcmNoIGZvclxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9uYWwgc2VhcmNoIG9wdGlvbnMgKGxpbWl0LCBvZmZzZXQsIG9yZGVyQnksIG9yZGVyRGlyZWN0aW9uKVxuICAgICAqIEByZXR1cm5zIExpc3Qgb2YgYWdlbnRzIG93bmVkIGJ5IHRoZSBFT0EgYWRkcmVzc1xuICAgICAqL1xuICAgIGFzeW5jIGdldE93bmVkQWdlbnRzKGVvYUFkZHJlc3MsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCFlb2FBZGRyZXNzIHx8IHR5cGVvZiBlb2FBZGRyZXNzICE9PSAnc3RyaW5nJyB8fCAhZW9hQWRkcmVzcy5zdGFydHNXaXRoKCcweCcpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgRU9BIGFkZHJlc3MuIE11c3QgYmUgYSB2YWxpZCBFdGhlcmV1bSBhZGRyZXNzIHN0YXJ0aW5nIHdpdGggMHgnKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJbmRleGVyL3N0b3JhZ2UgY2FuIHZhcnk6IHNvbWUgZGVwbG95bWVudHMgc3RvcmUgY2hlY2tzdW0gYWRkcmVzc2VzIGFzIHN0cmluZ3M7IG90aGVycyBzdG9yZSBsb3dlcmNhc2VkIGhleC5cbiAgICAgICAgLy8gUXVlcnkgZGVmZW5zaXZlbHkgaW4gYSBjYXNlLXNhZmUgd2F5LlxuICAgICAgICBjb25zdCBhZGRyTG93ZXIgPSBlb2FBZGRyZXNzLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGNvbnN0IGFkZHJDYW5kaWRhdGVzID0gW107XG4gICAgICAgIGFkZHJDYW5kaWRhdGVzLnB1c2goZW9hQWRkcmVzcyk7XG4gICAgICAgIGlmIChhZGRyTG93ZXIgIT09IGVvYUFkZHJlc3MpXG4gICAgICAgICAgICBhZGRyQ2FuZGlkYXRlcy5wdXNoKGFkZHJMb3dlcik7XG4gICAgICAgIGNvbnN0IGxpbWl0ID0gb3B0aW9ucz8ubGltaXQgPz8gMTAwO1xuICAgICAgICBjb25zdCBvZmZzZXQgPSBvcHRpb25zPy5vZmZzZXQgPz8gMDtcbiAgICAgICAgY29uc3Qgb3JkZXJCeSA9IG9wdGlvbnM/Lm9yZGVyQnkgPz8gJ2FnZW50SWQnO1xuICAgICAgICBjb25zdCBvcmRlckRpcmVjdGlvbiA9IG9wdGlvbnM/Lm9yZGVyRGlyZWN0aW9uID8/ICdERVNDJztcbiAgICAgICAgY29uc3QgcXVlcnkgPSBgXHJcbiAgICAgIHF1ZXJ5IEdldE93bmVkQWdlbnRzKFxyXG4gICAgICAgICR3aGVyZTogQWdlbnRXaGVyZUlucHV0XHJcbiAgICAgICAgJGZpcnN0OiBJbnRcclxuICAgICAgICAkc2tpcDogSW50XHJcbiAgICAgICAgJG9yZGVyQnk6IEFnZW50T3JkZXJCeVxyXG4gICAgICAgICRvcmRlckRpcmVjdGlvbjogT3JkZXJEaXJlY3Rpb25cclxuICAgICAgKSB7XHJcbiAgICAgICAgc2VhcmNoQWdlbnRzR3JhcGgoXHJcbiAgICAgICAgICB3aGVyZTogJHdoZXJlXHJcbiAgICAgICAgICBmaXJzdDogJGZpcnN0XHJcbiAgICAgICAgICBza2lwOiAkc2tpcFxyXG4gICAgICAgICAgb3JkZXJCeTogJG9yZGVyQnlcclxuICAgICAgICAgIG9yZGVyRGlyZWN0aW9uOiAkb3JkZXJEaXJlY3Rpb25cclxuICAgICAgICApIHtcclxuICAgICAgICAgIGFnZW50cyB7XHJcbiAgICAgICAgICAgIGNoYWluSWRcclxuICAgICAgICAgICAgYWdlbnRJZFxyXG4gICAgICAgICAgICBhZ2VudEFjY291bnRcclxuICAgICAgICAgICAgYWdlbnROYW1lXHJcbiAgICAgICAgICAgIGFnZW50Q2F0ZWdvcnlcclxuICAgICAgICAgICAgZGlkSWRlbnRpdHlcclxuICAgICAgICAgICAgZGlkQWNjb3VudFxyXG4gICAgICAgICAgICBkaWROYW1lXHJcbiAgICAgICAgICAgIGFnZW50SWRlbnRpdHlPd25lckFjY291bnRcclxuICAgICAgICAgICAgZW9hQWdlbnRJZGVudGl0eU93bmVyQWNjb3VudFxyXG4gICAgICAgICAgICBlb2FBZ2VudEFjY291bnRcclxuICAgICAgICAgICAgYWdlbnRVcmlcclxuICAgICAgICAgICAgY3JlYXRlZEF0QmxvY2tcclxuICAgICAgICAgICAgY3JlYXRlZEF0VGltZVxyXG4gICAgICAgICAgICB1cGRhdGVkQXRUaW1lXHJcbiAgICAgICAgICAgIHR5cGVcclxuICAgICAgICAgICAgZGVzY3JpcHRpb25cclxuICAgICAgICAgICAgaW1hZ2VcclxuICAgICAgICAgICAgYTJhRW5kcG9pbnRcclxuICAgICAgICAgICAgc3VwcG9ydGVkVHJ1c3RcclxuICAgICAgICAgICAgcmF3SnNvblxyXG4gICAgICAgICAgICBhZ2VudENhcmRKc29uXHJcbiAgICAgICAgICAgIGFnZW50Q2FyZFJlYWRBdFxyXG4gICAgICAgICAgICBkaWRcclxuICAgICAgICAgICAgbWNwXHJcbiAgICAgICAgICAgIHg0MDJzdXBwb3J0XHJcbiAgICAgICAgICAgIGFjdGl2ZVxyXG4gICAgICAgICAgICBmZWVkYmFja0NvdW50XHJcbiAgICAgICAgICAgIGZlZWRiYWNrQXZlcmFnZVNjb3JlXHJcbiAgICAgICAgICAgIHZhbGlkYXRpb25QZW5kaW5nQ291bnRcclxuICAgICAgICAgICAgdmFsaWRhdGlvbkNvbXBsZXRlZENvdW50XHJcbiAgICAgICAgICAgIHZhbGlkYXRpb25SZXF1ZXN0ZWRDb3VudFxyXG4gICAgICAgICAgICBpbml0aWF0ZWRBc3NvY2lhdGlvbkNvdW50XHJcbiAgICAgICAgICAgIGFwcHJvdmVkQXNzb2NpYXRpb25Db3VudFxyXG4gICAgICAgICAgICBhdGlPdmVyYWxsU2NvcmVcclxuICAgICAgICAgICAgYXRpT3ZlcmFsbENvbmZpZGVuY2VcclxuICAgICAgICAgICAgYXRpVmVyc2lvblxyXG4gICAgICAgICAgICBhdGlDb21wdXRlZEF0XHJcbiAgICAgICAgICAgIGF0aUJ1bmRsZUpzb25cclxuICAgICAgICAgICAgdHJ1c3RMZWRnZXJTY29yZVxyXG4gICAgICAgICAgICB0cnVzdExlZGdlckJhZGdlQ291bnRcclxuICAgICAgICAgICAgdHJ1c3RMZWRnZXJPdmVyYWxsUmFua1xyXG4gICAgICAgICAgICB0cnVzdExlZGdlckNhcGFiaWxpdHlSYW5rXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICB0b3RhbFxyXG4gICAgICAgICAgaGFzTW9yZVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgYDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFByZWZlciBfaW4gZmlsdGVyICh3b3JrcyBmb3Igc3RyaW5nIGZpZWxkcyBhbmQgc29tZSBieXRlcyBmaWVsZHMpLiBJZiBzY2hlbWEgZG9lc24ndCBzdXBwb3J0IGl0LFxuICAgICAgICAgICAgLy8gZmFsbCBiYWNrIHRvIGV4YWN0LW1hdGNoIGF0dGVtcHRzIGFjcm9zcyBjYW5kaWRhdGVzLlxuICAgICAgICAgICAgY29uc3QgdHJ5UXVlcnkgPSBhc3luYyAod2hlcmUpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YXJpYWJsZXMgPSB7XG4gICAgICAgICAgICAgICAgICAgIHdoZXJlLFxuICAgICAgICAgICAgICAgICAgICBmaXJzdDogbGltaXQsXG4gICAgICAgICAgICAgICAgICAgIHNraXA6IG9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgb3JkZXJCeSxcbiAgICAgICAgICAgICAgICAgICAgb3JkZXJEaXJlY3Rpb24sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy5jbGllbnQucmVxdWVzdChxdWVyeSwgdmFyaWFibGVzKTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBkYXRhLnNlYXJjaEFnZW50c0dyYXBoID8/IHsgYWdlbnRzOiBbXSwgdG90YWw6IDAsIGhhc01vcmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIChyZXN1bHQuYWdlbnRzID8/IFtdKS5tYXAoKGFnZW50KSA9PiB0aGlzLm5vcm1hbGl6ZUFnZW50KGFnZW50KSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gMSkgVHJ5IGVvYUFnZW50SWRlbnRpdHlPd25lckFjY291bnRfaW46IFtjYW5kaWRhdGVzXVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBvd25lZCA9IGF3YWl0IHRyeVF1ZXJ5KHsgZW9hQWdlbnRJZGVudGl0eU93bmVyQWNjb3VudF9pbjogYWRkckNhbmRpZGF0ZXMgfSk7XG4gICAgICAgICAgICAgICAgaWYgKG93bmVkLmxlbmd0aCA+IDApXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvd25lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2VFcnJvcnMgPSBlPy5yZXNwb25zZT8uZXJyb3JzO1xuICAgICAgICAgICAgICAgIGNvbnN0IGluTm90U3VwcG9ydGVkID0gQXJyYXkuaXNBcnJheShyZXNwb25zZUVycm9ycykgJiZcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VFcnJvcnMuc29tZSgoZXJyKSA9PiB0eXBlb2YgZXJyPy5tZXNzYWdlID09PSAnc3RyaW5nJyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKGVyci5tZXNzYWdlLmluY2x1ZGVzKCdlb2FBZ2VudElkZW50aXR5T3duZXJBY2NvdW50X2luJykgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnIubWVzc2FnZS5pbmNsdWRlcygnRmllbGQgXCJlb2FBZ2VudElkZW50aXR5T3duZXJBY2NvdW50X2luXCInKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVyci5tZXNzYWdlLmluY2x1ZGVzKCdVbmtub3duIGFyZ3VtZW50JykgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnIubWVzc2FnZS5pbmNsdWRlcygnQ2Fubm90IHF1ZXJ5IGZpZWxkJykpKTtcbiAgICAgICAgICAgICAgICBpZiAoIWluTm90U3VwcG9ydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gMikgRXhhY3QgbWF0Y2ggYXR0ZW1wdHNcbiAgICAgICAgICAgIGZvciAoY29uc3QgY2FuZGlkYXRlIG9mIGFkZHJDYW5kaWRhdGVzKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3duZWQgPSBhd2FpdCB0cnlRdWVyeSh7IGVvYUFnZW50SWRlbnRpdHlPd25lckFjY291bnQ6IGNhbmRpZGF0ZSB9KTtcbiAgICAgICAgICAgICAgICBpZiAob3duZWQubGVuZ3RoID4gMClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG93bmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignW0FJQWdlbnREaXNjb3ZlcnlDbGllbnQuZ2V0T3duZWRBZ2VudHNdIEVycm9yIGZldGNoaW5nIG93bmVkIGFnZW50czonLCBlcnJvcik7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFJQWdlbnREaXNjb3ZlcnlDbGllbnQuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@agentic-trust/8004-ext-sdk/dist/AIAgentDiscoveryClient.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@agentic-trust/8004-ext-sdk/dist/AIAgentENSClient.js":
/*!*******************************************************************************!*\
  !*** ../../node_modules/@agentic-trust/8004-ext-sdk/dist/AIAgentENSClient.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AIAgentENSClient: () => (/* binding */ AIAgentENSClient)\n/* harmony export */ });\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! viem */ \"(rsc)/../../node_modules/viem/_esm/clients/createPublicClient.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! viem */ \"(rsc)/../../node_modules/viem/_esm/clients/transports/http.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! viem */ \"(rsc)/../../node_modules/viem/_esm/utils/ens/namehash.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! viem */ \"(rsc)/../../node_modules/viem/_esm/utils/abi/encodeFunctionData.js\");\n/* harmony import */ var viem_ens__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! viem/ens */ \"(rsc)/../../node_modules/viem/_esm/utils/ens/normalize.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ethers */ \"(rsc)/../../node_modules/ethers/lib.esm/abi/interface.js\");\n/* harmony import */ var _abis_NameWrapper_json__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abis/NameWrapper.json */ \"(rsc)/../../node_modules/@agentic-trust/8004-ext-sdk/dist/abis/NameWrapper.json\");\n/* harmony import */ var _abis_PublicResolver_json__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./abis/PublicResolver.json */ \"(rsc)/../../node_modules/@agentic-trust/8004-ext-sdk/dist/abis/PublicResolver.json\");\n/**\n * Agentic Trust SDK - ENS Client\n * Uses AccountProvider (Ports & Adapters pattern) for chain I/O.\n */\n\n\n\n\n\nclass AIAgentENSClient {\n    chain;\n    accountProvider;\n    ensRegistryAddress;\n    ensResolverAddress;\n    identityRegistryAddress;\n    publicClient = null;\n    constructor(chain, rpcUrl, accountProvider, ensRegistryAddress, ensResolverAddress, identityRegistryAddress) {\n        this.chain = chain;\n        this.accountProvider = accountProvider;\n        // @ts-ignore - viem version compatibility issue\n        this.publicClient = (0,viem__WEBPACK_IMPORTED_MODULE_2__.createPublicClient)({ chain, transport: (0,viem__WEBPACK_IMPORTED_MODULE_3__.http)(rpcUrl) });\n        this.ensRegistryAddress = ensRegistryAddress;\n        this.ensResolverAddress = ensResolverAddress;\n        this.identityRegistryAddress = identityRegistryAddress;\n        // Try to extract publicClient from AccountProvider if it's a ViemAccountProvider\n        const viemProvider = accountProvider;\n        if (viemProvider.publicClient) {\n            this.publicClient = viemProvider.publicClient;\n        }\n    }\n    getEnsRegistryAddress() {\n        return this.ensRegistryAddress;\n    }\n    getEnsResolverAddress() {\n        return this.ensResolverAddress;\n    }\n    /**\n     * Check if this client is for L1 (ETH Sepolia)\n     * Base implementation - can be overridden by subclasses\n     */\n    isL1() {\n        // Default implementation: assume L1 unless overridden\n        // Subclasses like AIAgentL2ENSClient will override this\n        return !this.isL2();\n    }\n    /**\n     * Check if this client is for L2 (Base Sepolia, Optimism Sepolia, etc.)\n     * Base implementation - can be overridden by subclasses\n     */\n    isL2() {\n        // Default implementation: assume L1 unless overridden\n        // Subclasses like AIAgentL2ENSClient will override this\n        return false;\n    }\n    /**\n     * Get the chain type as a string\n     */\n    getChainType() {\n        return this.isL2() ? 'L2' : 'L1';\n    }\n    encodeCall(abi, functionName, args) {\n        const iface = new ethers__WEBPACK_IMPORTED_MODULE_4__.Interface(abi);\n        return iface.encodeFunctionData(functionName, args);\n    }\n    async encodeSetNameUri(name, uri) {\n        const node = (0,viem__WEBPACK_IMPORTED_MODULE_5__.namehash)(name);\n        const data = (0,viem__WEBPACK_IMPORTED_MODULE_6__.encodeFunctionData)({\n            abi: _abis_PublicResolver_json__WEBPACK_IMPORTED_MODULE_1__.abi,\n            functionName: 'setText',\n            args: [node, \"url\", uri]\n        });\n        return data;\n    }\n    async prepareSetNameUriCalls(name, uri) {\n        const calls = [];\n        const data = await this.encodeSetNameUri(name, uri);\n        if (this.publicClient) {\n            const resolver = this.getEnsResolverAddress();\n            /*\n              const node = namehash(name) as `0x${string}`;\n              const resolver = await this.// @ts-ignore - viem version compatibility issue\n          publicClient.readContract({\n                  address: this.ensRegistryAddress,\n                  abi: [{ name: \"resolver\", stateMutability: \"view\", type: \"function\",\n                          inputs: [{ name: \"node\", type: \"bytes32\"}], outputs: [{ type: \"address\"}]}],\n                  functionName: \"resolver\",\n                  args: [node],\n              });\n              */\n            console.info(\"++++++++++++++++++++ prepareSetNameUriCalls: chain\", this.publicClient?.chain?.id);\n            console.info(\"++++++++++++++++++++ prepareSetNameUriCalls: resolver\", resolver);\n            calls.push({ to: resolver, data: data });\n        }\n        return { calls };\n    }\n    async prepareAddAgentInfoCalls(params) {\n        return { calls: [] };\n    }\n    async prepareSetNameImageCalls(name, imageUrl) {\n        const calls = [];\n        const node = (0,viem__WEBPACK_IMPORTED_MODULE_5__.namehash)(name);\n        const data = (0,viem__WEBPACK_IMPORTED_MODULE_6__.encodeFunctionData)({\n            abi: _abis_PublicResolver_json__WEBPACK_IMPORTED_MODULE_1__.abi,\n            functionName: 'setText',\n            args: [node, \"avatar\", imageUrl]\n        });\n        if (this.publicClient) {\n            const resolver = this.getEnsResolverAddress();\n            console.info(\"++++++++++++++++++++ prepareSetNameImageCalls: chain\", this.publicClient?.chain?.id);\n            console.info(\"++++++++++++++++++++ prepareSetNameImageCalls: resolver\", resolver);\n            calls.push({ to: resolver, data: data });\n        }\n        return { calls };\n    }\n    async prepareSetNameDescriptionCalls(name, description) {\n        const calls = [];\n        const node = (0,viem__WEBPACK_IMPORTED_MODULE_5__.namehash)(name);\n        const data = (0,viem__WEBPACK_IMPORTED_MODULE_6__.encodeFunctionData)({\n            abi: _abis_PublicResolver_json__WEBPACK_IMPORTED_MODULE_1__.abi,\n            functionName: 'setText',\n            args: [node, \"description\", description]\n        });\n        if (this.publicClient) {\n            const resolver = this.getEnsResolverAddress();\n            console.info(\"++++++++++++++++++++ prepareSetNameDescriptionCalls: chain\", this.publicClient?.chain?.id);\n            console.info(\"++++++++++++++++++++ prepareSetNameDescriptionCalls: resolver\", resolver);\n            calls.push({ to: resolver, data: data });\n        }\n        return { calls };\n    }\n    async encodeSetNameAgentIdentity(name, agentIdentity) {\n        // Build ERC-7930 (approx) binary: [v1=01][ns=eip155=01][chainId(4 bytes)][address(20 bytes)] + [len(1)][agentId bytes]\n        const chainHex = (this.chain.id >>> 0).toString(16).padStart(8, '0');\n        const addrHex = (this.identityRegistryAddress).slice(2).toLowerCase().padStart(40, '0');\n        const idHex = agentIdentity.toString(16);\n        const idLen = Math.ceil(idHex.length / 2);\n        const idLenHex = idLen.toString(16).padStart(2, '0');\n        const valueHex = `0x01` + `01` + chainHex + addrHex + idLenHex + idHex.padStart(idLen * 2, '0');\n        const node = (0,viem__WEBPACK_IMPORTED_MODULE_5__.namehash)(name);\n        const data = (0,viem__WEBPACK_IMPORTED_MODULE_6__.encodeFunctionData)({\n            abi: _abis_PublicResolver_json__WEBPACK_IMPORTED_MODULE_1__.abi,\n            functionName: 'setText',\n            args: [node, \"agent-identity\", valueHex]\n        });\n        return data;\n    }\n    async prepareSetNameAgentIdentityCalls(name, agentIdentity) {\n        const data = await this.encodeSetNameAgentIdentity(name, agentIdentity);\n        const calls = [];\n        if (this.publicClient) {\n            const node = (0,viem__WEBPACK_IMPORTED_MODULE_5__.namehash)(name);\n            const resolver = await this. // @ts-ignore - viem version compatibility issue\n                publicClient.readContract({\n                address: this.ensRegistryAddress,\n                abi: [{ name: \"resolver\", stateMutability: \"view\", type: \"function\",\n                        inputs: [{ name: \"node\", type: \"bytes32\" }], outputs: [{ type: \"address\" }] }],\n                functionName: \"resolver\",\n                args: [node],\n            });\n            calls.push({ to: resolver, data: data });\n        }\n        return { calls };\n    }\n    async isValidAgentAccount(agentAccount) {\n        if (this.publicClient) {\n            const code = await this.publicClient.getBytecode({ address: agentAccount });\n            return code ? true : false;\n        }\n        return false;\n    }\n    /**\n     * Resolve an agent by account address via ENS reverse + text record.\n     * 1) Reverse resolve address -> ENS name via ENS Registry + resolver.name(bytes32)\n     * 2) Read resolver.text(node, 'agent-identity') and decode agentId\n     */\n    async getAgentIdentityByAccount(account) {\n        const ensRegistry = this.ensRegistryAddress;\n        const accountLower = account.toLowerCase();\n        // Minimal ABIs\n        const ENS_REGISTRY_ABI = [\n            { name: 'resolver', type: 'function', stateMutability: 'view', inputs: [{ name: 'node', type: 'bytes32' }], outputs: [{ name: '', type: 'address' }] },\n        ];\n        const RESOLVER_ABI = [\n            { name: 'name', type: 'function', stateMutability: 'view', inputs: [{ name: 'node', type: 'bytes32' }], outputs: [{ name: '', type: 'string' }] },\n            { name: 'text', type: 'function', stateMutability: 'view', inputs: [{ name: 'node', type: 'bytes32' }, { name: 'key', type: 'string' }], outputs: [{ name: '', type: 'string' }] },\n        ];\n        const reverseNode = (0,viem__WEBPACK_IMPORTED_MODULE_5__.namehash)(`${accountLower.slice(2)}.addr.reverse`);\n        // 1) resolver for reverse node\n        let resolverAddr = null;\n        try {\n            resolverAddr = await this.accountProvider.call({\n                to: this.ensRegistryAddress,\n                abi: [{\n                        name: 'resolver',\n                        type: 'function',\n                        stateMutability: 'view',\n                        inputs: [{ name: 'node', type: 'bytes32' }],\n                        outputs: [{ name: '', type: 'address' }]\n                    }],\n                functionName: 'resolver',\n                args: [reverseNode],\n            });\n        }\n        catch { }\n        if (!resolverAddr || resolverAddr === '0x0000000000000000000000000000000000000000') {\n            return { agentId: null, ensName: null };\n        }\n        // 2) resolver.name to get ENS name\n        let ensName = null;\n        try {\n            ensName = await this.accountProvider.call({\n                to: resolverAddr,\n                abi: _abis_PublicResolver_json__WEBPACK_IMPORTED_MODULE_1__.abi,\n                functionName: 'name',\n                args: [reverseNode],\n            }).catch(() => null);\n            if (typeof ensName !== 'string' || !ensName)\n                ensName = null;\n        }\n        catch { }\n        // 3) resolver.text(node, 'agent-identity') on forward node if we have a name\n        let agentId = null;\n        if (ensName) {\n            const forwardNode = (0,viem__WEBPACK_IMPORTED_MODULE_5__.namehash)(ensName);\n            try {\n                const value = await this.accountProvider.call({\n                    to: resolverAddr,\n                    abi: _abis_PublicResolver_json__WEBPACK_IMPORTED_MODULE_1__.abi,\n                    functionName: 'text',\n                    args: [forwardNode, 'agent-identity'],\n                }).catch(() => null);\n                const decoded = this.decodeAgentIdentity(value);\n                agentId = decoded?.agentId ?? null;\n            }\n            catch { }\n        }\n        return { agentId, ensName };\n    }\n    /**\n     * Resolve an agent by ENS name via resolver.text(namehash(name), 'agent-identity')\n     */\n    async getAgentIdentityByName(name) {\n        let ensName = name.trim().toLowerCase();\n        if (!ensName)\n            return { agentId: null, account: null };\n        ensName = ensName.endsWith('.eth') ? ensName.slice(0, -4) : ensName;\n        ensName = ensName + '.eth';\n        const node = (0,viem__WEBPACK_IMPORTED_MODULE_5__.namehash)(ensName);\n        // resolver\n        let resolverAddr = null;\n        try {\n            resolverAddr = await this.accountProvider.call({\n                to: this.ensRegistryAddress,\n                abi: [{\n                        name: 'resolver',\n                        type: 'function',\n                        stateMutability: 'view',\n                        inputs: [{ name: 'node', type: 'bytes32' }],\n                        outputs: [{ name: '', type: 'address' }]\n                    }],\n                functionName: 'resolver',\n                args: [node],\n            });\n            // returns 0xE99638b40E4Fff0129D56f03b55b6bbC4BBE49b5\n        }\n        catch (error) {\n            console.info(\"++++++++++++++++++++ getAgentIdentityByName 1: error\", error);\n            return { agentId: null, account: null }; // Return null if we can't get resolver\n        }\n        if (!resolverAddr || resolverAddr === '0x0000000000000000000000000000000000000000') {\n            return { agentId: null, account: null };\n        }\n        // agent-identity text\n        let agentId = null;\n        try {\n            const value = await this.accountProvider.call({\n                to: resolverAddr,\n                abi: _abis_PublicResolver_json__WEBPACK_IMPORTED_MODULE_1__.abi,\n                functionName: 'text',\n                args: [node, 'agent-identity'],\n            }).catch(() => null);\n            // Handle empty response\n            if (!value || value === '0x' || value === '') {\n                console.info(\"++++++++++++++++++++ getAgentIdentityByName: empty agent-identity text record\");\n                return { agentId: null, account: null };\n            }\n            const decoded = this.decodeAgentIdentity(value);\n            agentId = decoded?.agentId ?? null;\n        }\n        catch (error) {\n            console.info(\"++++++++++++++++++++ getAgentIdentityByName 2: error\", error);\n            return { agentId: null, account: null }; // Return null if we can't get the text record\n        }\n        return { agentId, account: null };\n    }\n    /**\n     * Check if an agent name record already has an owner in the ENS Registry.\n     * This doesn't require an address to be set, just checks if the record exists.\n     */\n    async hasAgentNameOwner(orgName, agentName) {\n        const clean = (s) => (s || '').trim().toLowerCase();\n        let parent = clean(orgName);\n        parent = parent.endsWith('.eth') ? parent.slice(0, -4) : parent;\n        const label = clean(agentName).replace(/\\s+/g, '-');\n        const fullSubname = `${label}.${parent}.eth`;\n        const subnameNode = (0,viem__WEBPACK_IMPORTED_MODULE_5__.namehash)(fullSubname);\n        try {\n            const existingOwner = await this.accountProvider.call({\n                to: this.ensRegistryAddress,\n                abi: [{ name: 'owner', type: 'function', stateMutability: 'view', inputs: [{ type: 'bytes32' }], outputs: [{ type: 'address' }] }],\n                functionName: 'owner',\n                args: [subnameNode],\n            });\n            const hasOwner = Boolean(existingOwner && existingOwner !== '0x0000000000000000000000000000000000000000');\n            console.info(`hasAgentNameOwner: \"${fullSubname}\" ${hasOwner ? 'HAS owner' : 'has NO owner'}${hasOwner ? `: ${existingOwner}` : ''}`);\n            return hasOwner;\n        }\n        catch (error) {\n            console.error('Error checking agent name owner:', error);\n            return false;\n        }\n    }\n    /**\n     * Resolve account address for an ENS name via resolver.addr(namehash(name)).\n     */\n    async getAgentAccountByName(name) {\n        let ensName = name.trim().toLowerCase();\n        ensName = ensName.endsWith('.eth') ? ensName.slice(0, -4) : ensName;\n        ensName = `${ensName}.eth`;\n        const normalizedName = (0,viem_ens__WEBPACK_IMPORTED_MODULE_7__.normalize)(ensName);\n        const node = (0,viem__WEBPACK_IMPORTED_MODULE_5__.namehash)(normalizedName);\n        console.log('[AIAgentENSClient.getAgentAccountByName] chain:', this.chain?.id, this.chain?.name);\n        console.log('[AIAgentENSClient.getAgentAccountByName] normalizedName:', normalizedName);\n        console.log('[AIAgentENSClient.getAgentAccountByName] node:', node);\n        console.log('[AIAgentENSClient.getAgentAccountByName] resolver address:', this.ensResolverAddress);\n        if (!this.publicClient) {\n            console.warn('[AIAgentENSClient.getAgentAccountByName] publicClient not initialized');\n            return null;\n        }\n        try {\n            // Call resolver.addr(namehash(name)) directly using the configured resolver\n            const resolverAbi = [\n                {\n                    inputs: [{ internalType: 'bytes32', name: 'node', type: 'bytes32' }],\n                    name: 'addr',\n                    outputs: [{ internalType: 'address', name: 'ret', type: 'address' }],\n                    stateMutability: 'view',\n                    type: 'function',\n                },\n            ];\n            const addr = await this.publicClient.readContract({\n                address: this.ensResolverAddress,\n                abi: resolverAbi,\n                functionName: 'addr',\n                args: [node],\n            });\n            const addrStr = addr;\n            const isZero = !addrStr || addrStr === '0x0000000000000000000000000000000000000000';\n            console.log('[AIAgentENSClient.getAgentAccountByName] return resolved addr:', addrStr);\n            return isZero ? null : addrStr;\n        }\n        catch (error) {\n            console.error('[AIAgentENSClient.getAgentAccountByName] Error resolving addr:', error);\n            return null;\n        }\n        /*\n    \n            const universalResolverAbi = parseAbi([\n          'error ResolverNotFound(bytes name)',\n          'error ResolverNotContract(bytes name, address resolver)',\n          'error UnsupportedResolverProfile(bytes4 selector)',\n          'error ResolverError(bytes errorData)',\n          'error ReverseAddressMismatch(string primary, bytes primaryAddress)',\n          'error HttpError(uint16 status, string message)',\n          'function resolve(bytes name, bytes data) view returns (bytes result, address resolver)',\n          'function reverse(bytes lookupAddress, uint256 coinType) view returns (string primary, address resolver, address reverseResolver)',\n        ])\n    \n        // universal resolver\n        const resolverAddr: `0x${string}` = \"0xeEeEEEeE14D718C2B47D9923Deab1335E144EeEe\";\n        \n    \n        try {\n    \n    \n          // construct data read\n          const simpleResolverAbi1 = parseAbi([\n            'function addr(bytes32 node) view returns (address)',\n            'function text(bytes32 node, string key) view returns (string)',\n          ])\n           \n          const multicallAbi = parseAbi([\n            'function multicall(bytes[] data) returns (bytes[] results)',\n          ])\n           \n          const name = normalize(ensName)\n          const node1 = namehash(name)\n           \n          const resolverCalls1 = [\n            {\n              abi: simpleResolverAbi1,\n              functionName: 'addr',\n              args: [node1],\n            },\n            {\n              abi: simpleResolverAbi1,\n              functionName: 'text',\n              args: [node1, 'description'],\n            },\n          ] as const\n           \n          const data = encodeFunctionData({\n            abi: multicallAbi,\n            functionName: 'multicall',\n            args: [resolverCalls1.map((call) => encodeFunctionData(call))],\n          })\n     \n          const universalResolverAbi = parseAbi([\n            'error ResolverNotFound(bytes name)',\n            'error ResolverNotContract(bytes name, address resolver)',\n            'error UnsupportedResolverProfile(bytes4 selector)',\n            'error ResolverError(bytes errorData)',\n            'error ReverseAddressMismatch(string primary, bytes primaryAddress)',\n            'error HttpError(uint16 status, string message)',\n            'function resolve(bytes name, bytes data) view returns (bytes result, address resolver)',\n            'function reverse(bytes lookupAddress, uint256 coinType) view returns (string primary, address resolver, address reverseResolver)',\n          ])\n          \n          console.info('*********** zzz getAgentAccountByName chain id', await this.publicClient?.getChainId());\n          \n    \n          const dnsEncodedName = toHex(packetToBytes(name))\n    \n          const resolveRes = await this.publicClient?.readContract({\n            abi: universalResolverAbi,\n            address: '0xeEeEEEeE14D718C2B47D9923Deab1335E144EeEe',\n            functionName: 'resolve',\n            args: [dnsEncodedName, data],\n          })\n          \n          if (!resolveRes) {\n            return null;\n          }\n    \n          const decodedMulticall = decodeFunctionResult({\n            abi: multicallAbi,\n            functionName: 'multicall',\n            data: resolveRes[0] as `0x${string}`,\n          }) as `0x${string}`[];\n          \n          console.log('*********** zzz getAgentAccountByName decodedMulticall', decodedMulticall);\n          const decodedRes = (decodedMulticall || []).map((res, i) => {\n            console.log('*********** zzz getAgentAccountByName res', res);\n            const call = resolverCalls1[i];\n            if (!call) {\n              return null;\n            }\n            const fn = (call.functionName === 'addr' ? 'addr' : 'text') as 'addr' | 'text';\n            console.log('*********** zzz getAgentAccountByName fn', fn);\n            return decodeFunctionResult({\n              abi: simpleResolverAbi1,\n              functionName: fn,\n              data: res,\n            });\n          }).filter(Boolean)\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n          const simpleResolverAbi = parseAbi([\n            'function addr(bytes32 node) view returns (address)',\n            'function text(bytes32 node, string key) view returns (string)',\n          ])\n           \n          console.log('*********** zzz getAgentAccountByName ensName', ensName);\n          const name = normalize(ensName);\n          console.log('*********** zzz getAgentAccountByName normalized name', name);\n          const node = namehash(name);\n    \n          // DNS wire-format encode of the ENS name for Universal Resolver (use normalized form)\n          const dnsEncodedName = toHex(packetToBytes(name));\n    \n          // Resolve addr(name) via Universal Resolver\n          const addrCallData = encodeFunctionData({\n            abi: simpleResolverAbi,\n            functionName: 'addr',\n            args: [node],\n          });\n          const addrResolve = await this.publicClient?.readContract({\n            address: resolverAddr,\n            abi: universalResolverAbi,\n            functionName: 'resolve',\n            args: [dnsEncodedName, addrCallData],\n          }).catch(() => null) as readonly [`0x${string}`, `0x${string}`] | null;\n    \n          console.log('*********** zzz getAgentAccountByName addrResolve', addrResolve);\n          let addrFromResolver: string | null = null;\n          if (addrResolve) {\n            console.log('*********** zzz getAgentAccountByName addrResolve[0]', addrResolve[0]);\n            try {\n              const decoded = decodeFunctionResult({\n                abi: simpleResolverAbi,\n                functionName: 'addr',\n                data: addrResolve[0],\n              }) as string;\n              console.log('*********** zzz getAgentAccountByName decoded', decoded);\n              addrFromResolver = decoded ?? null;\n            } catch (e) {\n              console.warn(\"UniversalResolver decode addr failed\", e);\n            }\n          }\n    \n          // Best-effort: resolve text(name,'description') for metadata (non-blocking)\n          const textCallData = encodeFunctionData({\n            abi: simpleResolverAbi,\n            functionName: 'text',\n            args: [node, 'description'],\n          });\n          const textResolve = await this.publicClient?.readContract({\n            address: resolverAddr,\n            abi: universalResolverAbi,\n            functionName: 'resolve',\n            args: [dnsEncodedName, textCallData],\n          }).catch(() => null);\n    \n          if (textResolve) {\n            try {\n              const textDecoded = decodeFunctionResult({\n                abi: simpleResolverAbi,\n                functionName: 'text',\n                data: textResolve[0] as `0x${string}`,\n              }) as string;\n              console.log('*********** zzz getAgentAccountByName description text', textDecoded);\n            } catch (e) {\n              console.warn('UniversalResolver decode text(description) failed', e);\n            }\n          }\n    \n          const addr = addrFromResolver;\n          if (addr && /^0x[a-fA-F0-9]{40}$/.test(addr) && addr !== '0x0000000000000000000000000000000000000000') {\n            return addr as `0x${string}`;\n          }\n         \n        } catch (error) {\n          console.error(\"Error getting agent account by name: \", error);\n        }\n    \n        return null;\n        */\n    }\n    /**\n     * Get the Agent URL via ENS text record for a given ENS name.\n     */\n    async getAgentUrlByName(name) {\n        const ensName = name.trim().toLowerCase();\n        if (!ensName)\n            return null;\n        const ENS_REGISTRY_ABI = [\n            { name: 'resolver', type: 'function', stateMutability: 'view', inputs: [{ name: 'node', type: 'bytes32' }], outputs: [{ name: '', type: 'address' }] },\n        ];\n        const RESOLVER_ABI = [\n            { name: 'text', type: 'function', stateMutability: 'view', inputs: [{ name: 'node', type: 'bytes32' }, { name: 'key', type: 'string' }], outputs: [{ name: '', type: 'string' }] },\n        ];\n        const node = (0,viem__WEBPACK_IMPORTED_MODULE_5__.namehash)(ensName);\n        // resolver\n        let resolverAddr = null;\n        try {\n            resolverAddr = await this.accountProvider.call({\n                to: this.ensRegistryAddress,\n                abi: [{\n                        name: 'resolver',\n                        type: 'function',\n                        stateMutability: 'view',\n                        inputs: [{ name: 'node', type: 'bytes32' }],\n                        outputs: [{ name: '', type: 'address' }]\n                    }],\n                functionName: 'resolver',\n                args: [node],\n            });\n            // returns 0xE99638b40E4Fff0129D56f03b55b6bbC4BBE49b5\n        }\n        catch { }\n        if (!resolverAddr || resolverAddr === '0x0000000000000000000000000000000000000000') {\n            return null;\n        }\n        try {\n            const url = await this.accountProvider.call({\n                to: resolverAddr,\n                abi: _abis_PublicResolver_json__WEBPACK_IMPORTED_MODULE_1__.abi,\n                functionName: 'text',\n                args: [node, 'url'],\n            }).catch(() => null);\n            const trimmed = (url || '').trim();\n            return trimmed.length > 0 ? trimmed : null;\n        }\n        catch {\n            return null;\n        }\n    }\n    /**\n     * Get the Agent Avatar/Image via ENS text record for a given ENS name.\n     */\n    async getAgentImageByName(name) {\n        const ensName = name.trim().toLowerCase();\n        if (!ensName)\n            return null;\n        const node = (0,viem__WEBPACK_IMPORTED_MODULE_5__.namehash)(ensName);\n        // resolver\n        let resolverAddr = null;\n        try {\n            resolverAddr = await this.accountProvider.call({\n                to: this.ensRegistryAddress,\n                abi: [{\n                        name: 'resolver',\n                        type: 'function',\n                        stateMutability: 'view',\n                        inputs: [{ name: 'node', type: 'bytes32' }],\n                        outputs: [{ name: '', type: 'address' }]\n                    }],\n                functionName: 'resolver',\n                args: [node],\n            });\n        }\n        catch { }\n        if (!resolverAddr || resolverAddr === '0x0000000000000000000000000000000000000000') {\n            return null;\n        }\n        try {\n            const image = await this.accountProvider.call({\n                to: resolverAddr,\n                abi: _abis_PublicResolver_json__WEBPACK_IMPORTED_MODULE_1__.abi,\n                functionName: 'text',\n                args: [node, 'avatar'],\n            }).catch(() => null);\n            const trimmed = (image || '').trim();\n            return trimmed.length > 0 ? trimmed : null;\n        }\n        catch {\n            return null;\n        }\n    }\n    /**\n     * Get the Agent Description via ENS text record for a given ENS name.\n     */\n    async getAgentDescriptionByName(name) {\n        const ensName = name.trim().toLowerCase();\n        if (!ensName)\n            return null;\n        const node = (0,viem__WEBPACK_IMPORTED_MODULE_5__.namehash)(ensName);\n        // resolver\n        let resolverAddr = null;\n        try {\n            resolverAddr = await this.accountProvider.call({\n                to: this.ensRegistryAddress,\n                abi: [{\n                        name: 'resolver',\n                        type: 'function',\n                        stateMutability: 'view',\n                        inputs: [{ name: 'node', type: 'bytes32' }],\n                        outputs: [{ name: '', type: 'address' }]\n                    }],\n                functionName: 'resolver',\n                args: [node],\n            });\n        }\n        catch { }\n        if (!resolverAddr || resolverAddr === '0x0000000000000000000000000000000000000000') {\n            return null;\n        }\n        try {\n            const description = await this.accountProvider.call({\n                to: resolverAddr,\n                abi: _abis_PublicResolver_json__WEBPACK_IMPORTED_MODULE_1__.abi,\n                functionName: 'text',\n                args: [node, 'description'],\n            }).catch(() => null);\n            const trimmed = (description || '').trim();\n            return trimmed.length > 0 ? trimmed : null;\n        }\n        catch {\n            return null;\n        }\n    }\n    /**\n     * Reverse lookup: account address -> ENS name via resolver.name(reverseNode)\n     */\n    async getAgentNameByAccount(account) {\n        const ensRegistry = this.ensRegistryAddress;\n        const accountLower = account.toLowerCase();\n        const ENS_REGISTRY_ABI = [\n            { name: 'resolver', type: 'function', stateMutability: 'view', inputs: [{ name: 'node', type: 'bytes32' }], outputs: [{ name: '', type: 'address' }] },\n        ];\n        const RESOLVER_ABI = [\n            { name: 'name', type: 'function', stateMutability: 'view', inputs: [{ name: 'node', type: 'bytes32' }], outputs: [{ name: '', type: 'string' }] },\n        ];\n        const reverseNode = (0,viem__WEBPACK_IMPORTED_MODULE_5__.namehash)(`${accountLower.slice(2)}.addr.reverse`);\n        // resolver for reverse node\n        let resolverAddr = null;\n        try {\n            // @ts-ignore - viem version compatibility issue\n            resolverAddr = await this.publicClient?.readContract({\n                address: this.ensRegistryAddress,\n                abi: [{\n                        name: 'resolver',\n                        type: 'function',\n                        stateMutability: 'view',\n                        inputs: [{ name: 'node', type: 'bytes32' }],\n                        outputs: [{ name: '', type: 'address' }]\n                    }],\n                functionName: 'resolver',\n                args: [reverseNode]\n            });\n        }\n        catch { }\n        if (!resolverAddr || resolverAddr === '0x0000000000000000000000000000000000000000') {\n            return null;\n        }\n        try {\n            const ensName = await this.accountProvider.call({\n                to: resolverAddr,\n                abi: _abis_PublicResolver_json__WEBPACK_IMPORTED_MODULE_1__.abi,\n                functionName: 'name',\n                args: [reverseNode],\n            }).catch(() => null);\n            const normalized = (ensName || '').trim().toLowerCase();\n            return normalized.length > 0 ? normalized : null;\n        }\n        catch {\n            return null;\n        }\n    }\n    async prepareSetAgentNameInfoCalls(params) {\n        const RESOLVER_ABI = [\n            { name: 'setAddr', type: 'function', stateMutability: 'nonpayable', inputs: [\n                    { name: 'node', type: 'bytes32' },\n                    { name: 'addr', type: 'address' }\n                ], outputs: [] },\n            { name: 'setText', type: 'function', stateMutability: 'nonpayable', inputs: [\n                    { name: 'node', type: 'bytes32' },\n                    { name: 'key', type: 'string' },\n                    { name: 'value', type: 'string' }\n                ], outputs: [] },\n        ];\n        const clean = (s) => (s || '').trim().toLowerCase();\n        const parent = clean(params.orgName);\n        const label = clean(params.agentName).replace(/\\s+/g, '-');\n        const childDomain = `${label}.${parent}`;\n        const ensFullName = childDomain + \".eth\";\n        const childNode = (0,viem__WEBPACK_IMPORTED_MODULE_5__.namehash)(ensFullName);\n        const calls = [];\n        if (this.publicClient) {\n            const resolver = await this.accountProvider.call({\n                to: this.ensRegistryAddress,\n                abi: [{ name: \"resolver\", stateMutability: \"view\", type: \"function\",\n                        inputs: [{ name: \"node\", type: \"bytes32\" }], outputs: [{ type: \"address\" }] }],\n                functionName: \"resolver\",\n                args: [childNode],\n            });\n            // 1) Set addr record\n            const setAddrData = (0,viem__WEBPACK_IMPORTED_MODULE_6__.encodeFunctionData)({\n                abi: [{ name: \"setAddr\", type: \"function\", stateMutability: \"nonpayable\",\n                        inputs: [{ name: \"node\", type: \"bytes32\" }, { name: \"a\", type: \"address\" }] }],\n                functionName: \"setAddr\",\n                args: [childNode, params.agentAddress],\n            });\n            calls.push({ to: resolver, data: setAddrData });\n            // 2) Optionally set URL text\n            if (params.agentUrl && params.agentUrl.trim() !== '') {\n                const dataSetUrl = this.encodeCall(RESOLVER_ABI, 'setText(bytes32,string,string)', [childNode, 'url', params.agentUrl.trim()]);\n                calls.push({ to: resolver, data: dataSetUrl });\n            }\n            // 2b) Optionally set description text\n            if (params.agentDescription && params.agentDescription.trim() !== '') {\n                const dataSetDescription = this.encodeCall(RESOLVER_ABI, 'setText(bytes32,string,string)', [childNode, 'description', params.agentDescription.trim()]);\n                calls.push({ to: resolver, data: dataSetDescription });\n            }\n            // 3) Set reverse record\n            //const reverseNode = namehash(params.agentAddress.slice(2).toLowerCase() + '.addr.reverse');\n            const BASE_REVERSE_NODE = (0,viem__WEBPACK_IMPORTED_MODULE_5__.namehash)(\"addr.reverse\");\n            const ENS_REGISTRY_ADDRESS = this.ensRegistryAddress;\n            const reverseRegistrar = await this.accountProvider.call({\n                to: ENS_REGISTRY_ADDRESS,\n                abi: [{\n                        name: \"owner\",\n                        type: \"function\",\n                        stateMutability: \"view\",\n                        inputs: [{ name: \"node\", type: \"bytes32\" }],\n                        outputs: [{ name: \"\", type: \"address\" }],\n                    }],\n                functionName: \"owner\",\n                args: [BASE_REVERSE_NODE],\n            });\n            /*\n            const ourReverseRegistrar = await this.accountProvider.call<`0x${string}`>({\n              to: ENS_REGISTRY_ADDRESS,\n              abi: [{\n                name: \"owner\",\n                type: \"function\",\n                stateMutability: \"view\",\n                inputs: [{ name: \"node\", type: \"bytes32\" }],\n                outputs: [{ name: \"\", type: \"address\" }],\n              }] as any,\n              functionName: \"owner\",\n              args: [reverseNode],\n            });\n            */\n            const setNameData = (0,viem__WEBPACK_IMPORTED_MODULE_6__.encodeFunctionData)({\n                abi: [{\n                        name: \"setName\",\n                        type: \"function\",\n                        stateMutability: \"nonpayable\",\n                        inputs: [{ name: \"name\", type: \"string\" }],\n                        outputs: [{ name: \"node\", type: \"bytes32\" }],\n                    }],\n                functionName: \"setName\",\n                args: [ensFullName], // e.g. \"finder-airbnb-com.orgtrust.eth\"\n            });\n            const call = {\n                to: reverseRegistrar,\n                data: setNameData,\n                value: 0n\n            };\n            calls.push(call);\n        }\n        return { calls };\n    }\n    // ENS wrapper\n    async prepareAddAgentNameToOrgCalls(params) {\n        const clean = (s) => (s || '').trim().toLowerCase();\n        let parent = clean(params.orgName);\n        parent = parent.endsWith('.eth') ? parent.slice(0, -4) : parent;\n        const parentNode = (0,viem__WEBPACK_IMPORTED_MODULE_5__.namehash)(parent + \".eth\");\n        console.log('!!!!!!!!!!!! prepareAddAgentNameToOrgCalls: parent', parent + \".eth\");\n        const label = clean(params.agentName).replace(/\\s+/g, '-');\n        console.log('!!!!!!!!!!!! prepareAddAgentNameToOrgCalls: agentName', params.agentName);\n        console.log('!!!!!!!!!!!! prepareAddAgentNameToOrgCalls: label', label);\n        const calls = [];\n        // Use stored resolver address from client instance\n        //const resolverAddress = this.getEnsResolverAddress();\n        //if (!resolverAddress || resolverAddress === '0x' || resolverAddress.length !== 42) {\n        //  throw new Error(`Invalid ENS resolver address: ${resolverAddress}. Ensure ENS resolver is properly configured.`);\n        //}\n        // Get identity wrapper address from environment (chain-scoped if available)\n        const identityWrapperAddress = this.getChainScopedAddress('AGENTIC_TRUST_ENS_IDENTITY_WRAPPER', this.chain.id);\n        if (!identityWrapperAddress) {\n            throw new Error(`Invalid ENS identity wrapper address. Set AGENTIC_TRUST_ENS_IDENTITY_WRAPPER_{CHAIN_SUFFIX} or AGENTIC_TRUST_ENS_IDENTITY_WRAPPER environment variable.`);\n        }\n        console.log('!!!!!!!!!!!! prepareAddAgentNameToOrgCalls: label, address', label, params.agentAddress);\n        const subdomainData = (0,viem__WEBPACK_IMPORTED_MODULE_6__.encodeFunctionData)({\n            abi: _abis_NameWrapper_json__WEBPACK_IMPORTED_MODULE_0__.abi,\n            functionName: 'setSubnodeRecord',\n            args: [\n                parentNode,\n                label,\n                params.agentAddress,\n                this.getChainScopedAddress('AGENTIC_TRUST_ENS_PUBLIC_RESOLVER', this.chain.id),\n                0,\n                0,\n                0\n            ]\n        });\n        const call = {\n            to: identityWrapperAddress,\n            data: subdomainData,\n            value: 0n\n        };\n        calls.push(call);\n        return { calls };\n    }\n    isZeroAddress(addr) {\n        return /^0x0{40}$/i.test(addr);\n    }\n    async getAddressFromENSName(ensName) {\n        const clean = (s) => (s || '').trim().toLowerCase();\n        let parent = clean(ensName);\n        parent = parent.endsWith('.eth') ? parent.slice(0, -4) : parent;\n        const fullname = `${parent}.eth`;\n        const nameNode = (0,viem__WEBPACK_IMPORTED_MODULE_5__.namehash)(fullname);\n        console.info(\"ensRegistryAddress: \", this.ensRegistryAddress);\n        console.info(\"fullname: \", fullname);\n        try {\n            const existingOwner = await this.publicClient?.readContract({\n                address: this.ensRegistryAddress,\n                abi: [{ name: 'owner', type: 'function', stateMutability: 'view', inputs: [{ type: 'bytes32' }], outputs: [{ type: 'address' }] }],\n                functionName: 'owner',\n                args: [nameNode]\n            });\n            const hasOwner = Boolean(existingOwner && existingOwner !== '0x0000000000000000000000000000000000000000');\n            console.info(`hasAgentNameOwner: \"${nameNode}\" ${hasOwner ? 'HAS owner' : 'has NO owner'}${hasOwner ? `: ${existingOwner}` : ''}`);\n            return existingOwner;\n        }\n        catch (error) {\n            console.error('Error checking agent name owner:', error);\n            return null;\n        }\n    }\n    /**\n     * Resolve a chain-scoped env var, falling back to the base name.\n     * For example, with baseName 'AGENTIC_TRUST_ENS_PUBLIC_RESOLVER' and\n     * chain.id=11155111, this checks:\n     *  - AGENTIC_TRUST_ENS_PUBLIC_RESOLVER_SEPOLIA\n     *  - AGENTIC_TRUST_ENS_PUBLIC_RESOLVER\n     */\n    getChainScopedAddress(baseName, chainId) {\n        const suffix = chainId === 11155111\n            ? 'SEPOLIA'\n            : chainId === 84532\n                ? 'BASE_SEPOLIA'\n                : chainId === 11155420\n                    ? 'OPTIMISM_SEPOLIA'\n                    : undefined;\n        const chainKey = suffix ? `${baseName}_${suffix}` : baseName;\n        const chainValue = process.env[chainKey];\n        const fallbackValue = process.env[baseName];\n        const raw = chainValue ?? fallbackValue;\n        if (!raw)\n            return undefined;\n        const trimmed = raw.trim();\n        if (!/^0x[0-9a-fA-F]{40}$/.test(trimmed))\n            return undefined;\n        return trimmed;\n    }\n    /** Decode ERC-7930-like agent identity hex string */\n    decodeAgentIdentity(value) {\n        try {\n            if (!value || !/^0x[0-9a-fA-F]+$/.test(value))\n                return null;\n            const hex = value.slice(2);\n            // [v1=01][ns=eip155=01][chainId(4)][address(20)][len(1)][id(var)]\n            if (hex.length < 2 + 2 + 8 + 40 + 2)\n                return null;\n            const chainIdHex = hex.slice(4, 12);\n            const chainId = parseInt(chainIdHex, 16);\n            const addrHex = hex.slice(12, 52);\n            const idLen = parseInt(hex.slice(52, 54), 16);\n            const idHex = hex.slice(54, 54 + idLen * 2);\n            const registry = (`0x${addrHex}`);\n            const agentId = BigInt(`0x${idHex || '0'}`);\n            return { chainId, registry, agentId };\n        }\n        catch {\n            return null;\n        }\n    }\n}\n//# sourceMappingURL=AIAgentENSClient.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BhZ2VudGljLXRydXN0LzgwMDQtZXh0LXNkay9kaXN0L0FJQWdlbnRFTlNDbGllbnQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDOEU7QUFDekM7QUFDTDtBQUNxQjtBQUNNO0FBQ3BEO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsd0RBQWtCLEdBQUcsa0JBQWtCLDBDQUFJLFVBQVU7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsNkNBQWdCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiw4Q0FBUTtBQUM3QixxQkFBcUIsd0RBQWtCO0FBQ3ZDLGlCQUFpQiwwREFBcUI7QUFDdEM7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELE9BQU87QUFDekQ7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCLHFDQUFxQyw4QkFBOEIsZUFBZSxnQkFBZ0IsRUFBRTtBQUNwRztBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QiwwQkFBMEI7QUFDbkQ7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsOENBQVE7QUFDN0IscUJBQXFCLHdEQUFrQjtBQUN2QyxpQkFBaUIsMERBQXFCO0FBQ3RDO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsMEJBQTBCO0FBQ25EO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiw4Q0FBUTtBQUM3QixxQkFBcUIsd0RBQWtCO0FBQ3ZDLGlCQUFpQiwwREFBcUI7QUFDdEM7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QiwwQkFBMEI7QUFDbkQ7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDhDQUFRO0FBQzdCLHFCQUFxQix3REFBa0I7QUFDdkMsaUJBQWlCLDBEQUFxQjtBQUN0QztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qiw4Q0FBUTtBQUNqQztBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIsbUNBQW1DLCtCQUErQixlQUFlLGlCQUFpQixHQUFHO0FBQ3JHO0FBQ0E7QUFDQSxhQUFhO0FBQ2IseUJBQXlCLDBCQUEwQjtBQUNuRDtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSwrREFBK0QsdUJBQXVCO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHdFQUF3RSwrQkFBK0IsZUFBZSwyQkFBMkIsR0FBRztBQUNsSztBQUNBO0FBQ0EsY0FBYyxvRUFBb0UsK0JBQStCLGVBQWUsMEJBQTBCLEdBQUc7QUFDN0osY0FBYyxvRUFBb0UsK0JBQStCLElBQUksNkJBQTZCLGVBQWUsMEJBQTBCLEdBQUc7QUFDOUw7QUFDQSw0QkFBNEIsOENBQVEsSUFBSSxzQkFBc0I7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLCtCQUErQjtBQUNsRSxvQ0FBb0MsMkJBQTJCO0FBQy9ELHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsMERBQXFCO0FBQzFDO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsOENBQVE7QUFDeEM7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDBEQUFxQjtBQUM5QztBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLHFCQUFxQiw4Q0FBUTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsK0JBQStCO0FBQ2xFLG9DQUFvQywyQkFBMkI7QUFDL0QscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsZ0NBQWdDO0FBQ3JEO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDBEQUFxQjtBQUMxQztBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsZ0NBQWdDO0FBQ3JEO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLE1BQU0sR0FBRyxPQUFPO0FBQy9DLDRCQUE0Qiw4Q0FBUTtBQUNwQztBQUNBO0FBQ0E7QUFDQSx3QkFBd0IscUVBQXFFLGlCQUFpQixlQUFlLGlCQUFpQixHQUFHO0FBQ2pKO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxnREFBZ0QsWUFBWSxJQUFJLHdDQUF3QyxFQUFFLGdCQUFnQixjQUFjLE9BQU87QUFDL0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsUUFBUTtBQUM3QiwrQkFBK0IsbURBQVM7QUFDeEMscUJBQXFCLDhDQUFRO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQix3REFBd0Q7QUFDdkY7QUFDQSxnQ0FBZ0MsdURBQXVEO0FBQ3ZGO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsT0FBTztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLE9BQU87QUFDL0MsV0FBVyxVQUFVLE9BQU87QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsc0NBQXNDLE9BQU8sUUFBUSxPQUFPO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLE9BQU87QUFDcEQsZUFBZTtBQUNmO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsR0FBRztBQUN6QyxnQ0FBZ0MsT0FBTztBQUN2QztBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHdFQUF3RSwrQkFBK0IsZUFBZSwyQkFBMkIsR0FBRztBQUNsSztBQUNBO0FBQ0EsY0FBYyxvRUFBb0UsK0JBQStCLElBQUksNkJBQTZCLGVBQWUsMEJBQTBCLEdBQUc7QUFDOUw7QUFDQSxxQkFBcUIsOENBQVE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLCtCQUErQjtBQUNsRSxvQ0FBb0MsMkJBQTJCO0FBQy9ELHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiwwREFBcUI7QUFDMUM7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDhDQUFRO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQywrQkFBK0I7QUFDbEUsb0NBQW9DLDJCQUEyQjtBQUMvRCxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDBEQUFxQjtBQUMxQztBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsOENBQVE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLCtCQUErQjtBQUNsRSxvQ0FBb0MsMkJBQTJCO0FBQy9ELHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsMERBQXFCO0FBQzFDO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsd0VBQXdFLCtCQUErQixlQUFlLDJCQUEyQixHQUFHO0FBQ2xLO0FBQ0E7QUFDQSxjQUFjLG9FQUFvRSwrQkFBK0IsZUFBZSwwQkFBMEIsR0FBRztBQUM3SjtBQUNBLDRCQUE0Qiw4Q0FBUSxJQUFJLHNCQUFzQjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQywrQkFBK0I7QUFDbEUsb0NBQW9DLDJCQUEyQjtBQUMvRCxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDBEQUFxQjtBQUMxQztBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxzQkFBc0IsK0JBQStCO0FBQ3JELHNCQUFzQjtBQUN0QixnQ0FBZ0M7QUFDaEMsY0FBYztBQUNkLHNCQUFzQiwrQkFBK0I7QUFDckQsc0JBQXNCLDZCQUE2QjtBQUNuRCxzQkFBc0I7QUFDdEIsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLE1BQU0sR0FBRyxPQUFPO0FBQy9DO0FBQ0EsMEJBQTBCLDhDQUFRO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCLG1DQUFtQywrQkFBK0IsZUFBZSxpQkFBaUIsR0FBRztBQUNyRztBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsZ0NBQWdDLHdEQUFrQjtBQUNsRCx3QkFBd0I7QUFDeEIsbUNBQW1DLCtCQUErQixJQUFJLDRCQUE0QixHQUFHO0FBQ3JHO0FBQ0E7QUFDQSxhQUFhO0FBQ2IseUJBQXlCLGlDQUFpQztBQUMxRDtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsZ0NBQWdDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHdDQUF3QztBQUNyRTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsOENBQVE7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsK0JBQStCO0FBQ2xFLG9DQUFvQywyQkFBMkI7QUFDL0QscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSw2RUFBNkUsT0FBTztBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLCtCQUErQjtBQUMxRCw0QkFBNEIsMkJBQTJCO0FBQ3ZELGVBQWU7QUFDZjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsZ0NBQWdDLHdEQUFrQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyw4QkFBOEI7QUFDakUsb0NBQW9DLCtCQUErQjtBQUNuRSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsOENBQVE7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxnQkFBZ0I7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyR0FBMkcsY0FBYztBQUN6SDtBQUNBO0FBQ0EsOEJBQThCLHdEQUFrQjtBQUNoRCxpQkFBaUIsdURBQWtCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EscUJBQXFCLEdBQUc7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixPQUFPO0FBQ25DLHlCQUF5Qiw4Q0FBUTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHFFQUFxRSxpQkFBaUIsZUFBZSxpQkFBaUIsR0FBRztBQUNqSjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsZ0RBQWdELFNBQVMsSUFBSSx3Q0FBd0MsRUFBRSxnQkFBZ0IsY0FBYyxPQUFPO0FBQzVJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLFNBQVMsR0FBRyxPQUFPO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixHQUFHO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsUUFBUTtBQUMzQyx3Q0FBd0MsYUFBYTtBQUNyRCxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL2JhcmIvYWEvQXNzb2NpYXRlZEFjY291bnRzL25vZGVfbW9kdWxlcy9AYWdlbnRpYy10cnVzdC84MDA0LWV4dC1zZGsvZGlzdC9BSUFnZW50RU5TQ2xpZW50LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQWdlbnRpYyBUcnVzdCBTREsgLSBFTlMgQ2xpZW50XG4gKiBVc2VzIEFjY291bnRQcm92aWRlciAoUG9ydHMgJiBBZGFwdGVycyBwYXR0ZXJuKSBmb3IgY2hhaW4gSS9PLlxuICovXG5pbXBvcnQgeyBjcmVhdGVQdWJsaWNDbGllbnQsIGh0dHAsIG5hbWVoYXNoLCBlbmNvZGVGdW5jdGlvbkRhdGEgfSBmcm9tICd2aWVtJztcbmltcG9ydCB7IG5vcm1hbGl6ZSB9IGZyb20gJ3ZpZW0vZW5zJztcbmltcG9ydCB7IGV0aGVycyB9IGZyb20gJ2V0aGVycyc7XG5pbXBvcnQgTmFtZVdyYXBwZXJBQkkgZnJvbSAnLi9hYmlzL05hbWVXcmFwcGVyLmpzb24nO1xuaW1wb3J0IFB1YmxpY1Jlc29sdmVyQUJJIGZyb20gJy4vYWJpcy9QdWJsaWNSZXNvbHZlci5qc29uJztcbmV4cG9ydCBjbGFzcyBBSUFnZW50RU5TQ2xpZW50IHtcbiAgICBjaGFpbjtcbiAgICBhY2NvdW50UHJvdmlkZXI7XG4gICAgZW5zUmVnaXN0cnlBZGRyZXNzO1xuICAgIGVuc1Jlc29sdmVyQWRkcmVzcztcbiAgICBpZGVudGl0eVJlZ2lzdHJ5QWRkcmVzcztcbiAgICBwdWJsaWNDbGllbnQgPSBudWxsO1xuICAgIGNvbnN0cnVjdG9yKGNoYWluLCBycGNVcmwsIGFjY291bnRQcm92aWRlciwgZW5zUmVnaXN0cnlBZGRyZXNzLCBlbnNSZXNvbHZlckFkZHJlc3MsIGlkZW50aXR5UmVnaXN0cnlBZGRyZXNzKSB7XG4gICAgICAgIHRoaXMuY2hhaW4gPSBjaGFpbjtcbiAgICAgICAgdGhpcy5hY2NvdW50UHJvdmlkZXIgPSBhY2NvdW50UHJvdmlkZXI7XG4gICAgICAgIC8vIEB0cy1pZ25vcmUgLSB2aWVtIHZlcnNpb24gY29tcGF0aWJpbGl0eSBpc3N1ZVxuICAgICAgICB0aGlzLnB1YmxpY0NsaWVudCA9IGNyZWF0ZVB1YmxpY0NsaWVudCh7IGNoYWluLCB0cmFuc3BvcnQ6IGh0dHAocnBjVXJsKSB9KTtcbiAgICAgICAgdGhpcy5lbnNSZWdpc3RyeUFkZHJlc3MgPSBlbnNSZWdpc3RyeUFkZHJlc3M7XG4gICAgICAgIHRoaXMuZW5zUmVzb2x2ZXJBZGRyZXNzID0gZW5zUmVzb2x2ZXJBZGRyZXNzO1xuICAgICAgICB0aGlzLmlkZW50aXR5UmVnaXN0cnlBZGRyZXNzID0gaWRlbnRpdHlSZWdpc3RyeUFkZHJlc3M7XG4gICAgICAgIC8vIFRyeSB0byBleHRyYWN0IHB1YmxpY0NsaWVudCBmcm9tIEFjY291bnRQcm92aWRlciBpZiBpdCdzIGEgVmllbUFjY291bnRQcm92aWRlclxuICAgICAgICBjb25zdCB2aWVtUHJvdmlkZXIgPSBhY2NvdW50UHJvdmlkZXI7XG4gICAgICAgIGlmICh2aWVtUHJvdmlkZXIucHVibGljQ2xpZW50KSB7XG4gICAgICAgICAgICB0aGlzLnB1YmxpY0NsaWVudCA9IHZpZW1Qcm92aWRlci5wdWJsaWNDbGllbnQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0RW5zUmVnaXN0cnlBZGRyZXNzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbnNSZWdpc3RyeUFkZHJlc3M7XG4gICAgfVxuICAgIGdldEVuc1Jlc29sdmVyQWRkcmVzcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5zUmVzb2x2ZXJBZGRyZXNzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0aGlzIGNsaWVudCBpcyBmb3IgTDEgKEVUSCBTZXBvbGlhKVxuICAgICAqIEJhc2UgaW1wbGVtZW50YXRpb24gLSBjYW4gYmUgb3ZlcnJpZGRlbiBieSBzdWJjbGFzc2VzXG4gICAgICovXG4gICAgaXNMMSgpIHtcbiAgICAgICAgLy8gRGVmYXVsdCBpbXBsZW1lbnRhdGlvbjogYXNzdW1lIEwxIHVubGVzcyBvdmVycmlkZGVuXG4gICAgICAgIC8vIFN1YmNsYXNzZXMgbGlrZSBBSUFnZW50TDJFTlNDbGllbnQgd2lsbCBvdmVycmlkZSB0aGlzXG4gICAgICAgIHJldHVybiAhdGhpcy5pc0wyKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHRoaXMgY2xpZW50IGlzIGZvciBMMiAoQmFzZSBTZXBvbGlhLCBPcHRpbWlzbSBTZXBvbGlhLCBldGMuKVxuICAgICAqIEJhc2UgaW1wbGVtZW50YXRpb24gLSBjYW4gYmUgb3ZlcnJpZGRlbiBieSBzdWJjbGFzc2VzXG4gICAgICovXG4gICAgaXNMMigpIHtcbiAgICAgICAgLy8gRGVmYXVsdCBpbXBsZW1lbnRhdGlvbjogYXNzdW1lIEwxIHVubGVzcyBvdmVycmlkZGVuXG4gICAgICAgIC8vIFN1YmNsYXNzZXMgbGlrZSBBSUFnZW50TDJFTlNDbGllbnQgd2lsbCBvdmVycmlkZSB0aGlzXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjaGFpbiB0eXBlIGFzIGEgc3RyaW5nXG4gICAgICovXG4gICAgZ2V0Q2hhaW5UeXBlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc0wyKCkgPyAnTDInIDogJ0wxJztcbiAgICB9XG4gICAgZW5jb2RlQ2FsbChhYmksIGZ1bmN0aW9uTmFtZSwgYXJncykge1xuICAgICAgICBjb25zdCBpZmFjZSA9IG5ldyBldGhlcnMuSW50ZXJmYWNlKGFiaSk7XG4gICAgICAgIHJldHVybiBpZmFjZS5lbmNvZGVGdW5jdGlvbkRhdGEoZnVuY3Rpb25OYW1lLCBhcmdzKTtcbiAgICB9XG4gICAgYXN5bmMgZW5jb2RlU2V0TmFtZVVyaShuYW1lLCB1cmkpIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IG5hbWVoYXNoKG5hbWUpO1xuICAgICAgICBjb25zdCBkYXRhID0gZW5jb2RlRnVuY3Rpb25EYXRhKHtcbiAgICAgICAgICAgIGFiaTogUHVibGljUmVzb2x2ZXJBQkkuYWJpLFxuICAgICAgICAgICAgZnVuY3Rpb25OYW1lOiAnc2V0VGV4dCcsXG4gICAgICAgICAgICBhcmdzOiBbbm9kZSwgXCJ1cmxcIiwgdXJpXVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIGFzeW5jIHByZXBhcmVTZXROYW1lVXJpQ2FsbHMobmFtZSwgdXJpKSB7XG4gICAgICAgIGNvbnN0IGNhbGxzID0gW107XG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLmVuY29kZVNldE5hbWVVcmkobmFtZSwgdXJpKTtcbiAgICAgICAgaWYgKHRoaXMucHVibGljQ2xpZW50KSB7XG4gICAgICAgICAgICBjb25zdCByZXNvbHZlciA9IHRoaXMuZ2V0RW5zUmVzb2x2ZXJBZGRyZXNzKCk7XG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICBjb25zdCBub2RlID0gbmFtZWhhc2gobmFtZSkgYXMgYDB4JHtzdHJpbmd9YDtcbiAgICAgICAgICAgICAgY29uc3QgcmVzb2x2ZXIgPSBhd2FpdCB0aGlzLi8vIEB0cy1pZ25vcmUgLSB2aWVtIHZlcnNpb24gY29tcGF0aWJpbGl0eSBpc3N1ZVxuICAgICAgICAgIHB1YmxpY0NsaWVudC5yZWFkQ29udHJhY3Qoe1xuICAgICAgICAgICAgICAgICAgYWRkcmVzczogdGhpcy5lbnNSZWdpc3RyeUFkZHJlc3MsXG4gICAgICAgICAgICAgICAgICBhYmk6IFt7IG5hbWU6IFwicmVzb2x2ZXJcIiwgc3RhdGVNdXRhYmlsaXR5OiBcInZpZXdcIiwgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBpbnB1dHM6IFt7IG5hbWU6IFwibm9kZVwiLCB0eXBlOiBcImJ5dGVzMzJcIn1dLCBvdXRwdXRzOiBbeyB0eXBlOiBcImFkZHJlc3NcIn1dfV0sXG4gICAgICAgICAgICAgICAgICBmdW5jdGlvbk5hbWU6IFwicmVzb2x2ZXJcIixcbiAgICAgICAgICAgICAgICAgIGFyZ3M6IFtub2RlXSxcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICovXG4gICAgICAgICAgICBjb25zb2xlLmluZm8oXCIrKysrKysrKysrKysrKysrKysrKyBwcmVwYXJlU2V0TmFtZVVyaUNhbGxzOiBjaGFpblwiLCB0aGlzLnB1YmxpY0NsaWVudD8uY2hhaW4/LmlkKTtcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhcIisrKysrKysrKysrKysrKysrKysrIHByZXBhcmVTZXROYW1lVXJpQ2FsbHM6IHJlc29sdmVyXCIsIHJlc29sdmVyKTtcbiAgICAgICAgICAgIGNhbGxzLnB1c2goeyB0bzogcmVzb2x2ZXIsIGRhdGE6IGRhdGEgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgY2FsbHMgfTtcbiAgICB9XG4gICAgYXN5bmMgcHJlcGFyZUFkZEFnZW50SW5mb0NhbGxzKHBhcmFtcykge1xuICAgICAgICByZXR1cm4geyBjYWxsczogW10gfTtcbiAgICB9XG4gICAgYXN5bmMgcHJlcGFyZVNldE5hbWVJbWFnZUNhbGxzKG5hbWUsIGltYWdlVXJsKSB7XG4gICAgICAgIGNvbnN0IGNhbGxzID0gW107XG4gICAgICAgIGNvbnN0IG5vZGUgPSBuYW1laGFzaChuYW1lKTtcbiAgICAgICAgY29uc3QgZGF0YSA9IGVuY29kZUZ1bmN0aW9uRGF0YSh7XG4gICAgICAgICAgICBhYmk6IFB1YmxpY1Jlc29sdmVyQUJJLmFiaSxcbiAgICAgICAgICAgIGZ1bmN0aW9uTmFtZTogJ3NldFRleHQnLFxuICAgICAgICAgICAgYXJnczogW25vZGUsIFwiYXZhdGFyXCIsIGltYWdlVXJsXVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHRoaXMucHVibGljQ2xpZW50KSB7XG4gICAgICAgICAgICBjb25zdCByZXNvbHZlciA9IHRoaXMuZ2V0RW5zUmVzb2x2ZXJBZGRyZXNzKCk7XG4gICAgICAgICAgICBjb25zb2xlLmluZm8oXCIrKysrKysrKysrKysrKysrKysrKyBwcmVwYXJlU2V0TmFtZUltYWdlQ2FsbHM6IGNoYWluXCIsIHRoaXMucHVibGljQ2xpZW50Py5jaGFpbj8uaWQpO1xuICAgICAgICAgICAgY29uc29sZS5pbmZvKFwiKysrKysrKysrKysrKysrKysrKysgcHJlcGFyZVNldE5hbWVJbWFnZUNhbGxzOiByZXNvbHZlclwiLCByZXNvbHZlcik7XG4gICAgICAgICAgICBjYWxscy5wdXNoKHsgdG86IHJlc29sdmVyLCBkYXRhOiBkYXRhIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGNhbGxzIH07XG4gICAgfVxuICAgIGFzeW5jIHByZXBhcmVTZXROYW1lRGVzY3JpcHRpb25DYWxscyhuYW1lLCBkZXNjcmlwdGlvbikge1xuICAgICAgICBjb25zdCBjYWxscyA9IFtdO1xuICAgICAgICBjb25zdCBub2RlID0gbmFtZWhhc2gobmFtZSk7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBlbmNvZGVGdW5jdGlvbkRhdGEoe1xuICAgICAgICAgICAgYWJpOiBQdWJsaWNSZXNvbHZlckFCSS5hYmksXG4gICAgICAgICAgICBmdW5jdGlvbk5hbWU6ICdzZXRUZXh0JyxcbiAgICAgICAgICAgIGFyZ3M6IFtub2RlLCBcImRlc2NyaXB0aW9uXCIsIGRlc2NyaXB0aW9uXVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHRoaXMucHVibGljQ2xpZW50KSB7XG4gICAgICAgICAgICBjb25zdCByZXNvbHZlciA9IHRoaXMuZ2V0RW5zUmVzb2x2ZXJBZGRyZXNzKCk7XG4gICAgICAgICAgICBjb25zb2xlLmluZm8oXCIrKysrKysrKysrKysrKysrKysrKyBwcmVwYXJlU2V0TmFtZURlc2NyaXB0aW9uQ2FsbHM6IGNoYWluXCIsIHRoaXMucHVibGljQ2xpZW50Py5jaGFpbj8uaWQpO1xuICAgICAgICAgICAgY29uc29sZS5pbmZvKFwiKysrKysrKysrKysrKysrKysrKysgcHJlcGFyZVNldE5hbWVEZXNjcmlwdGlvbkNhbGxzOiByZXNvbHZlclwiLCByZXNvbHZlcik7XG4gICAgICAgICAgICBjYWxscy5wdXNoKHsgdG86IHJlc29sdmVyLCBkYXRhOiBkYXRhIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGNhbGxzIH07XG4gICAgfVxuICAgIGFzeW5jIGVuY29kZVNldE5hbWVBZ2VudElkZW50aXR5KG5hbWUsIGFnZW50SWRlbnRpdHkpIHtcbiAgICAgICAgLy8gQnVpbGQgRVJDLTc5MzAgKGFwcHJveCkgYmluYXJ5OiBbdjE9MDFdW25zPWVpcDE1NT0wMV1bY2hhaW5JZCg0IGJ5dGVzKV1bYWRkcmVzcygyMCBieXRlcyldICsgW2xlbigxKV1bYWdlbnRJZCBieXRlc11cbiAgICAgICAgY29uc3QgY2hhaW5IZXggPSAodGhpcy5jaGFpbi5pZCA+Pj4gMCkudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDgsICcwJyk7XG4gICAgICAgIGNvbnN0IGFkZHJIZXggPSAodGhpcy5pZGVudGl0eVJlZ2lzdHJ5QWRkcmVzcykuc2xpY2UoMikudG9Mb3dlckNhc2UoKS5wYWRTdGFydCg0MCwgJzAnKTtcbiAgICAgICAgY29uc3QgaWRIZXggPSBhZ2VudElkZW50aXR5LnRvU3RyaW5nKDE2KTtcbiAgICAgICAgY29uc3QgaWRMZW4gPSBNYXRoLmNlaWwoaWRIZXgubGVuZ3RoIC8gMik7XG4gICAgICAgIGNvbnN0IGlkTGVuSGV4ID0gaWRMZW4udG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsICcwJyk7XG4gICAgICAgIGNvbnN0IHZhbHVlSGV4ID0gYDB4MDFgICsgYDAxYCArIGNoYWluSGV4ICsgYWRkckhleCArIGlkTGVuSGV4ICsgaWRIZXgucGFkU3RhcnQoaWRMZW4gKiAyLCAnMCcpO1xuICAgICAgICBjb25zdCBub2RlID0gbmFtZWhhc2gobmFtZSk7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBlbmNvZGVGdW5jdGlvbkRhdGEoe1xuICAgICAgICAgICAgYWJpOiBQdWJsaWNSZXNvbHZlckFCSS5hYmksXG4gICAgICAgICAgICBmdW5jdGlvbk5hbWU6ICdzZXRUZXh0JyxcbiAgICAgICAgICAgIGFyZ3M6IFtub2RlLCBcImFnZW50LWlkZW50aXR5XCIsIHZhbHVlSGV4XVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIGFzeW5jIHByZXBhcmVTZXROYW1lQWdlbnRJZGVudGl0eUNhbGxzKG5hbWUsIGFnZW50SWRlbnRpdHkpIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHRoaXMuZW5jb2RlU2V0TmFtZUFnZW50SWRlbnRpdHkobmFtZSwgYWdlbnRJZGVudGl0eSk7XG4gICAgICAgIGNvbnN0IGNhbGxzID0gW107XG4gICAgICAgIGlmICh0aGlzLnB1YmxpY0NsaWVudCkge1xuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IG5hbWVoYXNoKG5hbWUpO1xuICAgICAgICAgICAgY29uc3QgcmVzb2x2ZXIgPSBhd2FpdCB0aGlzLiAvLyBAdHMtaWdub3JlIC0gdmllbSB2ZXJzaW9uIGNvbXBhdGliaWxpdHkgaXNzdWVcbiAgICAgICAgICAgICAgICBwdWJsaWNDbGllbnQucmVhZENvbnRyYWN0KHtcbiAgICAgICAgICAgICAgICBhZGRyZXNzOiB0aGlzLmVuc1JlZ2lzdHJ5QWRkcmVzcyxcbiAgICAgICAgICAgICAgICBhYmk6IFt7IG5hbWU6IFwicmVzb2x2ZXJcIiwgc3RhdGVNdXRhYmlsaXR5OiBcInZpZXdcIiwgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRzOiBbeyBuYW1lOiBcIm5vZGVcIiwgdHlwZTogXCJieXRlczMyXCIgfV0sIG91dHB1dHM6IFt7IHR5cGU6IFwiYWRkcmVzc1wiIH1dIH1dLFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uTmFtZTogXCJyZXNvbHZlclwiLFxuICAgICAgICAgICAgICAgIGFyZ3M6IFtub2RlXSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2FsbHMucHVzaCh7IHRvOiByZXNvbHZlciwgZGF0YTogZGF0YSB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBjYWxscyB9O1xuICAgIH1cbiAgICBhc3luYyBpc1ZhbGlkQWdlbnRBY2NvdW50KGFnZW50QWNjb3VudCkge1xuICAgICAgICBpZiAodGhpcy5wdWJsaWNDbGllbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvZGUgPSBhd2FpdCB0aGlzLnB1YmxpY0NsaWVudC5nZXRCeXRlY29kZSh7IGFkZHJlc3M6IGFnZW50QWNjb3VudCB9KTtcbiAgICAgICAgICAgIHJldHVybiBjb2RlID8gdHJ1ZSA6IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVzb2x2ZSBhbiBhZ2VudCBieSBhY2NvdW50IGFkZHJlc3MgdmlhIEVOUyByZXZlcnNlICsgdGV4dCByZWNvcmQuXG4gICAgICogMSkgUmV2ZXJzZSByZXNvbHZlIGFkZHJlc3MgLT4gRU5TIG5hbWUgdmlhIEVOUyBSZWdpc3RyeSArIHJlc29sdmVyLm5hbWUoYnl0ZXMzMilcbiAgICAgKiAyKSBSZWFkIHJlc29sdmVyLnRleHQobm9kZSwgJ2FnZW50LWlkZW50aXR5JykgYW5kIGRlY29kZSBhZ2VudElkXG4gICAgICovXG4gICAgYXN5bmMgZ2V0QWdlbnRJZGVudGl0eUJ5QWNjb3VudChhY2NvdW50KSB7XG4gICAgICAgIGNvbnN0IGVuc1JlZ2lzdHJ5ID0gdGhpcy5lbnNSZWdpc3RyeUFkZHJlc3M7XG4gICAgICAgIGNvbnN0IGFjY291bnRMb3dlciA9IGFjY291bnQudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgLy8gTWluaW1hbCBBQklzXG4gICAgICAgIGNvbnN0IEVOU19SRUdJU1RSWV9BQkkgPSBbXG4gICAgICAgICAgICB7IG5hbWU6ICdyZXNvbHZlcicsIHR5cGU6ICdmdW5jdGlvbicsIHN0YXRlTXV0YWJpbGl0eTogJ3ZpZXcnLCBpbnB1dHM6IFt7IG5hbWU6ICdub2RlJywgdHlwZTogJ2J5dGVzMzInIH1dLCBvdXRwdXRzOiBbeyBuYW1lOiAnJywgdHlwZTogJ2FkZHJlc3MnIH1dIH0sXG4gICAgICAgIF07XG4gICAgICAgIGNvbnN0IFJFU09MVkVSX0FCSSA9IFtcbiAgICAgICAgICAgIHsgbmFtZTogJ25hbWUnLCB0eXBlOiAnZnVuY3Rpb24nLCBzdGF0ZU11dGFiaWxpdHk6ICd2aWV3JywgaW5wdXRzOiBbeyBuYW1lOiAnbm9kZScsIHR5cGU6ICdieXRlczMyJyB9XSwgb3V0cHV0czogW3sgbmFtZTogJycsIHR5cGU6ICdzdHJpbmcnIH1dIH0sXG4gICAgICAgICAgICB7IG5hbWU6ICd0ZXh0JywgdHlwZTogJ2Z1bmN0aW9uJywgc3RhdGVNdXRhYmlsaXR5OiAndmlldycsIGlucHV0czogW3sgbmFtZTogJ25vZGUnLCB0eXBlOiAnYnl0ZXMzMicgfSwgeyBuYW1lOiAna2V5JywgdHlwZTogJ3N0cmluZycgfV0sIG91dHB1dHM6IFt7IG5hbWU6ICcnLCB0eXBlOiAnc3RyaW5nJyB9XSB9LFxuICAgICAgICBdO1xuICAgICAgICBjb25zdCByZXZlcnNlTm9kZSA9IG5hbWVoYXNoKGAke2FjY291bnRMb3dlci5zbGljZSgyKX0uYWRkci5yZXZlcnNlYCk7XG4gICAgICAgIC8vIDEpIHJlc29sdmVyIGZvciByZXZlcnNlIG5vZGVcbiAgICAgICAgbGV0IHJlc29sdmVyQWRkciA9IG51bGw7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXNvbHZlckFkZHIgPSBhd2FpdCB0aGlzLmFjY291bnRQcm92aWRlci5jYWxsKHtcbiAgICAgICAgICAgICAgICB0bzogdGhpcy5lbnNSZWdpc3RyeUFkZHJlc3MsXG4gICAgICAgICAgICAgICAgYWJpOiBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3Jlc29sdmVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdmdW5jdGlvbicsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZU11dGFiaWxpdHk6ICd2aWV3JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0czogW3sgbmFtZTogJ25vZGUnLCB0eXBlOiAnYnl0ZXMzMicgfV0sXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRzOiBbeyBuYW1lOiAnJywgdHlwZTogJ2FkZHJlc3MnIH1dXG4gICAgICAgICAgICAgICAgICAgIH1dLFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uTmFtZTogJ3Jlc29sdmVyJyxcbiAgICAgICAgICAgICAgICBhcmdzOiBbcmV2ZXJzZU5vZGVdLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggeyB9XG4gICAgICAgIGlmICghcmVzb2x2ZXJBZGRyIHx8IHJlc29sdmVyQWRkciA9PT0gJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGFnZW50SWQ6IG51bGwsIGVuc05hbWU6IG51bGwgfTtcbiAgICAgICAgfVxuICAgICAgICAvLyAyKSByZXNvbHZlci5uYW1lIHRvIGdldCBFTlMgbmFtZVxuICAgICAgICBsZXQgZW5zTmFtZSA9IG51bGw7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBlbnNOYW1lID0gYXdhaXQgdGhpcy5hY2NvdW50UHJvdmlkZXIuY2FsbCh7XG4gICAgICAgICAgICAgICAgdG86IHJlc29sdmVyQWRkcixcbiAgICAgICAgICAgICAgICBhYmk6IFB1YmxpY1Jlc29sdmVyQUJJLmFiaSxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbk5hbWU6ICduYW1lJyxcbiAgICAgICAgICAgICAgICBhcmdzOiBbcmV2ZXJzZU5vZGVdLFxuICAgICAgICAgICAgfSkuY2F0Y2goKCkgPT4gbnVsbCk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGVuc05hbWUgIT09ICdzdHJpbmcnIHx8ICFlbnNOYW1lKVxuICAgICAgICAgICAgICAgIGVuc05hbWUgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIHsgfVxuICAgICAgICAvLyAzKSByZXNvbHZlci50ZXh0KG5vZGUsICdhZ2VudC1pZGVudGl0eScpIG9uIGZvcndhcmQgbm9kZSBpZiB3ZSBoYXZlIGEgbmFtZVxuICAgICAgICBsZXQgYWdlbnRJZCA9IG51bGw7XG4gICAgICAgIGlmIChlbnNOYW1lKSB7XG4gICAgICAgICAgICBjb25zdCBmb3J3YXJkTm9kZSA9IG5hbWVoYXNoKGVuc05hbWUpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGF3YWl0IHRoaXMuYWNjb3VudFByb3ZpZGVyLmNhbGwoe1xuICAgICAgICAgICAgICAgICAgICB0bzogcmVzb2x2ZXJBZGRyLFxuICAgICAgICAgICAgICAgICAgICBhYmk6IFB1YmxpY1Jlc29sdmVyQUJJLmFiaSxcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25OYW1lOiAndGV4dCcsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtmb3J3YXJkTm9kZSwgJ2FnZW50LWlkZW50aXR5J10sXG4gICAgICAgICAgICAgICAgfSkuY2F0Y2goKCkgPT4gbnVsbCk7XG4gICAgICAgICAgICAgICAgY29uc3QgZGVjb2RlZCA9IHRoaXMuZGVjb2RlQWdlbnRJZGVudGl0eSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgYWdlbnRJZCA9IGRlY29kZWQ/LmFnZW50SWQgPz8gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIHsgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGFnZW50SWQsIGVuc05hbWUgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVzb2x2ZSBhbiBhZ2VudCBieSBFTlMgbmFtZSB2aWEgcmVzb2x2ZXIudGV4dChuYW1laGFzaChuYW1lKSwgJ2FnZW50LWlkZW50aXR5JylcbiAgICAgKi9cbiAgICBhc3luYyBnZXRBZ2VudElkZW50aXR5QnlOYW1lKG5hbWUpIHtcbiAgICAgICAgbGV0IGVuc05hbWUgPSBuYW1lLnRyaW0oKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoIWVuc05hbWUpXG4gICAgICAgICAgICByZXR1cm4geyBhZ2VudElkOiBudWxsLCBhY2NvdW50OiBudWxsIH07XG4gICAgICAgIGVuc05hbWUgPSBlbnNOYW1lLmVuZHNXaXRoKCcuZXRoJykgPyBlbnNOYW1lLnNsaWNlKDAsIC00KSA6IGVuc05hbWU7XG4gICAgICAgIGVuc05hbWUgPSBlbnNOYW1lICsgJy5ldGgnO1xuICAgICAgICBjb25zdCBub2RlID0gbmFtZWhhc2goZW5zTmFtZSk7XG4gICAgICAgIC8vIHJlc29sdmVyXG4gICAgICAgIGxldCByZXNvbHZlckFkZHIgPSBudWxsO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzb2x2ZXJBZGRyID0gYXdhaXQgdGhpcy5hY2NvdW50UHJvdmlkZXIuY2FsbCh7XG4gICAgICAgICAgICAgICAgdG86IHRoaXMuZW5zUmVnaXN0cnlBZGRyZXNzLFxuICAgICAgICAgICAgICAgIGFiaTogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdyZXNvbHZlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnZnVuY3Rpb24nLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVNdXRhYmlsaXR5OiAndmlldycsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnB1dHM6IFt7IG5hbWU6ICdub2RlJywgdHlwZTogJ2J5dGVzMzInIH1dLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0czogW3sgbmFtZTogJycsIHR5cGU6ICdhZGRyZXNzJyB9XVxuICAgICAgICAgICAgICAgICAgICB9XSxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbk5hbWU6ICdyZXNvbHZlcicsXG4gICAgICAgICAgICAgICAgYXJnczogW25vZGVdLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyByZXR1cm5zIDB4RTk5NjM4YjQwRTRGZmYwMTI5RDU2ZjAzYjU1YjZiYkM0QkJFNDliNVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5pbmZvKFwiKysrKysrKysrKysrKysrKysrKysgZ2V0QWdlbnRJZGVudGl0eUJ5TmFtZSAxOiBlcnJvclwiLCBlcnJvcik7XG4gICAgICAgICAgICByZXR1cm4geyBhZ2VudElkOiBudWxsLCBhY2NvdW50OiBudWxsIH07IC8vIFJldHVybiBudWxsIGlmIHdlIGNhbid0IGdldCByZXNvbHZlclxuICAgICAgICB9XG4gICAgICAgIGlmICghcmVzb2x2ZXJBZGRyIHx8IHJlc29sdmVyQWRkciA9PT0gJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGFnZW50SWQ6IG51bGwsIGFjY291bnQ6IG51bGwgfTtcbiAgICAgICAgfVxuICAgICAgICAvLyBhZ2VudC1pZGVudGl0eSB0ZXh0XG4gICAgICAgIGxldCBhZ2VudElkID0gbnVsbDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgdGhpcy5hY2NvdW50UHJvdmlkZXIuY2FsbCh7XG4gICAgICAgICAgICAgICAgdG86IHJlc29sdmVyQWRkcixcbiAgICAgICAgICAgICAgICBhYmk6IFB1YmxpY1Jlc29sdmVyQUJJLmFiaSxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbk5hbWU6ICd0ZXh0JyxcbiAgICAgICAgICAgICAgICBhcmdzOiBbbm9kZSwgJ2FnZW50LWlkZW50aXR5J10sXG4gICAgICAgICAgICB9KS5jYXRjaCgoKSA9PiBudWxsKTtcbiAgICAgICAgICAgIC8vIEhhbmRsZSBlbXB0eSByZXNwb25zZVxuICAgICAgICAgICAgaWYgKCF2YWx1ZSB8fCB2YWx1ZSA9PT0gJzB4JyB8fCB2YWx1ZSA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmluZm8oXCIrKysrKysrKysrKysrKysrKysrKyBnZXRBZ2VudElkZW50aXR5QnlOYW1lOiBlbXB0eSBhZ2VudC1pZGVudGl0eSB0ZXh0IHJlY29yZFwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBhZ2VudElkOiBudWxsLCBhY2NvdW50OiBudWxsIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBkZWNvZGVkID0gdGhpcy5kZWNvZGVBZ2VudElkZW50aXR5KHZhbHVlKTtcbiAgICAgICAgICAgIGFnZW50SWQgPSBkZWNvZGVkPy5hZ2VudElkID8/IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmluZm8oXCIrKysrKysrKysrKysrKysrKysrKyBnZXRBZ2VudElkZW50aXR5QnlOYW1lIDI6IGVycm9yXCIsIGVycm9yKTtcbiAgICAgICAgICAgIHJldHVybiB7IGFnZW50SWQ6IG51bGwsIGFjY291bnQ6IG51bGwgfTsgLy8gUmV0dXJuIG51bGwgaWYgd2UgY2FuJ3QgZ2V0IHRoZSB0ZXh0IHJlY29yZFxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGFnZW50SWQsIGFjY291bnQ6IG51bGwgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgYW4gYWdlbnQgbmFtZSByZWNvcmQgYWxyZWFkeSBoYXMgYW4gb3duZXIgaW4gdGhlIEVOUyBSZWdpc3RyeS5cbiAgICAgKiBUaGlzIGRvZXNuJ3QgcmVxdWlyZSBhbiBhZGRyZXNzIHRvIGJlIHNldCwganVzdCBjaGVja3MgaWYgdGhlIHJlY29yZCBleGlzdHMuXG4gICAgICovXG4gICAgYXN5bmMgaGFzQWdlbnROYW1lT3duZXIob3JnTmFtZSwgYWdlbnROYW1lKSB7XG4gICAgICAgIGNvbnN0IGNsZWFuID0gKHMpID0+IChzIHx8ICcnKS50cmltKCkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgbGV0IHBhcmVudCA9IGNsZWFuKG9yZ05hbWUpO1xuICAgICAgICBwYXJlbnQgPSBwYXJlbnQuZW5kc1dpdGgoJy5ldGgnKSA/IHBhcmVudC5zbGljZSgwLCAtNCkgOiBwYXJlbnQ7XG4gICAgICAgIGNvbnN0IGxhYmVsID0gY2xlYW4oYWdlbnROYW1lKS5yZXBsYWNlKC9cXHMrL2csICctJyk7XG4gICAgICAgIGNvbnN0IGZ1bGxTdWJuYW1lID0gYCR7bGFiZWx9LiR7cGFyZW50fS5ldGhgO1xuICAgICAgICBjb25zdCBzdWJuYW1lTm9kZSA9IG5hbWVoYXNoKGZ1bGxTdWJuYW1lKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nT3duZXIgPSBhd2FpdCB0aGlzLmFjY291bnRQcm92aWRlci5jYWxsKHtcbiAgICAgICAgICAgICAgICB0bzogdGhpcy5lbnNSZWdpc3RyeUFkZHJlc3MsXG4gICAgICAgICAgICAgICAgYWJpOiBbeyBuYW1lOiAnb3duZXInLCB0eXBlOiAnZnVuY3Rpb24nLCBzdGF0ZU11dGFiaWxpdHk6ICd2aWV3JywgaW5wdXRzOiBbeyB0eXBlOiAnYnl0ZXMzMicgfV0sIG91dHB1dHM6IFt7IHR5cGU6ICdhZGRyZXNzJyB9XSB9XSxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbk5hbWU6ICdvd25lcicsXG4gICAgICAgICAgICAgICAgYXJnczogW3N1Ym5hbWVOb2RlXSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgaGFzT3duZXIgPSBCb29sZWFuKGV4aXN0aW5nT3duZXIgJiYgZXhpc3RpbmdPd25lciAhPT0gJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcpO1xuICAgICAgICAgICAgY29uc29sZS5pbmZvKGBoYXNBZ2VudE5hbWVPd25lcjogXCIke2Z1bGxTdWJuYW1lfVwiICR7aGFzT3duZXIgPyAnSEFTIG93bmVyJyA6ICdoYXMgTk8gb3duZXInfSR7aGFzT3duZXIgPyBgOiAke2V4aXN0aW5nT3duZXJ9YCA6ICcnfWApO1xuICAgICAgICAgICAgcmV0dXJuIGhhc093bmVyO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgY2hlY2tpbmcgYWdlbnQgbmFtZSBvd25lcjonLCBlcnJvcik7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVzb2x2ZSBhY2NvdW50IGFkZHJlc3MgZm9yIGFuIEVOUyBuYW1lIHZpYSByZXNvbHZlci5hZGRyKG5hbWVoYXNoKG5hbWUpKS5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRBZ2VudEFjY291bnRCeU5hbWUobmFtZSkge1xuICAgICAgICBsZXQgZW5zTmFtZSA9IG5hbWUudHJpbSgpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGVuc05hbWUgPSBlbnNOYW1lLmVuZHNXaXRoKCcuZXRoJykgPyBlbnNOYW1lLnNsaWNlKDAsIC00KSA6IGVuc05hbWU7XG4gICAgICAgIGVuc05hbWUgPSBgJHtlbnNOYW1lfS5ldGhgO1xuICAgICAgICBjb25zdCBub3JtYWxpemVkTmFtZSA9IG5vcm1hbGl6ZShlbnNOYW1lKTtcbiAgICAgICAgY29uc3Qgbm9kZSA9IG5hbWVoYXNoKG5vcm1hbGl6ZWROYW1lKTtcbiAgICAgICAgY29uc29sZS5sb2coJ1tBSUFnZW50RU5TQ2xpZW50LmdldEFnZW50QWNjb3VudEJ5TmFtZV0gY2hhaW46JywgdGhpcy5jaGFpbj8uaWQsIHRoaXMuY2hhaW4/Lm5hbWUpO1xuICAgICAgICBjb25zb2xlLmxvZygnW0FJQWdlbnRFTlNDbGllbnQuZ2V0QWdlbnRBY2NvdW50QnlOYW1lXSBub3JtYWxpemVkTmFtZTonLCBub3JtYWxpemVkTmFtZSk7XG4gICAgICAgIGNvbnNvbGUubG9nKCdbQUlBZ2VudEVOU0NsaWVudC5nZXRBZ2VudEFjY291bnRCeU5hbWVdIG5vZGU6Jywgbm9kZSk7XG4gICAgICAgIGNvbnNvbGUubG9nKCdbQUlBZ2VudEVOU0NsaWVudC5nZXRBZ2VudEFjY291bnRCeU5hbWVdIHJlc29sdmVyIGFkZHJlc3M6JywgdGhpcy5lbnNSZXNvbHZlckFkZHJlc3MpO1xuICAgICAgICBpZiAoIXRoaXMucHVibGljQ2xpZW50KSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ1tBSUFnZW50RU5TQ2xpZW50LmdldEFnZW50QWNjb3VudEJ5TmFtZV0gcHVibGljQ2xpZW50IG5vdCBpbml0aWFsaXplZCcpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIENhbGwgcmVzb2x2ZXIuYWRkcihuYW1laGFzaChuYW1lKSkgZGlyZWN0bHkgdXNpbmcgdGhlIGNvbmZpZ3VyZWQgcmVzb2x2ZXJcbiAgICAgICAgICAgIGNvbnN0IHJlc29sdmVyQWJpID0gW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgaW5wdXRzOiBbeyBpbnRlcm5hbFR5cGU6ICdieXRlczMyJywgbmFtZTogJ25vZGUnLCB0eXBlOiAnYnl0ZXMzMicgfV0sXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdhZGRyJyxcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0czogW3sgaW50ZXJuYWxUeXBlOiAnYWRkcmVzcycsIG5hbWU6ICdyZXQnLCB0eXBlOiAnYWRkcmVzcycgfV0sXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlTXV0YWJpbGl0eTogJ3ZpZXcnLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnZnVuY3Rpb24nLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgY29uc3QgYWRkciA9IGF3YWl0IHRoaXMucHVibGljQ2xpZW50LnJlYWRDb250cmFjdCh7XG4gICAgICAgICAgICAgICAgYWRkcmVzczogdGhpcy5lbnNSZXNvbHZlckFkZHJlc3MsXG4gICAgICAgICAgICAgICAgYWJpOiByZXNvbHZlckFiaSxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbk5hbWU6ICdhZGRyJyxcbiAgICAgICAgICAgICAgICBhcmdzOiBbbm9kZV0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGFkZHJTdHIgPSBhZGRyO1xuICAgICAgICAgICAgY29uc3QgaXNaZXJvID0gIWFkZHJTdHIgfHwgYWRkclN0ciA9PT0gJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCc7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnW0FJQWdlbnRFTlNDbGllbnQuZ2V0QWdlbnRBY2NvdW50QnlOYW1lXSByZXR1cm4gcmVzb2x2ZWQgYWRkcjonLCBhZGRyU3RyKTtcbiAgICAgICAgICAgIHJldHVybiBpc1plcm8gPyBudWxsIDogYWRkclN0cjtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1tBSUFnZW50RU5TQ2xpZW50LmdldEFnZW50QWNjb3VudEJ5TmFtZV0gRXJyb3IgcmVzb2x2aW5nIGFkZHI6JywgZXJyb3IpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLypcbiAgICBcbiAgICAgICAgICAgIGNvbnN0IHVuaXZlcnNhbFJlc29sdmVyQWJpID0gcGFyc2VBYmkoW1xuICAgICAgICAgICdlcnJvciBSZXNvbHZlck5vdEZvdW5kKGJ5dGVzIG5hbWUpJyxcbiAgICAgICAgICAnZXJyb3IgUmVzb2x2ZXJOb3RDb250cmFjdChieXRlcyBuYW1lLCBhZGRyZXNzIHJlc29sdmVyKScsXG4gICAgICAgICAgJ2Vycm9yIFVuc3VwcG9ydGVkUmVzb2x2ZXJQcm9maWxlKGJ5dGVzNCBzZWxlY3RvciknLFxuICAgICAgICAgICdlcnJvciBSZXNvbHZlckVycm9yKGJ5dGVzIGVycm9yRGF0YSknLFxuICAgICAgICAgICdlcnJvciBSZXZlcnNlQWRkcmVzc01pc21hdGNoKHN0cmluZyBwcmltYXJ5LCBieXRlcyBwcmltYXJ5QWRkcmVzcyknLFxuICAgICAgICAgICdlcnJvciBIdHRwRXJyb3IodWludDE2IHN0YXR1cywgc3RyaW5nIG1lc3NhZ2UpJyxcbiAgICAgICAgICAnZnVuY3Rpb24gcmVzb2x2ZShieXRlcyBuYW1lLCBieXRlcyBkYXRhKSB2aWV3IHJldHVybnMgKGJ5dGVzIHJlc3VsdCwgYWRkcmVzcyByZXNvbHZlciknLFxuICAgICAgICAgICdmdW5jdGlvbiByZXZlcnNlKGJ5dGVzIGxvb2t1cEFkZHJlc3MsIHVpbnQyNTYgY29pblR5cGUpIHZpZXcgcmV0dXJucyAoc3RyaW5nIHByaW1hcnksIGFkZHJlc3MgcmVzb2x2ZXIsIGFkZHJlc3MgcmV2ZXJzZVJlc29sdmVyKScsXG4gICAgICAgIF0pXG4gICAgXG4gICAgICAgIC8vIHVuaXZlcnNhbCByZXNvbHZlclxuICAgICAgICBjb25zdCByZXNvbHZlckFkZHI6IGAweCR7c3RyaW5nfWAgPSBcIjB4ZUVlRUVFZUUxNEQ3MThDMkI0N0Q5OTIzRGVhYjEzMzVFMTQ0RWVFZVwiO1xuICAgICAgICBcbiAgICBcbiAgICAgICAgdHJ5IHtcbiAgICBcbiAgICBcbiAgICAgICAgICAvLyBjb25zdHJ1Y3QgZGF0YSByZWFkXG4gICAgICAgICAgY29uc3Qgc2ltcGxlUmVzb2x2ZXJBYmkxID0gcGFyc2VBYmkoW1xuICAgICAgICAgICAgJ2Z1bmN0aW9uIGFkZHIoYnl0ZXMzMiBub2RlKSB2aWV3IHJldHVybnMgKGFkZHJlc3MpJyxcbiAgICAgICAgICAgICdmdW5jdGlvbiB0ZXh0KGJ5dGVzMzIgbm9kZSwgc3RyaW5nIGtleSkgdmlldyByZXR1cm5zIChzdHJpbmcpJyxcbiAgICAgICAgICBdKVxuICAgICAgICAgICBcbiAgICAgICAgICBjb25zdCBtdWx0aWNhbGxBYmkgPSBwYXJzZUFiaShbXG4gICAgICAgICAgICAnZnVuY3Rpb24gbXVsdGljYWxsKGJ5dGVzW10gZGF0YSkgcmV0dXJucyAoYnl0ZXNbXSByZXN1bHRzKScsXG4gICAgICAgICAgXSlcbiAgICAgICAgICAgXG4gICAgICAgICAgY29uc3QgbmFtZSA9IG5vcm1hbGl6ZShlbnNOYW1lKVxuICAgICAgICAgIGNvbnN0IG5vZGUxID0gbmFtZWhhc2gobmFtZSlcbiAgICAgICAgICAgXG4gICAgICAgICAgY29uc3QgcmVzb2x2ZXJDYWxsczEgPSBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGFiaTogc2ltcGxlUmVzb2x2ZXJBYmkxLFxuICAgICAgICAgICAgICBmdW5jdGlvbk5hbWU6ICdhZGRyJyxcbiAgICAgICAgICAgICAgYXJnczogW25vZGUxXSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGFiaTogc2ltcGxlUmVzb2x2ZXJBYmkxLFxuICAgICAgICAgICAgICBmdW5jdGlvbk5hbWU6ICd0ZXh0JyxcbiAgICAgICAgICAgICAgYXJnczogW25vZGUxLCAnZGVzY3JpcHRpb24nXSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgXSBhcyBjb25zdFxuICAgICAgICAgICBcbiAgICAgICAgICBjb25zdCBkYXRhID0gZW5jb2RlRnVuY3Rpb25EYXRhKHtcbiAgICAgICAgICAgIGFiaTogbXVsdGljYWxsQWJpLFxuICAgICAgICAgICAgZnVuY3Rpb25OYW1lOiAnbXVsdGljYWxsJyxcbiAgICAgICAgICAgIGFyZ3M6IFtyZXNvbHZlckNhbGxzMS5tYXAoKGNhbGwpID0+IGVuY29kZUZ1bmN0aW9uRGF0YShjYWxsKSldLFxuICAgICAgICAgIH0pXG4gICAgIFxuICAgICAgICAgIGNvbnN0IHVuaXZlcnNhbFJlc29sdmVyQWJpID0gcGFyc2VBYmkoW1xuICAgICAgICAgICAgJ2Vycm9yIFJlc29sdmVyTm90Rm91bmQoYnl0ZXMgbmFtZSknLFxuICAgICAgICAgICAgJ2Vycm9yIFJlc29sdmVyTm90Q29udHJhY3QoYnl0ZXMgbmFtZSwgYWRkcmVzcyByZXNvbHZlciknLFxuICAgICAgICAgICAgJ2Vycm9yIFVuc3VwcG9ydGVkUmVzb2x2ZXJQcm9maWxlKGJ5dGVzNCBzZWxlY3RvciknLFxuICAgICAgICAgICAgJ2Vycm9yIFJlc29sdmVyRXJyb3IoYnl0ZXMgZXJyb3JEYXRhKScsXG4gICAgICAgICAgICAnZXJyb3IgUmV2ZXJzZUFkZHJlc3NNaXNtYXRjaChzdHJpbmcgcHJpbWFyeSwgYnl0ZXMgcHJpbWFyeUFkZHJlc3MpJyxcbiAgICAgICAgICAgICdlcnJvciBIdHRwRXJyb3IodWludDE2IHN0YXR1cywgc3RyaW5nIG1lc3NhZ2UpJyxcbiAgICAgICAgICAgICdmdW5jdGlvbiByZXNvbHZlKGJ5dGVzIG5hbWUsIGJ5dGVzIGRhdGEpIHZpZXcgcmV0dXJucyAoYnl0ZXMgcmVzdWx0LCBhZGRyZXNzIHJlc29sdmVyKScsXG4gICAgICAgICAgICAnZnVuY3Rpb24gcmV2ZXJzZShieXRlcyBsb29rdXBBZGRyZXNzLCB1aW50MjU2IGNvaW5UeXBlKSB2aWV3IHJldHVybnMgKHN0cmluZyBwcmltYXJ5LCBhZGRyZXNzIHJlc29sdmVyLCBhZGRyZXNzIHJldmVyc2VSZXNvbHZlciknLFxuICAgICAgICAgIF0pXG4gICAgICAgICAgXG4gICAgICAgICAgY29uc29sZS5pbmZvKCcqKioqKioqKioqKiB6enogZ2V0QWdlbnRBY2NvdW50QnlOYW1lIGNoYWluIGlkJywgYXdhaXQgdGhpcy5wdWJsaWNDbGllbnQ/LmdldENoYWluSWQoKSk7XG4gICAgICAgICAgXG4gICAgXG4gICAgICAgICAgY29uc3QgZG5zRW5jb2RlZE5hbWUgPSB0b0hleChwYWNrZXRUb0J5dGVzKG5hbWUpKVxuICAgIFxuICAgICAgICAgIGNvbnN0IHJlc29sdmVSZXMgPSBhd2FpdCB0aGlzLnB1YmxpY0NsaWVudD8ucmVhZENvbnRyYWN0KHtcbiAgICAgICAgICAgIGFiaTogdW5pdmVyc2FsUmVzb2x2ZXJBYmksXG4gICAgICAgICAgICBhZGRyZXNzOiAnMHhlRWVFRUVlRTE0RDcxOEMyQjQ3RDk5MjNEZWFiMTMzNUUxNDRFZUVlJyxcbiAgICAgICAgICAgIGZ1bmN0aW9uTmFtZTogJ3Jlc29sdmUnLFxuICAgICAgICAgICAgYXJnczogW2Ruc0VuY29kZWROYW1lLCBkYXRhXSxcbiAgICAgICAgICB9KVxuICAgICAgICAgIFxuICAgICAgICAgIGlmICghcmVzb2x2ZVJlcykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgIFxuICAgICAgICAgIGNvbnN0IGRlY29kZWRNdWx0aWNhbGwgPSBkZWNvZGVGdW5jdGlvblJlc3VsdCh7XG4gICAgICAgICAgICBhYmk6IG11bHRpY2FsbEFiaSxcbiAgICAgICAgICAgIGZ1bmN0aW9uTmFtZTogJ211bHRpY2FsbCcsXG4gICAgICAgICAgICBkYXRhOiByZXNvbHZlUmVzWzBdIGFzIGAweCR7c3RyaW5nfWAsXG4gICAgICAgICAgfSkgYXMgYDB4JHtzdHJpbmd9YFtdO1xuICAgICAgICAgIFxuICAgICAgICAgIGNvbnNvbGUubG9nKCcqKioqKioqKioqKiB6enogZ2V0QWdlbnRBY2NvdW50QnlOYW1lIGRlY29kZWRNdWx0aWNhbGwnLCBkZWNvZGVkTXVsdGljYWxsKTtcbiAgICAgICAgICBjb25zdCBkZWNvZGVkUmVzID0gKGRlY29kZWRNdWx0aWNhbGwgfHwgW10pLm1hcCgocmVzLCBpKSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnKioqKioqKioqKiogenp6IGdldEFnZW50QWNjb3VudEJ5TmFtZSByZXMnLCByZXMpO1xuICAgICAgICAgICAgY29uc3QgY2FsbCA9IHJlc29sdmVyQ2FsbHMxW2ldO1xuICAgICAgICAgICAgaWYgKCFjYWxsKSB7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZm4gPSAoY2FsbC5mdW5jdGlvbk5hbWUgPT09ICdhZGRyJyA/ICdhZGRyJyA6ICd0ZXh0JykgYXMgJ2FkZHInIHwgJ3RleHQnO1xuICAgICAgICAgICAgY29uc29sZS5sb2coJyoqKioqKioqKioqIHp6eiBnZXRBZ2VudEFjY291bnRCeU5hbWUgZm4nLCBmbik7XG4gICAgICAgICAgICByZXR1cm4gZGVjb2RlRnVuY3Rpb25SZXN1bHQoe1xuICAgICAgICAgICAgICBhYmk6IHNpbXBsZVJlc29sdmVyQWJpMSxcbiAgICAgICAgICAgICAgZnVuY3Rpb25OYW1lOiBmbixcbiAgICAgICAgICAgICAgZGF0YTogcmVzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSkuZmlsdGVyKEJvb2xlYW4pXG4gICAgXG4gICAgXG4gICAgXG4gICAgXG4gICAgXG4gICAgXG4gICAgXG4gICAgXG4gICAgXG4gICAgXG4gICAgXG4gICAgXG4gICAgXG4gICAgXG4gICAgXG4gICAgXG4gICAgICAgICAgY29uc3Qgc2ltcGxlUmVzb2x2ZXJBYmkgPSBwYXJzZUFiaShbXG4gICAgICAgICAgICAnZnVuY3Rpb24gYWRkcihieXRlczMyIG5vZGUpIHZpZXcgcmV0dXJucyAoYWRkcmVzcyknLFxuICAgICAgICAgICAgJ2Z1bmN0aW9uIHRleHQoYnl0ZXMzMiBub2RlLCBzdHJpbmcga2V5KSB2aWV3IHJldHVybnMgKHN0cmluZyknLFxuICAgICAgICAgIF0pXG4gICAgICAgICAgIFxuICAgICAgICAgIGNvbnNvbGUubG9nKCcqKioqKioqKioqKiB6enogZ2V0QWdlbnRBY2NvdW50QnlOYW1lIGVuc05hbWUnLCBlbnNOYW1lKTtcbiAgICAgICAgICBjb25zdCBuYW1lID0gbm9ybWFsaXplKGVuc05hbWUpO1xuICAgICAgICAgIGNvbnNvbGUubG9nKCcqKioqKioqKioqKiB6enogZ2V0QWdlbnRBY2NvdW50QnlOYW1lIG5vcm1hbGl6ZWQgbmFtZScsIG5hbWUpO1xuICAgICAgICAgIGNvbnN0IG5vZGUgPSBuYW1laGFzaChuYW1lKTtcbiAgICBcbiAgICAgICAgICAvLyBETlMgd2lyZS1mb3JtYXQgZW5jb2RlIG9mIHRoZSBFTlMgbmFtZSBmb3IgVW5pdmVyc2FsIFJlc29sdmVyICh1c2Ugbm9ybWFsaXplZCBmb3JtKVxuICAgICAgICAgIGNvbnN0IGRuc0VuY29kZWROYW1lID0gdG9IZXgocGFja2V0VG9CeXRlcyhuYW1lKSk7XG4gICAgXG4gICAgICAgICAgLy8gUmVzb2x2ZSBhZGRyKG5hbWUpIHZpYSBVbml2ZXJzYWwgUmVzb2x2ZXJcbiAgICAgICAgICBjb25zdCBhZGRyQ2FsbERhdGEgPSBlbmNvZGVGdW5jdGlvbkRhdGEoe1xuICAgICAgICAgICAgYWJpOiBzaW1wbGVSZXNvbHZlckFiaSxcbiAgICAgICAgICAgIGZ1bmN0aW9uTmFtZTogJ2FkZHInLFxuICAgICAgICAgICAgYXJnczogW25vZGVdLFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGNvbnN0IGFkZHJSZXNvbHZlID0gYXdhaXQgdGhpcy5wdWJsaWNDbGllbnQ/LnJlYWRDb250cmFjdCh7XG4gICAgICAgICAgICBhZGRyZXNzOiByZXNvbHZlckFkZHIsXG4gICAgICAgICAgICBhYmk6IHVuaXZlcnNhbFJlc29sdmVyQWJpLFxuICAgICAgICAgICAgZnVuY3Rpb25OYW1lOiAncmVzb2x2ZScsXG4gICAgICAgICAgICBhcmdzOiBbZG5zRW5jb2RlZE5hbWUsIGFkZHJDYWxsRGF0YV0sXG4gICAgICAgICAgfSkuY2F0Y2goKCkgPT4gbnVsbCkgYXMgcmVhZG9ubHkgW2AweCR7c3RyaW5nfWAsIGAweCR7c3RyaW5nfWBdIHwgbnVsbDtcbiAgICBcbiAgICAgICAgICBjb25zb2xlLmxvZygnKioqKioqKioqKiogenp6IGdldEFnZW50QWNjb3VudEJ5TmFtZSBhZGRyUmVzb2x2ZScsIGFkZHJSZXNvbHZlKTtcbiAgICAgICAgICBsZXQgYWRkckZyb21SZXNvbHZlcjogc3RyaW5nIHwgbnVsbCA9IG51bGw7XG4gICAgICAgICAgaWYgKGFkZHJSZXNvbHZlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnKioqKioqKioqKiogenp6IGdldEFnZW50QWNjb3VudEJ5TmFtZSBhZGRyUmVzb2x2ZVswXScsIGFkZHJSZXNvbHZlWzBdKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGNvbnN0IGRlY29kZWQgPSBkZWNvZGVGdW5jdGlvblJlc3VsdCh7XG4gICAgICAgICAgICAgICAgYWJpOiBzaW1wbGVSZXNvbHZlckFiaSxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbk5hbWU6ICdhZGRyJyxcbiAgICAgICAgICAgICAgICBkYXRhOiBhZGRyUmVzb2x2ZVswXSxcbiAgICAgICAgICAgICAgfSkgYXMgc3RyaW5nO1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZygnKioqKioqKioqKiogenp6IGdldEFnZW50QWNjb3VudEJ5TmFtZSBkZWNvZGVkJywgZGVjb2RlZCk7XG4gICAgICAgICAgICAgIGFkZHJGcm9tUmVzb2x2ZXIgPSBkZWNvZGVkID8/IG51bGw7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlVuaXZlcnNhbFJlc29sdmVyIGRlY29kZSBhZGRyIGZhaWxlZFwiLCBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgLy8gQmVzdC1lZmZvcnQ6IHJlc29sdmUgdGV4dChuYW1lLCdkZXNjcmlwdGlvbicpIGZvciBtZXRhZGF0YSAobm9uLWJsb2NraW5nKVxuICAgICAgICAgIGNvbnN0IHRleHRDYWxsRGF0YSA9IGVuY29kZUZ1bmN0aW9uRGF0YSh7XG4gICAgICAgICAgICBhYmk6IHNpbXBsZVJlc29sdmVyQWJpLFxuICAgICAgICAgICAgZnVuY3Rpb25OYW1lOiAndGV4dCcsXG4gICAgICAgICAgICBhcmdzOiBbbm9kZSwgJ2Rlc2NyaXB0aW9uJ10sXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgY29uc3QgdGV4dFJlc29sdmUgPSBhd2FpdCB0aGlzLnB1YmxpY0NsaWVudD8ucmVhZENvbnRyYWN0KHtcbiAgICAgICAgICAgIGFkZHJlc3M6IHJlc29sdmVyQWRkcixcbiAgICAgICAgICAgIGFiaTogdW5pdmVyc2FsUmVzb2x2ZXJBYmksXG4gICAgICAgICAgICBmdW5jdGlvbk5hbWU6ICdyZXNvbHZlJyxcbiAgICAgICAgICAgIGFyZ3M6IFtkbnNFbmNvZGVkTmFtZSwgdGV4dENhbGxEYXRhXSxcbiAgICAgICAgICB9KS5jYXRjaCgoKSA9PiBudWxsKTtcbiAgICBcbiAgICAgICAgICBpZiAodGV4dFJlc29sdmUpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGNvbnN0IHRleHREZWNvZGVkID0gZGVjb2RlRnVuY3Rpb25SZXN1bHQoe1xuICAgICAgICAgICAgICAgIGFiaTogc2ltcGxlUmVzb2x2ZXJBYmksXG4gICAgICAgICAgICAgICAgZnVuY3Rpb25OYW1lOiAndGV4dCcsXG4gICAgICAgICAgICAgICAgZGF0YTogdGV4dFJlc29sdmVbMF0gYXMgYDB4JHtzdHJpbmd9YCxcbiAgICAgICAgICAgICAgfSkgYXMgc3RyaW5nO1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZygnKioqKioqKioqKiogenp6IGdldEFnZW50QWNjb3VudEJ5TmFtZSBkZXNjcmlwdGlvbiB0ZXh0JywgdGV4dERlY29kZWQpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1VuaXZlcnNhbFJlc29sdmVyIGRlY29kZSB0ZXh0KGRlc2NyaXB0aW9uKSBmYWlsZWQnLCBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgY29uc3QgYWRkciA9IGFkZHJGcm9tUmVzb2x2ZXI7XG4gICAgICAgICAgaWYgKGFkZHIgJiYgL14weFthLWZBLUYwLTldezQwfSQvLnRlc3QoYWRkcikgJiYgYWRkciAhPT0gJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcpIHtcbiAgICAgICAgICAgIHJldHVybiBhZGRyIGFzIGAweCR7c3RyaW5nfWA7XG4gICAgICAgICAgfVxuICAgICAgICAgXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGdldHRpbmcgYWdlbnQgYWNjb3VudCBieSBuYW1lOiBcIiwgZXJyb3IpO1xuICAgICAgICB9XG4gICAgXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAqL1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIEFnZW50IFVSTCB2aWEgRU5TIHRleHQgcmVjb3JkIGZvciBhIGdpdmVuIEVOUyBuYW1lLlxuICAgICAqL1xuICAgIGFzeW5jIGdldEFnZW50VXJsQnlOYW1lKG5hbWUpIHtcbiAgICAgICAgY29uc3QgZW5zTmFtZSA9IG5hbWUudHJpbSgpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmICghZW5zTmFtZSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBjb25zdCBFTlNfUkVHSVNUUllfQUJJID0gW1xuICAgICAgICAgICAgeyBuYW1lOiAncmVzb2x2ZXInLCB0eXBlOiAnZnVuY3Rpb24nLCBzdGF0ZU11dGFiaWxpdHk6ICd2aWV3JywgaW5wdXRzOiBbeyBuYW1lOiAnbm9kZScsIHR5cGU6ICdieXRlczMyJyB9XSwgb3V0cHV0czogW3sgbmFtZTogJycsIHR5cGU6ICdhZGRyZXNzJyB9XSB9LFxuICAgICAgICBdO1xuICAgICAgICBjb25zdCBSRVNPTFZFUl9BQkkgPSBbXG4gICAgICAgICAgICB7IG5hbWU6ICd0ZXh0JywgdHlwZTogJ2Z1bmN0aW9uJywgc3RhdGVNdXRhYmlsaXR5OiAndmlldycsIGlucHV0czogW3sgbmFtZTogJ25vZGUnLCB0eXBlOiAnYnl0ZXMzMicgfSwgeyBuYW1lOiAna2V5JywgdHlwZTogJ3N0cmluZycgfV0sIG91dHB1dHM6IFt7IG5hbWU6ICcnLCB0eXBlOiAnc3RyaW5nJyB9XSB9LFxuICAgICAgICBdO1xuICAgICAgICBjb25zdCBub2RlID0gbmFtZWhhc2goZW5zTmFtZSk7XG4gICAgICAgIC8vIHJlc29sdmVyXG4gICAgICAgIGxldCByZXNvbHZlckFkZHIgPSBudWxsO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzb2x2ZXJBZGRyID0gYXdhaXQgdGhpcy5hY2NvdW50UHJvdmlkZXIuY2FsbCh7XG4gICAgICAgICAgICAgICAgdG86IHRoaXMuZW5zUmVnaXN0cnlBZGRyZXNzLFxuICAgICAgICAgICAgICAgIGFiaTogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdyZXNvbHZlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnZnVuY3Rpb24nLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVNdXRhYmlsaXR5OiAndmlldycsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnB1dHM6IFt7IG5hbWU6ICdub2RlJywgdHlwZTogJ2J5dGVzMzInIH1dLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0czogW3sgbmFtZTogJycsIHR5cGU6ICdhZGRyZXNzJyB9XVxuICAgICAgICAgICAgICAgICAgICB9XSxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbk5hbWU6ICdyZXNvbHZlcicsXG4gICAgICAgICAgICAgICAgYXJnczogW25vZGVdLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyByZXR1cm5zIDB4RTk5NjM4YjQwRTRGZmYwMTI5RDU2ZjAzYjU1YjZiYkM0QkJFNDliNVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIHsgfVxuICAgICAgICBpZiAoIXJlc29sdmVyQWRkciB8fCByZXNvbHZlckFkZHIgPT09ICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgdXJsID0gYXdhaXQgdGhpcy5hY2NvdW50UHJvdmlkZXIuY2FsbCh7XG4gICAgICAgICAgICAgICAgdG86IHJlc29sdmVyQWRkcixcbiAgICAgICAgICAgICAgICBhYmk6IFB1YmxpY1Jlc29sdmVyQUJJLmFiaSxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbk5hbWU6ICd0ZXh0JyxcbiAgICAgICAgICAgICAgICBhcmdzOiBbbm9kZSwgJ3VybCddLFxuICAgICAgICAgICAgfSkuY2F0Y2goKCkgPT4gbnVsbCk7XG4gICAgICAgICAgICBjb25zdCB0cmltbWVkID0gKHVybCB8fCAnJykudHJpbSgpO1xuICAgICAgICAgICAgcmV0dXJuIHRyaW1tZWQubGVuZ3RoID4gMCA/IHRyaW1tZWQgOiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgQWdlbnQgQXZhdGFyL0ltYWdlIHZpYSBFTlMgdGV4dCByZWNvcmQgZm9yIGEgZ2l2ZW4gRU5TIG5hbWUuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0QWdlbnRJbWFnZUJ5TmFtZShuYW1lKSB7XG4gICAgICAgIGNvbnN0IGVuc05hbWUgPSBuYW1lLnRyaW0oKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoIWVuc05hbWUpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgY29uc3Qgbm9kZSA9IG5hbWVoYXNoKGVuc05hbWUpO1xuICAgICAgICAvLyByZXNvbHZlclxuICAgICAgICBsZXQgcmVzb2x2ZXJBZGRyID0gbnVsbDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc29sdmVyQWRkciA9IGF3YWl0IHRoaXMuYWNjb3VudFByb3ZpZGVyLmNhbGwoe1xuICAgICAgICAgICAgICAgIHRvOiB0aGlzLmVuc1JlZ2lzdHJ5QWRkcmVzcyxcbiAgICAgICAgICAgICAgICBhYmk6IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAncmVzb2x2ZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2Z1bmN0aW9uJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlTXV0YWJpbGl0eTogJ3ZpZXcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRzOiBbeyBuYW1lOiAnbm9kZScsIHR5cGU6ICdieXRlczMyJyB9XSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dHM6IFt7IG5hbWU6ICcnLCB0eXBlOiAnYWRkcmVzcycgfV1cbiAgICAgICAgICAgICAgICAgICAgfV0sXG4gICAgICAgICAgICAgICAgZnVuY3Rpb25OYW1lOiAncmVzb2x2ZXInLFxuICAgICAgICAgICAgICAgIGFyZ3M6IFtub2RlXSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIHsgfVxuICAgICAgICBpZiAoIXJlc29sdmVyQWRkciB8fCByZXNvbHZlckFkZHIgPT09ICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgaW1hZ2UgPSBhd2FpdCB0aGlzLmFjY291bnRQcm92aWRlci5jYWxsKHtcbiAgICAgICAgICAgICAgICB0bzogcmVzb2x2ZXJBZGRyLFxuICAgICAgICAgICAgICAgIGFiaTogUHVibGljUmVzb2x2ZXJBQkkuYWJpLFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uTmFtZTogJ3RleHQnLFxuICAgICAgICAgICAgICAgIGFyZ3M6IFtub2RlLCAnYXZhdGFyJ10sXG4gICAgICAgICAgICB9KS5jYXRjaCgoKSA9PiBudWxsKTtcbiAgICAgICAgICAgIGNvbnN0IHRyaW1tZWQgPSAoaW1hZ2UgfHwgJycpLnRyaW0oKTtcbiAgICAgICAgICAgIHJldHVybiB0cmltbWVkLmxlbmd0aCA+IDAgPyB0cmltbWVkIDogbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIEFnZW50IERlc2NyaXB0aW9uIHZpYSBFTlMgdGV4dCByZWNvcmQgZm9yIGEgZ2l2ZW4gRU5TIG5hbWUuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0QWdlbnREZXNjcmlwdGlvbkJ5TmFtZShuYW1lKSB7XG4gICAgICAgIGNvbnN0IGVuc05hbWUgPSBuYW1lLnRyaW0oKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoIWVuc05hbWUpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgY29uc3Qgbm9kZSA9IG5hbWVoYXNoKGVuc05hbWUpO1xuICAgICAgICAvLyByZXNvbHZlclxuICAgICAgICBsZXQgcmVzb2x2ZXJBZGRyID0gbnVsbDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc29sdmVyQWRkciA9IGF3YWl0IHRoaXMuYWNjb3VudFByb3ZpZGVyLmNhbGwoe1xuICAgICAgICAgICAgICAgIHRvOiB0aGlzLmVuc1JlZ2lzdHJ5QWRkcmVzcyxcbiAgICAgICAgICAgICAgICBhYmk6IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAncmVzb2x2ZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2Z1bmN0aW9uJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlTXV0YWJpbGl0eTogJ3ZpZXcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRzOiBbeyBuYW1lOiAnbm9kZScsIHR5cGU6ICdieXRlczMyJyB9XSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dHM6IFt7IG5hbWU6ICcnLCB0eXBlOiAnYWRkcmVzcycgfV1cbiAgICAgICAgICAgICAgICAgICAgfV0sXG4gICAgICAgICAgICAgICAgZnVuY3Rpb25OYW1lOiAncmVzb2x2ZXInLFxuICAgICAgICAgICAgICAgIGFyZ3M6IFtub2RlXSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIHsgfVxuICAgICAgICBpZiAoIXJlc29sdmVyQWRkciB8fCByZXNvbHZlckFkZHIgPT09ICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgZGVzY3JpcHRpb24gPSBhd2FpdCB0aGlzLmFjY291bnRQcm92aWRlci5jYWxsKHtcbiAgICAgICAgICAgICAgICB0bzogcmVzb2x2ZXJBZGRyLFxuICAgICAgICAgICAgICAgIGFiaTogUHVibGljUmVzb2x2ZXJBQkkuYWJpLFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uTmFtZTogJ3RleHQnLFxuICAgICAgICAgICAgICAgIGFyZ3M6IFtub2RlLCAnZGVzY3JpcHRpb24nXSxcbiAgICAgICAgICAgIH0pLmNhdGNoKCgpID0+IG51bGwpO1xuICAgICAgICAgICAgY29uc3QgdHJpbW1lZCA9IChkZXNjcmlwdGlvbiB8fCAnJykudHJpbSgpO1xuICAgICAgICAgICAgcmV0dXJuIHRyaW1tZWQubGVuZ3RoID4gMCA/IHRyaW1tZWQgOiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldmVyc2UgbG9va3VwOiBhY2NvdW50IGFkZHJlc3MgLT4gRU5TIG5hbWUgdmlhIHJlc29sdmVyLm5hbWUocmV2ZXJzZU5vZGUpXG4gICAgICovXG4gICAgYXN5bmMgZ2V0QWdlbnROYW1lQnlBY2NvdW50KGFjY291bnQpIHtcbiAgICAgICAgY29uc3QgZW5zUmVnaXN0cnkgPSB0aGlzLmVuc1JlZ2lzdHJ5QWRkcmVzcztcbiAgICAgICAgY29uc3QgYWNjb3VudExvd2VyID0gYWNjb3VudC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBjb25zdCBFTlNfUkVHSVNUUllfQUJJID0gW1xuICAgICAgICAgICAgeyBuYW1lOiAncmVzb2x2ZXInLCB0eXBlOiAnZnVuY3Rpb24nLCBzdGF0ZU11dGFiaWxpdHk6ICd2aWV3JywgaW5wdXRzOiBbeyBuYW1lOiAnbm9kZScsIHR5cGU6ICdieXRlczMyJyB9XSwgb3V0cHV0czogW3sgbmFtZTogJycsIHR5cGU6ICdhZGRyZXNzJyB9XSB9LFxuICAgICAgICBdO1xuICAgICAgICBjb25zdCBSRVNPTFZFUl9BQkkgPSBbXG4gICAgICAgICAgICB7IG5hbWU6ICduYW1lJywgdHlwZTogJ2Z1bmN0aW9uJywgc3RhdGVNdXRhYmlsaXR5OiAndmlldycsIGlucHV0czogW3sgbmFtZTogJ25vZGUnLCB0eXBlOiAnYnl0ZXMzMicgfV0sIG91dHB1dHM6IFt7IG5hbWU6ICcnLCB0eXBlOiAnc3RyaW5nJyB9XSB9LFxuICAgICAgICBdO1xuICAgICAgICBjb25zdCByZXZlcnNlTm9kZSA9IG5hbWVoYXNoKGAke2FjY291bnRMb3dlci5zbGljZSgyKX0uYWRkci5yZXZlcnNlYCk7XG4gICAgICAgIC8vIHJlc29sdmVyIGZvciByZXZlcnNlIG5vZGVcbiAgICAgICAgbGV0IHJlc29sdmVyQWRkciA9IG51bGw7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlIC0gdmllbSB2ZXJzaW9uIGNvbXBhdGliaWxpdHkgaXNzdWVcbiAgICAgICAgICAgIHJlc29sdmVyQWRkciA9IGF3YWl0IHRoaXMucHVibGljQ2xpZW50Py5yZWFkQ29udHJhY3Qoe1xuICAgICAgICAgICAgICAgIGFkZHJlc3M6IHRoaXMuZW5zUmVnaXN0cnlBZGRyZXNzLFxuICAgICAgICAgICAgICAgIGFiaTogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdyZXNvbHZlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnZnVuY3Rpb24nLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVNdXRhYmlsaXR5OiAndmlldycsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnB1dHM6IFt7IG5hbWU6ICdub2RlJywgdHlwZTogJ2J5dGVzMzInIH1dLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0czogW3sgbmFtZTogJycsIHR5cGU6ICdhZGRyZXNzJyB9XVxuICAgICAgICAgICAgICAgICAgICB9XSxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbk5hbWU6ICdyZXNvbHZlcicsXG4gICAgICAgICAgICAgICAgYXJnczogW3JldmVyc2VOb2RlXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggeyB9XG4gICAgICAgIGlmICghcmVzb2x2ZXJBZGRyIHx8IHJlc29sdmVyQWRkciA9PT0gJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBlbnNOYW1lID0gYXdhaXQgdGhpcy5hY2NvdW50UHJvdmlkZXIuY2FsbCh7XG4gICAgICAgICAgICAgICAgdG86IHJlc29sdmVyQWRkcixcbiAgICAgICAgICAgICAgICBhYmk6IFB1YmxpY1Jlc29sdmVyQUJJLmFiaSxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbk5hbWU6ICduYW1lJyxcbiAgICAgICAgICAgICAgICBhcmdzOiBbcmV2ZXJzZU5vZGVdLFxuICAgICAgICAgICAgfSkuY2F0Y2goKCkgPT4gbnVsbCk7XG4gICAgICAgICAgICBjb25zdCBub3JtYWxpemVkID0gKGVuc05hbWUgfHwgJycpLnRyaW0oKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZWQubGVuZ3RoID4gMCA/IG5vcm1hbGl6ZWQgOiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHByZXBhcmVTZXRBZ2VudE5hbWVJbmZvQ2FsbHMocGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IFJFU09MVkVSX0FCSSA9IFtcbiAgICAgICAgICAgIHsgbmFtZTogJ3NldEFkZHInLCB0eXBlOiAnZnVuY3Rpb24nLCBzdGF0ZU11dGFiaWxpdHk6ICdub25wYXlhYmxlJywgaW5wdXRzOiBbXG4gICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ25vZGUnLCB0eXBlOiAnYnl0ZXMzMicgfSxcbiAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAnYWRkcicsIHR5cGU6ICdhZGRyZXNzJyB9XG4gICAgICAgICAgICAgICAgXSwgb3V0cHV0czogW10gfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ3NldFRleHQnLCB0eXBlOiAnZnVuY3Rpb24nLCBzdGF0ZU11dGFiaWxpdHk6ICdub25wYXlhYmxlJywgaW5wdXRzOiBbXG4gICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ25vZGUnLCB0eXBlOiAnYnl0ZXMzMicgfSxcbiAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAna2V5JywgdHlwZTogJ3N0cmluZycgfSxcbiAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAndmFsdWUnLCB0eXBlOiAnc3RyaW5nJyB9XG4gICAgICAgICAgICAgICAgXSwgb3V0cHV0czogW10gfSxcbiAgICAgICAgXTtcbiAgICAgICAgY29uc3QgY2xlYW4gPSAocykgPT4gKHMgfHwgJycpLnRyaW0oKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBjb25zdCBwYXJlbnQgPSBjbGVhbihwYXJhbXMub3JnTmFtZSk7XG4gICAgICAgIGNvbnN0IGxhYmVsID0gY2xlYW4ocGFyYW1zLmFnZW50TmFtZSkucmVwbGFjZSgvXFxzKy9nLCAnLScpO1xuICAgICAgICBjb25zdCBjaGlsZERvbWFpbiA9IGAke2xhYmVsfS4ke3BhcmVudH1gO1xuICAgICAgICBjb25zdCBlbnNGdWxsTmFtZSA9IGNoaWxkRG9tYWluICsgXCIuZXRoXCI7XG4gICAgICAgIGNvbnN0IGNoaWxkTm9kZSA9IG5hbWVoYXNoKGVuc0Z1bGxOYW1lKTtcbiAgICAgICAgY29uc3QgY2FsbHMgPSBbXTtcbiAgICAgICAgaWYgKHRoaXMucHVibGljQ2xpZW50KSB7XG4gICAgICAgICAgICBjb25zdCByZXNvbHZlciA9IGF3YWl0IHRoaXMuYWNjb3VudFByb3ZpZGVyLmNhbGwoe1xuICAgICAgICAgICAgICAgIHRvOiB0aGlzLmVuc1JlZ2lzdHJ5QWRkcmVzcyxcbiAgICAgICAgICAgICAgICBhYmk6IFt7IG5hbWU6IFwicmVzb2x2ZXJcIiwgc3RhdGVNdXRhYmlsaXR5OiBcInZpZXdcIiwgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRzOiBbeyBuYW1lOiBcIm5vZGVcIiwgdHlwZTogXCJieXRlczMyXCIgfV0sIG91dHB1dHM6IFt7IHR5cGU6IFwiYWRkcmVzc1wiIH1dIH1dLFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uTmFtZTogXCJyZXNvbHZlclwiLFxuICAgICAgICAgICAgICAgIGFyZ3M6IFtjaGlsZE5vZGVdLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyAxKSBTZXQgYWRkciByZWNvcmRcbiAgICAgICAgICAgIGNvbnN0IHNldEFkZHJEYXRhID0gZW5jb2RlRnVuY3Rpb25EYXRhKHtcbiAgICAgICAgICAgICAgICBhYmk6IFt7IG5hbWU6IFwic2V0QWRkclwiLCB0eXBlOiBcImZ1bmN0aW9uXCIsIHN0YXRlTXV0YWJpbGl0eTogXCJub25wYXlhYmxlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnB1dHM6IFt7IG5hbWU6IFwibm9kZVwiLCB0eXBlOiBcImJ5dGVzMzJcIiB9LCB7IG5hbWU6IFwiYVwiLCB0eXBlOiBcImFkZHJlc3NcIiB9XSB9XSxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbk5hbWU6IFwic2V0QWRkclwiLFxuICAgICAgICAgICAgICAgIGFyZ3M6IFtjaGlsZE5vZGUsIHBhcmFtcy5hZ2VudEFkZHJlc3NdLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjYWxscy5wdXNoKHsgdG86IHJlc29sdmVyLCBkYXRhOiBzZXRBZGRyRGF0YSB9KTtcbiAgICAgICAgICAgIC8vIDIpIE9wdGlvbmFsbHkgc2V0IFVSTCB0ZXh0XG4gICAgICAgICAgICBpZiAocGFyYW1zLmFnZW50VXJsICYmIHBhcmFtcy5hZ2VudFVybC50cmltKCkgIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YVNldFVybCA9IHRoaXMuZW5jb2RlQ2FsbChSRVNPTFZFUl9BQkksICdzZXRUZXh0KGJ5dGVzMzIsc3RyaW5nLHN0cmluZyknLCBbY2hpbGROb2RlLCAndXJsJywgcGFyYW1zLmFnZW50VXJsLnRyaW0oKV0pO1xuICAgICAgICAgICAgICAgIGNhbGxzLnB1c2goeyB0bzogcmVzb2x2ZXIsIGRhdGE6IGRhdGFTZXRVcmwgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyAyYikgT3B0aW9uYWxseSBzZXQgZGVzY3JpcHRpb24gdGV4dFxuICAgICAgICAgICAgaWYgKHBhcmFtcy5hZ2VudERlc2NyaXB0aW9uICYmIHBhcmFtcy5hZ2VudERlc2NyaXB0aW9uLnRyaW0oKSAhPT0gJycpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhU2V0RGVzY3JpcHRpb24gPSB0aGlzLmVuY29kZUNhbGwoUkVTT0xWRVJfQUJJLCAnc2V0VGV4dChieXRlczMyLHN0cmluZyxzdHJpbmcpJywgW2NoaWxkTm9kZSwgJ2Rlc2NyaXB0aW9uJywgcGFyYW1zLmFnZW50RGVzY3JpcHRpb24udHJpbSgpXSk7XG4gICAgICAgICAgICAgICAgY2FsbHMucHVzaCh7IHRvOiByZXNvbHZlciwgZGF0YTogZGF0YVNldERlc2NyaXB0aW9uIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gMykgU2V0IHJldmVyc2UgcmVjb3JkXG4gICAgICAgICAgICAvL2NvbnN0IHJldmVyc2VOb2RlID0gbmFtZWhhc2gocGFyYW1zLmFnZW50QWRkcmVzcy5zbGljZSgyKS50b0xvd2VyQ2FzZSgpICsgJy5hZGRyLnJldmVyc2UnKTtcbiAgICAgICAgICAgIGNvbnN0IEJBU0VfUkVWRVJTRV9OT0RFID0gbmFtZWhhc2goXCJhZGRyLnJldmVyc2VcIik7XG4gICAgICAgICAgICBjb25zdCBFTlNfUkVHSVNUUllfQUREUkVTUyA9IHRoaXMuZW5zUmVnaXN0cnlBZGRyZXNzO1xuICAgICAgICAgICAgY29uc3QgcmV2ZXJzZVJlZ2lzdHJhciA9IGF3YWl0IHRoaXMuYWNjb3VudFByb3ZpZGVyLmNhbGwoe1xuICAgICAgICAgICAgICAgIHRvOiBFTlNfUkVHSVNUUllfQUREUkVTUyxcbiAgICAgICAgICAgICAgICBhYmk6IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIm93bmVyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZU11dGFiaWxpdHk6IFwidmlld1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRzOiBbeyBuYW1lOiBcIm5vZGVcIiwgdHlwZTogXCJieXRlczMyXCIgfV0sXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRzOiBbeyBuYW1lOiBcIlwiLCB0eXBlOiBcImFkZHJlc3NcIiB9XSxcbiAgICAgICAgICAgICAgICAgICAgfV0sXG4gICAgICAgICAgICAgICAgZnVuY3Rpb25OYW1lOiBcIm93bmVyXCIsXG4gICAgICAgICAgICAgICAgYXJnczogW0JBU0VfUkVWRVJTRV9OT0RFXSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLypcbiAgICAgICAgICAgIGNvbnN0IG91clJldmVyc2VSZWdpc3RyYXIgPSBhd2FpdCB0aGlzLmFjY291bnRQcm92aWRlci5jYWxsPGAweCR7c3RyaW5nfWA+KHtcbiAgICAgICAgICAgICAgdG86IEVOU19SRUdJU1RSWV9BRERSRVNTLFxuICAgICAgICAgICAgICBhYmk6IFt7XG4gICAgICAgICAgICAgICAgbmFtZTogXCJvd25lclwiLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICAgICAgICAgICAgICBzdGF0ZU11dGFiaWxpdHk6IFwidmlld1wiLFxuICAgICAgICAgICAgICAgIGlucHV0czogW3sgbmFtZTogXCJub2RlXCIsIHR5cGU6IFwiYnl0ZXMzMlwiIH1dLFxuICAgICAgICAgICAgICAgIG91dHB1dHM6IFt7IG5hbWU6IFwiXCIsIHR5cGU6IFwiYWRkcmVzc1wiIH1dLFxuICAgICAgICAgICAgICB9XSBhcyBhbnksXG4gICAgICAgICAgICAgIGZ1bmN0aW9uTmFtZTogXCJvd25lclwiLFxuICAgICAgICAgICAgICBhcmdzOiBbcmV2ZXJzZU5vZGVdLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgY29uc3Qgc2V0TmFtZURhdGEgPSBlbmNvZGVGdW5jdGlvbkRhdGEoe1xuICAgICAgICAgICAgICAgIGFiaTogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IFwic2V0TmFtZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVNdXRhYmlsaXR5OiBcIm5vbnBheWFibGVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0czogW3sgbmFtZTogXCJuYW1lXCIsIHR5cGU6IFwic3RyaW5nXCIgfV0sXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRzOiBbeyBuYW1lOiBcIm5vZGVcIiwgdHlwZTogXCJieXRlczMyXCIgfV0sXG4gICAgICAgICAgICAgICAgICAgIH1dLFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uTmFtZTogXCJzZXROYW1lXCIsXG4gICAgICAgICAgICAgICAgYXJnczogW2Vuc0Z1bGxOYW1lXSwgLy8gZS5nLiBcImZpbmRlci1haXJibmItY29tLm9yZ3RydXN0LmV0aFwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGNhbGwgPSB7XG4gICAgICAgICAgICAgICAgdG86IHJldmVyc2VSZWdpc3RyYXIsXG4gICAgICAgICAgICAgICAgZGF0YTogc2V0TmFtZURhdGEsXG4gICAgICAgICAgICAgICAgdmFsdWU6IDBuXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2FsbHMucHVzaChjYWxsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBjYWxscyB9O1xuICAgIH1cbiAgICAvLyBFTlMgd3JhcHBlclxuICAgIGFzeW5jIHByZXBhcmVBZGRBZ2VudE5hbWVUb09yZ0NhbGxzKHBhcmFtcykge1xuICAgICAgICBjb25zdCBjbGVhbiA9IChzKSA9PiAocyB8fCAnJykudHJpbSgpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGxldCBwYXJlbnQgPSBjbGVhbihwYXJhbXMub3JnTmFtZSk7XG4gICAgICAgIHBhcmVudCA9IHBhcmVudC5lbmRzV2l0aCgnLmV0aCcpID8gcGFyZW50LnNsaWNlKDAsIC00KSA6IHBhcmVudDtcbiAgICAgICAgY29uc3QgcGFyZW50Tm9kZSA9IG5hbWVoYXNoKHBhcmVudCArIFwiLmV0aFwiKTtcbiAgICAgICAgY29uc29sZS5sb2coJyEhISEhISEhISEhISBwcmVwYXJlQWRkQWdlbnROYW1lVG9PcmdDYWxsczogcGFyZW50JywgcGFyZW50ICsgXCIuZXRoXCIpO1xuICAgICAgICBjb25zdCBsYWJlbCA9IGNsZWFuKHBhcmFtcy5hZ2VudE5hbWUpLnJlcGxhY2UoL1xccysvZywgJy0nKTtcbiAgICAgICAgY29uc29sZS5sb2coJyEhISEhISEhISEhISBwcmVwYXJlQWRkQWdlbnROYW1lVG9PcmdDYWxsczogYWdlbnROYW1lJywgcGFyYW1zLmFnZW50TmFtZSk7XG4gICAgICAgIGNvbnNvbGUubG9nKCchISEhISEhISEhISEgcHJlcGFyZUFkZEFnZW50TmFtZVRvT3JnQ2FsbHM6IGxhYmVsJywgbGFiZWwpO1xuICAgICAgICBjb25zdCBjYWxscyA9IFtdO1xuICAgICAgICAvLyBVc2Ugc3RvcmVkIHJlc29sdmVyIGFkZHJlc3MgZnJvbSBjbGllbnQgaW5zdGFuY2VcbiAgICAgICAgLy9jb25zdCByZXNvbHZlckFkZHJlc3MgPSB0aGlzLmdldEVuc1Jlc29sdmVyQWRkcmVzcygpO1xuICAgICAgICAvL2lmICghcmVzb2x2ZXJBZGRyZXNzIHx8IHJlc29sdmVyQWRkcmVzcyA9PT0gJzB4JyB8fCByZXNvbHZlckFkZHJlc3MubGVuZ3RoICE9PSA0Mikge1xuICAgICAgICAvLyAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIEVOUyByZXNvbHZlciBhZGRyZXNzOiAke3Jlc29sdmVyQWRkcmVzc30uIEVuc3VyZSBFTlMgcmVzb2x2ZXIgaXMgcHJvcGVybHkgY29uZmlndXJlZC5gKTtcbiAgICAgICAgLy99XG4gICAgICAgIC8vIEdldCBpZGVudGl0eSB3cmFwcGVyIGFkZHJlc3MgZnJvbSBlbnZpcm9ubWVudCAoY2hhaW4tc2NvcGVkIGlmIGF2YWlsYWJsZSlcbiAgICAgICAgY29uc3QgaWRlbnRpdHlXcmFwcGVyQWRkcmVzcyA9IHRoaXMuZ2V0Q2hhaW5TY29wZWRBZGRyZXNzKCdBR0VOVElDX1RSVVNUX0VOU19JREVOVElUWV9XUkFQUEVSJywgdGhpcy5jaGFpbi5pZCk7XG4gICAgICAgIGlmICghaWRlbnRpdHlXcmFwcGVyQWRkcmVzcykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIEVOUyBpZGVudGl0eSB3cmFwcGVyIGFkZHJlc3MuIFNldCBBR0VOVElDX1RSVVNUX0VOU19JREVOVElUWV9XUkFQUEVSX3tDSEFJTl9TVUZGSVh9IG9yIEFHRU5USUNfVFJVU1RfRU5TX0lERU5USVRZX1dSQVBQRVIgZW52aXJvbm1lbnQgdmFyaWFibGUuYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc29sZS5sb2coJyEhISEhISEhISEhISBwcmVwYXJlQWRkQWdlbnROYW1lVG9PcmdDYWxsczogbGFiZWwsIGFkZHJlc3MnLCBsYWJlbCwgcGFyYW1zLmFnZW50QWRkcmVzcyk7XG4gICAgICAgIGNvbnN0IHN1YmRvbWFpbkRhdGEgPSBlbmNvZGVGdW5jdGlvbkRhdGEoe1xuICAgICAgICAgICAgYWJpOiBOYW1lV3JhcHBlckFCSS5hYmksXG4gICAgICAgICAgICBmdW5jdGlvbk5hbWU6ICdzZXRTdWJub2RlUmVjb3JkJyxcbiAgICAgICAgICAgIGFyZ3M6IFtcbiAgICAgICAgICAgICAgICBwYXJlbnROb2RlLFxuICAgICAgICAgICAgICAgIGxhYmVsLFxuICAgICAgICAgICAgICAgIHBhcmFtcy5hZ2VudEFkZHJlc3MsXG4gICAgICAgICAgICAgICAgdGhpcy5nZXRDaGFpblNjb3BlZEFkZHJlc3MoJ0FHRU5USUNfVFJVU1RfRU5TX1BVQkxJQ19SRVNPTFZFUicsIHRoaXMuY2hhaW4uaWQpLFxuICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAwXG4gICAgICAgICAgICBdXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBjYWxsID0ge1xuICAgICAgICAgICAgdG86IGlkZW50aXR5V3JhcHBlckFkZHJlc3MsXG4gICAgICAgICAgICBkYXRhOiBzdWJkb21haW5EYXRhLFxuICAgICAgICAgICAgdmFsdWU6IDBuXG4gICAgICAgIH07XG4gICAgICAgIGNhbGxzLnB1c2goY2FsbCk7XG4gICAgICAgIHJldHVybiB7IGNhbGxzIH07XG4gICAgfVxuICAgIGlzWmVyb0FkZHJlc3MoYWRkcikge1xuICAgICAgICByZXR1cm4gL14weDB7NDB9JC9pLnRlc3QoYWRkcik7XG4gICAgfVxuICAgIGFzeW5jIGdldEFkZHJlc3NGcm9tRU5TTmFtZShlbnNOYW1lKSB7XG4gICAgICAgIGNvbnN0IGNsZWFuID0gKHMpID0+IChzIHx8ICcnKS50cmltKCkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgbGV0IHBhcmVudCA9IGNsZWFuKGVuc05hbWUpO1xuICAgICAgICBwYXJlbnQgPSBwYXJlbnQuZW5kc1dpdGgoJy5ldGgnKSA/IHBhcmVudC5zbGljZSgwLCAtNCkgOiBwYXJlbnQ7XG4gICAgICAgIGNvbnN0IGZ1bGxuYW1lID0gYCR7cGFyZW50fS5ldGhgO1xuICAgICAgICBjb25zdCBuYW1lTm9kZSA9IG5hbWVoYXNoKGZ1bGxuYW1lKTtcbiAgICAgICAgY29uc29sZS5pbmZvKFwiZW5zUmVnaXN0cnlBZGRyZXNzOiBcIiwgdGhpcy5lbnNSZWdpc3RyeUFkZHJlc3MpO1xuICAgICAgICBjb25zb2xlLmluZm8oXCJmdWxsbmFtZTogXCIsIGZ1bGxuYW1lKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nT3duZXIgPSBhd2FpdCB0aGlzLnB1YmxpY0NsaWVudD8ucmVhZENvbnRyYWN0KHtcbiAgICAgICAgICAgICAgICBhZGRyZXNzOiB0aGlzLmVuc1JlZ2lzdHJ5QWRkcmVzcyxcbiAgICAgICAgICAgICAgICBhYmk6IFt7IG5hbWU6ICdvd25lcicsIHR5cGU6ICdmdW5jdGlvbicsIHN0YXRlTXV0YWJpbGl0eTogJ3ZpZXcnLCBpbnB1dHM6IFt7IHR5cGU6ICdieXRlczMyJyB9XSwgb3V0cHV0czogW3sgdHlwZTogJ2FkZHJlc3MnIH1dIH1dLFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uTmFtZTogJ293bmVyJyxcbiAgICAgICAgICAgICAgICBhcmdzOiBbbmFtZU5vZGVdXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGhhc093bmVyID0gQm9vbGVhbihleGlzdGluZ093bmVyICYmIGV4aXN0aW5nT3duZXIgIT09ICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnKTtcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhgaGFzQWdlbnROYW1lT3duZXI6IFwiJHtuYW1lTm9kZX1cIiAke2hhc093bmVyID8gJ0hBUyBvd25lcicgOiAnaGFzIE5PIG93bmVyJ30ke2hhc093bmVyID8gYDogJHtleGlzdGluZ093bmVyfWAgOiAnJ31gKTtcbiAgICAgICAgICAgIHJldHVybiBleGlzdGluZ093bmVyO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgY2hlY2tpbmcgYWdlbnQgbmFtZSBvd25lcjonLCBlcnJvcik7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXNvbHZlIGEgY2hhaW4tc2NvcGVkIGVudiB2YXIsIGZhbGxpbmcgYmFjayB0byB0aGUgYmFzZSBuYW1lLlxuICAgICAqIEZvciBleGFtcGxlLCB3aXRoIGJhc2VOYW1lICdBR0VOVElDX1RSVVNUX0VOU19QVUJMSUNfUkVTT0xWRVInIGFuZFxuICAgICAqIGNoYWluLmlkPTExMTU1MTExLCB0aGlzIGNoZWNrczpcbiAgICAgKiAgLSBBR0VOVElDX1RSVVNUX0VOU19QVUJMSUNfUkVTT0xWRVJfU0VQT0xJQVxuICAgICAqICAtIEFHRU5USUNfVFJVU1RfRU5TX1BVQkxJQ19SRVNPTFZFUlxuICAgICAqL1xuICAgIGdldENoYWluU2NvcGVkQWRkcmVzcyhiYXNlTmFtZSwgY2hhaW5JZCkge1xuICAgICAgICBjb25zdCBzdWZmaXggPSBjaGFpbklkID09PSAxMTE1NTExMVxuICAgICAgICAgICAgPyAnU0VQT0xJQSdcbiAgICAgICAgICAgIDogY2hhaW5JZCA9PT0gODQ1MzJcbiAgICAgICAgICAgICAgICA/ICdCQVNFX1NFUE9MSUEnXG4gICAgICAgICAgICAgICAgOiBjaGFpbklkID09PSAxMTE1NTQyMFxuICAgICAgICAgICAgICAgICAgICA/ICdPUFRJTUlTTV9TRVBPTElBJ1xuICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3QgY2hhaW5LZXkgPSBzdWZmaXggPyBgJHtiYXNlTmFtZX1fJHtzdWZmaXh9YCA6IGJhc2VOYW1lO1xuICAgICAgICBjb25zdCBjaGFpblZhbHVlID0gcHJvY2Vzcy5lbnZbY2hhaW5LZXldO1xuICAgICAgICBjb25zdCBmYWxsYmFja1ZhbHVlID0gcHJvY2Vzcy5lbnZbYmFzZU5hbWVdO1xuICAgICAgICBjb25zdCByYXcgPSBjaGFpblZhbHVlID8/IGZhbGxiYWNrVmFsdWU7XG4gICAgICAgIGlmICghcmF3KVxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3QgdHJpbW1lZCA9IHJhdy50cmltKCk7XG4gICAgICAgIGlmICghL14weFswLTlhLWZBLUZdezQwfSQvLnRlc3QodHJpbW1lZCkpXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gdHJpbW1lZDtcbiAgICB9XG4gICAgLyoqIERlY29kZSBFUkMtNzkzMC1saWtlIGFnZW50IGlkZW50aXR5IGhleCBzdHJpbmcgKi9cbiAgICBkZWNvZGVBZ2VudElkZW50aXR5KHZhbHVlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoIXZhbHVlIHx8ICEvXjB4WzAtOWEtZkEtRl0rJC8udGVzdCh2YWx1ZSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBjb25zdCBoZXggPSB2YWx1ZS5zbGljZSgyKTtcbiAgICAgICAgICAgIC8vIFt2MT0wMV1bbnM9ZWlwMTU1PTAxXVtjaGFpbklkKDQpXVthZGRyZXNzKDIwKV1bbGVuKDEpXVtpZCh2YXIpXVxuICAgICAgICAgICAgaWYgKGhleC5sZW5ndGggPCAyICsgMiArIDggKyA0MCArIDIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBjb25zdCBjaGFpbklkSGV4ID0gaGV4LnNsaWNlKDQsIDEyKTtcbiAgICAgICAgICAgIGNvbnN0IGNoYWluSWQgPSBwYXJzZUludChjaGFpbklkSGV4LCAxNik7XG4gICAgICAgICAgICBjb25zdCBhZGRySGV4ID0gaGV4LnNsaWNlKDEyLCA1Mik7XG4gICAgICAgICAgICBjb25zdCBpZExlbiA9IHBhcnNlSW50KGhleC5zbGljZSg1MiwgNTQpLCAxNik7XG4gICAgICAgICAgICBjb25zdCBpZEhleCA9IGhleC5zbGljZSg1NCwgNTQgKyBpZExlbiAqIDIpO1xuICAgICAgICAgICAgY29uc3QgcmVnaXN0cnkgPSAoYDB4JHthZGRySGV4fWApO1xuICAgICAgICAgICAgY29uc3QgYWdlbnRJZCA9IEJpZ0ludChgMHgke2lkSGV4IHx8ICcwJ31gKTtcbiAgICAgICAgICAgIHJldHVybiB7IGNoYWluSWQsIHJlZ2lzdHJ5LCBhZ2VudElkIH07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2gge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1BSUFnZW50RU5TQ2xpZW50LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@agentic-trust/8004-ext-sdk/dist/AIAgentENSClient.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@agentic-trust/8004-ext-sdk/dist/AIAgentIdentityClient.js":
/*!************************************************************************************!*\
  !*** ../../node_modules/@agentic-trust/8004-ext-sdk/dist/AIAgentIdentityClient.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AIAgentIdentityClient: () => (/* binding */ AIAgentIdentityClient)\n/* harmony export */ });\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! viem */ \"(rsc)/../../node_modules/viem/_esm/clients/createPublicClient.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! viem */ \"(rsc)/../../node_modules/viem/_esm/clients/transports/http.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! viem */ \"(rsc)/../../node_modules/viem/_esm/utils/encoding/fromHex.js\");\n/* harmony import */ var viem_chains__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! viem/chains */ \"(rsc)/../../node_modules/viem/_esm/chains/definitions/sepolia.js\");\n/* harmony import */ var viem_chains__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! viem/chains */ \"(rsc)/../../node_modules/viem/_esm/chains/definitions/baseSepolia.js\");\n/* harmony import */ var viem_chains__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! viem/chains */ \"(rsc)/../../node_modules/viem/_esm/chains/definitions/optimismSepolia.js\");\n/* harmony import */ var _agentic_trust_8004_sdk__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @agentic-trust/8004-sdk */ \"(rsc)/../../node_modules/@agentic-trust/8004-sdk/dist/index.js\");\n/* harmony import */ var _abis_IdentityRegistry_json__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./abis/IdentityRegistry.json */ \"(rsc)/../../node_modules/@agentic-trust/8004-ext-sdk/dist/abis/IdentityRegistry.json\");\n/**\n * Agentic Trust SDK - Identity Client\n * Extends the base ERC-8004 IdentityClient with AA-centric helpers.\n *\n * Uses AccountProvider (Ports & Adapters pattern) for chain I/O.\n */\n\n\n\n\nfunction getChainById(chainId) {\n    switch (chainId) {\n        case 11155111: // ETH Sepolia\n            return viem_chains__WEBPACK_IMPORTED_MODULE_2__.sepolia;\n        case 84532: // Base Sepolia\n            return viem_chains__WEBPACK_IMPORTED_MODULE_3__.baseSepolia;\n        case 11155420: // Optimism Sepolia\n            return viem_chains__WEBPACK_IMPORTED_MODULE_4__.optimismSepolia;\n        default:\n            console.warn(`Unknown chainId ${chainId}, defaulting to ETH Sepolia`);\n            return viem_chains__WEBPACK_IMPORTED_MODULE_2__.sepolia;\n    }\n}\nclass AIAgentIdentityClient extends _agentic_trust_8004_sdk__WEBPACK_IMPORTED_MODULE_0__.BaseIdentityClient {\n    chain = null;\n    identityRegistryAddress;\n    publicClient = null;\n    walletClient = null;\n    // accountProvider is protected in BaseIdentityClient, so we need to keep it accessible\n    accountProvider;\n    constructor(options) {\n        let accountProvider;\n        let chain = null;\n        let publicClient = null;\n        let walletClient = null;\n        let identityRegistryAddress;\n        if ('accountProvider' in options) {\n            // Option 1: Use provided AccountProvider (recommended)\n            accountProvider = options.accountProvider;\n            identityRegistryAddress = options.identityRegistryAddress;\n            // Try to extract publicClient from AccountProvider if it's a ViemAccountProvider\n            const viemProvider = accountProvider;\n            if (viemProvider.publicClient) {\n                publicClient = viemProvider.publicClient;\n            }\n            if (viemProvider.walletClient) {\n                walletClient = viemProvider.walletClient;\n            }\n            if (viemProvider.chainConfig?.chain) {\n                chain = viemProvider.chainConfig.chain;\n            }\n        }\n        else if ('publicClient' in options) {\n            // Option 2: Use viem clients directly (simplest, native viem)\n            publicClient = options.publicClient;\n            walletClient = options.walletClient ?? null;\n            identityRegistryAddress = options.identityRegistryAddress;\n            // Create ChainConfig\n            const chainConfig = options.chainConfig || {\n                id: publicClient.chain?.id || 11155111,\n                rpcUrl: publicClient.transport?.url || '',\n                name: publicClient.chain?.name || 'Unknown',\n                chain: publicClient.chain || undefined,\n            };\n            // Create ViemAccountProvider from the clients\n            accountProvider = new _agentic_trust_8004_sdk__WEBPACK_IMPORTED_MODULE_0__.ViemAccountProvider({\n                publicClient,\n                walletClient: walletClient ?? null,\n                account: walletClient?.account,\n                chainConfig,\n            });\n        }\n        else {\n            // Option 3: Legacy pattern - create from chainId/rpcUrl\n            chain = getChainById(options.chainId);\n            // @ts-ignore - viem version compatibility issue\n            publicClient = (0,viem__WEBPACK_IMPORTED_MODULE_5__.createPublicClient)({ chain, transport: (0,viem__WEBPACK_IMPORTED_MODULE_6__.http)(options.rpcUrl) });\n            walletClient = options.walletClient ?? null;\n            // Create ChainConfig\n            const chainConfig = {\n                id: options.chainId,\n                rpcUrl: options.rpcUrl,\n                name: chain.name,\n                chain: chain,\n                bundlerUrl: options.bundlerUrl,\n                paymasterUrl: options.paymasterUrl,\n            };\n            // Create ViemAccountProvider\n            accountProvider = new _agentic_trust_8004_sdk__WEBPACK_IMPORTED_MODULE_0__.ViemAccountProvider({\n                publicClient,\n                walletClient: walletClient ?? null,\n                account: options.account || walletClient?.account,\n                chainConfig,\n            });\n            identityRegistryAddress = options.identityRegistryAddress;\n        }\n        // Pass accountProvider to BaseIdentityClient\n        super(accountProvider, identityRegistryAddress);\n        this.chain = chain;\n        this.publicClient = publicClient;\n        this.walletClient = walletClient;\n        this.identityRegistryAddress = identityRegistryAddress;\n        this.accountProvider = accountProvider;\n    }\n    /**\n     * Get metadata using AccountProvider\n     */\n    async getMetadata(agentId, key) {\n        const bytes = await this.accountProvider.call({\n            to: this.identityRegistryAddress,\n            abi: _abis_IdentityRegistry_json__WEBPACK_IMPORTED_MODULE_1__,\n            functionName: 'getMetadata',\n            args: [agentId, key],\n        });\n        return (0,viem__WEBPACK_IMPORTED_MODULE_7__.hexToString)(bytes);\n    }\n    /**\n     * Get all available metadata from the Agent NFT by trying a comprehensive list of common keys.\n     * Returns a record of all metadata key-value pairs that exist on-chain.\n     *\n     * Processes requests in batches to avoid rate limiting.\n     *\n     * IMPORTANT: This method makes many on-chain RPC calls and should ONLY be used\n     * for detailed agent views (via loadAgentDetail). It should NOT be called for\n     * list queries - use GraphQL/discovery data instead.\n     */\n    async getAllMetadata(agentId) {\n        // Comprehensive list of common metadata keys to check\n        const METADATA_KEYS = [\n            // Standard ERC-8004 fields\n            'agentName',\n            'agentAccount',\n            'description',\n            'image',\n            'external_url',\n            'version',\n            'type',\n            'name',\n            'url',\n            'website',\n            'email',\n            'twitter',\n            'github',\n            'discord',\n            'telegram',\n            'metadata',\n            'attributes',\n            'createdAt',\n            'updatedAt',\n            // Additional common fields\n            'tags',\n            'glbUrl',\n            'glbCid',\n            'glbFileName',\n            'glbSource',\n            'agentWallet',\n            'capabilities',\n            'role',\n            'rating',\n            'pricing',\n            'pka',\n            'uri',\n            'endpoints',\n            'supportedTrust',\n            'registrations',\n            'agentUrl',\n            'contractAddress',\n            'did',\n            'didIdentity',\n            'didAccount',\n            'didName',\n            'active',\n            'x402support',\n            'mcp',\n            'a2aEndpoint',\n            'mcpEndpoint',\n            'ensEndpoint',\n            'agentAccountEndpoint',\n        ];\n        const metadata = {};\n        // Process requests in batches to avoid rate limiting\n        // Batch size: 5 requests at a time\n        // Delay between batches: 200ms\n        const BATCH_SIZE = 5;\n        const BATCH_DELAY_MS = 200;\n        for (let i = 0; i < METADATA_KEYS.length; i += BATCH_SIZE) {\n            const batch = METADATA_KEYS.slice(i, i + BATCH_SIZE);\n            // Process batch in parallel\n            const batchPromises = batch.map(async (key) => {\n                try {\n                    const value = await this.getMetadata(agentId, key);\n                    if (value && value.trim().length > 0) {\n                        return { key, value };\n                    }\n                    return null;\n                }\n                catch (error) {\n                    // Check if it's a rate limit error (429)\n                    const errorMessage = error instanceof Error ? error.message : String(error);\n                    if (errorMessage.includes('429') || errorMessage.includes('Too Many Requests')) {\n                        // For rate limit errors, wait longer before retrying\n                        await new Promise(resolve => setTimeout(resolve, 1000));\n                        try {\n                            const value = await this.getMetadata(agentId, key);\n                            if (value && value.trim().length > 0) {\n                                return { key, value };\n                            }\n                        }\n                        catch (retryError) {\n                            // Silently skip on retry failure\n                        }\n                    }\n                    // Silently skip if metadata key doesn't exist or fails\n                    return null;\n                }\n            });\n            const batchResults = await Promise.all(batchPromises);\n            // Collect successful results from this batch\n            for (const result of batchResults) {\n                if (result) {\n                    metadata[result.key] = result.value;\n                }\n            }\n            // Delay before next batch (except for the last batch)\n            if (i + BATCH_SIZE < METADATA_KEYS.length) {\n                await new Promise(resolve => setTimeout(resolve, BATCH_DELAY_MS));\n            }\n        }\n        return metadata;\n    }\n    /**\n     * Encode function call data using AccountProvider\n     */\n    async encodeFunctionData(abi, functionName, args) {\n        return await this.accountProvider.encodeFunctionData({\n            abi,\n            functionName,\n            args,\n        });\n    }\n    /**\n     * Legacy method - delegates to encodeFunctionData\n     * @deprecated Use encodeFunctionData instead\n     */\n    encodeCall(abi, functionName, args) {\n        // This is a synchronous method, but encodeFunctionData is async\n        // For backward compatibility, we'll use ethers for now\n        // TODO: Consider making this async or removing it\n        const { ethers } = require('ethers');\n        const iface = new ethers.Interface(abi);\n        return iface.encodeFunctionData(functionName, args);\n    }\n    /**\n     * Encode register calldata without sending (for bundler/AA - like EAS SDK pattern)\n     * This override exists in the Agentic Trust SDK to keep AA helpers here.\n     */\n    async encodeRegisterWithMetadata(tokenUri, metadata = []) {\n        // Format metadata: convert string values to hex strings (Viem expects hex for bytes)\n        const metadataFormatted = metadata.map(m => {\n            // Use stringToBytes from base class (via inheritance)\n            const bytes = this.stringToBytes(m.value);\n            // Convert to hex string (Viem requires hex strings, not Uint8Array)\n            const hexString = this.bytesToHex(bytes);\n            return {\n                // Updated ABI uses struct fields: { metadataKey, metadataValue }\n                metadataKey: m.key,\n                metadataValue: hexString,\n            };\n        });\n        // Use AccountProvider's encodeFunctionData\n        return await this.accountProvider.encodeFunctionData({\n            abi: _abis_IdentityRegistry_json__WEBPACK_IMPORTED_MODULE_1__,\n            functionName: 'register',\n            args: [tokenUri, metadataFormatted],\n        });\n    }\n    async encodeRegister(name, agentAccount, tokenUri) {\n        console.info(\"name: \", name);\n        console.info(\"agentAccount: \", agentAccount);\n        return await this.encodeRegisterWithMetadata(tokenUri, [{ key: 'agentName', value: name }, { key: 'agentAccount', value: agentAccount }]);\n    }\n    async prepareRegisterCalls(name, agentAccount, tokenUri, additionalMetadata) {\n        const metadata = [\n            { key: 'agentName', value: name },\n            { key: 'agentAccount', value: agentAccount },\n            ...(additionalMetadata || []),\n        ];\n        const data = await this.encodeRegisterWithMetadata(tokenUri, metadata);\n        const calls = [];\n        calls.push({\n            to: this.identityRegistryAddress,\n            data: data\n        });\n        return { calls };\n    }\n    async encodeSetRegistrationUri(agentId, uri) {\n        const data = await this.accountProvider.encodeFunctionData({\n            abi: _abis_IdentityRegistry_json__WEBPACK_IMPORTED_MODULE_1__,\n            // Updated ABI name is setAgentURI (capital URI)\n            functionName: 'setAgentURI',\n            args: [agentId, uri],\n        });\n        return data;\n    }\n    async prepareSetRegistrationUriCalls(agentId, uri) {\n        const calls = [];\n        const data = await this.encodeSetRegistrationUri(agentId, uri);\n        calls.push({\n            to: this.identityRegistryAddress,\n            data: data\n        });\n        return { calls };\n    }\n    /**\n     * Encode `setAgentWallet` calldata without sending.\n     *\n     * IdentityRegistry ABI:\n     * setAgentWallet(uint256 agentId, address newWallet, uint256 deadline, bytes signature)\n     */\n    async encodeSetAgentWallet(agentId, newWallet, deadline, signature) {\n        const data = await this.accountProvider.encodeFunctionData({\n            abi: _abis_IdentityRegistry_json__WEBPACK_IMPORTED_MODULE_1__,\n            functionName: 'setAgentWallet',\n            args: [agentId, newWallet, deadline, signature],\n        });\n        return data;\n    }\n    async prepareSetAgentWalletCalls(agentId, newWallet, deadline, signature) {\n        const calls = [];\n        const data = await this.encodeSetAgentWallet(agentId, newWallet, deadline, signature);\n        calls.push({\n            to: this.identityRegistryAddress,\n            data,\n        });\n        return { calls };\n    }\n    /**\n     * Prepare a complete transaction for client-side signing (similar to prepareCall for bundlers)\n     * All Ethereum logic (encoding, gas estimation, nonce) is handled server-side\n     * Client only needs to sign and send with MetaMask\n     * @param tokenUri - IPFS token URI for the agent registration\n     * @param metadata - Metadata entries for the agent\n     * @param fromAddress - Address that will sign the transaction (only address needed, no client)\n     * @returns Prepared transaction object ready for client-side signing\n     */\n    async prepareRegisterTransaction(tokenUri, metadata, fromAddress) {\n        // Encode the transaction data\n        const encodedData = await this.encodeRegisterWithMetadata(tokenUri, metadata);\n        // Get chain ID using AccountProvider\n        const chainId = await this.accountProvider.chainId();\n        // Initialize gas estimation variables\n        let gasEstimate;\n        let gasPrice;\n        let maxFeePerGas;\n        let maxPriorityFeePerGas;\n        let nonce;\n        try {\n            // Get current block data to check for EIP-1559 support\n            const blockData = await this.accountProvider.getBlock('latest');\n            // Prefer EIP-1559 (maxFeePerGas/maxPriorityFeePerGas) if available\n            // Otherwise fall back to legacy gasPrice\n            if (blockData && 'baseFeePerGas' in blockData && blockData.baseFeePerGas) {\n                // EIP-1559: Use maxFeePerGas and maxPriorityFeePerGas\n                // Set a reasonable priority fee (1-2 gwei typically)\n                // maxFeePerGas should be baseFeePerGas + maxPriorityFeePerGas + buffer\n                maxPriorityFeePerGas = 1000000000n; // 1 gwei as priority fee\n                maxFeePerGas = (blockData.baseFeePerGas * 2n) + maxPriorityFeePerGas; // 2x base + priority (buffer for safety)\n            }\n            else {\n                // Legacy: Use gasPrice\n                gasPrice = await this.accountProvider.getGasPrice();\n            }\n            // Estimate gas using AccountProvider\n            gasEstimate = await this.accountProvider.estimateGas({\n                account: fromAddress,\n                to: this.identityRegistryAddress,\n                data: encodedData,\n            });\n            // Get nonce using AccountProvider\n            nonce = await this.accountProvider.getTransactionCount(fromAddress, 'pending');\n        }\n        catch (error) {\n            console.warn('Could not estimate gas or get transaction parameters:', error);\n            // Continue without gas estimates - client can estimate\n        }\n        // Build transaction object - return hex strings for all bigint values (Viem accepts hex strings directly)\n        // This format can be used directly with Viem's sendTransaction without client-side conversion\n        const txParams = {\n            to: this.identityRegistryAddress,\n            data: encodedData,\n            value: '0x0', // Hex string for value\n            gas: gasEstimate ? `0x${gasEstimate.toString(16)}` : undefined,\n            nonce,\n            chainId,\n        };\n        // Include EIP-1559 fields if available, otherwise legacy gasPrice\n        // All as hex strings for direct Viem compatibility\n        if (maxFeePerGas && maxPriorityFeePerGas) {\n            txParams.maxFeePerGas = `0x${maxFeePerGas.toString(16)}`;\n            txParams.maxPriorityFeePerGas = `0x${maxPriorityFeePerGas.toString(16)}`;\n        }\n        else if (gasPrice) {\n            txParams.gasPrice = `0x${gasPrice.toString(16)}`;\n        }\n        return txParams;\n    }\n    async isValidAgentAccount(agentAccount) {\n        try {\n            // Use AccountProvider's ReadClient interface - check if address has code\n            // We can use a simple call to check if it's a contract\n            // For now, we'll use publicClient if available, otherwise return null\n            if (this.publicClient) {\n                const code = await this.publicClient.getBytecode({ address: agentAccount });\n                return code ? true : false;\n            }\n            // AccountProvider doesn't expose getBytecode directly, so we check via isContractSigner\n            // This is a workaround - ideally AccountProvider would expose getBytecode\n            return null;\n        }\n        catch {\n            return null;\n        }\n    }\n    /**\n     * Extract agentId from a user operation/transaction receipt\n     * Public in this SDK to support AA flows explicitly.\n     */\n    extractAgentIdFromReceiptPublic(receipt) {\n        // Look for parsed events first\n        if (receipt?.events) {\n            const registeredEvent = receipt.events.find((e) => e.name === 'Registered');\n            if (registeredEvent?.args) {\n                const val = registeredEvent.args.agentId ?? registeredEvent.args[0];\n                if (val !== undefined)\n                    return BigInt(val);\n            }\n            const transferEvent = receipt.events.find((e) => e.name === 'Transfer' && (e.args.from === '0x0000000000000000000000000000000000000000' || e.args.from === 0 || e.args.from === 0n));\n            if (transferEvent?.args) {\n                const val = transferEvent.args.tokenId ?? transferEvent.args[2];\n                if (val !== undefined)\n                    return BigInt(val);\n            }\n        }\n        // Fallback: raw logs array\n        if (receipt?.logs && Array.isArray(receipt.logs)) {\n            for (const log of receipt.logs) {\n                // Transfer(address,address,uint256)\n                if (log.topics && log.topics[0] === '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef') {\n                    const from = log.topics[1];\n                    if (from === '0x0000000000000000000000000000000000000000000000000000000000000000') {\n                        const tokenId = BigInt(log.topics[3] || log.data);\n                        return tokenId;\n                    }\n                }\n            }\n        }\n        throw new Error('Could not extract agentId from transaction receipt - Registered or Transfer event not found');\n    }\n    /**\n     * Get the owner (EOA) of an account address\n     *\n     * @param accountAddress - The account address (smart account or contract)\n     * @returns The owner address (EOA) or null if not found or error\n     */\n    async getAccountOwner(accountAddress) {\n        try {\n            const owner = await this.accountProvider.call({\n                to: accountAddress,\n                abi: [{ name: 'owner', type: 'function', stateMutability: 'view', inputs: [], outputs: [{ type: 'address' }] }],\n                functionName: 'owner',\n                args: [],\n            });\n            return owner;\n        }\n        catch {\n            return null;\n        }\n    }\n    /**\n     * @deprecated Use getAccountOwner instead\n     */\n    async getAgentEoaByAgentAccount(agentAccount) {\n        return this.getAccountOwner(agentAccount);\n    }\n    /**\n     * Get agentName from on-chain metadata (string value)\n     */\n    async getAgentName(agentId) {\n        try {\n            const name = await this.getMetadata(agentId, 'agentName');\n            if (typeof name === 'string') {\n                const trimmed = name.trim();\n                return trimmed.length > 0 ? trimmed : null;\n            }\n            return name ? String(name) : null;\n        }\n        catch (error) {\n            console.info(\"++++++++++++++++++++++++ getAgentName: error\", error);\n            return null;\n        }\n    }\n    /**\n     * Get agentAccount address from on-chain metadata.\n     * Supports CAIP-10 format like \"eip155:11155111:0x...\" or raw 0x address.\n     */\n    async getAgentAccount(agentId) {\n        try {\n            const value = await this.getMetadata(agentId, 'agentAccount');\n            if (!value)\n                return null;\n            if (typeof value === 'string') {\n                const v = value.trim();\n                if (v.startsWith('eip155:')) {\n                    const parts = v.split(':');\n                    const addr = parts[2];\n                    if (addr && /^0x[a-fA-F0-9]{40}$/.test(addr))\n                        return addr;\n                }\n                if (/^0x[a-fA-F0-9]{40}$/.test(v))\n                    return v;\n            }\n            return null;\n        }\n        catch {\n            return null;\n        }\n    }\n    /**\n     * Get agentCategory from on-chain metadata (string value)\n     * Returns one of the standard agent category types from the OAS ecosystem.\n     */\n    async getAgentCategory(agentId) {\n        try {\n            const category = await this.getMetadata(agentId, 'agentCategory');\n            if (typeof category === 'string') {\n                const trimmed = category.trim();\n                return trimmed.length > 0 ? trimmed : null;\n            }\n            return category ? String(category) : null;\n        }\n        catch (error) {\n            console.info(\"++++++++++++++++++++++++ getAgentCategory: error\", error);\n            return null;\n        }\n    }\n    /**\n     * Keep compatibility: delegate to receipt extractor.\n     */\n    extractAgentIdFromLogs(receipt) {\n        return this.extractAgentIdFromReceiptPublic(receipt);\n    }\n    /**\n     * Get the approved operator address for an agent NFT token\n     * Returns the address approved to operate on the token, or null if no operator is set\n     *\n     * @param agentId - The agent ID (token ID)\n     * @returns The approved operator address, or null if no operator is set (zero address)\n     */\n    async getNFTOperator(agentId) {\n        try {\n            const operatorAddress = await this.accountProvider.call({\n                to: this.identityRegistryAddress,\n                abi: _abis_IdentityRegistry_json__WEBPACK_IMPORTED_MODULE_1__,\n                functionName: 'getApproved',\n                args: [agentId],\n            });\n            // Check if operator is set (not zero address)\n            if (operatorAddress && operatorAddress !== '0x0000000000000000000000000000000000000000') {\n                return operatorAddress;\n            }\n            return null;\n        }\n        catch (error) {\n            console.error('Failed to get NFT operator:', error);\n            return null;\n        }\n    }\n}\n//# sourceMappingURL=AIAgentIdentityClient.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BhZ2VudGljLXRydXN0LzgwMDQtZXh0LXNkay9kaXN0L0FJQWdlbnRJZGVudGl0eUNsaWVudC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDOEQ7QUFDTTtBQUNlO0FBQ3BCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixnREFBTztBQUMxQjtBQUNBLG1CQUFtQixvREFBVztBQUM5QjtBQUNBLG1CQUFtQix3REFBZTtBQUNsQztBQUNBLDRDQUE0QyxRQUFRO0FBQ3BELG1CQUFtQixnREFBTztBQUMxQjtBQUNBO0FBQ08sb0NBQW9DLHVFQUFrQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLHdFQUFtQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHdEQUFrQixHQUFHLGtCQUFrQiwwQ0FBSSxrQkFBa0I7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyx3RUFBbUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsd0RBQW1CO0FBQ3BDO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsZUFBZSxpREFBVztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwwQkFBMEI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsaUJBQWlCLHdEQUFtQjtBQUNwQztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLCtCQUErQixJQUFJLDBDQUEwQztBQUMvSTtBQUNBO0FBQ0E7QUFDQSxjQUFjLCtCQUErQjtBQUM3QyxjQUFjLDBDQUEwQztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHdEQUFtQjtBQUNwQztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHdEQUFtQjtBQUNwQztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRCxzRkFBc0Y7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MseUJBQXlCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QywwQkFBMEI7QUFDbkUsaURBQWlELGtDQUFrQztBQUNuRjtBQUNBO0FBQ0EscUNBQXFDLHNCQUFzQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUsdUJBQXVCO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtGQUFrRixpQkFBaUIsR0FBRztBQUM5SDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELEdBQUc7QUFDbkQ7QUFDQTtBQUNBLG9DQUFvQyxHQUFHO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHdEQUFtQjtBQUN4QztBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9iYXJiL2FhL0Fzc29jaWF0ZWRBY2NvdW50cy9ub2RlX21vZHVsZXMvQGFnZW50aWMtdHJ1c3QvODAwNC1leHQtc2RrL2Rpc3QvQUlBZ2VudElkZW50aXR5Q2xpZW50LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQWdlbnRpYyBUcnVzdCBTREsgLSBJZGVudGl0eSBDbGllbnRcbiAqIEV4dGVuZHMgdGhlIGJhc2UgRVJDLTgwMDQgSWRlbnRpdHlDbGllbnQgd2l0aCBBQS1jZW50cmljIGhlbHBlcnMuXG4gKlxuICogVXNlcyBBY2NvdW50UHJvdmlkZXIgKFBvcnRzICYgQWRhcHRlcnMgcGF0dGVybikgZm9yIGNoYWluIEkvTy5cbiAqL1xuaW1wb3J0IHsgY3JlYXRlUHVibGljQ2xpZW50LCBodHRwLCBoZXhUb1N0cmluZywgfSBmcm9tICd2aWVtJztcbmltcG9ydCB7IHNlcG9saWEsIGJhc2VTZXBvbGlhLCBvcHRpbWlzbVNlcG9saWEgfSBmcm9tICd2aWVtL2NoYWlucyc7XG5pbXBvcnQgeyBCYXNlSWRlbnRpdHlDbGllbnQsIFZpZW1BY2NvdW50UHJvdmlkZXIsIH0gZnJvbSAnQGFnZW50aWMtdHJ1c3QvODAwNC1zZGsnO1xuaW1wb3J0IElkZW50aXR5UmVnaXN0cnlBQkkgZnJvbSAnLi9hYmlzL0lkZW50aXR5UmVnaXN0cnkuanNvbic7XG5mdW5jdGlvbiBnZXRDaGFpbkJ5SWQoY2hhaW5JZCkge1xuICAgIHN3aXRjaCAoY2hhaW5JZCkge1xuICAgICAgICBjYXNlIDExMTU1MTExOiAvLyBFVEggU2Vwb2xpYVxuICAgICAgICAgICAgcmV0dXJuIHNlcG9saWE7XG4gICAgICAgIGNhc2UgODQ1MzI6IC8vIEJhc2UgU2Vwb2xpYVxuICAgICAgICAgICAgcmV0dXJuIGJhc2VTZXBvbGlhO1xuICAgICAgICBjYXNlIDExMTU1NDIwOiAvLyBPcHRpbWlzbSBTZXBvbGlhXG4gICAgICAgICAgICByZXR1cm4gb3B0aW1pc21TZXBvbGlhO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgY29uc29sZS53YXJuKGBVbmtub3duIGNoYWluSWQgJHtjaGFpbklkfSwgZGVmYXVsdGluZyB0byBFVEggU2Vwb2xpYWApO1xuICAgICAgICAgICAgcmV0dXJuIHNlcG9saWE7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIEFJQWdlbnRJZGVudGl0eUNsaWVudCBleHRlbmRzIEJhc2VJZGVudGl0eUNsaWVudCB7XG4gICAgY2hhaW4gPSBudWxsO1xuICAgIGlkZW50aXR5UmVnaXN0cnlBZGRyZXNzO1xuICAgIHB1YmxpY0NsaWVudCA9IG51bGw7XG4gICAgd2FsbGV0Q2xpZW50ID0gbnVsbDtcbiAgICAvLyBhY2NvdW50UHJvdmlkZXIgaXMgcHJvdGVjdGVkIGluIEJhc2VJZGVudGl0eUNsaWVudCwgc28gd2UgbmVlZCB0byBrZWVwIGl0IGFjY2Vzc2libGVcbiAgICBhY2NvdW50UHJvdmlkZXI7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICBsZXQgYWNjb3VudFByb3ZpZGVyO1xuICAgICAgICBsZXQgY2hhaW4gPSBudWxsO1xuICAgICAgICBsZXQgcHVibGljQ2xpZW50ID0gbnVsbDtcbiAgICAgICAgbGV0IHdhbGxldENsaWVudCA9IG51bGw7XG4gICAgICAgIGxldCBpZGVudGl0eVJlZ2lzdHJ5QWRkcmVzcztcbiAgICAgICAgaWYgKCdhY2NvdW50UHJvdmlkZXInIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIC8vIE9wdGlvbiAxOiBVc2UgcHJvdmlkZWQgQWNjb3VudFByb3ZpZGVyIChyZWNvbW1lbmRlZClcbiAgICAgICAgICAgIGFjY291bnRQcm92aWRlciA9IG9wdGlvbnMuYWNjb3VudFByb3ZpZGVyO1xuICAgICAgICAgICAgaWRlbnRpdHlSZWdpc3RyeUFkZHJlc3MgPSBvcHRpb25zLmlkZW50aXR5UmVnaXN0cnlBZGRyZXNzO1xuICAgICAgICAgICAgLy8gVHJ5IHRvIGV4dHJhY3QgcHVibGljQ2xpZW50IGZyb20gQWNjb3VudFByb3ZpZGVyIGlmIGl0J3MgYSBWaWVtQWNjb3VudFByb3ZpZGVyXG4gICAgICAgICAgICBjb25zdCB2aWVtUHJvdmlkZXIgPSBhY2NvdW50UHJvdmlkZXI7XG4gICAgICAgICAgICBpZiAodmllbVByb3ZpZGVyLnB1YmxpY0NsaWVudCkge1xuICAgICAgICAgICAgICAgIHB1YmxpY0NsaWVudCA9IHZpZW1Qcm92aWRlci5wdWJsaWNDbGllbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmllbVByb3ZpZGVyLndhbGxldENsaWVudCkge1xuICAgICAgICAgICAgICAgIHdhbGxldENsaWVudCA9IHZpZW1Qcm92aWRlci53YWxsZXRDbGllbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmllbVByb3ZpZGVyLmNoYWluQ29uZmlnPy5jaGFpbikge1xuICAgICAgICAgICAgICAgIGNoYWluID0gdmllbVByb3ZpZGVyLmNoYWluQ29uZmlnLmNoYWluO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCdwdWJsaWNDbGllbnQnIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIC8vIE9wdGlvbiAyOiBVc2UgdmllbSBjbGllbnRzIGRpcmVjdGx5IChzaW1wbGVzdCwgbmF0aXZlIHZpZW0pXG4gICAgICAgICAgICBwdWJsaWNDbGllbnQgPSBvcHRpb25zLnB1YmxpY0NsaWVudDtcbiAgICAgICAgICAgIHdhbGxldENsaWVudCA9IG9wdGlvbnMud2FsbGV0Q2xpZW50ID8/IG51bGw7XG4gICAgICAgICAgICBpZGVudGl0eVJlZ2lzdHJ5QWRkcmVzcyA9IG9wdGlvbnMuaWRlbnRpdHlSZWdpc3RyeUFkZHJlc3M7XG4gICAgICAgICAgICAvLyBDcmVhdGUgQ2hhaW5Db25maWdcbiAgICAgICAgICAgIGNvbnN0IGNoYWluQ29uZmlnID0gb3B0aW9ucy5jaGFpbkNvbmZpZyB8fCB7XG4gICAgICAgICAgICAgICAgaWQ6IHB1YmxpY0NsaWVudC5jaGFpbj8uaWQgfHwgMTExNTUxMTEsXG4gICAgICAgICAgICAgICAgcnBjVXJsOiBwdWJsaWNDbGllbnQudHJhbnNwb3J0Py51cmwgfHwgJycsXG4gICAgICAgICAgICAgICAgbmFtZTogcHVibGljQ2xpZW50LmNoYWluPy5uYW1lIHx8ICdVbmtub3duJyxcbiAgICAgICAgICAgICAgICBjaGFpbjogcHVibGljQ2xpZW50LmNoYWluIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyBDcmVhdGUgVmllbUFjY291bnRQcm92aWRlciBmcm9tIHRoZSBjbGllbnRzXG4gICAgICAgICAgICBhY2NvdW50UHJvdmlkZXIgPSBuZXcgVmllbUFjY291bnRQcm92aWRlcih7XG4gICAgICAgICAgICAgICAgcHVibGljQ2xpZW50LFxuICAgICAgICAgICAgICAgIHdhbGxldENsaWVudDogd2FsbGV0Q2xpZW50ID8/IG51bGwsXG4gICAgICAgICAgICAgICAgYWNjb3VudDogd2FsbGV0Q2xpZW50Py5hY2NvdW50LFxuICAgICAgICAgICAgICAgIGNoYWluQ29uZmlnLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBPcHRpb24gMzogTGVnYWN5IHBhdHRlcm4gLSBjcmVhdGUgZnJvbSBjaGFpbklkL3JwY1VybFxuICAgICAgICAgICAgY2hhaW4gPSBnZXRDaGFpbkJ5SWQob3B0aW9ucy5jaGFpbklkKTtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgLSB2aWVtIHZlcnNpb24gY29tcGF0aWJpbGl0eSBpc3N1ZVxuICAgICAgICAgICAgcHVibGljQ2xpZW50ID0gY3JlYXRlUHVibGljQ2xpZW50KHsgY2hhaW4sIHRyYW5zcG9ydDogaHR0cChvcHRpb25zLnJwY1VybCkgfSk7XG4gICAgICAgICAgICB3YWxsZXRDbGllbnQgPSBvcHRpb25zLndhbGxldENsaWVudCA/PyBudWxsO1xuICAgICAgICAgICAgLy8gQ3JlYXRlIENoYWluQ29uZmlnXG4gICAgICAgICAgICBjb25zdCBjaGFpbkNvbmZpZyA9IHtcbiAgICAgICAgICAgICAgICBpZDogb3B0aW9ucy5jaGFpbklkLFxuICAgICAgICAgICAgICAgIHJwY1VybDogb3B0aW9ucy5ycGNVcmwsXG4gICAgICAgICAgICAgICAgbmFtZTogY2hhaW4ubmFtZSxcbiAgICAgICAgICAgICAgICBjaGFpbjogY2hhaW4sXG4gICAgICAgICAgICAgICAgYnVuZGxlclVybDogb3B0aW9ucy5idW5kbGVyVXJsLFxuICAgICAgICAgICAgICAgIHBheW1hc3RlclVybDogb3B0aW9ucy5wYXltYXN0ZXJVcmwsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gQ3JlYXRlIFZpZW1BY2NvdW50UHJvdmlkZXJcbiAgICAgICAgICAgIGFjY291bnRQcm92aWRlciA9IG5ldyBWaWVtQWNjb3VudFByb3ZpZGVyKHtcbiAgICAgICAgICAgICAgICBwdWJsaWNDbGllbnQsXG4gICAgICAgICAgICAgICAgd2FsbGV0Q2xpZW50OiB3YWxsZXRDbGllbnQgPz8gbnVsbCxcbiAgICAgICAgICAgICAgICBhY2NvdW50OiBvcHRpb25zLmFjY291bnQgfHwgd2FsbGV0Q2xpZW50Py5hY2NvdW50LFxuICAgICAgICAgICAgICAgIGNoYWluQ29uZmlnLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZGVudGl0eVJlZ2lzdHJ5QWRkcmVzcyA9IG9wdGlvbnMuaWRlbnRpdHlSZWdpc3RyeUFkZHJlc3M7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUGFzcyBhY2NvdW50UHJvdmlkZXIgdG8gQmFzZUlkZW50aXR5Q2xpZW50XG4gICAgICAgIHN1cGVyKGFjY291bnRQcm92aWRlciwgaWRlbnRpdHlSZWdpc3RyeUFkZHJlc3MpO1xuICAgICAgICB0aGlzLmNoYWluID0gY2hhaW47XG4gICAgICAgIHRoaXMucHVibGljQ2xpZW50ID0gcHVibGljQ2xpZW50O1xuICAgICAgICB0aGlzLndhbGxldENsaWVudCA9IHdhbGxldENsaWVudDtcbiAgICAgICAgdGhpcy5pZGVudGl0eVJlZ2lzdHJ5QWRkcmVzcyA9IGlkZW50aXR5UmVnaXN0cnlBZGRyZXNzO1xuICAgICAgICB0aGlzLmFjY291bnRQcm92aWRlciA9IGFjY291bnRQcm92aWRlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IG1ldGFkYXRhIHVzaW5nIEFjY291bnRQcm92aWRlclxuICAgICAqL1xuICAgIGFzeW5jIGdldE1ldGFkYXRhKGFnZW50SWQsIGtleSkge1xuICAgICAgICBjb25zdCBieXRlcyA9IGF3YWl0IHRoaXMuYWNjb3VudFByb3ZpZGVyLmNhbGwoe1xuICAgICAgICAgICAgdG86IHRoaXMuaWRlbnRpdHlSZWdpc3RyeUFkZHJlc3MsXG4gICAgICAgICAgICBhYmk6IElkZW50aXR5UmVnaXN0cnlBQkksXG4gICAgICAgICAgICBmdW5jdGlvbk5hbWU6ICdnZXRNZXRhZGF0YScsXG4gICAgICAgICAgICBhcmdzOiBbYWdlbnRJZCwga2V5XSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBoZXhUb1N0cmluZyhieXRlcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhbGwgYXZhaWxhYmxlIG1ldGFkYXRhIGZyb20gdGhlIEFnZW50IE5GVCBieSB0cnlpbmcgYSBjb21wcmVoZW5zaXZlIGxpc3Qgb2YgY29tbW9uIGtleXMuXG4gICAgICogUmV0dXJucyBhIHJlY29yZCBvZiBhbGwgbWV0YWRhdGEga2V5LXZhbHVlIHBhaXJzIHRoYXQgZXhpc3Qgb24tY2hhaW4uXG4gICAgICpcbiAgICAgKiBQcm9jZXNzZXMgcmVxdWVzdHMgaW4gYmF0Y2hlcyB0byBhdm9pZCByYXRlIGxpbWl0aW5nLlxuICAgICAqXG4gICAgICogSU1QT1JUQU5UOiBUaGlzIG1ldGhvZCBtYWtlcyBtYW55IG9uLWNoYWluIFJQQyBjYWxscyBhbmQgc2hvdWxkIE9OTFkgYmUgdXNlZFxuICAgICAqIGZvciBkZXRhaWxlZCBhZ2VudCB2aWV3cyAodmlhIGxvYWRBZ2VudERldGFpbCkuIEl0IHNob3VsZCBOT1QgYmUgY2FsbGVkIGZvclxuICAgICAqIGxpc3QgcXVlcmllcyAtIHVzZSBHcmFwaFFML2Rpc2NvdmVyeSBkYXRhIGluc3RlYWQuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0QWxsTWV0YWRhdGEoYWdlbnRJZCkge1xuICAgICAgICAvLyBDb21wcmVoZW5zaXZlIGxpc3Qgb2YgY29tbW9uIG1ldGFkYXRhIGtleXMgdG8gY2hlY2tcbiAgICAgICAgY29uc3QgTUVUQURBVEFfS0VZUyA9IFtcbiAgICAgICAgICAgIC8vIFN0YW5kYXJkIEVSQy04MDA0IGZpZWxkc1xuICAgICAgICAgICAgJ2FnZW50TmFtZScsXG4gICAgICAgICAgICAnYWdlbnRBY2NvdW50JyxcbiAgICAgICAgICAgICdkZXNjcmlwdGlvbicsXG4gICAgICAgICAgICAnaW1hZ2UnLFxuICAgICAgICAgICAgJ2V4dGVybmFsX3VybCcsXG4gICAgICAgICAgICAndmVyc2lvbicsXG4gICAgICAgICAgICAndHlwZScsXG4gICAgICAgICAgICAnbmFtZScsXG4gICAgICAgICAgICAndXJsJyxcbiAgICAgICAgICAgICd3ZWJzaXRlJyxcbiAgICAgICAgICAgICdlbWFpbCcsXG4gICAgICAgICAgICAndHdpdHRlcicsXG4gICAgICAgICAgICAnZ2l0aHViJyxcbiAgICAgICAgICAgICdkaXNjb3JkJyxcbiAgICAgICAgICAgICd0ZWxlZ3JhbScsXG4gICAgICAgICAgICAnbWV0YWRhdGEnLFxuICAgICAgICAgICAgJ2F0dHJpYnV0ZXMnLFxuICAgICAgICAgICAgJ2NyZWF0ZWRBdCcsXG4gICAgICAgICAgICAndXBkYXRlZEF0JyxcbiAgICAgICAgICAgIC8vIEFkZGl0aW9uYWwgY29tbW9uIGZpZWxkc1xuICAgICAgICAgICAgJ3RhZ3MnLFxuICAgICAgICAgICAgJ2dsYlVybCcsXG4gICAgICAgICAgICAnZ2xiQ2lkJyxcbiAgICAgICAgICAgICdnbGJGaWxlTmFtZScsXG4gICAgICAgICAgICAnZ2xiU291cmNlJyxcbiAgICAgICAgICAgICdhZ2VudFdhbGxldCcsXG4gICAgICAgICAgICAnY2FwYWJpbGl0aWVzJyxcbiAgICAgICAgICAgICdyb2xlJyxcbiAgICAgICAgICAgICdyYXRpbmcnLFxuICAgICAgICAgICAgJ3ByaWNpbmcnLFxuICAgICAgICAgICAgJ3BrYScsXG4gICAgICAgICAgICAndXJpJyxcbiAgICAgICAgICAgICdlbmRwb2ludHMnLFxuICAgICAgICAgICAgJ3N1cHBvcnRlZFRydXN0JyxcbiAgICAgICAgICAgICdyZWdpc3RyYXRpb25zJyxcbiAgICAgICAgICAgICdhZ2VudFVybCcsXG4gICAgICAgICAgICAnY29udHJhY3RBZGRyZXNzJyxcbiAgICAgICAgICAgICdkaWQnLFxuICAgICAgICAgICAgJ2RpZElkZW50aXR5JyxcbiAgICAgICAgICAgICdkaWRBY2NvdW50JyxcbiAgICAgICAgICAgICdkaWROYW1lJyxcbiAgICAgICAgICAgICdhY3RpdmUnLFxuICAgICAgICAgICAgJ3g0MDJzdXBwb3J0JyxcbiAgICAgICAgICAgICdtY3AnLFxuICAgICAgICAgICAgJ2EyYUVuZHBvaW50JyxcbiAgICAgICAgICAgICdtY3BFbmRwb2ludCcsXG4gICAgICAgICAgICAnZW5zRW5kcG9pbnQnLFxuICAgICAgICAgICAgJ2FnZW50QWNjb3VudEVuZHBvaW50JyxcbiAgICAgICAgXTtcbiAgICAgICAgY29uc3QgbWV0YWRhdGEgPSB7fTtcbiAgICAgICAgLy8gUHJvY2VzcyByZXF1ZXN0cyBpbiBiYXRjaGVzIHRvIGF2b2lkIHJhdGUgbGltaXRpbmdcbiAgICAgICAgLy8gQmF0Y2ggc2l6ZTogNSByZXF1ZXN0cyBhdCBhIHRpbWVcbiAgICAgICAgLy8gRGVsYXkgYmV0d2VlbiBiYXRjaGVzOiAyMDBtc1xuICAgICAgICBjb25zdCBCQVRDSF9TSVpFID0gNTtcbiAgICAgICAgY29uc3QgQkFUQ0hfREVMQVlfTVMgPSAyMDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTUVUQURBVEFfS0VZUy5sZW5ndGg7IGkgKz0gQkFUQ0hfU0laRSkge1xuICAgICAgICAgICAgY29uc3QgYmF0Y2ggPSBNRVRBREFUQV9LRVlTLnNsaWNlKGksIGkgKyBCQVRDSF9TSVpFKTtcbiAgICAgICAgICAgIC8vIFByb2Nlc3MgYmF0Y2ggaW4gcGFyYWxsZWxcbiAgICAgICAgICAgIGNvbnN0IGJhdGNoUHJvbWlzZXMgPSBiYXRjaC5tYXAoYXN5bmMgKGtleSkgPT4ge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgdGhpcy5nZXRNZXRhZGF0YShhZ2VudElkLCBrZXkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgJiYgdmFsdWUudHJpbSgpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGtleSwgdmFsdWUgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIGl0J3MgYSByYXRlIGxpbWl0IGVycm9yICg0MjkpXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yTWVzc2FnZS5pbmNsdWRlcygnNDI5JykgfHwgZXJyb3JNZXNzYWdlLmluY2x1ZGVzKCdUb28gTWFueSBSZXF1ZXN0cycpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGb3IgcmF0ZSBsaW1pdCBlcnJvcnMsIHdhaXQgbG9uZ2VyIGJlZm9yZSByZXRyeWluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDEwMDApKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBhd2FpdCB0aGlzLmdldE1ldGFkYXRhKGFnZW50SWQsIGtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICYmIHZhbHVlLnRyaW0oKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGtleSwgdmFsdWUgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAocmV0cnlFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNpbGVudGx5IHNraXAgb24gcmV0cnkgZmFpbHVyZVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFNpbGVudGx5IHNraXAgaWYgbWV0YWRhdGEga2V5IGRvZXNuJ3QgZXhpc3Qgb3IgZmFpbHNcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBiYXRjaFJlc3VsdHMgPSBhd2FpdCBQcm9taXNlLmFsbChiYXRjaFByb21pc2VzKTtcbiAgICAgICAgICAgIC8vIENvbGxlY3Qgc3VjY2Vzc2Z1bCByZXN1bHRzIGZyb20gdGhpcyBiYXRjaFxuICAgICAgICAgICAgZm9yIChjb25zdCByZXN1bHQgb2YgYmF0Y2hSZXN1bHRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YVtyZXN1bHQua2V5XSA9IHJlc3VsdC52YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBEZWxheSBiZWZvcmUgbmV4dCBiYXRjaCAoZXhjZXB0IGZvciB0aGUgbGFzdCBiYXRjaClcbiAgICAgICAgICAgIGlmIChpICsgQkFUQ0hfU0laRSA8IE1FVEFEQVRBX0tFWVMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIEJBVENIX0RFTEFZX01TKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1ldGFkYXRhO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbmNvZGUgZnVuY3Rpb24gY2FsbCBkYXRhIHVzaW5nIEFjY291bnRQcm92aWRlclxuICAgICAqL1xuICAgIGFzeW5jIGVuY29kZUZ1bmN0aW9uRGF0YShhYmksIGZ1bmN0aW9uTmFtZSwgYXJncykge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5hY2NvdW50UHJvdmlkZXIuZW5jb2RlRnVuY3Rpb25EYXRhKHtcbiAgICAgICAgICAgIGFiaSxcbiAgICAgICAgICAgIGZ1bmN0aW9uTmFtZSxcbiAgICAgICAgICAgIGFyZ3MsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMZWdhY3kgbWV0aG9kIC0gZGVsZWdhdGVzIHRvIGVuY29kZUZ1bmN0aW9uRGF0YVxuICAgICAqIEBkZXByZWNhdGVkIFVzZSBlbmNvZGVGdW5jdGlvbkRhdGEgaW5zdGVhZFxuICAgICAqL1xuICAgIGVuY29kZUNhbGwoYWJpLCBmdW5jdGlvbk5hbWUsIGFyZ3MpIHtcbiAgICAgICAgLy8gVGhpcyBpcyBhIHN5bmNocm9ub3VzIG1ldGhvZCwgYnV0IGVuY29kZUZ1bmN0aW9uRGF0YSBpcyBhc3luY1xuICAgICAgICAvLyBGb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgd2UnbGwgdXNlIGV0aGVycyBmb3Igbm93XG4gICAgICAgIC8vIFRPRE86IENvbnNpZGVyIG1ha2luZyB0aGlzIGFzeW5jIG9yIHJlbW92aW5nIGl0XG4gICAgICAgIGNvbnN0IHsgZXRoZXJzIH0gPSByZXF1aXJlKCdldGhlcnMnKTtcbiAgICAgICAgY29uc3QgaWZhY2UgPSBuZXcgZXRoZXJzLkludGVyZmFjZShhYmkpO1xuICAgICAgICByZXR1cm4gaWZhY2UuZW5jb2RlRnVuY3Rpb25EYXRhKGZ1bmN0aW9uTmFtZSwgYXJncyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuY29kZSByZWdpc3RlciBjYWxsZGF0YSB3aXRob3V0IHNlbmRpbmcgKGZvciBidW5kbGVyL0FBIC0gbGlrZSBFQVMgU0RLIHBhdHRlcm4pXG4gICAgICogVGhpcyBvdmVycmlkZSBleGlzdHMgaW4gdGhlIEFnZW50aWMgVHJ1c3QgU0RLIHRvIGtlZXAgQUEgaGVscGVycyBoZXJlLlxuICAgICAqL1xuICAgIGFzeW5jIGVuY29kZVJlZ2lzdGVyV2l0aE1ldGFkYXRhKHRva2VuVXJpLCBtZXRhZGF0YSA9IFtdKSB7XG4gICAgICAgIC8vIEZvcm1hdCBtZXRhZGF0YTogY29udmVydCBzdHJpbmcgdmFsdWVzIHRvIGhleCBzdHJpbmdzIChWaWVtIGV4cGVjdHMgaGV4IGZvciBieXRlcylcbiAgICAgICAgY29uc3QgbWV0YWRhdGFGb3JtYXR0ZWQgPSBtZXRhZGF0YS5tYXAobSA9PiB7XG4gICAgICAgICAgICAvLyBVc2Ugc3RyaW5nVG9CeXRlcyBmcm9tIGJhc2UgY2xhc3MgKHZpYSBpbmhlcml0YW5jZSlcbiAgICAgICAgICAgIGNvbnN0IGJ5dGVzID0gdGhpcy5zdHJpbmdUb0J5dGVzKG0udmFsdWUpO1xuICAgICAgICAgICAgLy8gQ29udmVydCB0byBoZXggc3RyaW5nIChWaWVtIHJlcXVpcmVzIGhleCBzdHJpbmdzLCBub3QgVWludDhBcnJheSlcbiAgICAgICAgICAgIGNvbnN0IGhleFN0cmluZyA9IHRoaXMuYnl0ZXNUb0hleChieXRlcyk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZWQgQUJJIHVzZXMgc3RydWN0IGZpZWxkczogeyBtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSB9XG4gICAgICAgICAgICAgICAgbWV0YWRhdGFLZXk6IG0ua2V5LFxuICAgICAgICAgICAgICAgIG1ldGFkYXRhVmFsdWU6IGhleFN0cmluZyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBVc2UgQWNjb3VudFByb3ZpZGVyJ3MgZW5jb2RlRnVuY3Rpb25EYXRhXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmFjY291bnRQcm92aWRlci5lbmNvZGVGdW5jdGlvbkRhdGEoe1xuICAgICAgICAgICAgYWJpOiBJZGVudGl0eVJlZ2lzdHJ5QUJJLFxuICAgICAgICAgICAgZnVuY3Rpb25OYW1lOiAncmVnaXN0ZXInLFxuICAgICAgICAgICAgYXJnczogW3Rva2VuVXJpLCBtZXRhZGF0YUZvcm1hdHRlZF0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBlbmNvZGVSZWdpc3RlcihuYW1lLCBhZ2VudEFjY291bnQsIHRva2VuVXJpKSB7XG4gICAgICAgIGNvbnNvbGUuaW5mbyhcIm5hbWU6IFwiLCBuYW1lKTtcbiAgICAgICAgY29uc29sZS5pbmZvKFwiYWdlbnRBY2NvdW50OiBcIiwgYWdlbnRBY2NvdW50KTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZW5jb2RlUmVnaXN0ZXJXaXRoTWV0YWRhdGEodG9rZW5VcmksIFt7IGtleTogJ2FnZW50TmFtZScsIHZhbHVlOiBuYW1lIH0sIHsga2V5OiAnYWdlbnRBY2NvdW50JywgdmFsdWU6IGFnZW50QWNjb3VudCB9XSk7XG4gICAgfVxuICAgIGFzeW5jIHByZXBhcmVSZWdpc3RlckNhbGxzKG5hbWUsIGFnZW50QWNjb3VudCwgdG9rZW5VcmksIGFkZGl0aW9uYWxNZXRhZGF0YSkge1xuICAgICAgICBjb25zdCBtZXRhZGF0YSA9IFtcbiAgICAgICAgICAgIHsga2V5OiAnYWdlbnROYW1lJywgdmFsdWU6IG5hbWUgfSxcbiAgICAgICAgICAgIHsga2V5OiAnYWdlbnRBY2NvdW50JywgdmFsdWU6IGFnZW50QWNjb3VudCB9LFxuICAgICAgICAgICAgLi4uKGFkZGl0aW9uYWxNZXRhZGF0YSB8fCBbXSksXG4gICAgICAgIF07XG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLmVuY29kZVJlZ2lzdGVyV2l0aE1ldGFkYXRhKHRva2VuVXJpLCBtZXRhZGF0YSk7XG4gICAgICAgIGNvbnN0IGNhbGxzID0gW107XG4gICAgICAgIGNhbGxzLnB1c2goe1xuICAgICAgICAgICAgdG86IHRoaXMuaWRlbnRpdHlSZWdpc3RyeUFkZHJlc3MsXG4gICAgICAgICAgICBkYXRhOiBkYXRhXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4geyBjYWxscyB9O1xuICAgIH1cbiAgICBhc3luYyBlbmNvZGVTZXRSZWdpc3RyYXRpb25VcmkoYWdlbnRJZCwgdXJpKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLmFjY291bnRQcm92aWRlci5lbmNvZGVGdW5jdGlvbkRhdGEoe1xuICAgICAgICAgICAgYWJpOiBJZGVudGl0eVJlZ2lzdHJ5QUJJLFxuICAgICAgICAgICAgLy8gVXBkYXRlZCBBQkkgbmFtZSBpcyBzZXRBZ2VudFVSSSAoY2FwaXRhbCBVUkkpXG4gICAgICAgICAgICBmdW5jdGlvbk5hbWU6ICdzZXRBZ2VudFVSSScsXG4gICAgICAgICAgICBhcmdzOiBbYWdlbnRJZCwgdXJpXSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICBhc3luYyBwcmVwYXJlU2V0UmVnaXN0cmF0aW9uVXJpQ2FsbHMoYWdlbnRJZCwgdXJpKSB7XG4gICAgICAgIGNvbnN0IGNhbGxzID0gW107XG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLmVuY29kZVNldFJlZ2lzdHJhdGlvblVyaShhZ2VudElkLCB1cmkpO1xuICAgICAgICBjYWxscy5wdXNoKHtcbiAgICAgICAgICAgIHRvOiB0aGlzLmlkZW50aXR5UmVnaXN0cnlBZGRyZXNzLFxuICAgICAgICAgICAgZGF0YTogZGF0YVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHsgY2FsbHMgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW5jb2RlIGBzZXRBZ2VudFdhbGxldGAgY2FsbGRhdGEgd2l0aG91dCBzZW5kaW5nLlxuICAgICAqXG4gICAgICogSWRlbnRpdHlSZWdpc3RyeSBBQkk6XG4gICAgICogc2V0QWdlbnRXYWxsZXQodWludDI1NiBhZ2VudElkLCBhZGRyZXNzIG5ld1dhbGxldCwgdWludDI1NiBkZWFkbGluZSwgYnl0ZXMgc2lnbmF0dXJlKVxuICAgICAqL1xuICAgIGFzeW5jIGVuY29kZVNldEFnZW50V2FsbGV0KGFnZW50SWQsIG5ld1dhbGxldCwgZGVhZGxpbmUsIHNpZ25hdHVyZSkge1xuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy5hY2NvdW50UHJvdmlkZXIuZW5jb2RlRnVuY3Rpb25EYXRhKHtcbiAgICAgICAgICAgIGFiaTogSWRlbnRpdHlSZWdpc3RyeUFCSSxcbiAgICAgICAgICAgIGZ1bmN0aW9uTmFtZTogJ3NldEFnZW50V2FsbGV0JyxcbiAgICAgICAgICAgIGFyZ3M6IFthZ2VudElkLCBuZXdXYWxsZXQsIGRlYWRsaW5lLCBzaWduYXR1cmVdLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIGFzeW5jIHByZXBhcmVTZXRBZ2VudFdhbGxldENhbGxzKGFnZW50SWQsIG5ld1dhbGxldCwgZGVhZGxpbmUsIHNpZ25hdHVyZSkge1xuICAgICAgICBjb25zdCBjYWxscyA9IFtdO1xuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy5lbmNvZGVTZXRBZ2VudFdhbGxldChhZ2VudElkLCBuZXdXYWxsZXQsIGRlYWRsaW5lLCBzaWduYXR1cmUpO1xuICAgICAgICBjYWxscy5wdXNoKHtcbiAgICAgICAgICAgIHRvOiB0aGlzLmlkZW50aXR5UmVnaXN0cnlBZGRyZXNzLFxuICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7IGNhbGxzIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByZXBhcmUgYSBjb21wbGV0ZSB0cmFuc2FjdGlvbiBmb3IgY2xpZW50LXNpZGUgc2lnbmluZyAoc2ltaWxhciB0byBwcmVwYXJlQ2FsbCBmb3IgYnVuZGxlcnMpXG4gICAgICogQWxsIEV0aGVyZXVtIGxvZ2ljIChlbmNvZGluZywgZ2FzIGVzdGltYXRpb24sIG5vbmNlKSBpcyBoYW5kbGVkIHNlcnZlci1zaWRlXG4gICAgICogQ2xpZW50IG9ubHkgbmVlZHMgdG8gc2lnbiBhbmQgc2VuZCB3aXRoIE1ldGFNYXNrXG4gICAgICogQHBhcmFtIHRva2VuVXJpIC0gSVBGUyB0b2tlbiBVUkkgZm9yIHRoZSBhZ2VudCByZWdpc3RyYXRpb25cbiAgICAgKiBAcGFyYW0gbWV0YWRhdGEgLSBNZXRhZGF0YSBlbnRyaWVzIGZvciB0aGUgYWdlbnRcbiAgICAgKiBAcGFyYW0gZnJvbUFkZHJlc3MgLSBBZGRyZXNzIHRoYXQgd2lsbCBzaWduIHRoZSB0cmFuc2FjdGlvbiAob25seSBhZGRyZXNzIG5lZWRlZCwgbm8gY2xpZW50KVxuICAgICAqIEByZXR1cm5zIFByZXBhcmVkIHRyYW5zYWN0aW9uIG9iamVjdCByZWFkeSBmb3IgY2xpZW50LXNpZGUgc2lnbmluZ1xuICAgICAqL1xuICAgIGFzeW5jIHByZXBhcmVSZWdpc3RlclRyYW5zYWN0aW9uKHRva2VuVXJpLCBtZXRhZGF0YSwgZnJvbUFkZHJlc3MpIHtcbiAgICAgICAgLy8gRW5jb2RlIHRoZSB0cmFuc2FjdGlvbiBkYXRhXG4gICAgICAgIGNvbnN0IGVuY29kZWREYXRhID0gYXdhaXQgdGhpcy5lbmNvZGVSZWdpc3RlcldpdGhNZXRhZGF0YSh0b2tlblVyaSwgbWV0YWRhdGEpO1xuICAgICAgICAvLyBHZXQgY2hhaW4gSUQgdXNpbmcgQWNjb3VudFByb3ZpZGVyXG4gICAgICAgIGNvbnN0IGNoYWluSWQgPSBhd2FpdCB0aGlzLmFjY291bnRQcm92aWRlci5jaGFpbklkKCk7XG4gICAgICAgIC8vIEluaXRpYWxpemUgZ2FzIGVzdGltYXRpb24gdmFyaWFibGVzXG4gICAgICAgIGxldCBnYXNFc3RpbWF0ZTtcbiAgICAgICAgbGV0IGdhc1ByaWNlO1xuICAgICAgICBsZXQgbWF4RmVlUGVyR2FzO1xuICAgICAgICBsZXQgbWF4UHJpb3JpdHlGZWVQZXJHYXM7XG4gICAgICAgIGxldCBub25jZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIEdldCBjdXJyZW50IGJsb2NrIGRhdGEgdG8gY2hlY2sgZm9yIEVJUC0xNTU5IHN1cHBvcnRcbiAgICAgICAgICAgIGNvbnN0IGJsb2NrRGF0YSA9IGF3YWl0IHRoaXMuYWNjb3VudFByb3ZpZGVyLmdldEJsb2NrKCdsYXRlc3QnKTtcbiAgICAgICAgICAgIC8vIFByZWZlciBFSVAtMTU1OSAobWF4RmVlUGVyR2FzL21heFByaW9yaXR5RmVlUGVyR2FzKSBpZiBhdmFpbGFibGVcbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSBmYWxsIGJhY2sgdG8gbGVnYWN5IGdhc1ByaWNlXG4gICAgICAgICAgICBpZiAoYmxvY2tEYXRhICYmICdiYXNlRmVlUGVyR2FzJyBpbiBibG9ja0RhdGEgJiYgYmxvY2tEYXRhLmJhc2VGZWVQZXJHYXMpIHtcbiAgICAgICAgICAgICAgICAvLyBFSVAtMTU1OTogVXNlIG1heEZlZVBlckdhcyBhbmQgbWF4UHJpb3JpdHlGZWVQZXJHYXNcbiAgICAgICAgICAgICAgICAvLyBTZXQgYSByZWFzb25hYmxlIHByaW9yaXR5IGZlZSAoMS0yIGd3ZWkgdHlwaWNhbGx5KVxuICAgICAgICAgICAgICAgIC8vIG1heEZlZVBlckdhcyBzaG91bGQgYmUgYmFzZUZlZVBlckdhcyArIG1heFByaW9yaXR5RmVlUGVyR2FzICsgYnVmZmVyXG4gICAgICAgICAgICAgICAgbWF4UHJpb3JpdHlGZWVQZXJHYXMgPSAxMDAwMDAwMDAwbjsgLy8gMSBnd2VpIGFzIHByaW9yaXR5IGZlZVxuICAgICAgICAgICAgICAgIG1heEZlZVBlckdhcyA9IChibG9ja0RhdGEuYmFzZUZlZVBlckdhcyAqIDJuKSArIG1heFByaW9yaXR5RmVlUGVyR2FzOyAvLyAyeCBiYXNlICsgcHJpb3JpdHkgKGJ1ZmZlciBmb3Igc2FmZXR5KVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gTGVnYWN5OiBVc2UgZ2FzUHJpY2VcbiAgICAgICAgICAgICAgICBnYXNQcmljZSA9IGF3YWl0IHRoaXMuYWNjb3VudFByb3ZpZGVyLmdldEdhc1ByaWNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBFc3RpbWF0ZSBnYXMgdXNpbmcgQWNjb3VudFByb3ZpZGVyXG4gICAgICAgICAgICBnYXNFc3RpbWF0ZSA9IGF3YWl0IHRoaXMuYWNjb3VudFByb3ZpZGVyLmVzdGltYXRlR2FzKHtcbiAgICAgICAgICAgICAgICBhY2NvdW50OiBmcm9tQWRkcmVzcyxcbiAgICAgICAgICAgICAgICB0bzogdGhpcy5pZGVudGl0eVJlZ2lzdHJ5QWRkcmVzcyxcbiAgICAgICAgICAgICAgICBkYXRhOiBlbmNvZGVkRGF0YSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gR2V0IG5vbmNlIHVzaW5nIEFjY291bnRQcm92aWRlclxuICAgICAgICAgICAgbm9uY2UgPSBhd2FpdCB0aGlzLmFjY291bnRQcm92aWRlci5nZXRUcmFuc2FjdGlvbkNvdW50KGZyb21BZGRyZXNzLCAncGVuZGluZycpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdDb3VsZCBub3QgZXN0aW1hdGUgZ2FzIG9yIGdldCB0cmFuc2FjdGlvbiBwYXJhbWV0ZXJzOicsIGVycm9yKTtcbiAgICAgICAgICAgIC8vIENvbnRpbnVlIHdpdGhvdXQgZ2FzIGVzdGltYXRlcyAtIGNsaWVudCBjYW4gZXN0aW1hdGVcbiAgICAgICAgfVxuICAgICAgICAvLyBCdWlsZCB0cmFuc2FjdGlvbiBvYmplY3QgLSByZXR1cm4gaGV4IHN0cmluZ3MgZm9yIGFsbCBiaWdpbnQgdmFsdWVzIChWaWVtIGFjY2VwdHMgaGV4IHN0cmluZ3MgZGlyZWN0bHkpXG4gICAgICAgIC8vIFRoaXMgZm9ybWF0IGNhbiBiZSB1c2VkIGRpcmVjdGx5IHdpdGggVmllbSdzIHNlbmRUcmFuc2FjdGlvbiB3aXRob3V0IGNsaWVudC1zaWRlIGNvbnZlcnNpb25cbiAgICAgICAgY29uc3QgdHhQYXJhbXMgPSB7XG4gICAgICAgICAgICB0bzogdGhpcy5pZGVudGl0eVJlZ2lzdHJ5QWRkcmVzcyxcbiAgICAgICAgICAgIGRhdGE6IGVuY29kZWREYXRhLFxuICAgICAgICAgICAgdmFsdWU6ICcweDAnLCAvLyBIZXggc3RyaW5nIGZvciB2YWx1ZVxuICAgICAgICAgICAgZ2FzOiBnYXNFc3RpbWF0ZSA/IGAweCR7Z2FzRXN0aW1hdGUudG9TdHJpbmcoMTYpfWAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBub25jZSxcbiAgICAgICAgICAgIGNoYWluSWQsXG4gICAgICAgIH07XG4gICAgICAgIC8vIEluY2x1ZGUgRUlQLTE1NTkgZmllbGRzIGlmIGF2YWlsYWJsZSwgb3RoZXJ3aXNlIGxlZ2FjeSBnYXNQcmljZVxuICAgICAgICAvLyBBbGwgYXMgaGV4IHN0cmluZ3MgZm9yIGRpcmVjdCBWaWVtIGNvbXBhdGliaWxpdHlcbiAgICAgICAgaWYgKG1heEZlZVBlckdhcyAmJiBtYXhQcmlvcml0eUZlZVBlckdhcykge1xuICAgICAgICAgICAgdHhQYXJhbXMubWF4RmVlUGVyR2FzID0gYDB4JHttYXhGZWVQZXJHYXMudG9TdHJpbmcoMTYpfWA7XG4gICAgICAgICAgICB0eFBhcmFtcy5tYXhQcmlvcml0eUZlZVBlckdhcyA9IGAweCR7bWF4UHJpb3JpdHlGZWVQZXJHYXMudG9TdHJpbmcoMTYpfWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZ2FzUHJpY2UpIHtcbiAgICAgICAgICAgIHR4UGFyYW1zLmdhc1ByaWNlID0gYDB4JHtnYXNQcmljZS50b1N0cmluZygxNil9YDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHhQYXJhbXM7XG4gICAgfVxuICAgIGFzeW5jIGlzVmFsaWRBZ2VudEFjY291bnQoYWdlbnRBY2NvdW50KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBVc2UgQWNjb3VudFByb3ZpZGVyJ3MgUmVhZENsaWVudCBpbnRlcmZhY2UgLSBjaGVjayBpZiBhZGRyZXNzIGhhcyBjb2RlXG4gICAgICAgICAgICAvLyBXZSBjYW4gdXNlIGEgc2ltcGxlIGNhbGwgdG8gY2hlY2sgaWYgaXQncyBhIGNvbnRyYWN0XG4gICAgICAgICAgICAvLyBGb3Igbm93LCB3ZSdsbCB1c2UgcHVibGljQ2xpZW50IGlmIGF2YWlsYWJsZSwgb3RoZXJ3aXNlIHJldHVybiBudWxsXG4gICAgICAgICAgICBpZiAodGhpcy5wdWJsaWNDbGllbnQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb2RlID0gYXdhaXQgdGhpcy5wdWJsaWNDbGllbnQuZ2V0Qnl0ZWNvZGUoeyBhZGRyZXNzOiBhZ2VudEFjY291bnQgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvZGUgPyB0cnVlIDogZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBY2NvdW50UHJvdmlkZXIgZG9lc24ndCBleHBvc2UgZ2V0Qnl0ZWNvZGUgZGlyZWN0bHksIHNvIHdlIGNoZWNrIHZpYSBpc0NvbnRyYWN0U2lnbmVyXG4gICAgICAgICAgICAvLyBUaGlzIGlzIGEgd29ya2Fyb3VuZCAtIGlkZWFsbHkgQWNjb3VudFByb3ZpZGVyIHdvdWxkIGV4cG9zZSBnZXRCeXRlY29kZVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2gge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRXh0cmFjdCBhZ2VudElkIGZyb20gYSB1c2VyIG9wZXJhdGlvbi90cmFuc2FjdGlvbiByZWNlaXB0XG4gICAgICogUHVibGljIGluIHRoaXMgU0RLIHRvIHN1cHBvcnQgQUEgZmxvd3MgZXhwbGljaXRseS5cbiAgICAgKi9cbiAgICBleHRyYWN0QWdlbnRJZEZyb21SZWNlaXB0UHVibGljKHJlY2VpcHQpIHtcbiAgICAgICAgLy8gTG9vayBmb3IgcGFyc2VkIGV2ZW50cyBmaXJzdFxuICAgICAgICBpZiAocmVjZWlwdD8uZXZlbnRzKSB7XG4gICAgICAgICAgICBjb25zdCByZWdpc3RlcmVkRXZlbnQgPSByZWNlaXB0LmV2ZW50cy5maW5kKChlKSA9PiBlLm5hbWUgPT09ICdSZWdpc3RlcmVkJyk7XG4gICAgICAgICAgICBpZiAocmVnaXN0ZXJlZEV2ZW50Py5hcmdzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsID0gcmVnaXN0ZXJlZEV2ZW50LmFyZ3MuYWdlbnRJZCA/PyByZWdpc3RlcmVkRXZlbnQuYXJnc1swXTtcbiAgICAgICAgICAgICAgICBpZiAodmFsICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBCaWdJbnQodmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHRyYW5zZmVyRXZlbnQgPSByZWNlaXB0LmV2ZW50cy5maW5kKChlKSA9PiBlLm5hbWUgPT09ICdUcmFuc2ZlcicgJiYgKGUuYXJncy5mcm9tID09PSAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyB8fCBlLmFyZ3MuZnJvbSA9PT0gMCB8fCBlLmFyZ3MuZnJvbSA9PT0gMG4pKTtcbiAgICAgICAgICAgIGlmICh0cmFuc2ZlckV2ZW50Py5hcmdzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsID0gdHJhbnNmZXJFdmVudC5hcmdzLnRva2VuSWQgPz8gdHJhbnNmZXJFdmVudC5hcmdzWzJdO1xuICAgICAgICAgICAgICAgIGlmICh2YWwgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEJpZ0ludCh2YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEZhbGxiYWNrOiByYXcgbG9ncyBhcnJheVxuICAgICAgICBpZiAocmVjZWlwdD8ubG9ncyAmJiBBcnJheS5pc0FycmF5KHJlY2VpcHQubG9ncykpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgbG9nIG9mIHJlY2VpcHQubG9ncykge1xuICAgICAgICAgICAgICAgIC8vIFRyYW5zZmVyKGFkZHJlc3MsYWRkcmVzcyx1aW50MjU2KVxuICAgICAgICAgICAgICAgIGlmIChsb2cudG9waWNzICYmIGxvZy50b3BpY3NbMF0gPT09ICcweGRkZjI1MmFkMWJlMmM4OWI2OWMyYjA2OGZjMzc4ZGFhOTUyYmE3ZjE2M2M0YTExNjI4ZjU1YTRkZjUyM2IzZWYnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZyb20gPSBsb2cudG9waWNzWzFdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZnJvbSA9PT0gJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRva2VuSWQgPSBCaWdJbnQobG9nLnRvcGljc1szXSB8fCBsb2cuZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW5JZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBleHRyYWN0IGFnZW50SWQgZnJvbSB0cmFuc2FjdGlvbiByZWNlaXB0IC0gUmVnaXN0ZXJlZCBvciBUcmFuc2ZlciBldmVudCBub3QgZm91bmQnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBvd25lciAoRU9BKSBvZiBhbiBhY2NvdW50IGFkZHJlc3NcbiAgICAgKlxuICAgICAqIEBwYXJhbSBhY2NvdW50QWRkcmVzcyAtIFRoZSBhY2NvdW50IGFkZHJlc3MgKHNtYXJ0IGFjY291bnQgb3IgY29udHJhY3QpXG4gICAgICogQHJldHVybnMgVGhlIG93bmVyIGFkZHJlc3MgKEVPQSkgb3IgbnVsbCBpZiBub3QgZm91bmQgb3IgZXJyb3JcbiAgICAgKi9cbiAgICBhc3luYyBnZXRBY2NvdW50T3duZXIoYWNjb3VudEFkZHJlc3MpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IG93bmVyID0gYXdhaXQgdGhpcy5hY2NvdW50UHJvdmlkZXIuY2FsbCh7XG4gICAgICAgICAgICAgICAgdG86IGFjY291bnRBZGRyZXNzLFxuICAgICAgICAgICAgICAgIGFiaTogW3sgbmFtZTogJ293bmVyJywgdHlwZTogJ2Z1bmN0aW9uJywgc3RhdGVNdXRhYmlsaXR5OiAndmlldycsIGlucHV0czogW10sIG91dHB1dHM6IFt7IHR5cGU6ICdhZGRyZXNzJyB9XSB9XSxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbk5hbWU6ICdvd25lcicsXG4gICAgICAgICAgICAgICAgYXJnczogW10sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBvd25lcjtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCBVc2UgZ2V0QWNjb3VudE93bmVyIGluc3RlYWRcbiAgICAgKi9cbiAgICBhc3luYyBnZXRBZ2VudEVvYUJ5QWdlbnRBY2NvdW50KGFnZW50QWNjb3VudCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRBY2NvdW50T3duZXIoYWdlbnRBY2NvdW50KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGFnZW50TmFtZSBmcm9tIG9uLWNoYWluIG1ldGFkYXRhIChzdHJpbmcgdmFsdWUpXG4gICAgICovXG4gICAgYXN5bmMgZ2V0QWdlbnROYW1lKGFnZW50SWQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBhd2FpdCB0aGlzLmdldE1ldGFkYXRhKGFnZW50SWQsICdhZ2VudE5hbWUnKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0cmltbWVkID0gbmFtZS50cmltKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRyaW1tZWQubGVuZ3RoID4gMCA/IHRyaW1tZWQgOiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5hbWUgPyBTdHJpbmcobmFtZSkgOiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5pbmZvKFwiKysrKysrKysrKysrKysrKysrKysrKysrIGdldEFnZW50TmFtZTogZXJyb3JcIiwgZXJyb3IpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGFnZW50QWNjb3VudCBhZGRyZXNzIGZyb20gb24tY2hhaW4gbWV0YWRhdGEuXG4gICAgICogU3VwcG9ydHMgQ0FJUC0xMCBmb3JtYXQgbGlrZSBcImVpcDE1NToxMTE1NTExMToweC4uLlwiIG9yIHJhdyAweCBhZGRyZXNzLlxuICAgICAqL1xuICAgIGFzeW5jIGdldEFnZW50QWNjb3VudChhZ2VudElkKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGF3YWl0IHRoaXMuZ2V0TWV0YWRhdGEoYWdlbnRJZCwgJ2FnZW50QWNjb3VudCcpO1xuICAgICAgICAgICAgaWYgKCF2YWx1ZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdiA9IHZhbHVlLnRyaW0oKTtcbiAgICAgICAgICAgICAgICBpZiAodi5zdGFydHNXaXRoKCdlaXAxNTU6JykpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFydHMgPSB2LnNwbGl0KCc6Jyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFkZHIgPSBwYXJ0c1syXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFkZHIgJiYgL14weFthLWZBLUYwLTldezQwfSQvLnRlc3QoYWRkcikpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWRkcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKC9eMHhbYS1mQS1GMC05XXs0MH0kLy50ZXN0KHYpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhZ2VudENhdGVnb3J5IGZyb20gb24tY2hhaW4gbWV0YWRhdGEgKHN0cmluZyB2YWx1ZSlcbiAgICAgKiBSZXR1cm5zIG9uZSBvZiB0aGUgc3RhbmRhcmQgYWdlbnQgY2F0ZWdvcnkgdHlwZXMgZnJvbSB0aGUgT0FTIGVjb3N5c3RlbS5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRBZ2VudENhdGVnb3J5KGFnZW50SWQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGNhdGVnb3J5ID0gYXdhaXQgdGhpcy5nZXRNZXRhZGF0YShhZ2VudElkLCAnYWdlbnRDYXRlZ29yeScpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjYXRlZ29yeSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0cmltbWVkID0gY2F0ZWdvcnkudHJpbSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cmltbWVkLmxlbmd0aCA+IDAgPyB0cmltbWVkIDogbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjYXRlZ29yeSA/IFN0cmluZyhjYXRlZ29yeSkgOiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5pbmZvKFwiKysrKysrKysrKysrKysrKysrKysrKysrIGdldEFnZW50Q2F0ZWdvcnk6IGVycm9yXCIsIGVycm9yKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEtlZXAgY29tcGF0aWJpbGl0eTogZGVsZWdhdGUgdG8gcmVjZWlwdCBleHRyYWN0b3IuXG4gICAgICovXG4gICAgZXh0cmFjdEFnZW50SWRGcm9tTG9ncyhyZWNlaXB0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmV4dHJhY3RBZ2VudElkRnJvbVJlY2VpcHRQdWJsaWMocmVjZWlwdCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgYXBwcm92ZWQgb3BlcmF0b3IgYWRkcmVzcyBmb3IgYW4gYWdlbnQgTkZUIHRva2VuXG4gICAgICogUmV0dXJucyB0aGUgYWRkcmVzcyBhcHByb3ZlZCB0byBvcGVyYXRlIG9uIHRoZSB0b2tlbiwgb3IgbnVsbCBpZiBubyBvcGVyYXRvciBpcyBzZXRcbiAgICAgKlxuICAgICAqIEBwYXJhbSBhZ2VudElkIC0gVGhlIGFnZW50IElEICh0b2tlbiBJRClcbiAgICAgKiBAcmV0dXJucyBUaGUgYXBwcm92ZWQgb3BlcmF0b3IgYWRkcmVzcywgb3IgbnVsbCBpZiBubyBvcGVyYXRvciBpcyBzZXQgKHplcm8gYWRkcmVzcylcbiAgICAgKi9cbiAgICBhc3luYyBnZXRORlRPcGVyYXRvcihhZ2VudElkKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBvcGVyYXRvckFkZHJlc3MgPSBhd2FpdCB0aGlzLmFjY291bnRQcm92aWRlci5jYWxsKHtcbiAgICAgICAgICAgICAgICB0bzogdGhpcy5pZGVudGl0eVJlZ2lzdHJ5QWRkcmVzcyxcbiAgICAgICAgICAgICAgICBhYmk6IElkZW50aXR5UmVnaXN0cnlBQkksXG4gICAgICAgICAgICAgICAgZnVuY3Rpb25OYW1lOiAnZ2V0QXBwcm92ZWQnLFxuICAgICAgICAgICAgICAgIGFyZ3M6IFthZ2VudElkXSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgb3BlcmF0b3IgaXMgc2V0IChub3QgemVybyBhZGRyZXNzKVxuICAgICAgICAgICAgaWYgKG9wZXJhdG9yQWRkcmVzcyAmJiBvcGVyYXRvckFkZHJlc3MgIT09ICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9wZXJhdG9yQWRkcmVzcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGdldCBORlQgb3BlcmF0b3I6JywgZXJyb3IpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1BSUFnZW50SWRlbnRpdHlDbGllbnQuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@agentic-trust/8004-ext-sdk/dist/AIAgentIdentityClient.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@agentic-trust/8004-ext-sdk/dist/AIAgentL2ENSDurenClient.js":
/*!**************************************************************************************!*\
  !*** ../../node_modules/@agentic-trust/8004-ext-sdk/dist/AIAgentL2ENSDurenClient.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AIAgentL2ENSDurenClient: () => (/* binding */ AIAgentL2ENSDurenClient)\n/* harmony export */ });\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! viem */ \"(rsc)/../../node_modules/viem/_esm/utils/ens/namehash.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! viem */ \"(rsc)/../../node_modules/viem/_esm/clients/createPublicClient.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! viem */ \"(rsc)/../../node_modules/viem/_esm/clients/transports/http.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! viem */ \"(rsc)/../../node_modules/viem/_esm/utils/abi/encodeFunctionData.js\");\n/* harmony import */ var _AIAgentENSClient__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AIAgentENSClient */ \"(rsc)/../../node_modules/@agentic-trust/8004-ext-sdk/dist/AIAgentENSClient.js\");\n\n\nclass AIAgentL2ENSDurenClient extends _AIAgentENSClient__WEBPACK_IMPORTED_MODULE_0__.AIAgentENSClient {\n    constructor(chain, rpcUrl, adapter, ensRegistryAddress, ensResolverAddress, identityRegistryAddress) {\n        super(chain, rpcUrl, adapter, '0x119bFf40969bFBe0438c3f72f3855958E8E0d30c', '0x119bFf40969bFBe0438c3f72f3855958E8E0d30c', identityRegistryAddress);\n        //ensRegistryAddress = '0xf584057f3e9ecd550b52a86f84dfeb9f928e003f' as `0x${string}`;\n        //ensResolverAddress = '0xf584057f3e9ecd550b52a86f84dfeb9f928e003f' as `0x${string}`;\n    }\n    /**\n     * Override to ensure L2 client always returns true for isL2()\n     */\n    isL2() {\n        return true; // This is always an L2 client\n    }\n    /**\n     * Override to ensure L2 client always returns false for isL1()\n     */\n    isL1() {\n        return false; // This is never an L1 client\n    }\n    /**\n     * Override to ensure L2 client always returns 'L2'\n     */\n    getChainType() {\n        return 'L2';\n    }\n    async getAgentUrlByName(name) {\n        console.info(\"AIAgentL2ENSDurenClient.getAgentUrlByName: \", name);\n        try {\n            // Calculate namehash for the subdomain\n            const node = (0,viem__WEBPACK_IMPORTED_MODULE_1__.namehash)(name);\n            console.info(\"AIAgentL2ENSDurenClient.getAgentUrlByName: node\", node);\n            // Use direct resolver call to get URL text record (equivalent to cast call)\n            const resolverAddress = this.getEnsResolverAddress();\n            // ENS Resolver ABI for text function\n            const resolverAbi = [\n                {\n                    \"inputs\": [\n                        {\n                            \"internalType\": \"bytes32\",\n                            \"name\": \"node\",\n                            \"type\": \"bytes32\"\n                        },\n                        {\n                            \"internalType\": \"string\",\n                            \"name\": \"key\",\n                            \"type\": \"string\"\n                        }\n                    ],\n                    \"name\": \"text\",\n                    \"outputs\": [\n                        {\n                            \"internalType\": \"string\",\n                            \"name\": \"\",\n                            \"type\": \"string\"\n                        }\n                    ],\n                    \"stateMutability\": \"view\",\n                    \"type\": \"function\"\n                }\n            ];\n            // Create public client for reading\n            const publicClient = // @ts-ignore - viem version compatibility issue\n             (0,viem__WEBPACK_IMPORTED_MODULE_2__.createPublicClient)({\n                chain: this.chain,\n                transport: (0,viem__WEBPACK_IMPORTED_MODULE_3__.http)(this.rpcUrl)\n            });\n            // Call the resolver directly to get URL text record\n            const url = await // @ts-ignore - viem version compatibility issue\n             publicClient.readContract({\n                address: resolverAddress,\n                abi: resolverAbi,\n                functionName: 'text',\n                args: [node, 'url']\n            });\n            console.info(\"AIAgentL2ENSDurenClient.getAgentUrlByName: resolved url\", url);\n            // Return null if URL is empty\n            if (!url || url.trim() === '') {\n                return null;\n            }\n            return url;\n        }\n        catch (error) {\n            console.error('Error resolving URL for name:', name, error);\n            return null;\n        }\n    }\n    async getAgentAccountByName(name) {\n        console.info(\"AIAgentL2ENSDurenClient.getAgentAccountByName: \", name);\n        try {\n            // Calculate namehash for the subdomain\n            const node = (0,viem__WEBPACK_IMPORTED_MODULE_1__.namehash)(name);\n            console.info(\".....node from hash: \", name, \" is: \", node);\n            //const node = '0x6ea6fadc0faff80d2349984bfc18c82b246ba9e8ba697f0356956a4f1e6b2b29' as `0x${string}`;\n            console.info(\"AIAgentL2ENSDurenClient.getAgentAccountByName: node\", node);\n            // TEST: Check if NFT exists but may not have address set\n            console.info(\"********************* TEST: Checking if NFT exists for name:\", name);\n            // First check if the name exists in the ENS registry (has an owner)\n            const ensRegistryAddress = this.getEnsRegistryAddress();\n            const ensRegistryAbi = [\n                {\n                    \"inputs\": [\n                        {\n                            \"internalType\": \"bytes32\",\n                            \"name\": \"node\",\n                            \"type\": \"bytes32\"\n                        }\n                    ],\n                    \"name\": \"owner\",\n                    \"outputs\": [\n                        {\n                            \"internalType\": \"address\",\n                            \"name\": \"\",\n                            \"type\": \"address\"\n                        }\n                    ],\n                    \"stateMutability\": \"view\",\n                    \"type\": \"function\"\n                }\n            ];\n            console.info(\"********************* TEST: Public client chain\", this.chain);\n            console.info(\"********************* TEST: Public client rpcUrl\", this.rpcUrl);\n            const publicClient = // @ts-ignore - viem version compatibility issue\n             (0,viem__WEBPACK_IMPORTED_MODULE_2__.createPublicClient)({\n                chain: this.chain,\n                transport: (0,viem__WEBPACK_IMPORTED_MODULE_3__.http)(this.rpcUrl)\n            });\n            try {\n                const owner = await // @ts-ignore - viem version compatibility issue\n                 publicClient.readContract({\n                    address: ensRegistryAddress,\n                    abi: ensRegistryAbi,\n                    functionName: 'owner',\n                    args: [node]\n                });\n                console.info(\"********************* TEST: ENS Registry owner for\", name, \":\", owner);\n                if (owner && owner !== '0x0000000000000000000000000000000000000000') {\n                    console.info(\"********************* TEST: NFT EXISTS - Name has owner:\", owner);\n                }\n                else {\n                    console.info(\"********************* TEST: NFT DOES NOT EXIST - No owner found\");\n                }\n            }\n            catch (registryError) {\n                console.error(\"********************* TEST: Error checking ENS registry:\", registryError);\n            }\n            // Use direct resolver call to get address (equivalent to cast call)\n            const resolverAddress = this.getEnsResolverAddress();\n            // ENS Resolver ABI for addr function\n            const resolverAbi = [\n                {\n                    \"inputs\": [\n                        {\n                            \"internalType\": \"bytes32\",\n                            \"name\": \"node\",\n                            \"type\": \"bytes32\"\n                        }\n                    ],\n                    \"name\": \"addr\",\n                    \"outputs\": [\n                        {\n                            \"internalType\": \"address\",\n                            \"name\": \"\",\n                            \"type\": \"address\"\n                        }\n                    ],\n                    \"stateMutability\": \"view\",\n                    \"type\": \"function\"\n                }\n            ];\n            /*\n            // TEST: Check resolver status\n            console.info(\"********************* TEST: Checking resolver for name:\", name);\n            \n            // Check if resolver is set for this node\n            const registryResolverAbi = [\n              {\n                \"inputs\": [\n                  {\n                    \"internalType\": \"bytes32\",\n                    \"name\": \"node\",\n                    \"type\": \"bytes32\"\n                  }\n                ],\n                \"name\": \"resolver\",\n                \"outputs\": [\n                  {\n                    \"internalType\": \"address\",\n                    \"name\": \"\",\n                    \"type\": \"address\"\n                  }\n                ],\n                \"stateMutability\": \"view\",\n                \"type\": \"function\"\n              }\n            ] as const;\n      \n            try {\n              const resolver = await // @ts-ignore - viem version compatibility issue\n          publicClient.readContract({\n                address: ensRegistryAddress,\n                abi: registryResolverAbi,\n                functionName: 'resolver',\n                args: [node]\n              });\n      \n              console.info(\"********************* TEST: Resolver for\", name, \":\", resolver);\n              \n              if (resolver && resolver !== '0x0000000000000000000000000000000000000000') {\n                console.info(\"********************* TEST: RESOLVER EXISTS - Name has resolver:\", resolver);\n              } else {\n                console.info(\"********************* TEST: NO RESOLVER - Name has no resolver set\");\n              }\n            } catch (resolverError) {\n              console.error(\"********************* TEST: Error checking resolver:\", resolverError);\n            }\n            */\n            // Call the resolver directly to get address\n            const addressResolverAbi = [\n                {\n                    \"inputs\": [\n                        {\n                            \"internalType\": \"bytes32\",\n                            \"name\": \"node\",\n                            \"type\": \"bytes32\"\n                        }\n                    ],\n                    \"name\": \"addr\",\n                    \"outputs\": [\n                        {\n                            \"internalType\": \"address\",\n                            \"name\": \"\",\n                            \"type\": \"address\"\n                        }\n                    ],\n                    \"stateMutability\": \"view\",\n                    \"type\": \"function\"\n                }\n            ];\n            const address = await // @ts-ignore - viem version compatibility issue\n             publicClient.readContract({\n                address: resolverAddress,\n                abi: addressResolverAbi,\n                functionName: 'addr',\n                args: [node]\n            });\n            console.info(\"AIAgentL2ENSDurenClient.getAgentAccountByName: resolved address\", address);\n            console.info(\"********************* TEST: Address resolution result:\", address);\n            // Return null if address is zero address\n            if (!address || address === '0x0000000000000000000000000000000000000000') {\n                return null;\n            }\n            return address;\n        }\n        catch (error) {\n            console.error('Error resolving address for name:', name, error);\n            return null;\n        }\n    }\n    /**\n     * Note: getAgentEoaByAgentAccount is not a method of AIAgentENSClient\n     * This method is actually in AIAgentIdentityClient, so we don't need to override it here.\n     * The ownership detection logic is handled in the UI layer (AddAgentModal.tsx)\n     */\n    /**\n     * Override hasAgentNameOwner to use L2Registrar available() function\n     */\n    async hasAgentNameOwner(orgName, agentName) {\n        console.info(\"AIAgentL2ENSDurenClient.hasAgentNameOwner\");\n        const clean = (s) => (s || '').trim().toLowerCase();\n        const parent = clean(orgName);\n        const label = clean(agentName).replace(/\\s+/g, '-');\n        console.info(\"AIAgentL2ENSDurenClient.hasAgentNameOwner: label\", label);\n        console.info(\"AIAgentL2ENSDurenClient.hasAgentNameOwner: parent\", parent);\n        const fullSubname = `${label}.${parent}`;\n        console.info(\"AIAgentL2ENSDurenClient.hasAgentNameOwner: fullSubname\", fullSubname);\n        // Use L2Registrar contract address (same as registerSubdomain)\n        const l2RegistrarAddress = \"0x68CAd072571E8bea1DA9e5C071367Aa6ddC8F37F\";\n        const l2RegistrarAbi = [\n            {\n                \"inputs\": [\n                    {\n                        \"internalType\": \"string\",\n                        \"name\": \"label\",\n                        \"type\": \"string\"\n                    }\n                ],\n                \"name\": \"available\",\n                \"outputs\": [\n                    {\n                        \"internalType\": \"bool\",\n                        \"name\": \"available\",\n                        \"type\": \"bool\"\n                    }\n                ],\n                \"stateMutability\": \"view\",\n                \"type\": \"function\"\n            }\n        ];\n        const publicClient = // @ts-ignore - viem version compatibility issue\n         (0,viem__WEBPACK_IMPORTED_MODULE_2__.createPublicClient)({\n            chain: this.chain,\n            transport: (0,viem__WEBPACK_IMPORTED_MODULE_3__.http)(this.rpcUrl)\n        });\n        try {\n            // Call registrar.available(label) - returns true if available, false if taken\n            const isAvailable = await // @ts-ignore - viem version compatibility issue\n             publicClient.readContract({\n                address: l2RegistrarAddress,\n                abi: l2RegistrarAbi,\n                functionName: 'available',\n                args: [label]\n            });\n            // If not available, then it has an owner\n            const hasOwner = !isAvailable;\n            console.info(`AIAgentL2ENSDurenClient.hasAgentNameOwner: \"${fullSubname}\" (label: \"${label}\") ${hasOwner ? 'HAS owner' : 'has NO owner'} (available: ${isAvailable})`);\n            return hasOwner;\n        }\n        catch (error) {\n            console.error('Error checking agent name owner via registrar:', error);\n            return false;\n        }\n    }\n    async prepareAddAgentNameToOrgCalls(params) {\n        console.log(\"AIAgentL2ENSDurenClient.prepareAddAgentNameToOrgCalls\");\n        console.log(\"orgName: \", params.orgName);\n        console.log(\"agentName: \", params.agentName);\n        console.log(\"agentAddress: \", params.agentAddress);\n        console.log(\"agentUrl: \", params.agentUrl);\n        const clean = (s) => (s || '').trim().toLowerCase();\n        const parent = clean(params.orgName) + \".eth\";\n        const label = clean(params.agentName).replace(/\\s+/g, '-');\n        const fullSubname = `${label}.${parent}`;\n        const agentAddress = params.agentAddress;\n        const agentUrl = params.agentUrl;\n        const chainName = this.chain.name.toLowerCase().replace(/\\s+/g, '-');\n        console.info(\"parent: \", parent);\n        console.info(\"label: \", label);\n        console.info(\"fullSubname: \", fullSubname);\n        console.info(\"agentAddress: \", agentAddress);\n        console.info(\"chainName: \", chainName);\n        console.info(\"agentUrl: \", agentUrl);\n        const calls = [];\n        try {\n            // Step 1: Register the subdomain with L2Registrar\n            const registrationCall = await this.registerSubdomain(label, agentAddress);\n            // Add registration call\n            calls.push(...registrationCall.calls);\n            /*\n      \n            // Step 2: Set address records for the subdomain\n            const chainId = (this as any).chain.id;\n      \n            // Set Base Sepolia address record (coinType 2147568164)\n            if (chainId === 84532) { // Base Sepolia\n              const baseAddrCall = await this.setResolverAddrRecordDirect(\n                fullSubname,\n                2147568164, // Base Sepolia coin type\n                agentAddress\n              );\n              calls.push(baseAddrCall);\n            }\n      \n            \n            // Set Ethereum address record (coinType 60) for cross-chain compatibility\n            const ethAddrCall = await this.setResolverAddrRecordDirect(\n              fullSubname,\n              60, // Ethereum coin type\n              agentAddress\n            );\n            calls.push(ethAddrCall);\n      \n      \n            // Step 3: Set resolver records for the subdomain\n            const textRecords = [\n              { key: 'name', value: label },\n              { key: 'url', value: agentUrl },\n              { key: 'description', value: `Agent: ${label}` },\n              { key: 'chain', value: chainName },\n              { key: 'agent-account', value: agentAddress },\n            ];\n      \n            for (const record of textRecords) {\n              const recordCall = await this.setResolverTextRecordDirect(\n                fullSubname,\n                record.key,\n                record.value,\n              );\n              calls.push(recordCall);\n            }\n      \n      \n      \n      \n            console.info(\"Generated calls count: \", calls.length);\n            console.info(\"Calls: \", calls);\n      \n            */\n        }\n        catch (error) {\n            console.error(\"Error preparing agent name calls:\", error);\n            throw error;\n        }\n        return { calls };\n    }\n    async prepareAddAgentInfoCalls(params) {\n        console.log(\"AIAgentL2ENSDurenClient.prepareAddAgentNameToOrgCalls\");\n        console.log(\"orgName: \", params.orgName);\n        console.log(\"agentName: \", params.agentName);\n        console.log(\"agentAddress: \", params.agentAddress);\n        console.log(\"agentUrl: \", params.agentUrl);\n        const clean = (s) => (s || '').trim().toLowerCase();\n        const parent = clean(params.orgName) + \".eth\";\n        const label = clean(params.agentName).replace(/\\s+/g, '-');\n        const fullSubname = `${label}.${parent}`;\n        const agentAddress = params.agentAddress;\n        const agentUrl = params.agentUrl;\n        const chainName = this.chain.name.toLowerCase().replace(/\\s+/g, '-');\n        console.info(\"parent: \", parent);\n        console.info(\"label: \", label);\n        console.info(\"fullSubname: \", fullSubname);\n        console.info(\"agentAddress: \", agentAddress);\n        console.info(\"chainName: \", chainName);\n        console.info(\"agentUrl: \", agentUrl);\n        const calls = [];\n        try {\n            // Step 2: Set address records for the subdomain\n            const chainId = this.chain.id;\n            // Set Base Sepolia address record (coinType 2147568164)\n            if (chainId === 84532) { // Base Sepolia\n                const baseAddrCall = await this.setResolverAddrRecordDirect(fullSubname, 2147568164, // Base Sepolia coin type\n                agentAddress);\n                calls.push(baseAddrCall);\n            }\n            /*\n            // Set Ethereum address record (coinType 60) for cross-chain compatibility\n            const ethAddrCall = await this.setResolverAddrRecordDirect(\n              fullSubname,\n              60, // Ethereum coin type\n              agentAddress\n            );\n            calls.push(ethAddrCall);\n            */\n            // Step 3: Set resolver records for the subdomain\n            const textRecords = [\n                //{ key: 'name', value: label },\n                { key: 'url', value: agentUrl },\n                //{ key: 'description', value: `Agent: ${label}` },\n                //{ key: 'chain', value: chainName },\n                //{ key: 'agent-account', value: agentAddress },\n            ];\n            // Add description if provided\n            if (params.agentDescription && params.agentDescription.trim() !== '') {\n                textRecords.push({ key: 'description', value: params.agentDescription.trim() });\n            }\n            for (const record of textRecords) {\n                const recordCall = await this.setResolverTextRecordDirect(fullSubname, record.key, record.value);\n                calls.push(recordCall);\n            }\n            console.info(\"Generated calls count: \", calls.length);\n            console.info(\"Calls: \", calls);\n        }\n        catch (error) {\n            console.error(\"Error preparing agent name calls:\", error);\n            throw error;\n        }\n        return { calls };\n    }\n    async prepareSetNameUriCalls(name, uri) {\n        const calls = [];\n        return { calls };\n    }\n    /**\n     * Register subdomain using L2Registrar contract (Base Sepolia specific)\n     */\n    async registerSubdomain(subdomain, owner) {\n        console.log(\"AIAgentL2ENSDurenClient.registerSubdomain\");\n        console.log(\"subdomain:\", subdomain);\n        console.log(\"owner:\", owner);\n        const calls = [];\n        // L2Registrar ABI - 2-parameter register function\n        const l2RegistrarAbi = [\n            {\n                \"inputs\": [\n                    {\n                        \"internalType\": \"string\",\n                        \"name\": \"name\",\n                        \"type\": \"string\"\n                    },\n                    {\n                        \"internalType\": \"address\",\n                        \"name\": \"owner\",\n                        \"type\": \"address\"\n                    }\n                ],\n                \"name\": \"register\",\n                \"outputs\": [],\n                \"stateMutability\": \"nonpayable\",\n                \"type\": \"function\"\n            }\n        ];\n        // Use L2Registrar contract address for Base Sepolia\n        const l2RegistrarAddress = \"0x68CAd072571E8bea1DA9e5C071367Aa6ddC8F37F\";\n        // Register subdomain using L2Registrar (equivalent to your cast command)\n        const registerData = (0,viem__WEBPACK_IMPORTED_MODULE_4__.encodeFunctionData)({\n            abi: l2RegistrarAbi,\n            functionName: 'register',\n            args: [subdomain, owner]\n        });\n        calls.push({\n            to: l2RegistrarAddress,\n            data: registerData,\n            value: 0n\n        });\n        return { calls };\n    }\n    /**\n     * Direct chain call for setting resolver records\n     */\n    async setResolverTextRecordDirect(name, key, value) {\n        console.log(\"AIAgentL2ENSDurenClient.setResolverTextRecordDirect\");\n        console.log(\"name:\", name);\n        console.log(\"key:\", key);\n        console.log(\"value:\", value);\n        const resolverAddress = this.getEnsResolverAddress();\n        // ENS Resolver ABI for setText\n        const resolverAbi = [\n            {\n                \"inputs\": [\n                    {\n                        \"internalType\": \"bytes32\",\n                        \"name\": \"node\",\n                        \"type\": \"bytes32\"\n                    },\n                    {\n                        \"internalType\": \"string\",\n                        \"name\": \"key\",\n                        \"type\": \"string\"\n                    },\n                    {\n                        \"internalType\": \"string\",\n                        \"name\": \"value\",\n                        \"type\": \"string\"\n                    }\n                ],\n                \"name\": \"setText\",\n                \"outputs\": [],\n                \"stateMutability\": \"nonpayable\",\n                \"type\": \"function\"\n            }\n        ];\n        // Calculate namehash for the subdomain\n        const node = (0,viem__WEBPACK_IMPORTED_MODULE_1__.namehash)(name);\n        // Encode the setText function call\n        const data = (0,viem__WEBPACK_IMPORTED_MODULE_4__.encodeFunctionData)({\n            abi: resolverAbi,\n            functionName: 'setText',\n            args: [node, key, value]\n        });\n        return {\n            to: resolverAddress,\n            data\n        };\n    }\n    /**\n     * Direct chain call for setting resolver address records\n     * Equivalent to: cast send resolver \"setAddr(bytes32,uint256,bytes)\" $NODE coinType encodedAddress\n     */\n    async setResolverAddrRecordDirect(name, coinType, address) {\n        console.log(\"AIAgentL2ENSDurenClient.setResolverAddrRecordDirect\");\n        console.log(\"name:\", name);\n        console.log(\"coinType:\", coinType);\n        console.log(\"address:\", address);\n        const resolverAddress = this.getEnsResolverAddress();\n        // ENS Resolver ABI for setAddr\n        const resolverAbi = [\n            {\n                \"inputs\": [\n                    {\n                        \"internalType\": \"bytes32\",\n                        \"name\": \"node\",\n                        \"type\": \"bytes32\"\n                    },\n                    {\n                        \"internalType\": \"uint256\",\n                        \"name\": \"coinType\",\n                        \"type\": \"uint256\"\n                    },\n                    {\n                        \"internalType\": \"bytes\",\n                        \"name\": \"a\",\n                        \"type\": \"bytes\"\n                    }\n                ],\n                \"name\": \"setAddr\",\n                \"outputs\": [],\n                \"stateMutability\": \"nonpayable\",\n                \"type\": \"function\"\n            }\n        ];\n        // Calculate namehash for the subdomain\n        const node = (0,viem__WEBPACK_IMPORTED_MODULE_1__.namehash)(name);\n        // Encode the address according to the coin type\n        // For Base Sepolia (coinType 2147568164), we need to encode as bytes\n        let encodedAddress;\n        if (coinType === 2147568164) {\n            // Base Sepolia coin type - encode as bytes\n            // Equivalent to: $(cast abi-encode \"f(address)\" 0xYourBaseAddress)\n            encodedAddress = (0,viem__WEBPACK_IMPORTED_MODULE_4__.encodeFunctionData)({\n                abi: [{ \"inputs\": [{ \"internalType\": \"address\", \"name\": \"addr\", \"type\": \"address\" }], \"name\": \"f\", \"outputs\": [], \"stateMutability\": \"nonpayable\", \"type\": \"function\" }],\n                functionName: 'f',\n                args: [address]\n            });\n        }\n        else if (coinType === 60) {\n            // Ethereum coin type - encode as 20-byte address\n            encodedAddress = address.padEnd(66, '0');\n        }\n        else {\n            // Generic encoding for other coin types\n            encodedAddress = address.padEnd(66, '0');\n        }\n        console.log(\"node:\", node);\n        console.log(\"encodedAddress:\", encodedAddress);\n        // Encode the setAddr function call\n        const data = (0,viem__WEBPACK_IMPORTED_MODULE_4__.encodeFunctionData)({\n            abi: resolverAbi,\n            functionName: 'setAddr',\n            args: [node, BigInt(coinType), encodedAddress]\n        });\n        return {\n            to: resolverAddress,\n            data\n        };\n    }\n}\n//# sourceMappingURL=AIAgentL2ENSDurenClient.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BhZ2VudGljLXRydXN0LzgwMDQtZXh0LXNkay9kaXN0L0FJQWdlbnRMMkVOU0R1cmVuQ2xpZW50LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUE4RTtBQUN4QjtBQUMvQyxzQ0FBc0MsK0RBQWdCO0FBQzdEO0FBQ0E7QUFDQSxvRkFBb0YsT0FBTztBQUMzRixvRkFBb0YsT0FBTztBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qiw4Q0FBUTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHdEQUFrQjtBQUMvQjtBQUNBLDJCQUEyQiwwQ0FBSTtBQUMvQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsOENBQVE7QUFDakM7QUFDQSx3R0FBd0csT0FBTztBQUMvRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSx3REFBa0I7QUFDL0I7QUFDQSwyQkFBMkIsMENBQUk7QUFDL0IsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsTUFBTSxHQUFHLE9BQU87QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLHdEQUFrQjtBQUMzQjtBQUNBLHVCQUF1QiwwQ0FBSTtBQUMzQixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0Esd0VBQXdFLFlBQVksYUFBYSxNQUFNLEtBQUsseUNBQXlDLGNBQWMsWUFBWTtBQUMvSztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixNQUFNLEdBQUcsT0FBTztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwyQkFBMkI7QUFDM0MsZ0JBQWdCLDZCQUE2QjtBQUM3QyxnQkFBZ0IscUNBQXFDLE1BQU0sR0FBRztBQUM5RCxnQkFBZ0IsZ0NBQWdDO0FBQ2hELGdCQUFnQiwyQ0FBMkM7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixNQUFNLEdBQUcsT0FBTztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwyQkFBMkI7QUFDL0Msa0JBQWtCLDZCQUE2QjtBQUMvQyxvQkFBb0IscUNBQXFDLE1BQU0sR0FBRztBQUNsRSxvQkFBb0IsZ0NBQWdDO0FBQ3BELG9CQUFvQiwyQ0FBMkM7QUFDL0Q7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLDJEQUEyRDtBQUM5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHdEQUFrQjtBQUMvQztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiw4Q0FBUTtBQUM3QjtBQUNBLHFCQUFxQix3REFBa0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsOENBQVE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHdEQUFrQjtBQUMvQyx3QkFBd0IsYUFBYSw4REFBOEQsb0ZBQW9GO0FBQ3ZMO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHdEQUFrQjtBQUN2QztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL2JhcmIvYWEvQXNzb2NpYXRlZEFjY291bnRzL25vZGVfbW9kdWxlcy9AYWdlbnRpYy10cnVzdC84MDA0LWV4dC1zZGsvZGlzdC9BSUFnZW50TDJFTlNEdXJlbkNsaWVudC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjcmVhdGVQdWJsaWNDbGllbnQsIGh0dHAsIGVuY29kZUZ1bmN0aW9uRGF0YSwgbmFtZWhhc2ggfSBmcm9tICd2aWVtJztcbmltcG9ydCB7IEFJQWdlbnRFTlNDbGllbnQgfSBmcm9tICcuL0FJQWdlbnRFTlNDbGllbnQnO1xuZXhwb3J0IGNsYXNzIEFJQWdlbnRMMkVOU0R1cmVuQ2xpZW50IGV4dGVuZHMgQUlBZ2VudEVOU0NsaWVudCB7XG4gICAgY29uc3RydWN0b3IoY2hhaW4sIHJwY1VybCwgYWRhcHRlciwgZW5zUmVnaXN0cnlBZGRyZXNzLCBlbnNSZXNvbHZlckFkZHJlc3MsIGlkZW50aXR5UmVnaXN0cnlBZGRyZXNzKSB7XG4gICAgICAgIHN1cGVyKGNoYWluLCBycGNVcmwsIGFkYXB0ZXIsICcweDExOWJGZjQwOTY5YkZCZTA0MzhjM2Y3MmYzODU1OTU4RThFMGQzMGMnLCAnMHgxMTliRmY0MDk2OWJGQmUwNDM4YzNmNzJmMzg1NTk1OEU4RTBkMzBjJywgaWRlbnRpdHlSZWdpc3RyeUFkZHJlc3MpO1xuICAgICAgICAvL2Vuc1JlZ2lzdHJ5QWRkcmVzcyA9ICcweGY1ODQwNTdmM2U5ZWNkNTUwYjUyYTg2Zjg0ZGZlYjlmOTI4ZTAwM2YnIGFzIGAweCR7c3RyaW5nfWA7XG4gICAgICAgIC8vZW5zUmVzb2x2ZXJBZGRyZXNzID0gJzB4ZjU4NDA1N2YzZTllY2Q1NTBiNTJhODZmODRkZmViOWY5MjhlMDAzZicgYXMgYDB4JHtzdHJpbmd9YDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGUgdG8gZW5zdXJlIEwyIGNsaWVudCBhbHdheXMgcmV0dXJucyB0cnVlIGZvciBpc0wyKClcbiAgICAgKi9cbiAgICBpc0wyKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gVGhpcyBpcyBhbHdheXMgYW4gTDIgY2xpZW50XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlIHRvIGVuc3VyZSBMMiBjbGllbnQgYWx3YXlzIHJldHVybnMgZmFsc2UgZm9yIGlzTDEoKVxuICAgICAqL1xuICAgIGlzTDEoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTsgLy8gVGhpcyBpcyBuZXZlciBhbiBMMSBjbGllbnRcbiAgICB9XG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGUgdG8gZW5zdXJlIEwyIGNsaWVudCBhbHdheXMgcmV0dXJucyAnTDInXG4gICAgICovXG4gICAgZ2V0Q2hhaW5UeXBlKCkge1xuICAgICAgICByZXR1cm4gJ0wyJztcbiAgICB9XG4gICAgYXN5bmMgZ2V0QWdlbnRVcmxCeU5hbWUobmFtZSkge1xuICAgICAgICBjb25zb2xlLmluZm8oXCJBSUFnZW50TDJFTlNEdXJlbkNsaWVudC5nZXRBZ2VudFVybEJ5TmFtZTogXCIsIG5hbWUpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIG5hbWVoYXNoIGZvciB0aGUgc3ViZG9tYWluXG4gICAgICAgICAgICBjb25zdCBub2RlID0gbmFtZWhhc2gobmFtZSk7XG4gICAgICAgICAgICBjb25zb2xlLmluZm8oXCJBSUFnZW50TDJFTlNEdXJlbkNsaWVudC5nZXRBZ2VudFVybEJ5TmFtZTogbm9kZVwiLCBub2RlKTtcbiAgICAgICAgICAgIC8vIFVzZSBkaXJlY3QgcmVzb2x2ZXIgY2FsbCB0byBnZXQgVVJMIHRleHQgcmVjb3JkIChlcXVpdmFsZW50IHRvIGNhc3QgY2FsbClcbiAgICAgICAgICAgIGNvbnN0IHJlc29sdmVyQWRkcmVzcyA9IHRoaXMuZ2V0RW5zUmVzb2x2ZXJBZGRyZXNzKCk7XG4gICAgICAgICAgICAvLyBFTlMgUmVzb2x2ZXIgQUJJIGZvciB0ZXh0IGZ1bmN0aW9uXG4gICAgICAgICAgICBjb25zdCByZXNvbHZlckFiaSA9IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIFwiaW5wdXRzXCI6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImludGVybmFsVHlwZVwiOiBcImJ5dGVzMzJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJub2RlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYnl0ZXMzMlwiXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiaW50ZXJuYWxUeXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwia2V5XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwidGV4dFwiLFxuICAgICAgICAgICAgICAgICAgICBcIm91dHB1dHNcIjogW1xuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiaW50ZXJuYWxUeXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgXCJzdGF0ZU11dGFiaWxpdHlcIjogXCJ2aWV3XCIsXG4gICAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImZ1bmN0aW9uXCJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgLy8gQ3JlYXRlIHB1YmxpYyBjbGllbnQgZm9yIHJlYWRpbmdcbiAgICAgICAgICAgIGNvbnN0IHB1YmxpY0NsaWVudCA9IC8vIEB0cy1pZ25vcmUgLSB2aWVtIHZlcnNpb24gY29tcGF0aWJpbGl0eSBpc3N1ZVxuICAgICAgICAgICAgIGNyZWF0ZVB1YmxpY0NsaWVudCh7XG4gICAgICAgICAgICAgICAgY2hhaW46IHRoaXMuY2hhaW4sXG4gICAgICAgICAgICAgICAgdHJhbnNwb3J0OiBodHRwKHRoaXMucnBjVXJsKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBDYWxsIHRoZSByZXNvbHZlciBkaXJlY3RseSB0byBnZXQgVVJMIHRleHQgcmVjb3JkXG4gICAgICAgICAgICBjb25zdCB1cmwgPSBhd2FpdCAvLyBAdHMtaWdub3JlIC0gdmllbSB2ZXJzaW9uIGNvbXBhdGliaWxpdHkgaXNzdWVcbiAgICAgICAgICAgICBwdWJsaWNDbGllbnQucmVhZENvbnRyYWN0KHtcbiAgICAgICAgICAgICAgICBhZGRyZXNzOiByZXNvbHZlckFkZHJlc3MsXG4gICAgICAgICAgICAgICAgYWJpOiByZXNvbHZlckFiaSxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbk5hbWU6ICd0ZXh0JyxcbiAgICAgICAgICAgICAgICBhcmdzOiBbbm9kZSwgJ3VybCddXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhcIkFJQWdlbnRMMkVOU0R1cmVuQ2xpZW50LmdldEFnZW50VXJsQnlOYW1lOiByZXNvbHZlZCB1cmxcIiwgdXJsKTtcbiAgICAgICAgICAgIC8vIFJldHVybiBudWxsIGlmIFVSTCBpcyBlbXB0eVxuICAgICAgICAgICAgaWYgKCF1cmwgfHwgdXJsLnRyaW0oKSA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB1cmw7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciByZXNvbHZpbmcgVVJMIGZvciBuYW1lOicsIG5hbWUsIGVycm9yKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGdldEFnZW50QWNjb3VudEJ5TmFtZShuYW1lKSB7XG4gICAgICAgIGNvbnNvbGUuaW5mbyhcIkFJQWdlbnRMMkVOU0R1cmVuQ2xpZW50LmdldEFnZW50QWNjb3VudEJ5TmFtZTogXCIsIG5hbWUpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIG5hbWVoYXNoIGZvciB0aGUgc3ViZG9tYWluXG4gICAgICAgICAgICBjb25zdCBub2RlID0gbmFtZWhhc2gobmFtZSk7XG4gICAgICAgICAgICBjb25zb2xlLmluZm8oXCIuLi4uLm5vZGUgZnJvbSBoYXNoOiBcIiwgbmFtZSwgXCIgaXM6IFwiLCBub2RlKTtcbiAgICAgICAgICAgIC8vY29uc3Qgbm9kZSA9ICcweDZlYTZmYWRjMGZhZmY4MGQyMzQ5OTg0YmZjMThjODJiMjQ2YmE5ZThiYTY5N2YwMzU2OTU2YTRmMWU2YjJiMjknIGFzIGAweCR7c3RyaW5nfWA7XG4gICAgICAgICAgICBjb25zb2xlLmluZm8oXCJBSUFnZW50TDJFTlNEdXJlbkNsaWVudC5nZXRBZ2VudEFjY291bnRCeU5hbWU6IG5vZGVcIiwgbm9kZSk7XG4gICAgICAgICAgICAvLyBURVNUOiBDaGVjayBpZiBORlQgZXhpc3RzIGJ1dCBtYXkgbm90IGhhdmUgYWRkcmVzcyBzZXRcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhcIioqKioqKioqKioqKioqKioqKioqKiBURVNUOiBDaGVja2luZyBpZiBORlQgZXhpc3RzIGZvciBuYW1lOlwiLCBuYW1lKTtcbiAgICAgICAgICAgIC8vIEZpcnN0IGNoZWNrIGlmIHRoZSBuYW1lIGV4aXN0cyBpbiB0aGUgRU5TIHJlZ2lzdHJ5IChoYXMgYW4gb3duZXIpXG4gICAgICAgICAgICBjb25zdCBlbnNSZWdpc3RyeUFkZHJlc3MgPSB0aGlzLmdldEVuc1JlZ2lzdHJ5QWRkcmVzcygpO1xuICAgICAgICAgICAgY29uc3QgZW5zUmVnaXN0cnlBYmkgPSBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBcImlucHV0c1wiOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJpbnRlcm5hbFR5cGVcIjogXCJieXRlczMyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwibm9kZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImJ5dGVzMzJcIlxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJvd25lclwiLFxuICAgICAgICAgICAgICAgICAgICBcIm91dHB1dHNcIjogW1xuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiaW50ZXJuYWxUeXBlXCI6IFwiYWRkcmVzc1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImFkZHJlc3NcIlxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICBcInN0YXRlTXV0YWJpbGl0eVwiOiBcInZpZXdcIixcbiAgICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZnVuY3Rpb25cIlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICBjb25zb2xlLmluZm8oXCIqKioqKioqKioqKioqKioqKioqKiogVEVTVDogUHVibGljIGNsaWVudCBjaGFpblwiLCB0aGlzLmNoYWluKTtcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhcIioqKioqKioqKioqKioqKioqKioqKiBURVNUOiBQdWJsaWMgY2xpZW50IHJwY1VybFwiLCB0aGlzLnJwY1VybCk7XG4gICAgICAgICAgICBjb25zdCBwdWJsaWNDbGllbnQgPSAvLyBAdHMtaWdub3JlIC0gdmllbSB2ZXJzaW9uIGNvbXBhdGliaWxpdHkgaXNzdWVcbiAgICAgICAgICAgICBjcmVhdGVQdWJsaWNDbGllbnQoe1xuICAgICAgICAgICAgICAgIGNoYWluOiB0aGlzLmNoYWluLFxuICAgICAgICAgICAgICAgIHRyYW5zcG9ydDogaHR0cCh0aGlzLnJwY1VybClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBvd25lciA9IGF3YWl0IC8vIEB0cy1pZ25vcmUgLSB2aWVtIHZlcnNpb24gY29tcGF0aWJpbGl0eSBpc3N1ZVxuICAgICAgICAgICAgICAgICBwdWJsaWNDbGllbnQucmVhZENvbnRyYWN0KHtcbiAgICAgICAgICAgICAgICAgICAgYWRkcmVzczogZW5zUmVnaXN0cnlBZGRyZXNzLFxuICAgICAgICAgICAgICAgICAgICBhYmk6IGVuc1JlZ2lzdHJ5QWJpLFxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbk5hbWU6ICdvd25lcicsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtub2RlXVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhcIioqKioqKioqKioqKioqKioqKioqKiBURVNUOiBFTlMgUmVnaXN0cnkgb3duZXIgZm9yXCIsIG5hbWUsIFwiOlwiLCBvd25lcik7XG4gICAgICAgICAgICAgICAgaWYgKG93bmVyICYmIG93bmVyICE9PSAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJykge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmluZm8oXCIqKioqKioqKioqKioqKioqKioqKiogVEVTVDogTkZUIEVYSVNUUyAtIE5hbWUgaGFzIG93bmVyOlwiLCBvd25lcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmluZm8oXCIqKioqKioqKioqKioqKioqKioqKiogVEVTVDogTkZUIERPRVMgTk9UIEVYSVNUIC0gTm8gb3duZXIgZm91bmRcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKHJlZ2lzdHJ5RXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiKioqKioqKioqKioqKioqKioqKioqIFRFU1Q6IEVycm9yIGNoZWNraW5nIEVOUyByZWdpc3RyeTpcIiwgcmVnaXN0cnlFcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBVc2UgZGlyZWN0IHJlc29sdmVyIGNhbGwgdG8gZ2V0IGFkZHJlc3MgKGVxdWl2YWxlbnQgdG8gY2FzdCBjYWxsKVxuICAgICAgICAgICAgY29uc3QgcmVzb2x2ZXJBZGRyZXNzID0gdGhpcy5nZXRFbnNSZXNvbHZlckFkZHJlc3MoKTtcbiAgICAgICAgICAgIC8vIEVOUyBSZXNvbHZlciBBQkkgZm9yIGFkZHIgZnVuY3Rpb25cbiAgICAgICAgICAgIGNvbnN0IHJlc29sdmVyQWJpID0gW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgXCJpbnB1dHNcIjogW1xuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiaW50ZXJuYWxUeXBlXCI6IFwiYnl0ZXMzMlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIm5vZGVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJieXRlczMyXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiYWRkclwiLFxuICAgICAgICAgICAgICAgICAgICBcIm91dHB1dHNcIjogW1xuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiaW50ZXJuYWxUeXBlXCI6IFwiYWRkcmVzc1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImFkZHJlc3NcIlxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICBcInN0YXRlTXV0YWJpbGl0eVwiOiBcInZpZXdcIixcbiAgICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZnVuY3Rpb25cIlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgLy8gVEVTVDogQ2hlY2sgcmVzb2x2ZXIgc3RhdHVzXG4gICAgICAgICAgICBjb25zb2xlLmluZm8oXCIqKioqKioqKioqKioqKioqKioqKiogVEVTVDogQ2hlY2tpbmcgcmVzb2x2ZXIgZm9yIG5hbWU6XCIsIG5hbWUpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBDaGVjayBpZiByZXNvbHZlciBpcyBzZXQgZm9yIHRoaXMgbm9kZVxuICAgICAgICAgICAgY29uc3QgcmVnaXN0cnlSZXNvbHZlckFiaSA9IFtcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIFwiaW5wdXRzXCI6IFtcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgXCJpbnRlcm5hbFR5cGVcIjogXCJieXRlczMyXCIsXG4gICAgICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIm5vZGVcIixcbiAgICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYnl0ZXMzMlwiXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJyZXNvbHZlclwiLFxuICAgICAgICAgICAgICAgIFwib3V0cHV0c1wiOiBbXG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIFwiaW50ZXJuYWxUeXBlXCI6IFwiYWRkcmVzc1wiLFxuICAgICAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJcIixcbiAgICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYWRkcmVzc1wiXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBcInN0YXRlTXV0YWJpbGl0eVwiOiBcInZpZXdcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJmdW5jdGlvblwiXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF0gYXMgY29uc3Q7XG4gICAgICBcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGNvbnN0IHJlc29sdmVyID0gYXdhaXQgLy8gQHRzLWlnbm9yZSAtIHZpZW0gdmVyc2lvbiBjb21wYXRpYmlsaXR5IGlzc3VlXG4gICAgICAgICAgcHVibGljQ2xpZW50LnJlYWRDb250cmFjdCh7XG4gICAgICAgICAgICAgICAgYWRkcmVzczogZW5zUmVnaXN0cnlBZGRyZXNzLFxuICAgICAgICAgICAgICAgIGFiaTogcmVnaXN0cnlSZXNvbHZlckFiaSxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbk5hbWU6ICdyZXNvbHZlcicsXG4gICAgICAgICAgICAgICAgYXJnczogW25vZGVdXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgXG4gICAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhcIioqKioqKioqKioqKioqKioqKioqKiBURVNUOiBSZXNvbHZlciBmb3JcIiwgbmFtZSwgXCI6XCIsIHJlc29sdmVyKTtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIGlmIChyZXNvbHZlciAmJiByZXNvbHZlciAhPT0gJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmluZm8oXCIqKioqKioqKioqKioqKioqKioqKiogVEVTVDogUkVTT0xWRVIgRVhJU1RTIC0gTmFtZSBoYXMgcmVzb2x2ZXI6XCIsIHJlc29sdmVyKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmluZm8oXCIqKioqKioqKioqKioqKioqKioqKiogVEVTVDogTk8gUkVTT0xWRVIgLSBOYW1lIGhhcyBubyByZXNvbHZlciBzZXRcIik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKHJlc29sdmVyRXJyb3IpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIioqKioqKioqKioqKioqKioqKioqKiBURVNUOiBFcnJvciBjaGVja2luZyByZXNvbHZlcjpcIiwgcmVzb2x2ZXJFcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgLy8gQ2FsbCB0aGUgcmVzb2x2ZXIgZGlyZWN0bHkgdG8gZ2V0IGFkZHJlc3NcbiAgICAgICAgICAgIGNvbnN0IGFkZHJlc3NSZXNvbHZlckFiaSA9IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIFwiaW5wdXRzXCI6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImludGVybmFsVHlwZVwiOiBcImJ5dGVzMzJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJub2RlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYnl0ZXMzMlwiXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImFkZHJcIixcbiAgICAgICAgICAgICAgICAgICAgXCJvdXRwdXRzXCI6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImludGVybmFsVHlwZVwiOiBcImFkZHJlc3NcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJhZGRyZXNzXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgXCJzdGF0ZU11dGFiaWxpdHlcIjogXCJ2aWV3XCIsXG4gICAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImZ1bmN0aW9uXCJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgY29uc3QgYWRkcmVzcyA9IGF3YWl0IC8vIEB0cy1pZ25vcmUgLSB2aWVtIHZlcnNpb24gY29tcGF0aWJpbGl0eSBpc3N1ZVxuICAgICAgICAgICAgIHB1YmxpY0NsaWVudC5yZWFkQ29udHJhY3Qoe1xuICAgICAgICAgICAgICAgIGFkZHJlc3M6IHJlc29sdmVyQWRkcmVzcyxcbiAgICAgICAgICAgICAgICBhYmk6IGFkZHJlc3NSZXNvbHZlckFiaSxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbk5hbWU6ICdhZGRyJyxcbiAgICAgICAgICAgICAgICBhcmdzOiBbbm9kZV1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc29sZS5pbmZvKFwiQUlBZ2VudEwyRU5TRHVyZW5DbGllbnQuZ2V0QWdlbnRBY2NvdW50QnlOYW1lOiByZXNvbHZlZCBhZGRyZXNzXCIsIGFkZHJlc3MpO1xuICAgICAgICAgICAgY29uc29sZS5pbmZvKFwiKioqKioqKioqKioqKioqKioqKioqIFRFU1Q6IEFkZHJlc3MgcmVzb2x1dGlvbiByZXN1bHQ6XCIsIGFkZHJlc3MpO1xuICAgICAgICAgICAgLy8gUmV0dXJuIG51bGwgaWYgYWRkcmVzcyBpcyB6ZXJvIGFkZHJlc3NcbiAgICAgICAgICAgIGlmICghYWRkcmVzcyB8fCBhZGRyZXNzID09PSAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFkZHJlc3M7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciByZXNvbHZpbmcgYWRkcmVzcyBmb3IgbmFtZTonLCBuYW1lLCBlcnJvcik7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBOb3RlOiBnZXRBZ2VudEVvYUJ5QWdlbnRBY2NvdW50IGlzIG5vdCBhIG1ldGhvZCBvZiBBSUFnZW50RU5TQ2xpZW50XG4gICAgICogVGhpcyBtZXRob2QgaXMgYWN0dWFsbHkgaW4gQUlBZ2VudElkZW50aXR5Q2xpZW50LCBzbyB3ZSBkb24ndCBuZWVkIHRvIG92ZXJyaWRlIGl0IGhlcmUuXG4gICAgICogVGhlIG93bmVyc2hpcCBkZXRlY3Rpb24gbG9naWMgaXMgaGFuZGxlZCBpbiB0aGUgVUkgbGF5ZXIgKEFkZEFnZW50TW9kYWwudHN4KVxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlIGhhc0FnZW50TmFtZU93bmVyIHRvIHVzZSBMMlJlZ2lzdHJhciBhdmFpbGFibGUoKSBmdW5jdGlvblxuICAgICAqL1xuICAgIGFzeW5jIGhhc0FnZW50TmFtZU93bmVyKG9yZ05hbWUsIGFnZW50TmFtZSkge1xuICAgICAgICBjb25zb2xlLmluZm8oXCJBSUFnZW50TDJFTlNEdXJlbkNsaWVudC5oYXNBZ2VudE5hbWVPd25lclwiKTtcbiAgICAgICAgY29uc3QgY2xlYW4gPSAocykgPT4gKHMgfHwgJycpLnRyaW0oKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBjb25zdCBwYXJlbnQgPSBjbGVhbihvcmdOYW1lKTtcbiAgICAgICAgY29uc3QgbGFiZWwgPSBjbGVhbihhZ2VudE5hbWUpLnJlcGxhY2UoL1xccysvZywgJy0nKTtcbiAgICAgICAgY29uc29sZS5pbmZvKFwiQUlBZ2VudEwyRU5TRHVyZW5DbGllbnQuaGFzQWdlbnROYW1lT3duZXI6IGxhYmVsXCIsIGxhYmVsKTtcbiAgICAgICAgY29uc29sZS5pbmZvKFwiQUlBZ2VudEwyRU5TRHVyZW5DbGllbnQuaGFzQWdlbnROYW1lT3duZXI6IHBhcmVudFwiLCBwYXJlbnQpO1xuICAgICAgICBjb25zdCBmdWxsU3VibmFtZSA9IGAke2xhYmVsfS4ke3BhcmVudH1gO1xuICAgICAgICBjb25zb2xlLmluZm8oXCJBSUFnZW50TDJFTlNEdXJlbkNsaWVudC5oYXNBZ2VudE5hbWVPd25lcjogZnVsbFN1Ym5hbWVcIiwgZnVsbFN1Ym5hbWUpO1xuICAgICAgICAvLyBVc2UgTDJSZWdpc3RyYXIgY29udHJhY3QgYWRkcmVzcyAoc2FtZSBhcyByZWdpc3RlclN1YmRvbWFpbilcbiAgICAgICAgY29uc3QgbDJSZWdpc3RyYXJBZGRyZXNzID0gXCIweDY4Q0FkMDcyNTcxRThiZWExREE5ZTVDMDcxMzY3QWE2ZGRDOEYzN0ZcIjtcbiAgICAgICAgY29uc3QgbDJSZWdpc3RyYXJBYmkgPSBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgXCJpbnB1dHNcIjogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBcImludGVybmFsVHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwibGFiZWxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImF2YWlsYWJsZVwiLFxuICAgICAgICAgICAgICAgIFwib3V0cHV0c1wiOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiaW50ZXJuYWxUeXBlXCI6IFwiYm9vbFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiYXZhaWxhYmxlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJib29sXCJcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgXCJzdGF0ZU11dGFiaWxpdHlcIjogXCJ2aWV3XCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZnVuY3Rpb25cIlxuICAgICAgICAgICAgfVxuICAgICAgICBdO1xuICAgICAgICBjb25zdCBwdWJsaWNDbGllbnQgPSAvLyBAdHMtaWdub3JlIC0gdmllbSB2ZXJzaW9uIGNvbXBhdGliaWxpdHkgaXNzdWVcbiAgICAgICAgIGNyZWF0ZVB1YmxpY0NsaWVudCh7XG4gICAgICAgICAgICBjaGFpbjogdGhpcy5jaGFpbixcbiAgICAgICAgICAgIHRyYW5zcG9ydDogaHR0cCh0aGlzLnJwY1VybClcbiAgICAgICAgfSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBDYWxsIHJlZ2lzdHJhci5hdmFpbGFibGUobGFiZWwpIC0gcmV0dXJucyB0cnVlIGlmIGF2YWlsYWJsZSwgZmFsc2UgaWYgdGFrZW5cbiAgICAgICAgICAgIGNvbnN0IGlzQXZhaWxhYmxlID0gYXdhaXQgLy8gQHRzLWlnbm9yZSAtIHZpZW0gdmVyc2lvbiBjb21wYXRpYmlsaXR5IGlzc3VlXG4gICAgICAgICAgICAgcHVibGljQ2xpZW50LnJlYWRDb250cmFjdCh7XG4gICAgICAgICAgICAgICAgYWRkcmVzczogbDJSZWdpc3RyYXJBZGRyZXNzLFxuICAgICAgICAgICAgICAgIGFiaTogbDJSZWdpc3RyYXJBYmksXG4gICAgICAgICAgICAgICAgZnVuY3Rpb25OYW1lOiAnYXZhaWxhYmxlJyxcbiAgICAgICAgICAgICAgICBhcmdzOiBbbGFiZWxdXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIElmIG5vdCBhdmFpbGFibGUsIHRoZW4gaXQgaGFzIGFuIG93bmVyXG4gICAgICAgICAgICBjb25zdCBoYXNPd25lciA9ICFpc0F2YWlsYWJsZTtcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhgQUlBZ2VudEwyRU5TRHVyZW5DbGllbnQuaGFzQWdlbnROYW1lT3duZXI6IFwiJHtmdWxsU3VibmFtZX1cIiAobGFiZWw6IFwiJHtsYWJlbH1cIikgJHtoYXNPd25lciA/ICdIQVMgb3duZXInIDogJ2hhcyBOTyBvd25lcid9IChhdmFpbGFibGU6ICR7aXNBdmFpbGFibGV9KWApO1xuICAgICAgICAgICAgcmV0dXJuIGhhc093bmVyO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgY2hlY2tpbmcgYWdlbnQgbmFtZSBvd25lciB2aWEgcmVnaXN0cmFyOicsIGVycm9yKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBwcmVwYXJlQWRkQWdlbnROYW1lVG9PcmdDYWxscyhwYXJhbXMpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJBSUFnZW50TDJFTlNEdXJlbkNsaWVudC5wcmVwYXJlQWRkQWdlbnROYW1lVG9PcmdDYWxsc1wiKTtcbiAgICAgICAgY29uc29sZS5sb2coXCJvcmdOYW1lOiBcIiwgcGFyYW1zLm9yZ05hbWUpO1xuICAgICAgICBjb25zb2xlLmxvZyhcImFnZW50TmFtZTogXCIsIHBhcmFtcy5hZ2VudE5hbWUpO1xuICAgICAgICBjb25zb2xlLmxvZyhcImFnZW50QWRkcmVzczogXCIsIHBhcmFtcy5hZ2VudEFkZHJlc3MpO1xuICAgICAgICBjb25zb2xlLmxvZyhcImFnZW50VXJsOiBcIiwgcGFyYW1zLmFnZW50VXJsKTtcbiAgICAgICAgY29uc3QgY2xlYW4gPSAocykgPT4gKHMgfHwgJycpLnRyaW0oKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBjb25zdCBwYXJlbnQgPSBjbGVhbihwYXJhbXMub3JnTmFtZSkgKyBcIi5ldGhcIjtcbiAgICAgICAgY29uc3QgbGFiZWwgPSBjbGVhbihwYXJhbXMuYWdlbnROYW1lKS5yZXBsYWNlKC9cXHMrL2csICctJyk7XG4gICAgICAgIGNvbnN0IGZ1bGxTdWJuYW1lID0gYCR7bGFiZWx9LiR7cGFyZW50fWA7XG4gICAgICAgIGNvbnN0IGFnZW50QWRkcmVzcyA9IHBhcmFtcy5hZ2VudEFkZHJlc3M7XG4gICAgICAgIGNvbnN0IGFnZW50VXJsID0gcGFyYW1zLmFnZW50VXJsO1xuICAgICAgICBjb25zdCBjaGFpbk5hbWUgPSB0aGlzLmNoYWluLm5hbWUudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9cXHMrL2csICctJyk7XG4gICAgICAgIGNvbnNvbGUuaW5mbyhcInBhcmVudDogXCIsIHBhcmVudCk7XG4gICAgICAgIGNvbnNvbGUuaW5mbyhcImxhYmVsOiBcIiwgbGFiZWwpO1xuICAgICAgICBjb25zb2xlLmluZm8oXCJmdWxsU3VibmFtZTogXCIsIGZ1bGxTdWJuYW1lKTtcbiAgICAgICAgY29uc29sZS5pbmZvKFwiYWdlbnRBZGRyZXNzOiBcIiwgYWdlbnRBZGRyZXNzKTtcbiAgICAgICAgY29uc29sZS5pbmZvKFwiY2hhaW5OYW1lOiBcIiwgY2hhaW5OYW1lKTtcbiAgICAgICAgY29uc29sZS5pbmZvKFwiYWdlbnRVcmw6IFwiLCBhZ2VudFVybCk7XG4gICAgICAgIGNvbnN0IGNhbGxzID0gW107XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBTdGVwIDE6IFJlZ2lzdGVyIHRoZSBzdWJkb21haW4gd2l0aCBMMlJlZ2lzdHJhclxuICAgICAgICAgICAgY29uc3QgcmVnaXN0cmF0aW9uQ2FsbCA9IGF3YWl0IHRoaXMucmVnaXN0ZXJTdWJkb21haW4obGFiZWwsIGFnZW50QWRkcmVzcyk7XG4gICAgICAgICAgICAvLyBBZGQgcmVnaXN0cmF0aW9uIGNhbGxcbiAgICAgICAgICAgIGNhbGxzLnB1c2goLi4ucmVnaXN0cmF0aW9uQ2FsbC5jYWxscyk7XG4gICAgICAgICAgICAvKlxuICAgICAgXG4gICAgICAgICAgICAvLyBTdGVwIDI6IFNldCBhZGRyZXNzIHJlY29yZHMgZm9yIHRoZSBzdWJkb21haW5cbiAgICAgICAgICAgIGNvbnN0IGNoYWluSWQgPSAodGhpcyBhcyBhbnkpLmNoYWluLmlkO1xuICAgICAgXG4gICAgICAgICAgICAvLyBTZXQgQmFzZSBTZXBvbGlhIGFkZHJlc3MgcmVjb3JkIChjb2luVHlwZSAyMTQ3NTY4MTY0KVxuICAgICAgICAgICAgaWYgKGNoYWluSWQgPT09IDg0NTMyKSB7IC8vIEJhc2UgU2Vwb2xpYVxuICAgICAgICAgICAgICBjb25zdCBiYXNlQWRkckNhbGwgPSBhd2FpdCB0aGlzLnNldFJlc29sdmVyQWRkclJlY29yZERpcmVjdChcbiAgICAgICAgICAgICAgICBmdWxsU3VibmFtZSxcbiAgICAgICAgICAgICAgICAyMTQ3NTY4MTY0LCAvLyBCYXNlIFNlcG9saWEgY29pbiB0eXBlXG4gICAgICAgICAgICAgICAgYWdlbnRBZGRyZXNzXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGNhbGxzLnB1c2goYmFzZUFkZHJDYWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgIFxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBTZXQgRXRoZXJldW0gYWRkcmVzcyByZWNvcmQgKGNvaW5UeXBlIDYwKSBmb3IgY3Jvc3MtY2hhaW4gY29tcGF0aWJpbGl0eVxuICAgICAgICAgICAgY29uc3QgZXRoQWRkckNhbGwgPSBhd2FpdCB0aGlzLnNldFJlc29sdmVyQWRkclJlY29yZERpcmVjdChcbiAgICAgICAgICAgICAgZnVsbFN1Ym5hbWUsXG4gICAgICAgICAgICAgIDYwLCAvLyBFdGhlcmV1bSBjb2luIHR5cGVcbiAgICAgICAgICAgICAgYWdlbnRBZGRyZXNzXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgY2FsbHMucHVzaChldGhBZGRyQ2FsbCk7XG4gICAgICBcbiAgICAgIFxuICAgICAgICAgICAgLy8gU3RlcCAzOiBTZXQgcmVzb2x2ZXIgcmVjb3JkcyBmb3IgdGhlIHN1YmRvbWFpblxuICAgICAgICAgICAgY29uc3QgdGV4dFJlY29yZHMgPSBbXG4gICAgICAgICAgICAgIHsga2V5OiAnbmFtZScsIHZhbHVlOiBsYWJlbCB9LFxuICAgICAgICAgICAgICB7IGtleTogJ3VybCcsIHZhbHVlOiBhZ2VudFVybCB9LFxuICAgICAgICAgICAgICB7IGtleTogJ2Rlc2NyaXB0aW9uJywgdmFsdWU6IGBBZ2VudDogJHtsYWJlbH1gIH0sXG4gICAgICAgICAgICAgIHsga2V5OiAnY2hhaW4nLCB2YWx1ZTogY2hhaW5OYW1lIH0sXG4gICAgICAgICAgICAgIHsga2V5OiAnYWdlbnQtYWNjb3VudCcsIHZhbHVlOiBhZ2VudEFkZHJlc3MgfSxcbiAgICAgICAgICAgIF07XG4gICAgICBcbiAgICAgICAgICAgIGZvciAoY29uc3QgcmVjb3JkIG9mIHRleHRSZWNvcmRzKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHJlY29yZENhbGwgPSBhd2FpdCB0aGlzLnNldFJlc29sdmVyVGV4dFJlY29yZERpcmVjdChcbiAgICAgICAgICAgICAgICBmdWxsU3VibmFtZSxcbiAgICAgICAgICAgICAgICByZWNvcmQua2V5LFxuICAgICAgICAgICAgICAgIHJlY29yZC52YWx1ZSxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgY2FsbHMucHVzaChyZWNvcmRDYWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgIFxuICAgICAgXG4gICAgICBcbiAgICAgIFxuICAgICAgICAgICAgY29uc29sZS5pbmZvKFwiR2VuZXJhdGVkIGNhbGxzIGNvdW50OiBcIiwgY2FsbHMubGVuZ3RoKTtcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhcIkNhbGxzOiBcIiwgY2FsbHMpO1xuICAgICAgXG4gICAgICAgICAgICAqL1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIHByZXBhcmluZyBhZ2VudCBuYW1lIGNhbGxzOlwiLCBlcnJvcik7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBjYWxscyB9O1xuICAgIH1cbiAgICBhc3luYyBwcmVwYXJlQWRkQWdlbnRJbmZvQ2FsbHMocGFyYW1zKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiQUlBZ2VudEwyRU5TRHVyZW5DbGllbnQucHJlcGFyZUFkZEFnZW50TmFtZVRvT3JnQ2FsbHNcIik7XG4gICAgICAgIGNvbnNvbGUubG9nKFwib3JnTmFtZTogXCIsIHBhcmFtcy5vcmdOYW1lKTtcbiAgICAgICAgY29uc29sZS5sb2coXCJhZ2VudE5hbWU6IFwiLCBwYXJhbXMuYWdlbnROYW1lKTtcbiAgICAgICAgY29uc29sZS5sb2coXCJhZ2VudEFkZHJlc3M6IFwiLCBwYXJhbXMuYWdlbnRBZGRyZXNzKTtcbiAgICAgICAgY29uc29sZS5sb2coXCJhZ2VudFVybDogXCIsIHBhcmFtcy5hZ2VudFVybCk7XG4gICAgICAgIGNvbnN0IGNsZWFuID0gKHMpID0+IChzIHx8ICcnKS50cmltKCkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgY29uc3QgcGFyZW50ID0gY2xlYW4ocGFyYW1zLm9yZ05hbWUpICsgXCIuZXRoXCI7XG4gICAgICAgIGNvbnN0IGxhYmVsID0gY2xlYW4ocGFyYW1zLmFnZW50TmFtZSkucmVwbGFjZSgvXFxzKy9nLCAnLScpO1xuICAgICAgICBjb25zdCBmdWxsU3VibmFtZSA9IGAke2xhYmVsfS4ke3BhcmVudH1gO1xuICAgICAgICBjb25zdCBhZ2VudEFkZHJlc3MgPSBwYXJhbXMuYWdlbnRBZGRyZXNzO1xuICAgICAgICBjb25zdCBhZ2VudFVybCA9IHBhcmFtcy5hZ2VudFVybDtcbiAgICAgICAgY29uc3QgY2hhaW5OYW1lID0gdGhpcy5jaGFpbi5uYW1lLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvXFxzKy9nLCAnLScpO1xuICAgICAgICBjb25zb2xlLmluZm8oXCJwYXJlbnQ6IFwiLCBwYXJlbnQpO1xuICAgICAgICBjb25zb2xlLmluZm8oXCJsYWJlbDogXCIsIGxhYmVsKTtcbiAgICAgICAgY29uc29sZS5pbmZvKFwiZnVsbFN1Ym5hbWU6IFwiLCBmdWxsU3VibmFtZSk7XG4gICAgICAgIGNvbnNvbGUuaW5mbyhcImFnZW50QWRkcmVzczogXCIsIGFnZW50QWRkcmVzcyk7XG4gICAgICAgIGNvbnNvbGUuaW5mbyhcImNoYWluTmFtZTogXCIsIGNoYWluTmFtZSk7XG4gICAgICAgIGNvbnNvbGUuaW5mbyhcImFnZW50VXJsOiBcIiwgYWdlbnRVcmwpO1xuICAgICAgICBjb25zdCBjYWxscyA9IFtdO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gU3RlcCAyOiBTZXQgYWRkcmVzcyByZWNvcmRzIGZvciB0aGUgc3ViZG9tYWluXG4gICAgICAgICAgICBjb25zdCBjaGFpbklkID0gdGhpcy5jaGFpbi5pZDtcbiAgICAgICAgICAgIC8vIFNldCBCYXNlIFNlcG9saWEgYWRkcmVzcyByZWNvcmQgKGNvaW5UeXBlIDIxNDc1NjgxNjQpXG4gICAgICAgICAgICBpZiAoY2hhaW5JZCA9PT0gODQ1MzIpIHsgLy8gQmFzZSBTZXBvbGlhXG4gICAgICAgICAgICAgICAgY29uc3QgYmFzZUFkZHJDYWxsID0gYXdhaXQgdGhpcy5zZXRSZXNvbHZlckFkZHJSZWNvcmREaXJlY3QoZnVsbFN1Ym5hbWUsIDIxNDc1NjgxNjQsIC8vIEJhc2UgU2Vwb2xpYSBjb2luIHR5cGVcbiAgICAgICAgICAgICAgICBhZ2VudEFkZHJlc3MpO1xuICAgICAgICAgICAgICAgIGNhbGxzLnB1c2goYmFzZUFkZHJDYWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAvLyBTZXQgRXRoZXJldW0gYWRkcmVzcyByZWNvcmQgKGNvaW5UeXBlIDYwKSBmb3IgY3Jvc3MtY2hhaW4gY29tcGF0aWJpbGl0eVxuICAgICAgICAgICAgY29uc3QgZXRoQWRkckNhbGwgPSBhd2FpdCB0aGlzLnNldFJlc29sdmVyQWRkclJlY29yZERpcmVjdChcbiAgICAgICAgICAgICAgZnVsbFN1Ym5hbWUsXG4gICAgICAgICAgICAgIDYwLCAvLyBFdGhlcmV1bSBjb2luIHR5cGVcbiAgICAgICAgICAgICAgYWdlbnRBZGRyZXNzXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgY2FsbHMucHVzaChldGhBZGRyQ2FsbCk7XG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgLy8gU3RlcCAzOiBTZXQgcmVzb2x2ZXIgcmVjb3JkcyBmb3IgdGhlIHN1YmRvbWFpblxuICAgICAgICAgICAgY29uc3QgdGV4dFJlY29yZHMgPSBbXG4gICAgICAgICAgICAgICAgLy97IGtleTogJ25hbWUnLCB2YWx1ZTogbGFiZWwgfSxcbiAgICAgICAgICAgICAgICB7IGtleTogJ3VybCcsIHZhbHVlOiBhZ2VudFVybCB9LFxuICAgICAgICAgICAgICAgIC8veyBrZXk6ICdkZXNjcmlwdGlvbicsIHZhbHVlOiBgQWdlbnQ6ICR7bGFiZWx9YCB9LFxuICAgICAgICAgICAgICAgIC8veyBrZXk6ICdjaGFpbicsIHZhbHVlOiBjaGFpbk5hbWUgfSxcbiAgICAgICAgICAgICAgICAvL3sga2V5OiAnYWdlbnQtYWNjb3VudCcsIHZhbHVlOiBhZ2VudEFkZHJlc3MgfSxcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICAvLyBBZGQgZGVzY3JpcHRpb24gaWYgcHJvdmlkZWRcbiAgICAgICAgICAgIGlmIChwYXJhbXMuYWdlbnREZXNjcmlwdGlvbiAmJiBwYXJhbXMuYWdlbnREZXNjcmlwdGlvbi50cmltKCkgIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgdGV4dFJlY29yZHMucHVzaCh7IGtleTogJ2Rlc2NyaXB0aW9uJywgdmFsdWU6IHBhcmFtcy5hZ2VudERlc2NyaXB0aW9uLnRyaW0oKSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3QgcmVjb3JkIG9mIHRleHRSZWNvcmRzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVjb3JkQ2FsbCA9IGF3YWl0IHRoaXMuc2V0UmVzb2x2ZXJUZXh0UmVjb3JkRGlyZWN0KGZ1bGxTdWJuYW1lLCByZWNvcmQua2V5LCByZWNvcmQudmFsdWUpO1xuICAgICAgICAgICAgICAgIGNhbGxzLnB1c2gocmVjb3JkQ2FsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zb2xlLmluZm8oXCJHZW5lcmF0ZWQgY2FsbHMgY291bnQ6IFwiLCBjYWxscy5sZW5ndGgpO1xuICAgICAgICAgICAgY29uc29sZS5pbmZvKFwiQ2FsbHM6IFwiLCBjYWxscyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgcHJlcGFyaW5nIGFnZW50IG5hbWUgY2FsbHM6XCIsIGVycm9yKTtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGNhbGxzIH07XG4gICAgfVxuICAgIGFzeW5jIHByZXBhcmVTZXROYW1lVXJpQ2FsbHMobmFtZSwgdXJpKSB7XG4gICAgICAgIGNvbnN0IGNhbGxzID0gW107XG4gICAgICAgIHJldHVybiB7IGNhbGxzIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVyIHN1YmRvbWFpbiB1c2luZyBMMlJlZ2lzdHJhciBjb250cmFjdCAoQmFzZSBTZXBvbGlhIHNwZWNpZmljKVxuICAgICAqL1xuICAgIGFzeW5jIHJlZ2lzdGVyU3ViZG9tYWluKHN1YmRvbWFpbiwgb3duZXIpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJBSUFnZW50TDJFTlNEdXJlbkNsaWVudC5yZWdpc3RlclN1YmRvbWFpblwiKTtcbiAgICAgICAgY29uc29sZS5sb2coXCJzdWJkb21haW46XCIsIHN1YmRvbWFpbik7XG4gICAgICAgIGNvbnNvbGUubG9nKFwib3duZXI6XCIsIG93bmVyKTtcbiAgICAgICAgY29uc3QgY2FsbHMgPSBbXTtcbiAgICAgICAgLy8gTDJSZWdpc3RyYXIgQUJJIC0gMi1wYXJhbWV0ZXIgcmVnaXN0ZXIgZnVuY3Rpb25cbiAgICAgICAgY29uc3QgbDJSZWdpc3RyYXJBYmkgPSBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgXCJpbnB1dHNcIjogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBcImludGVybmFsVHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwibmFtZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCJcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJpbnRlcm5hbFR5cGVcIjogXCJhZGRyZXNzXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJvd25lclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYWRkcmVzc1wiXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcInJlZ2lzdGVyXCIsXG4gICAgICAgICAgICAgICAgXCJvdXRwdXRzXCI6IFtdLFxuICAgICAgICAgICAgICAgIFwic3RhdGVNdXRhYmlsaXR5XCI6IFwibm9ucGF5YWJsZVwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImZ1bmN0aW9uXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgXTtcbiAgICAgICAgLy8gVXNlIEwyUmVnaXN0cmFyIGNvbnRyYWN0IGFkZHJlc3MgZm9yIEJhc2UgU2Vwb2xpYVxuICAgICAgICBjb25zdCBsMlJlZ2lzdHJhckFkZHJlc3MgPSBcIjB4NjhDQWQwNzI1NzFFOGJlYTFEQTllNUMwNzEzNjdBYTZkZEM4RjM3RlwiO1xuICAgICAgICAvLyBSZWdpc3RlciBzdWJkb21haW4gdXNpbmcgTDJSZWdpc3RyYXIgKGVxdWl2YWxlbnQgdG8geW91ciBjYXN0IGNvbW1hbmQpXG4gICAgICAgIGNvbnN0IHJlZ2lzdGVyRGF0YSA9IGVuY29kZUZ1bmN0aW9uRGF0YSh7XG4gICAgICAgICAgICBhYmk6IGwyUmVnaXN0cmFyQWJpLFxuICAgICAgICAgICAgZnVuY3Rpb25OYW1lOiAncmVnaXN0ZXInLFxuICAgICAgICAgICAgYXJnczogW3N1YmRvbWFpbiwgb3duZXJdXG4gICAgICAgIH0pO1xuICAgICAgICBjYWxscy5wdXNoKHtcbiAgICAgICAgICAgIHRvOiBsMlJlZ2lzdHJhckFkZHJlc3MsXG4gICAgICAgICAgICBkYXRhOiByZWdpc3RlckRhdGEsXG4gICAgICAgICAgICB2YWx1ZTogMG5cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7IGNhbGxzIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERpcmVjdCBjaGFpbiBjYWxsIGZvciBzZXR0aW5nIHJlc29sdmVyIHJlY29yZHNcbiAgICAgKi9cbiAgICBhc3luYyBzZXRSZXNvbHZlclRleHRSZWNvcmREaXJlY3QobmFtZSwga2V5LCB2YWx1ZSkge1xuICAgICAgICBjb25zb2xlLmxvZyhcIkFJQWdlbnRMMkVOU0R1cmVuQ2xpZW50LnNldFJlc29sdmVyVGV4dFJlY29yZERpcmVjdFwiKTtcbiAgICAgICAgY29uc29sZS5sb2coXCJuYW1lOlwiLCBuYW1lKTtcbiAgICAgICAgY29uc29sZS5sb2coXCJrZXk6XCIsIGtleSk7XG4gICAgICAgIGNvbnNvbGUubG9nKFwidmFsdWU6XCIsIHZhbHVlKTtcbiAgICAgICAgY29uc3QgcmVzb2x2ZXJBZGRyZXNzID0gdGhpcy5nZXRFbnNSZXNvbHZlckFkZHJlc3MoKTtcbiAgICAgICAgLy8gRU5TIFJlc29sdmVyIEFCSSBmb3Igc2V0VGV4dFxuICAgICAgICBjb25zdCByZXNvbHZlckFiaSA9IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBcImlucHV0c1wiOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiaW50ZXJuYWxUeXBlXCI6IFwiYnl0ZXMzMlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwibm9kZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYnl0ZXMzMlwiXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiaW50ZXJuYWxUeXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJrZXlcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiaW50ZXJuYWxUeXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJ2YWx1ZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCJcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwic2V0VGV4dFwiLFxuICAgICAgICAgICAgICAgIFwib3V0cHV0c1wiOiBbXSxcbiAgICAgICAgICAgICAgICBcInN0YXRlTXV0YWJpbGl0eVwiOiBcIm5vbnBheWFibGVcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJmdW5jdGlvblwiXG4gICAgICAgICAgICB9XG4gICAgICAgIF07XG4gICAgICAgIC8vIENhbGN1bGF0ZSBuYW1laGFzaCBmb3IgdGhlIHN1YmRvbWFpblxuICAgICAgICBjb25zdCBub2RlID0gbmFtZWhhc2gobmFtZSk7XG4gICAgICAgIC8vIEVuY29kZSB0aGUgc2V0VGV4dCBmdW5jdGlvbiBjYWxsXG4gICAgICAgIGNvbnN0IGRhdGEgPSBlbmNvZGVGdW5jdGlvbkRhdGEoe1xuICAgICAgICAgICAgYWJpOiByZXNvbHZlckFiaSxcbiAgICAgICAgICAgIGZ1bmN0aW9uTmFtZTogJ3NldFRleHQnLFxuICAgICAgICAgICAgYXJnczogW25vZGUsIGtleSwgdmFsdWVdXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdG86IHJlc29sdmVyQWRkcmVzcyxcbiAgICAgICAgICAgIGRhdGFcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGlyZWN0IGNoYWluIGNhbGwgZm9yIHNldHRpbmcgcmVzb2x2ZXIgYWRkcmVzcyByZWNvcmRzXG4gICAgICogRXF1aXZhbGVudCB0bzogY2FzdCBzZW5kIHJlc29sdmVyIFwic2V0QWRkcihieXRlczMyLHVpbnQyNTYsYnl0ZXMpXCIgJE5PREUgY29pblR5cGUgZW5jb2RlZEFkZHJlc3NcbiAgICAgKi9cbiAgICBhc3luYyBzZXRSZXNvbHZlckFkZHJSZWNvcmREaXJlY3QobmFtZSwgY29pblR5cGUsIGFkZHJlc3MpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJBSUFnZW50TDJFTlNEdXJlbkNsaWVudC5zZXRSZXNvbHZlckFkZHJSZWNvcmREaXJlY3RcIik7XG4gICAgICAgIGNvbnNvbGUubG9nKFwibmFtZTpcIiwgbmFtZSk7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiY29pblR5cGU6XCIsIGNvaW5UeXBlKTtcbiAgICAgICAgY29uc29sZS5sb2coXCJhZGRyZXNzOlwiLCBhZGRyZXNzKTtcbiAgICAgICAgY29uc3QgcmVzb2x2ZXJBZGRyZXNzID0gdGhpcy5nZXRFbnNSZXNvbHZlckFkZHJlc3MoKTtcbiAgICAgICAgLy8gRU5TIFJlc29sdmVyIEFCSSBmb3Igc2V0QWRkclxuICAgICAgICBjb25zdCByZXNvbHZlckFiaSA9IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBcImlucHV0c1wiOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiaW50ZXJuYWxUeXBlXCI6IFwiYnl0ZXMzMlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwibm9kZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYnl0ZXMzMlwiXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiaW50ZXJuYWxUeXBlXCI6IFwidWludDI1NlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiY29pblR5cGVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInVpbnQyNTZcIlxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBcImludGVybmFsVHlwZVwiOiBcImJ5dGVzXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJhXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJieXRlc1wiXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcInNldEFkZHJcIixcbiAgICAgICAgICAgICAgICBcIm91dHB1dHNcIjogW10sXG4gICAgICAgICAgICAgICAgXCJzdGF0ZU11dGFiaWxpdHlcIjogXCJub25wYXlhYmxlXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZnVuY3Rpb25cIlxuICAgICAgICAgICAgfVxuICAgICAgICBdO1xuICAgICAgICAvLyBDYWxjdWxhdGUgbmFtZWhhc2ggZm9yIHRoZSBzdWJkb21haW5cbiAgICAgICAgY29uc3Qgbm9kZSA9IG5hbWVoYXNoKG5hbWUpO1xuICAgICAgICAvLyBFbmNvZGUgdGhlIGFkZHJlc3MgYWNjb3JkaW5nIHRvIHRoZSBjb2luIHR5cGVcbiAgICAgICAgLy8gRm9yIEJhc2UgU2Vwb2xpYSAoY29pblR5cGUgMjE0NzU2ODE2NCksIHdlIG5lZWQgdG8gZW5jb2RlIGFzIGJ5dGVzXG4gICAgICAgIGxldCBlbmNvZGVkQWRkcmVzcztcbiAgICAgICAgaWYgKGNvaW5UeXBlID09PSAyMTQ3NTY4MTY0KSB7XG4gICAgICAgICAgICAvLyBCYXNlIFNlcG9saWEgY29pbiB0eXBlIC0gZW5jb2RlIGFzIGJ5dGVzXG4gICAgICAgICAgICAvLyBFcXVpdmFsZW50IHRvOiAkKGNhc3QgYWJpLWVuY29kZSBcImYoYWRkcmVzcylcIiAweFlvdXJCYXNlQWRkcmVzcylcbiAgICAgICAgICAgIGVuY29kZWRBZGRyZXNzID0gZW5jb2RlRnVuY3Rpb25EYXRhKHtcbiAgICAgICAgICAgICAgICBhYmk6IFt7IFwiaW5wdXRzXCI6IFt7IFwiaW50ZXJuYWxUeXBlXCI6IFwiYWRkcmVzc1wiLCBcIm5hbWVcIjogXCJhZGRyXCIsIFwidHlwZVwiOiBcImFkZHJlc3NcIiB9XSwgXCJuYW1lXCI6IFwiZlwiLCBcIm91dHB1dHNcIjogW10sIFwic3RhdGVNdXRhYmlsaXR5XCI6IFwibm9ucGF5YWJsZVwiLCBcInR5cGVcIjogXCJmdW5jdGlvblwiIH1dLFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uTmFtZTogJ2YnLFxuICAgICAgICAgICAgICAgIGFyZ3M6IFthZGRyZXNzXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29pblR5cGUgPT09IDYwKSB7XG4gICAgICAgICAgICAvLyBFdGhlcmV1bSBjb2luIHR5cGUgLSBlbmNvZGUgYXMgMjAtYnl0ZSBhZGRyZXNzXG4gICAgICAgICAgICBlbmNvZGVkQWRkcmVzcyA9IGFkZHJlc3MucGFkRW5kKDY2LCAnMCcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gR2VuZXJpYyBlbmNvZGluZyBmb3Igb3RoZXIgY29pbiB0eXBlc1xuICAgICAgICAgICAgZW5jb2RlZEFkZHJlc3MgPSBhZGRyZXNzLnBhZEVuZCg2NiwgJzAnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zb2xlLmxvZyhcIm5vZGU6XCIsIG5vZGUpO1xuICAgICAgICBjb25zb2xlLmxvZyhcImVuY29kZWRBZGRyZXNzOlwiLCBlbmNvZGVkQWRkcmVzcyk7XG4gICAgICAgIC8vIEVuY29kZSB0aGUgc2V0QWRkciBmdW5jdGlvbiBjYWxsXG4gICAgICAgIGNvbnN0IGRhdGEgPSBlbmNvZGVGdW5jdGlvbkRhdGEoe1xuICAgICAgICAgICAgYWJpOiByZXNvbHZlckFiaSxcbiAgICAgICAgICAgIGZ1bmN0aW9uTmFtZTogJ3NldEFkZHInLFxuICAgICAgICAgICAgYXJnczogW25vZGUsIEJpZ0ludChjb2luVHlwZSksIGVuY29kZWRBZGRyZXNzXVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRvOiByZXNvbHZlckFkZHJlc3MsXG4gICAgICAgICAgICBkYXRhXG4gICAgICAgIH07XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QUlBZ2VudEwyRU5TRHVyZW5DbGllbnQuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@agentic-trust/8004-ext-sdk/dist/AIAgentL2ENSDurenClient.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@agentic-trust/8004-ext-sdk/dist/AIAgentL2ENSNamespaceClient.js":
/*!******************************************************************************************!*\
  !*** ../../node_modules/@agentic-trust/8004-ext-sdk/dist/AIAgentL2ENSNamespaceClient.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AIAgentL2ENSNamespaceClient: () => (/* binding */ AIAgentL2ENSNamespaceClient)\n/* harmony export */ });\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! viem */ \"(rsc)/../../node_modules/viem/_esm/utils/ens/namehash.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! viem */ \"(rsc)/../../node_modules/viem/_esm/utils/abi/encodeFunctionData.js\");\n/* harmony import */ var _AIAgentENSClient__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AIAgentENSClient */ \"(rsc)/../../node_modules/@agentic-trust/8004-ext-sdk/dist/AIAgentENSClient.js\");\n/* harmony import */ var _thenamespace_mint_manager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @thenamespace/mint-manager */ \"(rsc)/../../node_modules/@thenamespace/mint-manager/dist/index.js\");\n/* harmony import */ var _thenamespace_indexer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @thenamespace/indexer */ \"(rsc)/../../node_modules/@thenamespace/indexer/dist/index.js\");\n/* harmony import */ var viem_chains__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! viem/chains */ \"(rsc)/../../node_modules/viem/_esm/chains/definitions/sepolia.js\");\n/* harmony import */ var viem_chains__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! viem/chains */ \"(rsc)/../../node_modules/viem/_esm/chains/definitions/baseSepolia.js\");\n/* harmony import */ var viem_chains__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! viem/chains */ \"(rsc)/../../node_modules/viem/_esm/chains/definitions/optimismSepolia.js\");\n/**\n * L2 ENS Client for Base Sepolia and Optimism Sepolia\n * Extends AIAgentENSClient with namespace.ninja integration for L2 subname operations\n */\n\n\n// @ts-ignore - @thenamespace/mint-manager doesn't have type definitions\n\n\n\nclass AIAgentL2ENSNamespaceClient extends _AIAgentENSClient__WEBPACK_IMPORTED_MODULE_0__.AIAgentENSClient {\n    namespaceClient = null;\n    constructor(chain, rpcUrl, adapter, ensRegistryAddress, ensResolverAddress, identityRegistryAddress) {\n        super(chain, rpcUrl, adapter, ensRegistryAddress, ensResolverAddress, identityRegistryAddress);\n        this.initializeNamespaceClient();\n    }\n    /**\n     * Override to ensure L2 client always returns true for isL2()\n     */\n    isL2() {\n        return true; // This is always an L2 client\n    }\n    /**\n     * Override to ensure L2 client always returns false for isL1()\n     */\n    isL1() {\n        return false; // This is never an L1 client\n    }\n    /**\n     * Override to ensure L2 client always returns 'L2'\n     */\n    getChainType() {\n        return 'L2';\n    }\n    initializeNamespaceClient() {\n        try {\n            const client = (0,_thenamespace_mint_manager__WEBPACK_IMPORTED_MODULE_1__.createMintClient)({\n                isTestnet: true, // Use testnet (sepolia)\n                cursomRpcUrls: {\n                    [viem_chains__WEBPACK_IMPORTED_MODULE_3__.sepolia.id]: process.env.ETH_SEPOLIA_RPC_URL || '',\n                    [viem_chains__WEBPACK_IMPORTED_MODULE_4__.baseSepolia.id]: process.env.BASE_SEPOLIA_RPC_URL || '',\n                    [viem_chains__WEBPACK_IMPORTED_MODULE_5__.optimismSepolia.id]: process.env.OP_SEPOLIA_RPC_URL || '',\n                }\n            });\n            this.namespaceClient = client;\n            console.info('Namespace.ninja L2 client initialized successfully');\n        }\n        catch (error) {\n            console.error('Failed to initialize namespace.ninja L2 client:', error);\n        }\n    }\n    async getAgentUrlByName(name) {\n        // If standard lookup fails and we have namespace client, try L2 lookup\n        if (this.namespaceClient) {\n            try {\n                const chainId = this.chain.id;\n                const isAvailable = await this.namespaceClient.isL2SubnameAvailable(name, chainId);\n                if (!isAvailable) {\n                    const client = (0,_thenamespace_indexer__WEBPACK_IMPORTED_MODULE_2__.createIndexerClient)();\n                    const subname = await client.getL2Subname({\n                        chainId: this.chain.id,\n                        nameOrNamehash: (0,viem__WEBPACK_IMPORTED_MODULE_6__.namehash)(name)\n                    });\n                    console.info(\"subname for name: \", name, \" is: \", subname);\n                    if (subname) {\n                        if (subname.records?.texts?.url) {\n                            const url = subname.records?.texts?.url;\n                            return url;\n                        }\n                    }\n                    return null;\n                }\n            }\n            catch (error) {\n                console.error('Error checking L2 subname availability 1:', error);\n            }\n        }\n        return null;\n    }\n    /**\n     * Override getAgentAccountByName to use namespace.ninja for L2 availability checking\n     */\n    async getAgentAccountByName(name) {\n        console.info(\"AIAgentL2ENSClient.getAgentAccountByName: \", name);\n        // If standard lookup fails and we have namespace client, try L2 lookup\n        if (this.namespaceClient) {\n            try {\n                const chainId = this.chain.id;\n                const isAvailable = await this.namespaceClient.isL2SubnameAvailable(name, chainId);\n                if (!isAvailable) {\n                    console.info(\"AIAgentL2ENSClient.getAgentAccountByName: not available\");\n                    const client = (0,_thenamespace_indexer__WEBPACK_IMPORTED_MODULE_2__.createIndexerClient)();\n                    const subname = await client.getL2Subname({\n                        chainId: this.chain.id,\n                        nameOrNamehash: (0,viem__WEBPACK_IMPORTED_MODULE_6__.namehash)(name)\n                    });\n                    console.info(\"AIAgentL2ENSClient.getAgentAccountByName: subname: \", subname);\n                    if (subname) {\n                        console.info(\"AIAgentL2ENSClient.getAgentAccountByName: subname.owner: \", subname.owner);\n                        return subname.owner;\n                    }\n                    return null;\n                }\n            }\n            catch (error) {\n                console.error('Error checking L2 subname availability 2:', error);\n            }\n        }\n        return null;\n    }\n    /**\n     * Get the namespace client instance\n     */\n    getNamespaceClient() {\n        return this.namespaceClient;\n    }\n    /**\n     * Note: getAgentEoaByAgentAccount is not a method of AIAgentENSClient\n     * This method is actually in AIAgentIdentityClient, so we don't need to override it here.\n     * The ownership detection logic is handled in the UI layer (AddAgentModal.tsx)\n     */\n    /**\n     * Override hasAgentNameOwner to use namespace.ninja for L2 availability checking\n     */\n    async hasAgentNameOwner(orgName, agentName) {\n        console.info(\"AIAgentL2ENSNamespaceClient.hasAgentNameOwner\");\n        const clean = (s) => (s || '').trim().toLowerCase();\n        const parent = clean(orgName) + \".eth\";\n        const label = clean(agentName).replace(/\\s+/g, '-');\n        const fullSubname = `${label}.${parent}`;\n        // Use namespace.ninja to check if subname exists\n        if (this.namespaceClient) {\n            try {\n                const chainId = this.chain.id;\n                const isAvailable = await this.namespaceClient.isL2SubnameAvailable(fullSubname, chainId);\n                const hasOwner = !isAvailable; // If not available, it has an owner\n                console.info(`AIAgentL2ENSNamespaceClient.hasAgentNameOwner: \"${fullSubname}\" ${hasOwner ? 'HAS owner' : 'has NO owner'}`);\n                return hasOwner;\n            }\n            catch (error) {\n                console.error('Error checking agent name owner:', error);\n                return false;\n            }\n        }\n        return false;\n    }\n    /**\n     * Override prepareAddAgentNameToOrgCalls to use namespace.ninja SDK for L2\n     */\n    async prepareAddAgentNameToOrgCalls(params) {\n        console.log(\"AIAgentL2ENSClient.prepareAddAgentNameToOrgCalls\");\n        console.log(\"orgName: \", params.orgName);\n        console.log(\"agentName: \", params.agentName);\n        console.log(\"agentAddress: \", params.agentAddress);\n        const clean = (s) => (s || '').trim().toLowerCase();\n        const parent = clean(params.orgName) + \".eth\";\n        const label = clean(params.agentName).replace(/\\s+/g, '-');\n        const fullSubname = `${label}.${parent}.eth`;\n        const agentAddress = params.agentAddress;\n        const agentUrl = params.agentUrl;\n        const chainName = this.chain.name.toLowerCase().replace(/\\s+/g, '-');\n        console.info(\"parent: \", parent);\n        console.info(\"label: \", label);\n        console.info(\"agentAddress: \", agentAddress);\n        console.info(\"chainName: \", chainName);\n        console.info(\"agentUrl: \", agentUrl);\n        // Prepare mint transaction parameters using namespace.ninja SDK\n        const mintRequest = {\n            parentName: parent, // e.g., \"theorg.eth\"\n            label: label, // e.g., \"atl-test-1\"\n            owner: agentAddress,\n            minterAddress: agentAddress,\n            records: {\n                texts: [\n                    { key: 'name', value: label },\n                    { key: 'url', value: agentUrl },\n                    { key: 'description', value: `Agent: ${label}` },\n                    { key: 'chain', value: chainName },\n                    { key: 'agent-account', value: agentAddress },\n                ],\n                addresses: [\n                    {\n                        chain: 60, // Ethereum coin type\n                        value: agentAddress\n                    },\n                ],\n            }\n        };\n        console.info(\"mintRequest: \", mintRequest);\n        const mintParams = await this.namespaceClient.getMintTransactionParameters(mintRequest);\n        console.info(\"mintParams: \", mintParams);\n        const { to, data, value } = {\n            to: mintParams.contractAddress,\n            data: (0,viem__WEBPACK_IMPORTED_MODULE_7__.encodeFunctionData)({\n                abi: mintParams.abi,\n                functionName: mintParams.functionName,\n                args: mintParams.args,\n            }),\n            value: mintParams.value || 0n\n        };\n        const rtnCalls = [{\n                to: to,\n                data: data,\n                value: value,\n            }];\n        // Return the mint transaction parameters as calls\n        return { calls: rtnCalls };\n    }\n    async prepareSetNameUriCalls(name, uri) {\n        const calls = [];\n        return { calls };\n    }\n}\n//# sourceMappingURL=AIAgentL2ENSNamespaceClient.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BhZ2VudGljLXRydXN0LzgwMDQtZXh0LXNkay9kaXN0L0FJQWdlbnRMMkVOU05hbWVzcGFjZUNsaWVudC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNvRDtBQUNFO0FBQ3REO0FBQzhEO0FBQ0Y7QUFDUTtBQUM3RCwwQ0FBMEMsK0RBQWdCO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiw0RUFBZ0I7QUFDM0M7QUFDQTtBQUNBLHFCQUFxQixnREFBTztBQUM1QixxQkFBcUIsb0RBQVc7QUFDaEMscUJBQXFCLHdEQUFlO0FBQ3BDO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsMEVBQW1CO0FBQ3REO0FBQ0E7QUFDQSx3Q0FBd0MsOENBQVE7QUFDaEQscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLDBFQUFtQjtBQUN0RDtBQUNBO0FBQ0Esd0NBQXdDLDhDQUFRO0FBQ2hELHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsTUFBTSxHQUFHLE9BQU87QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQyxnRkFBZ0YsWUFBWSxJQUFJLHdDQUF3QztBQUN4STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLE1BQU0sR0FBRyxPQUFPO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDJCQUEyQjtBQUNqRCxzQkFBc0IsNkJBQTZCO0FBQ25ELHNCQUFzQixxQ0FBcUMsTUFBTSxHQUFHO0FBQ3BFLHNCQUFzQixnQ0FBZ0M7QUFDdEQsc0JBQXNCLDJDQUEyQztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixrQkFBa0I7QUFDbEM7QUFDQSxrQkFBa0Isd0RBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvYmFyYi9hYS9Bc3NvY2lhdGVkQWNjb3VudHMvbm9kZV9tb2R1bGVzL0BhZ2VudGljLXRydXN0LzgwMDQtZXh0LXNkay9kaXN0L0FJQWdlbnRMMkVOU05hbWVzcGFjZUNsaWVudC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEwyIEVOUyBDbGllbnQgZm9yIEJhc2UgU2Vwb2xpYSBhbmQgT3B0aW1pc20gU2Vwb2xpYVxuICogRXh0ZW5kcyBBSUFnZW50RU5TQ2xpZW50IHdpdGggbmFtZXNwYWNlLm5pbmphIGludGVncmF0aW9uIGZvciBMMiBzdWJuYW1lIG9wZXJhdGlvbnNcbiAqL1xuaW1wb3J0IHsgZW5jb2RlRnVuY3Rpb25EYXRhLCBuYW1laGFzaCB9IGZyb20gJ3ZpZW0nO1xuaW1wb3J0IHsgQUlBZ2VudEVOU0NsaWVudCB9IGZyb20gJy4vQUlBZ2VudEVOU0NsaWVudCc7XG4vLyBAdHMtaWdub3JlIC0gQHRoZW5hbWVzcGFjZS9taW50LW1hbmFnZXIgZG9lc24ndCBoYXZlIHR5cGUgZGVmaW5pdGlvbnNcbmltcG9ydCB7IGNyZWF0ZU1pbnRDbGllbnQgfSBmcm9tICdAdGhlbmFtZXNwYWNlL21pbnQtbWFuYWdlcic7XG5pbXBvcnQgeyBjcmVhdGVJbmRleGVyQ2xpZW50IH0gZnJvbSAnQHRoZW5hbWVzcGFjZS9pbmRleGVyJztcbmltcG9ydCB7IHNlcG9saWEsIGJhc2VTZXBvbGlhLCBvcHRpbWlzbVNlcG9saWEgfSBmcm9tICd2aWVtL2NoYWlucyc7XG5leHBvcnQgY2xhc3MgQUlBZ2VudEwyRU5TTmFtZXNwYWNlQ2xpZW50IGV4dGVuZHMgQUlBZ2VudEVOU0NsaWVudCB7XG4gICAgbmFtZXNwYWNlQ2xpZW50ID0gbnVsbDtcbiAgICBjb25zdHJ1Y3RvcihjaGFpbiwgcnBjVXJsLCBhZGFwdGVyLCBlbnNSZWdpc3RyeUFkZHJlc3MsIGVuc1Jlc29sdmVyQWRkcmVzcywgaWRlbnRpdHlSZWdpc3RyeUFkZHJlc3MpIHtcbiAgICAgICAgc3VwZXIoY2hhaW4sIHJwY1VybCwgYWRhcHRlciwgZW5zUmVnaXN0cnlBZGRyZXNzLCBlbnNSZXNvbHZlckFkZHJlc3MsIGlkZW50aXR5UmVnaXN0cnlBZGRyZXNzKTtcbiAgICAgICAgdGhpcy5pbml0aWFsaXplTmFtZXNwYWNlQ2xpZW50KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlIHRvIGVuc3VyZSBMMiBjbGllbnQgYWx3YXlzIHJldHVybnMgdHJ1ZSBmb3IgaXNMMigpXG4gICAgICovXG4gICAgaXNMMigpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7IC8vIFRoaXMgaXMgYWx3YXlzIGFuIEwyIGNsaWVudFxuICAgIH1cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZSB0byBlbnN1cmUgTDIgY2xpZW50IGFsd2F5cyByZXR1cm5zIGZhbHNlIGZvciBpc0wxKClcbiAgICAgKi9cbiAgICBpc0wxKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7IC8vIFRoaXMgaXMgbmV2ZXIgYW4gTDEgY2xpZW50XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlIHRvIGVuc3VyZSBMMiBjbGllbnQgYWx3YXlzIHJldHVybnMgJ0wyJ1xuICAgICAqL1xuICAgIGdldENoYWluVHlwZSgpIHtcbiAgICAgICAgcmV0dXJuICdMMic7XG4gICAgfVxuICAgIGluaXRpYWxpemVOYW1lc3BhY2VDbGllbnQoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBjbGllbnQgPSBjcmVhdGVNaW50Q2xpZW50KHtcbiAgICAgICAgICAgICAgICBpc1Rlc3RuZXQ6IHRydWUsIC8vIFVzZSB0ZXN0bmV0IChzZXBvbGlhKVxuICAgICAgICAgICAgICAgIGN1cnNvbVJwY1VybHM6IHtcbiAgICAgICAgICAgICAgICAgICAgW3NlcG9saWEuaWRdOiBwcm9jZXNzLmVudi5FVEhfU0VQT0xJQV9SUENfVVJMIHx8ICcnLFxuICAgICAgICAgICAgICAgICAgICBbYmFzZVNlcG9saWEuaWRdOiBwcm9jZXNzLmVudi5CQVNFX1NFUE9MSUFfUlBDX1VSTCB8fCAnJyxcbiAgICAgICAgICAgICAgICAgICAgW29wdGltaXNtU2Vwb2xpYS5pZF06IHByb2Nlc3MuZW52Lk9QX1NFUE9MSUFfUlBDX1VSTCB8fCAnJyxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMubmFtZXNwYWNlQ2xpZW50ID0gY2xpZW50O1xuICAgICAgICAgICAgY29uc29sZS5pbmZvKCdOYW1lc3BhY2UubmluamEgTDIgY2xpZW50IGluaXRpYWxpemVkIHN1Y2Nlc3NmdWxseScpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGluaXRpYWxpemUgbmFtZXNwYWNlLm5pbmphIEwyIGNsaWVudDonLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZ2V0QWdlbnRVcmxCeU5hbWUobmFtZSkge1xuICAgICAgICAvLyBJZiBzdGFuZGFyZCBsb29rdXAgZmFpbHMgYW5kIHdlIGhhdmUgbmFtZXNwYWNlIGNsaWVudCwgdHJ5IEwyIGxvb2t1cFxuICAgICAgICBpZiAodGhpcy5uYW1lc3BhY2VDbGllbnQpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2hhaW5JZCA9IHRoaXMuY2hhaW4uaWQ7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNBdmFpbGFibGUgPSBhd2FpdCB0aGlzLm5hbWVzcGFjZUNsaWVudC5pc0wyU3VibmFtZUF2YWlsYWJsZShuYW1lLCBjaGFpbklkKTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzQXZhaWxhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNsaWVudCA9IGNyZWF0ZUluZGV4ZXJDbGllbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3VibmFtZSA9IGF3YWl0IGNsaWVudC5nZXRMMlN1Ym5hbWUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhaW5JZDogdGhpcy5jaGFpbi5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWVPck5hbWVoYXNoOiBuYW1laGFzaChuYW1lKVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5pbmZvKFwic3VibmFtZSBmb3IgbmFtZTogXCIsIG5hbWUsIFwiIGlzOiBcIiwgc3VibmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdWJuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3VibmFtZS5yZWNvcmRzPy50ZXh0cz8udXJsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdXJsID0gc3VibmFtZS5yZWNvcmRzPy50ZXh0cz8udXJsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB1cmw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgY2hlY2tpbmcgTDIgc3VibmFtZSBhdmFpbGFiaWxpdHkgMTonLCBlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlIGdldEFnZW50QWNjb3VudEJ5TmFtZSB0byB1c2UgbmFtZXNwYWNlLm5pbmphIGZvciBMMiBhdmFpbGFiaWxpdHkgY2hlY2tpbmdcbiAgICAgKi9cbiAgICBhc3luYyBnZXRBZ2VudEFjY291bnRCeU5hbWUobmFtZSkge1xuICAgICAgICBjb25zb2xlLmluZm8oXCJBSUFnZW50TDJFTlNDbGllbnQuZ2V0QWdlbnRBY2NvdW50QnlOYW1lOiBcIiwgbmFtZSk7XG4gICAgICAgIC8vIElmIHN0YW5kYXJkIGxvb2t1cCBmYWlscyBhbmQgd2UgaGF2ZSBuYW1lc3BhY2UgY2xpZW50LCB0cnkgTDIgbG9va3VwXG4gICAgICAgIGlmICh0aGlzLm5hbWVzcGFjZUNsaWVudCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGFpbklkID0gdGhpcy5jaGFpbi5pZDtcbiAgICAgICAgICAgICAgICBjb25zdCBpc0F2YWlsYWJsZSA9IGF3YWl0IHRoaXMubmFtZXNwYWNlQ2xpZW50LmlzTDJTdWJuYW1lQXZhaWxhYmxlKG5hbWUsIGNoYWluSWQpO1xuICAgICAgICAgICAgICAgIGlmICghaXNBdmFpbGFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5pbmZvKFwiQUlBZ2VudEwyRU5TQ2xpZW50LmdldEFnZW50QWNjb3VudEJ5TmFtZTogbm90IGF2YWlsYWJsZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2xpZW50ID0gY3JlYXRlSW5kZXhlckNsaWVudCgpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdWJuYW1lID0gYXdhaXQgY2xpZW50LmdldEwyU3VibmFtZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFpbklkOiB0aGlzLmNoYWluLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZU9yTmFtZWhhc2g6IG5hbWVoYXNoKG5hbWUpXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmluZm8oXCJBSUFnZW50TDJFTlNDbGllbnQuZ2V0QWdlbnRBY2NvdW50QnlOYW1lOiBzdWJuYW1lOiBcIiwgc3VibmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdWJuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmluZm8oXCJBSUFnZW50TDJFTlNDbGllbnQuZ2V0QWdlbnRBY2NvdW50QnlOYW1lOiBzdWJuYW1lLm93bmVyOiBcIiwgc3VibmFtZS5vd25lcik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3VibmFtZS5vd25lcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjaGVja2luZyBMMiBzdWJuYW1lIGF2YWlsYWJpbGl0eSAyOicsIGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBuYW1lc3BhY2UgY2xpZW50IGluc3RhbmNlXG4gICAgICovXG4gICAgZ2V0TmFtZXNwYWNlQ2xpZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5uYW1lc3BhY2VDbGllbnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE5vdGU6IGdldEFnZW50RW9hQnlBZ2VudEFjY291bnQgaXMgbm90IGEgbWV0aG9kIG9mIEFJQWdlbnRFTlNDbGllbnRcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBhY3R1YWxseSBpbiBBSUFnZW50SWRlbnRpdHlDbGllbnQsIHNvIHdlIGRvbid0IG5lZWQgdG8gb3ZlcnJpZGUgaXQgaGVyZS5cbiAgICAgKiBUaGUgb3duZXJzaGlwIGRldGVjdGlvbiBsb2dpYyBpcyBoYW5kbGVkIGluIHRoZSBVSSBsYXllciAoQWRkQWdlbnRNb2RhbC50c3gpXG4gICAgICovXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGUgaGFzQWdlbnROYW1lT3duZXIgdG8gdXNlIG5hbWVzcGFjZS5uaW5qYSBmb3IgTDIgYXZhaWxhYmlsaXR5IGNoZWNraW5nXG4gICAgICovXG4gICAgYXN5bmMgaGFzQWdlbnROYW1lT3duZXIob3JnTmFtZSwgYWdlbnROYW1lKSB7XG4gICAgICAgIGNvbnNvbGUuaW5mbyhcIkFJQWdlbnRMMkVOU05hbWVzcGFjZUNsaWVudC5oYXNBZ2VudE5hbWVPd25lclwiKTtcbiAgICAgICAgY29uc3QgY2xlYW4gPSAocykgPT4gKHMgfHwgJycpLnRyaW0oKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBjb25zdCBwYXJlbnQgPSBjbGVhbihvcmdOYW1lKSArIFwiLmV0aFwiO1xuICAgICAgICBjb25zdCBsYWJlbCA9IGNsZWFuKGFnZW50TmFtZSkucmVwbGFjZSgvXFxzKy9nLCAnLScpO1xuICAgICAgICBjb25zdCBmdWxsU3VibmFtZSA9IGAke2xhYmVsfS4ke3BhcmVudH1gO1xuICAgICAgICAvLyBVc2UgbmFtZXNwYWNlLm5pbmphIHRvIGNoZWNrIGlmIHN1Ym5hbWUgZXhpc3RzXG4gICAgICAgIGlmICh0aGlzLm5hbWVzcGFjZUNsaWVudCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGFpbklkID0gdGhpcy5jaGFpbi5pZDtcbiAgICAgICAgICAgICAgICBjb25zdCBpc0F2YWlsYWJsZSA9IGF3YWl0IHRoaXMubmFtZXNwYWNlQ2xpZW50LmlzTDJTdWJuYW1lQXZhaWxhYmxlKGZ1bGxTdWJuYW1lLCBjaGFpbklkKTtcbiAgICAgICAgICAgICAgICBjb25zdCBoYXNPd25lciA9ICFpc0F2YWlsYWJsZTsgLy8gSWYgbm90IGF2YWlsYWJsZSwgaXQgaGFzIGFuIG93bmVyXG4gICAgICAgICAgICAgICAgY29uc29sZS5pbmZvKGBBSUFnZW50TDJFTlNOYW1lc3BhY2VDbGllbnQuaGFzQWdlbnROYW1lT3duZXI6IFwiJHtmdWxsU3VibmFtZX1cIiAke2hhc093bmVyID8gJ0hBUyBvd25lcicgOiAnaGFzIE5PIG93bmVyJ31gKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaGFzT3duZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjaGVja2luZyBhZ2VudCBuYW1lIG93bmVyOicsIGVycm9yKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZSBwcmVwYXJlQWRkQWdlbnROYW1lVG9PcmdDYWxscyB0byB1c2UgbmFtZXNwYWNlLm5pbmphIFNESyBmb3IgTDJcbiAgICAgKi9cbiAgICBhc3luYyBwcmVwYXJlQWRkQWdlbnROYW1lVG9PcmdDYWxscyhwYXJhbXMpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJBSUFnZW50TDJFTlNDbGllbnQucHJlcGFyZUFkZEFnZW50TmFtZVRvT3JnQ2FsbHNcIik7XG4gICAgICAgIGNvbnNvbGUubG9nKFwib3JnTmFtZTogXCIsIHBhcmFtcy5vcmdOYW1lKTtcbiAgICAgICAgY29uc29sZS5sb2coXCJhZ2VudE5hbWU6IFwiLCBwYXJhbXMuYWdlbnROYW1lKTtcbiAgICAgICAgY29uc29sZS5sb2coXCJhZ2VudEFkZHJlc3M6IFwiLCBwYXJhbXMuYWdlbnRBZGRyZXNzKTtcbiAgICAgICAgY29uc3QgY2xlYW4gPSAocykgPT4gKHMgfHwgJycpLnRyaW0oKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBjb25zdCBwYXJlbnQgPSBjbGVhbihwYXJhbXMub3JnTmFtZSkgKyBcIi5ldGhcIjtcbiAgICAgICAgY29uc3QgbGFiZWwgPSBjbGVhbihwYXJhbXMuYWdlbnROYW1lKS5yZXBsYWNlKC9cXHMrL2csICctJyk7XG4gICAgICAgIGNvbnN0IGZ1bGxTdWJuYW1lID0gYCR7bGFiZWx9LiR7cGFyZW50fS5ldGhgO1xuICAgICAgICBjb25zdCBhZ2VudEFkZHJlc3MgPSBwYXJhbXMuYWdlbnRBZGRyZXNzO1xuICAgICAgICBjb25zdCBhZ2VudFVybCA9IHBhcmFtcy5hZ2VudFVybDtcbiAgICAgICAgY29uc3QgY2hhaW5OYW1lID0gdGhpcy5jaGFpbi5uYW1lLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvXFxzKy9nLCAnLScpO1xuICAgICAgICBjb25zb2xlLmluZm8oXCJwYXJlbnQ6IFwiLCBwYXJlbnQpO1xuICAgICAgICBjb25zb2xlLmluZm8oXCJsYWJlbDogXCIsIGxhYmVsKTtcbiAgICAgICAgY29uc29sZS5pbmZvKFwiYWdlbnRBZGRyZXNzOiBcIiwgYWdlbnRBZGRyZXNzKTtcbiAgICAgICAgY29uc29sZS5pbmZvKFwiY2hhaW5OYW1lOiBcIiwgY2hhaW5OYW1lKTtcbiAgICAgICAgY29uc29sZS5pbmZvKFwiYWdlbnRVcmw6IFwiLCBhZ2VudFVybCk7XG4gICAgICAgIC8vIFByZXBhcmUgbWludCB0cmFuc2FjdGlvbiBwYXJhbWV0ZXJzIHVzaW5nIG5hbWVzcGFjZS5uaW5qYSBTREtcbiAgICAgICAgY29uc3QgbWludFJlcXVlc3QgPSB7XG4gICAgICAgICAgICBwYXJlbnROYW1lOiBwYXJlbnQsIC8vIGUuZy4sIFwidGhlb3JnLmV0aFwiXG4gICAgICAgICAgICBsYWJlbDogbGFiZWwsIC8vIGUuZy4sIFwiYXRsLXRlc3QtMVwiXG4gICAgICAgICAgICBvd25lcjogYWdlbnRBZGRyZXNzLFxuICAgICAgICAgICAgbWludGVyQWRkcmVzczogYWdlbnRBZGRyZXNzLFxuICAgICAgICAgICAgcmVjb3Jkczoge1xuICAgICAgICAgICAgICAgIHRleHRzOiBbXG4gICAgICAgICAgICAgICAgICAgIHsga2V5OiAnbmFtZScsIHZhbHVlOiBsYWJlbCB9LFxuICAgICAgICAgICAgICAgICAgICB7IGtleTogJ3VybCcsIHZhbHVlOiBhZ2VudFVybCB9LFxuICAgICAgICAgICAgICAgICAgICB7IGtleTogJ2Rlc2NyaXB0aW9uJywgdmFsdWU6IGBBZ2VudDogJHtsYWJlbH1gIH0sXG4gICAgICAgICAgICAgICAgICAgIHsga2V5OiAnY2hhaW4nLCB2YWx1ZTogY2hhaW5OYW1lIH0sXG4gICAgICAgICAgICAgICAgICAgIHsga2V5OiAnYWdlbnQtYWNjb3VudCcsIHZhbHVlOiBhZ2VudEFkZHJlc3MgfSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIGFkZHJlc3NlczogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFpbjogNjAsIC8vIEV0aGVyZXVtIGNvaW4gdHlwZVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGFnZW50QWRkcmVzc1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGNvbnNvbGUuaW5mbyhcIm1pbnRSZXF1ZXN0OiBcIiwgbWludFJlcXVlc3QpO1xuICAgICAgICBjb25zdCBtaW50UGFyYW1zID0gYXdhaXQgdGhpcy5uYW1lc3BhY2VDbGllbnQuZ2V0TWludFRyYW5zYWN0aW9uUGFyYW1ldGVycyhtaW50UmVxdWVzdCk7XG4gICAgICAgIGNvbnNvbGUuaW5mbyhcIm1pbnRQYXJhbXM6IFwiLCBtaW50UGFyYW1zKTtcbiAgICAgICAgY29uc3QgeyB0bywgZGF0YSwgdmFsdWUgfSA9IHtcbiAgICAgICAgICAgIHRvOiBtaW50UGFyYW1zLmNvbnRyYWN0QWRkcmVzcyxcbiAgICAgICAgICAgIGRhdGE6IGVuY29kZUZ1bmN0aW9uRGF0YSh7XG4gICAgICAgICAgICAgICAgYWJpOiBtaW50UGFyYW1zLmFiaSxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbk5hbWU6IG1pbnRQYXJhbXMuZnVuY3Rpb25OYW1lLFxuICAgICAgICAgICAgICAgIGFyZ3M6IG1pbnRQYXJhbXMuYXJncyxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgdmFsdWU6IG1pbnRQYXJhbXMudmFsdWUgfHwgMG5cbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcnRuQ2FsbHMgPSBbe1xuICAgICAgICAgICAgICAgIHRvOiB0byxcbiAgICAgICAgICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgIH1dO1xuICAgICAgICAvLyBSZXR1cm4gdGhlIG1pbnQgdHJhbnNhY3Rpb24gcGFyYW1ldGVycyBhcyBjYWxsc1xuICAgICAgICByZXR1cm4geyBjYWxsczogcnRuQ2FsbHMgfTtcbiAgICB9XG4gICAgYXN5bmMgcHJlcGFyZVNldE5hbWVVcmlDYWxscyhuYW1lLCB1cmkpIHtcbiAgICAgICAgY29uc3QgY2FsbHMgPSBbXTtcbiAgICAgICAgcmV0dXJuIHsgY2FsbHMgfTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1BSUFnZW50TDJFTlNOYW1lc3BhY2VDbGllbnQuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@agentic-trust/8004-ext-sdk/dist/AIAgentL2ENSNamespaceClient.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@agentic-trust/8004-ext-sdk/dist/AIAgentReputationClient.js":
/*!**************************************************************************************!*\
  !*** ../../node_modules/@agentic-trust/8004-ext-sdk/dist/AIAgentReputationClient.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AIAgentReputationClient: () => (/* binding */ AIAgentReputationClient)\n/* harmony export */ });\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ethers */ \"(rsc)/../../node_modules/ethers/lib.esm/constants/hashes.js\");\n/* harmony import */ var viem_chains__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! viem/chains */ \"(rsc)/../../node_modules/viem/_esm/chains/definitions/sepolia.js\");\n/* harmony import */ var _agentic_trust_8004_sdk__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @agentic-trust/8004-sdk */ \"(rsc)/../../node_modules/@agentic-trust/8004-sdk/dist/index.js\");\n/* harmony import */ var _abis_ReputationRegistry_json__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./abis/ReputationRegistry.json */ \"(rsc)/../../node_modules/@agentic-trust/8004-ext-sdk/dist/abis/ReputationRegistry.json\");\n\n\n\n\nclass AIAgentReputationClient extends _agentic_trust_8004_sdk__WEBPACK_IMPORTED_MODULE_0__.ReputationClient {\n    chain;\n    accountProvider;\n    ensRegistryAddress;\n    reputationAddress;\n    publicClient = null;\n    constructor(accountProvider, registrationRegistryAddress, identityRegistryAddress, ensRegistryAddress) {\n        // For now, we still need to pass a BlockchainAdapter to BaseReputationClient\n        // TODO: Update BaseReputationClient to use AccountProvider\n        // We'll create a minimal adapter wrapper for compatibility\n        const minimalAdapter = {\n            call: async (to, abi, functionName, args) => {\n                return accountProvider?.call({ to: to, abi, functionName, args });\n            },\n            send: async (to, abi, functionName, args) => {\n                const data = await accountProvider?.encodeFunctionData({ abi, functionName, args: args || [] });\n                if (data) {\n                    const tx = { to: to, data };\n                    const result = await accountProvider?.send(tx);\n                    return { hash: result?.hash, txHash: result?.hash };\n                }\n                return { hash: undefined, txHash: undefined };\n            },\n            signMessage: async (message) => {\n                return accountProvider?.signMessage(message);\n            },\n        };\n        super(minimalAdapter, registrationRegistryAddress, identityRegistryAddress);\n        this.chain = viem_chains__WEBPACK_IMPORTED_MODULE_2__.sepolia;\n        this.accountProvider = accountProvider;\n        this.reputationAddress = registrationRegistryAddress;\n        this.ensRegistryAddress = ensRegistryAddress;\n        // Try to extract publicClient from AccountProvider if it's a ViemAccountProvider\n        const viemProvider = accountProvider;\n        if (viemProvider.publicClient) {\n            this.publicClient = viemProvider.publicClient;\n        }\n    }\n    // Expose base-class methods so TypeScript recognizes them on this subclass\n    getIdentityRegistry() {\n        return _agentic_trust_8004_sdk__WEBPACK_IMPORTED_MODULE_0__.ReputationClient.prototype.getIdentityRegistry.call(this);\n    }\n    getLastIndex(agentId, clientAddress) {\n        return _agentic_trust_8004_sdk__WEBPACK_IMPORTED_MODULE_0__.ReputationClient.prototype.getLastIndex.call(this, agentId, clientAddress);\n    }\n    createFeedbackAuth(agentId, clientAddress, indexLimit, expiry, chainId, signerAddress) {\n        console.info(\"----------> createFeedbackAuth\", agentId, clientAddress, indexLimit, expiry, chainId, signerAddress);\n        return _agentic_trust_8004_sdk__WEBPACK_IMPORTED_MODULE_0__.ReputationClient.prototype.createFeedbackAuth.call(this, agentId, clientAddress, indexLimit, expiry, chainId, signerAddress);\n    }\n    signFeedbackAuth(auth) {\n        return _agentic_trust_8004_sdk__WEBPACK_IMPORTED_MODULE_0__.ReputationClient.prototype.signFeedbackAuth.call(this, auth);\n    }\n    // Factory: resolve identityRegistry from reputation/registration registry before constructing\n    static async create(accountProvider, identityRegistryAddress, registrationRegistryAddress, ensRegistryAddress) {\n        return new AIAgentReputationClient(accountProvider, registrationRegistryAddress, identityRegistryAddress, ensRegistryAddress);\n    }\n    /**\n     * Submit feedback for an agent\n     * Updated ABI:\n     *   giveFeedback(uint256 agentId, uint8 score, string tag1, string tag2, string endpoint, string feedbackURI, bytes32 feedbackHash)\n     *\n     * @param params - Feedback parameters (score is MUST, others are OPTIONAL)\n     * @returns Transaction result\n     */\n    async giveClientFeedback(params) {\n        // Validate score is 0-100 (MUST per spec)\n        if (params.score < 0 || params.score > 100) {\n            throw new Error('Score MUST be between 0 and 100');\n        }\n        const tag1 = params.tag1 || '';\n        const tag2 = params.tag2 || '';\n        const endpoint = params.endpoint || '';\n        const feedbackHash = params.feedbackHash || ethers__WEBPACK_IMPORTED_MODULE_3__.ZeroHash;\n        const feedbackUri = params.feedbackUri || '';\n        // Convert agentId to bigint (contract expects uint256)\n        if (!params.agentId) {\n            throw new Error('agentId is required');\n        }\n        const agentId = BigInt(params.agentId);\n        console.info(\"params.feedbackAuth\", JSON.stringify(params.feedbackAuth, null, 2));\n        console.info(\"this.reputationAddress\", this.reputationAddress);\n        console.info(\"agentId\", agentId.toString());\n        console.info(\"score\", params.score);\n        console.info(\"tag1\", tag1);\n        console.info(\"tag2\", tag2);\n        console.info(\"feedbackUri\", feedbackUri);\n        console.info(\"feedbackHash\", feedbackHash);\n        // Encode function data using AccountProvider\n        const data = await this.accountProvider?.encodeFunctionData({\n            abi: _abis_ReputationRegistry_json__WEBPACK_IMPORTED_MODULE_1__,\n            functionName: 'giveFeedback',\n            args: [\n                agentId,\n                params.score,\n                tag1,\n                tag2,\n                endpoint,\n                feedbackUri,\n                feedbackHash,\n            ],\n        });\n        // Send transaction using AccountProvider\n        const tx = {\n            to: this.reputationAddress,\n            data: data || '0x',\n            value: 0n,\n        };\n        const result = await this.accountProvider?.send(tx, {\n            simulation: true,\n        });\n        return { txHash: result?.hash || '' };\n    }\n    /**\n     * Prepare the giveFeedback transaction data without sending it.\n     */\n    async prepareGiveFeedbackTx(params) {\n        if (params.score < 0 || params.score > 100) {\n            throw new Error('Score MUST be between 0 and 100');\n        }\n        if (!params.agentId) {\n            throw new Error('agentId is required');\n        }\n        const tag1 = params.tag1 || '';\n        const tag2 = params.tag2 || '';\n        const endpoint = params.endpoint || '';\n        const feedbackHash = params.feedbackHash || ethers__WEBPACK_IMPORTED_MODULE_3__.ZeroHash;\n        const feedbackUri = params.feedbackUri || '';\n        const agentId = BigInt(params.agentId);\n        const data = await this.accountProvider?.encodeFunctionData({\n            abi: _abis_ReputationRegistry_json__WEBPACK_IMPORTED_MODULE_1__,\n            functionName: 'giveFeedback',\n            args: [\n                agentId,\n                params.score,\n                tag1,\n                tag2,\n                endpoint,\n                feedbackUri,\n                feedbackHash,\n            ],\n        });\n        return {\n            to: this.reputationAddress,\n            data: data || '0x',\n            value: 0n,\n        };\n    }\n    /**\n     * Append a response to an existing feedback entry for an agent.\n     *\n     * Wraps the ReputationRegistry `appendResponse(agentId, clientAddress, feedbackIndex, responseUri, responseHash)`\n     * function using the same AccountProvider / ClientApp wiring as giveClientFeedback.\n     */\n    async appendToFeedback(params) {\n        const agentId = BigInt(params.agentId);\n        const feedbackIndex = BigInt(params.feedbackIndex);\n        const responseUri = params.responseUri || '';\n        const responseHash = params.responseHash && params.responseHash.length === 66\n            ? params.responseHash\n            : ethers__WEBPACK_IMPORTED_MODULE_3__.ZeroHash;\n        const data = await this.accountProvider?.encodeFunctionData({\n            abi: _abis_ReputationRegistry_json__WEBPACK_IMPORTED_MODULE_1__,\n            functionName: 'appendResponse',\n            args: [agentId, params.clientAddress, feedbackIndex, responseUri, responseHash],\n        });\n        const tx = {\n            to: this.reputationAddress,\n            data: data || '0x',\n            value: 0n,\n        };\n        const result = await this.accountProvider?.send(tx, {\n            simulation: true,\n        });\n        return { txHash: result?.hash || '' };\n    }\n    /**\n     * Revoke a previously submitted feedback entry for an agent.\n     *\n     * This wraps the ReputationRegistry `revokeFeedback(uint256 tokenId, uint256 feedbackIndex)`\n     * function using the same AccountProvider / ClientApp wiring as giveClientFeedback.\n     */\n    async revokeFeedback(agentId, feedbackIndex) {\n        const data = await this.accountProvider?.encodeFunctionData({\n            abi: _abis_ReputationRegistry_json__WEBPACK_IMPORTED_MODULE_1__,\n            functionName: 'revokeFeedback',\n            args: [agentId, feedbackIndex],\n        });\n        const tx = {\n            to: this.reputationAddress,\n            data: data || '0x',\n            value: 0n,\n        };\n        const result = await this.accountProvider?.send(tx, {\n            simulation: true,\n        });\n        return { txHash: result?.hash || '' };\n    }\n}\n//# sourceMappingURL=AIAgentReputationClient.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BhZ2VudGljLXRydXN0LzgwMDQtZXh0LXNkay9kaXN0L0FJQWdlbnRSZXB1dGF0aW9uQ2xpZW50LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQWdDO0FBQ007QUFDOEM7QUFDakI7QUFDNUQsc0NBQXNDLHFFQUFvQjtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLGlDQUFpQztBQUNoRixhQUFhO0FBQ2I7QUFDQSx5RUFBeUUscUNBQXFDO0FBQzlHO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0EseUJBQXlCO0FBQ3pCLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxxQkFBcUIsZ0RBQU87QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUscUVBQW9CO0FBQ25DO0FBQ0E7QUFDQSxlQUFlLHFFQUFvQjtBQUNuQztBQUNBO0FBQ0E7QUFDQSxlQUFlLHFFQUFvQjtBQUNuQztBQUNBO0FBQ0EsZUFBZSxxRUFBb0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELDRDQUFlO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDBEQUFxQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELDRDQUFlO0FBQ25FO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiwwREFBcUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyw0Q0FBZTtBQUM3QjtBQUNBLGlCQUFpQiwwREFBcUI7QUFDdEM7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDBEQUFxQjtBQUN0QztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL2JhcmIvYWEvQXNzb2NpYXRlZEFjY291bnRzL25vZGVfbW9kdWxlcy9AYWdlbnRpYy10cnVzdC84MDA0LWV4dC1zZGsvZGlzdC9BSUFnZW50UmVwdXRhdGlvbkNsaWVudC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBldGhlcnMgfSBmcm9tICdldGhlcnMnO1xuaW1wb3J0IHsgc2Vwb2xpYSB9IGZyb20gJ3ZpZW0vY2hhaW5zJztcbmltcG9ydCB7IFJlcHV0YXRpb25DbGllbnQgYXMgQmFzZVJlcHV0YXRpb25DbGllbnQsIH0gZnJvbSAnQGFnZW50aWMtdHJ1c3QvODAwNC1zZGsnO1xuaW1wb3J0IFJlcHV0YXRpb25SZWdpc3RyeUFCSSBmcm9tICcuL2FiaXMvUmVwdXRhdGlvblJlZ2lzdHJ5Lmpzb24nO1xuZXhwb3J0IGNsYXNzIEFJQWdlbnRSZXB1dGF0aW9uQ2xpZW50IGV4dGVuZHMgQmFzZVJlcHV0YXRpb25DbGllbnQge1xuICAgIGNoYWluO1xuICAgIGFjY291bnRQcm92aWRlcjtcbiAgICBlbnNSZWdpc3RyeUFkZHJlc3M7XG4gICAgcmVwdXRhdGlvbkFkZHJlc3M7XG4gICAgcHVibGljQ2xpZW50ID0gbnVsbDtcbiAgICBjb25zdHJ1Y3RvcihhY2NvdW50UHJvdmlkZXIsIHJlZ2lzdHJhdGlvblJlZ2lzdHJ5QWRkcmVzcywgaWRlbnRpdHlSZWdpc3RyeUFkZHJlc3MsIGVuc1JlZ2lzdHJ5QWRkcmVzcykge1xuICAgICAgICAvLyBGb3Igbm93LCB3ZSBzdGlsbCBuZWVkIHRvIHBhc3MgYSBCbG9ja2NoYWluQWRhcHRlciB0byBCYXNlUmVwdXRhdGlvbkNsaWVudFxuICAgICAgICAvLyBUT0RPOiBVcGRhdGUgQmFzZVJlcHV0YXRpb25DbGllbnQgdG8gdXNlIEFjY291bnRQcm92aWRlclxuICAgICAgICAvLyBXZSdsbCBjcmVhdGUgYSBtaW5pbWFsIGFkYXB0ZXIgd3JhcHBlciBmb3IgY29tcGF0aWJpbGl0eVxuICAgICAgICBjb25zdCBtaW5pbWFsQWRhcHRlciA9IHtcbiAgICAgICAgICAgIGNhbGw6IGFzeW5jICh0bywgYWJpLCBmdW5jdGlvbk5hbWUsIGFyZ3MpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjb3VudFByb3ZpZGVyPy5jYWxsKHsgdG86IHRvLCBhYmksIGZ1bmN0aW9uTmFtZSwgYXJncyB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZW5kOiBhc3luYyAodG8sIGFiaSwgZnVuY3Rpb25OYW1lLCBhcmdzKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IGFjY291bnRQcm92aWRlcj8uZW5jb2RlRnVuY3Rpb25EYXRhKHsgYWJpLCBmdW5jdGlvbk5hbWUsIGFyZ3M6IGFyZ3MgfHwgW10gfSk7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdHggPSB7IHRvOiB0bywgZGF0YSB9O1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBhY2NvdW50UHJvdmlkZXI/LnNlbmQodHgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBoYXNoOiByZXN1bHQ/Lmhhc2gsIHR4SGFzaDogcmVzdWx0Py5oYXNoIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7IGhhc2g6IHVuZGVmaW5lZCwgdHhIYXNoOiB1bmRlZmluZWQgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzaWduTWVzc2FnZTogYXN5bmMgKG1lc3NhZ2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjb3VudFByb3ZpZGVyPy5zaWduTWVzc2FnZShtZXNzYWdlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIHN1cGVyKG1pbmltYWxBZGFwdGVyLCByZWdpc3RyYXRpb25SZWdpc3RyeUFkZHJlc3MsIGlkZW50aXR5UmVnaXN0cnlBZGRyZXNzKTtcbiAgICAgICAgdGhpcy5jaGFpbiA9IHNlcG9saWE7XG4gICAgICAgIHRoaXMuYWNjb3VudFByb3ZpZGVyID0gYWNjb3VudFByb3ZpZGVyO1xuICAgICAgICB0aGlzLnJlcHV0YXRpb25BZGRyZXNzID0gcmVnaXN0cmF0aW9uUmVnaXN0cnlBZGRyZXNzO1xuICAgICAgICB0aGlzLmVuc1JlZ2lzdHJ5QWRkcmVzcyA9IGVuc1JlZ2lzdHJ5QWRkcmVzcztcbiAgICAgICAgLy8gVHJ5IHRvIGV4dHJhY3QgcHVibGljQ2xpZW50IGZyb20gQWNjb3VudFByb3ZpZGVyIGlmIGl0J3MgYSBWaWVtQWNjb3VudFByb3ZpZGVyXG4gICAgICAgIGNvbnN0IHZpZW1Qcm92aWRlciA9IGFjY291bnRQcm92aWRlcjtcbiAgICAgICAgaWYgKHZpZW1Qcm92aWRlci5wdWJsaWNDbGllbnQpIHtcbiAgICAgICAgICAgIHRoaXMucHVibGljQ2xpZW50ID0gdmllbVByb3ZpZGVyLnB1YmxpY0NsaWVudDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBFeHBvc2UgYmFzZS1jbGFzcyBtZXRob2RzIHNvIFR5cGVTY3JpcHQgcmVjb2duaXplcyB0aGVtIG9uIHRoaXMgc3ViY2xhc3NcbiAgICBnZXRJZGVudGl0eVJlZ2lzdHJ5KCkge1xuICAgICAgICByZXR1cm4gQmFzZVJlcHV0YXRpb25DbGllbnQucHJvdG90eXBlLmdldElkZW50aXR5UmVnaXN0cnkuY2FsbCh0aGlzKTtcbiAgICB9XG4gICAgZ2V0TGFzdEluZGV4KGFnZW50SWQsIGNsaWVudEFkZHJlc3MpIHtcbiAgICAgICAgcmV0dXJuIEJhc2VSZXB1dGF0aW9uQ2xpZW50LnByb3RvdHlwZS5nZXRMYXN0SW5kZXguY2FsbCh0aGlzLCBhZ2VudElkLCBjbGllbnRBZGRyZXNzKTtcbiAgICB9XG4gICAgY3JlYXRlRmVlZGJhY2tBdXRoKGFnZW50SWQsIGNsaWVudEFkZHJlc3MsIGluZGV4TGltaXQsIGV4cGlyeSwgY2hhaW5JZCwgc2lnbmVyQWRkcmVzcykge1xuICAgICAgICBjb25zb2xlLmluZm8oXCItLS0tLS0tLS0tPiBjcmVhdGVGZWVkYmFja0F1dGhcIiwgYWdlbnRJZCwgY2xpZW50QWRkcmVzcywgaW5kZXhMaW1pdCwgZXhwaXJ5LCBjaGFpbklkLCBzaWduZXJBZGRyZXNzKTtcbiAgICAgICAgcmV0dXJuIEJhc2VSZXB1dGF0aW9uQ2xpZW50LnByb3RvdHlwZS5jcmVhdGVGZWVkYmFja0F1dGguY2FsbCh0aGlzLCBhZ2VudElkLCBjbGllbnRBZGRyZXNzLCBpbmRleExpbWl0LCBleHBpcnksIGNoYWluSWQsIHNpZ25lckFkZHJlc3MpO1xuICAgIH1cbiAgICBzaWduRmVlZGJhY2tBdXRoKGF1dGgpIHtcbiAgICAgICAgcmV0dXJuIEJhc2VSZXB1dGF0aW9uQ2xpZW50LnByb3RvdHlwZS5zaWduRmVlZGJhY2tBdXRoLmNhbGwodGhpcywgYXV0aCk7XG4gICAgfVxuICAgIC8vIEZhY3Rvcnk6IHJlc29sdmUgaWRlbnRpdHlSZWdpc3RyeSBmcm9tIHJlcHV0YXRpb24vcmVnaXN0cmF0aW9uIHJlZ2lzdHJ5IGJlZm9yZSBjb25zdHJ1Y3RpbmdcbiAgICBzdGF0aWMgYXN5bmMgY3JlYXRlKGFjY291bnRQcm92aWRlciwgaWRlbnRpdHlSZWdpc3RyeUFkZHJlc3MsIHJlZ2lzdHJhdGlvblJlZ2lzdHJ5QWRkcmVzcywgZW5zUmVnaXN0cnlBZGRyZXNzKSB7XG4gICAgICAgIHJldHVybiBuZXcgQUlBZ2VudFJlcHV0YXRpb25DbGllbnQoYWNjb3VudFByb3ZpZGVyLCByZWdpc3RyYXRpb25SZWdpc3RyeUFkZHJlc3MsIGlkZW50aXR5UmVnaXN0cnlBZGRyZXNzLCBlbnNSZWdpc3RyeUFkZHJlc3MpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdWJtaXQgZmVlZGJhY2sgZm9yIGFuIGFnZW50XG4gICAgICogVXBkYXRlZCBBQkk6XG4gICAgICogICBnaXZlRmVlZGJhY2sodWludDI1NiBhZ2VudElkLCB1aW50OCBzY29yZSwgc3RyaW5nIHRhZzEsIHN0cmluZyB0YWcyLCBzdHJpbmcgZW5kcG9pbnQsIHN0cmluZyBmZWVkYmFja1VSSSwgYnl0ZXMzMiBmZWVkYmFja0hhc2gpXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyYW1zIC0gRmVlZGJhY2sgcGFyYW1ldGVycyAoc2NvcmUgaXMgTVVTVCwgb3RoZXJzIGFyZSBPUFRJT05BTClcbiAgICAgKiBAcmV0dXJucyBUcmFuc2FjdGlvbiByZXN1bHRcbiAgICAgKi9cbiAgICBhc3luYyBnaXZlQ2xpZW50RmVlZGJhY2socGFyYW1zKSB7XG4gICAgICAgIC8vIFZhbGlkYXRlIHNjb3JlIGlzIDAtMTAwIChNVVNUIHBlciBzcGVjKVxuICAgICAgICBpZiAocGFyYW1zLnNjb3JlIDwgMCB8fCBwYXJhbXMuc2NvcmUgPiAxMDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU2NvcmUgTVVTVCBiZSBiZXR3ZWVuIDAgYW5kIDEwMCcpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRhZzEgPSBwYXJhbXMudGFnMSB8fCAnJztcbiAgICAgICAgY29uc3QgdGFnMiA9IHBhcmFtcy50YWcyIHx8ICcnO1xuICAgICAgICBjb25zdCBlbmRwb2ludCA9IHBhcmFtcy5lbmRwb2ludCB8fCAnJztcbiAgICAgICAgY29uc3QgZmVlZGJhY2tIYXNoID0gcGFyYW1zLmZlZWRiYWNrSGFzaCB8fCBldGhlcnMuWmVyb0hhc2g7XG4gICAgICAgIGNvbnN0IGZlZWRiYWNrVXJpID0gcGFyYW1zLmZlZWRiYWNrVXJpIHx8ICcnO1xuICAgICAgICAvLyBDb252ZXJ0IGFnZW50SWQgdG8gYmlnaW50IChjb250cmFjdCBleHBlY3RzIHVpbnQyNTYpXG4gICAgICAgIGlmICghcGFyYW1zLmFnZW50SWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYWdlbnRJZCBpcyByZXF1aXJlZCcpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFnZW50SWQgPSBCaWdJbnQocGFyYW1zLmFnZW50SWQpO1xuICAgICAgICBjb25zb2xlLmluZm8oXCJwYXJhbXMuZmVlZGJhY2tBdXRoXCIsIEpTT04uc3RyaW5naWZ5KHBhcmFtcy5mZWVkYmFja0F1dGgsIG51bGwsIDIpKTtcbiAgICAgICAgY29uc29sZS5pbmZvKFwidGhpcy5yZXB1dGF0aW9uQWRkcmVzc1wiLCB0aGlzLnJlcHV0YXRpb25BZGRyZXNzKTtcbiAgICAgICAgY29uc29sZS5pbmZvKFwiYWdlbnRJZFwiLCBhZ2VudElkLnRvU3RyaW5nKCkpO1xuICAgICAgICBjb25zb2xlLmluZm8oXCJzY29yZVwiLCBwYXJhbXMuc2NvcmUpO1xuICAgICAgICBjb25zb2xlLmluZm8oXCJ0YWcxXCIsIHRhZzEpO1xuICAgICAgICBjb25zb2xlLmluZm8oXCJ0YWcyXCIsIHRhZzIpO1xuICAgICAgICBjb25zb2xlLmluZm8oXCJmZWVkYmFja1VyaVwiLCBmZWVkYmFja1VyaSk7XG4gICAgICAgIGNvbnNvbGUuaW5mbyhcImZlZWRiYWNrSGFzaFwiLCBmZWVkYmFja0hhc2gpO1xuICAgICAgICAvLyBFbmNvZGUgZnVuY3Rpb24gZGF0YSB1c2luZyBBY2NvdW50UHJvdmlkZXJcbiAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHRoaXMuYWNjb3VudFByb3ZpZGVyPy5lbmNvZGVGdW5jdGlvbkRhdGEoe1xuICAgICAgICAgICAgYWJpOiBSZXB1dGF0aW9uUmVnaXN0cnlBQkksXG4gICAgICAgICAgICBmdW5jdGlvbk5hbWU6ICdnaXZlRmVlZGJhY2snLFxuICAgICAgICAgICAgYXJnczogW1xuICAgICAgICAgICAgICAgIGFnZW50SWQsXG4gICAgICAgICAgICAgICAgcGFyYW1zLnNjb3JlLFxuICAgICAgICAgICAgICAgIHRhZzEsXG4gICAgICAgICAgICAgICAgdGFnMixcbiAgICAgICAgICAgICAgICBlbmRwb2ludCxcbiAgICAgICAgICAgICAgICBmZWVkYmFja1VyaSxcbiAgICAgICAgICAgICAgICBmZWVkYmFja0hhc2gsXG4gICAgICAgICAgICBdLFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gU2VuZCB0cmFuc2FjdGlvbiB1c2luZyBBY2NvdW50UHJvdmlkZXJcbiAgICAgICAgY29uc3QgdHggPSB7XG4gICAgICAgICAgICB0bzogdGhpcy5yZXB1dGF0aW9uQWRkcmVzcyxcbiAgICAgICAgICAgIGRhdGE6IGRhdGEgfHwgJzB4JyxcbiAgICAgICAgICAgIHZhbHVlOiAwbixcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5hY2NvdW50UHJvdmlkZXI/LnNlbmQodHgsIHtcbiAgICAgICAgICAgIHNpbXVsYXRpb246IHRydWUsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4geyB0eEhhc2g6IHJlc3VsdD8uaGFzaCB8fCAnJyB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcmVwYXJlIHRoZSBnaXZlRmVlZGJhY2sgdHJhbnNhY3Rpb24gZGF0YSB3aXRob3V0IHNlbmRpbmcgaXQuXG4gICAgICovXG4gICAgYXN5bmMgcHJlcGFyZUdpdmVGZWVkYmFja1R4KHBhcmFtcykge1xuICAgICAgICBpZiAocGFyYW1zLnNjb3JlIDwgMCB8fCBwYXJhbXMuc2NvcmUgPiAxMDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU2NvcmUgTVVTVCBiZSBiZXR3ZWVuIDAgYW5kIDEwMCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcGFyYW1zLmFnZW50SWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYWdlbnRJZCBpcyByZXF1aXJlZCcpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRhZzEgPSBwYXJhbXMudGFnMSB8fCAnJztcbiAgICAgICAgY29uc3QgdGFnMiA9IHBhcmFtcy50YWcyIHx8ICcnO1xuICAgICAgICBjb25zdCBlbmRwb2ludCA9IHBhcmFtcy5lbmRwb2ludCB8fCAnJztcbiAgICAgICAgY29uc3QgZmVlZGJhY2tIYXNoID0gcGFyYW1zLmZlZWRiYWNrSGFzaCB8fCBldGhlcnMuWmVyb0hhc2g7XG4gICAgICAgIGNvbnN0IGZlZWRiYWNrVXJpID0gcGFyYW1zLmZlZWRiYWNrVXJpIHx8ICcnO1xuICAgICAgICBjb25zdCBhZ2VudElkID0gQmlnSW50KHBhcmFtcy5hZ2VudElkKTtcbiAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHRoaXMuYWNjb3VudFByb3ZpZGVyPy5lbmNvZGVGdW5jdGlvbkRhdGEoe1xuICAgICAgICAgICAgYWJpOiBSZXB1dGF0aW9uUmVnaXN0cnlBQkksXG4gICAgICAgICAgICBmdW5jdGlvbk5hbWU6ICdnaXZlRmVlZGJhY2snLFxuICAgICAgICAgICAgYXJnczogW1xuICAgICAgICAgICAgICAgIGFnZW50SWQsXG4gICAgICAgICAgICAgICAgcGFyYW1zLnNjb3JlLFxuICAgICAgICAgICAgICAgIHRhZzEsXG4gICAgICAgICAgICAgICAgdGFnMixcbiAgICAgICAgICAgICAgICBlbmRwb2ludCxcbiAgICAgICAgICAgICAgICBmZWVkYmFja1VyaSxcbiAgICAgICAgICAgICAgICBmZWVkYmFja0hhc2gsXG4gICAgICAgICAgICBdLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRvOiB0aGlzLnJlcHV0YXRpb25BZGRyZXNzLFxuICAgICAgICAgICAgZGF0YTogZGF0YSB8fCAnMHgnLFxuICAgICAgICAgICAgdmFsdWU6IDBuLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBcHBlbmQgYSByZXNwb25zZSB0byBhbiBleGlzdGluZyBmZWVkYmFjayBlbnRyeSBmb3IgYW4gYWdlbnQuXG4gICAgICpcbiAgICAgKiBXcmFwcyB0aGUgUmVwdXRhdGlvblJlZ2lzdHJ5IGBhcHBlbmRSZXNwb25zZShhZ2VudElkLCBjbGllbnRBZGRyZXNzLCBmZWVkYmFja0luZGV4LCByZXNwb25zZVVyaSwgcmVzcG9uc2VIYXNoKWBcbiAgICAgKiBmdW5jdGlvbiB1c2luZyB0aGUgc2FtZSBBY2NvdW50UHJvdmlkZXIgLyBDbGllbnRBcHAgd2lyaW5nIGFzIGdpdmVDbGllbnRGZWVkYmFjay5cbiAgICAgKi9cbiAgICBhc3luYyBhcHBlbmRUb0ZlZWRiYWNrKHBhcmFtcykge1xuICAgICAgICBjb25zdCBhZ2VudElkID0gQmlnSW50KHBhcmFtcy5hZ2VudElkKTtcbiAgICAgICAgY29uc3QgZmVlZGJhY2tJbmRleCA9IEJpZ0ludChwYXJhbXMuZmVlZGJhY2tJbmRleCk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlVXJpID0gcGFyYW1zLnJlc3BvbnNlVXJpIHx8ICcnO1xuICAgICAgICBjb25zdCByZXNwb25zZUhhc2ggPSBwYXJhbXMucmVzcG9uc2VIYXNoICYmIHBhcmFtcy5yZXNwb25zZUhhc2gubGVuZ3RoID09PSA2NlxuICAgICAgICAgICAgPyBwYXJhbXMucmVzcG9uc2VIYXNoXG4gICAgICAgICAgICA6IGV0aGVycy5aZXJvSGFzaDtcbiAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHRoaXMuYWNjb3VudFByb3ZpZGVyPy5lbmNvZGVGdW5jdGlvbkRhdGEoe1xuICAgICAgICAgICAgYWJpOiBSZXB1dGF0aW9uUmVnaXN0cnlBQkksXG4gICAgICAgICAgICBmdW5jdGlvbk5hbWU6ICdhcHBlbmRSZXNwb25zZScsXG4gICAgICAgICAgICBhcmdzOiBbYWdlbnRJZCwgcGFyYW1zLmNsaWVudEFkZHJlc3MsIGZlZWRiYWNrSW5kZXgsIHJlc3BvbnNlVXJpLCByZXNwb25zZUhhc2hdLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgdHggPSB7XG4gICAgICAgICAgICB0bzogdGhpcy5yZXB1dGF0aW9uQWRkcmVzcyxcbiAgICAgICAgICAgIGRhdGE6IGRhdGEgfHwgJzB4JyxcbiAgICAgICAgICAgIHZhbHVlOiAwbixcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5hY2NvdW50UHJvdmlkZXI/LnNlbmQodHgsIHtcbiAgICAgICAgICAgIHNpbXVsYXRpb246IHRydWUsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4geyB0eEhhc2g6IHJlc3VsdD8uaGFzaCB8fCAnJyB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXZva2UgYSBwcmV2aW91c2x5IHN1Ym1pdHRlZCBmZWVkYmFjayBlbnRyeSBmb3IgYW4gYWdlbnQuXG4gICAgICpcbiAgICAgKiBUaGlzIHdyYXBzIHRoZSBSZXB1dGF0aW9uUmVnaXN0cnkgYHJldm9rZUZlZWRiYWNrKHVpbnQyNTYgdG9rZW5JZCwgdWludDI1NiBmZWVkYmFja0luZGV4KWBcbiAgICAgKiBmdW5jdGlvbiB1c2luZyB0aGUgc2FtZSBBY2NvdW50UHJvdmlkZXIgLyBDbGllbnRBcHAgd2lyaW5nIGFzIGdpdmVDbGllbnRGZWVkYmFjay5cbiAgICAgKi9cbiAgICBhc3luYyByZXZva2VGZWVkYmFjayhhZ2VudElkLCBmZWVkYmFja0luZGV4KSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLmFjY291bnRQcm92aWRlcj8uZW5jb2RlRnVuY3Rpb25EYXRhKHtcbiAgICAgICAgICAgIGFiaTogUmVwdXRhdGlvblJlZ2lzdHJ5QUJJLFxuICAgICAgICAgICAgZnVuY3Rpb25OYW1lOiAncmV2b2tlRmVlZGJhY2snLFxuICAgICAgICAgICAgYXJnczogW2FnZW50SWQsIGZlZWRiYWNrSW5kZXhdLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgdHggPSB7XG4gICAgICAgICAgICB0bzogdGhpcy5yZXB1dGF0aW9uQWRkcmVzcyxcbiAgICAgICAgICAgIGRhdGE6IGRhdGEgfHwgJzB4JyxcbiAgICAgICAgICAgIHZhbHVlOiAwbixcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5hY2NvdW50UHJvdmlkZXI/LnNlbmQodHgsIHtcbiAgICAgICAgICAgIHNpbXVsYXRpb246IHRydWUsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4geyB0eEhhc2g6IHJlc3VsdD8uaGFzaCB8fCAnJyB9O1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFJQWdlbnRSZXB1dGF0aW9uQ2xpZW50LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@agentic-trust/8004-ext-sdk/dist/AIAgentReputationClient.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@agentic-trust/8004-ext-sdk/dist/AIAgentValidationClient.js":
/*!**************************************************************************************!*\
  !*** ../../node_modules/@agentic-trust/8004-ext-sdk/dist/AIAgentValidationClient.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AIAgentValidationClient: () => (/* binding */ AIAgentValidationClient)\n/* harmony export */ });\n/* harmony import */ var viem_chains__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! viem/chains */ \"(rsc)/../../node_modules/viem/_esm/chains/definitions/sepolia.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! viem */ \"(rsc)/../../node_modules/viem/_esm/utils/hash/keccak256.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! viem */ \"(rsc)/../../node_modules/viem/_esm/utils/encoding/toHex.js\");\n/* harmony import */ var _agentic_trust_8004_sdk__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @agentic-trust/8004-sdk */ \"(rsc)/../../node_modules/@agentic-trust/8004-sdk/dist/index.js\");\n/* harmony import */ var _abis_ValidationRegistry_json__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./abis/ValidationRegistry.json */ \"(rsc)/../../node_modules/@agentic-trust/8004-ext-sdk/dist/abis/ValidationRegistry.json\");\n/**\n * Agentic Trust SDK - Validation Client\n * Extends the base ERC-8004 ValidationClient with AccountProvider support.\n * Uses AccountProvider (Ports & Adapters pattern) for chain I/O.\n */\n\n\n\n\nclass AIAgentValidationClient extends _agentic_trust_8004_sdk__WEBPACK_IMPORTED_MODULE_0__.ValidationClient {\n    chain;\n    accountProvider;\n    validationRegistryAddress;\n    constructor(accountProvider, validationRegistryAddress) {\n        // Minimal adapter wrapper using AccountProvider for BaseValidationClient compatibility\n        const minimalAdapter = {\n            call: async (to, abi, functionName, args) => {\n                return accountProvider?.call({ to: to, abi, functionName, args });\n            },\n            send: async (to, abi, functionName, args) => {\n                const data = await accountProvider?.encodeFunctionData({\n                    abi,\n                    functionName,\n                    args: args || [],\n                });\n                if (data) {\n                    const tx = { to: to, data };\n                    const result = await accountProvider?.send(tx);\n                    return { hash: result?.hash, txHash: result?.hash };\n                }\n                return { hash: undefined, txHash: undefined };\n            },\n        };\n        super(minimalAdapter, validationRegistryAddress);\n        this.chain = viem_chains__WEBPACK_IMPORTED_MODULE_2__.sepolia;\n        this.accountProvider = accountProvider;\n        this.validationRegistryAddress = validationRegistryAddress;\n    }\n    // Factory helper to mirror AIAgentReputationClient.create-style API\n    static async create(accountProvider, validationRegistryAddress) {\n        return new AIAgentValidationClient(accountProvider, validationRegistryAddress);\n    }\n    // Re-expose base-class methods for TypeScript consumers\n    getIdentityRegistry() {\n        return _agentic_trust_8004_sdk__WEBPACK_IMPORTED_MODULE_0__.ValidationClient.prototype.getIdentityRegistry.call(this);\n    }\n    getAgentValidations(agentId) {\n        return _agentic_trust_8004_sdk__WEBPACK_IMPORTED_MODULE_0__.ValidationClient.prototype.getAgentValidations.call(this, agentId);\n    }\n    getValidatorRequests(validatorAddress) {\n        return _agentic_trust_8004_sdk__WEBPACK_IMPORTED_MODULE_0__.ValidationClient.prototype.getValidatorRequests.call(this, validatorAddress);\n    }\n    getValidationStatus(requestHash) {\n        return _agentic_trust_8004_sdk__WEBPACK_IMPORTED_MODULE_0__.ValidationClient.prototype.getValidationStatus.call(this, requestHash);\n    }\n    getSummary(agentId, validatorAddresses, tag) {\n        return _agentic_trust_8004_sdk__WEBPACK_IMPORTED_MODULE_0__.ValidationClient.prototype.getSummary.call(this, agentId, validatorAddresses, tag);\n    }\n    validationRequest(params) {\n        return _agentic_trust_8004_sdk__WEBPACK_IMPORTED_MODULE_0__.ValidationClient.prototype.validationRequest.call(this, params);\n    }\n    validationResponse(params) {\n        return _agentic_trust_8004_sdk__WEBPACK_IMPORTED_MODULE_0__.ValidationClient.prototype.validationResponse.call(this, params);\n    }\n    /**\n     * Prepare the validationRequest transaction data without sending it.\n     * Requires the validator account address to be provided (computed server-side).\n     */\n    async prepareValidationRequestTx(params) {\n        if (!params.agentId) {\n            throw new Error('agentId requesting validation is required');\n        }\n        if (!params.validatorAddress) {\n            throw new Error('validatorAddress that performs the validation is required');\n        }\n        // Prepare validation request parameters\n        const agentIdBigInt = typeof params.agentId === 'bigint'\n            ? params.agentId\n            : BigInt(params.agentId.toString());\n        const finalRequestUri = params.requestUri || `https://agentic-trust.org/validation/${params.agentId}`;\n        const finalRequestHash = params.requestHash || (0,viem__WEBPACK_IMPORTED_MODULE_3__.keccak256)((0,viem__WEBPACK_IMPORTED_MODULE_4__.stringToHex)(finalRequestUri));\n        // Encode the validation request call\n        const data = await this.accountProvider?.encodeFunctionData({\n            abi: _abis_ValidationRegistry_json__WEBPACK_IMPORTED_MODULE_1__,\n            functionName: 'validationRequest',\n            args: [params.validatorAddress, agentIdBigInt, finalRequestUri, finalRequestHash],\n        });\n        return {\n            txRequest: {\n                to: this.validationRegistryAddress,\n                data: data || '0x',\n                value: 0n,\n            },\n            requestHash: finalRequestHash,\n        };\n    }\n    /**\n     * Prepare the validationResponse transaction data without sending it.\n     * This encodes the transaction that can be sent via a bundler using account abstraction.\n     */\n    async prepareValidationResponseTx(params) {\n        if (params.response < 0 || params.response > 100) {\n            throw new Error('Response MUST be between 0 and 100');\n        }\n        // Convert optional parameters to proper format (matching BaseValidationClient logic)\n        const { ethers } = await __webpack_require__.e(/*! import() */ \"vendor-chunks/ethers\").then(__webpack_require__.bind(__webpack_require__, /*! ethers */ \"(rsc)/../../node_modules/ethers/lib.esm/index.js\"));\n        const responseUri = params.responseUri || '';\n        const responseHash = params.responseHash || ethers.ZeroHash;\n        const tag = params.tag || '';\n        // Encode the validation response call\n        const data = await this.accountProvider?.encodeFunctionData({\n            abi: _abis_ValidationRegistry_json__WEBPACK_IMPORTED_MODULE_1__,\n            functionName: 'validationResponse',\n            args: [params.requestHash, params.response, responseUri, responseHash, tag],\n        });\n        return {\n            to: this.validationRegistryAddress,\n            data: data || '0x',\n            value: 0n,\n        };\n    }\n}\n//# sourceMappingURL=AIAgentValidationClient.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BhZ2VudGljLXRydXN0LzgwMDQtZXh0LXNkay9kaXN0L0FJQWdlbnRWYWxpZGF0aW9uQ2xpZW50LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDc0M7QUFDUTtBQUNzQztBQUNqQjtBQUM1RCxzQ0FBc0MscUVBQW9CO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLGlDQUFpQztBQUNoRixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGlDQUFpQztBQUNqQztBQUNBLDZCQUE2QjtBQUM3QjtBQUNBLHlCQUF5QjtBQUN6QixhQUFhO0FBQ2I7QUFDQTtBQUNBLHFCQUFxQixnREFBTztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHFFQUFvQjtBQUNuQztBQUNBO0FBQ0EsZUFBZSxxRUFBb0I7QUFDbkM7QUFDQTtBQUNBLGVBQWUscUVBQW9CO0FBQ25DO0FBQ0E7QUFDQSxlQUFlLHFFQUFvQjtBQUNuQztBQUNBO0FBQ0EsZUFBZSxxRUFBb0I7QUFDbkM7QUFDQTtBQUNBLGVBQWUscUVBQW9CO0FBQ25DO0FBQ0E7QUFDQSxlQUFlLHFFQUFvQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZGQUE2RixlQUFlO0FBQzVHLHVEQUF1RCwrQ0FBUyxDQUFDLGlEQUFXO0FBQzVFO0FBQ0E7QUFDQSxpQkFBaUIsMERBQXFCO0FBQ3RDO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUyxRQUFRLG1MQUFnQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDBEQUFxQjtBQUN0QztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL2JhcmIvYWEvQXNzb2NpYXRlZEFjY291bnRzL25vZGVfbW9kdWxlcy9AYWdlbnRpYy10cnVzdC84MDA0LWV4dC1zZGsvZGlzdC9BSUFnZW50VmFsaWRhdGlvbkNsaWVudC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEFnZW50aWMgVHJ1c3QgU0RLIC0gVmFsaWRhdGlvbiBDbGllbnRcbiAqIEV4dGVuZHMgdGhlIGJhc2UgRVJDLTgwMDQgVmFsaWRhdGlvbkNsaWVudCB3aXRoIEFjY291bnRQcm92aWRlciBzdXBwb3J0LlxuICogVXNlcyBBY2NvdW50UHJvdmlkZXIgKFBvcnRzICYgQWRhcHRlcnMgcGF0dGVybikgZm9yIGNoYWluIEkvTy5cbiAqL1xuaW1wb3J0IHsgc2Vwb2xpYSB9IGZyb20gJ3ZpZW0vY2hhaW5zJztcbmltcG9ydCB7IGtlY2NhazI1Niwgc3RyaW5nVG9IZXggfSBmcm9tICd2aWVtJztcbmltcG9ydCB7IFZhbGlkYXRpb25DbGllbnQgYXMgQmFzZVZhbGlkYXRpb25DbGllbnQsIH0gZnJvbSAnQGFnZW50aWMtdHJ1c3QvODAwNC1zZGsnO1xuaW1wb3J0IFZhbGlkYXRpb25SZWdpc3RyeUFCSSBmcm9tICcuL2FiaXMvVmFsaWRhdGlvblJlZ2lzdHJ5Lmpzb24nO1xuZXhwb3J0IGNsYXNzIEFJQWdlbnRWYWxpZGF0aW9uQ2xpZW50IGV4dGVuZHMgQmFzZVZhbGlkYXRpb25DbGllbnQge1xuICAgIGNoYWluO1xuICAgIGFjY291bnRQcm92aWRlcjtcbiAgICB2YWxpZGF0aW9uUmVnaXN0cnlBZGRyZXNzO1xuICAgIGNvbnN0cnVjdG9yKGFjY291bnRQcm92aWRlciwgdmFsaWRhdGlvblJlZ2lzdHJ5QWRkcmVzcykge1xuICAgICAgICAvLyBNaW5pbWFsIGFkYXB0ZXIgd3JhcHBlciB1c2luZyBBY2NvdW50UHJvdmlkZXIgZm9yIEJhc2VWYWxpZGF0aW9uQ2xpZW50IGNvbXBhdGliaWxpdHlcbiAgICAgICAgY29uc3QgbWluaW1hbEFkYXB0ZXIgPSB7XG4gICAgICAgICAgICBjYWxsOiBhc3luYyAodG8sIGFiaSwgZnVuY3Rpb25OYW1lLCBhcmdzKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjY291bnRQcm92aWRlcj8uY2FsbCh7IHRvOiB0bywgYWJpLCBmdW5jdGlvbk5hbWUsIGFyZ3MgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2VuZDogYXN5bmMgKHRvLCBhYmksIGZ1bmN0aW9uTmFtZSwgYXJncykgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBhY2NvdW50UHJvdmlkZXI/LmVuY29kZUZ1bmN0aW9uRGF0YSh7XG4gICAgICAgICAgICAgICAgICAgIGFiaSxcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25OYW1lLFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBhcmdzIHx8IFtdLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHR4ID0geyB0bzogdG8sIGRhdGEgfTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgYWNjb3VudFByb3ZpZGVyPy5zZW5kKHR4KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgaGFzaDogcmVzdWx0Py5oYXNoLCB0eEhhc2g6IHJlc3VsdD8uaGFzaCB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4geyBoYXNoOiB1bmRlZmluZWQsIHR4SGFzaDogdW5kZWZpbmVkIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICBzdXBlcihtaW5pbWFsQWRhcHRlciwgdmFsaWRhdGlvblJlZ2lzdHJ5QWRkcmVzcyk7XG4gICAgICAgIHRoaXMuY2hhaW4gPSBzZXBvbGlhO1xuICAgICAgICB0aGlzLmFjY291bnRQcm92aWRlciA9IGFjY291bnRQcm92aWRlcjtcbiAgICAgICAgdGhpcy52YWxpZGF0aW9uUmVnaXN0cnlBZGRyZXNzID0gdmFsaWRhdGlvblJlZ2lzdHJ5QWRkcmVzcztcbiAgICB9XG4gICAgLy8gRmFjdG9yeSBoZWxwZXIgdG8gbWlycm9yIEFJQWdlbnRSZXB1dGF0aW9uQ2xpZW50LmNyZWF0ZS1zdHlsZSBBUElcbiAgICBzdGF0aWMgYXN5bmMgY3JlYXRlKGFjY291bnRQcm92aWRlciwgdmFsaWRhdGlvblJlZ2lzdHJ5QWRkcmVzcykge1xuICAgICAgICByZXR1cm4gbmV3IEFJQWdlbnRWYWxpZGF0aW9uQ2xpZW50KGFjY291bnRQcm92aWRlciwgdmFsaWRhdGlvblJlZ2lzdHJ5QWRkcmVzcyk7XG4gICAgfVxuICAgIC8vIFJlLWV4cG9zZSBiYXNlLWNsYXNzIG1ldGhvZHMgZm9yIFR5cGVTY3JpcHQgY29uc3VtZXJzXG4gICAgZ2V0SWRlbnRpdHlSZWdpc3RyeSgpIHtcbiAgICAgICAgcmV0dXJuIEJhc2VWYWxpZGF0aW9uQ2xpZW50LnByb3RvdHlwZS5nZXRJZGVudGl0eVJlZ2lzdHJ5LmNhbGwodGhpcyk7XG4gICAgfVxuICAgIGdldEFnZW50VmFsaWRhdGlvbnMoYWdlbnRJZCkge1xuICAgICAgICByZXR1cm4gQmFzZVZhbGlkYXRpb25DbGllbnQucHJvdG90eXBlLmdldEFnZW50VmFsaWRhdGlvbnMuY2FsbCh0aGlzLCBhZ2VudElkKTtcbiAgICB9XG4gICAgZ2V0VmFsaWRhdG9yUmVxdWVzdHModmFsaWRhdG9yQWRkcmVzcykge1xuICAgICAgICByZXR1cm4gQmFzZVZhbGlkYXRpb25DbGllbnQucHJvdG90eXBlLmdldFZhbGlkYXRvclJlcXVlc3RzLmNhbGwodGhpcywgdmFsaWRhdG9yQWRkcmVzcyk7XG4gICAgfVxuICAgIGdldFZhbGlkYXRpb25TdGF0dXMocmVxdWVzdEhhc2gpIHtcbiAgICAgICAgcmV0dXJuIEJhc2VWYWxpZGF0aW9uQ2xpZW50LnByb3RvdHlwZS5nZXRWYWxpZGF0aW9uU3RhdHVzLmNhbGwodGhpcywgcmVxdWVzdEhhc2gpO1xuICAgIH1cbiAgICBnZXRTdW1tYXJ5KGFnZW50SWQsIHZhbGlkYXRvckFkZHJlc3NlcywgdGFnKSB7XG4gICAgICAgIHJldHVybiBCYXNlVmFsaWRhdGlvbkNsaWVudC5wcm90b3R5cGUuZ2V0U3VtbWFyeS5jYWxsKHRoaXMsIGFnZW50SWQsIHZhbGlkYXRvckFkZHJlc3NlcywgdGFnKTtcbiAgICB9XG4gICAgdmFsaWRhdGlvblJlcXVlc3QocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBCYXNlVmFsaWRhdGlvbkNsaWVudC5wcm90b3R5cGUudmFsaWRhdGlvblJlcXVlc3QuY2FsbCh0aGlzLCBwYXJhbXMpO1xuICAgIH1cbiAgICB2YWxpZGF0aW9uUmVzcG9uc2UocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBCYXNlVmFsaWRhdGlvbkNsaWVudC5wcm90b3R5cGUudmFsaWRhdGlvblJlc3BvbnNlLmNhbGwodGhpcywgcGFyYW1zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJlcGFyZSB0aGUgdmFsaWRhdGlvblJlcXVlc3QgdHJhbnNhY3Rpb24gZGF0YSB3aXRob3V0IHNlbmRpbmcgaXQuXG4gICAgICogUmVxdWlyZXMgdGhlIHZhbGlkYXRvciBhY2NvdW50IGFkZHJlc3MgdG8gYmUgcHJvdmlkZWQgKGNvbXB1dGVkIHNlcnZlci1zaWRlKS5cbiAgICAgKi9cbiAgICBhc3luYyBwcmVwYXJlVmFsaWRhdGlvblJlcXVlc3RUeChwYXJhbXMpIHtcbiAgICAgICAgaWYgKCFwYXJhbXMuYWdlbnRJZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhZ2VudElkIHJlcXVlc3RpbmcgdmFsaWRhdGlvbiBpcyByZXF1aXJlZCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcGFyYW1zLnZhbGlkYXRvckFkZHJlc3MpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndmFsaWRhdG9yQWRkcmVzcyB0aGF0IHBlcmZvcm1zIHRoZSB2YWxpZGF0aW9uIGlzIHJlcXVpcmVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUHJlcGFyZSB2YWxpZGF0aW9uIHJlcXVlc3QgcGFyYW1ldGVyc1xuICAgICAgICBjb25zdCBhZ2VudElkQmlnSW50ID0gdHlwZW9mIHBhcmFtcy5hZ2VudElkID09PSAnYmlnaW50J1xuICAgICAgICAgICAgPyBwYXJhbXMuYWdlbnRJZFxuICAgICAgICAgICAgOiBCaWdJbnQocGFyYW1zLmFnZW50SWQudG9TdHJpbmcoKSk7XG4gICAgICAgIGNvbnN0IGZpbmFsUmVxdWVzdFVyaSA9IHBhcmFtcy5yZXF1ZXN0VXJpIHx8IGBodHRwczovL2FnZW50aWMtdHJ1c3Qub3JnL3ZhbGlkYXRpb24vJHtwYXJhbXMuYWdlbnRJZH1gO1xuICAgICAgICBjb25zdCBmaW5hbFJlcXVlc3RIYXNoID0gcGFyYW1zLnJlcXVlc3RIYXNoIHx8IGtlY2NhazI1NihzdHJpbmdUb0hleChmaW5hbFJlcXVlc3RVcmkpKTtcbiAgICAgICAgLy8gRW5jb2RlIHRoZSB2YWxpZGF0aW9uIHJlcXVlc3QgY2FsbFxuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy5hY2NvdW50UHJvdmlkZXI/LmVuY29kZUZ1bmN0aW9uRGF0YSh7XG4gICAgICAgICAgICBhYmk6IFZhbGlkYXRpb25SZWdpc3RyeUFCSSxcbiAgICAgICAgICAgIGZ1bmN0aW9uTmFtZTogJ3ZhbGlkYXRpb25SZXF1ZXN0JyxcbiAgICAgICAgICAgIGFyZ3M6IFtwYXJhbXMudmFsaWRhdG9yQWRkcmVzcywgYWdlbnRJZEJpZ0ludCwgZmluYWxSZXF1ZXN0VXJpLCBmaW5hbFJlcXVlc3RIYXNoXSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eFJlcXVlc3Q6IHtcbiAgICAgICAgICAgICAgICB0bzogdGhpcy52YWxpZGF0aW9uUmVnaXN0cnlBZGRyZXNzLFxuICAgICAgICAgICAgICAgIGRhdGE6IGRhdGEgfHwgJzB4JyxcbiAgICAgICAgICAgICAgICB2YWx1ZTogMG4sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVxdWVzdEhhc2g6IGZpbmFsUmVxdWVzdEhhc2gsXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByZXBhcmUgdGhlIHZhbGlkYXRpb25SZXNwb25zZSB0cmFuc2FjdGlvbiBkYXRhIHdpdGhvdXQgc2VuZGluZyBpdC5cbiAgICAgKiBUaGlzIGVuY29kZXMgdGhlIHRyYW5zYWN0aW9uIHRoYXQgY2FuIGJlIHNlbnQgdmlhIGEgYnVuZGxlciB1c2luZyBhY2NvdW50IGFic3RyYWN0aW9uLlxuICAgICAqL1xuICAgIGFzeW5jIHByZXBhcmVWYWxpZGF0aW9uUmVzcG9uc2VUeChwYXJhbXMpIHtcbiAgICAgICAgaWYgKHBhcmFtcy5yZXNwb25zZSA8IDAgfHwgcGFyYW1zLnJlc3BvbnNlID4gMTAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Jlc3BvbnNlIE1VU1QgYmUgYmV0d2VlbiAwIGFuZCAxMDAnKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDb252ZXJ0IG9wdGlvbmFsIHBhcmFtZXRlcnMgdG8gcHJvcGVyIGZvcm1hdCAobWF0Y2hpbmcgQmFzZVZhbGlkYXRpb25DbGllbnQgbG9naWMpXG4gICAgICAgIGNvbnN0IHsgZXRoZXJzIH0gPSBhd2FpdCBpbXBvcnQoJ2V0aGVycycpO1xuICAgICAgICBjb25zdCByZXNwb25zZVVyaSA9IHBhcmFtcy5yZXNwb25zZVVyaSB8fCAnJztcbiAgICAgICAgY29uc3QgcmVzcG9uc2VIYXNoID0gcGFyYW1zLnJlc3BvbnNlSGFzaCB8fCBldGhlcnMuWmVyb0hhc2g7XG4gICAgICAgIGNvbnN0IHRhZyA9IHBhcmFtcy50YWcgfHwgJyc7XG4gICAgICAgIC8vIEVuY29kZSB0aGUgdmFsaWRhdGlvbiByZXNwb25zZSBjYWxsXG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLmFjY291bnRQcm92aWRlcj8uZW5jb2RlRnVuY3Rpb25EYXRhKHtcbiAgICAgICAgICAgIGFiaTogVmFsaWRhdGlvblJlZ2lzdHJ5QUJJLFxuICAgICAgICAgICAgZnVuY3Rpb25OYW1lOiAndmFsaWRhdGlvblJlc3BvbnNlJyxcbiAgICAgICAgICAgIGFyZ3M6IFtwYXJhbXMucmVxdWVzdEhhc2gsIHBhcmFtcy5yZXNwb25zZSwgcmVzcG9uc2VVcmksIHJlc3BvbnNlSGFzaCwgdGFnXSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0bzogdGhpcy52YWxpZGF0aW9uUmVnaXN0cnlBZGRyZXNzLFxuICAgICAgICAgICAgZGF0YTogZGF0YSB8fCAnMHgnLFxuICAgICAgICAgICAgdmFsdWU6IDBuLFxuICAgICAgICB9O1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFJQWdlbnRWYWxpZGF0aW9uQ2xpZW50LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@agentic-trust/8004-ext-sdk/dist/AIAgentValidationClient.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@agentic-trust/8004-ext-sdk/dist/OrgIdentityClient.js":
/*!********************************************************************************!*\
  !*** ../../node_modules/@agentic-trust/8004-ext-sdk/dist/OrgIdentityClient.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   OrgIdentityClient: () => (/* binding */ OrgIdentityClient)\n/* harmony export */ });\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! viem */ \"(rsc)/../../node_modules/viem/_esm/clients/createPublicClient.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! viem */ \"(rsc)/../../node_modules/viem/_esm/clients/transports/http.js\");\n/* harmony import */ var viem_chains__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! viem/chains */ \"(rsc)/../../node_modules/viem/_esm/chains/definitions/sepolia.js\");\n\n\n/**\n * Org Identity Client - ENS utilities for organizations\n * Uses AccountProvider (Ports & Adapters pattern) for chain I/O.\n * Provides helpers to resolve an org's ENS name to its account address and URL text record.\n */\nclass OrgIdentityClient {\n    accountProvider;\n    ensRegistryAddress;\n    publicClient = null;\n    constructor(accountProvider, options) {\n        this.accountProvider = accountProvider;\n        this.ensRegistryAddress = (options?.ensRegistry || '0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e');\n        if (options?.rpcUrl) {\n            // @ts-ignore - viem version compatibility issue\n            this.publicClient = (0,viem__WEBPACK_IMPORTED_MODULE_0__.createPublicClient)({ chain: viem_chains__WEBPACK_IMPORTED_MODULE_1__.sepolia, transport: (0,viem__WEBPACK_IMPORTED_MODULE_2__.http)(options.rpcUrl) });\n        }\n        // Try to extract publicClient from AccountProvider if it's a ViemAccountProvider\n        const viemProvider = accountProvider;\n        if (viemProvider.publicClient) {\n            this.publicClient = viemProvider.publicClient;\n        }\n    }\n    /** Resolve the account address for an org ENS name via resolver.addr(namehash(name)). */\n    async getOrgAccountByName(orgName) {\n        const ensName = this.normalizeEnsName(orgName);\n        if (!ensName)\n            return null;\n        const node = this.namehash(ensName);\n        const resolver = await this.getResolver(node);\n        if (!resolver)\n            return null;\n        const RESOLVER_ABI = [\n            { name: 'addr', type: 'function', stateMutability: 'view', inputs: [{ name: 'node', type: 'bytes32' }], outputs: [{ name: '', type: 'address' }] },\n        ];\n        try {\n            const addr = await this.accountProvider.call({\n                to: resolver,\n                abi: RESOLVER_ABI,\n                functionName: 'addr',\n                args: [node],\n            });\n            if (addr && /^0x[a-fA-F0-9]{40}$/.test(addr) && !this.isZeroAddress(addr)) {\n                return addr;\n            }\n        }\n        catch { }\n        return null;\n    }\n    async getOrgEoaByAccount(orgAccount) {\n        if (this.publicClient) {\n            // @ts-ignore - viem version compatibility issue\n            const eoa = await this.publicClient.readContract({\n                address: orgAccount,\n                abi: [{ name: 'owner', type: 'function', stateMutability: 'view', inputs: [], outputs: [{ type: 'address' }] }],\n                functionName: 'owner',\n            });\n            return eoa;\n        }\n        return null;\n    }\n    /** Resolve the URL text record for an org ENS name via resolver.text(namehash(name), 'url'). */\n    async getOrgUrlByName(orgName) {\n        const ensName = this.normalizeEnsName(orgName);\n        if (!ensName)\n            return null;\n        const node = this.namehash(ensName);\n        const resolver = await this.getResolver(node);\n        if (!resolver)\n            return null;\n        const RESOLVER_ABI = [\n            { name: 'text', type: 'function', stateMutability: 'view', inputs: [{ name: 'node', type: 'bytes32' }, { name: 'key', type: 'string' }], outputs: [{ name: '', type: 'string' }] },\n        ];\n        try {\n            const value = await this.accountProvider.call({\n                to: resolver,\n                abi: RESOLVER_ABI,\n                functionName: 'text',\n                args: [node, 'url'],\n            });\n            const trimmed = (value || '').trim();\n            return trimmed.length > 0 ? trimmed : null;\n        }\n        catch { }\n        return null;\n    }\n    /** Reverse lookup: account address -> ENS name via resolver.name(reverseNode) */\n    async getOrgNameByAccount(account) {\n        const ENS_REGISTRY_ABI = [\n            { name: 'resolver', type: 'function', stateMutability: 'view', inputs: [{ name: 'node', type: 'bytes32' }], outputs: [{ name: '', type: 'address' }] },\n        ];\n        const RESOLVER_ABI = [\n            { name: 'name', type: 'function', stateMutability: 'view', inputs: [{ name: 'node', type: 'bytes32' }], outputs: [{ name: '', type: 'string' }] },\n        ];\n        const lower = account.toLowerCase();\n        const reverseNode = this.namehash(`${lower.slice(2)}.addr.reverse`);\n        let resolver = null;\n        try {\n            resolver = await this.accountProvider.call({\n                to: this.ensRegistryAddress,\n                abi: ENS_REGISTRY_ABI,\n                functionName: 'resolver',\n                args: [reverseNode],\n            });\n        }\n        catch { }\n        if (!resolver || this.isZeroAddress(resolver))\n            return null;\n        try {\n            const name = await this.accountProvider.call({\n                to: resolver,\n                abi: RESOLVER_ABI,\n                functionName: 'name',\n                args: [reverseNode],\n            });\n            const normalized = (name || '').trim().toLowerCase();\n            return normalized.length > 0 ? normalized : null;\n        }\n        catch {\n            return null;\n        }\n    }\n    // --- internals ---\n    async getResolver(node) {\n        const ENS_REGISTRY_ABI = [\n            { name: 'resolver', type: 'function', stateMutability: 'view', inputs: [{ name: 'node', type: 'bytes32' }], outputs: [{ name: '', type: 'address' }] },\n        ];\n        try {\n            const resolver = await this.accountProvider.call({\n                to: this.ensRegistryAddress,\n                abi: ENS_REGISTRY_ABI,\n                functionName: 'resolver',\n                args: [node],\n            });\n            if (resolver && !this.isZeroAddress(resolver))\n                return resolver;\n        }\n        catch { }\n        return null;\n    }\n    normalizeEnsName(name) {\n        const cleaned = (name || '').trim().toLowerCase().replace(/^ens:\\s*/i, '');\n        if (!cleaned)\n            return '';\n        if (!/\\./.test(cleaned))\n            return `${cleaned}.eth`;\n        return cleaned;\n    }\n    namehash(name) {\n        const { keccak256, toUtf8Bytes } = require('ethers');\n        let node = '0x' + '00'.repeat(32);\n        if (!name)\n            return node;\n        const labels = name.split('.');\n        for (let i = labels.length - 1; i >= 0; i--) {\n            const label = labels[i];\n            if (!label)\n                continue;\n            const labelSha = keccak256(toUtf8Bytes(label));\n            node = keccak256(Buffer.concat([Buffer.from(node.slice(2), 'hex'), Buffer.from(labelSha.slice(2), 'hex')]));\n        }\n        return node;\n    }\n    isZeroAddress(addr) {\n        return /^0x0{40}$/i.test(addr);\n    }\n}\n//# sourceMappingURL=OrgIdentityClient.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BhZ2VudGljLXRydXN0LzgwMDQtZXh0LXNkay9kaXN0L09yZ0lkZW50aXR5Q2xpZW50LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBZ0Q7QUFDVjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHdEQUFrQixHQUFHLE9BQU8sZ0RBQU8sYUFBYSwwQ0FBSSxrQkFBa0I7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsb0VBQW9FLCtCQUErQixlQUFlLDJCQUEyQixHQUFHO0FBQzlKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLHdDQUF3QyxHQUFHO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0ZBQWtGLGlCQUFpQixHQUFHO0FBQzlIO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLG9FQUFvRSwrQkFBK0IsSUFBSSw2QkFBNkIsZUFBZSwwQkFBMEIsR0FBRztBQUM5TDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHdFQUF3RSwrQkFBK0IsZUFBZSwyQkFBMkIsR0FBRztBQUNsSztBQUNBO0FBQ0EsY0FBYyxvRUFBb0UsK0JBQStCLGVBQWUsMEJBQTBCLEdBQUc7QUFDN0o7QUFDQTtBQUNBLDZDQUE2QyxlQUFlO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyx3RUFBd0UsK0JBQStCLGVBQWUsMkJBQTJCLEdBQUc7QUFDbEs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixRQUFRO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix5QkFBeUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsUUFBUTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsR0FBRztBQUN4QjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL2JhcmIvYWEvQXNzb2NpYXRlZEFjY291bnRzL25vZGVfbW9kdWxlcy9AYWdlbnRpYy10cnVzdC84MDA0LWV4dC1zZGsvZGlzdC9PcmdJZGVudGl0eUNsaWVudC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjcmVhdGVQdWJsaWNDbGllbnQsIGh0dHAgfSBmcm9tICd2aWVtJztcbmltcG9ydCB7IHNlcG9saWEgfSBmcm9tICd2aWVtL2NoYWlucyc7XG4vKipcbiAqIE9yZyBJZGVudGl0eSBDbGllbnQgLSBFTlMgdXRpbGl0aWVzIGZvciBvcmdhbml6YXRpb25zXG4gKiBVc2VzIEFjY291bnRQcm92aWRlciAoUG9ydHMgJiBBZGFwdGVycyBwYXR0ZXJuKSBmb3IgY2hhaW4gSS9PLlxuICogUHJvdmlkZXMgaGVscGVycyB0byByZXNvbHZlIGFuIG9yZydzIEVOUyBuYW1lIHRvIGl0cyBhY2NvdW50IGFkZHJlc3MgYW5kIFVSTCB0ZXh0IHJlY29yZC5cbiAqL1xuZXhwb3J0IGNsYXNzIE9yZ0lkZW50aXR5Q2xpZW50IHtcbiAgICBhY2NvdW50UHJvdmlkZXI7XG4gICAgZW5zUmVnaXN0cnlBZGRyZXNzO1xuICAgIHB1YmxpY0NsaWVudCA9IG51bGw7XG4gICAgY29uc3RydWN0b3IoYWNjb3VudFByb3ZpZGVyLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuYWNjb3VudFByb3ZpZGVyID0gYWNjb3VudFByb3ZpZGVyO1xuICAgICAgICB0aGlzLmVuc1JlZ2lzdHJ5QWRkcmVzcyA9IChvcHRpb25zPy5lbnNSZWdpc3RyeSB8fCAnMHgwMDAwMDAwMDAwMEMyRTA3NGVDNjlBMGRGYjI5OTdCQTZDN2QyZTFlJyk7XG4gICAgICAgIGlmIChvcHRpb25zPy5ycGNVcmwpIHtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgLSB2aWVtIHZlcnNpb24gY29tcGF0aWJpbGl0eSBpc3N1ZVxuICAgICAgICAgICAgdGhpcy5wdWJsaWNDbGllbnQgPSBjcmVhdGVQdWJsaWNDbGllbnQoeyBjaGFpbjogc2Vwb2xpYSwgdHJhbnNwb3J0OiBodHRwKG9wdGlvbnMucnBjVXJsKSB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUcnkgdG8gZXh0cmFjdCBwdWJsaWNDbGllbnQgZnJvbSBBY2NvdW50UHJvdmlkZXIgaWYgaXQncyBhIFZpZW1BY2NvdW50UHJvdmlkZXJcbiAgICAgICAgY29uc3QgdmllbVByb3ZpZGVyID0gYWNjb3VudFByb3ZpZGVyO1xuICAgICAgICBpZiAodmllbVByb3ZpZGVyLnB1YmxpY0NsaWVudCkge1xuICAgICAgICAgICAgdGhpcy5wdWJsaWNDbGllbnQgPSB2aWVtUHJvdmlkZXIucHVibGljQ2xpZW50O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiBSZXNvbHZlIHRoZSBhY2NvdW50IGFkZHJlc3MgZm9yIGFuIG9yZyBFTlMgbmFtZSB2aWEgcmVzb2x2ZXIuYWRkcihuYW1laGFzaChuYW1lKSkuICovXG4gICAgYXN5bmMgZ2V0T3JnQWNjb3VudEJ5TmFtZShvcmdOYW1lKSB7XG4gICAgICAgIGNvbnN0IGVuc05hbWUgPSB0aGlzLm5vcm1hbGl6ZUVuc05hbWUob3JnTmFtZSk7XG4gICAgICAgIGlmICghZW5zTmFtZSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBjb25zdCBub2RlID0gdGhpcy5uYW1laGFzaChlbnNOYW1lKTtcbiAgICAgICAgY29uc3QgcmVzb2x2ZXIgPSBhd2FpdCB0aGlzLmdldFJlc29sdmVyKG5vZGUpO1xuICAgICAgICBpZiAoIXJlc29sdmVyKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGNvbnN0IFJFU09MVkVSX0FCSSA9IFtcbiAgICAgICAgICAgIHsgbmFtZTogJ2FkZHInLCB0eXBlOiAnZnVuY3Rpb24nLCBzdGF0ZU11dGFiaWxpdHk6ICd2aWV3JywgaW5wdXRzOiBbeyBuYW1lOiAnbm9kZScsIHR5cGU6ICdieXRlczMyJyB9XSwgb3V0cHV0czogW3sgbmFtZTogJycsIHR5cGU6ICdhZGRyZXNzJyB9XSB9LFxuICAgICAgICBdO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgYWRkciA9IGF3YWl0IHRoaXMuYWNjb3VudFByb3ZpZGVyLmNhbGwoe1xuICAgICAgICAgICAgICAgIHRvOiByZXNvbHZlcixcbiAgICAgICAgICAgICAgICBhYmk6IFJFU09MVkVSX0FCSSxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbk5hbWU6ICdhZGRyJyxcbiAgICAgICAgICAgICAgICBhcmdzOiBbbm9kZV0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChhZGRyICYmIC9eMHhbYS1mQS1GMC05XXs0MH0kLy50ZXN0KGFkZHIpICYmICF0aGlzLmlzWmVyb0FkZHJlc3MoYWRkcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWRkcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCB7IH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGFzeW5jIGdldE9yZ0VvYUJ5QWNjb3VudChvcmdBY2NvdW50KSB7XG4gICAgICAgIGlmICh0aGlzLnB1YmxpY0NsaWVudCkge1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSAtIHZpZW0gdmVyc2lvbiBjb21wYXRpYmlsaXR5IGlzc3VlXG4gICAgICAgICAgICBjb25zdCBlb2EgPSBhd2FpdCB0aGlzLnB1YmxpY0NsaWVudC5yZWFkQ29udHJhY3Qoe1xuICAgICAgICAgICAgICAgIGFkZHJlc3M6IG9yZ0FjY291bnQsXG4gICAgICAgICAgICAgICAgYWJpOiBbeyBuYW1lOiAnb3duZXInLCB0eXBlOiAnZnVuY3Rpb24nLCBzdGF0ZU11dGFiaWxpdHk6ICd2aWV3JywgaW5wdXRzOiBbXSwgb3V0cHV0czogW3sgdHlwZTogJ2FkZHJlc3MnIH1dIH1dLFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uTmFtZTogJ293bmVyJyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGVvYTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLyoqIFJlc29sdmUgdGhlIFVSTCB0ZXh0IHJlY29yZCBmb3IgYW4gb3JnIEVOUyBuYW1lIHZpYSByZXNvbHZlci50ZXh0KG5hbWVoYXNoKG5hbWUpLCAndXJsJykuICovXG4gICAgYXN5bmMgZ2V0T3JnVXJsQnlOYW1lKG9yZ05hbWUpIHtcbiAgICAgICAgY29uc3QgZW5zTmFtZSA9IHRoaXMubm9ybWFsaXplRW5zTmFtZShvcmdOYW1lKTtcbiAgICAgICAgaWYgKCFlbnNOYW1lKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLm5hbWVoYXNoKGVuc05hbWUpO1xuICAgICAgICBjb25zdCByZXNvbHZlciA9IGF3YWl0IHRoaXMuZ2V0UmVzb2x2ZXIobm9kZSk7XG4gICAgICAgIGlmICghcmVzb2x2ZXIpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgY29uc3QgUkVTT0xWRVJfQUJJID0gW1xuICAgICAgICAgICAgeyBuYW1lOiAndGV4dCcsIHR5cGU6ICdmdW5jdGlvbicsIHN0YXRlTXV0YWJpbGl0eTogJ3ZpZXcnLCBpbnB1dHM6IFt7IG5hbWU6ICdub2RlJywgdHlwZTogJ2J5dGVzMzInIH0sIHsgbmFtZTogJ2tleScsIHR5cGU6ICdzdHJpbmcnIH1dLCBvdXRwdXRzOiBbeyBuYW1lOiAnJywgdHlwZTogJ3N0cmluZycgfV0gfSxcbiAgICAgICAgXTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgdGhpcy5hY2NvdW50UHJvdmlkZXIuY2FsbCh7XG4gICAgICAgICAgICAgICAgdG86IHJlc29sdmVyLFxuICAgICAgICAgICAgICAgIGFiaTogUkVTT0xWRVJfQUJJLFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uTmFtZTogJ3RleHQnLFxuICAgICAgICAgICAgICAgIGFyZ3M6IFtub2RlLCAndXJsJ10sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHRyaW1tZWQgPSAodmFsdWUgfHwgJycpLnRyaW0oKTtcbiAgICAgICAgICAgIHJldHVybiB0cmltbWVkLmxlbmd0aCA+IDAgPyB0cmltbWVkIDogbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCB7IH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8qKiBSZXZlcnNlIGxvb2t1cDogYWNjb3VudCBhZGRyZXNzIC0+IEVOUyBuYW1lIHZpYSByZXNvbHZlci5uYW1lKHJldmVyc2VOb2RlKSAqL1xuICAgIGFzeW5jIGdldE9yZ05hbWVCeUFjY291bnQoYWNjb3VudCkge1xuICAgICAgICBjb25zdCBFTlNfUkVHSVNUUllfQUJJID0gW1xuICAgICAgICAgICAgeyBuYW1lOiAncmVzb2x2ZXInLCB0eXBlOiAnZnVuY3Rpb24nLCBzdGF0ZU11dGFiaWxpdHk6ICd2aWV3JywgaW5wdXRzOiBbeyBuYW1lOiAnbm9kZScsIHR5cGU6ICdieXRlczMyJyB9XSwgb3V0cHV0czogW3sgbmFtZTogJycsIHR5cGU6ICdhZGRyZXNzJyB9XSB9LFxuICAgICAgICBdO1xuICAgICAgICBjb25zdCBSRVNPTFZFUl9BQkkgPSBbXG4gICAgICAgICAgICB7IG5hbWU6ICduYW1lJywgdHlwZTogJ2Z1bmN0aW9uJywgc3RhdGVNdXRhYmlsaXR5OiAndmlldycsIGlucHV0czogW3sgbmFtZTogJ25vZGUnLCB0eXBlOiAnYnl0ZXMzMicgfV0sIG91dHB1dHM6IFt7IG5hbWU6ICcnLCB0eXBlOiAnc3RyaW5nJyB9XSB9LFxuICAgICAgICBdO1xuICAgICAgICBjb25zdCBsb3dlciA9IGFjY291bnQudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgY29uc3QgcmV2ZXJzZU5vZGUgPSB0aGlzLm5hbWVoYXNoKGAke2xvd2VyLnNsaWNlKDIpfS5hZGRyLnJldmVyc2VgKTtcbiAgICAgICAgbGV0IHJlc29sdmVyID0gbnVsbDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc29sdmVyID0gYXdhaXQgdGhpcy5hY2NvdW50UHJvdmlkZXIuY2FsbCh7XG4gICAgICAgICAgICAgICAgdG86IHRoaXMuZW5zUmVnaXN0cnlBZGRyZXNzLFxuICAgICAgICAgICAgICAgIGFiaTogRU5TX1JFR0lTVFJZX0FCSSxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbk5hbWU6ICdyZXNvbHZlcicsXG4gICAgICAgICAgICAgICAgYXJnczogW3JldmVyc2VOb2RlXSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIHsgfVxuICAgICAgICBpZiAoIXJlc29sdmVyIHx8IHRoaXMuaXNaZXJvQWRkcmVzcyhyZXNvbHZlcikpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBhd2FpdCB0aGlzLmFjY291bnRQcm92aWRlci5jYWxsKHtcbiAgICAgICAgICAgICAgICB0bzogcmVzb2x2ZXIsXG4gICAgICAgICAgICAgICAgYWJpOiBSRVNPTFZFUl9BQkksXG4gICAgICAgICAgICAgICAgZnVuY3Rpb25OYW1lOiAnbmFtZScsXG4gICAgICAgICAgICAgICAgYXJnczogW3JldmVyc2VOb2RlXSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3Qgbm9ybWFsaXplZCA9IChuYW1lIHx8ICcnKS50cmltKCkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIHJldHVybiBub3JtYWxpemVkLmxlbmd0aCA+IDAgPyBub3JtYWxpemVkIDogbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyAtLS0gaW50ZXJuYWxzIC0tLVxuICAgIGFzeW5jIGdldFJlc29sdmVyKG5vZGUpIHtcbiAgICAgICAgY29uc3QgRU5TX1JFR0lTVFJZX0FCSSA9IFtcbiAgICAgICAgICAgIHsgbmFtZTogJ3Jlc29sdmVyJywgdHlwZTogJ2Z1bmN0aW9uJywgc3RhdGVNdXRhYmlsaXR5OiAndmlldycsIGlucHV0czogW3sgbmFtZTogJ25vZGUnLCB0eXBlOiAnYnl0ZXMzMicgfV0sIG91dHB1dHM6IFt7IG5hbWU6ICcnLCB0eXBlOiAnYWRkcmVzcycgfV0gfSxcbiAgICAgICAgXTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc29sdmVyID0gYXdhaXQgdGhpcy5hY2NvdW50UHJvdmlkZXIuY2FsbCh7XG4gICAgICAgICAgICAgICAgdG86IHRoaXMuZW5zUmVnaXN0cnlBZGRyZXNzLFxuICAgICAgICAgICAgICAgIGFiaTogRU5TX1JFR0lTVFJZX0FCSSxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbk5hbWU6ICdyZXNvbHZlcicsXG4gICAgICAgICAgICAgICAgYXJnczogW25vZGVdLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAocmVzb2x2ZXIgJiYgIXRoaXMuaXNaZXJvQWRkcmVzcyhyZXNvbHZlcikpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmVyO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIHsgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgbm9ybWFsaXplRW5zTmFtZShuYW1lKSB7XG4gICAgICAgIGNvbnN0IGNsZWFuZWQgPSAobmFtZSB8fCAnJykudHJpbSgpLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvXmVuczpcXHMqL2ksICcnKTtcbiAgICAgICAgaWYgKCFjbGVhbmVkKVxuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICBpZiAoIS9cXC4vLnRlc3QoY2xlYW5lZCkpXG4gICAgICAgICAgICByZXR1cm4gYCR7Y2xlYW5lZH0uZXRoYDtcbiAgICAgICAgcmV0dXJuIGNsZWFuZWQ7XG4gICAgfVxuICAgIG5hbWVoYXNoKG5hbWUpIHtcbiAgICAgICAgY29uc3QgeyBrZWNjYWsyNTYsIHRvVXRmOEJ5dGVzIH0gPSByZXF1aXJlKCdldGhlcnMnKTtcbiAgICAgICAgbGV0IG5vZGUgPSAnMHgnICsgJzAwJy5yZXBlYXQoMzIpO1xuICAgICAgICBpZiAoIW5hbWUpXG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgY29uc3QgbGFiZWxzID0gbmFtZS5zcGxpdCgnLicpO1xuICAgICAgICBmb3IgKGxldCBpID0gbGFiZWxzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBjb25zdCBsYWJlbCA9IGxhYmVsc1tpXTtcbiAgICAgICAgICAgIGlmICghbGFiZWwpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBjb25zdCBsYWJlbFNoYSA9IGtlY2NhazI1Nih0b1V0ZjhCeXRlcyhsYWJlbCkpO1xuICAgICAgICAgICAgbm9kZSA9IGtlY2NhazI1NihCdWZmZXIuY29uY2F0KFtCdWZmZXIuZnJvbShub2RlLnNsaWNlKDIpLCAnaGV4JyksIEJ1ZmZlci5mcm9tKGxhYmVsU2hhLnNsaWNlKDIpLCAnaGV4JyldKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICAgIGlzWmVyb0FkZHJlc3MoYWRkcikge1xuICAgICAgICByZXR1cm4gL14weDB7NDB9JC9pLnRlc3QoYWRkcik7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9T3JnSWRlbnRpdHlDbGllbnQuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@agentic-trust/8004-ext-sdk/dist/OrgIdentityClient.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@agentic-trust/8004-ext-sdk/dist/abis/IdentityRegistry.json":
/*!**************************************************************************************!*\
  !*** ../../node_modules/@agentic-trust/8004-ext-sdk/dist/abis/IdentityRegistry.json ***!
  \**************************************************************************************/
/***/ ((module) => {

module.exports = /*#__PURE__*/JSON.parse('[{"inputs":[],"stateMutability":"nonpayable","type":"constructor"},{"inputs":[{"internalType":"address","name":"target","type":"address"}],"name":"AddressEmptyCode","type":"error"},{"inputs":[],"name":"ECDSAInvalidSignature","type":"error"},{"inputs":[{"internalType":"uint256","name":"length","type":"uint256"}],"name":"ECDSAInvalidSignatureLength","type":"error"},{"inputs":[{"internalType":"bytes32","name":"s","type":"bytes32"}],"name":"ECDSAInvalidSignatureS","type":"error"},{"inputs":[{"internalType":"address","name":"implementation","type":"address"}],"name":"ERC1967InvalidImplementation","type":"error"},{"inputs":[],"name":"ERC1967NonPayable","type":"error"},{"inputs":[{"internalType":"address","name":"sender","type":"address"},{"internalType":"uint256","name":"tokenId","type":"uint256"},{"internalType":"address","name":"owner","type":"address"}],"name":"ERC721IncorrectOwner","type":"error"},{"inputs":[{"internalType":"address","name":"operator","type":"address"},{"internalType":"uint256","name":"tokenId","type":"uint256"}],"name":"ERC721InsufficientApproval","type":"error"},{"inputs":[{"internalType":"address","name":"approver","type":"address"}],"name":"ERC721InvalidApprover","type":"error"},{"inputs":[{"internalType":"address","name":"operator","type":"address"}],"name":"ERC721InvalidOperator","type":"error"},{"inputs":[{"internalType":"address","name":"owner","type":"address"}],"name":"ERC721InvalidOwner","type":"error"},{"inputs":[{"internalType":"address","name":"receiver","type":"address"}],"name":"ERC721InvalidReceiver","type":"error"},{"inputs":[{"internalType":"address","name":"sender","type":"address"}],"name":"ERC721InvalidSender","type":"error"},{"inputs":[{"internalType":"uint256","name":"tokenId","type":"uint256"}],"name":"ERC721NonexistentToken","type":"error"},{"inputs":[],"name":"FailedCall","type":"error"},{"inputs":[],"name":"InvalidInitialization","type":"error"},{"inputs":[],"name":"NotInitializing","type":"error"},{"inputs":[{"internalType":"address","name":"owner","type":"address"}],"name":"OwnableInvalidOwner","type":"error"},{"inputs":[{"internalType":"address","name":"account","type":"address"}],"name":"OwnableUnauthorizedAccount","type":"error"},{"inputs":[],"name":"UUPSUnauthorizedCallContext","type":"error"},{"inputs":[{"internalType":"bytes32","name":"slot","type":"bytes32"}],"name":"UUPSUnsupportedProxiableUUID","type":"error"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"owner","type":"address"},{"indexed":true,"internalType":"address","name":"approved","type":"address"},{"indexed":true,"internalType":"uint256","name":"tokenId","type":"uint256"}],"name":"Approval","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"owner","type":"address"},{"indexed":true,"internalType":"address","name":"operator","type":"address"},{"indexed":false,"internalType":"bool","name":"approved","type":"bool"}],"name":"ApprovalForAll","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"_fromTokenId","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"_toTokenId","type":"uint256"}],"name":"BatchMetadataUpdate","type":"event"},{"anonymous":false,"inputs":[],"name":"EIP712DomainChanged","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint64","name":"version","type":"uint64"}],"name":"Initialized","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"uint256","name":"agentId","type":"uint256"},{"indexed":true,"internalType":"string","name":"indexedMetadataKey","type":"string"},{"indexed":false,"internalType":"string","name":"metadataKey","type":"string"},{"indexed":false,"internalType":"bytes","name":"metadataValue","type":"bytes"}],"name":"MetadataSet","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"_tokenId","type":"uint256"}],"name":"MetadataUpdate","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"previousOwner","type":"address"},{"indexed":true,"internalType":"address","name":"newOwner","type":"address"}],"name":"OwnershipTransferred","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"uint256","name":"agentId","type":"uint256"},{"indexed":false,"internalType":"string","name":"agentURI","type":"string"},{"indexed":true,"internalType":"address","name":"owner","type":"address"}],"name":"Registered","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"from","type":"address"},{"indexed":true,"internalType":"address","name":"to","type":"address"},{"indexed":true,"internalType":"uint256","name":"tokenId","type":"uint256"}],"name":"Transfer","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"uint256","name":"agentId","type":"uint256"},{"indexed":false,"internalType":"string","name":"newURI","type":"string"},{"indexed":true,"internalType":"address","name":"updatedBy","type":"address"}],"name":"URIUpdated","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"implementation","type":"address"}],"name":"Upgraded","type":"event"},{"inputs":[],"name":"UPGRADE_INTERFACE_VERSION","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"tokenId","type":"uint256"}],"name":"approve","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"owner","type":"address"}],"name":"balanceOf","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"eip712Domain","outputs":[{"internalType":"bytes1","name":"fields","type":"bytes1"},{"internalType":"string","name":"name","type":"string"},{"internalType":"string","name":"version","type":"string"},{"internalType":"uint256","name":"chainId","type":"uint256"},{"internalType":"address","name":"verifyingContract","type":"address"},{"internalType":"bytes32","name":"salt","type":"bytes32"},{"internalType":"uint256[]","name":"extensions","type":"uint256[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"agentId","type":"uint256"}],"name":"getAgentWallet","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"tokenId","type":"uint256"}],"name":"getApproved","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"agentId","type":"uint256"},{"internalType":"string","name":"metadataKey","type":"string"}],"name":"getMetadata","outputs":[{"internalType":"bytes","name":"","type":"bytes"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getVersion","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"pure","type":"function"},{"inputs":[],"name":"initialize","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"owner","type":"address"},{"internalType":"address","name":"operator","type":"address"}],"name":"isApprovedForAll","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"name","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"owner","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"tokenId","type":"uint256"}],"name":"ownerOf","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"proxiableUUID","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"register","outputs":[{"internalType":"uint256","name":"agentId","type":"uint256"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"string","name":"agentURI","type":"string"},{"components":[{"internalType":"string","name":"metadataKey","type":"string"},{"internalType":"bytes","name":"metadataValue","type":"bytes"}],"internalType":"struct IdentityRegistryUpgradeable.MetadataEntry[]","name":"metadata","type":"tuple[]"}],"name":"register","outputs":[{"internalType":"uint256","name":"agentId","type":"uint256"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"string","name":"agentURI","type":"string"}],"name":"register","outputs":[{"internalType":"uint256","name":"agentId","type":"uint256"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"renounceOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"from","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"tokenId","type":"uint256"}],"name":"safeTransferFrom","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"from","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"tokenId","type":"uint256"},{"internalType":"bytes","name":"data","type":"bytes"}],"name":"safeTransferFrom","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"agentId","type":"uint256"},{"internalType":"string","name":"newURI","type":"string"}],"name":"setAgentURI","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"agentId","type":"uint256"},{"internalType":"address","name":"newWallet","type":"address"},{"internalType":"uint256","name":"deadline","type":"uint256"},{"internalType":"bytes","name":"signature","type":"bytes"}],"name":"setAgentWallet","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"operator","type":"address"},{"internalType":"bool","name":"approved","type":"bool"}],"name":"setApprovalForAll","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"agentId","type":"uint256"},{"internalType":"string","name":"metadataKey","type":"string"},{"internalType":"bytes","name":"metadataValue","type":"bytes"}],"name":"setMetadata","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes4","name":"interfaceId","type":"bytes4"}],"name":"supportsInterface","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"symbol","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"tokenId","type":"uint256"}],"name":"tokenURI","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"from","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"tokenId","type":"uint256"}],"name":"transferFrom","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"newOwner","type":"address"}],"name":"transferOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"newImplementation","type":"address"},{"internalType":"bytes","name":"data","type":"bytes"}],"name":"upgradeToAndCall","outputs":[],"stateMutability":"payable","type":"function"}]');

/***/ }),

/***/ "(rsc)/../../node_modules/@agentic-trust/8004-ext-sdk/dist/abis/NameWrapper.json":
/*!*********************************************************************************!*\
  !*** ../../node_modules/@agentic-trust/8004-ext-sdk/dist/abis/NameWrapper.json ***!
  \*********************************************************************************/
/***/ ((module) => {

module.exports = /*#__PURE__*/JSON.parse('{"address":"0x0635513f179D50A207757E05759CbD106d7dFcE8","abi":[{"inputs":[{"internalType":"contract ENS","name":"_ens","type":"address"},{"internalType":"contract IBaseRegistrar","name":"_registrar","type":"address"},{"internalType":"contract IMetadataService","name":"_metadataService","type":"address"}],"stateMutability":"nonpayable","type":"constructor"},{"inputs":[],"name":"CannotUpgrade","type":"error"},{"inputs":[],"name":"IncompatibleParent","type":"error"},{"inputs":[{"internalType":"address","name":"owner","type":"address"}],"name":"IncorrectTargetOwner","type":"error"},{"inputs":[],"name":"IncorrectTokenType","type":"error"},{"inputs":[{"internalType":"bytes32","name":"labelHash","type":"bytes32"},{"internalType":"bytes32","name":"expectedLabelhash","type":"bytes32"}],"name":"LabelMismatch","type":"error"},{"inputs":[{"internalType":"string","name":"label","type":"string"}],"name":"LabelTooLong","type":"error"},{"inputs":[],"name":"LabelTooShort","type":"error"},{"inputs":[],"name":"NameIsNotWrapped","type":"error"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"OperationProhibited","type":"error"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"},{"internalType":"address","name":"addr","type":"address"}],"name":"Unauthorised","type":"error"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"owner","type":"address"},{"indexed":true,"internalType":"address","name":"approved","type":"address"},{"indexed":true,"internalType":"uint256","name":"tokenId","type":"uint256"}],"name":"Approval","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"account","type":"address"},{"indexed":true,"internalType":"address","name":"operator","type":"address"},{"indexed":false,"internalType":"bool","name":"approved","type":"bool"}],"name":"ApprovalForAll","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"controller","type":"address"},{"indexed":false,"internalType":"bool","name":"active","type":"bool"}],"name":"ControllerChanged","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"node","type":"bytes32"},{"indexed":false,"internalType":"uint64","name":"expiry","type":"uint64"}],"name":"ExpiryExtended","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"node","type":"bytes32"},{"indexed":false,"internalType":"uint32","name":"fuses","type":"uint32"}],"name":"FusesSet","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"node","type":"bytes32"},{"indexed":false,"internalType":"address","name":"owner","type":"address"}],"name":"NameUnwrapped","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"node","type":"bytes32"},{"indexed":false,"internalType":"bytes","name":"name","type":"bytes"},{"indexed":false,"internalType":"address","name":"owner","type":"address"},{"indexed":false,"internalType":"uint32","name":"fuses","type":"uint32"},{"indexed":false,"internalType":"uint64","name":"expiry","type":"uint64"}],"name":"NameWrapped","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"previousOwner","type":"address"},{"indexed":true,"internalType":"address","name":"newOwner","type":"address"}],"name":"OwnershipTransferred","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"operator","type":"address"},{"indexed":true,"internalType":"address","name":"from","type":"address"},{"indexed":true,"internalType":"address","name":"to","type":"address"},{"indexed":false,"internalType":"uint256[]","name":"ids","type":"uint256[]"},{"indexed":false,"internalType":"uint256[]","name":"values","type":"uint256[]"}],"name":"TransferBatch","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"operator","type":"address"},{"indexed":true,"internalType":"address","name":"from","type":"address"},{"indexed":true,"internalType":"address","name":"to","type":"address"},{"indexed":false,"internalType":"uint256","name":"id","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"value","type":"uint256"}],"name":"TransferSingle","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"string","name":"value","type":"string"},{"indexed":true,"internalType":"uint256","name":"id","type":"uint256"}],"name":"URI","type":"event"},{"inputs":[{"internalType":"uint256","name":"","type":"uint256"}],"name":"_tokens","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"},{"internalType":"uint32","name":"fuseMask","type":"uint32"}],"name":"allFusesBurned","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"tokenId","type":"uint256"}],"name":"approve","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"account","type":"address"},{"internalType":"uint256","name":"id","type":"uint256"}],"name":"balanceOf","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address[]","name":"accounts","type":"address[]"},{"internalType":"uint256[]","name":"ids","type":"uint256[]"}],"name":"balanceOfBatch","outputs":[{"internalType":"uint256[]","name":"","type":"uint256[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"},{"internalType":"address","name":"addr","type":"address"}],"name":"canExtendSubnames","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"},{"internalType":"address","name":"addr","type":"address"}],"name":"canModifyName","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"","type":"address"}],"name":"controllers","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"ens","outputs":[{"internalType":"contract ENS","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"parentNode","type":"bytes32"},{"internalType":"bytes32","name":"labelhash","type":"bytes32"},{"internalType":"uint64","name":"expiry","type":"uint64"}],"name":"extendExpiry","outputs":[{"internalType":"uint64","name":"","type":"uint64"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"id","type":"uint256"}],"name":"getApproved","outputs":[{"internalType":"address","name":"operator","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"id","type":"uint256"}],"name":"getData","outputs":[{"internalType":"address","name":"owner","type":"address"},{"internalType":"uint32","name":"fuses","type":"uint32"},{"internalType":"uint64","name":"expiry","type":"uint64"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"account","type":"address"},{"internalType":"address","name":"operator","type":"address"}],"name":"isApprovedForAll","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"parentNode","type":"bytes32"},{"internalType":"bytes32","name":"labelhash","type":"bytes32"}],"name":"isWrapped","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"isWrapped","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"metadataService","outputs":[{"internalType":"contract IMetadataService","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"name","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"name":"names","outputs":[{"internalType":"bytes","name":"","type":"bytes"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"to","type":"address"},{"internalType":"address","name":"","type":"address"},{"internalType":"uint256","name":"tokenId","type":"uint256"},{"internalType":"bytes","name":"data","type":"bytes"}],"name":"onERC721Received","outputs":[{"internalType":"bytes4","name":"","type":"bytes4"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"owner","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"id","type":"uint256"}],"name":"ownerOf","outputs":[{"internalType":"address","name":"owner","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"_token","type":"address"},{"internalType":"address","name":"_to","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"recoverFunds","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"string","name":"label","type":"string"},{"internalType":"address","name":"wrappedOwner","type":"address"},{"internalType":"uint256","name":"duration","type":"uint256"},{"internalType":"address","name":"resolver","type":"address"},{"internalType":"uint16","name":"ownerControlledFuses","type":"uint16"}],"name":"registerAndWrapETH2LD","outputs":[{"internalType":"uint256","name":"registrarExpiry","type":"uint256"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"registrar","outputs":[{"internalType":"contract IBaseRegistrar","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"tokenId","type":"uint256"},{"internalType":"uint256","name":"duration","type":"uint256"}],"name":"renew","outputs":[{"internalType":"uint256","name":"expires","type":"uint256"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"renounceOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"from","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256[]","name":"ids","type":"uint256[]"},{"internalType":"uint256[]","name":"amounts","type":"uint256[]"},{"internalType":"bytes","name":"data","type":"bytes"}],"name":"safeBatchTransferFrom","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"from","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"id","type":"uint256"},{"internalType":"uint256","name":"amount","type":"uint256"},{"internalType":"bytes","name":"data","type":"bytes"}],"name":"safeTransferFrom","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"operator","type":"address"},{"internalType":"bool","name":"approved","type":"bool"}],"name":"setApprovalForAll","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"parentNode","type":"bytes32"},{"internalType":"bytes32","name":"labelhash","type":"bytes32"},{"internalType":"uint32","name":"fuses","type":"uint32"},{"internalType":"uint64","name":"expiry","type":"uint64"}],"name":"setChildFuses","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"controller","type":"address"},{"internalType":"bool","name":"active","type":"bool"}],"name":"setController","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"},{"internalType":"uint16","name":"ownerControlledFuses","type":"uint16"}],"name":"setFuses","outputs":[{"internalType":"uint32","name":"","type":"uint32"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"contract IMetadataService","name":"_metadataService","type":"address"}],"name":"setMetadataService","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"},{"internalType":"address","name":"owner","type":"address"},{"internalType":"address","name":"resolver","type":"address"},{"internalType":"uint64","name":"ttl","type":"uint64"}],"name":"setRecord","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"},{"internalType":"address","name":"resolver","type":"address"}],"name":"setResolver","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"parentNode","type":"bytes32"},{"internalType":"string","name":"label","type":"string"},{"internalType":"address","name":"owner","type":"address"},{"internalType":"uint32","name":"fuses","type":"uint32"},{"internalType":"uint64","name":"expiry","type":"uint64"}],"name":"setSubnodeOwner","outputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"parentNode","type":"bytes32"},{"internalType":"string","name":"label","type":"string"},{"internalType":"address","name":"owner","type":"address"},{"internalType":"address","name":"resolver","type":"address"},{"internalType":"uint64","name":"ttl","type":"uint64"},{"internalType":"uint32","name":"fuses","type":"uint32"},{"internalType":"uint64","name":"expiry","type":"uint64"}],"name":"setSubnodeRecord","outputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"},{"internalType":"uint64","name":"ttl","type":"uint64"}],"name":"setTTL","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"contract INameWrapperUpgrade","name":"_upgradeAddress","type":"address"}],"name":"setUpgradeContract","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes4","name":"interfaceId","type":"bytes4"}],"name":"supportsInterface","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"newOwner","type":"address"}],"name":"transferOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"parentNode","type":"bytes32"},{"internalType":"bytes32","name":"labelhash","type":"bytes32"},{"internalType":"address","name":"controller","type":"address"}],"name":"unwrap","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"labelhash","type":"bytes32"},{"internalType":"address","name":"registrant","type":"address"},{"internalType":"address","name":"controller","type":"address"}],"name":"unwrapETH2LD","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes","name":"name","type":"bytes"},{"internalType":"bytes","name":"extraData","type":"bytes"}],"name":"upgrade","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"upgradeContract","outputs":[{"internalType":"contract INameWrapperUpgrade","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"tokenId","type":"uint256"}],"name":"uri","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes","name":"name","type":"bytes"},{"internalType":"address","name":"wrappedOwner","type":"address"},{"internalType":"address","name":"resolver","type":"address"}],"name":"wrap","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"string","name":"label","type":"string"},{"internalType":"address","name":"wrappedOwner","type":"address"},{"internalType":"uint16","name":"ownerControlledFuses","type":"uint16"},{"internalType":"address","name":"resolver","type":"address"}],"name":"wrapETH2LD","outputs":[{"internalType":"uint64","name":"expiry","type":"uint64"}],"stateMutability":"nonpayable","type":"function"}],"transactionHash":"0x60f94207da794ed2a42bef84ad3ffbe39aab7a08501fc6cc35b9bddacb182144","receipt":{"to":null,"from":"0x4Fe4e666Be5752f1FdD210F4Ab5DE2Cc26e3E0e8","contractAddress":"0x0635513f179D50A207757E05759CbD106d7dFcE8","transactionIndex":62,"gasUsed":"5487360","logsBloom":"0x00001000000000400000000000000000000000000000200000800000000004000000000000000000100000000000000000000000000010000000000000000000000000000000000000000000008000000001000000000000100000000000000000000000020000000000000004000800000000000000000000001000000000400000010000000000000000000000000000000000000010200000000000000000000000000000040000000019000000000000000000000000008000240000000080000000000000000002000000005040000000000000000020000000000020000000000000000000000020000100000000000000001000000000000008000000","blockHash":"0xa14ab7b389c1fa6e5c0635638d9aed3123472664c873a1296a4c3ce8cc5c6839","transactionHash":"0x60f94207da794ed2a42bef84ad3ffbe39aab7a08501fc6cc35b9bddacb182144","logs":[{"transactionIndex":62,"blockNumber":3790153,"transactionHash":"0x60f94207da794ed2a42bef84ad3ffbe39aab7a08501fc6cc35b9bddacb182144","address":"0x0635513f179D50A207757E05759CbD106d7dFcE8","topics":["0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0","0x0000000000000000000000000000000000000000000000000000000000000000","0x0000000000000000000000004fe4e666be5752f1fdd210f4ab5de2cc26e3e0e8"],"data":"0x","logIndex":94,"blockHash":"0xa14ab7b389c1fa6e5c0635638d9aed3123472664c873a1296a4c3ce8cc5c6839"},{"transactionIndex":62,"blockNumber":3790153,"transactionHash":"0x60f94207da794ed2a42bef84ad3ffbe39aab7a08501fc6cc35b9bddacb182144","address":"0xA0a1AbcDAe1a2a4A2EF8e9113Ff0e02DD81DC0C6","topics":["0x6ada868dd3058cf77a48a74489fd7963688e5464b2b0fa957ace976243270e92","0x0000000000000000000000000635513f179d50a207757e05759cbd106d7dfce8","0x4ef5377426f026cf8bf8e26532753941a1216caa1729302267b8c57117310271"],"data":"0x","logIndex":95,"blockHash":"0xa14ab7b389c1fa6e5c0635638d9aed3123472664c873a1296a4c3ce8cc5c6839"},{"transactionIndex":62,"blockNumber":3790153,"transactionHash":"0x60f94207da794ed2a42bef84ad3ffbe39aab7a08501fc6cc35b9bddacb182144","address":"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e","topics":["0xce0457fe73731f824cc272376169235128c118b49d344817417c6d108d155e82","0x91d1777781884d03a6757a803996e38de2a42967fb37eeaca72729271025a9e2","0x3b2f093329dda9e8020bdae7615b2d0825e7b39a6b72263a3119df90765c2f95"],"data":"0x0000000000000000000000004fe4e666be5752f1fdd210f4ab5de2cc26e3e0e8","logIndex":96,"blockHash":"0xa14ab7b389c1fa6e5c0635638d9aed3123472664c873a1296a4c3ce8cc5c6839"}],"blockNumber":3790153,"cumulativeGasUsed":"20337800","status":1,"byzantium":true},"args":["0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e","0x57f1887a8bf19b14fc0df6fd9b2acc9af147ea85","0x2e9736e109a2745628a5915983f8d9172414f1ac"],"numDeployments":1,"solcInputHash":"e04502f562d98d0455f6c1c453418cdd","metadata":"{\\"compiler\\":{\\"version\\":\\"0.8.17+commit.8df45f5f\\"},\\"language\\":\\"Solidity\\",\\"output\\":{\\"abi\\":[{\\"inputs\\":[{\\"internalType\\":\\"contract ENS\\",\\"name\\":\\"_ens\\",\\"type\\":\\"address\\"},{\\"internalType\\":\\"contract IBaseRegistrar\\",\\"name\\":\\"_registrar\\",\\"type\\":\\"address\\"},{\\"internalType\\":\\"contract IMetadataService\\",\\"name\\":\\"_metadataService\\",\\"type\\":\\"address\\"}],\\"stateMutability\\":\\"nonpayable\\",\\"type\\":\\"constructor\\"},{\\"inputs\\":[],\\"name\\":\\"CannotUpgrade\\",\\"type\\":\\"error\\"},{\\"inputs\\":[],\\"name\\":\\"IncompatibleParent\\",\\"type\\":\\"error\\"},{\\"inputs\\":[{\\"internalType\\":\\"address\\",\\"name\\":\\"owner\\",\\"type\\":\\"address\\"}],\\"name\\":\\"IncorrectTargetOwner\\",\\"type\\":\\"error\\"},{\\"inputs\\":[],\\"name\\":\\"IncorrectTokenType\\",\\"type\\":\\"error\\"},{\\"inputs\\":[{\\"internalType\\":\\"bytes32\\",\\"name\\":\\"labelHash\\",\\"type\\":\\"bytes32\\"},{\\"internalType\\":\\"bytes32\\",\\"name\\":\\"expectedLabelhash\\",\\"type\\":\\"bytes32\\"}],\\"name\\":\\"LabelMismatch\\",\\"type\\":\\"error\\"},{\\"inputs\\":[{\\"internalType\\":\\"string\\",\\"name\\":\\"label\\",\\"type\\":\\"string\\"}],\\"name\\":\\"LabelTooLong\\",\\"type\\":\\"error\\"},{\\"inputs\\":[],\\"name\\":\\"LabelTooShort\\",\\"type\\":\\"error\\"},{\\"inputs\\":[],\\"name\\":\\"NameIsNotWrapped\\",\\"type\\":\\"error\\"},{\\"inputs\\":[{\\"internalType\\":\\"bytes32\\",\\"name\\":\\"node\\",\\"type\\":\\"bytes32\\"}],\\"name\\":\\"OperationProhibited\\",\\"type\\":\\"error\\"},{\\"inputs\\":[{\\"internalType\\":\\"bytes32\\",\\"name\\":\\"node\\",\\"type\\":\\"bytes32\\"},{\\"internalType\\":\\"address\\",\\"name\\":\\"addr\\",\\"type\\":\\"address\\"}],\\"name\\":\\"Unauthorised\\",\\"type\\":\\"error\\"},{\\"anonymous\\":false,\\"inputs\\":[{\\"indexed\\":true,\\"internalType\\":\\"address\\",\\"name\\":\\"owner\\",\\"type\\":\\"address\\"},{\\"indexed\\":true,\\"internalType\\":\\"address\\",\\"name\\":\\"approved\\",\\"type\\":\\"address\\"},{\\"indexed\\":true,\\"internalType\\":\\"uint256\\",\\"name\\":\\"tokenId\\",\\"type\\":\\"uint256\\"}],\\"name\\":\\"Approval\\",\\"type\\":\\"event\\"},{\\"anonymous\\":false,\\"inputs\\":[{\\"indexed\\":true,\\"internalType\\":\\"address\\",\\"name\\":\\"account\\",\\"type\\":\\"address\\"},{\\"indexed\\":true,\\"internalType\\":\\"address\\",\\"name\\":\\"operator\\",\\"type\\":\\"address\\"},{\\"indexed\\":false,\\"internalType\\":\\"bool\\",\\"name\\":\\"approved\\",\\"type\\":\\"bool\\"}],\\"name\\":\\"ApprovalForAll\\",\\"type\\":\\"event\\"},{\\"anonymous\\":false,\\"inputs\\":[{\\"indexed\\":true,\\"internalType\\":\\"address\\",\\"name\\":\\"controller\\",\\"type\\":\\"address\\"},{\\"indexed\\":false,\\"internalType\\":\\"bool\\",\\"name\\":\\"active\\",\\"type\\":\\"bool\\"}],\\"name\\":\\"ControllerChanged\\",\\"type\\":\\"event\\"},{\\"anonymous\\":false,\\"inputs\\":[{\\"indexed\\":true,\\"internalType\\":\\"bytes32\\",\\"name\\":\\"node\\",\\"type\\":\\"bytes32\\"},{\\"indexed\\":false,\\"internalType\\":\\"uint64\\",\\"name\\":\\"expiry\\",\\"type\\":\\"uint64\\"}],\\"name\\":\\"ExpiryExtended\\",\\"type\\":\\"event\\"},{\\"anonymous\\":false,\\"inputs\\":[{\\"indexed\\":true,\\"internalType\\":\\"bytes32\\",\\"name\\":\\"node\\",\\"type\\":\\"bytes32\\"},{\\"indexed\\":false,\\"internalType\\":\\"uint32\\",\\"name\\":\\"fuses\\",\\"type\\":\\"uint32\\"}],\\"name\\":\\"FusesSet\\",\\"type\\":\\"event\\"},{\\"anonymous\\":false,\\"inputs\\":[{\\"indexed\\":true,\\"internalType\\":\\"bytes32\\",\\"name\\":\\"node\\",\\"type\\":\\"bytes32\\"},{\\"indexed\\":false,\\"internalType\\":\\"address\\",\\"name\\":\\"owner\\",\\"type\\":\\"address\\"}],\\"name\\":\\"NameUnwrapped\\",\\"type\\":\\"event\\"},{\\"anonymous\\":false,\\"inputs\\":[{\\"indexed\\":true,\\"internalType\\":\\"bytes32\\",\\"name\\":\\"node\\",\\"type\\":\\"bytes32\\"},{\\"indexed\\":false,\\"internalType\\":\\"bytes\\",\\"name\\":\\"name\\",\\"type\\":\\"bytes\\"},{\\"indexed\\":false,\\"internalType\\":\\"address\\",\\"name\\":\\"owner\\",\\"type\\":\\"address\\"},{\\"indexed\\":false,\\"internalType\\":\\"uint32\\",\\"name\\":\\"fuses\\",\\"type\\":\\"uint32\\"},{\\"indexed\\":false,\\"internalType\\":\\"uint64\\",\\"name\\":\\"expiry\\",\\"type\\":\\"uint64\\"}],\\"name\\":\\"NameWrapped\\",\\"type\\":\\"event\\"},{\\"anonymous\\":false,\\"inputs\\":[{\\"indexed\\":true,\\"internalType\\":\\"address\\",\\"name\\":\\"previousOwner\\",\\"type\\":\\"address\\"},{\\"indexed\\":true,\\"internalType\\":\\"address\\",\\"name\\":\\"newOwner\\",\\"type\\":\\"address\\"}],\\"name\\":\\"OwnershipTransferred\\",\\"type\\":\\"event\\"},{\\"anonymous\\":false,\\"inputs\\":[{\\"indexed\\":true,\\"internalType\\":\\"address\\",\\"name\\":\\"operator\\",\\"type\\":\\"address\\"},{\\"indexed\\":true,\\"internalType\\":\\"address\\",\\"name\\":\\"from\\",\\"type\\":\\"address\\"},{\\"indexed\\":true,\\"internalType\\":\\"address\\",\\"name\\":\\"to\\",\\"type\\":\\"address\\"},{\\"indexed\\":false,\\"internalType\\":\\"uint256[]\\",\\"name\\":\\"ids\\",\\"type\\":\\"uint256[]\\"},{\\"indexed\\":false,\\"internalType\\":\\"uint256[]\\",\\"name\\":\\"values\\",\\"type\\":\\"uint256[]\\"}],\\"name\\":\\"TransferBatch\\",\\"type\\":\\"event\\"},{\\"anonymous\\":false,\\"inputs\\":[{\\"indexed\\":true,\\"internalType\\":\\"address\\",\\"name\\":\\"operator\\",\\"type\\":\\"address\\"},{\\"indexed\\":true,\\"internalType\\":\\"address\\",\\"name\\":\\"from\\",\\"type\\":\\"address\\"},{\\"indexed\\":true,\\"internalType\\":\\"address\\",\\"name\\":\\"to\\",\\"type\\":\\"address\\"},{\\"indexed\\":false,\\"internalType\\":\\"uint256\\",\\"name\\":\\"id\\",\\"type\\":\\"uint256\\"},{\\"indexed\\":false,\\"internalType\\":\\"uint256\\",\\"name\\":\\"value\\",\\"type\\":\\"uint256\\"}],\\"name\\":\\"TransferSingle\\",\\"type\\":\\"event\\"},{\\"anonymous\\":false,\\"inputs\\":[{\\"indexed\\":false,\\"internalType\\":\\"string\\",\\"name\\":\\"value\\",\\"type\\":\\"string\\"},{\\"indexed\\":true,\\"internalType\\":\\"uint256\\",\\"name\\":\\"id\\",\\"type\\":\\"uint256\\"}],\\"name\\":\\"URI\\",\\"type\\":\\"event\\"},{\\"inputs\\":[{\\"internalType\\":\\"uint256\\",\\"name\\":\\"\\",\\"type\\":\\"uint256\\"}],\\"name\\":\\"_tokens\\",\\"outputs\\":[{\\"internalType\\":\\"uint256\\",\\"name\\":\\"\\",\\"type\\":\\"uint256\\"}],\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"},{\\"inputs\\":[{\\"internalType\\":\\"bytes32\\",\\"name\\":\\"node\\",\\"type\\":\\"bytes32\\"},{\\"internalType\\":\\"uint32\\",\\"name\\":\\"fuseMask\\",\\"type\\":\\"uint32\\"}],\\"name\\":\\"allFusesBurned\\",\\"outputs\\":[{\\"internalType\\":\\"bool\\",\\"name\\":\\"\\",\\"type\\":\\"bool\\"}],\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"},{\\"inputs\\":[{\\"internalType\\":\\"address\\",\\"name\\":\\"to\\",\\"type\\":\\"address\\"},{\\"internalType\\":\\"uint256\\",\\"name\\":\\"tokenId\\",\\"type\\":\\"uint256\\"}],\\"name\\":\\"approve\\",\\"outputs\\":[],\\"stateMutability\\":\\"nonpayable\\",\\"type\\":\\"function\\"},{\\"inputs\\":[{\\"internalType\\":\\"address\\",\\"name\\":\\"account\\",\\"type\\":\\"address\\"},{\\"internalType\\":\\"uint256\\",\\"name\\":\\"id\\",\\"type\\":\\"uint256\\"}],\\"name\\":\\"balanceOf\\",\\"outputs\\":[{\\"internalType\\":\\"uint256\\",\\"name\\":\\"\\",\\"type\\":\\"uint256\\"}],\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"},{\\"inputs\\":[{\\"internalType\\":\\"address[]\\",\\"name\\":\\"accounts\\",\\"type\\":\\"address[]\\"},{\\"internalType\\":\\"uint256[]\\",\\"name\\":\\"ids\\",\\"type\\":\\"uint256[]\\"}],\\"name\\":\\"balanceOfBatch\\",\\"outputs\\":[{\\"internalType\\":\\"uint256[]\\",\\"name\\":\\"\\",\\"type\\":\\"uint256[]\\"}],\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"},{\\"inputs\\":[{\\"internalType\\":\\"bytes32\\",\\"name\\":\\"node\\",\\"type\\":\\"bytes32\\"},{\\"internalType\\":\\"address\\",\\"name\\":\\"addr\\",\\"type\\":\\"address\\"}],\\"name\\":\\"canExtendSubnames\\",\\"outputs\\":[{\\"internalType\\":\\"bool\\",\\"name\\":\\"\\",\\"type\\":\\"bool\\"}],\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"},{\\"inputs\\":[{\\"internalType\\":\\"bytes32\\",\\"name\\":\\"node\\",\\"type\\":\\"bytes32\\"},{\\"internalType\\":\\"address\\",\\"name\\":\\"addr\\",\\"type\\":\\"address\\"}],\\"name\\":\\"canModifyName\\",\\"outputs\\":[{\\"internalType\\":\\"bool\\",\\"name\\":\\"\\",\\"type\\":\\"bool\\"}],\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"},{\\"inputs\\":[{\\"internalType\\":\\"address\\",\\"name\\":\\"\\",\\"type\\":\\"address\\"}],\\"name\\":\\"controllers\\",\\"outputs\\":[{\\"internalType\\":\\"bool\\",\\"name\\":\\"\\",\\"type\\":\\"bool\\"}],\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"},{\\"inputs\\":[],\\"name\\":\\"ens\\",\\"outputs\\":[{\\"internalType\\":\\"contract ENS\\",\\"name\\":\\"\\",\\"type\\":\\"address\\"}],\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"},{\\"inputs\\":[{\\"internalType\\":\\"bytes32\\",\\"name\\":\\"parentNode\\",\\"type\\":\\"bytes32\\"},{\\"internalType\\":\\"bytes32\\",\\"name\\":\\"labelhash\\",\\"type\\":\\"bytes32\\"},{\\"internalType\\":\\"uint64\\",\\"name\\":\\"expiry\\",\\"type\\":\\"uint64\\"}],\\"name\\":\\"extendExpiry\\",\\"outputs\\":[{\\"internalType\\":\\"uint64\\",\\"name\\":\\"\\",\\"type\\":\\"uint64\\"}],\\"stateMutability\\":\\"nonpayable\\",\\"type\\":\\"function\\"},{\\"inputs\\":[{\\"internalType\\":\\"uint256\\",\\"name\\":\\"id\\",\\"type\\":\\"uint256\\"}],\\"name\\":\\"getApproved\\",\\"outputs\\":[{\\"internalType\\":\\"address\\",\\"name\\":\\"operator\\",\\"type\\":\\"address\\"}],\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"},{\\"inputs\\":[{\\"internalType\\":\\"uint256\\",\\"name\\":\\"id\\",\\"type\\":\\"uint256\\"}],\\"name\\":\\"getData\\",\\"outputs\\":[{\\"internalType\\":\\"address\\",\\"name\\":\\"owner\\",\\"type\\":\\"address\\"},{\\"internalType\\":\\"uint32\\",\\"name\\":\\"fuses\\",\\"type\\":\\"uint32\\"},{\\"internalType\\":\\"uint64\\",\\"name\\":\\"expiry\\",\\"type\\":\\"uint64\\"}],\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"},{\\"inputs\\":[{\\"internalType\\":\\"address\\",\\"name\\":\\"account\\",\\"type\\":\\"address\\"},{\\"internalType\\":\\"address\\",\\"name\\":\\"operator\\",\\"type\\":\\"address\\"}],\\"name\\":\\"isApprovedForAll\\",\\"outputs\\":[{\\"internalType\\":\\"bool\\",\\"name\\":\\"\\",\\"type\\":\\"bool\\"}],\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"},{\\"inputs\\":[{\\"internalType\\":\\"bytes32\\",\\"name\\":\\"parentNode\\",\\"type\\":\\"bytes32\\"},{\\"internalType\\":\\"bytes32\\",\\"name\\":\\"labelhash\\",\\"type\\":\\"bytes32\\"}],\\"name\\":\\"isWrapped\\",\\"outputs\\":[{\\"internalType\\":\\"bool\\",\\"name\\":\\"\\",\\"type\\":\\"bool\\"}],\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"},{\\"inputs\\":[{\\"internalType\\":\\"bytes32\\",\\"name\\":\\"node\\",\\"type\\":\\"bytes32\\"}],\\"name\\":\\"isWrapped\\",\\"outputs\\":[{\\"internalType\\":\\"bool\\",\\"name\\":\\"\\",\\"type\\":\\"bool\\"}],\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"},{\\"inputs\\":[],\\"name\\":\\"metadataService\\",\\"outputs\\":[{\\"internalType\\":\\"contract IMetadataService\\",\\"name\\":\\"\\",\\"type\\":\\"address\\"}],\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"},{\\"inputs\\":[],\\"name\\":\\"name\\",\\"outputs\\":[{\\"internalType\\":\\"string\\",\\"name\\":\\"\\",\\"type\\":\\"string\\"}],\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"},{\\"inputs\\":[{\\"internalType\\":\\"bytes32\\",\\"name\\":\\"\\",\\"type\\":\\"bytes32\\"}],\\"name\\":\\"names\\",\\"outputs\\":[{\\"internalType\\":\\"bytes\\",\\"name\\":\\"\\",\\"type\\":\\"bytes\\"}],\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"},{\\"inputs\\":[{\\"internalType\\":\\"address\\",\\"name\\":\\"to\\",\\"type\\":\\"address\\"},{\\"internalType\\":\\"address\\",\\"name\\":\\"\\",\\"type\\":\\"address\\"},{\\"internalType\\":\\"uint256\\",\\"name\\":\\"tokenId\\",\\"type\\":\\"uint256\\"},{\\"internalType\\":\\"bytes\\",\\"name\\":\\"data\\",\\"type\\":\\"bytes\\"}],\\"name\\":\\"onERC721Received\\",\\"outputs\\":[{\\"internalType\\":\\"bytes4\\",\\"name\\":\\"\\",\\"type\\":\\"bytes4\\"}],\\"stateMutability\\":\\"nonpayable\\",\\"type\\":\\"function\\"},{\\"inputs\\":[],\\"name\\":\\"owner\\",\\"outputs\\":[{\\"internalType\\":\\"address\\",\\"name\\":\\"\\",\\"type\\":\\"address\\"}],\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"},{\\"inputs\\":[{\\"internalType\\":\\"uint256\\",\\"name\\":\\"id\\",\\"type\\":\\"uint256\\"}],\\"name\\":\\"ownerOf\\",\\"outputs\\":[{\\"internalType\\":\\"address\\",\\"name\\":\\"owner\\",\\"type\\":\\"address\\"}],\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"},{\\"inputs\\":[{\\"internalType\\":\\"address\\",\\"name\\":\\"_token\\",\\"type\\":\\"address\\"},{\\"internalType\\":\\"address\\",\\"name\\":\\"_to\\",\\"type\\":\\"address\\"},{\\"internalType\\":\\"uint256\\",\\"name\\":\\"_amount\\",\\"type\\":\\"uint256\\"}],\\"name\\":\\"recoverFunds\\",\\"outputs\\":[],\\"stateMutability\\":\\"nonpayable\\",\\"type\\":\\"function\\"},{\\"inputs\\":[{\\"internalType\\":\\"string\\",\\"name\\":\\"label\\",\\"type\\":\\"string\\"},{\\"internalType\\":\\"address\\",\\"name\\":\\"wrappedOwner\\",\\"type\\":\\"address\\"},{\\"internalType\\":\\"uint256\\",\\"name\\":\\"duration\\",\\"type\\":\\"uint256\\"},{\\"internalType\\":\\"address\\",\\"name\\":\\"resolver\\",\\"type\\":\\"address\\"},{\\"internalType\\":\\"uint16\\",\\"name\\":\\"ownerControlledFuses\\",\\"type\\":\\"uint16\\"}],\\"name\\":\\"registerAndWrapETH2LD\\",\\"outputs\\":[{\\"internalType\\":\\"uint256\\",\\"name\\":\\"registrarExpiry\\",\\"type\\":\\"uint256\\"}],\\"stateMutability\\":\\"nonpayable\\",\\"type\\":\\"function\\"},{\\"inputs\\":[],\\"name\\":\\"registrar\\",\\"outputs\\":[{\\"internalType\\":\\"contract IBaseRegistrar\\",\\"name\\":\\"\\",\\"type\\":\\"address\\"}],\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"},{\\"inputs\\":[{\\"internalType\\":\\"uint256\\",\\"name\\":\\"tokenId\\",\\"type\\":\\"uint256\\"},{\\"internalType\\":\\"uint256\\",\\"name\\":\\"duration\\",\\"type\\":\\"uint256\\"}],\\"name\\":\\"renew\\",\\"outputs\\":[{\\"internalType\\":\\"uint256\\",\\"name\\":\\"expires\\",\\"type\\":\\"uint256\\"}],\\"stateMutability\\":\\"nonpayable\\",\\"type\\":\\"function\\"},{\\"inputs\\":[],\\"name\\":\\"renounceOwnership\\",\\"outputs\\":[],\\"stateMutability\\":\\"nonpayable\\",\\"type\\":\\"function\\"},{\\"inputs\\":[{\\"internalType\\":\\"address\\",\\"name\\":\\"from\\",\\"type\\":\\"address\\"},{\\"internalType\\":\\"address\\",\\"name\\":\\"to\\",\\"type\\":\\"address\\"},{\\"internalType\\":\\"uint256[]\\",\\"name\\":\\"ids\\",\\"type\\":\\"uint256[]\\"},{\\"internalType\\":\\"uint256[]\\",\\"name\\":\\"amounts\\",\\"type\\":\\"uint256[]\\"},{\\"internalType\\":\\"bytes\\",\\"name\\":\\"data\\",\\"type\\":\\"bytes\\"}],\\"name\\":\\"safeBatchTransferFrom\\",\\"outputs\\":[],\\"stateMutability\\":\\"nonpayable\\",\\"type\\":\\"function\\"},{\\"inputs\\":[{\\"internalType\\":\\"address\\",\\"name\\":\\"from\\",\\"type\\":\\"address\\"},{\\"internalType\\":\\"address\\",\\"name\\":\\"to\\",\\"type\\":\\"address\\"},{\\"internalType\\":\\"uint256\\",\\"name\\":\\"id\\",\\"type\\":\\"uint256\\"},{\\"internalType\\":\\"uint256\\",\\"name\\":\\"amount\\",\\"type\\":\\"uint256\\"},{\\"internalType\\":\\"bytes\\",\\"name\\":\\"data\\",\\"type\\":\\"bytes\\"}],\\"name\\":\\"safeTransferFrom\\",\\"outputs\\":[],\\"stateMutability\\":\\"nonpayable\\",\\"type\\":\\"function\\"},{\\"inputs\\":[{\\"internalType\\":\\"address\\",\\"name\\":\\"operator\\",\\"type\\":\\"address\\"},{\\"internalType\\":\\"bool\\",\\"name\\":\\"approved\\",\\"type\\":\\"bool\\"}],\\"name\\":\\"setApprovalForAll\\",\\"outputs\\":[],\\"stateMutability\\":\\"nonpayable\\",\\"type\\":\\"function\\"},{\\"inputs\\":[{\\"internalType\\":\\"bytes32\\",\\"name\\":\\"parentNode\\",\\"type\\":\\"bytes32\\"},{\\"internalType\\":\\"bytes32\\",\\"name\\":\\"labelhash\\",\\"type\\":\\"bytes32\\"},{\\"internalType\\":\\"uint32\\",\\"name\\":\\"fuses\\",\\"type\\":\\"uint32\\"},{\\"internalType\\":\\"uint64\\",\\"name\\":\\"expiry\\",\\"type\\":\\"uint64\\"}],\\"name\\":\\"setChildFuses\\",\\"outputs\\":[],\\"stateMutability\\":\\"nonpayable\\",\\"type\\":\\"function\\"},{\\"inputs\\":[{\\"internalType\\":\\"address\\",\\"name\\":\\"controller\\",\\"type\\":\\"address\\"},{\\"internalType\\":\\"bool\\",\\"name\\":\\"active\\",\\"type\\":\\"bool\\"}],\\"name\\":\\"setController\\",\\"outputs\\":[],\\"stateMutability\\":\\"nonpayable\\",\\"type\\":\\"function\\"},{\\"inputs\\":[{\\"internalType\\":\\"bytes32\\",\\"name\\":\\"node\\",\\"type\\":\\"bytes32\\"},{\\"internalType\\":\\"uint16\\",\\"name\\":\\"ownerControlledFuses\\",\\"type\\":\\"uint16\\"}],\\"name\\":\\"setFuses\\",\\"outputs\\":[{\\"internalType\\":\\"uint32\\",\\"name\\":\\"\\",\\"type\\":\\"uint32\\"}],\\"stateMutability\\":\\"nonpayable\\",\\"type\\":\\"function\\"},{\\"inputs\\":[{\\"internalType\\":\\"contract IMetadataService\\",\\"name\\":\\"_metadataService\\",\\"type\\":\\"address\\"}],\\"name\\":\\"setMetadataService\\",\\"outputs\\":[],\\"stateMutability\\":\\"nonpayable\\",\\"type\\":\\"function\\"},{\\"inputs\\":[{\\"internalType\\":\\"bytes32\\",\\"name\\":\\"node\\",\\"type\\":\\"bytes32\\"},{\\"internalType\\":\\"address\\",\\"name\\":\\"owner\\",\\"type\\":\\"address\\"},{\\"internalType\\":\\"address\\",\\"name\\":\\"resolver\\",\\"type\\":\\"address\\"},{\\"internalType\\":\\"uint64\\",\\"name\\":\\"ttl\\",\\"type\\":\\"uint64\\"}],\\"name\\":\\"setRecord\\",\\"outputs\\":[],\\"stateMutability\\":\\"nonpayable\\",\\"type\\":\\"function\\"},{\\"inputs\\":[{\\"internalType\\":\\"bytes32\\",\\"name\\":\\"node\\",\\"type\\":\\"bytes32\\"},{\\"internalType\\":\\"address\\",\\"name\\":\\"resolver\\",\\"type\\":\\"address\\"}],\\"name\\":\\"setResolver\\",\\"outputs\\":[],\\"stateMutability\\":\\"nonpayable\\",\\"type\\":\\"function\\"},{\\"inputs\\":[{\\"internalType\\":\\"bytes32\\",\\"name\\":\\"parentNode\\",\\"type\\":\\"bytes32\\"},{\\"internalType\\":\\"string\\",\\"name\\":\\"label\\",\\"type\\":\\"string\\"},{\\"internalType\\":\\"address\\",\\"name\\":\\"owner\\",\\"type\\":\\"address\\"},{\\"internalType\\":\\"uint32\\",\\"name\\":\\"fuses\\",\\"type\\":\\"uint32\\"},{\\"internalType\\":\\"uint64\\",\\"name\\":\\"expiry\\",\\"type\\":\\"uint64\\"}],\\"name\\":\\"setSubnodeOwner\\",\\"outputs\\":[{\\"internalType\\":\\"bytes32\\",\\"name\\":\\"node\\",\\"type\\":\\"bytes32\\"}],\\"stateMutability\\":\\"nonpayable\\",\\"type\\":\\"function\\"},{\\"inputs\\":[{\\"internalType\\":\\"bytes32\\",\\"name\\":\\"parentNode\\",\\"type\\":\\"bytes32\\"},{\\"internalType\\":\\"string\\",\\"name\\":\\"label\\",\\"type\\":\\"string\\"},{\\"internalType\\":\\"address\\",\\"name\\":\\"owner\\",\\"type\\":\\"address\\"},{\\"internalType\\":\\"address\\",\\"name\\":\\"resolver\\",\\"type\\":\\"address\\"},{\\"internalType\\":\\"uint64\\",\\"name\\":\\"ttl\\",\\"type\\":\\"uint64\\"},{\\"internalType\\":\\"uint32\\",\\"name\\":\\"fuses\\",\\"type\\":\\"uint32\\"},{\\"internalType\\":\\"uint64\\",\\"name\\":\\"expiry\\",\\"type\\":\\"uint64\\"}],\\"name\\":\\"setSubnodeRecord\\",\\"outputs\\":[{\\"internalType\\":\\"bytes32\\",\\"name\\":\\"node\\",\\"type\\":\\"bytes32\\"}],\\"stateMutability\\":\\"nonpayable\\",\\"type\\":\\"function\\"},{\\"inputs\\":[{\\"internalType\\":\\"bytes32\\",\\"name\\":\\"node\\",\\"type\\":\\"bytes32\\"},{\\"internalType\\":\\"uint64\\",\\"name\\":\\"ttl\\",\\"type\\":\\"uint64\\"}],\\"name\\":\\"setTTL\\",\\"outputs\\":[],\\"stateMutability\\":\\"nonpayable\\",\\"type\\":\\"function\\"},{\\"inputs\\":[{\\"internalType\\":\\"contract INameWrapperUpgrade\\",\\"name\\":\\"_upgradeAddress\\",\\"type\\":\\"address\\"}],\\"name\\":\\"setUpgradeContract\\",\\"outputs\\":[],\\"stateMutability\\":\\"nonpayable\\",\\"type\\":\\"function\\"},{\\"inputs\\":[{\\"internalType\\":\\"bytes4\\",\\"name\\":\\"interfaceId\\",\\"type\\":\\"bytes4\\"}],\\"name\\":\\"supportsInterface\\",\\"outputs\\":[{\\"internalType\\":\\"bool\\",\\"name\\":\\"\\",\\"type\\":\\"bool\\"}],\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"},{\\"inputs\\":[{\\"internalType\\":\\"address\\",\\"name\\":\\"newOwner\\",\\"type\\":\\"address\\"}],\\"name\\":\\"transferOwnership\\",\\"outputs\\":[],\\"stateMutability\\":\\"nonpayable\\",\\"type\\":\\"function\\"},{\\"inputs\\":[{\\"internalType\\":\\"bytes32\\",\\"name\\":\\"parentNode\\",\\"type\\":\\"bytes32\\"},{\\"internalType\\":\\"bytes32\\",\\"name\\":\\"labelhash\\",\\"type\\":\\"bytes32\\"},{\\"internalType\\":\\"address\\",\\"name\\":\\"controller\\",\\"type\\":\\"address\\"}],\\"name\\":\\"unwrap\\",\\"outputs\\":[],\\"stateMutability\\":\\"nonpayable\\",\\"type\\":\\"function\\"},{\\"inputs\\":[{\\"internalType\\":\\"bytes32\\",\\"name\\":\\"labelhash\\",\\"type\\":\\"bytes32\\"},{\\"internalType\\":\\"address\\",\\"name\\":\\"registrant\\",\\"type\\":\\"address\\"},{\\"internalType\\":\\"address\\",\\"name\\":\\"controller\\",\\"type\\":\\"address\\"}],\\"name\\":\\"unwrapETH2LD\\",\\"outputs\\":[],\\"stateMutability\\":\\"nonpayable\\",\\"type\\":\\"function\\"},{\\"inputs\\":[{\\"internalType\\":\\"bytes\\",\\"name\\":\\"name\\",\\"type\\":\\"bytes\\"},{\\"internalType\\":\\"bytes\\",\\"name\\":\\"extraData\\",\\"type\\":\\"bytes\\"}],\\"name\\":\\"upgrade\\",\\"outputs\\":[],\\"stateMutability\\":\\"nonpayable\\",\\"type\\":\\"function\\"},{\\"inputs\\":[],\\"name\\":\\"upgradeContract\\",\\"outputs\\":[{\\"internalType\\":\\"contract INameWrapperUpgrade\\",\\"name\\":\\"\\",\\"type\\":\\"address\\"}],\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"},{\\"inputs\\":[{\\"internalType\\":\\"uint256\\",\\"name\\":\\"tokenId\\",\\"type\\":\\"uint256\\"}],\\"name\\":\\"uri\\",\\"outputs\\":[{\\"internalType\\":\\"string\\",\\"name\\":\\"\\",\\"type\\":\\"string\\"}],\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"},{\\"inputs\\":[{\\"internalType\\":\\"bytes\\",\\"name\\":\\"name\\",\\"type\\":\\"bytes\\"},{\\"internalType\\":\\"address\\",\\"name\\":\\"wrappedOwner\\",\\"type\\":\\"address\\"},{\\"internalType\\":\\"address\\",\\"name\\":\\"resolver\\",\\"type\\":\\"address\\"}],\\"name\\":\\"wrap\\",\\"outputs\\":[],\\"stateMutability\\":\\"nonpayable\\",\\"type\\":\\"function\\"},{\\"inputs\\":[{\\"internalType\\":\\"string\\",\\"name\\":\\"label\\",\\"type\\":\\"string\\"},{\\"internalType\\":\\"address\\",\\"name\\":\\"wrappedOwner\\",\\"type\\":\\"address\\"},{\\"internalType\\":\\"uint16\\",\\"name\\":\\"ownerControlledFuses\\",\\"type\\":\\"uint16\\"},{\\"internalType\\":\\"address\\",\\"name\\":\\"resolver\\",\\"type\\":\\"address\\"}],\\"name\\":\\"wrapETH2LD\\",\\"outputs\\":[{\\"internalType\\":\\"uint64\\",\\"name\\":\\"expiry\\",\\"type\\":\\"uint64\\"}],\\"stateMutability\\":\\"nonpayable\\",\\"type\\":\\"function\\"}],\\"devdoc\\":{\\"kind\\":\\"dev\\",\\"methods\\":{\\"allFusesBurned(bytes32,uint32)\\":{\\"params\\":{\\"fuseMask\\":\\"The fuses you want to check\\",\\"node\\":\\"Namehash of the name\\"},\\"returns\\":{\\"_0\\":\\"Boolean of whether or not all the selected fuses are burned\\"}},\\"approve(address,uint256)\\":{\\"params\\":{\\"to\\":\\"address to approve\\",\\"tokenId\\":\\"name to approve\\"}},\\"balanceOf(address,uint256)\\":{\\"details\\":\\"See {IERC1155-balanceOf}. Requirements: - `account` cannot be the zero address.\\"},\\"balanceOfBatch(address[],uint256[])\\":{\\"details\\":\\"See {IERC1155-balanceOfBatch}. Requirements: - `accounts` and `ids` must have the same length.\\"},\\"canExtendSubnames(bytes32,address)\\":{\\"params\\":{\\"addr\\":\\"which address to check permissions for\\",\\"node\\":\\"namehash of the name to check\\"},\\"returns\\":{\\"_0\\":\\"whether or not is owner/operator or approved\\"}},\\"canModifyName(bytes32,address)\\":{\\"params\\":{\\"addr\\":\\"which address to check permissions for\\",\\"node\\":\\"namehash of the name to check\\"},\\"returns\\":{\\"_0\\":\\"whether or not is owner or operator\\"}},\\"extendExpiry(bytes32,bytes32,uint64)\\":{\\"params\\":{\\"expiry\\":\\"When the name will expire in seconds since the Unix epoch\\",\\"labelhash\\":\\"Labelhash of the name, e.g. vitalik.xyz would be keccak256(\'vitalik\')\\",\\"parentNode\\":\\"Parent namehash of the name e.g. vitalik.xyz would be namehash(\'xyz\')\\"},\\"returns\\":{\\"_0\\":\\"New expiry\\"}},\\"getApproved(uint256)\\":{\\"params\\":{\\"id\\":\\"Namehash of the name\\"},\\"returns\\":{\\"operator\\":\\"Approved operator of a name\\"}},\\"getData(uint256)\\":{\\"params\\":{\\"id\\":\\"Namehash of the name\\"},\\"returns\\":{\\"expiry\\":\\"Expiry of the name\\",\\"fuses\\":\\"Fuses of the name\\",\\"owner\\":\\"Owner of the name\\"}},\\"isApprovedForAll(address,address)\\":{\\"details\\":\\"See {IERC1155-isApprovedForAll}.\\"},\\"isWrapped(bytes32)\\":{\\"params\\":{\\"node\\":\\"Namehash of the name\\"},\\"returns\\":{\\"_0\\":\\"Boolean of whether or not the name is wrapped\\"}},\\"isWrapped(bytes32,bytes32)\\":{\\"params\\":{\\"labelhash\\":\\"Namehash of the name\\",\\"parentNode\\":\\"Namehash of the name\\"},\\"returns\\":{\\"_0\\":\\"Boolean of whether or not the name is wrapped\\"}},\\"owner()\\":{\\"details\\":\\"Returns the address of the current owner.\\"},\\"ownerOf(uint256)\\":{\\"params\\":{\\"id\\":\\"Label as a string of the .eth domain to wrap\\"},\\"returns\\":{\\"owner\\":\\"The owner of the name\\"}},\\"recoverFunds(address,address,uint256)\\":{\\"details\\":\\"The contract is Ownable and only the owner can call the recover function.\\",\\"params\\":{\\"_amount\\":\\"The amount of tokens to recover.\\",\\"_to\\":\\"The address to send the tokens to.\\",\\"_token\\":\\"The address of the ERC20 token to recover\\"}},\\"registerAndWrapETH2LD(string,address,uint256,address,uint16)\\":{\\"details\\":\\"Registers a new .eth second-level domain and wraps it.      Only callable by authorised controllers.\\",\\"params\\":{\\"duration\\":\\"The duration, in seconds, to register the name for.\\",\\"label\\":\\"The label to register (Eg, \'foo\' for \'foo.eth\').\\",\\"ownerControlledFuses\\":\\"Initial owner-controlled fuses to set\\",\\"resolver\\":\\"The resolver address to set on the ENS registry (optional).\\",\\"wrappedOwner\\":\\"The owner of the wrapped name.\\"},\\"returns\\":{\\"registrarExpiry\\":\\"The expiry date of the new name on the .eth registrar, in seconds since the Unix epoch.\\"}},\\"renew(uint256,uint256)\\":{\\"details\\":\\"Only callable by authorised controllers.\\",\\"params\\":{\\"duration\\":\\"The number of seconds to renew the name for.\\",\\"tokenId\\":\\"The hash of the label to register (eg, `keccak256(\'foo\')`, for \'foo.eth\').\\"},\\"returns\\":{\\"expires\\":\\"The expiry date of the name on the .eth registrar, in seconds since the Unix epoch.\\"}},\\"renounceOwnership()\\":{\\"details\\":\\"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.\\"},\\"safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)\\":{\\"details\\":\\"See {IERC1155-safeBatchTransferFrom}.\\"},\\"safeTransferFrom(address,address,uint256,uint256,bytes)\\":{\\"details\\":\\"See {IERC1155-safeTransferFrom}.\\"},\\"setApprovalForAll(address,bool)\\":{\\"details\\":\\"See {IERC1155-setApprovalForAll}.\\"},\\"setChildFuses(bytes32,bytes32,uint32,uint64)\\":{\\"params\\":{\\"expiry\\":\\"When the name will expire in seconds since the Unix epoch\\",\\"fuses\\":\\"Fuses to burn\\",\\"labelhash\\":\\"Labelhash of the name, e.g. vitalik.xyz would be keccak256(\'vitalik\')\\",\\"parentNode\\":\\"Parent namehash of the name e.g. vitalik.xyz would be namehash(\'xyz\')\\"}},\\"setFuses(bytes32,uint16)\\":{\\"params\\":{\\"node\\":\\"Namehash of the name\\",\\"ownerControlledFuses\\":\\"Owner-controlled fuses to burn\\"},\\"returns\\":{\\"_0\\":\\"Old fuses\\"}},\\"setMetadataService(address)\\":{\\"params\\":{\\"_metadataService\\":\\"The new metadata service\\"}},\\"setRecord(bytes32,address,address,uint64)\\":{\\"params\\":{\\"node\\":\\"Namehash of the name to set a record for\\",\\"owner\\":\\"New owner in the registry\\",\\"resolver\\":\\"Resolver contract\\",\\"ttl\\":\\"Time to live in the registry\\"}},\\"setResolver(bytes32,address)\\":{\\"params\\":{\\"node\\":\\"namehash of the name\\",\\"resolver\\":\\"the resolver contract\\"}},\\"setSubnodeOwner(bytes32,string,address,uint32,uint64)\\":{\\"params\\":{\\"expiry\\":\\"When the name will expire in seconds since the Unix epoch\\",\\"fuses\\":\\"Initial fuses for the wrapped subdomain\\",\\"label\\":\\"Label of the subdomain as a string\\",\\"owner\\":\\"New owner in the wrapper\\",\\"parentNode\\":\\"Parent namehash of the subdomain\\"},\\"returns\\":{\\"node\\":\\"Namehash of the subdomain\\"}},\\"setSubnodeRecord(bytes32,string,address,address,uint64,uint32,uint64)\\":{\\"params\\":{\\"expiry\\":\\"When the name will expire in seconds since the Unix epoch\\",\\"fuses\\":\\"initial fuses for the wrapped subdomain\\",\\"label\\":\\"label of the subdomain as a string\\",\\"owner\\":\\"new owner in the wrapper\\",\\"parentNode\\":\\"parent namehash of the subdomain\\",\\"resolver\\":\\"resolver contract in the registry\\",\\"ttl\\":\\"ttl in the registry\\"},\\"returns\\":{\\"node\\":\\"Namehash of the subdomain\\"}},\\"setTTL(bytes32,uint64)\\":{\\"params\\":{\\"node\\":\\"Namehash of the name\\",\\"ttl\\":\\"TTL in the registry\\"}},\\"setUpgradeContract(address)\\":{\\"details\\":\\"The default value of upgradeContract is the 0 address. Use the 0 address at any time to make the contract not upgradable.\\",\\"params\\":{\\"_upgradeAddress\\":\\"address of an upgraded contract\\"}},\\"transferOwnership(address)\\":{\\"details\\":\\"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.\\"},\\"unwrap(bytes32,bytes32,address)\\":{\\"details\\":\\"Can be called by the owner in the wrapper or an authorised caller in the wrapper\\",\\"params\\":{\\"controller\\":\\"Sets the owner in the registry to this address\\",\\"labelhash\\":\\"Labelhash of the name, e.g. vitalik.xyz would be keccak256(\'vitalik\')\\",\\"parentNode\\":\\"Parent namehash of the name e.g. vitalik.xyz would be namehash(\'xyz\')\\"}},\\"unwrapETH2LD(bytes32,address,address)\\":{\\"details\\":\\"Can be called by the owner in the wrapper or an authorised caller in the wrapper\\",\\"params\\":{\\"controller\\":\\"Sets the owner in the registry to this address\\",\\"labelhash\\":\\"Labelhash of the .eth domain\\",\\"registrant\\":\\"Sets the owner in the .eth registrar to this address\\"}},\\"upgrade(bytes,bytes)\\":{\\"details\\":\\"Can be called by the owner or an authorised caller\\",\\"params\\":{\\"extraData\\":\\"Extra data to pass to the upgrade contract\\",\\"name\\":\\"The name to upgrade, in DNS format\\"}},\\"uri(uint256)\\":{\\"params\\":{\\"tokenId\\":\\"The id of the token\\"},\\"returns\\":{\\"_0\\":\\"string uri of the metadata service\\"}},\\"wrap(bytes,address,address)\\":{\\"details\\":\\"Can be called by the owner in the registry or an authorised caller in the registry\\",\\"params\\":{\\"name\\":\\"The name to wrap, in DNS format\\",\\"resolver\\":\\"Resolver contract\\",\\"wrappedOwner\\":\\"Owner of the name in this contract\\"}},\\"wrapETH2LD(string,address,uint16,address)\\":{\\"details\\":\\"Can be called by the owner of the name on the .eth registrar or an authorised caller on the registrar\\",\\"params\\":{\\"label\\":\\"Label as a string of the .eth domain to wrap\\",\\"ownerControlledFuses\\":\\"Initial owner-controlled fuses to set\\",\\"resolver\\":\\"Resolver contract address\\",\\"wrappedOwner\\":\\"Owner of the name in this contract\\"}}},\\"version\\":1},\\"userdoc\\":{\\"kind\\":\\"user\\",\\"methods\\":{\\"allFusesBurned(bytes32,uint32)\\":{\\"notice\\":\\"Checks all Fuses in the mask are burned for the node\\"},\\"approve(address,uint256)\\":{\\"notice\\":\\"Approves an address for a name\\"},\\"canExtendSubnames(bytes32,address)\\":{\\"notice\\":\\"Checks if owner/operator or approved by owner\\"},\\"canModifyName(bytes32,address)\\":{\\"notice\\":\\"Checks if owner or operator of the owner\\"},\\"extendExpiry(bytes32,bytes32,uint64)\\":{\\"notice\\":\\"Extends expiry for a name\\"},\\"getApproved(uint256)\\":{\\"notice\\":\\"Gets the owner of a name\\"},\\"getData(uint256)\\":{\\"notice\\":\\"Gets the data for a name\\"},\\"isWrapped(bytes32)\\":{\\"notice\\":\\"Checks if a name is wrapped\\"},\\"isWrapped(bytes32,bytes32)\\":{\\"notice\\":\\"Checks if a name is wrapped in a more gas efficient way\\"},\\"ownerOf(uint256)\\":{\\"notice\\":\\"Gets the owner of a name\\"},\\"recoverFunds(address,address,uint256)\\":{\\"notice\\":\\"Recover ERC20 tokens sent to the contract by mistake.\\"},\\"renew(uint256,uint256)\\":{\\"notice\\":\\"Renews a .eth second-level domain.\\"},\\"setChildFuses(bytes32,bytes32,uint32,uint64)\\":{\\"notice\\":\\"Sets fuses of a name that you own the parent of\\"},\\"setFuses(bytes32,uint16)\\":{\\"notice\\":\\"Sets fuses of a name\\"},\\"setMetadataService(address)\\":{\\"notice\\":\\"Set the metadata service. Only the owner can do this\\"},\\"setRecord(bytes32,address,address,uint64)\\":{\\"notice\\":\\"Sets records for the name in the ENS Registry\\"},\\"setResolver(bytes32,address)\\":{\\"notice\\":\\"Sets resolver contract in the registry\\"},\\"setSubnodeOwner(bytes32,string,address,uint32,uint64)\\":{\\"notice\\":\\"Sets the subdomain owner in the registry and then wraps the subdomain\\"},\\"setSubnodeRecord(bytes32,string,address,address,uint64,uint32,uint64)\\":{\\"notice\\":\\"Sets the subdomain owner in the registry with records and then wraps the subdomain\\"},\\"setTTL(bytes32,uint64)\\":{\\"notice\\":\\"Sets TTL in the registry\\"},\\"setUpgradeContract(address)\\":{\\"notice\\":\\"Set the address of the upgradeContract of the contract. only admin can do this\\"},\\"unwrap(bytes32,bytes32,address)\\":{\\"notice\\":\\"Unwraps a non .eth domain, of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain\\"},\\"unwrapETH2LD(bytes32,address,address)\\":{\\"notice\\":\\"Unwraps a .eth domain. e.g. vitalik.eth\\"},\\"upgrade(bytes,bytes)\\":{\\"notice\\":\\"Upgrades a domain of any kind. Could be a .eth name vitalik.eth, a DNSSEC name vitalik.xyz, or a subdomain\\"},\\"uri(uint256)\\":{\\"notice\\":\\"Get the metadata uri\\"},\\"wrap(bytes,address,address)\\":{\\"notice\\":\\"Wraps a non .eth domain, of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain\\"},\\"wrapETH2LD(string,address,uint16,address)\\":{\\"notice\\":\\"Wraps a .eth domain, creating a new token and sending the original ERC721 token to this contract\\"}},\\"version\\":1}},\\"settings\\":{\\"compilationTarget\\":{\\"contracts/wrapper/NameWrapper.sol\\":\\"NameWrapper\\"},\\"evmVersion\\":\\"london\\",\\"libraries\\":{},\\"metadata\\":{\\"bytecodeHash\\":\\"ipfs\\",\\"useLiteralContent\\":true},\\"optimizer\\":{\\"enabled\\":true,\\"runs\\":1200},\\"remappings\\":[]},\\"sources\\":{\\"@openzeppelin/contracts/access/Ownable.sol\\":{\\"content\\":\\"// SPDX-License-Identifier: MIT\\\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\\\n\\\\npragma solidity ^0.8.0;\\\\n\\\\nimport \\\\\\"../utils/Context.sol\\\\\\";\\\\n\\\\n/**\\\\n * @dev Contract module which provides a basic access control mechanism, where\\\\n * there is an account (an owner) that can be granted exclusive access to\\\\n * specific functions.\\\\n *\\\\n * By default, the owner account will be the one that deploys the contract. This\\\\n * can later be changed with {transferOwnership}.\\\\n *\\\\n * This module is used through inheritance. It will make available the modifier\\\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\\\n * the owner.\\\\n */\\\\nabstract contract Ownable is Context {\\\\n    address private _owner;\\\\n\\\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\\\n\\\\n    /**\\\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\\\n     */\\\\n    constructor() {\\\\n        _transferOwnership(_msgSender());\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Throws if called by any account other than the owner.\\\\n     */\\\\n    modifier onlyOwner() {\\\\n        _checkOwner();\\\\n        _;\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Returns the address of the current owner.\\\\n     */\\\\n    function owner() public view virtual returns (address) {\\\\n        return _owner;\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Throws if the sender is not the owner.\\\\n     */\\\\n    function _checkOwner() internal view virtual {\\\\n        require(owner() == _msgSender(), \\\\\\"Ownable: caller is not the owner\\\\\\");\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Leaves the contract without owner. It will not be possible to call\\\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\\\n     *\\\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\\\n     * thereby removing any functionality that is only available to the owner.\\\\n     */\\\\n    function renounceOwnership() public virtual onlyOwner {\\\\n        _transferOwnership(address(0));\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\\\n     * Can only be called by the current owner.\\\\n     */\\\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\\\n        require(newOwner != address(0), \\\\\\"Ownable: new owner is the zero address\\\\\\");\\\\n        _transferOwnership(newOwner);\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\\\n     * Internal function without access restriction.\\\\n     */\\\\n    function _transferOwnership(address newOwner) internal virtual {\\\\n        address oldOwner = _owner;\\\\n        _owner = newOwner;\\\\n        emit OwnershipTransferred(oldOwner, newOwner);\\\\n    }\\\\n}\\\\n\\",\\"keccak256\\":\\"0xa94b34880e3c1b0b931662cb1c09e5dfa6662f31cba80e07c5ee71cd135c9673\\",\\"license\\":\\"MIT\\"},\\"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\\":{\\"content\\":\\"// SPDX-License-Identifier: MIT\\\\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC1155/IERC1155.sol)\\\\n\\\\npragma solidity ^0.8.0;\\\\n\\\\nimport \\\\\\"../../utils/introspection/IERC165.sol\\\\\\";\\\\n\\\\n/**\\\\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\\\\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\\\\n *\\\\n * _Available since v3.1._\\\\n */\\\\ninterface IERC1155 is IERC165 {\\\\n    /**\\\\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\\\\n     */\\\\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\\\\n\\\\n    /**\\\\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\\\\n     * transfers.\\\\n     */\\\\n    event TransferBatch(\\\\n        address indexed operator,\\\\n        address indexed from,\\\\n        address indexed to,\\\\n        uint256[] ids,\\\\n        uint256[] values\\\\n    );\\\\n\\\\n    /**\\\\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\\\\n     * `approved`.\\\\n     */\\\\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\\\\n\\\\n    /**\\\\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\\\\n     *\\\\n     * If an {URI} event was emitted for `id`, the standard\\\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\\\\n     * returned by {IERC1155MetadataURI-uri}.\\\\n     */\\\\n    event URI(string value, uint256 indexed id);\\\\n\\\\n    /**\\\\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\\\\n     *\\\\n     * Requirements:\\\\n     *\\\\n     * - `account` cannot be the zero address.\\\\n     */\\\\n    function balanceOf(address account, uint256 id) external view returns (uint256);\\\\n\\\\n    /**\\\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\\\\n     *\\\\n     * Requirements:\\\\n     *\\\\n     * - `accounts` and `ids` must have the same length.\\\\n     */\\\\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\\\\n        external\\\\n        view\\\\n        returns (uint256[] memory);\\\\n\\\\n    /**\\\\n     * @dev Grants or revokes permission to `operator` to transfer the caller\'s tokens, according to `approved`,\\\\n     *\\\\n     * Emits an {ApprovalForAll} event.\\\\n     *\\\\n     * Requirements:\\\\n     *\\\\n     * - `operator` cannot be the caller.\\\\n     */\\\\n    function setApprovalForAll(address operator, bool approved) external;\\\\n\\\\n    /**\\\\n     * @dev Returns true if `operator` is approved to transfer ``account``\'s tokens.\\\\n     *\\\\n     * See {setApprovalForAll}.\\\\n     */\\\\n    function isApprovedForAll(address account, address operator) external view returns (bool);\\\\n\\\\n    /**\\\\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\\\\n     *\\\\n     * Emits a {TransferSingle} event.\\\\n     *\\\\n     * Requirements:\\\\n     *\\\\n     * - `to` cannot be the zero address.\\\\n     * - If the caller is not `from`, it must have been approved to spend ``from``\'s tokens via {setApprovalForAll}.\\\\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\\\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\\\n     * acceptance magic value.\\\\n     */\\\\n    function safeTransferFrom(\\\\n        address from,\\\\n        address to,\\\\n        uint256 id,\\\\n        uint256 amount,\\\\n        bytes calldata data\\\\n    ) external;\\\\n\\\\n    /**\\\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\\\\n     *\\\\n     * Emits a {TransferBatch} event.\\\\n     *\\\\n     * Requirements:\\\\n     *\\\\n     * - `ids` and `amounts` must have the same length.\\\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\\\n     * acceptance magic value.\\\\n     */\\\\n    function safeBatchTransferFrom(\\\\n        address from,\\\\n        address to,\\\\n        uint256[] calldata ids,\\\\n        uint256[] calldata amounts,\\\\n        bytes calldata data\\\\n    ) external;\\\\n}\\\\n\\",\\"keccak256\\":\\"0x6392f2cfe3a5ee802227fe7a2dfd47096d881aec89bddd214b35c5b46d3cd941\\",\\"license\\":\\"MIT\\"},\\"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\\":{\\"content\\":\\"// SPDX-License-Identifier: MIT\\\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\\\\n\\\\npragma solidity ^0.8.0;\\\\n\\\\nimport \\\\\\"../../utils/introspection/IERC165.sol\\\\\\";\\\\n\\\\n/**\\\\n * @dev _Available since v3.1._\\\\n */\\\\ninterface IERC1155Receiver is IERC165 {\\\\n    /**\\\\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\\\\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\\\\n     *\\\\n     * NOTE: To accept the transfer, this must return\\\\n     * `bytes4(keccak256(\\\\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\\\\"))`\\\\n     * (i.e. 0xf23a6e61, or its own function selector).\\\\n     *\\\\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\\\\n     * @param from The address which previously owned the token\\\\n     * @param id The ID of the token being transferred\\\\n     * @param value The amount of tokens being transferred\\\\n     * @param data Additional data with no specified format\\\\n     * @return `bytes4(keccak256(\\\\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\\\\"))` if transfer is allowed\\\\n     */\\\\n    function onERC1155Received(\\\\n        address operator,\\\\n        address from,\\\\n        uint256 id,\\\\n        uint256 value,\\\\n        bytes calldata data\\\\n    ) external returns (bytes4);\\\\n\\\\n    /**\\\\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\\\\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\\\\n     * been updated.\\\\n     *\\\\n     * NOTE: To accept the transfer(s), this must return\\\\n     * `bytes4(keccak256(\\\\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\\\\"))`\\\\n     * (i.e. 0xbc197c81, or its own function selector).\\\\n     *\\\\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\\\\n     * @param from The address which previously owned the token\\\\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\\\\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\\\\n     * @param data Additional data with no specified format\\\\n     * @return `bytes4(keccak256(\\\\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\\\\"))` if transfer is allowed\\\\n     */\\\\n    function onERC1155BatchReceived(\\\\n        address operator,\\\\n        address from,\\\\n        uint256[] calldata ids,\\\\n        uint256[] calldata values,\\\\n        bytes calldata data\\\\n    ) external returns (bytes4);\\\\n}\\\\n\\",\\"keccak256\\":\\"0xeb373f1fdc7b755c6a750123a9b9e3a8a02c1470042fd6505d875000a80bde0b\\",\\"license\\":\\"MIT\\"},\\"@openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol\\":{\\"content\\":\\"// SPDX-License-Identifier: MIT\\\\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/extensions/IERC1155MetadataURI.sol)\\\\n\\\\npragma solidity ^0.8.0;\\\\n\\\\nimport \\\\\\"../IERC1155.sol\\\\\\";\\\\n\\\\n/**\\\\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\\\\n * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].\\\\n *\\\\n * _Available since v3.1._\\\\n */\\\\ninterface IERC1155MetadataURI is IERC1155 {\\\\n    /**\\\\n     * @dev Returns the URI for token type `id`.\\\\n     *\\\\n     * If the `\\\\\\\\{id\\\\\\\\}` substring is present in the URI, it must be replaced by\\\\n     * clients with the actual token type ID.\\\\n     */\\\\n    function uri(uint256 id) external view returns (string memory);\\\\n}\\\\n\\",\\"keccak256\\":\\"0xa66d18b9a85458d28fc3304717964502ae36f7f8a2ff35bc83f6f85d74b03574\\",\\"license\\":\\"MIT\\"},\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\":{\\"content\\":\\"// SPDX-License-Identifier: MIT\\\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\\\n\\\\npragma solidity ^0.8.0;\\\\n\\\\n/**\\\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\\\n */\\\\ninterface IERC20 {\\\\n    /**\\\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\\\n     * another (`to`).\\\\n     *\\\\n     * Note that `value` may be zero.\\\\n     */\\\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\\\n\\\\n    /**\\\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\\\n     * a call to {approve}. `value` is the new allowance.\\\\n     */\\\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\\\n\\\\n    /**\\\\n     * @dev Returns the amount of tokens in existence.\\\\n     */\\\\n    function totalSupply() external view returns (uint256);\\\\n\\\\n    /**\\\\n     * @dev Returns the amount of tokens owned by `account`.\\\\n     */\\\\n    function balanceOf(address account) external view returns (uint256);\\\\n\\\\n    /**\\\\n     * @dev Moves `amount` tokens from the caller\'s account to `to`.\\\\n     *\\\\n     * Returns a boolean value indicating whether the operation succeeded.\\\\n     *\\\\n     * Emits a {Transfer} event.\\\\n     */\\\\n    function transfer(address to, uint256 amount) external returns (bool);\\\\n\\\\n    /**\\\\n     * @dev Returns the remaining number of tokens that `spender` will be\\\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\\\n     * zero by default.\\\\n     *\\\\n     * This value changes when {approve} or {transferFrom} are called.\\\\n     */\\\\n    function allowance(address owner, address spender) external view returns (uint256);\\\\n\\\\n    /**\\\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\'s tokens.\\\\n     *\\\\n     * Returns a boolean value indicating whether the operation succeeded.\\\\n     *\\\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\\\n     * that someone may use both the old and the new allowance by unfortunate\\\\n     * transaction ordering. One possible solution to mitigate this race\\\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\\\n     * desired value afterwards:\\\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\\\n     *\\\\n     * Emits an {Approval} event.\\\\n     */\\\\n    function approve(address spender, uint256 amount) external returns (bool);\\\\n\\\\n    /**\\\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\\\n     * allowance mechanism. `amount` is then deducted from the caller\'s\\\\n     * allowance.\\\\n     *\\\\n     * Returns a boolean value indicating whether the operation succeeded.\\\\n     *\\\\n     * Emits a {Transfer} event.\\\\n     */\\\\n    function transferFrom(\\\\n        address from,\\\\n        address to,\\\\n        uint256 amount\\\\n    ) external returns (bool);\\\\n}\\\\n\\",\\"keccak256\\":\\"0x9750c6b834f7b43000631af5cc30001c5f547b3ceb3635488f140f60e897ea6b\\",\\"license\\":\\"MIT\\"},\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\":{\\"content\\":\\"// SPDX-License-Identifier: MIT\\\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/IERC721.sol)\\\\n\\\\npragma solidity ^0.8.0;\\\\n\\\\nimport \\\\\\"../../utils/introspection/IERC165.sol\\\\\\";\\\\n\\\\n/**\\\\n * @dev Required interface of an ERC721 compliant contract.\\\\n */\\\\ninterface IERC721 is IERC165 {\\\\n    /**\\\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\\\n     */\\\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\\\n\\\\n    /**\\\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\\\n     */\\\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\\\n\\\\n    /**\\\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\\\n     */\\\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\\\n\\\\n    /**\\\\n     * @dev Returns the number of tokens in ``owner``\'s account.\\\\n     */\\\\n    function balanceOf(address owner) external view returns (uint256 balance);\\\\n\\\\n    /**\\\\n     * @dev Returns the owner of the `tokenId` token.\\\\n     *\\\\n     * Requirements:\\\\n     *\\\\n     * - `tokenId` must exist.\\\\n     */\\\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\\\n\\\\n    /**\\\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\\\n     *\\\\n     * Requirements:\\\\n     *\\\\n     * - `from` cannot be the zero address.\\\\n     * - `to` cannot be the zero address.\\\\n     * - `tokenId` token must exist and be owned by `from`.\\\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\\\n     *\\\\n     * Emits a {Transfer} event.\\\\n     */\\\\n    function safeTransferFrom(\\\\n        address from,\\\\n        address to,\\\\n        uint256 tokenId,\\\\n        bytes calldata data\\\\n    ) external;\\\\n\\\\n    /**\\\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\\\n     *\\\\n     * Requirements:\\\\n     *\\\\n     * - `from` cannot be the zero address.\\\\n     * - `to` cannot be the zero address.\\\\n     * - `tokenId` token must exist and be owned by `from`.\\\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\\\n     *\\\\n     * Emits a {Transfer} event.\\\\n     */\\\\n    function safeTransferFrom(\\\\n        address from,\\\\n        address to,\\\\n        uint256 tokenId\\\\n    ) external;\\\\n\\\\n    /**\\\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\\\n     *\\\\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\\\\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\\\\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\\\\n     *\\\\n     * Requirements:\\\\n     *\\\\n     * - `from` cannot be the zero address.\\\\n     * - `to` cannot be the zero address.\\\\n     * - `tokenId` token must be owned by `from`.\\\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\\\n     *\\\\n     * Emits a {Transfer} event.\\\\n     */\\\\n    function transferFrom(\\\\n        address from,\\\\n        address to,\\\\n        uint256 tokenId\\\\n    ) external;\\\\n\\\\n    /**\\\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\\\n     * The approval is cleared when the token is transferred.\\\\n     *\\\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\\\n     *\\\\n     * Requirements:\\\\n     *\\\\n     * - The caller must own the token or be an approved operator.\\\\n     * - `tokenId` must exist.\\\\n     *\\\\n     * Emits an {Approval} event.\\\\n     */\\\\n    function approve(address to, uint256 tokenId) external;\\\\n\\\\n    /**\\\\n     * @dev Approve or remove `operator` as an operator for the caller.\\\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\\\n     *\\\\n     * Requirements:\\\\n     *\\\\n     * - The `operator` cannot be the caller.\\\\n     *\\\\n     * Emits an {ApprovalForAll} event.\\\\n     */\\\\n    function setApprovalForAll(address operator, bool _approved) external;\\\\n\\\\n    /**\\\\n     * @dev Returns the account approved for `tokenId` token.\\\\n     *\\\\n     * Requirements:\\\\n     *\\\\n     * - `tokenId` must exist.\\\\n     */\\\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\\\n\\\\n    /**\\\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\\\n     *\\\\n     * See {setApprovalForAll}\\\\n     */\\\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\\\n}\\\\n\\",\\"keccak256\\":\\"0xab28a56179c1db258c9bf5235b382698cb650debecb51b23d12be9e241374b68\\",\\"license\\":\\"MIT\\"},\\"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\\":{\\"content\\":\\"// SPDX-License-Identifier: MIT\\\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\\\\n\\\\npragma solidity ^0.8.0;\\\\n\\\\n/**\\\\n * @title ERC721 token receiver interface\\\\n * @dev Interface for any contract that wants to support safeTransfers\\\\n * from ERC721 asset contracts.\\\\n */\\\\ninterface IERC721Receiver {\\\\n    /**\\\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\\\n     * by `operator` from `from`, this function is called.\\\\n     *\\\\n     * It must return its Solidity selector to confirm the token transfer.\\\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\\\n     *\\\\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\\\\n     */\\\\n    function onERC721Received(\\\\n        address operator,\\\\n        address from,\\\\n        uint256 tokenId,\\\\n        bytes calldata data\\\\n    ) external returns (bytes4);\\\\n}\\\\n\\",\\"keccak256\\":\\"0xa82b58eca1ee256be466e536706850163d2ec7821945abd6b4778cfb3bee37da\\",\\"license\\":\\"MIT\\"},\\"@openzeppelin/contracts/utils/Address.sol\\":{\\"content\\":\\"// SPDX-License-Identifier: MIT\\\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\\\\n\\\\npragma solidity ^0.8.1;\\\\n\\\\n/**\\\\n * @dev Collection of functions related to the address type\\\\n */\\\\nlibrary Address {\\\\n    /**\\\\n     * @dev Returns true if `account` is a contract.\\\\n     *\\\\n     * [IMPORTANT]\\\\n     * ====\\\\n     * It is unsafe to assume that an address for which this function returns\\\\n     * false is an externally-owned account (EOA) and not a contract.\\\\n     *\\\\n     * Among others, `isContract` will return false for the following\\\\n     * types of addresses:\\\\n     *\\\\n     *  - an externally-owned account\\\\n     *  - a contract in construction\\\\n     *  - an address where a contract will be created\\\\n     *  - an address where a contract lived, but was destroyed\\\\n     * ====\\\\n     *\\\\n     * [IMPORTANT]\\\\n     * ====\\\\n     * You shouldn\'t rely on `isContract` to protect against flash loan attacks!\\\\n     *\\\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\\\n     * constructor.\\\\n     * ====\\\\n     */\\\\n    function isContract(address account) internal view returns (bool) {\\\\n        // This method relies on extcodesize/address.code.length, which returns 0\\\\n        // for contracts in construction, since the code is only stored at the end\\\\n        // of the constructor execution.\\\\n\\\\n        return account.code.length > 0;\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\\\\n     * `recipient`, forwarding all available gas and reverting on errors.\\\\n     *\\\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\\\n     * imposed by `transfer`, making them unable to receive funds via\\\\n     * `transfer`. {sendValue} removes this limitation.\\\\n     *\\\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\\\n     *\\\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\\\n     * taken to not create reentrancy vulnerabilities. Consider using\\\\n     * {ReentrancyGuard} or the\\\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\\\n     */\\\\n    function sendValue(address payable recipient, uint256 amount) internal {\\\\n        require(address(this).balance >= amount, \\\\\\"Address: insufficient balance\\\\\\");\\\\n\\\\n        (bool success, ) = recipient.call{value: amount}(\\\\\\"\\\\\\");\\\\n        require(success, \\\\\\"Address: unable to send value, recipient may have reverted\\\\\\");\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Performs a Solidity function call using a low level `call`. A\\\\n     * plain `call` is an unsafe replacement for a function call: use this\\\\n     * function instead.\\\\n     *\\\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\\\n     * function (like regular Solidity function calls).\\\\n     *\\\\n     * Returns the raw returned data. To convert to the expected return value,\\\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\\\n     *\\\\n     * Requirements:\\\\n     *\\\\n     * - `target` must be a contract.\\\\n     * - calling `target` with `data` must not revert.\\\\n     *\\\\n     * _Available since v3.1._\\\\n     */\\\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\\\n        return functionCallWithValue(target, data, 0, \\\\\\"Address: low-level call failed\\\\\\");\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\\\n     *\\\\n     * _Available since v3.1._\\\\n     */\\\\n    function functionCall(\\\\n        address target,\\\\n        bytes memory data,\\\\n        string memory errorMessage\\\\n    ) internal returns (bytes memory) {\\\\n        return functionCallWithValue(target, data, 0, errorMessage);\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\\\n     * but also transferring `value` wei to `target`.\\\\n     *\\\\n     * Requirements:\\\\n     *\\\\n     * - the calling contract must have an ETH balance of at least `value`.\\\\n     * - the called Solidity function must be `payable`.\\\\n     *\\\\n     * _Available since v3.1._\\\\n     */\\\\n    function functionCallWithValue(\\\\n        address target,\\\\n        bytes memory data,\\\\n        uint256 value\\\\n    ) internal returns (bytes memory) {\\\\n        return functionCallWithValue(target, data, value, \\\\\\"Address: low-level call with value failed\\\\\\");\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\\\n     *\\\\n     * _Available since v3.1._\\\\n     */\\\\n    function functionCallWithValue(\\\\n        address target,\\\\n        bytes memory data,\\\\n        uint256 value,\\\\n        string memory errorMessage\\\\n    ) internal returns (bytes memory) {\\\\n        require(address(this).balance >= value, \\\\\\"Address: insufficient balance for call\\\\\\");\\\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\\\n     * but performing a static call.\\\\n     *\\\\n     * _Available since v3.3._\\\\n     */\\\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\\\n        return functionStaticCall(target, data, \\\\\\"Address: low-level static call failed\\\\\\");\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\\\n     * but performing a static call.\\\\n     *\\\\n     * _Available since v3.3._\\\\n     */\\\\n    function functionStaticCall(\\\\n        address target,\\\\n        bytes memory data,\\\\n        string memory errorMessage\\\\n    ) internal view returns (bytes memory) {\\\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\\\n     * but performing a delegate call.\\\\n     *\\\\n     * _Available since v3.4._\\\\n     */\\\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\\\n        return functionDelegateCall(target, data, \\\\\\"Address: low-level delegate call failed\\\\\\");\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\\\n     * but performing a delegate call.\\\\n     *\\\\n     * _Available since v3.4._\\\\n     */\\\\n    function functionDelegateCall(\\\\n        address target,\\\\n        bytes memory data,\\\\n        string memory errorMessage\\\\n    ) internal returns (bytes memory) {\\\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\\\n     *\\\\n     * _Available since v4.8._\\\\n     */\\\\n    function verifyCallResultFromTarget(\\\\n        address target,\\\\n        bool success,\\\\n        bytes memory returndata,\\\\n        string memory errorMessage\\\\n    ) internal view returns (bytes memory) {\\\\n        if (success) {\\\\n            if (returndata.length == 0) {\\\\n                // only check isContract if the call was successful and the return data is empty\\\\n                // otherwise we already know that it was a contract\\\\n                require(isContract(target), \\\\\\"Address: call to non-contract\\\\\\");\\\\n            }\\\\n            return returndata;\\\\n        } else {\\\\n            _revert(returndata, errorMessage);\\\\n        }\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\'t, either by bubbling the\\\\n     * revert reason or using the provided one.\\\\n     *\\\\n     * _Available since v4.3._\\\\n     */\\\\n    function verifyCallResult(\\\\n        bool success,\\\\n        bytes memory returndata,\\\\n        string memory errorMessage\\\\n    ) internal pure returns (bytes memory) {\\\\n        if (success) {\\\\n            return returndata;\\\\n        } else {\\\\n            _revert(returndata, errorMessage);\\\\n        }\\\\n    }\\\\n\\\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\\\n        // Look for revert reason and bubble it up if present\\\\n        if (returndata.length > 0) {\\\\n            // The easiest way to bubble the revert reason is using memory via assembly\\\\n            /// @solidity memory-safe-assembly\\\\n            assembly {\\\\n                let returndata_size := mload(returndata)\\\\n                revert(add(32, returndata), returndata_size)\\\\n            }\\\\n        } else {\\\\n            revert(errorMessage);\\\\n        }\\\\n    }\\\\n}\\\\n\\",\\"keccak256\\":\\"0xf96f969e24029d43d0df89e59d365f277021dac62b48e1c1e3ebe0acdd7f1ca1\\",\\"license\\":\\"MIT\\"},\\"@openzeppelin/contracts/utils/Context.sol\\":{\\"content\\":\\"// SPDX-License-Identifier: MIT\\\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\\\n\\\\npragma solidity ^0.8.0;\\\\n\\\\n/**\\\\n * @dev Provides information about the current execution context, including the\\\\n * sender of the transaction and its data. While these are generally available\\\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\\\n * manner, since when dealing with meta-transactions the account sending and\\\\n * paying for execution may not be the actual sender (as far as an application\\\\n * is concerned).\\\\n *\\\\n * This contract is only required for intermediate, library-like contracts.\\\\n */\\\\nabstract contract Context {\\\\n    function _msgSender() internal view virtual returns (address) {\\\\n        return msg.sender;\\\\n    }\\\\n\\\\n    function _msgData() internal view virtual returns (bytes calldata) {\\\\n        return msg.data;\\\\n    }\\\\n}\\\\n\\",\\"keccak256\\":\\"0xe2e337e6dde9ef6b680e07338c493ebea1b5fd09b43424112868e9cc1706bca7\\",\\"license\\":\\"MIT\\"},\\"@openzeppelin/contracts/utils/introspection/ERC165.sol\\":{\\"content\\":\\"// SPDX-License-Identifier: MIT\\\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\\\n\\\\npragma solidity ^0.8.0;\\\\n\\\\nimport \\\\\\"./IERC165.sol\\\\\\";\\\\n\\\\n/**\\\\n * @dev Implementation of the {IERC165} interface.\\\\n *\\\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\\\n * for the additional interface id that will be supported. For example:\\\\n *\\\\n * ```solidity\\\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\\\n * }\\\\n * ```\\\\n *\\\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\\\n */\\\\nabstract contract ERC165 is IERC165 {\\\\n    /**\\\\n     * @dev See {IERC165-supportsInterface}.\\\\n     */\\\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\\\n        return interfaceId == type(IERC165).interfaceId;\\\\n    }\\\\n}\\\\n\\",\\"keccak256\\":\\"0xd10975de010d89fd1c78dc5e8a9a7e7f496198085c151648f20cba166b32582b\\",\\"license\\":\\"MIT\\"},\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\":{\\"content\\":\\"// SPDX-License-Identifier: MIT\\\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\\\n\\\\npragma solidity ^0.8.0;\\\\n\\\\n/**\\\\n * @dev Interface of the ERC165 standard, as defined in the\\\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\\\n *\\\\n * Implementers can declare support of contract interfaces, which can then be\\\\n * queried by others ({ERC165Checker}).\\\\n *\\\\n * For an implementation, see {ERC165}.\\\\n */\\\\ninterface IERC165 {\\\\n    /**\\\\n     * @dev Returns true if this contract implements the interface defined by\\\\n     * `interfaceId`. See the corresponding\\\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\\\n     * to learn more about how these ids are created.\\\\n     *\\\\n     * This function call must use less than 30 000 gas.\\\\n     */\\\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\\\n}\\\\n\\",\\"keccak256\\":\\"0x447a5f3ddc18419d41ff92b3773fb86471b1db25773e07f877f548918a185bf1\\",\\"license\\":\\"MIT\\"},\\"contracts/ethregistrar/IBaseRegistrar.sol\\":{\\"content\\":\\"import \\\\\\"../registry/ENS.sol\\\\\\";\\\\nimport \\\\\\"./IBaseRegistrar.sol\\\\\\";\\\\nimport \\\\\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\\\\";\\\\n\\\\ninterface IBaseRegistrar is IERC721 {\\\\n    event ControllerAdded(address indexed controller);\\\\n    event ControllerRemoved(address indexed controller);\\\\n    event NameMigrated(\\\\n        uint256 indexed id,\\\\n        address indexed owner,\\\\n        uint256 expires\\\\n    );\\\\n    event NameRegistered(\\\\n        uint256 indexed id,\\\\n        address indexed owner,\\\\n        uint256 expires\\\\n    );\\\\n    event NameRenewed(uint256 indexed id, uint256 expires);\\\\n\\\\n    // Authorises a controller, who can register and renew domains.\\\\n    function addController(address controller) external;\\\\n\\\\n    // Revoke controller permission for an address.\\\\n    function removeController(address controller) external;\\\\n\\\\n    // Set the resolver for the TLD this registrar manages.\\\\n    function setResolver(address resolver) external;\\\\n\\\\n    // Returns the expiration timestamp of the specified label hash.\\\\n    function nameExpires(uint256 id) external view returns (uint256);\\\\n\\\\n    // Returns true if the specified name is available for registration.\\\\n    function available(uint256 id) external view returns (bool);\\\\n\\\\n    /**\\\\n     * @dev Register a name.\\\\n     */\\\\n    function register(\\\\n        uint256 id,\\\\n        address owner,\\\\n        uint256 duration\\\\n    ) external returns (uint256);\\\\n\\\\n    function renew(uint256 id, uint256 duration) external returns (uint256);\\\\n\\\\n    /**\\\\n     * @dev Reclaim ownership of a name in ENS, if you own it in the registrar.\\\\n     */\\\\n    function reclaim(uint256 id, address owner) external;\\\\n}\\\\n\\",\\"keccak256\\":\\"0x15f7b1dfa7cd34444daf79ec9b4d40437caa9257893ce0639d706fcc2ba69e52\\"},\\"contracts/registry/ENS.sol\\":{\\"content\\":\\"pragma solidity >=0.8.4;\\\\n\\\\ninterface ENS {\\\\n    // Logged when the owner of a node assigns a new owner to a subnode.\\\\n    event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\\\\n\\\\n    // Logged when the owner of a node transfers ownership to a new account.\\\\n    event Transfer(bytes32 indexed node, address owner);\\\\n\\\\n    // Logged when the resolver for a node changes.\\\\n    event NewResolver(bytes32 indexed node, address resolver);\\\\n\\\\n    // Logged when the TTL of a node changes\\\\n    event NewTTL(bytes32 indexed node, uint64 ttl);\\\\n\\\\n    // Logged when an operator is added or removed.\\\\n    event ApprovalForAll(\\\\n        address indexed owner,\\\\n        address indexed operator,\\\\n        bool approved\\\\n    );\\\\n\\\\n    function setRecord(\\\\n        bytes32 node,\\\\n        address owner,\\\\n        address resolver,\\\\n        uint64 ttl\\\\n    ) external;\\\\n\\\\n    function setSubnodeRecord(\\\\n        bytes32 node,\\\\n        bytes32 label,\\\\n        address owner,\\\\n        address resolver,\\\\n        uint64 ttl\\\\n    ) external;\\\\n\\\\n    function setSubnodeOwner(\\\\n        bytes32 node,\\\\n        bytes32 label,\\\\n        address owner\\\\n    ) external returns (bytes32);\\\\n\\\\n    function setResolver(bytes32 node, address resolver) external;\\\\n\\\\n    function setOwner(bytes32 node, address owner) external;\\\\n\\\\n    function setTTL(bytes32 node, uint64 ttl) external;\\\\n\\\\n    function setApprovalForAll(address operator, bool approved) external;\\\\n\\\\n    function owner(bytes32 node) external view returns (address);\\\\n\\\\n    function resolver(bytes32 node) external view returns (address);\\\\n\\\\n    function ttl(bytes32 node) external view returns (uint64);\\\\n\\\\n    function recordExists(bytes32 node) external view returns (bool);\\\\n\\\\n    function isApprovedForAll(\\\\n        address owner,\\\\n        address operator\\\\n    ) external view returns (bool);\\\\n}\\\\n\\",\\"keccak256\\":\\"0x7cb1158c7d268b63de1468e28e2711b28d686e2628ddb22da2149cd93ddeafda\\"},\\"contracts/reverseRegistrar/IReverseRegistrar.sol\\":{\\"content\\":\\"pragma solidity >=0.8.4;\\\\n\\\\ninterface IReverseRegistrar {\\\\n    function setDefaultResolver(address resolver) external;\\\\n\\\\n    function claim(address owner) external returns (bytes32);\\\\n\\\\n    function claimForAddr(\\\\n        address addr,\\\\n        address owner,\\\\n        address resolver\\\\n    ) external returns (bytes32);\\\\n\\\\n    function claimWithResolver(\\\\n        address owner,\\\\n        address resolver\\\\n    ) external returns (bytes32);\\\\n\\\\n    function setName(string memory name) external returns (bytes32);\\\\n\\\\n    function setNameForAddr(\\\\n        address addr,\\\\n        address owner,\\\\n        address resolver,\\\\n        string memory name\\\\n    ) external returns (bytes32);\\\\n\\\\n    function node(address addr) external pure returns (bytes32);\\\\n}\\\\n\\",\\"keccak256\\":\\"0x83adfcf6da72b1bcd1e3ac387afe5fc7fdf7f2ac28b7601544d2ca4b9d45d159\\"},\\"contracts/reverseRegistrar/ReverseClaimer.sol\\":{\\"content\\":\\"//SPDX-License-Identifier: MIT\\\\npragma solidity >=0.8.17 <0.9.0;\\\\n\\\\nimport {ENS} from \\\\\\"../registry/ENS.sol\\\\\\";\\\\nimport {IReverseRegistrar} from \\\\\\"../reverseRegistrar/IReverseRegistrar.sol\\\\\\";\\\\n\\\\ncontract ReverseClaimer {\\\\n    bytes32 constant ADDR_REVERSE_NODE =\\\\n        0x91d1777781884d03a6757a803996e38de2a42967fb37eeaca72729271025a9e2;\\\\n\\\\n    constructor(ENS ens, address claimant) {\\\\n        IReverseRegistrar reverseRegistrar = IReverseRegistrar(\\\\n            ens.owner(ADDR_REVERSE_NODE)\\\\n        );\\\\n        reverseRegistrar.claim(claimant);\\\\n    }\\\\n}\\\\n\\",\\"keccak256\\":\\"0x78a28627241535b595f6fff476a1fa7acc90c80684fe7784734920fc8af6fc22\\",\\"license\\":\\"MIT\\"},\\"contracts/utils/ERC20Recoverable.sol\\":{\\"content\\":\\"//SPDX-License-Identifier: MIT\\\\npragma solidity >=0.8.17 <0.9.0;\\\\n\\\\nimport \\\\\\"@openzeppelin/contracts/access/Ownable.sol\\\\\\";\\\\nimport \\\\\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\\\\";\\\\n\\\\n/**\\\\n    @notice Contract is used to recover ERC20 tokens sent to the contract by mistake.\\\\n */\\\\n\\\\ncontract ERC20Recoverable is Ownable {\\\\n    /**\\\\n    @notice Recover ERC20 tokens sent to the contract by mistake.\\\\n    @dev The contract is Ownable and only the owner can call the recover function.\\\\n    @param _to The address to send the tokens to.\\\\n@param _token The address of the ERC20 token to recover\\\\n    @param _amount The amount of tokens to recover.\\\\n */\\\\n    function recoverFunds(\\\\n        address _token,\\\\n        address _to,\\\\n        uint256 _amount\\\\n    ) external onlyOwner {\\\\n        IERC20(_token).transfer(_to, _amount);\\\\n    }\\\\n}\\\\n\\",\\"keccak256\\":\\"0x793a38091e1f81499a29ddba82c2b2f3cdd07071b81a832886e8e02a45ff352a\\",\\"license\\":\\"MIT\\"},\\"contracts/wrapper/BytesUtils.sol\\":{\\"content\\":\\"//SPDX-License-Identifier: MIT\\\\npragma solidity ~0.8.17;\\\\n\\\\nlibrary BytesUtils {\\\\n    /*\\\\n     * @dev Returns the keccak-256 hash of a byte range.\\\\n     * @param self The byte string to hash.\\\\n     * @param offset The position to start hashing at.\\\\n     * @param len The number of bytes to hash.\\\\n     * @return The hash of the byte range.\\\\n     */\\\\n    function keccak(\\\\n        bytes memory self,\\\\n        uint256 offset,\\\\n        uint256 len\\\\n    ) internal pure returns (bytes32 ret) {\\\\n        require(offset + len <= self.length);\\\\n        assembly {\\\\n            ret := keccak256(add(add(self, 32), offset), len)\\\\n        }\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Returns the ENS namehash of a DNS-encoded name.\\\\n     * @param self The DNS-encoded name to hash.\\\\n     * @param offset The offset at which to start hashing.\\\\n     * @return The namehash of the name.\\\\n     */\\\\n    function namehash(\\\\n        bytes memory self,\\\\n        uint256 offset\\\\n    ) internal pure returns (bytes32) {\\\\n        (bytes32 labelhash, uint256 newOffset) = readLabel(self, offset);\\\\n        if (labelhash == bytes32(0)) {\\\\n            require(offset == self.length - 1, \\\\\\"namehash: Junk at end of name\\\\\\");\\\\n            return bytes32(0);\\\\n        }\\\\n        return\\\\n            keccak256(abi.encodePacked(namehash(self, newOffset), labelhash));\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Returns the keccak-256 hash of a DNS-encoded label, and the offset to the start of the next label.\\\\n     * @param self The byte string to read a label from.\\\\n     * @param idx The index to read a label at.\\\\n     * @return labelhash The hash of the label at the specified index, or 0 if it is the last label.\\\\n     * @return newIdx The index of the start of the next label.\\\\n     */\\\\n    function readLabel(\\\\n        bytes memory self,\\\\n        uint256 idx\\\\n    ) internal pure returns (bytes32 labelhash, uint256 newIdx) {\\\\n        require(idx < self.length, \\\\\\"readLabel: Index out of bounds\\\\\\");\\\\n        uint256 len = uint256(uint8(self[idx]));\\\\n        if (len > 0) {\\\\n            labelhash = keccak(self, idx + 1, len);\\\\n        } else {\\\\n            labelhash = bytes32(0);\\\\n        }\\\\n        newIdx = idx + len + 1;\\\\n    }\\\\n}\\\\n\\",\\"keccak256\\":\\"0xf862cd86d749158a554e3cb517efa9097331ec0cf7225117f21e96fb50c67edb\\",\\"license\\":\\"MIT\\"},\\"contracts/wrapper/Controllable.sol\\":{\\"content\\":\\"//SPDX-License-Identifier: MIT\\\\npragma solidity ~0.8.17;\\\\n\\\\nimport \\\\\\"@openzeppelin/contracts/access/Ownable.sol\\\\\\";\\\\n\\\\ncontract Controllable is Ownable {\\\\n    mapping(address => bool) public controllers;\\\\n\\\\n    event ControllerChanged(address indexed controller, bool active);\\\\n\\\\n    function setController(address controller, bool active) public onlyOwner {\\\\n        controllers[controller] = active;\\\\n        emit ControllerChanged(controller, active);\\\\n    }\\\\n\\\\n    modifier onlyController() {\\\\n        require(\\\\n            controllers[msg.sender],\\\\n            \\\\\\"Controllable: Caller is not a controller\\\\\\"\\\\n        );\\\\n        _;\\\\n    }\\\\n}\\\\n\\",\\"keccak256\\":\\"0x9a9191656a82eda6763cda29ce893ddbfddb6c43559ff3b90c00a184e14e1fa1\\",\\"license\\":\\"MIT\\"},\\"contracts/wrapper/ERC1155Fuse.sol\\":{\\"content\\":\\"//SPDX-License-Identifier: MIT\\\\npragma solidity ~0.8.17;\\\\n\\\\nimport \\\\\\"@openzeppelin/contracts/utils/introspection/ERC165.sol\\\\\\";\\\\nimport \\\\\\"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\\\\\\";\\\\nimport \\\\\\"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\\\\\\";\\\\nimport \\\\\\"@openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol\\\\\\";\\\\nimport \\\\\\"@openzeppelin/contracts/utils/Address.sol\\\\\\";\\\\n\\\\n/* This contract is a variation on ERC1155 with the additions of _setData, getData and _beforeTransfer and ownerOf. _setData and getData allows the use of the other 96 bits next to the address of the owner for extra data. We use this to store \'fuses\' that control permissions that can be burnt. 32 bits are used for the fuses themselves and 64 bits are used for the expiry of the name. When a name has expired, its fuses will be be set back to 0 */\\\\n\\\\nabstract contract ERC1155Fuse is ERC165, IERC1155, IERC1155MetadataURI {\\\\n    using Address for address;\\\\n    /**\\\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\\\n     */\\\\n    event Approval(\\\\n        address indexed owner,\\\\n        address indexed approved,\\\\n        uint256 indexed tokenId\\\\n    );\\\\n    mapping(uint256 => uint256) public _tokens;\\\\n\\\\n    // Mapping from owner to operator approvals\\\\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\\\\n    // Mapping from token ID to approved address\\\\n    mapping(uint256 => address) internal _tokenApprovals;\\\\n\\\\n    /**************************************************************************\\\\n     * ERC721 methods\\\\n     *************************************************************************/\\\\n\\\\n    function ownerOf(uint256 id) public view virtual returns (address) {\\\\n        (address owner, , ) = getData(id);\\\\n        return owner;\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev See {IERC721-approve}.\\\\n     */\\\\n    function approve(address to, uint256 tokenId) public virtual {\\\\n        address owner = ownerOf(tokenId);\\\\n        require(to != owner, \\\\\\"ERC721: approval to current owner\\\\\\");\\\\n\\\\n        require(\\\\n            msg.sender == owner || isApprovedForAll(owner, msg.sender),\\\\n            \\\\\\"ERC721: approve caller is not token owner or approved for all\\\\\\"\\\\n        );\\\\n\\\\n        _approve(to, tokenId);\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev See {IERC721-getApproved}.\\\\n     */\\\\n    function getApproved(\\\\n        uint256 tokenId\\\\n    ) public view virtual returns (address) {\\\\n        return _tokenApprovals[tokenId];\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev See {IERC165-supportsInterface}.\\\\n     */\\\\n    function supportsInterface(\\\\n        bytes4 interfaceId\\\\n    ) public view virtual override(ERC165, IERC165) returns (bool) {\\\\n        return\\\\n            interfaceId == type(IERC1155).interfaceId ||\\\\n            interfaceId == type(IERC1155MetadataURI).interfaceId ||\\\\n            super.supportsInterface(interfaceId);\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev See {IERC1155-balanceOf}.\\\\n     *\\\\n     * Requirements:\\\\n     *\\\\n     * - `account` cannot be the zero address.\\\\n     */\\\\n    function balanceOf(\\\\n        address account,\\\\n        uint256 id\\\\n    ) public view virtual override returns (uint256) {\\\\n        require(\\\\n            account != address(0),\\\\n            \\\\\\"ERC1155: balance query for the zero address\\\\\\"\\\\n        );\\\\n        address owner = ownerOf(id);\\\\n        if (owner == account) {\\\\n            return 1;\\\\n        }\\\\n        return 0;\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev See {IERC1155-balanceOfBatch}.\\\\n     *\\\\n     * Requirements:\\\\n     *\\\\n     * - `accounts` and `ids` must have the same length.\\\\n     */\\\\n    function balanceOfBatch(\\\\n        address[] memory accounts,\\\\n        uint256[] memory ids\\\\n    ) public view virtual override returns (uint256[] memory) {\\\\n        require(\\\\n            accounts.length == ids.length,\\\\n            \\\\\\"ERC1155: accounts and ids length mismatch\\\\\\"\\\\n        );\\\\n\\\\n        uint256[] memory batchBalances = new uint256[](accounts.length);\\\\n\\\\n        for (uint256 i = 0; i < accounts.length; ++i) {\\\\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\\\\n        }\\\\n\\\\n        return batchBalances;\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev See {IERC1155-setApprovalForAll}.\\\\n     */\\\\n    function setApprovalForAll(\\\\n        address operator,\\\\n        bool approved\\\\n    ) public virtual override {\\\\n        require(\\\\n            msg.sender != operator,\\\\n            \\\\\\"ERC1155: setting approval status for self\\\\\\"\\\\n        );\\\\n\\\\n        _operatorApprovals[msg.sender][operator] = approved;\\\\n        emit ApprovalForAll(msg.sender, operator, approved);\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev See {IERC1155-isApprovedForAll}.\\\\n     */\\\\n    function isApprovedForAll(\\\\n        address account,\\\\n        address operator\\\\n    ) public view virtual override returns (bool) {\\\\n        return _operatorApprovals[account][operator];\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Returns the Name\'s owner address and fuses\\\\n     */\\\\n    function getData(\\\\n        uint256 tokenId\\\\n    ) public view virtual returns (address owner, uint32 fuses, uint64 expiry) {\\\\n        uint256 t = _tokens[tokenId];\\\\n        owner = address(uint160(t));\\\\n        expiry = uint64(t >> 192);\\\\n        fuses = uint32(t >> 160);\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev See {IERC1155-safeTransferFrom}.\\\\n     */\\\\n    function safeTransferFrom(\\\\n        address from,\\\\n        address to,\\\\n        uint256 id,\\\\n        uint256 amount,\\\\n        bytes memory data\\\\n    ) public virtual override {\\\\n        require(to != address(0), \\\\\\"ERC1155: transfer to the zero address\\\\\\");\\\\n        require(\\\\n            from == msg.sender || isApprovedForAll(from, msg.sender),\\\\n            \\\\\\"ERC1155: caller is not owner nor approved\\\\\\"\\\\n        );\\\\n\\\\n        _transfer(from, to, id, amount, data);\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev See {IERC1155-safeBatchTransferFrom}.\\\\n     */\\\\n    function safeBatchTransferFrom(\\\\n        address from,\\\\n        address to,\\\\n        uint256[] memory ids,\\\\n        uint256[] memory amounts,\\\\n        bytes memory data\\\\n    ) public virtual override {\\\\n        require(\\\\n            ids.length == amounts.length,\\\\n            \\\\\\"ERC1155: ids and amounts length mismatch\\\\\\"\\\\n        );\\\\n        require(to != address(0), \\\\\\"ERC1155: transfer to the zero address\\\\\\");\\\\n        require(\\\\n            from == msg.sender || isApprovedForAll(from, msg.sender),\\\\n            \\\\\\"ERC1155: transfer caller is not owner nor approved\\\\\\"\\\\n        );\\\\n\\\\n        for (uint256 i = 0; i < ids.length; ++i) {\\\\n            uint256 id = ids[i];\\\\n            uint256 amount = amounts[i];\\\\n\\\\n            (address oldOwner, uint32 fuses, uint64 expiry) = getData(id);\\\\n\\\\n            _beforeTransfer(id, fuses, expiry);\\\\n\\\\n            require(\\\\n                amount == 1 && oldOwner == from,\\\\n                \\\\\\"ERC1155: insufficient balance for transfer\\\\\\"\\\\n            );\\\\n            _setData(id, to, fuses, expiry);\\\\n        }\\\\n\\\\n        emit TransferBatch(msg.sender, from, to, ids, amounts);\\\\n\\\\n        _doSafeBatchTransferAcceptanceCheck(\\\\n            msg.sender,\\\\n            from,\\\\n            to,\\\\n            ids,\\\\n            amounts,\\\\n            data\\\\n        );\\\\n    }\\\\n\\\\n    /**************************************************************************\\\\n     * Internal/private methods\\\\n     *************************************************************************/\\\\n\\\\n    /**\\\\n     * @dev Sets the Name\'s owner address and fuses\\\\n     */\\\\n    function _setData(\\\\n        uint256 tokenId,\\\\n        address owner,\\\\n        uint32 fuses,\\\\n        uint64 expiry\\\\n    ) internal virtual {\\\\n        _tokens[tokenId] =\\\\n            uint256(uint160(owner)) |\\\\n            (uint256(fuses) << 160) |\\\\n            (uint256(expiry) << 192);\\\\n    }\\\\n\\\\n    function _beforeTransfer(\\\\n        uint256 id,\\\\n        uint32 fuses,\\\\n        uint64 expiry\\\\n    ) internal virtual;\\\\n\\\\n    function _clearOwnerAndFuses(\\\\n        address owner,\\\\n        uint32 fuses,\\\\n        uint64 expiry\\\\n    ) internal virtual returns (address, uint32);\\\\n\\\\n    function _mint(\\\\n        bytes32 node,\\\\n        address owner,\\\\n        uint32 fuses,\\\\n        uint64 expiry\\\\n    ) internal virtual {\\\\n        uint256 tokenId = uint256(node);\\\\n        (address oldOwner, uint32 oldFuses, uint64 oldExpiry) = getData(\\\\n            uint256(node)\\\\n        );\\\\n\\\\n        uint32 parentControlledFuses = (uint32(type(uint16).max) << 16) &\\\\n            oldFuses;\\\\n\\\\n        if (oldExpiry > expiry) {\\\\n            expiry = oldExpiry;\\\\n        }\\\\n\\\\n        if (oldExpiry >= block.timestamp) {\\\\n            fuses = fuses | parentControlledFuses;\\\\n        }\\\\n\\\\n        require(oldOwner == address(0), \\\\\\"ERC1155: mint of existing token\\\\\\");\\\\n        require(owner != address(0), \\\\\\"ERC1155: mint to the zero address\\\\\\");\\\\n        require(\\\\n            owner != address(this),\\\\n            \\\\\\"ERC1155: newOwner cannot be the NameWrapper contract\\\\\\"\\\\n        );\\\\n\\\\n        _setData(tokenId, owner, fuses, expiry);\\\\n        emit TransferSingle(msg.sender, address(0x0), owner, tokenId, 1);\\\\n        _doSafeTransferAcceptanceCheck(\\\\n            msg.sender,\\\\n            address(0),\\\\n            owner,\\\\n            tokenId,\\\\n            1,\\\\n            \\\\\\"\\\\\\"\\\\n        );\\\\n    }\\\\n\\\\n    function _burn(uint256 tokenId) internal virtual {\\\\n        (address oldOwner, uint32 fuses, uint64 expiry) = ERC1155Fuse.getData(\\\\n            tokenId\\\\n        );\\\\n        (, fuses) = _clearOwnerAndFuses(oldOwner, fuses, expiry);\\\\n        // Clear approvals\\\\n        delete _tokenApprovals[tokenId];\\\\n        // Fuses and expiry are kept on burn\\\\n        _setData(tokenId, address(0x0), fuses, expiry);\\\\n        emit TransferSingle(msg.sender, oldOwner, address(0x0), tokenId, 1);\\\\n    }\\\\n\\\\n    function _transfer(\\\\n        address from,\\\\n        address to,\\\\n        uint256 id,\\\\n        uint256 amount,\\\\n        bytes memory data\\\\n    ) internal {\\\\n        (address oldOwner, uint32 fuses, uint64 expiry) = getData(id);\\\\n\\\\n        _beforeTransfer(id, fuses, expiry);\\\\n\\\\n        require(\\\\n            amount == 1 && oldOwner == from,\\\\n            \\\\\\"ERC1155: insufficient balance for transfer\\\\\\"\\\\n        );\\\\n\\\\n        if (oldOwner == to) {\\\\n            return;\\\\n        }\\\\n\\\\n        _setData(id, to, fuses, expiry);\\\\n\\\\n        emit TransferSingle(msg.sender, from, to, id, amount);\\\\n\\\\n        _doSafeTransferAcceptanceCheck(msg.sender, from, to, id, amount, data);\\\\n    }\\\\n\\\\n    function _doSafeTransferAcceptanceCheck(\\\\n        address operator,\\\\n        address from,\\\\n        address to,\\\\n        uint256 id,\\\\n        uint256 amount,\\\\n        bytes memory data\\\\n    ) private {\\\\n        if (to.isContract()) {\\\\n            try\\\\n                IERC1155Receiver(to).onERC1155Received(\\\\n                    operator,\\\\n                    from,\\\\n                    id,\\\\n                    amount,\\\\n                    data\\\\n                )\\\\n            returns (bytes4 response) {\\\\n                if (\\\\n                    response != IERC1155Receiver(to).onERC1155Received.selector\\\\n                ) {\\\\n                    revert(\\\\\\"ERC1155: ERC1155Receiver rejected tokens\\\\\\");\\\\n                }\\\\n            } catch Error(string memory reason) {\\\\n                revert(reason);\\\\n            } catch {\\\\n                revert(\\\\\\"ERC1155: transfer to non ERC1155Receiver implementer\\\\\\");\\\\n            }\\\\n        }\\\\n    }\\\\n\\\\n    function _doSafeBatchTransferAcceptanceCheck(\\\\n        address operator,\\\\n        address from,\\\\n        address to,\\\\n        uint256[] memory ids,\\\\n        uint256[] memory amounts,\\\\n        bytes memory data\\\\n    ) private {\\\\n        if (to.isContract()) {\\\\n            try\\\\n                IERC1155Receiver(to).onERC1155BatchReceived(\\\\n                    operator,\\\\n                    from,\\\\n                    ids,\\\\n                    amounts,\\\\n                    data\\\\n                )\\\\n            returns (bytes4 response) {\\\\n                if (\\\\n                    response !=\\\\n                    IERC1155Receiver(to).onERC1155BatchReceived.selector\\\\n                ) {\\\\n                    revert(\\\\\\"ERC1155: ERC1155Receiver rejected tokens\\\\\\");\\\\n                }\\\\n            } catch Error(string memory reason) {\\\\n                revert(reason);\\\\n            } catch {\\\\n                revert(\\\\\\"ERC1155: transfer to non ERC1155Receiver implementer\\\\\\");\\\\n            }\\\\n        }\\\\n    }\\\\n\\\\n    /* ERC721 internal functions */\\\\n\\\\n    /**\\\\n     * @dev Approve `to` to operate on `tokenId`\\\\n     *\\\\n     * Emits an {Approval} event.\\\\n     */\\\\n    function _approve(address to, uint256 tokenId) internal virtual {\\\\n        _tokenApprovals[tokenId] = to;\\\\n        emit Approval(ownerOf(tokenId), to, tokenId);\\\\n    }\\\\n}\\\\n\\",\\"keccak256\\":\\"0xfbbd36e7f5df0fe7a8e9199783af99ac61ab24122e4a9fdb072bbd4cd676a88b\\",\\"license\\":\\"MIT\\"},\\"contracts/wrapper/IMetadataService.sol\\":{\\"content\\":\\"//SPDX-License-Identifier: MIT\\\\npragma solidity ~0.8.17;\\\\n\\\\ninterface IMetadataService {\\\\n    function uri(uint256) external view returns (string memory);\\\\n}\\\\n\\",\\"keccak256\\":\\"0xb3f1cf6df01ed7b15e5f2318f6823afbdb586ca38c2124c67955c645647ae9a2\\",\\"license\\":\\"MIT\\"},\\"contracts/wrapper/INameWrapper.sol\\":{\\"content\\":\\"//SPDX-License-Identifier: MIT\\\\npragma solidity ~0.8.17;\\\\n\\\\nimport \\\\\\"../registry/ENS.sol\\\\\\";\\\\nimport \\\\\\"../ethregistrar/IBaseRegistrar.sol\\\\\\";\\\\nimport \\\\\\"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\\\\\\";\\\\nimport \\\\\\"./IMetadataService.sol\\\\\\";\\\\nimport \\\\\\"./INameWrapperUpgrade.sol\\\\\\";\\\\n\\\\nuint32 constant CANNOT_UNWRAP = 1;\\\\nuint32 constant CANNOT_BURN_FUSES = 2;\\\\nuint32 constant CANNOT_TRANSFER = 4;\\\\nuint32 constant CANNOT_SET_RESOLVER = 8;\\\\nuint32 constant CANNOT_SET_TTL = 16;\\\\nuint32 constant CANNOT_CREATE_SUBDOMAIN = 32;\\\\nuint32 constant CANNOT_APPROVE = 64;\\\\n//uint16 reserved for parent controlled fuses from bit 17 to bit 32\\\\nuint32 constant PARENT_CANNOT_CONTROL = 1 << 16;\\\\nuint32 constant IS_DOT_ETH = 1 << 17;\\\\nuint32 constant CAN_EXTEND_EXPIRY = 1 << 18;\\\\nuint32 constant CAN_DO_EVERYTHING = 0;\\\\nuint32 constant PARENT_CONTROLLED_FUSES = 0xFFFF0000;\\\\n// all fuses apart from IS_DOT_ETH\\\\nuint32 constant USER_SETTABLE_FUSES = 0xFFFDFFFF;\\\\n\\\\ninterface INameWrapper is IERC1155 {\\\\n    event NameWrapped(\\\\n        bytes32 indexed node,\\\\n        bytes name,\\\\n        address owner,\\\\n        uint32 fuses,\\\\n        uint64 expiry\\\\n    );\\\\n\\\\n    event NameUnwrapped(bytes32 indexed node, address owner);\\\\n\\\\n    event FusesSet(bytes32 indexed node, uint32 fuses);\\\\n    event ExpiryExtended(bytes32 indexed node, uint64 expiry);\\\\n\\\\n    function ens() external view returns (ENS);\\\\n\\\\n    function registrar() external view returns (IBaseRegistrar);\\\\n\\\\n    function metadataService() external view returns (IMetadataService);\\\\n\\\\n    function names(bytes32) external view returns (bytes memory);\\\\n\\\\n    function name() external view returns (string memory);\\\\n\\\\n    function upgradeContract() external view returns (INameWrapperUpgrade);\\\\n\\\\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\\\\n\\\\n    function wrap(\\\\n        bytes calldata name,\\\\n        address wrappedOwner,\\\\n        address resolver\\\\n    ) external;\\\\n\\\\n    function wrapETH2LD(\\\\n        string calldata label,\\\\n        address wrappedOwner,\\\\n        uint16 ownerControlledFuses,\\\\n        address resolver\\\\n    ) external returns (uint64 expires);\\\\n\\\\n    function registerAndWrapETH2LD(\\\\n        string calldata label,\\\\n        address wrappedOwner,\\\\n        uint256 duration,\\\\n        address resolver,\\\\n        uint16 ownerControlledFuses\\\\n    ) external returns (uint256 registrarExpiry);\\\\n\\\\n    function renew(\\\\n        uint256 labelHash,\\\\n        uint256 duration\\\\n    ) external returns (uint256 expires);\\\\n\\\\n    function unwrap(bytes32 node, bytes32 label, address owner) external;\\\\n\\\\n    function unwrapETH2LD(\\\\n        bytes32 label,\\\\n        address newRegistrant,\\\\n        address newController\\\\n    ) external;\\\\n\\\\n    function upgrade(bytes calldata name, bytes calldata extraData) external;\\\\n\\\\n    function setFuses(\\\\n        bytes32 node,\\\\n        uint16 ownerControlledFuses\\\\n    ) external returns (uint32 newFuses);\\\\n\\\\n    function setChildFuses(\\\\n        bytes32 parentNode,\\\\n        bytes32 labelhash,\\\\n        uint32 fuses,\\\\n        uint64 expiry\\\\n    ) external;\\\\n\\\\n    function setSubnodeRecord(\\\\n        bytes32 node,\\\\n        string calldata label,\\\\n        address owner,\\\\n        address resolver,\\\\n        uint64 ttl,\\\\n        uint32 fuses,\\\\n        uint64 expiry\\\\n    ) external returns (bytes32);\\\\n\\\\n    function setRecord(\\\\n        bytes32 node,\\\\n        address owner,\\\\n        address resolver,\\\\n        uint64 ttl\\\\n    ) external;\\\\n\\\\n    function setSubnodeOwner(\\\\n        bytes32 node,\\\\n        string calldata label,\\\\n        address newOwner,\\\\n        uint32 fuses,\\\\n        uint64 expiry\\\\n    ) external returns (bytes32);\\\\n\\\\n    function extendExpiry(\\\\n        bytes32 node,\\\\n        bytes32 labelhash,\\\\n        uint64 expiry\\\\n    ) external returns (uint64);\\\\n\\\\n    function canModifyName(\\\\n        bytes32 node,\\\\n        address addr\\\\n    ) external view returns (bool);\\\\n\\\\n    function setResolver(bytes32 node, address resolver) external;\\\\n\\\\n    function setTTL(bytes32 node, uint64 ttl) external;\\\\n\\\\n    function ownerOf(uint256 id) external view returns (address owner);\\\\n\\\\n    function approve(address to, uint256 tokenId) external;\\\\n\\\\n    function getApproved(uint256 tokenId) external view returns (address);\\\\n\\\\n    function getData(\\\\n        uint256 id\\\\n    ) external view returns (address, uint32, uint64);\\\\n\\\\n    function setMetadataService(IMetadataService _metadataService) external;\\\\n\\\\n    function uri(uint256 tokenId) external view returns (string memory);\\\\n\\\\n    function setUpgradeContract(INameWrapperUpgrade _upgradeAddress) external;\\\\n\\\\n    function allFusesBurned(\\\\n        bytes32 node,\\\\n        uint32 fuseMask\\\\n    ) external view returns (bool);\\\\n\\\\n    function isWrapped(bytes32) external view returns (bool);\\\\n\\\\n    function isWrapped(bytes32, bytes32) external view returns (bool);\\\\n}\\\\n\\",\\"keccak256\\":\\"0x70310eb67146d7290731c31841399640ac3b6a949eadc6598bc150123d185c57\\",\\"license\\":\\"MIT\\"},\\"contracts/wrapper/INameWrapperUpgrade.sol\\":{\\"content\\":\\"//SPDX-License-Identifier: MIT\\\\npragma solidity ~0.8.17;\\\\n\\\\ninterface INameWrapperUpgrade {\\\\n    function wrapFromUpgrade(\\\\n        bytes calldata name,\\\\n        address wrappedOwner,\\\\n        uint32 fuses,\\\\n        uint64 expiry,\\\\n        address approved,\\\\n        bytes calldata extraData\\\\n    ) external;\\\\n}\\\\n\\",\\"keccak256\\":\\"0x42e0cec6cd9d1a62d51d45b678f69d3e4ad5555e659b197e41257b308346bb8a\\",\\"license\\":\\"MIT\\"},\\"contracts/wrapper/NameWrapper.sol\\":{\\"content\\":\\"//SPDX-License-Identifier: MIT\\\\npragma solidity ~0.8.17;\\\\n\\\\nimport {ERC1155Fuse, IERC165, IERC1155MetadataURI} from \\\\\\"./ERC1155Fuse.sol\\\\\\";\\\\nimport {Controllable} from \\\\\\"./Controllable.sol\\\\\\";\\\\nimport {INameWrapper, CANNOT_UNWRAP, CANNOT_BURN_FUSES, CANNOT_TRANSFER, CANNOT_SET_RESOLVER, CANNOT_SET_TTL, CANNOT_CREATE_SUBDOMAIN, CANNOT_APPROVE, PARENT_CANNOT_CONTROL, CAN_DO_EVERYTHING, IS_DOT_ETH, CAN_EXTEND_EXPIRY, PARENT_CONTROLLED_FUSES, USER_SETTABLE_FUSES} from \\\\\\"./INameWrapper.sol\\\\\\";\\\\nimport {INameWrapperUpgrade} from \\\\\\"./INameWrapperUpgrade.sol\\\\\\";\\\\nimport {IMetadataService} from \\\\\\"./IMetadataService.sol\\\\\\";\\\\nimport {ENS} from \\\\\\"../registry/ENS.sol\\\\\\";\\\\nimport {IReverseRegistrar} from \\\\\\"../reverseRegistrar/IReverseRegistrar.sol\\\\\\";\\\\nimport {ReverseClaimer} from \\\\\\"../reverseRegistrar/ReverseClaimer.sol\\\\\\";\\\\nimport {IBaseRegistrar} from \\\\\\"../ethregistrar/IBaseRegistrar.sol\\\\\\";\\\\nimport {IERC721Receiver} from \\\\\\"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\\\\\\";\\\\nimport \\\\\\"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\\\\\\";\\\\nimport {Ownable} from \\\\\\"@openzeppelin/contracts/access/Ownable.sol\\\\\\";\\\\nimport {BytesUtils} from \\\\\\"./BytesUtils.sol\\\\\\";\\\\nimport {ERC20Recoverable} from \\\\\\"../utils/ERC20Recoverable.sol\\\\\\";\\\\n\\\\nerror Unauthorised(bytes32 node, address addr);\\\\nerror IncompatibleParent();\\\\nerror IncorrectTokenType();\\\\nerror LabelMismatch(bytes32 labelHash, bytes32 expectedLabelhash);\\\\nerror LabelTooShort();\\\\nerror LabelTooLong(string label);\\\\nerror IncorrectTargetOwner(address owner);\\\\nerror CannotUpgrade();\\\\nerror OperationProhibited(bytes32 node);\\\\nerror NameIsNotWrapped();\\\\nerror NameIsStillExpired();\\\\n\\\\ncontract NameWrapper is\\\\n    Ownable,\\\\n    ERC1155Fuse,\\\\n    INameWrapper,\\\\n    Controllable,\\\\n    IERC721Receiver,\\\\n    ERC20Recoverable,\\\\n    ReverseClaimer\\\\n{\\\\n    using BytesUtils for bytes;\\\\n\\\\n    ENS public immutable ens;\\\\n    IBaseRegistrar public immutable registrar;\\\\n    IMetadataService public metadataService;\\\\n    mapping(bytes32 => bytes) public names;\\\\n    string public constant name = \\\\\\"NameWrapper\\\\\\";\\\\n\\\\n    uint64 private constant GRACE_PERIOD = 90 days;\\\\n    bytes32 private constant ETH_NODE =\\\\n        0x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae;\\\\n    bytes32 private constant ETH_LABELHASH =\\\\n        0x4f5b812789fc606be1b3b16908db13fc7a9adf7ca72641f84d75b47069d3d7f0;\\\\n    bytes32 private constant ROOT_NODE =\\\\n        0x0000000000000000000000000000000000000000000000000000000000000000;\\\\n\\\\n    INameWrapperUpgrade public upgradeContract;\\\\n    uint64 private constant MAX_EXPIRY = type(uint64).max;\\\\n\\\\n    constructor(\\\\n        ENS _ens,\\\\n        IBaseRegistrar _registrar,\\\\n        IMetadataService _metadataService\\\\n    ) ReverseClaimer(_ens, msg.sender) {\\\\n        ens = _ens;\\\\n        registrar = _registrar;\\\\n        metadataService = _metadataService;\\\\n\\\\n        /* Burn PARENT_CANNOT_CONTROL and CANNOT_UNWRAP fuses for ROOT_NODE and ETH_NODE and set expiry to max */\\\\n\\\\n        _setData(\\\\n            uint256(ETH_NODE),\\\\n            address(0),\\\\n            uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),\\\\n            MAX_EXPIRY\\\\n        );\\\\n        _setData(\\\\n            uint256(ROOT_NODE),\\\\n            address(0),\\\\n            uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),\\\\n            MAX_EXPIRY\\\\n        );\\\\n        names[ROOT_NODE] = \\\\\\"\\\\\\\\x00\\\\\\";\\\\n        names[ETH_NODE] = \\\\\\"\\\\\\\\x03eth\\\\\\\\x00\\\\\\";\\\\n    }\\\\n\\\\n    function supportsInterface(\\\\n        bytes4 interfaceId\\\\n    ) public view virtual override(ERC1155Fuse, INameWrapper) returns (bool) {\\\\n        return\\\\n            interfaceId == type(INameWrapper).interfaceId ||\\\\n            interfaceId == type(IERC721Receiver).interfaceId ||\\\\n            super.supportsInterface(interfaceId);\\\\n    }\\\\n\\\\n    /* ERC1155 Fuse */\\\\n\\\\n    /**\\\\n     * @notice Gets the owner of a name\\\\n     * @param id Label as a string of the .eth domain to wrap\\\\n     * @return owner The owner of the name\\\\n     */\\\\n\\\\n    function ownerOf(\\\\n        uint256 id\\\\n    ) public view override(ERC1155Fuse, INameWrapper) returns (address owner) {\\\\n        return super.ownerOf(id);\\\\n    }\\\\n\\\\n    /**\\\\n     * @notice Gets the owner of a name\\\\n     * @param id Namehash of the name\\\\n     * @return operator Approved operator of a name\\\\n     */\\\\n\\\\n    function getApproved(\\\\n        uint256 id\\\\n    )\\\\n        public\\\\n        view\\\\n        override(ERC1155Fuse, INameWrapper)\\\\n        returns (address operator)\\\\n    {\\\\n        address owner = ownerOf(id);\\\\n        if (owner == address(0)) {\\\\n            return address(0);\\\\n        }\\\\n        return super.getApproved(id);\\\\n    }\\\\n\\\\n    /**\\\\n     * @notice Approves an address for a name\\\\n     * @param to address to approve\\\\n     * @param tokenId name to approve\\\\n     */\\\\n\\\\n    function approve(\\\\n        address to,\\\\n        uint256 tokenId\\\\n    ) public override(ERC1155Fuse, INameWrapper) {\\\\n        (, uint32 fuses, ) = getData(tokenId);\\\\n        if (fuses & CANNOT_APPROVE == CANNOT_APPROVE) {\\\\n            revert OperationProhibited(bytes32(tokenId));\\\\n        }\\\\n        super.approve(to, tokenId);\\\\n    }\\\\n\\\\n    /**\\\\n     * @notice Gets the data for a name\\\\n     * @param id Namehash of the name\\\\n     * @return owner Owner of the name\\\\n     * @return fuses Fuses of the name\\\\n     * @return expiry Expiry of the name\\\\n     */\\\\n\\\\n    function getData(\\\\n        uint256 id\\\\n    )\\\\n        public\\\\n        view\\\\n        override(ERC1155Fuse, INameWrapper)\\\\n        returns (address owner, uint32 fuses, uint64 expiry)\\\\n    {\\\\n        (owner, fuses, expiry) = super.getData(id);\\\\n\\\\n        (owner, fuses) = _clearOwnerAndFuses(owner, fuses, expiry);\\\\n    }\\\\n\\\\n    /* Metadata service */\\\\n\\\\n    /**\\\\n     * @notice Set the metadata service. Only the owner can do this\\\\n     * @param _metadataService The new metadata service\\\\n     */\\\\n\\\\n    function setMetadataService(\\\\n        IMetadataService _metadataService\\\\n    ) public onlyOwner {\\\\n        metadataService = _metadataService;\\\\n    }\\\\n\\\\n    /**\\\\n     * @notice Get the metadata uri\\\\n     * @param tokenId The id of the token\\\\n     * @return string uri of the metadata service\\\\n     */\\\\n\\\\n    function uri(\\\\n        uint256 tokenId\\\\n    )\\\\n        public\\\\n        view\\\\n        override(INameWrapper, IERC1155MetadataURI)\\\\n        returns (string memory)\\\\n    {\\\\n        return metadataService.uri(tokenId);\\\\n    }\\\\n\\\\n    /**\\\\n     * @notice Set the address of the upgradeContract of the contract. only admin can do this\\\\n     * @dev The default value of upgradeContract is the 0 address. Use the 0 address at any time\\\\n     * to make the contract not upgradable.\\\\n     * @param _upgradeAddress address of an upgraded contract\\\\n     */\\\\n\\\\n    function setUpgradeContract(\\\\n        INameWrapperUpgrade _upgradeAddress\\\\n    ) public onlyOwner {\\\\n        if (address(upgradeContract) != address(0)) {\\\\n            registrar.setApprovalForAll(address(upgradeContract), false);\\\\n            ens.setApprovalForAll(address(upgradeContract), false);\\\\n        }\\\\n\\\\n        upgradeContract = _upgradeAddress;\\\\n\\\\n        if (address(upgradeContract) != address(0)) {\\\\n            registrar.setApprovalForAll(address(upgradeContract), true);\\\\n            ens.setApprovalForAll(address(upgradeContract), true);\\\\n        }\\\\n    }\\\\n\\\\n    /**\\\\n     * @notice Checks if msg.sender is the owner or operator of the owner of a name\\\\n     * @param node namehash of the name to check\\\\n     */\\\\n\\\\n    modifier onlyTokenOwner(bytes32 node) {\\\\n        if (!canModifyName(node, msg.sender)) {\\\\n            revert Unauthorised(node, msg.sender);\\\\n        }\\\\n\\\\n        _;\\\\n    }\\\\n\\\\n    /**\\\\n     * @notice Checks if owner or operator of the owner\\\\n     * @param node namehash of the name to check\\\\n     * @param addr which address to check permissions for\\\\n     * @return whether or not is owner or operator\\\\n     */\\\\n\\\\n    function canModifyName(\\\\n        bytes32 node,\\\\n        address addr\\\\n    ) public view returns (bool) {\\\\n        (address owner, uint32 fuses, uint64 expiry) = getData(uint256(node));\\\\n        return\\\\n            (owner == addr || isApprovedForAll(owner, addr)) &&\\\\n            !_isETH2LDInGracePeriod(fuses, expiry);\\\\n    }\\\\n\\\\n    /**\\\\n     * @notice Checks if owner/operator or approved by owner\\\\n     * @param node namehash of the name to check\\\\n     * @param addr which address to check permissions for\\\\n     * @return whether or not is owner/operator or approved\\\\n     */\\\\n\\\\n    function canExtendSubnames(\\\\n        bytes32 node,\\\\n        address addr\\\\n    ) public view returns (bool) {\\\\n        (address owner, uint32 fuses, uint64 expiry) = getData(uint256(node));\\\\n        return\\\\n            (owner == addr ||\\\\n                isApprovedForAll(owner, addr) ||\\\\n                getApproved(uint256(node)) == addr) &&\\\\n            !_isETH2LDInGracePeriod(fuses, expiry);\\\\n    }\\\\n\\\\n    /**\\\\n     * @notice Wraps a .eth domain, creating a new token and sending the original ERC721 token to this contract\\\\n     * @dev Can be called by the owner of the name on the .eth registrar or an authorised caller on the registrar\\\\n     * @param label Label as a string of the .eth domain to wrap\\\\n     * @param wrappedOwner Owner of the name in this contract\\\\n     * @param ownerControlledFuses Initial owner-controlled fuses to set\\\\n     * @param resolver Resolver contract address\\\\n     */\\\\n\\\\n    function wrapETH2LD(\\\\n        string calldata label,\\\\n        address wrappedOwner,\\\\n        uint16 ownerControlledFuses,\\\\n        address resolver\\\\n    ) public returns (uint64 expiry) {\\\\n        uint256 tokenId = uint256(keccak256(bytes(label)));\\\\n        address registrant = registrar.ownerOf(tokenId);\\\\n        if (\\\\n            registrant != msg.sender &&\\\\n            !registrar.isApprovedForAll(registrant, msg.sender)\\\\n        ) {\\\\n            revert Unauthorised(\\\\n                _makeNode(ETH_NODE, bytes32(tokenId)),\\\\n                msg.sender\\\\n            );\\\\n        }\\\\n\\\\n        // transfer the token from the user to this contract\\\\n        registrar.transferFrom(registrant, address(this), tokenId);\\\\n\\\\n        // transfer the ens record back to the new owner (this contract)\\\\n        registrar.reclaim(tokenId, address(this));\\\\n\\\\n        expiry = uint64(registrar.nameExpires(tokenId)) + GRACE_PERIOD;\\\\n\\\\n        _wrapETH2LD(\\\\n            label,\\\\n            wrappedOwner,\\\\n            ownerControlledFuses,\\\\n            expiry,\\\\n            resolver\\\\n        );\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Registers a new .eth second-level domain and wraps it.\\\\n     *      Only callable by authorised controllers.\\\\n     * @param label The label to register (Eg, \'foo\' for \'foo.eth\').\\\\n     * @param wrappedOwner The owner of the wrapped name.\\\\n     * @param duration The duration, in seconds, to register the name for.\\\\n     * @param resolver The resolver address to set on the ENS registry (optional).\\\\n     * @param ownerControlledFuses Initial owner-controlled fuses to set\\\\n     * @return registrarExpiry The expiry date of the new name on the .eth registrar, in seconds since the Unix epoch.\\\\n     */\\\\n\\\\n    function registerAndWrapETH2LD(\\\\n        string calldata label,\\\\n        address wrappedOwner,\\\\n        uint256 duration,\\\\n        address resolver,\\\\n        uint16 ownerControlledFuses\\\\n    ) external onlyController returns (uint256 registrarExpiry) {\\\\n        uint256 tokenId = uint256(keccak256(bytes(label)));\\\\n        registrarExpiry = registrar.register(tokenId, address(this), duration);\\\\n        _wrapETH2LD(\\\\n            label,\\\\n            wrappedOwner,\\\\n            ownerControlledFuses,\\\\n            uint64(registrarExpiry) + GRACE_PERIOD,\\\\n            resolver\\\\n        );\\\\n    }\\\\n\\\\n    /**\\\\n     * @notice Renews a .eth second-level domain.\\\\n     * @dev Only callable by authorised controllers.\\\\n     * @param tokenId The hash of the label to register (eg, `keccak256(\'foo\')`, for \'foo.eth\').\\\\n     * @param duration The number of seconds to renew the name for.\\\\n     * @return expires The expiry date of the name on the .eth registrar, in seconds since the Unix epoch.\\\\n     */\\\\n\\\\n    function renew(\\\\n        uint256 tokenId,\\\\n        uint256 duration\\\\n    ) external onlyController returns (uint256 expires) {\\\\n        bytes32 node = _makeNode(ETH_NODE, bytes32(tokenId));\\\\n\\\\n        uint256 registrarExpiry = registrar.renew(tokenId, duration);\\\\n\\\\n        // Do not set anything in wrapper if name is not wrapped\\\\n        try registrar.ownerOf(tokenId) returns (address registrarOwner) {\\\\n            if (\\\\n                registrarOwner != address(this) ||\\\\n                ens.owner(node) != address(this)\\\\n            ) {\\\\n                return registrarExpiry;\\\\n            }\\\\n        } catch {\\\\n            return registrarExpiry;\\\\n        }\\\\n\\\\n        // Set expiry in Wrapper\\\\n        uint64 expiry = uint64(registrarExpiry) + GRACE_PERIOD;\\\\n\\\\n        // Use super to allow names expired on the wrapper, but not expired on the registrar to renew()\\\\n        (address owner, uint32 fuses, ) = super.getData(uint256(node));\\\\n        _setData(node, owner, fuses, expiry);\\\\n\\\\n        return registrarExpiry;\\\\n    }\\\\n\\\\n    /**\\\\n     * @notice Wraps a non .eth domain, of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain\\\\n     * @dev Can be called by the owner in the registry or an authorised caller in the registry\\\\n     * @param name The name to wrap, in DNS format\\\\n     * @param wrappedOwner Owner of the name in this contract\\\\n     * @param resolver Resolver contract\\\\n     */\\\\n\\\\n    function wrap(\\\\n        bytes calldata name,\\\\n        address wrappedOwner,\\\\n        address resolver\\\\n    ) public {\\\\n        (bytes32 labelhash, uint256 offset) = name.readLabel(0);\\\\n        bytes32 parentNode = name.namehash(offset);\\\\n        bytes32 node = _makeNode(parentNode, labelhash);\\\\n\\\\n        names[node] = name;\\\\n\\\\n        if (parentNode == ETH_NODE) {\\\\n            revert IncompatibleParent();\\\\n        }\\\\n\\\\n        address owner = ens.owner(node);\\\\n\\\\n        if (owner != msg.sender && !ens.isApprovedForAll(owner, msg.sender)) {\\\\n            revert Unauthorised(node, msg.sender);\\\\n        }\\\\n\\\\n        if (resolver != address(0)) {\\\\n            ens.setResolver(node, resolver);\\\\n        }\\\\n\\\\n        ens.setOwner(node, address(this));\\\\n\\\\n        _wrap(node, name, wrappedOwner, 0, 0);\\\\n    }\\\\n\\\\n    /**\\\\n     * @notice Unwraps a .eth domain. e.g. vitalik.eth\\\\n     * @dev Can be called by the owner in the wrapper or an authorised caller in the wrapper\\\\n     * @param labelhash Labelhash of the .eth domain\\\\n     * @param registrant Sets the owner in the .eth registrar to this address\\\\n     * @param controller Sets the owner in the registry to this address\\\\n     */\\\\n\\\\n    function unwrapETH2LD(\\\\n        bytes32 labelhash,\\\\n        address registrant,\\\\n        address controller\\\\n    ) public onlyTokenOwner(_makeNode(ETH_NODE, labelhash)) {\\\\n        if (registrant == address(this)) {\\\\n            revert IncorrectTargetOwner(registrant);\\\\n        }\\\\n        _unwrap(_makeNode(ETH_NODE, labelhash), controller);\\\\n        registrar.safeTransferFrom(\\\\n            address(this),\\\\n            registrant,\\\\n            uint256(labelhash)\\\\n        );\\\\n    }\\\\n\\\\n    /**\\\\n     * @notice Unwraps a non .eth domain, of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain\\\\n     * @dev Can be called by the owner in the wrapper or an authorised caller in the wrapper\\\\n     * @param parentNode Parent namehash of the name e.g. vitalik.xyz would be namehash(\'xyz\')\\\\n     * @param labelhash Labelhash of the name, e.g. vitalik.xyz would be keccak256(\'vitalik\')\\\\n     * @param controller Sets the owner in the registry to this address\\\\n     */\\\\n\\\\n    function unwrap(\\\\n        bytes32 parentNode,\\\\n        bytes32 labelhash,\\\\n        address controller\\\\n    ) public onlyTokenOwner(_makeNode(parentNode, labelhash)) {\\\\n        if (parentNode == ETH_NODE) {\\\\n            revert IncompatibleParent();\\\\n        }\\\\n        if (controller == address(0x0) || controller == address(this)) {\\\\n            revert IncorrectTargetOwner(controller);\\\\n        }\\\\n        _unwrap(_makeNode(parentNode, labelhash), controller);\\\\n    }\\\\n\\\\n    /**\\\\n     * @notice Sets fuses of a name\\\\n     * @param node Namehash of the name\\\\n     * @param ownerControlledFuses Owner-controlled fuses to burn\\\\n     * @return Old fuses\\\\n     */\\\\n\\\\n    function setFuses(\\\\n        bytes32 node,\\\\n        uint16 ownerControlledFuses\\\\n    )\\\\n        public\\\\n        onlyTokenOwner(node)\\\\n        operationAllowed(node, CANNOT_BURN_FUSES)\\\\n        returns (uint32)\\\\n    {\\\\n        // owner protected by onlyTokenOwner\\\\n        (address owner, uint32 oldFuses, uint64 expiry) = getData(\\\\n            uint256(node)\\\\n        );\\\\n        _setFuses(node, owner, ownerControlledFuses | oldFuses, expiry, expiry);\\\\n        return oldFuses;\\\\n    }\\\\n\\\\n    /**\\\\n     * @notice Extends expiry for a name\\\\n     * @param parentNode Parent namehash of the name e.g. vitalik.xyz would be namehash(\'xyz\')\\\\n     * @param labelhash Labelhash of the name, e.g. vitalik.xyz would be keccak256(\'vitalik\')\\\\n     * @param expiry When the name will expire in seconds since the Unix epoch\\\\n     * @return New expiry\\\\n     */\\\\n\\\\n    function extendExpiry(\\\\n        bytes32 parentNode,\\\\n        bytes32 labelhash,\\\\n        uint64 expiry\\\\n    ) public returns (uint64) {\\\\n        bytes32 node = _makeNode(parentNode, labelhash);\\\\n\\\\n        if (!_isWrapped(node)) {\\\\n            revert NameIsNotWrapped();\\\\n        }\\\\n\\\\n        // this flag is used later, when checking fuses\\\\n        bool canExtendSubname = canExtendSubnames(parentNode, msg.sender);\\\\n        // only allow the owner of the name or owner of the parent name\\\\n        if (!canExtendSubname && !canModifyName(node, msg.sender)) {\\\\n            revert Unauthorised(node, msg.sender);\\\\n        }\\\\n\\\\n        (address owner, uint32 fuses, uint64 oldExpiry) = getData(\\\\n            uint256(node)\\\\n        );\\\\n\\\\n        // Either CAN_EXTEND_EXPIRY must be set, or the caller must have permission to modify the parent name\\\\n        if (!canExtendSubname && fuses & CAN_EXTEND_EXPIRY == 0) {\\\\n            revert OperationProhibited(node);\\\\n        }\\\\n\\\\n        // Max expiry is set to the expiry of the parent\\\\n        (, , uint64 maxExpiry) = getData(uint256(parentNode));\\\\n        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);\\\\n\\\\n        _setData(node, owner, fuses, expiry);\\\\n        emit ExpiryExtended(node, expiry);\\\\n        return expiry;\\\\n    }\\\\n\\\\n    /**\\\\n     * @notice Upgrades a domain of any kind. Could be a .eth name vitalik.eth, a DNSSEC name vitalik.xyz, or a subdomain\\\\n     * @dev Can be called by the owner or an authorised caller\\\\n     * @param name The name to upgrade, in DNS format\\\\n     * @param extraData Extra data to pass to the upgrade contract\\\\n     */\\\\n\\\\n    function upgrade(bytes calldata name, bytes calldata extraData) public {\\\\n        bytes32 node = name.namehash(0);\\\\n\\\\n        if (address(upgradeContract) == address(0)) {\\\\n            revert CannotUpgrade();\\\\n        }\\\\n\\\\n        if (!canModifyName(node, msg.sender)) {\\\\n            revert Unauthorised(node, msg.sender);\\\\n        }\\\\n\\\\n        (address currentOwner, uint32 fuses, uint64 expiry) = getData(\\\\n            uint256(node)\\\\n        );\\\\n\\\\n        address approved = getApproved(uint256(node));\\\\n\\\\n        _burn(uint256(node));\\\\n\\\\n        upgradeContract.wrapFromUpgrade(\\\\n            name,\\\\n            currentOwner,\\\\n            fuses,\\\\n            expiry,\\\\n            approved,\\\\n            extraData\\\\n        );\\\\n    }\\\\n\\\\n    /** \\\\n    /* @notice Sets fuses of a name that you own the parent of\\\\n     * @param parentNode Parent namehash of the name e.g. vitalik.xyz would be namehash(\'xyz\')\\\\n     * @param labelhash Labelhash of the name, e.g. vitalik.xyz would be keccak256(\'vitalik\')\\\\n     * @param fuses Fuses to burn\\\\n     * @param expiry When the name will expire in seconds since the Unix epoch\\\\n     */\\\\n\\\\n    function setChildFuses(\\\\n        bytes32 parentNode,\\\\n        bytes32 labelhash,\\\\n        uint32 fuses,\\\\n        uint64 expiry\\\\n    ) public {\\\\n        bytes32 node = _makeNode(parentNode, labelhash);\\\\n        _checkFusesAreSettable(node, fuses);\\\\n        (address owner, uint32 oldFuses, uint64 oldExpiry) = getData(\\\\n            uint256(node)\\\\n        );\\\\n        if (owner == address(0) || ens.owner(node) != address(this)) {\\\\n            revert NameIsNotWrapped();\\\\n        }\\\\n        // max expiry is set to the expiry of the parent\\\\n        (, uint32 parentFuses, uint64 maxExpiry) = getData(uint256(parentNode));\\\\n        if (parentNode == ROOT_NODE) {\\\\n            if (!canModifyName(node, msg.sender)) {\\\\n                revert Unauthorised(node, msg.sender);\\\\n            }\\\\n        } else {\\\\n            if (!canModifyName(parentNode, msg.sender)) {\\\\n                revert Unauthorised(parentNode, msg.sender);\\\\n            }\\\\n        }\\\\n\\\\n        _checkParentFuses(node, fuses, parentFuses);\\\\n\\\\n        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);\\\\n\\\\n        // if PARENT_CANNOT_CONTROL has been burned and fuses have changed\\\\n        if (\\\\n            oldFuses & PARENT_CANNOT_CONTROL != 0 &&\\\\n            oldFuses | fuses != oldFuses\\\\n        ) {\\\\n            revert OperationProhibited(node);\\\\n        }\\\\n        fuses |= oldFuses;\\\\n        _setFuses(node, owner, fuses, oldExpiry, expiry);\\\\n    }\\\\n\\\\n    /**\\\\n     * @notice Sets the subdomain owner in the registry and then wraps the subdomain\\\\n     * @param parentNode Parent namehash of the subdomain\\\\n     * @param label Label of the subdomain as a string\\\\n     * @param owner New owner in the wrapper\\\\n     * @param fuses Initial fuses for the wrapped subdomain\\\\n     * @param expiry When the name will expire in seconds since the Unix epoch\\\\n     * @return node Namehash of the subdomain\\\\n     */\\\\n\\\\n    function setSubnodeOwner(\\\\n        bytes32 parentNode,\\\\n        string calldata label,\\\\n        address owner,\\\\n        uint32 fuses,\\\\n        uint64 expiry\\\\n    ) public onlyTokenOwner(parentNode) returns (bytes32 node) {\\\\n        bytes32 labelhash = keccak256(bytes(label));\\\\n        node = _makeNode(parentNode, labelhash);\\\\n        _checkCanCallSetSubnodeOwner(parentNode, node);\\\\n        _checkFusesAreSettable(node, fuses);\\\\n        bytes memory name = _saveLabel(parentNode, node, label);\\\\n        expiry = _checkParentFusesAndExpiry(parentNode, node, fuses, expiry);\\\\n\\\\n        if (!_isWrapped(node)) {\\\\n            ens.setSubnodeOwner(parentNode, labelhash, address(this));\\\\n            _wrap(node, name, owner, fuses, expiry);\\\\n        } else {\\\\n            _updateName(parentNode, node, label, owner, fuses, expiry);\\\\n        }\\\\n    }\\\\n\\\\n    /**\\\\n     * @notice Sets the subdomain owner in the registry with records and then wraps the subdomain\\\\n     * @param parentNode parent namehash of the subdomain\\\\n     * @param label label of the subdomain as a string\\\\n     * @param owner new owner in the wrapper\\\\n     * @param resolver resolver contract in the registry\\\\n     * @param ttl ttl in the registry\\\\n     * @param fuses initial fuses for the wrapped subdomain\\\\n     * @param expiry When the name will expire in seconds since the Unix epoch\\\\n     * @return node Namehash of the subdomain\\\\n     */\\\\n\\\\n    function setSubnodeRecord(\\\\n        bytes32 parentNode,\\\\n        string memory label,\\\\n        address owner,\\\\n        address resolver,\\\\n        uint64 ttl,\\\\n        uint32 fuses,\\\\n        uint64 expiry\\\\n    ) public onlyTokenOwner(parentNode) returns (bytes32 node) {\\\\n        bytes32 labelhash = keccak256(bytes(label));\\\\n        node = _makeNode(parentNode, labelhash);\\\\n        _checkCanCallSetSubnodeOwner(parentNode, node);\\\\n        _checkFusesAreSettable(node, fuses);\\\\n        _saveLabel(parentNode, node, label);\\\\n        expiry = _checkParentFusesAndExpiry(parentNode, node, fuses, expiry);\\\\n        if (!_isWrapped(node)) {\\\\n            ens.setSubnodeRecord(\\\\n                parentNode,\\\\n                labelhash,\\\\n                address(this),\\\\n                resolver,\\\\n                ttl\\\\n            );\\\\n            _storeNameAndWrap(parentNode, node, label, owner, fuses, expiry);\\\\n        } else {\\\\n            ens.setSubnodeRecord(\\\\n                parentNode,\\\\n                labelhash,\\\\n                address(this),\\\\n                resolver,\\\\n                ttl\\\\n            );\\\\n            _updateName(parentNode, node, label, owner, fuses, expiry);\\\\n        }\\\\n    }\\\\n\\\\n    /**\\\\n     * @notice Sets records for the name in the ENS Registry\\\\n     * @param node Namehash of the name to set a record for\\\\n     * @param owner New owner in the registry\\\\n     * @param resolver Resolver contract\\\\n     * @param ttl Time to live in the registry\\\\n     */\\\\n\\\\n    function setRecord(\\\\n        bytes32 node,\\\\n        address owner,\\\\n        address resolver,\\\\n        uint64 ttl\\\\n    )\\\\n        public\\\\n        onlyTokenOwner(node)\\\\n        operationAllowed(\\\\n            node,\\\\n            CANNOT_TRANSFER | CANNOT_SET_RESOLVER | CANNOT_SET_TTL\\\\n        )\\\\n    {\\\\n        ens.setRecord(node, address(this), resolver, ttl);\\\\n        if (owner == address(0)) {\\\\n            (, uint32 fuses, ) = getData(uint256(node));\\\\n            if (fuses & IS_DOT_ETH == IS_DOT_ETH) {\\\\n                revert IncorrectTargetOwner(owner);\\\\n            }\\\\n            _unwrap(node, address(0));\\\\n        } else {\\\\n            address oldOwner = ownerOf(uint256(node));\\\\n            _transfer(oldOwner, owner, uint256(node), 1, \\\\\\"\\\\\\");\\\\n        }\\\\n    }\\\\n\\\\n    /**\\\\n     * @notice Sets resolver contract in the registry\\\\n     * @param node namehash of the name\\\\n     * @param resolver the resolver contract\\\\n     */\\\\n\\\\n    function setResolver(\\\\n        bytes32 node,\\\\n        address resolver\\\\n    ) public onlyTokenOwner(node) operationAllowed(node, CANNOT_SET_RESOLVER) {\\\\n        ens.setResolver(node, resolver);\\\\n    }\\\\n\\\\n    /**\\\\n     * @notice Sets TTL in the registry\\\\n     * @param node Namehash of the name\\\\n     * @param ttl TTL in the registry\\\\n     */\\\\n\\\\n    function setTTL(\\\\n        bytes32 node,\\\\n        uint64 ttl\\\\n    ) public onlyTokenOwner(node) operationAllowed(node, CANNOT_SET_TTL) {\\\\n        ens.setTTL(node, ttl);\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Allows an operation only if none of the specified fuses are burned.\\\\n     * @param node The namehash of the name to check fuses on.\\\\n     * @param fuseMask A bitmask of fuses that must not be burned.\\\\n     */\\\\n\\\\n    modifier operationAllowed(bytes32 node, uint32 fuseMask) {\\\\n        (, uint32 fuses, ) = getData(uint256(node));\\\\n        if (fuses & fuseMask != 0) {\\\\n            revert OperationProhibited(node);\\\\n        }\\\\n        _;\\\\n    }\\\\n\\\\n    /**\\\\n     * @notice Check whether a name can call setSubnodeOwner/setSubnodeRecord\\\\n     * @dev Checks both CANNOT_CREATE_SUBDOMAIN and PARENT_CANNOT_CONTROL and whether not they have been burnt\\\\n     *      and checks whether the owner of the subdomain is 0x0 for creating or already exists for\\\\n     *      replacing a subdomain. If either conditions are true, then it is possible to call\\\\n     *      setSubnodeOwner\\\\n     * @param parentNode Namehash of the parent name to check\\\\n     * @param subnode Namehash of the subname to check\\\\n     */\\\\n\\\\n    function _checkCanCallSetSubnodeOwner(\\\\n        bytes32 parentNode,\\\\n        bytes32 subnode\\\\n    ) internal view {\\\\n        (\\\\n            address subnodeOwner,\\\\n            uint32 subnodeFuses,\\\\n            uint64 subnodeExpiry\\\\n        ) = getData(uint256(subnode));\\\\n\\\\n        // check if the registry owner is 0 and expired\\\\n        // check if the wrapper owner is 0 and expired\\\\n        // If either, then check parent fuses for CANNOT_CREATE_SUBDOMAIN\\\\n        bool expired = subnodeExpiry < block.timestamp;\\\\n        if (\\\\n            expired &&\\\\n            // protects a name that has been unwrapped with PCC and doesn\'t allow the parent to take control by recreating it if unexpired\\\\n            (subnodeOwner == address(0) ||\\\\n                // protects a name that has been burnt and doesn\'t allow the parent to take control by recreating it if unexpired\\\\n                ens.owner(subnode) == address(0))\\\\n        ) {\\\\n            (, uint32 parentFuses, ) = getData(uint256(parentNode));\\\\n            if (parentFuses & CANNOT_CREATE_SUBDOMAIN != 0) {\\\\n                revert OperationProhibited(subnode);\\\\n            }\\\\n        } else {\\\\n            if (subnodeFuses & PARENT_CANNOT_CONTROL != 0) {\\\\n                revert OperationProhibited(subnode);\\\\n            }\\\\n        }\\\\n    }\\\\n\\\\n    /**\\\\n     * @notice Checks all Fuses in the mask are burned for the node\\\\n     * @param node Namehash of the name\\\\n     * @param fuseMask The fuses you want to check\\\\n     * @return Boolean of whether or not all the selected fuses are burned\\\\n     */\\\\n\\\\n    function allFusesBurned(\\\\n        bytes32 node,\\\\n        uint32 fuseMask\\\\n    ) public view returns (bool) {\\\\n        (, uint32 fuses, ) = getData(uint256(node));\\\\n        return fuses & fuseMask == fuseMask;\\\\n    }\\\\n\\\\n    /**\\\\n     * @notice Checks if a name is wrapped\\\\n     * @param node Namehash of the name\\\\n     * @return Boolean of whether or not the name is wrapped\\\\n     */\\\\n\\\\n    function isWrapped(bytes32 node) public view returns (bool) {\\\\n        bytes memory name = names[node];\\\\n        if (name.length == 0) {\\\\n            return false;\\\\n        }\\\\n        (bytes32 labelhash, uint256 offset) = name.readLabel(0);\\\\n        bytes32 parentNode = name.namehash(offset);\\\\n        return isWrapped(parentNode, labelhash);\\\\n    }\\\\n\\\\n    /**\\\\n     * @notice Checks if a name is wrapped in a more gas efficient way\\\\n     * @param parentNode Namehash of the name\\\\n     * @param labelhash Namehash of the name\\\\n     * @return Boolean of whether or not the name is wrapped\\\\n     */\\\\n\\\\n    function isWrapped(\\\\n        bytes32 parentNode,\\\\n        bytes32 labelhash\\\\n    ) public view returns (bool) {\\\\n        bytes32 node = _makeNode(parentNode, labelhash);\\\\n        bool wrapped = _isWrapped(node);\\\\n        if (parentNode != ETH_NODE) {\\\\n            return wrapped;\\\\n        }\\\\n        try registrar.ownerOf(uint256(labelhash)) returns (address owner) {\\\\n            return owner == address(this);\\\\n        } catch {\\\\n            return false;\\\\n        }\\\\n    }\\\\n\\\\n    function onERC721Received(\\\\n        address to,\\\\n        address,\\\\n        uint256 tokenId,\\\\n        bytes calldata data\\\\n    ) public returns (bytes4) {\\\\n        //check if it\'s the eth registrar ERC721\\\\n        if (msg.sender != address(registrar)) {\\\\n            revert IncorrectTokenType();\\\\n        }\\\\n\\\\n        (\\\\n            string memory label,\\\\n            address owner,\\\\n            uint16 ownerControlledFuses,\\\\n            address resolver\\\\n        ) = abi.decode(data, (string, address, uint16, address));\\\\n\\\\n        bytes32 labelhash = bytes32(tokenId);\\\\n        bytes32 labelhashFromData = keccak256(bytes(label));\\\\n\\\\n        if (labelhashFromData != labelhash) {\\\\n            revert LabelMismatch(labelhashFromData, labelhash);\\\\n        }\\\\n\\\\n        // transfer the ens record back to the new owner (this contract)\\\\n        registrar.reclaim(uint256(labelhash), address(this));\\\\n\\\\n        uint64 expiry = uint64(registrar.nameExpires(tokenId)) + GRACE_PERIOD;\\\\n\\\\n        _wrapETH2LD(label, owner, ownerControlledFuses, expiry, resolver);\\\\n\\\\n        return IERC721Receiver(to).onERC721Received.selector;\\\\n    }\\\\n\\\\n    /***** Internal functions */\\\\n\\\\n    function _beforeTransfer(\\\\n        uint256 id,\\\\n        uint32 fuses,\\\\n        uint64 expiry\\\\n    ) internal override {\\\\n        // For this check, treat .eth 2LDs as expiring at the start of the grace period.\\\\n        if (fuses & IS_DOT_ETH == IS_DOT_ETH) {\\\\n            expiry -= GRACE_PERIOD;\\\\n        }\\\\n\\\\n        if (expiry < block.timestamp) {\\\\n            // Transferable if the name was not emancipated\\\\n            if (fuses & PARENT_CANNOT_CONTROL != 0) {\\\\n                revert(\\\\\\"ERC1155: insufficient balance for transfer\\\\\\");\\\\n            }\\\\n        } else {\\\\n            // Transferable if CANNOT_TRANSFER is unburned\\\\n            if (fuses & CANNOT_TRANSFER != 0) {\\\\n                revert OperationProhibited(bytes32(id));\\\\n            }\\\\n        }\\\\n\\\\n        // delete token approval if CANNOT_APPROVE has not been burnt\\\\n        if (fuses & CANNOT_APPROVE == 0) {\\\\n            delete _tokenApprovals[id];\\\\n        }\\\\n    }\\\\n\\\\n    function _clearOwnerAndFuses(\\\\n        address owner,\\\\n        uint32 fuses,\\\\n        uint64 expiry\\\\n    ) internal view override returns (address, uint32) {\\\\n        if (expiry < block.timestamp) {\\\\n            if (fuses & PARENT_CANNOT_CONTROL == PARENT_CANNOT_CONTROL) {\\\\n                owner = address(0);\\\\n            }\\\\n            fuses = 0;\\\\n        }\\\\n\\\\n        return (owner, fuses);\\\\n    }\\\\n\\\\n    function _makeNode(\\\\n        bytes32 node,\\\\n        bytes32 labelhash\\\\n    ) private pure returns (bytes32) {\\\\n        return keccak256(abi.encodePacked(node, labelhash));\\\\n    }\\\\n\\\\n    function _addLabel(\\\\n        string memory label,\\\\n        bytes memory name\\\\n    ) internal pure returns (bytes memory ret) {\\\\n        if (bytes(label).length < 1) {\\\\n            revert LabelTooShort();\\\\n        }\\\\n        if (bytes(label).length > 255) {\\\\n            revert LabelTooLong(label);\\\\n        }\\\\n        return abi.encodePacked(uint8(bytes(label).length), label, name);\\\\n    }\\\\n\\\\n    function _mint(\\\\n        bytes32 node,\\\\n        address owner,\\\\n        uint32 fuses,\\\\n        uint64 expiry\\\\n    ) internal override {\\\\n        _canFusesBeBurned(node, fuses);\\\\n        (address oldOwner, , ) = super.getData(uint256(node));\\\\n        if (oldOwner != address(0)) {\\\\n            // burn and unwrap old token of old owner\\\\n            _burn(uint256(node));\\\\n            emit NameUnwrapped(node, address(0));\\\\n        }\\\\n        super._mint(node, owner, fuses, expiry);\\\\n    }\\\\n\\\\n    function _wrap(\\\\n        bytes32 node,\\\\n        bytes memory name,\\\\n        address wrappedOwner,\\\\n        uint32 fuses,\\\\n        uint64 expiry\\\\n    ) internal {\\\\n        _mint(node, wrappedOwner, fuses, expiry);\\\\n        emit NameWrapped(node, name, wrappedOwner, fuses, expiry);\\\\n    }\\\\n\\\\n    function _storeNameAndWrap(\\\\n        bytes32 parentNode,\\\\n        bytes32 node,\\\\n        string memory label,\\\\n        address owner,\\\\n        uint32 fuses,\\\\n        uint64 expiry\\\\n    ) internal {\\\\n        bytes memory name = _addLabel(label, names[parentNode]);\\\\n        _wrap(node, name, owner, fuses, expiry);\\\\n    }\\\\n\\\\n    function _saveLabel(\\\\n        bytes32 parentNode,\\\\n        bytes32 node,\\\\n        string memory label\\\\n    ) internal returns (bytes memory) {\\\\n        bytes memory name = _addLabel(label, names[parentNode]);\\\\n        names[node] = name;\\\\n        return name;\\\\n    }\\\\n\\\\n    function _updateName(\\\\n        bytes32 parentNode,\\\\n        bytes32 node,\\\\n        string memory label,\\\\n        address owner,\\\\n        uint32 fuses,\\\\n        uint64 expiry\\\\n    ) internal {\\\\n        (address oldOwner, uint32 oldFuses, uint64 oldExpiry) = getData(\\\\n            uint256(node)\\\\n        );\\\\n        bytes memory name = _addLabel(label, names[parentNode]);\\\\n        if (names[node].length == 0) {\\\\n            names[node] = name;\\\\n        }\\\\n        _setFuses(node, oldOwner, oldFuses | fuses, oldExpiry, expiry);\\\\n        if (owner == address(0)) {\\\\n            _unwrap(node, address(0));\\\\n        } else {\\\\n            _transfer(oldOwner, owner, uint256(node), 1, \\\\\\"\\\\\\");\\\\n        }\\\\n    }\\\\n\\\\n    // wrapper function for stack limit\\\\n    function _checkParentFusesAndExpiry(\\\\n        bytes32 parentNode,\\\\n        bytes32 node,\\\\n        uint32 fuses,\\\\n        uint64 expiry\\\\n    ) internal view returns (uint64) {\\\\n        (, , uint64 oldExpiry) = getData(uint256(node));\\\\n        (, uint32 parentFuses, uint64 maxExpiry) = getData(uint256(parentNode));\\\\n        _checkParentFuses(node, fuses, parentFuses);\\\\n        return _normaliseExpiry(expiry, oldExpiry, maxExpiry);\\\\n    }\\\\n\\\\n    function _checkParentFuses(\\\\n        bytes32 node,\\\\n        uint32 fuses,\\\\n        uint32 parentFuses\\\\n    ) internal pure {\\\\n        bool isBurningParentControlledFuses = fuses & PARENT_CONTROLLED_FUSES !=\\\\n            0;\\\\n\\\\n        bool parentHasNotBurnedCU = parentFuses & CANNOT_UNWRAP == 0;\\\\n\\\\n        if (isBurningParentControlledFuses && parentHasNotBurnedCU) {\\\\n            revert OperationProhibited(node);\\\\n        }\\\\n    }\\\\n\\\\n    function _normaliseExpiry(\\\\n        uint64 expiry,\\\\n        uint64 oldExpiry,\\\\n        uint64 maxExpiry\\\\n    ) private pure returns (uint64) {\\\\n        // Expiry cannot be more than maximum allowed\\\\n        // .eth names will check registrar, non .eth check parent\\\\n        if (expiry > maxExpiry) {\\\\n            expiry = maxExpiry;\\\\n        }\\\\n        // Expiry cannot be less than old expiry\\\\n        if (expiry < oldExpiry) {\\\\n            expiry = oldExpiry;\\\\n        }\\\\n\\\\n        return expiry;\\\\n    }\\\\n\\\\n    function _wrapETH2LD(\\\\n        string memory label,\\\\n        address wrappedOwner,\\\\n        uint32 fuses,\\\\n        uint64 expiry,\\\\n        address resolver\\\\n    ) private {\\\\n        bytes32 labelhash = keccak256(bytes(label));\\\\n        bytes32 node = _makeNode(ETH_NODE, labelhash);\\\\n        // hardcode dns-encoded eth string for gas savings\\\\n        bytes memory name = _addLabel(label, \\\\\\"\\\\\\\\x03eth\\\\\\\\x00\\\\\\");\\\\n        names[node] = name;\\\\n\\\\n        _wrap(\\\\n            node,\\\\n            name,\\\\n            wrappedOwner,\\\\n            fuses | PARENT_CANNOT_CONTROL | IS_DOT_ETH,\\\\n            expiry\\\\n        );\\\\n\\\\n        if (resolver != address(0)) {\\\\n            ens.setResolver(node, resolver);\\\\n        }\\\\n    }\\\\n\\\\n    function _unwrap(bytes32 node, address owner) private {\\\\n        if (allFusesBurned(node, CANNOT_UNWRAP)) {\\\\n            revert OperationProhibited(node);\\\\n        }\\\\n\\\\n        // Burn token and fuse data\\\\n        _burn(uint256(node));\\\\n        ens.setOwner(node, owner);\\\\n\\\\n        emit NameUnwrapped(node, owner);\\\\n    }\\\\n\\\\n    function _setFuses(\\\\n        bytes32 node,\\\\n        address owner,\\\\n        uint32 fuses,\\\\n        uint64 oldExpiry,\\\\n        uint64 expiry\\\\n    ) internal {\\\\n        _setData(node, owner, fuses, expiry);\\\\n        emit FusesSet(node, fuses);\\\\n        if (expiry > oldExpiry) {\\\\n            emit ExpiryExtended(node, expiry);\\\\n        }\\\\n    }\\\\n\\\\n    function _setData(\\\\n        bytes32 node,\\\\n        address owner,\\\\n        uint32 fuses,\\\\n        uint64 expiry\\\\n    ) internal {\\\\n        _canFusesBeBurned(node, fuses);\\\\n        super._setData(uint256(node), owner, fuses, expiry);\\\\n    }\\\\n\\\\n    function _canFusesBeBurned(bytes32 node, uint32 fuses) internal pure {\\\\n        // If a non-parent controlled fuse is being burned, check PCC and CU are burnt\\\\n        if (\\\\n            fuses & ~PARENT_CONTROLLED_FUSES != 0 &&\\\\n            fuses & (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP) !=\\\\n            (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP)\\\\n        ) {\\\\n            revert OperationProhibited(node);\\\\n        }\\\\n    }\\\\n\\\\n    function _checkFusesAreSettable(bytes32 node, uint32 fuses) internal pure {\\\\n        if (fuses | USER_SETTABLE_FUSES != USER_SETTABLE_FUSES) {\\\\n            // Cannot directly burn other non-user settable fuses\\\\n            revert OperationProhibited(node);\\\\n        }\\\\n    }\\\\n\\\\n    function _isWrapped(bytes32 node) internal view returns (bool) {\\\\n        return\\\\n            ownerOf(uint256(node)) != address(0) &&\\\\n            ens.owner(node) == address(this);\\\\n    }\\\\n\\\\n    function _isETH2LDInGracePeriod(\\\\n        uint32 fuses,\\\\n        uint64 expiry\\\\n    ) internal view returns (bool) {\\\\n        return\\\\n            fuses & IS_DOT_ETH == IS_DOT_ETH &&\\\\n            expiry - GRACE_PERIOD < block.timestamp;\\\\n    }\\\\n}\\\\n\\",\\"keccak256\\":\\"0x91ee0a58d8ecf132c4e7fba9a25bbf45bbfc3634f2024b30a6a2eea4a151ed0c\\",\\"license\\":\\"MIT\\"}},\\"version\\":1}","bytecode":"0x60c06040523480156200001157600080fd5b5060405162006502380380620065028339810160408190526200003491620002f8565b823362000041816200028f565b6040516302571be360e01b81527f91d1777781884d03a6757a803996e38de2a42967fb37eeaca72729271025a9e260048201526000906001600160a01b038416906302571be390602401602060405180830381865afa158015620000a9573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190620000cf91906200034c565b604051630f41a04d60e11b81526001600160a01b03848116600483015291925090821690631e83409a906024016020604051808303816000875af11580156200011c573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019062000142919062000373565b505050506001600160a01b0383811660805282811660a052600580546001600160a01b031916918316919091179055600163fffeffff60a01b03197fafa26c20e8b3d9a2853d642cfe1021dae26242ffedfac91c97aab212c1a4b93b8190557fa6eef7e35abe7026729641147f7915573c7e97b47efa546f5f6e3230263bcb4955604080518082019091526001815260006020808301829052908052600690527f54cdd369e4e8a8515e52ca72ec816c2101831ad1f18bf44102ed171459c9b4f89062000210908262000432565b506040805180820190915260058152626cae8d60e31b6020808301919091527f93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae600052600690527ffb9e8e321b8a5ec48f12a7b41f22c6e595d761285c9eb19d8dda7c99edf1b54f9062000285908262000432565b50505050620004fe565b600080546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b6001600160a01b0381168114620002f557600080fd5b50565b6000806000606084860312156200030e57600080fd5b83516200031b81620002df565b60208501519093506200032e81620002df565b60408501519092506200034181620002df565b809150509250925092565b6000602082840312156200035f57600080fd5b81516200036c81620002df565b9392505050565b6000602082840312156200038657600080fd5b5051919050565b634e487b7160e01b600052604160045260246000fd5b600181811c90821680620003b857607f821691505b602082108103620003d957634e487b7160e01b600052602260045260246000fd5b50919050565b601f8211156200042d57600081815260208120601f850160051c81016020861015620004085750805b601f850160051c820191505b81811015620004295782815560010162000414565b5050505b505050565b81516001600160401b038111156200044e576200044e6200038d565b62000466816200045f8454620003a3565b84620003df565b602080601f8311600181146200049e5760008415620004855750858301515b600019600386901b1c1916600185901b17855562000429565b600085815260208120601f198616915b82811015620004cf57888601518255948401946001909101908401620004ae565b5085821015620004ee5787850151600019600388901b60f8161c191681555b5050505050600190811b01905550565b60805160a051615ef76200060b6000396000818161050601528181610c1501528181610cef01528181610d7901528181611c6601528181611cfc01528181611daa01528181611ecc01528181611f4201528181611fc20152818161224401528181612380015281816124b2015281816126970152818161271d0152612f5201526000818161055301528181610b9b01528181610ed70152818161108b0152818161113d015281816115550152818161240501528181612537015281816127c8015281816129bf01528181612ccd0152818161317d0152818161322b015281816132f40152818161336d015281816139ca01528181613ae501528181613d4d015261438d0152615ef76000f3fe608060405234801561001057600080fd5b506004361061031f5760003560e01c80636352211e116101a7578063c93ab3fd116100ee578063e985e9c511610097578063f242432a11610071578063f242432a146107d7578063f2fde38b146107ea578063fd0cd0d9146107fd57600080fd5b8063e985e9c514610768578063eb8ae530146107a4578063ed70554d146107b757600080fd5b8063d9a50c12116100c8578063d9a50c121461071f578063da8c229e14610732578063e0dba60f1461075557600080fd5b8063c93ab3fd146106e6578063cf408823146106f9578063d8c9921a1461070c57600080fd5b8063a22cb46511610150578063b6bcad261161012a578063b6bcad26146106ad578063c475abff146106c0578063c658e086146106d357600080fd5b8063a22cb46514610674578063a401498214610687578063adf4960a1461069a57600080fd5b80638b4dfa75116101815780638b4dfa751461063d5780638cf8b41e146106505780638da5cb5b1461066357600080fd5b80636352211e146105f65780636e5d6ad214610609578063715018a61461063557600080fd5b80631f4e15041161026b5780633f15457f116102145780634e1273f4116101ee5780634e1273f4146105b057806353095467146105d05780635d3590d5146105e357600080fd5b80633f15457f1461054e578063402906fc1461057557806341415eab1461059d57600080fd5b80632b20e397116102455780632b20e397146105015780632eb2c2d61461052857806333c69ea91461053b57600080fd5b80631f4e1504146104c857806320c38e2b146104db57806324c1af44146104ee57600080fd5b80630e4cd725116102cd578063150b7a02116102a7578063150b7a02146104765780631534e177146104a25780631896f70a146104b557600080fd5b80630e4cd7251461043d5780630e89341c1461045057806314ab90381461046357600080fd5b806306fdde03116102fe57806306fdde03146103b4578063081812fc146103fd578063095ea7b31461042857600080fd5b8062fdd58e146103245780630178fe3f1461034a57806301ffc9a714610391575b600080fd5b610337610332366004614d26565b610810565b6040519081526020015b60405180910390f35b61035d610358366004614d52565b6108cf565b604080516001600160a01b03909416845263ffffffff909216602084015267ffffffffffffffff1690820152606001610341565b6103a461039f366004614d81565b6108ff565b6040519015158152602001610341565b6103f06040518060400160405280600b81526020017f4e616d655772617070657200000000000000000000000000000000000000000081525081565b6040516103419190614dee565b61041061040b366004614d52565b610958565b6040516001600160a01b039091168152602001610341565b61043b610436366004614d26565b61099d565b005b6103a461044b366004614e01565b6109e3565b6103f061045e366004614d52565b610a7d565b61043b610471366004614e4e565b610aef565b610489610484366004614ec3565b610c08565b6040516001600160e01b03199091168152602001610341565b61043b6104b0366004614f36565b610e1a565b61043b6104c3366004614e01565b610e44565b600754610410906001600160a01b031681565b6103f06104e9366004614d52565b610f06565b6103376104fc36600461502e565b610fa0565b6104107f000000000000000000000000000000000000000000000000000000000000000081565b61043b610536366004615156565b6111b4565b61043b610549366004615204565b6114de565b6104107f000000000000000000000000000000000000000000000000000000000000000081565b61058861058336600461525c565b6116d3565b60405163ffffffff9091168152602001610341565b6103a46105ab366004614e01565b611775565b6105c36105be36600461527f565b6117d2565b604051610341919061537d565b600554610410906001600160a01b031681565b61043b6105f1366004615390565b611910565b610410610604366004614d52565b6119aa565b61061c6106173660046153d1565b6119b5565b60405167ffffffffffffffff9091168152602001610341565b61043b611b0a565b61043b61064b366004615406565b611b1e565b61061c61065e366004615448565b611cc8565b6000546001600160a01b0316610410565b61043b6106823660046154d1565b612094565b6103376106953660046154ff565b61217e565b6103a46106a8366004615580565b612319565b61043b6106bb366004614f36565b61233e565b6103376106ce3660046155a3565b612596565b6103376106e13660046155c5565b61288d565b61043b6106f4366004615638565b612a9a565b61043b6107073660046156a4565b612c0b565b61043b61071a3660046156dc565b612dc4565b6103a461072d3660046155a3565b612ed4565b6103a4610740366004614f36565b60046020526000908152604090205460ff1681565b61043b6107633660046154d1565b612fe1565b6103a461077636600461570a565b6001600160a01b03918216600090815260026020908152604080832093909416825291909152205460ff1690565b61043b6107b2366004615738565b613049565b6103376107c5366004614d52565b60016020526000908152604090205481565b61043b6107e53660046157a0565b613414565b61043b6107f8366004614f36565b613531565b6103a461080b366004614d52565b6135be565b60006001600160a01b0383166108935760405162461bcd60e51b815260206004820152602b60248201527f455243313135353a2062616c616e636520717565727920666f7220746865207a60448201527f65726f206164647265737300000000000000000000000000000000000000000060648201526084015b60405180910390fd5b600061089e836119aa565b9050836001600160a01b0316816001600160a01b0316036108c35760019150506108c9565b60009150505b92915050565b60008181526001602052604090205460a081901c60c082901c6108f3838383613696565b90959094509092509050565b60006001600160e01b031982167fd82c42d800000000000000000000000000000000000000000000000000000000148061094957506001600160e01b03198216630a85bd0160e11b145b806108c957506108c9826136cd565b600080610964836119aa565b90506001600160a01b03811661097d5750600092915050565b6000838152600360205260409020546001600160a01b03165b9392505050565b60006109a8826108cf565b50915050603f1960408216016109d45760405163a2a7201360e01b81526004810183905260240161088a565b6109de838361374f565b505050565b60008080806109f1866108cf565b925092509250846001600160a01b0316836001600160a01b03161480610a3c57506001600160a01b0380841660009081526002602090815260408083209389168352929052205460ff165b80610a6057506001600160a01b038516610a5587610958565b6001600160a01b0316145b8015610a735750610a718282613899565b155b9695505050505050565b6005546040516303a24d0760e21b8152600481018390526060916001600160a01b031690630e89341c90602401600060405180830381865afa158015610ac7573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526108c99190810190615809565b81610afa8133611775565b610b205760405163168ab55d60e31b81526004810182905233602482015260440161088a565b8260106000610b2e836108cf565b5091505063ffffffff8282161615610b5c5760405163a2a7201360e01b81526004810184905260240161088a565b6040517f14ab90380000000000000000000000000000000000000000000000000000000081526004810187905267ffffffffffffffff861660248201527f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316906314ab9038906044015b600060405180830381600087803b158015610be857600080fd5b505af1158015610bfc573d6000803e3d6000fd5b50505050505050505050565b6000336001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001614610c6c576040517f1931a53800000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6000808080610c7d86880188615881565b83516020850120939750919550935091508890808214610cd3576040517fc65c3ccc000000000000000000000000000000000000000000000000000000008152600481018290526024810183905260440161088a565b604051630a3b53db60e21b8152600481018390523060248201527f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316906328ed4f6c90604401600060405180830381600087803b158015610d3b57600080fd5b505af1158015610d4f573d6000803e3d6000fd5b5050604051636b727d4360e11b8152600481018d9052600092506276a70091506001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000169063d6e4fa8690602401602060405180830381865afa158015610dc0573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610de491906158e9565b610dee9190615918565b9050610e0187878761ffff1684886138ca565b50630a85bd0160e11b9c9b505050505050505050505050565b610e22613a30565b600580546001600160a01b0319166001600160a01b0392909216919091179055565b81610e4f8133611775565b610e755760405163168ab55d60e31b81526004810182905233602482015260440161088a565b8260086000610e83836108cf565b5091505063ffffffff8282161615610eb15760405163a2a7201360e01b81526004810184905260240161088a565b604051630c4b7b8560e11b8152600481018790526001600160a01b0386811660248301527f00000000000000000000000000000000000000000000000000000000000000001690631896f70a90604401610bce565b60066020526000908152604090208054610f1f90615940565b80601f0160208091040260200160405190810160405280929190818152602001828054610f4b90615940565b8015610f985780601f10610f6d57610100808354040283529160200191610f98565b820191906000526020600020905b815481529060010190602001808311610f7b57829003601f168201915b505050505081565b600087610fad8133611775565b610fd35760405163168ab55d60e31b81526004810182905233602482015260440161088a565b8751602089012061100b8a82604080516020808201949094528082019290925280518083038201815260609092019052805191012090565b92506110178a84613a8a565b6110218386613bc9565b61102c8a848b613bfc565b506110398a848787613cc9565b935061104483613d0f565b6110fa576040516305ef2c7f60e41b8152600481018b9052602481018290523060448201526001600160a01b03888116606483015267ffffffffffffffff881660848301527f00000000000000000000000000000000000000000000000000000000000000001690635ef2c7f09060a401600060405180830381600087803b1580156110cf57600080fd5b505af11580156110e3573d6000803e3d6000fd5b505050506110f58a848b8b8989613dc8565b6111a7565b6040516305ef2c7f60e41b8152600481018b9052602481018290523060448201526001600160a01b03888116606483015267ffffffffffffffff881660848301527f00000000000000000000000000000000000000000000000000000000000000001690635ef2c7f09060a401600060405180830381600087803b15801561118157600080fd5b505af1158015611195573d6000803e3d6000fd5b505050506111a78a848b8b8989613dff565b5050979650505050505050565b815183511461122b5760405162461bcd60e51b815260206004820152602860248201527f455243313135353a2069647320616e6420616d6f756e7473206c656e6774682060448201527f6d69736d61746368000000000000000000000000000000000000000000000000606482015260840161088a565b6001600160a01b03841661128f5760405162461bcd60e51b815260206004820152602560248201527f455243313135353a207472616e7366657220746f20746865207a65726f206164604482015264647265737360d81b606482015260840161088a565b6001600160a01b0385163314806112c957506001600160a01b038516600090815260026020908152604080832033845290915290205460ff165b61133b5760405162461bcd60e51b815260206004820152603260248201527f455243313135353a207472616e736665722063616c6c6572206973206e6f742060448201527f6f776e6572206e6f7220617070726f7665640000000000000000000000000000606482015260840161088a565b60005b835181101561147157600084828151811061135b5761135b61597a565b6020026020010151905060008483815181106113795761137961597a565b602002602001015190506000806000611391856108cf565b9250925092506113a2858383613ec3565b8360011480156113c357508a6001600160a01b0316836001600160a01b0316145b6114225760405162461bcd60e51b815260206004820152602a60248201527f455243313135353a20696e73756666696369656e742062616c616e636520666f60448201526939103a3930b739b332b960b11b606482015260840161088a565b60008581526001602052604090206001600160a01b038b1663ffffffff60a01b60a085901b16176001600160c01b031960c084901b1617905550505050508061146a90615990565b905061133e565b50836001600160a01b0316856001600160a01b0316336001600160a01b03167f4a39dc06d4c0dbc64b70af90fd698a233a518aa5d07e595d983b8c0526c8f7fb86866040516114c19291906159a9565b60405180910390a46114d7338686868686613fb0565b5050505050565b604080516020808201879052818301869052825180830384018152606090920190925280519101206115108184613bc9565b6000808061151d846108cf565b919450925090506001600160a01b03831615806115cc57506040516302571be360e01b81526004810185905230906001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016906302571be390602401602060405180830381865afa15801561159c573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906115c091906159d7565b6001600160a01b031614155b156115ea57604051635374b59960e01b815260040160405180910390fd5b6000806115f68a6108cf565b90935091508a90506116375761160c8633611775565b6116325760405163168ab55d60e31b81526004810187905233602482015260440161088a565b611667565b6116418a33611775565b6116675760405163168ab55d60e31b8152600481018b905233602482015260440161088a565b611672868984614155565b61167d878483614190565b9650620100008416158015906116a157508363ffffffff1688851763ffffffff1614155b156116c25760405163a2a7201360e01b81526004810187905260240161088a565b96831796610bfc86868a868b6141da565b6000826116e08133611775565b6117065760405163168ab55d60e31b81526004810182905233602482015260440161088a565b8360026000611714836108cf565b5091505063ffffffff82821616156117425760405163a2a7201360e01b81526004810184905260240161088a565b6000808061174f8a6108cf565b9250925092506117688a84848c61ffff161784856141da565b5098975050505050505050565b6000808080611783866108cf565b925092509250846001600160a01b0316836001600160a01b03161480610a6057506001600160a01b0380841660009081526002602090815260408083209389168352929052205460ff16610a60565b6060815183511461184b5760405162461bcd60e51b815260206004820152602960248201527f455243313135353a206163636f756e747320616e6420696473206c656e67746860448201527f206d69736d617463680000000000000000000000000000000000000000000000606482015260840161088a565b6000835167ffffffffffffffff81111561186757611867614f53565b604051908082528060200260200182016040528015611890578160200160208202803683370190505b50905060005b8451811015611908576118db8582815181106118b4576118b461597a565b60200260200101518583815181106118ce576118ce61597a565b6020026020010151610810565b8282815181106118ed576118ed61597a565b602090810291909101015261190181615990565b9050611896565b509392505050565b611918613a30565b6040517fa9059cbb0000000000000000000000000000000000000000000000000000000081526001600160a01b0383811660048301526024820183905284169063a9059cbb906044016020604051808303816000875af1158015611980573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906119a491906159f4565b50505050565b60006108c982614284565b604080516020808201869052818301859052825180830384018152606090920190925280519101206000906119e981613d0f565b611a0657604051635374b59960e01b815260040160405180910390fd5b6000611a1286336109e3565b905080158015611a295750611a278233611775565b155b15611a505760405163168ab55d60e31b81526004810183905233602482015260440161088a565b60008080611a5d856108cf565b92509250925083158015611a745750620400008216155b15611a955760405163a2a7201360e01b81526004810186905260240161088a565b6000611aa08a6108cf565b92505050611aaf888383614190565b9750611abd8685858b61429a565b60405167ffffffffffffffff8916815286907ff675815a0817338f93a7da433f6bd5f5542f1029b11b455191ac96c7f6a9b1329060200160405180910390a2509598975050505050505050565b611b12613a30565b611b1c60006142e2565b565b604080517f93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae60208083019190915281830186905282518083038401815260609092019092528051910120611b728133611775565b611b985760405163168ab55d60e31b81526004810182905233602482015260440161088a565b306001600160a01b03841603611bcc57604051632ca49b0d60e11b81526001600160a01b038416600482015260240161088a565b604080517f93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae60208083019190915281830187905282518083038401815260609092019092528051910120611c21905b83614332565b6040517f42842e0e0000000000000000000000000000000000000000000000000000000081523060048201526001600160a01b038481166024830152604482018690527f000000000000000000000000000000000000000000000000000000000000000016906342842e0e90606401600060405180830381600087803b158015611caa57600080fd5b505af1158015611cbe573d6000803e3d6000fd5b5050505050505050565b6000808686604051611cdb929190615a11565b6040519081900381206331a9108f60e11b82526004820181905291506000907f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031690636352211e90602401602060405180830381865afa158015611d4b573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611d6f91906159d7565b90506001600160a01b0381163314801590611e17575060405163e985e9c560e01b81526001600160a01b0382811660048301523360248301527f0000000000000000000000000000000000000000000000000000000000000000169063e985e9c590604401602060405180830381865afa158015611df1573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611e1591906159f4565b155b15611e8757604080517f93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae6020808301919091528183018590528251808303840181526060830193849052805191012063168ab55d60e31b909252606481019190915233608482015260a40161088a565b6040517f23b872dd0000000000000000000000000000000000000000000000000000000081526001600160a01b038281166004830152306024830152604482018490527f000000000000000000000000000000000000000000000000000000000000000016906323b872dd90606401600060405180830381600087803b158015611f1057600080fd5b505af1158015611f24573d6000803e3d6000fd5b5050604051630a3b53db60e21b8152600481018590523060248201527f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031692506328ed4f6c9150604401600060405180830381600087803b158015611f9057600080fd5b505af1158015611fa4573d6000803e3d6000fd5b5050604051636b727d4360e11b8152600481018590526276a70092507f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316915063d6e4fa8690602401602060405180830381865afa158015612012573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061203691906158e9565b6120409190615918565b925061208988888080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920191909152508a9250505061ffff881686886138ca565b505095945050505050565b6001600160a01b03821633036121125760405162461bcd60e51b815260206004820152602960248201527f455243313135353a2073657474696e6720617070726f76616c2073746174757360448201527f20666f722073656c660000000000000000000000000000000000000000000000606482015260840161088a565b3360008181526002602090815260408083206001600160a01b03871680855290835292819020805460ff191686151590811790915590519081529192917f17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31910160405180910390a35050565b3360009081526004602052604081205460ff166121ee5760405162461bcd60e51b815260206004820152602860248201527f436f6e74726f6c6c61626c653a2043616c6c6572206973206e6f74206120636f604482015267373a3937b63632b960c11b606482015260840161088a565b60008787604051612200929190615a11565b6040519081900381207ffca247ac000000000000000000000000000000000000000000000000000000008252600482018190523060248301526044820187905291507f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03169063fca247ac906064016020604051808303816000875af1158015612295573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906122b991906158e9565b915061230e88888080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920191909152508a9250505061ffff86166123086276a70087615918565b886138ca565b509695505050505050565b600080612325846108cf565b50841663ffffffff908116908516149250505092915050565b612346613a30565b6007546001600160a01b0316156124665760075460405163a22cb46560e01b81526001600160a01b039182166004820152600060248201527f00000000000000000000000000000000000000000000000000000000000000009091169063a22cb46590604401600060405180830381600087803b1580156123c657600080fd5b505af11580156123da573d6000803e3d6000fd5b505060075460405163a22cb46560e01b81526001600160a01b039182166004820152600060248201527f0000000000000000000000000000000000000000000000000000000000000000909116925063a22cb4659150604401600060405180830381600087803b15801561244d57600080fd5b505af1158015612461573d6000803e3d6000fd5b505050505b600780546001600160a01b0319166001600160a01b038316908117909155156125935760075460405163a22cb46560e01b81526001600160a01b039182166004820152600160248201527f00000000000000000000000000000000000000000000000000000000000000009091169063a22cb46590604401600060405180830381600087803b1580156124f857600080fd5b505af115801561250c573d6000803e3d6000fd5b505060075460405163a22cb46560e01b81526001600160a01b039182166004820152600160248201527f0000000000000000000000000000000000000000000000000000000000000000909116925063a22cb4659150604401600060405180830381600087803b15801561257f57600080fd5b505af11580156114d7573d6000803e3d6000fd5b50565b3360009081526004602052604081205460ff166126065760405162461bcd60e51b815260206004820152602860248201527f436f6e74726f6c6c61626c653a2043616c6c6572206973206e6f74206120636f604482015267373a3937b63632b960c11b606482015260840161088a565b604080517f93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae602080830191909152818301869052825180830384018152606090920190925280519101206000906040517fc475abff00000000000000000000000000000000000000000000000000000000815260048101869052602481018590529091506000906001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000169063c475abff906044016020604051808303816000875af11580156126e0573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061270491906158e9565b6040516331a9108f60e11b8152600481018790529091507f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031690636352211e90602401602060405180830381865afa925050508015612788575060408051601f3d908101601f19168201909252612785918101906159d7565b60015b6127955791506108c99050565b6001600160a01b0381163014158061283f57506040516302571be360e01b81526004810184905230906001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016906302571be390602401602060405180830381865afa15801561280f573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061283391906159d7565b6001600160a01b031614155b1561284e575091506108c99050565b50600061285e6276a70083615918565b60008481526001602052604090205490915060a081901c6128818583838661429a565b50919695505050505050565b60008661289a8133611775565b6128c05760405163168ab55d60e31b81526004810182905233602482015260440161088a565b600087876040516128d2929190615a11565b6040518091039020905061290d8982604080516020808201949094528082019290925280518083038201815260609092019052805191012090565b92506129198984613a8a565b6129238386613bc9565b60006129668a858b8b8080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250613bfc92505050565b90506129748a858888613cc9565b945061297f84613d0f565b612a47576040517f06ab5923000000000000000000000000000000000000000000000000000000008152600481018b9052602481018390523060448201527f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316906306ab5923906064016020604051808303816000875af1158015612a10573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612a3491906158e9565b50612a428482898989614424565b612a8d565b612a8d8a858b8b8080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920191909152508d92508c91508b9050613dff565b5050509695505050505050565b6000612ae0600086868080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201919091525092939250506144669050565b6007549091506001600160a01b0316612b25576040517f24c1d6d400000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b612b2f8133611775565b612b555760405163168ab55d60e31b81526004810182905233602482015260440161088a565b60008080612b62846108cf565b919450925090506000612b7485610958565b9050612b7f85614525565b600760009054906101000a90046001600160a01b03166001600160a01b0316639198c2768a8a878787878e8e6040518963ffffffff1660e01b8152600401612bce989796959493929190615a4a565b600060405180830381600087803b158015612be857600080fd5b505af1158015612bfc573d6000803e3d6000fd5b50505050505050505050505050565b83612c168133611775565b612c3c5760405163168ab55d60e31b81526004810182905233602482015260440161088a565b84601c6000612c4a836108cf565b5091505063ffffffff8282161615612c785760405163a2a7201360e01b81526004810184905260240161088a565b6040517fcf408823000000000000000000000000000000000000000000000000000000008152600481018990523060248201526001600160a01b03878116604483015267ffffffffffffffff871660648301527f0000000000000000000000000000000000000000000000000000000000000000169063cf40882390608401600060405180830381600087803b158015612d1157600080fd5b505af1158015612d25573d6000803e3d6000fd5b5050506001600160a01b0388169050612d8c576000612d43896108cf565b509150506201ffff1962020000821601612d7b57604051632ca49b0d60e11b81526001600160a01b038916600482015260240161088a565b612d86896000614332565b50611cbe565b6000612d97896119aa565b9050612db981898b60001c6001604051806020016040528060008152506145e7565b505050505050505050565b60408051602080820186905281830185905282518083038401815260609092019092528051910120612df68133611775565b612e1c5760405163168ab55d60e31b81526004810182905233602482015260440161088a565b7f6c32148f748aba23997146d7fe89e962e3cc30271290fb96f5f4337756c03b528401612e5c5760405163615a470360e01b815260040160405180910390fd5b6001600160a01b0382161580612e7a57506001600160a01b03821630145b15612ea357604051632ca49b0d60e11b81526001600160a01b038316600482015260240161088a565b604080516020808201879052818301869052825180830384018152606090920190925280519101206119a490611c1b565b604080516020808201859052818301849052825180830384018152606090920190925280519101206000906000612f0a82613d0f565b90507f93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae8514612f3c5791506108c99050565b6040516331a9108f60e11b8152600481018590527f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031690636352211e90602401602060405180830381865afa925050508015612fbd575060408051601f3d908101601f19168201909252612fba918101906159d7565b60015b612fcc576000925050506108c9565b6001600160a01b0316301492506108c9915050565b612fe9613a30565b6001600160a01b038216600081815260046020908152604091829020805460ff191685151590811790915591519182527f4c97694570a07277810af7e5669ffd5f6a2d6b74b6e9a274b8b870fd5114cf8791015b60405180910390a25050565b600080613090600087878080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201919091525092939250506147399050565b9150915060006130d98288888080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201919091525092939250506144669050565b604080516020808201849052818301879052825180830384018152606090920190925280519101209091506000906000818152600660205260409020909150613123888a83615af9565b507f6c32148f748aba23997146d7fe89e962e3cc30271290fb96f5f4337756c03b5282016131645760405163615a470360e01b815260040160405180910390fd5b6040516302571be360e01b8152600481018290526000907f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316906302571be390602401602060405180830381865afa1580156131cc573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906131f091906159d7565b90506001600160a01b0381163314801590613298575060405163e985e9c560e01b81526001600160a01b0382811660048301523360248301527f0000000000000000000000000000000000000000000000000000000000000000169063e985e9c590604401602060405180830381865afa158015613272573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061329691906159f4565b155b156132bf5760405163168ab55d60e31b81526004810183905233602482015260440161088a565b6001600160a01b0386161561335157604051630c4b7b8560e11b8152600481018390526001600160a01b0387811660248301527f00000000000000000000000000000000000000000000000000000000000000001690631896f70a90604401600060405180830381600087803b15801561333857600080fd5b505af115801561334c573d6000803e3d6000fd5b505050505b604051635b0fc9c360e01b8152600481018390523060248201527f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031690635b0fc9c390604401600060405180830381600087803b1580156133b957600080fd5b505af11580156133cd573d6000803e3d6000fd5b50505050612db9828a8a8080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201829052508d93509150819050614424565b6001600160a01b0384166134785760405162461bcd60e51b815260206004820152602560248201527f455243313135353a207472616e7366657220746f20746865207a65726f206164604482015264647265737360d81b606482015260840161088a565b6001600160a01b0385163314806134b257506001600160a01b038516600090815260026020908152604080832033845290915290205460ff165b6135245760405162461bcd60e51b815260206004820152602960248201527f455243313135353a2063616c6c6572206973206e6f74206f776e6572206e6f7260448201527f20617070726f7665640000000000000000000000000000000000000000000000606482015260840161088a565b6114d785858585856145e7565b613539613a30565b6001600160a01b0381166135b55760405162461bcd60e51b815260206004820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201527f6464726573730000000000000000000000000000000000000000000000000000606482015260840161088a565b612593816142e2565b600081815260066020526040812080548291906135da90615940565b80601f016020809104026020016040519081016040528092919081815260200182805461360690615940565b80156136535780601f1061362857610100808354040283529160200191613653565b820191906000526020600020905b81548152906001019060200180831161363657829003601f168201915b50505050509050805160000361366c5750600092915050565b6000806136798382614739565b9092509050600061368a8483614466565b9050610a738184612ed4565b600080428367ffffffffffffffff1610156136c45761ffff19620100008516016136bf57600094505b600093505b50929391925050565b60006001600160e01b031982167fd9b67a2600000000000000000000000000000000000000000000000000000000148061371757506001600160e01b031982166303a24d0760e21b145b806108c957507f01ffc9a7000000000000000000000000000000000000000000000000000000006001600160e01b03198316146108c9565b600061375a826119aa565b9050806001600160a01b0316836001600160a01b0316036137e35760405162461bcd60e51b815260206004820152602160248201527f4552433732313a20617070726f76616c20746f2063757272656e74206f776e6560448201527f7200000000000000000000000000000000000000000000000000000000000000606482015260840161088a565b336001600160a01b038216148061381d57506001600160a01b038116600090815260026020908152604080832033845290915290205460ff165b61388f5760405162461bcd60e51b815260206004820152603d60248201527f4552433732313a20617070726f76652063616c6c6572206973206e6f7420746f60448201527f6b656e206f776e6572206f7220617070726f76656420666f7220616c6c000000606482015260840161088a565b6109de83836147f0565b6000620200008381161480156109965750426138b86276a70084615bb9565b67ffffffffffffffff16109392505050565b8451602086012060006139247f93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae83604080516020808201949094528082019290925280518083038201815260609092019052805191012090565b90506000613967886040518060400160405280600581526020017f036574680000000000000000000000000000000000000000000000000000000081525061485e565b60008381526006602052604090209091506139828282615bda565b50613995828289620300008a1789614424565b6001600160a01b03841615611cbe57604051630c4b7b8560e11b8152600481018390526001600160a01b0385811660248301527f00000000000000000000000000000000000000000000000000000000000000001690631896f70a90604401600060405180830381600087803b158015613a0e57600080fd5b505af1158015613a22573d6000803e3d6000fd5b505050505050505050505050565b6000546001600160a01b03163314611b1c5760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572604482015260640161088a565b60008080613a97846108cf565b919450925090504267ffffffffffffffff821610808015613b5b57506001600160a01b0384161580613b5b57506040516302571be360e01b8152600481018690526000906001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016906302571be390602401602060405180830381865afa158015613b2c573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190613b5091906159d7565b6001600160a01b0316145b15613b9a576000613b6b876108cf565b509150506020811615613b945760405163a2a7201360e01b81526004810187905260240161088a565b50613bc1565b62010000831615613bc15760405163a2a7201360e01b81526004810186905260240161088a565b505050505050565b63fffdffff81811763ffffffff1614613bf85760405163a2a7201360e01b81526004810183905260240161088a565b5050565b60606000613ca583600660008881526020019081526020016000208054613c2290615940565b80601f0160208091040260200160405190810160405280929190818152602001828054613c4e90615940565b8015613c9b5780601f10613c7057610100808354040283529160200191613c9b565b820191906000526020600020905b815481529060010190602001808311613c7e57829003601f168201915b505050505061485e565b6000858152600660205260409020909150613cc08282615bda565b50949350505050565b600080613cd5856108cf565b92505050600080613ce88860001c6108cf565b9250925050613cf8878784614155565b613d03858483614190565b98975050505050505050565b600080613d1b836119aa565b6001600160a01b0316141580156108c957506040516302571be360e01b81526004810183905230906001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016906302571be390602401602060405180830381865afa158015613d94573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190613db891906159d7565b6001600160a01b03161492915050565b60008681526006602052604081208054613de7918791613c2290615940565b9050613df68682868686614424565b50505050505050565b60008080613e0c886108cf565b9250925092506000613e3688600660008d81526020019081526020016000208054613c2290615940565b60008a8152600660205260409020805491925090613e5390615940565b9050600003613e76576000898152600660205260409020613e748282615bda565b505b613e85898588861785896141da565b6001600160a01b038716613ea357613e9e896000614332565b610bfc565b610bfc84888b60001c6001604051806020016040528060008152506145e7565b6201ffff1962020000831601613ee357613ee06276a70082615bb9565b90505b428167ffffffffffffffff161015613f605762010000821615613f5b5760405162461bcd60e51b815260206004820152602a60248201527f455243313135353a20696e73756666696369656e742062616c616e636520666f60448201526939103a3930b739b332b960b11b606482015260840161088a565b613f85565b6004821615613f855760405163a2a7201360e01b81526004810184905260240161088a565b604082166000036109de575050600090815260036020526040902080546001600160a01b0319169055565b6001600160a01b0384163b15613bc15760405163bc197c8160e01b81526001600160a01b0385169063bc197c8190613ff49089908990889088908890600401615c9a565b6020604051808303816000875af192505050801561402f575060408051601f3d908101601f1916820190925261402c91810190615cec565b60015b6140e45761403b615d09565b806308c379a003614074575061404f615d25565b8061405a5750614076565b8060405162461bcd60e51b815260040161088a9190614dee565b505b60405162461bcd60e51b815260206004820152603460248201527f455243313135353a207472616e7366657220746f206e6f6e204552433131353560448201527f526563656976657220696d706c656d656e746572000000000000000000000000606482015260840161088a565b6001600160e01b0319811663bc197c8160e01b14613df65760405162461bcd60e51b815260206004820152602860248201527f455243313135353a204552433131353552656365697665722072656a656374656044820152676420746f6b656e7360c01b606482015260840161088a565b63ffff0000821615801590600183161590829061416f5750805b156114d75760405163a2a7201360e01b81526004810186905260240161088a565b60008167ffffffffffffffff168467ffffffffffffffff1611156141b2578193505b8267ffffffffffffffff168467ffffffffffffffff1610156141d2578293505b509192915050565b6141e68585858461429a565b60405163ffffffff8416815285907f39873f00c80f4f94b7bd1594aebcf650f003545b74824d57ddf4939e3ff3a34b9060200160405180910390a28167ffffffffffffffff168167ffffffffffffffff1611156114d75760405167ffffffffffffffff8216815285907ff675815a0817338f93a7da433f6bd5f5542f1029b11b455191ac96c7f6a9b132906020015b60405180910390a25050505050565b600080614290836108cf565b5090949350505050565b6142a48483614907565b60008481526001602052604090206001600160a01b03841663ffffffff60a01b60a085901b16176001600160c01b031960c084901b161790556119a4565b600080546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b61433d826001612319565b1561435e5760405163a2a7201360e01b81526004810183905260240161088a565b61436782614525565b604051635b0fc9c360e01b8152600481018390526001600160a01b0382811660248301527f00000000000000000000000000000000000000000000000000000000000000001690635b0fc9c390604401600060405180830381600087803b1580156143d157600080fd5b505af11580156143e5573d6000803e3d6000fd5b50506040516001600160a01b03841681528492507fee2ba1195c65bcf218a83d874335c6bf9d9067b4c672f3c3bf16cf40de7586c4915060200161303d565b61443085848484614940565b847f8ce7013e8abebc55c3890a68f5a27c67c3f7efa64e584de5fb22363c606fd340858585856040516142759493929190615daf565b60008060006144758585614739565b9092509050816144e7576001855161448d9190615df7565b84146144db5760405162461bcd60e51b815260206004820152601d60248201527f6e616d65686173683a204a756e6b20617420656e64206f66206e616d65000000604482015260640161088a565b50600091506108c99050565b6144f18582614466565b6040805160208101929092528101839052606001604051602081830303815290604052805190602001209250505092915050565b60008181526001602052604090205460a081901c60c082901c614549838383613696565b600086815260036020908152604080832080546001600160a01b03191690556001909152902063ffffffff60a01b60a083901b166001600160c01b031960c086901b1617905592506145989050565b60408051858152600160208201526000916001600160a01b0386169133917fc3d58168c5ae7397731d063d5bbf3d657854427343f4c083240f7aacaa2d0f62910160405180910390a450505050565b60008060006145f5866108cf565b925092509250614606868383613ec3565b8460011480156146275750876001600160a01b0316836001600160a01b0316145b6146865760405162461bcd60e51b815260206004820152602a60248201527f455243313135353a20696e73756666696369656e742062616c616e636520666f60448201526939103a3930b739b332b960b11b606482015260840161088a565b866001600160a01b0316836001600160a01b0316036146a7575050506114d7565b60008681526001602052604090206001600160a01b03881663ffffffff60a01b60a085901b16176001600160c01b031960c084901b1617905560408051878152602081018790526001600160a01b03808a1692908b169133917fc3d58168c5ae7397731d063d5bbf3d657854427343f4c083240f7aacaa2d0f62910160405180910390a4611cbe3389898989896149b4565b6000808351831061478c5760405162461bcd60e51b815260206004820152601e60248201527f726561644c6162656c3a20496e646578206f7574206f6620626f756e64730000604482015260640161088a565b60008484815181106147a0576147a061597a565b016020015160f81c905080156147cc576147c5856147bf866001615e0a565b83614ab0565b92506147d1565b600092505b6147db8185615e0a565b6147e6906001615e0a565b9150509250929050565b600081815260036020526040902080546001600160a01b0319166001600160a01b0384169081179091558190614825826119aa565b6001600160a01b03167f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b92560405160405180910390a45050565b606060018351101561489c576040517f280dacb600000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60ff835111156148da57826040517fe3ba295f00000000000000000000000000000000000000000000000000000000815260040161088a9190614dee565b825183836040516020016148f093929190615e1d565b604051602081830303815290604052905092915050565b61ffff81161580159061491f57506201000181811614155b15613bf85760405163a2a7201360e01b81526004810183905260240161088a565b61494a8483614907565b6000848152600160205260409020546001600160a01b038116156149a85761497185614525565b6040516000815285907fee2ba1195c65bcf218a83d874335c6bf9d9067b4c672f3c3bf16cf40de7586c49060200160405180910390a25b6114d785858585614ad4565b6001600160a01b0384163b15613bc15760405163f23a6e6160e01b81526001600160a01b0385169063f23a6e61906149f89089908990889088908890600401615e7e565b6020604051808303816000875af1925050508015614a33575060408051601f3d908101601f19168201909252614a3091810190615cec565b60015b614a3f5761403b615d09565b6001600160e01b0319811663f23a6e6160e01b14613df65760405162461bcd60e51b815260206004820152602860248201527f455243313135353a204552433131353552656365697665722072656a656374656044820152676420746f6b656e7360c01b606482015260840161088a565b8251600090614abf8385615e0a565b1115614aca57600080fd5b5091016020012090565b8360008080614ae2846108cf565b9194509250905063ffff0000821667ffffffffffffffff8087169083161115614b09578195505b428267ffffffffffffffff1610614b1f57958617955b6001600160a01b03841615614b765760405162461bcd60e51b815260206004820152601f60248201527f455243313135353a206d696e74206f66206578697374696e6720746f6b656e00604482015260640161088a565b6001600160a01b038816614bf25760405162461bcd60e51b815260206004820152602160248201527f455243313135353a206d696e7420746f20746865207a65726f2061646472657360448201527f7300000000000000000000000000000000000000000000000000000000000000606482015260840161088a565b306001600160a01b03891603614c705760405162461bcd60e51b815260206004820152603460248201527f455243313135353a206e65774f776e65722063616e6e6f74206265207468652060448201527f4e616d655772617070657220636f6e7472616374000000000000000000000000606482015260840161088a565b60008581526001602052604090206001600160a01b03891663ffffffff60a01b60a08a901b16176001600160c01b031960c089901b1617905560408051868152600160208201526001600160a01b038a169160009133917fc3d58168c5ae7397731d063d5bbf3d657854427343f4c083240f7aacaa2d0f62910160405180910390a4612db93360008a886001604051806020016040528060008152506149b4565b6001600160a01b038116811461259357600080fd5b60008060408385031215614d3957600080fd5b8235614d4481614d11565b946020939093013593505050565b600060208284031215614d6457600080fd5b5035919050565b6001600160e01b03198116811461259357600080fd5b600060208284031215614d9357600080fd5b813561099681614d6b565b60005b83811015614db9578181015183820152602001614da1565b50506000910152565b60008151808452614dda816020860160208601614d9e565b601f01601f19169290920160200192915050565b6020815260006109966020830184614dc2565b60008060408385031215614e1457600080fd5b823591506020830135614e2681614d11565b809150509250929050565b803567ffffffffffffffff81168114614e4957600080fd5b919050565b60008060408385031215614e6157600080fd5b82359150614e7160208401614e31565b90509250929050565b60008083601f840112614e8c57600080fd5b50813567ffffffffffffffff811115614ea457600080fd5b602083019150836020828501011115614ebc57600080fd5b9250929050565b600080600080600060808688031215614edb57600080fd5b8535614ee681614d11565b94506020860135614ef681614d11565b935060408601359250606086013567ffffffffffffffff811115614f1957600080fd5b614f2588828901614e7a565b969995985093965092949392505050565b600060208284031215614f4857600080fd5b813561099681614d11565b634e487b7160e01b600052604160045260246000fd5b601f8201601f1916810167ffffffffffffffff81118282101715614f8f57614f8f614f53565b6040525050565b600067ffffffffffffffff821115614fb057614fb0614f53565b50601f01601f191660200190565b600082601f830112614fcf57600080fd5b8135614fda81614f96565b604051614fe78282614f69565b828152856020848701011115614ffc57600080fd5b82602086016020830137600092810160200192909252509392505050565b803563ffffffff81168114614e4957600080fd5b600080600080600080600060e0888a03121561504957600080fd5b87359650602088013567ffffffffffffffff81111561506757600080fd5b6150738a828b01614fbe565b965050604088013561508481614d11565b9450606088013561509481614d11565b93506150a260808901614e31565b92506150b060a0890161501a565b91506150be60c08901614e31565b905092959891949750929550565b600067ffffffffffffffff8211156150e6576150e6614f53565b5060051b60200190565b600082601f83011261510157600080fd5b8135602061510e826150cc565b60405161511b8282614f69565b83815260059390931b850182019282810191508684111561513b57600080fd5b8286015b8481101561230e578035835291830191830161513f565b600080600080600060a0868803121561516e57600080fd5b853561517981614d11565b9450602086013561518981614d11565b9350604086013567ffffffffffffffff808211156151a657600080fd5b6151b289838a016150f0565b945060608801359150808211156151c857600080fd5b6151d489838a016150f0565b935060808801359150808211156151ea57600080fd5b506151f788828901614fbe565b9150509295509295909350565b6000806000806080858703121561521a57600080fd5b84359350602085013592506152316040860161501a565b915061523f60608601614e31565b905092959194509250565b803561ffff81168114614e4957600080fd5b6000806040838503121561526f57600080fd5b82359150614e716020840161524a565b6000806040838503121561529257600080fd5b823567ffffffffffffffff808211156152aa57600080fd5b818501915085601f8301126152be57600080fd5b813560206152cb826150cc565b6040516152d88282614f69565b83815260059390931b85018201928281019150898411156152f857600080fd5b948201945b8386101561531f57853561531081614d11565b825294820194908201906152fd565b9650508601359250508082111561533557600080fd5b506147e6858286016150f0565b600081518084526020808501945080840160005b8381101561537257815187529582019590820190600101615356565b509495945050505050565b6020815260006109966020830184615342565b6000806000606084860312156153a557600080fd5b83356153b081614d11565b925060208401356153c081614d11565b929592945050506040919091013590565b6000806000606084860312156153e657600080fd5b83359250602084013591506153fd60408501614e31565b90509250925092565b60008060006060848603121561541b57600080fd5b83359250602084013561542d81614d11565b9150604084013561543d81614d11565b809150509250925092565b60008060008060006080868803121561546057600080fd5b853567ffffffffffffffff81111561547757600080fd5b61548388828901614e7a565b909650945050602086013561549781614d11565b92506154a56040870161524a565b915060608601356154b581614d11565b809150509295509295909350565b801515811461259357600080fd5b600080604083850312156154e457600080fd5b82356154ef81614d11565b91506020830135614e26816154c3565b60008060008060008060a0878903121561551857600080fd5b863567ffffffffffffffff81111561552f57600080fd5b61553b89828a01614e7a565b909750955050602087013561554f81614d11565b935060408701359250606087013561556681614d11565b91506155746080880161524a565b90509295509295509295565b6000806040838503121561559357600080fd5b82359150614e716020840161501a565b600080604083850312156155b657600080fd5b50508035926020909101359150565b60008060008060008060a087890312156155de57600080fd5b86359550602087013567ffffffffffffffff8111156155fc57600080fd5b61560889828a01614e7a565b909650945050604087013561561c81614d11565b925061562a6060880161501a565b915061557460808801614e31565b6000806000806040858703121561564e57600080fd5b843567ffffffffffffffff8082111561566657600080fd5b61567288838901614e7a565b9096509450602087013591508082111561568b57600080fd5b5061569887828801614e7a565b95989497509550505050565b600080600080608085870312156156ba57600080fd5b8435935060208501356156cc81614d11565b9250604085013561523181614d11565b6000806000606084860312156156f157600080fd5b8335925060208401359150604084013561543d81614d11565b6000806040838503121561571d57600080fd5b823561572881614d11565b91506020830135614e2681614d11565b6000806000806060858703121561574e57600080fd5b843567ffffffffffffffff81111561576557600080fd5b61577187828801614e7a565b909550935050602085013561578581614d11565b9150604085013561579581614d11565b939692955090935050565b600080600080600060a086880312156157b857600080fd5b85356157c381614d11565b945060208601356157d381614d11565b93506040860135925060608601359150608086013567ffffffffffffffff8111156157fd57600080fd5b6151f788828901614fbe565b60006020828403121561581b57600080fd5b815167ffffffffffffffff81111561583257600080fd5b8201601f8101841361584357600080fd5b805161584e81614f96565b60405161585b8282614f69565b82815286602084860101111561587057600080fd5b610a73836020830160208701614d9e565b6000806000806080858703121561589757600080fd5b843567ffffffffffffffff8111156158ae57600080fd5b6158ba87828801614fbe565b94505060208501356158cb81614d11565b92506158d96040860161524a565b9150606085013561579581614d11565b6000602082840312156158fb57600080fd5b5051919050565b634e487b7160e01b600052601160045260246000fd5b67ffffffffffffffff81811683821601908082111561593957615939615902565b5092915050565b600181811c9082168061595457607f821691505b60208210810361597457634e487b7160e01b600052602260045260246000fd5b50919050565b634e487b7160e01b600052603260045260246000fd5b6000600182016159a2576159a2615902565b5060010190565b6040815260006159bc6040830185615342565b82810360208401526159ce8185615342565b95945050505050565b6000602082840312156159e957600080fd5b815161099681614d11565b600060208284031215615a0657600080fd5b8151610996816154c3565b8183823760009101908152919050565b81835281816020850137506000828201602090810191909152601f909101601f19169091010190565b60c081526000615a5e60c083018a8c615a21565b6001600160a01b03898116602085015263ffffffff8916604085015267ffffffffffffffff881660608501528616608084015282810360a0840152615aa4818587615a21565b9b9a5050505050505050505050565b601f8211156109de57600081815260208120601f850160051c81016020861015615ada5750805b601f850160051c820191505b81811015613bc157828155600101615ae6565b67ffffffffffffffff831115615b1157615b11614f53565b615b2583615b1f8354615940565b83615ab3565b6000601f841160018114615b595760008515615b415750838201355b600019600387901b1c1916600186901b1783556114d7565b600083815260209020601f19861690835b82811015615b8a5786850135825560209485019460019092019101615b6a565b5086821015615ba75760001960f88860031b161c19848701351681555b505060018560011b0183555050505050565b67ffffffffffffffff82811682821603908082111561593957615939615902565b815167ffffffffffffffff811115615bf457615bf4614f53565b615c0881615c028454615940565b84615ab3565b602080601f831160018114615c3d5760008415615c255750858301515b600019600386901b1c1916600185901b178555613bc1565b600085815260208120601f198616915b82811015615c6c57888601518255948401946001909101908401615c4d565b5085821015615c8a5787850151600019600388901b60f8161c191681555b5050505050600190811b01905550565b60006001600160a01b03808816835280871660208401525060a06040830152615cc660a0830186615342565b8281036060840152615cd88186615342565b90508281036080840152613d038185614dc2565b600060208284031215615cfe57600080fd5b815161099681614d6b565b600060033d1115615d225760046000803e5060005160e01c5b90565b600060443d1015615d335790565b6040516003193d81016004833e81513d67ffffffffffffffff8160248401118184111715615d6357505050505090565b8285019150815181811115615d7b5750505050505090565b843d8701016020828501011115615d955750505050505090565b615da460208286010187614f69565b509095945050505050565b608081526000615dc26080830187614dc2565b6001600160a01b039590951660208301525063ffffffff92909216604083015267ffffffffffffffff16606090910152919050565b818103818111156108c9576108c9615902565b808201808211156108c9576108c9615902565b7fff000000000000000000000000000000000000000000000000000000000000008460f81b16815260008351615e5a816001850160208801614d9e565b835190830190615e71816001840160208801614d9e565b0160010195945050505050565b60006001600160a01b03808816835280871660208401525084604083015283606083015260a06080830152615eb660a0830184614dc2565b97965050505050505056fea26469706673582212204f37b28dc45c53fb37759a47de9637b4ff115b46e39238a82dadf100cccbc4dc64736f6c63430008110033","deployedBytecode":"0x608060405234801561001057600080fd5b506004361061031f5760003560e01c80636352211e116101a7578063c93ab3fd116100ee578063e985e9c511610097578063f242432a11610071578063f242432a146107d7578063f2fde38b146107ea578063fd0cd0d9146107fd57600080fd5b8063e985e9c514610768578063eb8ae530146107a4578063ed70554d146107b757600080fd5b8063d9a50c12116100c8578063d9a50c121461071f578063da8c229e14610732578063e0dba60f1461075557600080fd5b8063c93ab3fd146106e6578063cf408823146106f9578063d8c9921a1461070c57600080fd5b8063a22cb46511610150578063b6bcad261161012a578063b6bcad26146106ad578063c475abff146106c0578063c658e086146106d357600080fd5b8063a22cb46514610674578063a401498214610687578063adf4960a1461069a57600080fd5b80638b4dfa75116101815780638b4dfa751461063d5780638cf8b41e146106505780638da5cb5b1461066357600080fd5b80636352211e146105f65780636e5d6ad214610609578063715018a61461063557600080fd5b80631f4e15041161026b5780633f15457f116102145780634e1273f4116101ee5780634e1273f4146105b057806353095467146105d05780635d3590d5146105e357600080fd5b80633f15457f1461054e578063402906fc1461057557806341415eab1461059d57600080fd5b80632b20e397116102455780632b20e397146105015780632eb2c2d61461052857806333c69ea91461053b57600080fd5b80631f4e1504146104c857806320c38e2b146104db57806324c1af44146104ee57600080fd5b80630e4cd725116102cd578063150b7a02116102a7578063150b7a02146104765780631534e177146104a25780631896f70a146104b557600080fd5b80630e4cd7251461043d5780630e89341c1461045057806314ab90381461046357600080fd5b806306fdde03116102fe57806306fdde03146103b4578063081812fc146103fd578063095ea7b31461042857600080fd5b8062fdd58e146103245780630178fe3f1461034a57806301ffc9a714610391575b600080fd5b610337610332366004614d26565b610810565b6040519081526020015b60405180910390f35b61035d610358366004614d52565b6108cf565b604080516001600160a01b03909416845263ffffffff909216602084015267ffffffffffffffff1690820152606001610341565b6103a461039f366004614d81565b6108ff565b6040519015158152602001610341565b6103f06040518060400160405280600b81526020017f4e616d655772617070657200000000000000000000000000000000000000000081525081565b6040516103419190614dee565b61041061040b366004614d52565b610958565b6040516001600160a01b039091168152602001610341565b61043b610436366004614d26565b61099d565b005b6103a461044b366004614e01565b6109e3565b6103f061045e366004614d52565b610a7d565b61043b610471366004614e4e565b610aef565b610489610484366004614ec3565b610c08565b6040516001600160e01b03199091168152602001610341565b61043b6104b0366004614f36565b610e1a565b61043b6104c3366004614e01565b610e44565b600754610410906001600160a01b031681565b6103f06104e9366004614d52565b610f06565b6103376104fc36600461502e565b610fa0565b6104107f000000000000000000000000000000000000000000000000000000000000000081565b61043b610536366004615156565b6111b4565b61043b610549366004615204565b6114de565b6104107f000000000000000000000000000000000000000000000000000000000000000081565b61058861058336600461525c565b6116d3565b60405163ffffffff9091168152602001610341565b6103a46105ab366004614e01565b611775565b6105c36105be36600461527f565b6117d2565b604051610341919061537d565b600554610410906001600160a01b031681565b61043b6105f1366004615390565b611910565b610410610604366004614d52565b6119aa565b61061c6106173660046153d1565b6119b5565b60405167ffffffffffffffff9091168152602001610341565b61043b611b0a565b61043b61064b366004615406565b611b1e565b61061c61065e366004615448565b611cc8565b6000546001600160a01b0316610410565b61043b6106823660046154d1565b612094565b6103376106953660046154ff565b61217e565b6103a46106a8366004615580565b612319565b61043b6106bb366004614f36565b61233e565b6103376106ce3660046155a3565b612596565b6103376106e13660046155c5565b61288d565b61043b6106f4366004615638565b612a9a565b61043b6107073660046156a4565b612c0b565b61043b61071a3660046156dc565b612dc4565b6103a461072d3660046155a3565b612ed4565b6103a4610740366004614f36565b60046020526000908152604090205460ff1681565b61043b6107633660046154d1565b612fe1565b6103a461077636600461570a565b6001600160a01b03918216600090815260026020908152604080832093909416825291909152205460ff1690565b61043b6107b2366004615738565b613049565b6103376107c5366004614d52565b60016020526000908152604090205481565b61043b6107e53660046157a0565b613414565b61043b6107f8366004614f36565b613531565b6103a461080b366004614d52565b6135be565b60006001600160a01b0383166108935760405162461bcd60e51b815260206004820152602b60248201527f455243313135353a2062616c616e636520717565727920666f7220746865207a60448201527f65726f206164647265737300000000000000000000000000000000000000000060648201526084015b60405180910390fd5b600061089e836119aa565b9050836001600160a01b0316816001600160a01b0316036108c35760019150506108c9565b60009150505b92915050565b60008181526001602052604090205460a081901c60c082901c6108f3838383613696565b90959094509092509050565b60006001600160e01b031982167fd82c42d800000000000000000000000000000000000000000000000000000000148061094957506001600160e01b03198216630a85bd0160e11b145b806108c957506108c9826136cd565b600080610964836119aa565b90506001600160a01b03811661097d5750600092915050565b6000838152600360205260409020546001600160a01b03165b9392505050565b60006109a8826108cf565b50915050603f1960408216016109d45760405163a2a7201360e01b81526004810183905260240161088a565b6109de838361374f565b505050565b60008080806109f1866108cf565b925092509250846001600160a01b0316836001600160a01b03161480610a3c57506001600160a01b0380841660009081526002602090815260408083209389168352929052205460ff165b80610a6057506001600160a01b038516610a5587610958565b6001600160a01b0316145b8015610a735750610a718282613899565b155b9695505050505050565b6005546040516303a24d0760e21b8152600481018390526060916001600160a01b031690630e89341c90602401600060405180830381865afa158015610ac7573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526108c99190810190615809565b81610afa8133611775565b610b205760405163168ab55d60e31b81526004810182905233602482015260440161088a565b8260106000610b2e836108cf565b5091505063ffffffff8282161615610b5c5760405163a2a7201360e01b81526004810184905260240161088a565b6040517f14ab90380000000000000000000000000000000000000000000000000000000081526004810187905267ffffffffffffffff861660248201527f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316906314ab9038906044015b600060405180830381600087803b158015610be857600080fd5b505af1158015610bfc573d6000803e3d6000fd5b50505050505050505050565b6000336001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001614610c6c576040517f1931a53800000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6000808080610c7d86880188615881565b83516020850120939750919550935091508890808214610cd3576040517fc65c3ccc000000000000000000000000000000000000000000000000000000008152600481018290526024810183905260440161088a565b604051630a3b53db60e21b8152600481018390523060248201527f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316906328ed4f6c90604401600060405180830381600087803b158015610d3b57600080fd5b505af1158015610d4f573d6000803e3d6000fd5b5050604051636b727d4360e11b8152600481018d9052600092506276a70091506001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000169063d6e4fa8690602401602060405180830381865afa158015610dc0573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610de491906158e9565b610dee9190615918565b9050610e0187878761ffff1684886138ca565b50630a85bd0160e11b9c9b505050505050505050505050565b610e22613a30565b600580546001600160a01b0319166001600160a01b0392909216919091179055565b81610e4f8133611775565b610e755760405163168ab55d60e31b81526004810182905233602482015260440161088a565b8260086000610e83836108cf565b5091505063ffffffff8282161615610eb15760405163a2a7201360e01b81526004810184905260240161088a565b604051630c4b7b8560e11b8152600481018790526001600160a01b0386811660248301527f00000000000000000000000000000000000000000000000000000000000000001690631896f70a90604401610bce565b60066020526000908152604090208054610f1f90615940565b80601f0160208091040260200160405190810160405280929190818152602001828054610f4b90615940565b8015610f985780601f10610f6d57610100808354040283529160200191610f98565b820191906000526020600020905b815481529060010190602001808311610f7b57829003601f168201915b505050505081565b600087610fad8133611775565b610fd35760405163168ab55d60e31b81526004810182905233602482015260440161088a565b8751602089012061100b8a82604080516020808201949094528082019290925280518083038201815260609092019052805191012090565b92506110178a84613a8a565b6110218386613bc9565b61102c8a848b613bfc565b506110398a848787613cc9565b935061104483613d0f565b6110fa576040516305ef2c7f60e41b8152600481018b9052602481018290523060448201526001600160a01b03888116606483015267ffffffffffffffff881660848301527f00000000000000000000000000000000000000000000000000000000000000001690635ef2c7f09060a401600060405180830381600087803b1580156110cf57600080fd5b505af11580156110e3573d6000803e3d6000fd5b505050506110f58a848b8b8989613dc8565b6111a7565b6040516305ef2c7f60e41b8152600481018b9052602481018290523060448201526001600160a01b03888116606483015267ffffffffffffffff881660848301527f00000000000000000000000000000000000000000000000000000000000000001690635ef2c7f09060a401600060405180830381600087803b15801561118157600080fd5b505af1158015611195573d6000803e3d6000fd5b505050506111a78a848b8b8989613dff565b5050979650505050505050565b815183511461122b5760405162461bcd60e51b815260206004820152602860248201527f455243313135353a2069647320616e6420616d6f756e7473206c656e6774682060448201527f6d69736d61746368000000000000000000000000000000000000000000000000606482015260840161088a565b6001600160a01b03841661128f5760405162461bcd60e51b815260206004820152602560248201527f455243313135353a207472616e7366657220746f20746865207a65726f206164604482015264647265737360d81b606482015260840161088a565b6001600160a01b0385163314806112c957506001600160a01b038516600090815260026020908152604080832033845290915290205460ff165b61133b5760405162461bcd60e51b815260206004820152603260248201527f455243313135353a207472616e736665722063616c6c6572206973206e6f742060448201527f6f776e6572206e6f7220617070726f7665640000000000000000000000000000606482015260840161088a565b60005b835181101561147157600084828151811061135b5761135b61597a565b6020026020010151905060008483815181106113795761137961597a565b602002602001015190506000806000611391856108cf565b9250925092506113a2858383613ec3565b8360011480156113c357508a6001600160a01b0316836001600160a01b0316145b6114225760405162461bcd60e51b815260206004820152602a60248201527f455243313135353a20696e73756666696369656e742062616c616e636520666f60448201526939103a3930b739b332b960b11b606482015260840161088a565b60008581526001602052604090206001600160a01b038b1663ffffffff60a01b60a085901b16176001600160c01b031960c084901b1617905550505050508061146a90615990565b905061133e565b50836001600160a01b0316856001600160a01b0316336001600160a01b03167f4a39dc06d4c0dbc64b70af90fd698a233a518aa5d07e595d983b8c0526c8f7fb86866040516114c19291906159a9565b60405180910390a46114d7338686868686613fb0565b5050505050565b604080516020808201879052818301869052825180830384018152606090920190925280519101206115108184613bc9565b6000808061151d846108cf565b919450925090506001600160a01b03831615806115cc57506040516302571be360e01b81526004810185905230906001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016906302571be390602401602060405180830381865afa15801561159c573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906115c091906159d7565b6001600160a01b031614155b156115ea57604051635374b59960e01b815260040160405180910390fd5b6000806115f68a6108cf565b90935091508a90506116375761160c8633611775565b6116325760405163168ab55d60e31b81526004810187905233602482015260440161088a565b611667565b6116418a33611775565b6116675760405163168ab55d60e31b8152600481018b905233602482015260440161088a565b611672868984614155565b61167d878483614190565b9650620100008416158015906116a157508363ffffffff1688851763ffffffff1614155b156116c25760405163a2a7201360e01b81526004810187905260240161088a565b96831796610bfc86868a868b6141da565b6000826116e08133611775565b6117065760405163168ab55d60e31b81526004810182905233602482015260440161088a565b8360026000611714836108cf565b5091505063ffffffff82821616156117425760405163a2a7201360e01b81526004810184905260240161088a565b6000808061174f8a6108cf565b9250925092506117688a84848c61ffff161784856141da565b5098975050505050505050565b6000808080611783866108cf565b925092509250846001600160a01b0316836001600160a01b03161480610a6057506001600160a01b0380841660009081526002602090815260408083209389168352929052205460ff16610a60565b6060815183511461184b5760405162461bcd60e51b815260206004820152602960248201527f455243313135353a206163636f756e747320616e6420696473206c656e67746860448201527f206d69736d617463680000000000000000000000000000000000000000000000606482015260840161088a565b6000835167ffffffffffffffff81111561186757611867614f53565b604051908082528060200260200182016040528015611890578160200160208202803683370190505b50905060005b8451811015611908576118db8582815181106118b4576118b461597a565b60200260200101518583815181106118ce576118ce61597a565b6020026020010151610810565b8282815181106118ed576118ed61597a565b602090810291909101015261190181615990565b9050611896565b509392505050565b611918613a30565b6040517fa9059cbb0000000000000000000000000000000000000000000000000000000081526001600160a01b0383811660048301526024820183905284169063a9059cbb906044016020604051808303816000875af1158015611980573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906119a491906159f4565b50505050565b60006108c982614284565b604080516020808201869052818301859052825180830384018152606090920190925280519101206000906119e981613d0f565b611a0657604051635374b59960e01b815260040160405180910390fd5b6000611a1286336109e3565b905080158015611a295750611a278233611775565b155b15611a505760405163168ab55d60e31b81526004810183905233602482015260440161088a565b60008080611a5d856108cf565b92509250925083158015611a745750620400008216155b15611a955760405163a2a7201360e01b81526004810186905260240161088a565b6000611aa08a6108cf565b92505050611aaf888383614190565b9750611abd8685858b61429a565b60405167ffffffffffffffff8916815286907ff675815a0817338f93a7da433f6bd5f5542f1029b11b455191ac96c7f6a9b1329060200160405180910390a2509598975050505050505050565b611b12613a30565b611b1c60006142e2565b565b604080517f93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae60208083019190915281830186905282518083038401815260609092019092528051910120611b728133611775565b611b985760405163168ab55d60e31b81526004810182905233602482015260440161088a565b306001600160a01b03841603611bcc57604051632ca49b0d60e11b81526001600160a01b038416600482015260240161088a565b604080517f93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae60208083019190915281830187905282518083038401815260609092019092528051910120611c21905b83614332565b6040517f42842e0e0000000000000000000000000000000000000000000000000000000081523060048201526001600160a01b038481166024830152604482018690527f000000000000000000000000000000000000000000000000000000000000000016906342842e0e90606401600060405180830381600087803b158015611caa57600080fd5b505af1158015611cbe573d6000803e3d6000fd5b5050505050505050565b6000808686604051611cdb929190615a11565b6040519081900381206331a9108f60e11b82526004820181905291506000907f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031690636352211e90602401602060405180830381865afa158015611d4b573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611d6f91906159d7565b90506001600160a01b0381163314801590611e17575060405163e985e9c560e01b81526001600160a01b0382811660048301523360248301527f0000000000000000000000000000000000000000000000000000000000000000169063e985e9c590604401602060405180830381865afa158015611df1573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611e1591906159f4565b155b15611e8757604080517f93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae6020808301919091528183018590528251808303840181526060830193849052805191012063168ab55d60e31b909252606481019190915233608482015260a40161088a565b6040517f23b872dd0000000000000000000000000000000000000000000000000000000081526001600160a01b038281166004830152306024830152604482018490527f000000000000000000000000000000000000000000000000000000000000000016906323b872dd90606401600060405180830381600087803b158015611f1057600080fd5b505af1158015611f24573d6000803e3d6000fd5b5050604051630a3b53db60e21b8152600481018590523060248201527f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031692506328ed4f6c9150604401600060405180830381600087803b158015611f9057600080fd5b505af1158015611fa4573d6000803e3d6000fd5b5050604051636b727d4360e11b8152600481018590526276a70092507f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316915063d6e4fa8690602401602060405180830381865afa158015612012573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061203691906158e9565b6120409190615918565b925061208988888080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920191909152508a9250505061ffff881686886138ca565b505095945050505050565b6001600160a01b03821633036121125760405162461bcd60e51b815260206004820152602960248201527f455243313135353a2073657474696e6720617070726f76616c2073746174757360448201527f20666f722073656c660000000000000000000000000000000000000000000000606482015260840161088a565b3360008181526002602090815260408083206001600160a01b03871680855290835292819020805460ff191686151590811790915590519081529192917f17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31910160405180910390a35050565b3360009081526004602052604081205460ff166121ee5760405162461bcd60e51b815260206004820152602860248201527f436f6e74726f6c6c61626c653a2043616c6c6572206973206e6f74206120636f604482015267373a3937b63632b960c11b606482015260840161088a565b60008787604051612200929190615a11565b6040519081900381207ffca247ac000000000000000000000000000000000000000000000000000000008252600482018190523060248301526044820187905291507f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03169063fca247ac906064016020604051808303816000875af1158015612295573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906122b991906158e9565b915061230e88888080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920191909152508a9250505061ffff86166123086276a70087615918565b886138ca565b509695505050505050565b600080612325846108cf565b50841663ffffffff908116908516149250505092915050565b612346613a30565b6007546001600160a01b0316156124665760075460405163a22cb46560e01b81526001600160a01b039182166004820152600060248201527f00000000000000000000000000000000000000000000000000000000000000009091169063a22cb46590604401600060405180830381600087803b1580156123c657600080fd5b505af11580156123da573d6000803e3d6000fd5b505060075460405163a22cb46560e01b81526001600160a01b039182166004820152600060248201527f0000000000000000000000000000000000000000000000000000000000000000909116925063a22cb4659150604401600060405180830381600087803b15801561244d57600080fd5b505af1158015612461573d6000803e3d6000fd5b505050505b600780546001600160a01b0319166001600160a01b038316908117909155156125935760075460405163a22cb46560e01b81526001600160a01b039182166004820152600160248201527f00000000000000000000000000000000000000000000000000000000000000009091169063a22cb46590604401600060405180830381600087803b1580156124f857600080fd5b505af115801561250c573d6000803e3d6000fd5b505060075460405163a22cb46560e01b81526001600160a01b039182166004820152600160248201527f0000000000000000000000000000000000000000000000000000000000000000909116925063a22cb4659150604401600060405180830381600087803b15801561257f57600080fd5b505af11580156114d7573d6000803e3d6000fd5b50565b3360009081526004602052604081205460ff166126065760405162461bcd60e51b815260206004820152602860248201527f436f6e74726f6c6c61626c653a2043616c6c6572206973206e6f74206120636f604482015267373a3937b63632b960c11b606482015260840161088a565b604080517f93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae602080830191909152818301869052825180830384018152606090920190925280519101206000906040517fc475abff00000000000000000000000000000000000000000000000000000000815260048101869052602481018590529091506000906001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000169063c475abff906044016020604051808303816000875af11580156126e0573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061270491906158e9565b6040516331a9108f60e11b8152600481018790529091507f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031690636352211e90602401602060405180830381865afa925050508015612788575060408051601f3d908101601f19168201909252612785918101906159d7565b60015b6127955791506108c99050565b6001600160a01b0381163014158061283f57506040516302571be360e01b81526004810184905230906001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016906302571be390602401602060405180830381865afa15801561280f573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061283391906159d7565b6001600160a01b031614155b1561284e575091506108c99050565b50600061285e6276a70083615918565b60008481526001602052604090205490915060a081901c6128818583838661429a565b50919695505050505050565b60008661289a8133611775565b6128c05760405163168ab55d60e31b81526004810182905233602482015260440161088a565b600087876040516128d2929190615a11565b6040518091039020905061290d8982604080516020808201949094528082019290925280518083038201815260609092019052805191012090565b92506129198984613a8a565b6129238386613bc9565b60006129668a858b8b8080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250613bfc92505050565b90506129748a858888613cc9565b945061297f84613d0f565b612a47576040517f06ab5923000000000000000000000000000000000000000000000000000000008152600481018b9052602481018390523060448201527f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316906306ab5923906064016020604051808303816000875af1158015612a10573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612a3491906158e9565b50612a428482898989614424565b612a8d565b612a8d8a858b8b8080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920191909152508d92508c91508b9050613dff565b5050509695505050505050565b6000612ae0600086868080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201919091525092939250506144669050565b6007549091506001600160a01b0316612b25576040517f24c1d6d400000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b612b2f8133611775565b612b555760405163168ab55d60e31b81526004810182905233602482015260440161088a565b60008080612b62846108cf565b919450925090506000612b7485610958565b9050612b7f85614525565b600760009054906101000a90046001600160a01b03166001600160a01b0316639198c2768a8a878787878e8e6040518963ffffffff1660e01b8152600401612bce989796959493929190615a4a565b600060405180830381600087803b158015612be857600080fd5b505af1158015612bfc573d6000803e3d6000fd5b50505050505050505050505050565b83612c168133611775565b612c3c5760405163168ab55d60e31b81526004810182905233602482015260440161088a565b84601c6000612c4a836108cf565b5091505063ffffffff8282161615612c785760405163a2a7201360e01b81526004810184905260240161088a565b6040517fcf408823000000000000000000000000000000000000000000000000000000008152600481018990523060248201526001600160a01b03878116604483015267ffffffffffffffff871660648301527f0000000000000000000000000000000000000000000000000000000000000000169063cf40882390608401600060405180830381600087803b158015612d1157600080fd5b505af1158015612d25573d6000803e3d6000fd5b5050506001600160a01b0388169050612d8c576000612d43896108cf565b509150506201ffff1962020000821601612d7b57604051632ca49b0d60e11b81526001600160a01b038916600482015260240161088a565b612d86896000614332565b50611cbe565b6000612d97896119aa565b9050612db981898b60001c6001604051806020016040528060008152506145e7565b505050505050505050565b60408051602080820186905281830185905282518083038401815260609092019092528051910120612df68133611775565b612e1c5760405163168ab55d60e31b81526004810182905233602482015260440161088a565b7f6c32148f748aba23997146d7fe89e962e3cc30271290fb96f5f4337756c03b528401612e5c5760405163615a470360e01b815260040160405180910390fd5b6001600160a01b0382161580612e7a57506001600160a01b03821630145b15612ea357604051632ca49b0d60e11b81526001600160a01b038316600482015260240161088a565b604080516020808201879052818301869052825180830384018152606090920190925280519101206119a490611c1b565b604080516020808201859052818301849052825180830384018152606090920190925280519101206000906000612f0a82613d0f565b90507f93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae8514612f3c5791506108c99050565b6040516331a9108f60e11b8152600481018590527f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031690636352211e90602401602060405180830381865afa925050508015612fbd575060408051601f3d908101601f19168201909252612fba918101906159d7565b60015b612fcc576000925050506108c9565b6001600160a01b0316301492506108c9915050565b612fe9613a30565b6001600160a01b038216600081815260046020908152604091829020805460ff191685151590811790915591519182527f4c97694570a07277810af7e5669ffd5f6a2d6b74b6e9a274b8b870fd5114cf8791015b60405180910390a25050565b600080613090600087878080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201919091525092939250506147399050565b9150915060006130d98288888080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201919091525092939250506144669050565b604080516020808201849052818301879052825180830384018152606090920190925280519101209091506000906000818152600660205260409020909150613123888a83615af9565b507f6c32148f748aba23997146d7fe89e962e3cc30271290fb96f5f4337756c03b5282016131645760405163615a470360e01b815260040160405180910390fd5b6040516302571be360e01b8152600481018290526000907f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316906302571be390602401602060405180830381865afa1580156131cc573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906131f091906159d7565b90506001600160a01b0381163314801590613298575060405163e985e9c560e01b81526001600160a01b0382811660048301523360248301527f0000000000000000000000000000000000000000000000000000000000000000169063e985e9c590604401602060405180830381865afa158015613272573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061329691906159f4565b155b156132bf5760405163168ab55d60e31b81526004810183905233602482015260440161088a565b6001600160a01b0386161561335157604051630c4b7b8560e11b8152600481018390526001600160a01b0387811660248301527f00000000000000000000000000000000000000000000000000000000000000001690631896f70a90604401600060405180830381600087803b15801561333857600080fd5b505af115801561334c573d6000803e3d6000fd5b505050505b604051635b0fc9c360e01b8152600481018390523060248201527f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031690635b0fc9c390604401600060405180830381600087803b1580156133b957600080fd5b505af11580156133cd573d6000803e3d6000fd5b50505050612db9828a8a8080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201829052508d93509150819050614424565b6001600160a01b0384166134785760405162461bcd60e51b815260206004820152602560248201527f455243313135353a207472616e7366657220746f20746865207a65726f206164604482015264647265737360d81b606482015260840161088a565b6001600160a01b0385163314806134b257506001600160a01b038516600090815260026020908152604080832033845290915290205460ff165b6135245760405162461bcd60e51b815260206004820152602960248201527f455243313135353a2063616c6c6572206973206e6f74206f776e6572206e6f7260448201527f20617070726f7665640000000000000000000000000000000000000000000000606482015260840161088a565b6114d785858585856145e7565b613539613a30565b6001600160a01b0381166135b55760405162461bcd60e51b815260206004820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201527f6464726573730000000000000000000000000000000000000000000000000000606482015260840161088a565b612593816142e2565b600081815260066020526040812080548291906135da90615940565b80601f016020809104026020016040519081016040528092919081815260200182805461360690615940565b80156136535780601f1061362857610100808354040283529160200191613653565b820191906000526020600020905b81548152906001019060200180831161363657829003601f168201915b50505050509050805160000361366c5750600092915050565b6000806136798382614739565b9092509050600061368a8483614466565b9050610a738184612ed4565b600080428367ffffffffffffffff1610156136c45761ffff19620100008516016136bf57600094505b600093505b50929391925050565b60006001600160e01b031982167fd9b67a2600000000000000000000000000000000000000000000000000000000148061371757506001600160e01b031982166303a24d0760e21b145b806108c957507f01ffc9a7000000000000000000000000000000000000000000000000000000006001600160e01b03198316146108c9565b600061375a826119aa565b9050806001600160a01b0316836001600160a01b0316036137e35760405162461bcd60e51b815260206004820152602160248201527f4552433732313a20617070726f76616c20746f2063757272656e74206f776e6560448201527f7200000000000000000000000000000000000000000000000000000000000000606482015260840161088a565b336001600160a01b038216148061381d57506001600160a01b038116600090815260026020908152604080832033845290915290205460ff165b61388f5760405162461bcd60e51b815260206004820152603d60248201527f4552433732313a20617070726f76652063616c6c6572206973206e6f7420746f60448201527f6b656e206f776e6572206f7220617070726f76656420666f7220616c6c000000606482015260840161088a565b6109de83836147f0565b6000620200008381161480156109965750426138b86276a70084615bb9565b67ffffffffffffffff16109392505050565b8451602086012060006139247f93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae83604080516020808201949094528082019290925280518083038201815260609092019052805191012090565b90506000613967886040518060400160405280600581526020017f036574680000000000000000000000000000000000000000000000000000000081525061485e565b60008381526006602052604090209091506139828282615bda565b50613995828289620300008a1789614424565b6001600160a01b03841615611cbe57604051630c4b7b8560e11b8152600481018390526001600160a01b0385811660248301527f00000000000000000000000000000000000000000000000000000000000000001690631896f70a90604401600060405180830381600087803b158015613a0e57600080fd5b505af1158015613a22573d6000803e3d6000fd5b505050505050505050505050565b6000546001600160a01b03163314611b1c5760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572604482015260640161088a565b60008080613a97846108cf565b919450925090504267ffffffffffffffff821610808015613b5b57506001600160a01b0384161580613b5b57506040516302571be360e01b8152600481018690526000906001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016906302571be390602401602060405180830381865afa158015613b2c573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190613b5091906159d7565b6001600160a01b0316145b15613b9a576000613b6b876108cf565b509150506020811615613b945760405163a2a7201360e01b81526004810187905260240161088a565b50613bc1565b62010000831615613bc15760405163a2a7201360e01b81526004810186905260240161088a565b505050505050565b63fffdffff81811763ffffffff1614613bf85760405163a2a7201360e01b81526004810183905260240161088a565b5050565b60606000613ca583600660008881526020019081526020016000208054613c2290615940565b80601f0160208091040260200160405190810160405280929190818152602001828054613c4e90615940565b8015613c9b5780601f10613c7057610100808354040283529160200191613c9b565b820191906000526020600020905b815481529060010190602001808311613c7e57829003601f168201915b505050505061485e565b6000858152600660205260409020909150613cc08282615bda565b50949350505050565b600080613cd5856108cf565b92505050600080613ce88860001c6108cf565b9250925050613cf8878784614155565b613d03858483614190565b98975050505050505050565b600080613d1b836119aa565b6001600160a01b0316141580156108c957506040516302571be360e01b81526004810183905230906001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016906302571be390602401602060405180830381865afa158015613d94573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190613db891906159d7565b6001600160a01b03161492915050565b60008681526006602052604081208054613de7918791613c2290615940565b9050613df68682868686614424565b50505050505050565b60008080613e0c886108cf565b9250925092506000613e3688600660008d81526020019081526020016000208054613c2290615940565b60008a8152600660205260409020805491925090613e5390615940565b9050600003613e76576000898152600660205260409020613e748282615bda565b505b613e85898588861785896141da565b6001600160a01b038716613ea357613e9e896000614332565b610bfc565b610bfc84888b60001c6001604051806020016040528060008152506145e7565b6201ffff1962020000831601613ee357613ee06276a70082615bb9565b90505b428167ffffffffffffffff161015613f605762010000821615613f5b5760405162461bcd60e51b815260206004820152602a60248201527f455243313135353a20696e73756666696369656e742062616c616e636520666f60448201526939103a3930b739b332b960b11b606482015260840161088a565b613f85565b6004821615613f855760405163a2a7201360e01b81526004810184905260240161088a565b604082166000036109de575050600090815260036020526040902080546001600160a01b0319169055565b6001600160a01b0384163b15613bc15760405163bc197c8160e01b81526001600160a01b0385169063bc197c8190613ff49089908990889088908890600401615c9a565b6020604051808303816000875af192505050801561402f575060408051601f3d908101601f1916820190925261402c91810190615cec565b60015b6140e45761403b615d09565b806308c379a003614074575061404f615d25565b8061405a5750614076565b8060405162461bcd60e51b815260040161088a9190614dee565b505b60405162461bcd60e51b815260206004820152603460248201527f455243313135353a207472616e7366657220746f206e6f6e204552433131353560448201527f526563656976657220696d706c656d656e746572000000000000000000000000606482015260840161088a565b6001600160e01b0319811663bc197c8160e01b14613df65760405162461bcd60e51b815260206004820152602860248201527f455243313135353a204552433131353552656365697665722072656a656374656044820152676420746f6b656e7360c01b606482015260840161088a565b63ffff0000821615801590600183161590829061416f5750805b156114d75760405163a2a7201360e01b81526004810186905260240161088a565b60008167ffffffffffffffff168467ffffffffffffffff1611156141b2578193505b8267ffffffffffffffff168467ffffffffffffffff1610156141d2578293505b509192915050565b6141e68585858461429a565b60405163ffffffff8416815285907f39873f00c80f4f94b7bd1594aebcf650f003545b74824d57ddf4939e3ff3a34b9060200160405180910390a28167ffffffffffffffff168167ffffffffffffffff1611156114d75760405167ffffffffffffffff8216815285907ff675815a0817338f93a7da433f6bd5f5542f1029b11b455191ac96c7f6a9b132906020015b60405180910390a25050505050565b600080614290836108cf565b5090949350505050565b6142a48483614907565b60008481526001602052604090206001600160a01b03841663ffffffff60a01b60a085901b16176001600160c01b031960c084901b161790556119a4565b600080546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b61433d826001612319565b1561435e5760405163a2a7201360e01b81526004810183905260240161088a565b61436782614525565b604051635b0fc9c360e01b8152600481018390526001600160a01b0382811660248301527f00000000000000000000000000000000000000000000000000000000000000001690635b0fc9c390604401600060405180830381600087803b1580156143d157600080fd5b505af11580156143e5573d6000803e3d6000fd5b50506040516001600160a01b03841681528492507fee2ba1195c65bcf218a83d874335c6bf9d9067b4c672f3c3bf16cf40de7586c4915060200161303d565b61443085848484614940565b847f8ce7013e8abebc55c3890a68f5a27c67c3f7efa64e584de5fb22363c606fd340858585856040516142759493929190615daf565b60008060006144758585614739565b9092509050816144e7576001855161448d9190615df7565b84146144db5760405162461bcd60e51b815260206004820152601d60248201527f6e616d65686173683a204a756e6b20617420656e64206f66206e616d65000000604482015260640161088a565b50600091506108c99050565b6144f18582614466565b6040805160208101929092528101839052606001604051602081830303815290604052805190602001209250505092915050565b60008181526001602052604090205460a081901c60c082901c614549838383613696565b600086815260036020908152604080832080546001600160a01b03191690556001909152902063ffffffff60a01b60a083901b166001600160c01b031960c086901b1617905592506145989050565b60408051858152600160208201526000916001600160a01b0386169133917fc3d58168c5ae7397731d063d5bbf3d657854427343f4c083240f7aacaa2d0f62910160405180910390a450505050565b60008060006145f5866108cf565b925092509250614606868383613ec3565b8460011480156146275750876001600160a01b0316836001600160a01b0316145b6146865760405162461bcd60e51b815260206004820152602a60248201527f455243313135353a20696e73756666696369656e742062616c616e636520666f60448201526939103a3930b739b332b960b11b606482015260840161088a565b866001600160a01b0316836001600160a01b0316036146a7575050506114d7565b60008681526001602052604090206001600160a01b03881663ffffffff60a01b60a085901b16176001600160c01b031960c084901b1617905560408051878152602081018790526001600160a01b03808a1692908b169133917fc3d58168c5ae7397731d063d5bbf3d657854427343f4c083240f7aacaa2d0f62910160405180910390a4611cbe3389898989896149b4565b6000808351831061478c5760405162461bcd60e51b815260206004820152601e60248201527f726561644c6162656c3a20496e646578206f7574206f6620626f756e64730000604482015260640161088a565b60008484815181106147a0576147a061597a565b016020015160f81c905080156147cc576147c5856147bf866001615e0a565b83614ab0565b92506147d1565b600092505b6147db8185615e0a565b6147e6906001615e0a565b9150509250929050565b600081815260036020526040902080546001600160a01b0319166001600160a01b0384169081179091558190614825826119aa565b6001600160a01b03167f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b92560405160405180910390a45050565b606060018351101561489c576040517f280dacb600000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60ff835111156148da57826040517fe3ba295f00000000000000000000000000000000000000000000000000000000815260040161088a9190614dee565b825183836040516020016148f093929190615e1d565b604051602081830303815290604052905092915050565b61ffff81161580159061491f57506201000181811614155b15613bf85760405163a2a7201360e01b81526004810183905260240161088a565b61494a8483614907565b6000848152600160205260409020546001600160a01b038116156149a85761497185614525565b6040516000815285907fee2ba1195c65bcf218a83d874335c6bf9d9067b4c672f3c3bf16cf40de7586c49060200160405180910390a25b6114d785858585614ad4565b6001600160a01b0384163b15613bc15760405163f23a6e6160e01b81526001600160a01b0385169063f23a6e61906149f89089908990889088908890600401615e7e565b6020604051808303816000875af1925050508015614a33575060408051601f3d908101601f19168201909252614a3091810190615cec565b60015b614a3f5761403b615d09565b6001600160e01b0319811663f23a6e6160e01b14613df65760405162461bcd60e51b815260206004820152602860248201527f455243313135353a204552433131353552656365697665722072656a656374656044820152676420746f6b656e7360c01b606482015260840161088a565b8251600090614abf8385615e0a565b1115614aca57600080fd5b5091016020012090565b8360008080614ae2846108cf565b9194509250905063ffff0000821667ffffffffffffffff8087169083161115614b09578195505b428267ffffffffffffffff1610614b1f57958617955b6001600160a01b03841615614b765760405162461bcd60e51b815260206004820152601f60248201527f455243313135353a206d696e74206f66206578697374696e6720746f6b656e00604482015260640161088a565b6001600160a01b038816614bf25760405162461bcd60e51b815260206004820152602160248201527f455243313135353a206d696e7420746f20746865207a65726f2061646472657360448201527f7300000000000000000000000000000000000000000000000000000000000000606482015260840161088a565b306001600160a01b03891603614c705760405162461bcd60e51b815260206004820152603460248201527f455243313135353a206e65774f776e65722063616e6e6f74206265207468652060448201527f4e616d655772617070657220636f6e7472616374000000000000000000000000606482015260840161088a565b60008581526001602052604090206001600160a01b03891663ffffffff60a01b60a08a901b16176001600160c01b031960c089901b1617905560408051868152600160208201526001600160a01b038a169160009133917fc3d58168c5ae7397731d063d5bbf3d657854427343f4c083240f7aacaa2d0f62910160405180910390a4612db93360008a886001604051806020016040528060008152506149b4565b6001600160a01b038116811461259357600080fd5b60008060408385031215614d3957600080fd5b8235614d4481614d11565b946020939093013593505050565b600060208284031215614d6457600080fd5b5035919050565b6001600160e01b03198116811461259357600080fd5b600060208284031215614d9357600080fd5b813561099681614d6b565b60005b83811015614db9578181015183820152602001614da1565b50506000910152565b60008151808452614dda816020860160208601614d9e565b601f01601f19169290920160200192915050565b6020815260006109966020830184614dc2565b60008060408385031215614e1457600080fd5b823591506020830135614e2681614d11565b809150509250929050565b803567ffffffffffffffff81168114614e4957600080fd5b919050565b60008060408385031215614e6157600080fd5b82359150614e7160208401614e31565b90509250929050565b60008083601f840112614e8c57600080fd5b50813567ffffffffffffffff811115614ea457600080fd5b602083019150836020828501011115614ebc57600080fd5b9250929050565b600080600080600060808688031215614edb57600080fd5b8535614ee681614d11565b94506020860135614ef681614d11565b935060408601359250606086013567ffffffffffffffff811115614f1957600080fd5b614f2588828901614e7a565b969995985093965092949392505050565b600060208284031215614f4857600080fd5b813561099681614d11565b634e487b7160e01b600052604160045260246000fd5b601f8201601f1916810167ffffffffffffffff81118282101715614f8f57614f8f614f53565b6040525050565b600067ffffffffffffffff821115614fb057614fb0614f53565b50601f01601f191660200190565b600082601f830112614fcf57600080fd5b8135614fda81614f96565b604051614fe78282614f69565b828152856020848701011115614ffc57600080fd5b82602086016020830137600092810160200192909252509392505050565b803563ffffffff81168114614e4957600080fd5b600080600080600080600060e0888a03121561504957600080fd5b87359650602088013567ffffffffffffffff81111561506757600080fd5b6150738a828b01614fbe565b965050604088013561508481614d11565b9450606088013561509481614d11565b93506150a260808901614e31565b92506150b060a0890161501a565b91506150be60c08901614e31565b905092959891949750929550565b600067ffffffffffffffff8211156150e6576150e6614f53565b5060051b60200190565b600082601f83011261510157600080fd5b8135602061510e826150cc565b60405161511b8282614f69565b83815260059390931b850182019282810191508684111561513b57600080fd5b8286015b8481101561230e578035835291830191830161513f565b600080600080600060a0868803121561516e57600080fd5b853561517981614d11565b9450602086013561518981614d11565b9350604086013567ffffffffffffffff808211156151a657600080fd5b6151b289838a016150f0565b945060608801359150808211156151c857600080fd5b6151d489838a016150f0565b935060808801359150808211156151ea57600080fd5b506151f788828901614fbe565b9150509295509295909350565b6000806000806080858703121561521a57600080fd5b84359350602085013592506152316040860161501a565b915061523f60608601614e31565b905092959194509250565b803561ffff81168114614e4957600080fd5b6000806040838503121561526f57600080fd5b82359150614e716020840161524a565b6000806040838503121561529257600080fd5b823567ffffffffffffffff808211156152aa57600080fd5b818501915085601f8301126152be57600080fd5b813560206152cb826150cc565b6040516152d88282614f69565b83815260059390931b85018201928281019150898411156152f857600080fd5b948201945b8386101561531f57853561531081614d11565b825294820194908201906152fd565b9650508601359250508082111561533557600080fd5b506147e6858286016150f0565b600081518084526020808501945080840160005b8381101561537257815187529582019590820190600101615356565b509495945050505050565b6020815260006109966020830184615342565b6000806000606084860312156153a557600080fd5b83356153b081614d11565b925060208401356153c081614d11565b929592945050506040919091013590565b6000806000606084860312156153e657600080fd5b83359250602084013591506153fd60408501614e31565b90509250925092565b60008060006060848603121561541b57600080fd5b83359250602084013561542d81614d11565b9150604084013561543d81614d11565b809150509250925092565b60008060008060006080868803121561546057600080fd5b853567ffffffffffffffff81111561547757600080fd5b61548388828901614e7a565b909650945050602086013561549781614d11565b92506154a56040870161524a565b915060608601356154b581614d11565b809150509295509295909350565b801515811461259357600080fd5b600080604083850312156154e457600080fd5b82356154ef81614d11565b91506020830135614e26816154c3565b60008060008060008060a0878903121561551857600080fd5b863567ffffffffffffffff81111561552f57600080fd5b61553b89828a01614e7a565b909750955050602087013561554f81614d11565b935060408701359250606087013561556681614d11565b91506155746080880161524a565b90509295509295509295565b6000806040838503121561559357600080fd5b82359150614e716020840161501a565b600080604083850312156155b657600080fd5b50508035926020909101359150565b60008060008060008060a087890312156155de57600080fd5b86359550602087013567ffffffffffffffff8111156155fc57600080fd5b61560889828a01614e7a565b909650945050604087013561561c81614d11565b925061562a6060880161501a565b915061557460808801614e31565b6000806000806040858703121561564e57600080fd5b843567ffffffffffffffff8082111561566657600080fd5b61567288838901614e7a565b9096509450602087013591508082111561568b57600080fd5b5061569887828801614e7a565b95989497509550505050565b600080600080608085870312156156ba57600080fd5b8435935060208501356156cc81614d11565b9250604085013561523181614d11565b6000806000606084860312156156f157600080fd5b8335925060208401359150604084013561543d81614d11565b6000806040838503121561571d57600080fd5b823561572881614d11565b91506020830135614e2681614d11565b6000806000806060858703121561574e57600080fd5b843567ffffffffffffffff81111561576557600080fd5b61577187828801614e7a565b909550935050602085013561578581614d11565b9150604085013561579581614d11565b939692955090935050565b600080600080600060a086880312156157b857600080fd5b85356157c381614d11565b945060208601356157d381614d11565b93506040860135925060608601359150608086013567ffffffffffffffff8111156157fd57600080fd5b6151f788828901614fbe565b60006020828403121561581b57600080fd5b815167ffffffffffffffff81111561583257600080fd5b8201601f8101841361584357600080fd5b805161584e81614f96565b60405161585b8282614f69565b82815286602084860101111561587057600080fd5b610a73836020830160208701614d9e565b6000806000806080858703121561589757600080fd5b843567ffffffffffffffff8111156158ae57600080fd5b6158ba87828801614fbe565b94505060208501356158cb81614d11565b92506158d96040860161524a565b9150606085013561579581614d11565b6000602082840312156158fb57600080fd5b5051919050565b634e487b7160e01b600052601160045260246000fd5b67ffffffffffffffff81811683821601908082111561593957615939615902565b5092915050565b600181811c9082168061595457607f821691505b60208210810361597457634e487b7160e01b600052602260045260246000fd5b50919050565b634e487b7160e01b600052603260045260246000fd5b6000600182016159a2576159a2615902565b5060010190565b6040815260006159bc6040830185615342565b82810360208401526159ce8185615342565b95945050505050565b6000602082840312156159e957600080fd5b815161099681614d11565b600060208284031215615a0657600080fd5b8151610996816154c3565b8183823760009101908152919050565b81835281816020850137506000828201602090810191909152601f909101601f19169091010190565b60c081526000615a5e60c083018a8c615a21565b6001600160a01b03898116602085015263ffffffff8916604085015267ffffffffffffffff881660608501528616608084015282810360a0840152615aa4818587615a21565b9b9a5050505050505050505050565b601f8211156109de57600081815260208120601f850160051c81016020861015615ada5750805b601f850160051c820191505b81811015613bc157828155600101615ae6565b67ffffffffffffffff831115615b1157615b11614f53565b615b2583615b1f8354615940565b83615ab3565b6000601f841160018114615b595760008515615b415750838201355b600019600387901b1c1916600186901b1783556114d7565b600083815260209020601f19861690835b82811015615b8a5786850135825560209485019460019092019101615b6a565b5086821015615ba75760001960f88860031b161c19848701351681555b505060018560011b0183555050505050565b67ffffffffffffffff82811682821603908082111561593957615939615902565b815167ffffffffffffffff811115615bf457615bf4614f53565b615c0881615c028454615940565b84615ab3565b602080601f831160018114615c3d5760008415615c255750858301515b600019600386901b1c1916600185901b178555613bc1565b600085815260208120601f198616915b82811015615c6c57888601518255948401946001909101908401615c4d565b5085821015615c8a5787850151600019600388901b60f8161c191681555b5050505050600190811b01905550565b60006001600160a01b03808816835280871660208401525060a06040830152615cc660a0830186615342565b8281036060840152615cd88186615342565b90508281036080840152613d038185614dc2565b600060208284031215615cfe57600080fd5b815161099681614d6b565b600060033d1115615d225760046000803e5060005160e01c5b90565b600060443d1015615d335790565b6040516003193d81016004833e81513d67ffffffffffffffff8160248401118184111715615d6357505050505090565b8285019150815181811115615d7b5750505050505090565b843d8701016020828501011115615d955750505050505090565b615da460208286010187614f69565b509095945050505050565b608081526000615dc26080830187614dc2565b6001600160a01b039590951660208301525063ffffffff92909216604083015267ffffffffffffffff16606090910152919050565b818103818111156108c9576108c9615902565b808201808211156108c9576108c9615902565b7fff000000000000000000000000000000000000000000000000000000000000008460f81b16815260008351615e5a816001850160208801614d9e565b835190830190615e71816001840160208801614d9e565b0160010195945050505050565b60006001600160a01b03808816835280871660208401525084604083015283606083015260a06080830152615eb660a0830184614dc2565b97965050505050505056fea26469706673582212204f37b28dc45c53fb37759a47de9637b4ff115b46e39238a82dadf100cccbc4dc64736f6c63430008110033","devdoc":{"kind":"dev","methods":{"allFusesBurned(bytes32,uint32)":{"params":{"fuseMask":"The fuses you want to check","node":"Namehash of the name"},"returns":{"_0":"Boolean of whether or not all the selected fuses are burned"}},"approve(address,uint256)":{"params":{"to":"address to approve","tokenId":"name to approve"}},"balanceOf(address,uint256)":{"details":"See {IERC1155-balanceOf}. Requirements: - `account` cannot be the zero address."},"balanceOfBatch(address[],uint256[])":{"details":"See {IERC1155-balanceOfBatch}. Requirements: - `accounts` and `ids` must have the same length."},"canExtendSubnames(bytes32,address)":{"params":{"addr":"which address to check permissions for","node":"namehash of the name to check"},"returns":{"_0":"whether or not is owner/operator or approved"}},"canModifyName(bytes32,address)":{"params":{"addr":"which address to check permissions for","node":"namehash of the name to check"},"returns":{"_0":"whether or not is owner or operator"}},"extendExpiry(bytes32,bytes32,uint64)":{"params":{"expiry":"When the name will expire in seconds since the Unix epoch","labelhash":"Labelhash of the name, e.g. vitalik.xyz would be keccak256(\'vitalik\')","parentNode":"Parent namehash of the name e.g. vitalik.xyz would be namehash(\'xyz\')"},"returns":{"_0":"New expiry"}},"getApproved(uint256)":{"params":{"id":"Namehash of the name"},"returns":{"operator":"Approved operator of a name"}},"getData(uint256)":{"params":{"id":"Namehash of the name"},"returns":{"expiry":"Expiry of the name","fuses":"Fuses of the name","owner":"Owner of the name"}},"isApprovedForAll(address,address)":{"details":"See {IERC1155-isApprovedForAll}."},"isWrapped(bytes32)":{"params":{"node":"Namehash of the name"},"returns":{"_0":"Boolean of whether or not the name is wrapped"}},"isWrapped(bytes32,bytes32)":{"params":{"labelhash":"Namehash of the name","parentNode":"Namehash of the name"},"returns":{"_0":"Boolean of whether or not the name is wrapped"}},"owner()":{"details":"Returns the address of the current owner."},"ownerOf(uint256)":{"params":{"id":"Label as a string of the .eth domain to wrap"},"returns":{"owner":"The owner of the name"}},"recoverFunds(address,address,uint256)":{"details":"The contract is Ownable and only the owner can call the recover function.","params":{"_amount":"The amount of tokens to recover.","_to":"The address to send the tokens to.","_token":"The address of the ERC20 token to recover"}},"registerAndWrapETH2LD(string,address,uint256,address,uint16)":{"details":"Registers a new .eth second-level domain and wraps it.      Only callable by authorised controllers.","params":{"duration":"The duration, in seconds, to register the name for.","label":"The label to register (Eg, \'foo\' for \'foo.eth\').","ownerControlledFuses":"Initial owner-controlled fuses to set","resolver":"The resolver address to set on the ENS registry (optional).","wrappedOwner":"The owner of the wrapped name."},"returns":{"registrarExpiry":"The expiry date of the new name on the .eth registrar, in seconds since the Unix epoch."}},"renew(uint256,uint256)":{"details":"Only callable by authorised controllers.","params":{"duration":"The number of seconds to renew the name for.","tokenId":"The hash of the label to register (eg, `keccak256(\'foo\')`, for \'foo.eth\')."},"returns":{"expires":"The expiry date of the name on the .eth registrar, in seconds since the Unix epoch."}},"renounceOwnership()":{"details":"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner."},"safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)":{"details":"See {IERC1155-safeBatchTransferFrom}."},"safeTransferFrom(address,address,uint256,uint256,bytes)":{"details":"See {IERC1155-safeTransferFrom}."},"setApprovalForAll(address,bool)":{"details":"See {IERC1155-setApprovalForAll}."},"setChildFuses(bytes32,bytes32,uint32,uint64)":{"params":{"expiry":"When the name will expire in seconds since the Unix epoch","fuses":"Fuses to burn","labelhash":"Labelhash of the name, e.g. vitalik.xyz would be keccak256(\'vitalik\')","parentNode":"Parent namehash of the name e.g. vitalik.xyz would be namehash(\'xyz\')"}},"setFuses(bytes32,uint16)":{"params":{"node":"Namehash of the name","ownerControlledFuses":"Owner-controlled fuses to burn"},"returns":{"_0":"Old fuses"}},"setMetadataService(address)":{"params":{"_metadataService":"The new metadata service"}},"setRecord(bytes32,address,address,uint64)":{"params":{"node":"Namehash of the name to set a record for","owner":"New owner in the registry","resolver":"Resolver contract","ttl":"Time to live in the registry"}},"setResolver(bytes32,address)":{"params":{"node":"namehash of the name","resolver":"the resolver contract"}},"setSubnodeOwner(bytes32,string,address,uint32,uint64)":{"params":{"expiry":"When the name will expire in seconds since the Unix epoch","fuses":"Initial fuses for the wrapped subdomain","label":"Label of the subdomain as a string","owner":"New owner in the wrapper","parentNode":"Parent namehash of the subdomain"},"returns":{"node":"Namehash of the subdomain"}},"setSubnodeRecord(bytes32,string,address,address,uint64,uint32,uint64)":{"params":{"expiry":"When the name will expire in seconds since the Unix epoch","fuses":"initial fuses for the wrapped subdomain","label":"label of the subdomain as a string","owner":"new owner in the wrapper","parentNode":"parent namehash of the subdomain","resolver":"resolver contract in the registry","ttl":"ttl in the registry"},"returns":{"node":"Namehash of the subdomain"}},"setTTL(bytes32,uint64)":{"params":{"node":"Namehash of the name","ttl":"TTL in the registry"}},"setUpgradeContract(address)":{"details":"The default value of upgradeContract is the 0 address. Use the 0 address at any time to make the contract not upgradable.","params":{"_upgradeAddress":"address of an upgraded contract"}},"transferOwnership(address)":{"details":"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."},"unwrap(bytes32,bytes32,address)":{"details":"Can be called by the owner in the wrapper or an authorised caller in the wrapper","params":{"controller":"Sets the owner in the registry to this address","labelhash":"Labelhash of the name, e.g. vitalik.xyz would be keccak256(\'vitalik\')","parentNode":"Parent namehash of the name e.g. vitalik.xyz would be namehash(\'xyz\')"}},"unwrapETH2LD(bytes32,address,address)":{"details":"Can be called by the owner in the wrapper or an authorised caller in the wrapper","params":{"controller":"Sets the owner in the registry to this address","labelhash":"Labelhash of the .eth domain","registrant":"Sets the owner in the .eth registrar to this address"}},"upgrade(bytes,bytes)":{"details":"Can be called by the owner or an authorised caller","params":{"extraData":"Extra data to pass to the upgrade contract","name":"The name to upgrade, in DNS format"}},"uri(uint256)":{"params":{"tokenId":"The id of the token"},"returns":{"_0":"string uri of the metadata service"}},"wrap(bytes,address,address)":{"details":"Can be called by the owner in the registry or an authorised caller in the registry","params":{"name":"The name to wrap, in DNS format","resolver":"Resolver contract","wrappedOwner":"Owner of the name in this contract"}},"wrapETH2LD(string,address,uint16,address)":{"details":"Can be called by the owner of the name on the .eth registrar or an authorised caller on the registrar","params":{"label":"Label as a string of the .eth domain to wrap","ownerControlledFuses":"Initial owner-controlled fuses to set","resolver":"Resolver contract address","wrappedOwner":"Owner of the name in this contract"}}},"version":1},"userdoc":{"kind":"user","methods":{"allFusesBurned(bytes32,uint32)":{"notice":"Checks all Fuses in the mask are burned for the node"},"approve(address,uint256)":{"notice":"Approves an address for a name"},"canExtendSubnames(bytes32,address)":{"notice":"Checks if owner/operator or approved by owner"},"canModifyName(bytes32,address)":{"notice":"Checks if owner or operator of the owner"},"extendExpiry(bytes32,bytes32,uint64)":{"notice":"Extends expiry for a name"},"getApproved(uint256)":{"notice":"Gets the owner of a name"},"getData(uint256)":{"notice":"Gets the data for a name"},"isWrapped(bytes32)":{"notice":"Checks if a name is wrapped"},"isWrapped(bytes32,bytes32)":{"notice":"Checks if a name is wrapped in a more gas efficient way"},"ownerOf(uint256)":{"notice":"Gets the owner of a name"},"recoverFunds(address,address,uint256)":{"notice":"Recover ERC20 tokens sent to the contract by mistake."},"renew(uint256,uint256)":{"notice":"Renews a .eth second-level domain."},"setChildFuses(bytes32,bytes32,uint32,uint64)":{"notice":"Sets fuses of a name that you own the parent of"},"setFuses(bytes32,uint16)":{"notice":"Sets fuses of a name"},"setMetadataService(address)":{"notice":"Set the metadata service. Only the owner can do this"},"setRecord(bytes32,address,address,uint64)":{"notice":"Sets records for the name in the ENS Registry"},"setResolver(bytes32,address)":{"notice":"Sets resolver contract in the registry"},"setSubnodeOwner(bytes32,string,address,uint32,uint64)":{"notice":"Sets the subdomain owner in the registry and then wraps the subdomain"},"setSubnodeRecord(bytes32,string,address,address,uint64,uint32,uint64)":{"notice":"Sets the subdomain owner in the registry with records and then wraps the subdomain"},"setTTL(bytes32,uint64)":{"notice":"Sets TTL in the registry"},"setUpgradeContract(address)":{"notice":"Set the address of the upgradeContract of the contract. only admin can do this"},"unwrap(bytes32,bytes32,address)":{"notice":"Unwraps a non .eth domain, of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain"},"unwrapETH2LD(bytes32,address,address)":{"notice":"Unwraps a .eth domain. e.g. vitalik.eth"},"upgrade(bytes,bytes)":{"notice":"Upgrades a domain of any kind. Could be a .eth name vitalik.eth, a DNSSEC name vitalik.xyz, or a subdomain"},"uri(uint256)":{"notice":"Get the metadata uri"},"wrap(bytes,address,address)":{"notice":"Wraps a non .eth domain, of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain"},"wrapETH2LD(string,address,uint16,address)":{"notice":"Wraps a .eth domain, creating a new token and sending the original ERC721 token to this contract"}},"version":1},"storageLayout":{"storage":[{"astId":444,"contract":"contracts/wrapper/NameWrapper.sol:NameWrapper","label":"_owner","offset":0,"slot":"0","type":"t_address"},{"astId":20114,"contract":"contracts/wrapper/NameWrapper.sol:NameWrapper","label":"_tokens","offset":0,"slot":"1","type":"t_mapping(t_uint256,t_uint256)"},{"astId":20120,"contract":"contracts/wrapper/NameWrapper.sol:NameWrapper","label":"_operatorApprovals","offset":0,"slot":"2","type":"t_mapping(t_address,t_mapping(t_address,t_bool))"},{"astId":20124,"contract":"contracts/wrapper/NameWrapper.sol:NameWrapper","label":"_tokenApprovals","offset":0,"slot":"3","type":"t_mapping(t_uint256,t_address)"},{"astId":20045,"contract":"contracts/wrapper/NameWrapper.sol:NameWrapper","label":"controllers","offset":0,"slot":"4","type":"t_mapping(t_address,t_bool)"},{"astId":21586,"contract":"contracts/wrapper/NameWrapper.sol:NameWrapper","label":"metadataService","offset":0,"slot":"5","type":"t_contract(IMetadataService)21088"},{"astId":21590,"contract":"contracts/wrapper/NameWrapper.sol:NameWrapper","label":"names","offset":0,"slot":"6","type":"t_mapping(t_bytes32,t_bytes_storage)"},{"astId":21608,"contract":"contracts/wrapper/NameWrapper.sol:NameWrapper","label":"upgradeContract","offset":0,"slot":"7","type":"t_contract(INameWrapperUpgrade)21480"}],"types":{"t_address":{"encoding":"inplace","label":"address","numberOfBytes":"20"},"t_bool":{"encoding":"inplace","label":"bool","numberOfBytes":"1"},"t_bytes32":{"encoding":"inplace","label":"bytes32","numberOfBytes":"32"},"t_bytes_storage":{"encoding":"bytes","label":"bytes","numberOfBytes":"32"},"t_contract(IMetadataService)21088":{"encoding":"inplace","label":"contract IMetadataService","numberOfBytes":"20"},"t_contract(INameWrapperUpgrade)21480":{"encoding":"inplace","label":"contract INameWrapperUpgrade","numberOfBytes":"20"},"t_mapping(t_address,t_bool)":{"encoding":"mapping","key":"t_address","label":"mapping(address => bool)","numberOfBytes":"32","value":"t_bool"},"t_mapping(t_address,t_mapping(t_address,t_bool))":{"encoding":"mapping","key":"t_address","label":"mapping(address => mapping(address => bool))","numberOfBytes":"32","value":"t_mapping(t_address,t_bool)"},"t_mapping(t_bytes32,t_bytes_storage)":{"encoding":"mapping","key":"t_bytes32","label":"mapping(bytes32 => bytes)","numberOfBytes":"32","value":"t_bytes_storage"},"t_mapping(t_uint256,t_address)":{"encoding":"mapping","key":"t_uint256","label":"mapping(uint256 => address)","numberOfBytes":"32","value":"t_address"},"t_mapping(t_uint256,t_uint256)":{"encoding":"mapping","key":"t_uint256","label":"mapping(uint256 => uint256)","numberOfBytes":"32","value":"t_uint256"},"t_uint256":{"encoding":"inplace","label":"uint256","numberOfBytes":"32"}}}}');

/***/ }),

/***/ "(rsc)/../../node_modules/@agentic-trust/8004-ext-sdk/dist/abis/PublicResolver.json":
/*!************************************************************************************!*\
  !*** ../../node_modules/@agentic-trust/8004-ext-sdk/dist/abis/PublicResolver.json ***!
  \************************************************************************************/
/***/ ((module) => {

module.exports = /*#__PURE__*/JSON.parse('{"address":"0xE99638b40E4Fff0129D56f03b55b6bbC4BBE49b5","abi":[{"inputs":[{"internalType":"contract ENS","name":"_ens","type":"address"},{"internalType":"contract INameWrapper","name":"wrapperAddress","type":"address"},{"internalType":"address","name":"_trustedETHController","type":"address"},{"internalType":"address","name":"_trustedReverseRegistrar","type":"address"}],"stateMutability":"nonpayable","type":"constructor"},{"inputs":[{"internalType":"bytes","name":"addressBytes","type":"bytes"}],"name":"InvalidEVMAddress","type":"error"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"node","type":"bytes32"},{"indexed":true,"internalType":"uint256","name":"contentType","type":"uint256"}],"name":"ABIChanged","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"node","type":"bytes32"},{"indexed":false,"internalType":"address","name":"a","type":"address"}],"name":"AddrChanged","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"node","type":"bytes32"},{"indexed":false,"internalType":"uint256","name":"coinType","type":"uint256"},{"indexed":false,"internalType":"bytes","name":"newAddress","type":"bytes"}],"name":"AddressChanged","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"owner","type":"address"},{"indexed":true,"internalType":"address","name":"operator","type":"address"},{"indexed":false,"internalType":"bool","name":"approved","type":"bool"}],"name":"ApprovalForAll","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"owner","type":"address"},{"indexed":true,"internalType":"bytes32","name":"node","type":"bytes32"},{"indexed":true,"internalType":"address","name":"delegate","type":"address"},{"indexed":true,"internalType":"bool","name":"approved","type":"bool"}],"name":"Approved","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"node","type":"bytes32"},{"indexed":false,"internalType":"bytes","name":"hash","type":"bytes"}],"name":"ContenthashChanged","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"node","type":"bytes32"},{"indexed":false,"internalType":"bytes","name":"name","type":"bytes"},{"indexed":false,"internalType":"uint16","name":"resource","type":"uint16"},{"indexed":false,"internalType":"bytes","name":"record","type":"bytes"}],"name":"DNSRecordChanged","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"node","type":"bytes32"},{"indexed":false,"internalType":"bytes","name":"name","type":"bytes"},{"indexed":false,"internalType":"uint16","name":"resource","type":"uint16"}],"name":"DNSRecordDeleted","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"node","type":"bytes32"},{"indexed":false,"internalType":"bytes","name":"lastzonehash","type":"bytes"},{"indexed":false,"internalType":"bytes","name":"zonehash","type":"bytes"}],"name":"DNSZonehashChanged","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"node","type":"bytes32"},{"indexed":true,"internalType":"bytes4","name":"interfaceID","type":"bytes4"},{"indexed":false,"internalType":"address","name":"implementer","type":"address"}],"name":"InterfaceChanged","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"node","type":"bytes32"},{"indexed":false,"internalType":"string","name":"name","type":"string"}],"name":"NameChanged","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"node","type":"bytes32"},{"indexed":false,"internalType":"bytes32","name":"x","type":"bytes32"},{"indexed":false,"internalType":"bytes32","name":"y","type":"bytes32"}],"name":"PubkeyChanged","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"node","type":"bytes32"},{"indexed":true,"internalType":"string","name":"indexedKey","type":"string"},{"indexed":false,"internalType":"string","name":"key","type":"string"},{"indexed":false,"internalType":"string","name":"value","type":"string"}],"name":"TextChanged","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"node","type":"bytes32"},{"indexed":false,"internalType":"uint64","name":"newVersion","type":"uint64"}],"name":"VersionChanged","type":"event"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"},{"internalType":"uint256","name":"contentTypes","type":"uint256"}],"name":"ABI","outputs":[{"internalType":"uint256","name":"","type":"uint256"},{"internalType":"bytes","name":"","type":"bytes"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"addr","outputs":[{"internalType":"address payable","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"},{"internalType":"uint256","name":"coinType","type":"uint256"}],"name":"addr","outputs":[{"internalType":"bytes","name":"addressBytes","type":"bytes"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"},{"internalType":"address","name":"delegate","type":"address"},{"internalType":"bool","name":"approved","type":"bool"}],"name":"approve","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"clearRecords","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"contenthash","outputs":[{"internalType":"bytes","name":"","type":"bytes"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"},{"internalType":"bytes32","name":"name","type":"bytes32"},{"internalType":"uint16","name":"resource","type":"uint16"}],"name":"dnsRecord","outputs":[{"internalType":"bytes","name":"","type":"bytes"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"},{"internalType":"uint256","name":"coinType","type":"uint256"}],"name":"hasAddr","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"},{"internalType":"bytes32","name":"name","type":"bytes32"}],"name":"hasDNSRecords","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"},{"internalType":"bytes4","name":"interfaceID","type":"bytes4"}],"name":"interfaceImplementer","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"owner","type":"address"},{"internalType":"bytes32","name":"node","type":"bytes32"},{"internalType":"address","name":"delegate","type":"address"}],"name":"isApprovedFor","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"account","type":"address"},{"internalType":"address","name":"operator","type":"address"}],"name":"isApprovedForAll","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"data","type":"bytes[]"}],"name":"multicall","outputs":[{"internalType":"bytes[]","name":"results","type":"bytes[]"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"nodehash","type":"bytes32"},{"internalType":"bytes[]","name":"data","type":"bytes[]"}],"name":"multicallWithNodeCheck","outputs":[{"internalType":"bytes[]","name":"results","type":"bytes[]"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"name","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"pubkey","outputs":[{"internalType":"bytes32","name":"x","type":"bytes32"},{"internalType":"bytes32","name":"y","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"name":"recordVersions","outputs":[{"internalType":"uint64","name":"","type":"uint64"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"},{"internalType":"uint256","name":"contentType","type":"uint256"},{"internalType":"bytes","name":"data","type":"bytes"}],"name":"setABI","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"},{"internalType":"uint256","name":"coinType","type":"uint256"},{"internalType":"bytes","name":"addressBytes","type":"bytes"}],"name":"setAddr","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"},{"internalType":"address","name":"_addr","type":"address"}],"name":"setAddr","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"operator","type":"address"},{"internalType":"bool","name":"approved","type":"bool"}],"name":"setApprovalForAll","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"},{"internalType":"bytes","name":"hash","type":"bytes"}],"name":"setContenthash","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"},{"internalType":"bytes","name":"data","type":"bytes"}],"name":"setDNSRecords","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"},{"internalType":"bytes4","name":"interfaceID","type":"bytes4"},{"internalType":"address","name":"implementer","type":"address"}],"name":"setInterface","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"},{"internalType":"string","name":"newName","type":"string"}],"name":"setName","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"},{"internalType":"bytes32","name":"x","type":"bytes32"},{"internalType":"bytes32","name":"y","type":"bytes32"}],"name":"setPubkey","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"},{"internalType":"string","name":"key","type":"string"},{"internalType":"string","name":"value","type":"string"}],"name":"setText","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"},{"internalType":"bytes","name":"hash","type":"bytes"}],"name":"setZonehash","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes4","name":"interfaceID","type":"bytes4"}],"name":"supportsInterface","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"},{"internalType":"string","name":"key","type":"string"}],"name":"text","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"zonehash","outputs":[{"internalType":"bytes","name":"","type":"bytes"}],"stateMutability":"view","type":"function"}],"transactionHash":"0xc32e1b668f2b54072ad52a8f1c240c2d6d045a4a4e5bccf0783d4cf5159601fe","receipt":{"to":null,"from":"0x0F32b753aFc8ABad9Ca6fE589F707755f4df2353","contractAddress":"0xE99638b40E4Fff0129D56f03b55b6bbC4BBE49b5","transactionIndex":91,"gasUsed":"3245285","logsBloom":"0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000020000200000000200000040000000008000000000000000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000010000000000000000000000000000000000000010200000008000000000080000000000040000000018000000000004000000000000008010040000000000000000000000000000000000005002000002000000000000800000000000000000000000000000000020000100000000000000001000000000000000000000","blockHash":"0xe7a054cdd5aa5d82d7c74e111dbb1441961b638973aa4f1b7ce8dcf7eb14e720","transactionHash":"0xc32e1b668f2b54072ad52a8f1c240c2d6d045a4a4e5bccf0783d4cf5159601fe","logs":[{"transactionIndex":91,"blockNumber":8580001,"transactionHash":"0xc32e1b668f2b54072ad52a8f1c240c2d6d045a4a4e5bccf0783d4cf5159601fe","address":"0xA0a1AbcDAe1a2a4A2EF8e9113Ff0e02DD81DC0C6","topics":["0x6ada868dd3058cf77a48a74489fd7963688e5464b2b0fa957ace976243270e92","0x000000000000000000000000e99638b40e4fff0129d56f03b55b6bbc4bbe49b5","0xc80503aa696a6808506ee7ad5a6ac5592bdd9b82df4be83b7878d4f021211078"],"data":"0x","logIndex":134,"blockHash":"0xe7a054cdd5aa5d82d7c74e111dbb1441961b638973aa4f1b7ce8dcf7eb14e720"},{"transactionIndex":91,"blockNumber":8580001,"transactionHash":"0xc32e1b668f2b54072ad52a8f1c240c2d6d045a4a4e5bccf0783d4cf5159601fe","address":"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e","topics":["0xce0457fe73731f824cc272376169235128c118b49d344817417c6d108d155e82","0x91d1777781884d03a6757a803996e38de2a42967fb37eeaca72729271025a9e2","0x90c0ba0bf94c247a45dd232535f5c24affdcc31676849cd7ff4993579ed74ce8"],"data":"0x0000000000000000000000000f32b753afc8abad9ca6fe589f707755f4df2353","logIndex":135,"blockHash":"0xe7a054cdd5aa5d82d7c74e111dbb1441961b638973aa4f1b7ce8dcf7eb14e720"},{"transactionIndex":91,"blockNumber":8580001,"transactionHash":"0xc32e1b668f2b54072ad52a8f1c240c2d6d045a4a4e5bccf0783d4cf5159601fe","address":"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e","topics":["0x335721b01866dc23fbee8b6b2c7b1e14d6f05c28cd35a2c934239f94095602a0","0xc80503aa696a6808506ee7ad5a6ac5592bdd9b82df4be83b7878d4f021211078"],"data":"0x000000000000000000000000519f981afc637fdad26c8669b0991b9977b0a216","logIndex":136,"blockHash":"0xe7a054cdd5aa5d82d7c74e111dbb1441961b638973aa4f1b7ce8dcf7eb14e720"}],"blockNumber":8580001,"cumulativeGasUsed":"11373920","status":1,"byzantium":true},"args":["0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e","0x0635513f179D50A207757E05759CbD106d7dFcE8","0xfb3cE5D01e0f33f41DbB39035dB9745962F1f968","0xA0a1AbcDAe1a2a4A2EF8e9113Ff0e02DD81DC0C6"],"numDeployments":3,"solcInputHash":"53607203823ca934dc777094bb2d514e","metadata":"{\\"compiler\\":{\\"version\\":\\"0.8.26+commit.8a97fa7a\\"},\\"language\\":\\"Solidity\\",\\"output\\":{\\"abi\\":[{\\"inputs\\":[{\\"internalType\\":\\"contract ENS\\",\\"name\\":\\"_ens\\",\\"type\\":\\"address\\"},{\\"internalType\\":\\"contract INameWrapper\\",\\"name\\":\\"wrapperAddress\\",\\"type\\":\\"address\\"},{\\"internalType\\":\\"address\\",\\"name\\":\\"_trustedETHController\\",\\"type\\":\\"address\\"},{\\"internalType\\":\\"address\\",\\"name\\":\\"_trustedReverseRegistrar\\",\\"type\\":\\"address\\"}],\\"stateMutability\\":\\"nonpayable\\",\\"type\\":\\"constructor\\"},{\\"inputs\\":[{\\"internalType\\":\\"bytes\\",\\"name\\":\\"addressBytes\\",\\"type\\":\\"bytes\\"}],\\"name\\":\\"InvalidEVMAddress\\",\\"type\\":\\"error\\"},{\\"anonymous\\":false,\\"inputs\\":[{\\"indexed\\":true,\\"internalType\\":\\"bytes32\\",\\"name\\":\\"node\\",\\"type\\":\\"bytes32\\"},{\\"indexed\\":true,\\"internalType\\":\\"uint256\\",\\"name\\":\\"contentType\\",\\"type\\":\\"uint256\\"}],\\"name\\":\\"ABIChanged\\",\\"type\\":\\"event\\"},{\\"anonymous\\":false,\\"inputs\\":[{\\"indexed\\":true,\\"internalType\\":\\"bytes32\\",\\"name\\":\\"node\\",\\"type\\":\\"bytes32\\"},{\\"indexed\\":false,\\"internalType\\":\\"address\\",\\"name\\":\\"a\\",\\"type\\":\\"address\\"}],\\"name\\":\\"AddrChanged\\",\\"type\\":\\"event\\"},{\\"anonymous\\":false,\\"inputs\\":[{\\"indexed\\":true,\\"internalType\\":\\"bytes32\\",\\"name\\":\\"node\\",\\"type\\":\\"bytes32\\"},{\\"indexed\\":false,\\"internalType\\":\\"uint256\\",\\"name\\":\\"coinType\\",\\"type\\":\\"uint256\\"},{\\"indexed\\":false,\\"internalType\\":\\"bytes\\",\\"name\\":\\"newAddress\\",\\"type\\":\\"bytes\\"}],\\"name\\":\\"AddressChanged\\",\\"type\\":\\"event\\"},{\\"anonymous\\":false,\\"inputs\\":[{\\"indexed\\":true,\\"internalType\\":\\"address\\",\\"name\\":\\"owner\\",\\"type\\":\\"address\\"},{\\"indexed\\":true,\\"internalType\\":\\"address\\",\\"name\\":\\"operator\\",\\"type\\":\\"address\\"},{\\"indexed\\":false,\\"internalType\\":\\"bool\\",\\"name\\":\\"approved\\",\\"type\\":\\"bool\\"}],\\"name\\":\\"ApprovalForAll\\",\\"type\\":\\"event\\"},{\\"anonymous\\":false,\\"inputs\\":[{\\"indexed\\":false,\\"internalType\\":\\"address\\",\\"name\\":\\"owner\\",\\"type\\":\\"address\\"},{\\"indexed\\":true,\\"internalType\\":\\"bytes32\\",\\"name\\":\\"node\\",\\"type\\":\\"bytes32\\"},{\\"indexed\\":true,\\"internalType\\":\\"address\\",\\"name\\":\\"delegate\\",\\"type\\":\\"address\\"},{\\"indexed\\":true,\\"internalType\\":\\"bool\\",\\"name\\":\\"approved\\",\\"type\\":\\"bool\\"}],\\"name\\":\\"Approved\\",\\"type\\":\\"event\\"},{\\"anonymous\\":false,\\"inputs\\":[{\\"indexed\\":true,\\"internalType\\":\\"bytes32\\",\\"name\\":\\"node\\",\\"type\\":\\"bytes32\\"},{\\"indexed\\":false,\\"internalType\\":\\"bytes\\",\\"name\\":\\"hash\\",\\"type\\":\\"bytes\\"}],\\"name\\":\\"ContenthashChanged\\",\\"type\\":\\"event\\"},{\\"anonymous\\":false,\\"inputs\\":[{\\"indexed\\":true,\\"internalType\\":\\"bytes32\\",\\"name\\":\\"node\\",\\"type\\":\\"bytes32\\"},{\\"indexed\\":false,\\"internalType\\":\\"bytes\\",\\"name\\":\\"name\\",\\"type\\":\\"bytes\\"},{\\"indexed\\":false,\\"internalType\\":\\"uint16\\",\\"name\\":\\"resource\\",\\"type\\":\\"uint16\\"},{\\"indexed\\":false,\\"internalType\\":\\"bytes\\",\\"name\\":\\"record\\",\\"type\\":\\"bytes\\"}],\\"name\\":\\"DNSRecordChanged\\",\\"type\\":\\"event\\"},{\\"anonymous\\":false,\\"inputs\\":[{\\"indexed\\":true,\\"internalType\\":\\"bytes32\\",\\"name\\":\\"node\\",\\"type\\":\\"bytes32\\"},{\\"indexed\\":false,\\"internalType\\":\\"bytes\\",\\"name\\":\\"name\\",\\"type\\":\\"bytes\\"},{\\"indexed\\":false,\\"internalType\\":\\"uint16\\",\\"name\\":\\"resource\\",\\"type\\":\\"uint16\\"}],\\"name\\":\\"DNSRecordDeleted\\",\\"type\\":\\"event\\"},{\\"anonymous\\":false,\\"inputs\\":[{\\"indexed\\":true,\\"internalType\\":\\"bytes32\\",\\"name\\":\\"node\\",\\"type\\":\\"bytes32\\"},{\\"indexed\\":false,\\"internalType\\":\\"bytes\\",\\"name\\":\\"lastzonehash\\",\\"type\\":\\"bytes\\"},{\\"indexed\\":false,\\"internalType\\":\\"bytes\\",\\"name\\":\\"zonehash\\",\\"type\\":\\"bytes\\"}],\\"name\\":\\"DNSZonehashChanged\\",\\"type\\":\\"event\\"},{\\"anonymous\\":false,\\"inputs\\":[{\\"indexed\\":true,\\"internalType\\":\\"bytes32\\",\\"name\\":\\"node\\",\\"type\\":\\"bytes32\\"},{\\"indexed\\":true,\\"internalType\\":\\"bytes4\\",\\"name\\":\\"interfaceID\\",\\"type\\":\\"bytes4\\"},{\\"indexed\\":false,\\"internalType\\":\\"address\\",\\"name\\":\\"implementer\\",\\"type\\":\\"address\\"}],\\"name\\":\\"InterfaceChanged\\",\\"type\\":\\"event\\"},{\\"anonymous\\":false,\\"inputs\\":[{\\"indexed\\":true,\\"internalType\\":\\"bytes32\\",\\"name\\":\\"node\\",\\"type\\":\\"bytes32\\"},{\\"indexed\\":false,\\"internalType\\":\\"string\\",\\"name\\":\\"name\\",\\"type\\":\\"string\\"}],\\"name\\":\\"NameChanged\\",\\"type\\":\\"event\\"},{\\"anonymous\\":false,\\"inputs\\":[{\\"indexed\\":true,\\"internalType\\":\\"bytes32\\",\\"name\\":\\"node\\",\\"type\\":\\"bytes32\\"},{\\"indexed\\":false,\\"internalType\\":\\"bytes32\\",\\"name\\":\\"x\\",\\"type\\":\\"bytes32\\"},{\\"indexed\\":false,\\"internalType\\":\\"bytes32\\",\\"name\\":\\"y\\",\\"type\\":\\"bytes32\\"}],\\"name\\":\\"PubkeyChanged\\",\\"type\\":\\"event\\"},{\\"anonymous\\":false,\\"inputs\\":[{\\"indexed\\":true,\\"internalType\\":\\"bytes32\\",\\"name\\":\\"node\\",\\"type\\":\\"bytes32\\"},{\\"indexed\\":true,\\"internalType\\":\\"string\\",\\"name\\":\\"indexedKey\\",\\"type\\":\\"string\\"},{\\"indexed\\":false,\\"internalType\\":\\"string\\",\\"name\\":\\"key\\",\\"type\\":\\"string\\"},{\\"indexed\\":false,\\"internalType\\":\\"string\\",\\"name\\":\\"value\\",\\"type\\":\\"string\\"}],\\"name\\":\\"TextChanged\\",\\"type\\":\\"event\\"},{\\"anonymous\\":false,\\"inputs\\":[{\\"indexed\\":true,\\"internalType\\":\\"bytes32\\",\\"name\\":\\"node\\",\\"type\\":\\"bytes32\\"},{\\"indexed\\":false,\\"internalType\\":\\"uint64\\",\\"name\\":\\"newVersion\\",\\"type\\":\\"uint64\\"}],\\"name\\":\\"VersionChanged\\",\\"type\\":\\"event\\"},{\\"inputs\\":[{\\"internalType\\":\\"bytes32\\",\\"name\\":\\"node\\",\\"type\\":\\"bytes32\\"},{\\"internalType\\":\\"uint256\\",\\"name\\":\\"contentTypes\\",\\"type\\":\\"uint256\\"}],\\"name\\":\\"ABI\\",\\"outputs\\":[{\\"internalType\\":\\"uint256\\",\\"name\\":\\"\\",\\"type\\":\\"uint256\\"},{\\"internalType\\":\\"bytes\\",\\"name\\":\\"\\",\\"type\\":\\"bytes\\"}],\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"},{\\"inputs\\":[{\\"internalType\\":\\"bytes32\\",\\"name\\":\\"node\\",\\"type\\":\\"bytes32\\"}],\\"name\\":\\"addr\\",\\"outputs\\":[{\\"internalType\\":\\"address payable\\",\\"name\\":\\"\\",\\"type\\":\\"address\\"}],\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"},{\\"inputs\\":[{\\"internalType\\":\\"bytes32\\",\\"name\\":\\"node\\",\\"type\\":\\"bytes32\\"},{\\"internalType\\":\\"uint256\\",\\"name\\":\\"coinType\\",\\"type\\":\\"uint256\\"}],\\"name\\":\\"addr\\",\\"outputs\\":[{\\"internalType\\":\\"bytes\\",\\"name\\":\\"addressBytes\\",\\"type\\":\\"bytes\\"}],\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"},{\\"inputs\\":[{\\"internalType\\":\\"bytes32\\",\\"name\\":\\"node\\",\\"type\\":\\"bytes32\\"},{\\"internalType\\":\\"address\\",\\"name\\":\\"delegate\\",\\"type\\":\\"address\\"},{\\"internalType\\":\\"bool\\",\\"name\\":\\"approved\\",\\"type\\":\\"bool\\"}],\\"name\\":\\"approve\\",\\"outputs\\":[],\\"stateMutability\\":\\"nonpayable\\",\\"type\\":\\"function\\"},{\\"inputs\\":[{\\"internalType\\":\\"bytes32\\",\\"name\\":\\"node\\",\\"type\\":\\"bytes32\\"}],\\"name\\":\\"clearRecords\\",\\"outputs\\":[],\\"stateMutability\\":\\"nonpayable\\",\\"type\\":\\"function\\"},{\\"inputs\\":[{\\"internalType\\":\\"bytes32\\",\\"name\\":\\"node\\",\\"type\\":\\"bytes32\\"}],\\"name\\":\\"contenthash\\",\\"outputs\\":[{\\"internalType\\":\\"bytes\\",\\"name\\":\\"\\",\\"type\\":\\"bytes\\"}],\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"},{\\"inputs\\":[{\\"internalType\\":\\"bytes32\\",\\"name\\":\\"node\\",\\"type\\":\\"bytes32\\"},{\\"internalType\\":\\"bytes32\\",\\"name\\":\\"name\\",\\"type\\":\\"bytes32\\"},{\\"internalType\\":\\"uint16\\",\\"name\\":\\"resource\\",\\"type\\":\\"uint16\\"}],\\"name\\":\\"dnsRecord\\",\\"outputs\\":[{\\"internalType\\":\\"bytes\\",\\"name\\":\\"\\",\\"type\\":\\"bytes\\"}],\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"},{\\"inputs\\":[{\\"internalType\\":\\"bytes32\\",\\"name\\":\\"node\\",\\"type\\":\\"bytes32\\"},{\\"internalType\\":\\"uint256\\",\\"name\\":\\"coinType\\",\\"type\\":\\"uint256\\"}],\\"name\\":\\"hasAddr\\",\\"outputs\\":[{\\"internalType\\":\\"bool\\",\\"name\\":\\"\\",\\"type\\":\\"bool\\"}],\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"},{\\"inputs\\":[{\\"internalType\\":\\"bytes32\\",\\"name\\":\\"node\\",\\"type\\":\\"bytes32\\"},{\\"internalType\\":\\"bytes32\\",\\"name\\":\\"name\\",\\"type\\":\\"bytes32\\"}],\\"name\\":\\"hasDNSRecords\\",\\"outputs\\":[{\\"internalType\\":\\"bool\\",\\"name\\":\\"\\",\\"type\\":\\"bool\\"}],\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"},{\\"inputs\\":[{\\"internalType\\":\\"bytes32\\",\\"name\\":\\"node\\",\\"type\\":\\"bytes32\\"},{\\"internalType\\":\\"bytes4\\",\\"name\\":\\"interfaceID\\",\\"type\\":\\"bytes4\\"}],\\"name\\":\\"interfaceImplementer\\",\\"outputs\\":[{\\"internalType\\":\\"address\\",\\"name\\":\\"\\",\\"type\\":\\"address\\"}],\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"},{\\"inputs\\":[{\\"internalType\\":\\"address\\",\\"name\\":\\"owner\\",\\"type\\":\\"address\\"},{\\"internalType\\":\\"bytes32\\",\\"name\\":\\"node\\",\\"type\\":\\"bytes32\\"},{\\"internalType\\":\\"address\\",\\"name\\":\\"delegate\\",\\"type\\":\\"address\\"}],\\"name\\":\\"isApprovedFor\\",\\"outputs\\":[{\\"internalType\\":\\"bool\\",\\"name\\":\\"\\",\\"type\\":\\"bool\\"}],\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"},{\\"inputs\\":[{\\"internalType\\":\\"address\\",\\"name\\":\\"account\\",\\"type\\":\\"address\\"},{\\"internalType\\":\\"address\\",\\"name\\":\\"operator\\",\\"type\\":\\"address\\"}],\\"name\\":\\"isApprovedForAll\\",\\"outputs\\":[{\\"internalType\\":\\"bool\\",\\"name\\":\\"\\",\\"type\\":\\"bool\\"}],\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"},{\\"inputs\\":[{\\"internalType\\":\\"bytes[]\\",\\"name\\":\\"data\\",\\"type\\":\\"bytes[]\\"}],\\"name\\":\\"multicall\\",\\"outputs\\":[{\\"internalType\\":\\"bytes[]\\",\\"name\\":\\"results\\",\\"type\\":\\"bytes[]\\"}],\\"stateMutability\\":\\"nonpayable\\",\\"type\\":\\"function\\"},{\\"inputs\\":[{\\"internalType\\":\\"bytes32\\",\\"name\\":\\"nodehash\\",\\"type\\":\\"bytes32\\"},{\\"internalType\\":\\"bytes[]\\",\\"name\\":\\"data\\",\\"type\\":\\"bytes[]\\"}],\\"name\\":\\"multicallWithNodeCheck\\",\\"outputs\\":[{\\"internalType\\":\\"bytes[]\\",\\"name\\":\\"results\\",\\"type\\":\\"bytes[]\\"}],\\"stateMutability\\":\\"nonpayable\\",\\"type\\":\\"function\\"},{\\"inputs\\":[{\\"internalType\\":\\"bytes32\\",\\"name\\":\\"node\\",\\"type\\":\\"bytes32\\"}],\\"name\\":\\"name\\",\\"outputs\\":[{\\"internalType\\":\\"string\\",\\"name\\":\\"\\",\\"type\\":\\"string\\"}],\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"},{\\"inputs\\":[{\\"internalType\\":\\"bytes32\\",\\"name\\":\\"node\\",\\"type\\":\\"bytes32\\"}],\\"name\\":\\"pubkey\\",\\"outputs\\":[{\\"internalType\\":\\"bytes32\\",\\"name\\":\\"x\\",\\"type\\":\\"bytes32\\"},{\\"internalType\\":\\"bytes32\\",\\"name\\":\\"y\\",\\"type\\":\\"bytes32\\"}],\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"},{\\"inputs\\":[{\\"internalType\\":\\"bytes32\\",\\"name\\":\\"\\",\\"type\\":\\"bytes32\\"}],\\"name\\":\\"recordVersions\\",\\"outputs\\":[{\\"internalType\\":\\"uint64\\",\\"name\\":\\"\\",\\"type\\":\\"uint64\\"}],\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"},{\\"inputs\\":[{\\"internalType\\":\\"bytes32\\",\\"name\\":\\"node\\",\\"type\\":\\"bytes32\\"},{\\"internalType\\":\\"uint256\\",\\"name\\":\\"contentType\\",\\"type\\":\\"uint256\\"},{\\"internalType\\":\\"bytes\\",\\"name\\":\\"data\\",\\"type\\":\\"bytes\\"}],\\"name\\":\\"setABI\\",\\"outputs\\":[],\\"stateMutability\\":\\"nonpayable\\",\\"type\\":\\"function\\"},{\\"inputs\\":[{\\"internalType\\":\\"bytes32\\",\\"name\\":\\"node\\",\\"type\\":\\"bytes32\\"},{\\"internalType\\":\\"uint256\\",\\"name\\":\\"coinType\\",\\"type\\":\\"uint256\\"},{\\"internalType\\":\\"bytes\\",\\"name\\":\\"addressBytes\\",\\"type\\":\\"bytes\\"}],\\"name\\":\\"setAddr\\",\\"outputs\\":[],\\"stateMutability\\":\\"nonpayable\\",\\"type\\":\\"function\\"},{\\"inputs\\":[{\\"internalType\\":\\"bytes32\\",\\"name\\":\\"node\\",\\"type\\":\\"bytes32\\"},{\\"internalType\\":\\"address\\",\\"name\\":\\"_addr\\",\\"type\\":\\"address\\"}],\\"name\\":\\"setAddr\\",\\"outputs\\":[],\\"stateMutability\\":\\"nonpayable\\",\\"type\\":\\"function\\"},{\\"inputs\\":[{\\"internalType\\":\\"address\\",\\"name\\":\\"operator\\",\\"type\\":\\"address\\"},{\\"internalType\\":\\"bool\\",\\"name\\":\\"approved\\",\\"type\\":\\"bool\\"}],\\"name\\":\\"setApprovalForAll\\",\\"outputs\\":[],\\"stateMutability\\":\\"nonpayable\\",\\"type\\":\\"function\\"},{\\"inputs\\":[{\\"internalType\\":\\"bytes32\\",\\"name\\":\\"node\\",\\"type\\":\\"bytes32\\"},{\\"internalType\\":\\"bytes\\",\\"name\\":\\"hash\\",\\"type\\":\\"bytes\\"}],\\"name\\":\\"setContenthash\\",\\"outputs\\":[],\\"stateMutability\\":\\"nonpayable\\",\\"type\\":\\"function\\"},{\\"inputs\\":[{\\"internalType\\":\\"bytes32\\",\\"name\\":\\"node\\",\\"type\\":\\"bytes32\\"},{\\"internalType\\":\\"bytes\\",\\"name\\":\\"data\\",\\"type\\":\\"bytes\\"}],\\"name\\":\\"setDNSRecords\\",\\"outputs\\":[],\\"stateMutability\\":\\"nonpayable\\",\\"type\\":\\"function\\"},{\\"inputs\\":[{\\"internalType\\":\\"bytes32\\",\\"name\\":\\"node\\",\\"type\\":\\"bytes32\\"},{\\"internalType\\":\\"bytes4\\",\\"name\\":\\"interfaceID\\",\\"type\\":\\"bytes4\\"},{\\"internalType\\":\\"address\\",\\"name\\":\\"implementer\\",\\"type\\":\\"address\\"}],\\"name\\":\\"setInterface\\",\\"outputs\\":[],\\"stateMutability\\":\\"nonpayable\\",\\"type\\":\\"function\\"},{\\"inputs\\":[{\\"internalType\\":\\"bytes32\\",\\"name\\":\\"node\\",\\"type\\":\\"bytes32\\"},{\\"internalType\\":\\"string\\",\\"name\\":\\"newName\\",\\"type\\":\\"string\\"}],\\"name\\":\\"setName\\",\\"outputs\\":[],\\"stateMutability\\":\\"nonpayable\\",\\"type\\":\\"function\\"},{\\"inputs\\":[{\\"internalType\\":\\"bytes32\\",\\"name\\":\\"node\\",\\"type\\":\\"bytes32\\"},{\\"internalType\\":\\"bytes32\\",\\"name\\":\\"x\\",\\"type\\":\\"bytes32\\"},{\\"internalType\\":\\"bytes32\\",\\"name\\":\\"y\\",\\"type\\":\\"bytes32\\"}],\\"name\\":\\"setPubkey\\",\\"outputs\\":[],\\"stateMutability\\":\\"nonpayable\\",\\"type\\":\\"function\\"},{\\"inputs\\":[{\\"internalType\\":\\"bytes32\\",\\"name\\":\\"node\\",\\"type\\":\\"bytes32\\"},{\\"internalType\\":\\"string\\",\\"name\\":\\"key\\",\\"type\\":\\"string\\"},{\\"internalType\\":\\"string\\",\\"name\\":\\"value\\",\\"type\\":\\"string\\"}],\\"name\\":\\"setText\\",\\"outputs\\":[],\\"stateMutability\\":\\"nonpayable\\",\\"type\\":\\"function\\"},{\\"inputs\\":[{\\"internalType\\":\\"bytes32\\",\\"name\\":\\"node\\",\\"type\\":\\"bytes32\\"},{\\"internalType\\":\\"bytes\\",\\"name\\":\\"hash\\",\\"type\\":\\"bytes\\"}],\\"name\\":\\"setZonehash\\",\\"outputs\\":[],\\"stateMutability\\":\\"nonpayable\\",\\"type\\":\\"function\\"},{\\"inputs\\":[{\\"internalType\\":\\"bytes4\\",\\"name\\":\\"interfaceID\\",\\"type\\":\\"bytes4\\"}],\\"name\\":\\"supportsInterface\\",\\"outputs\\":[{\\"internalType\\":\\"bool\\",\\"name\\":\\"\\",\\"type\\":\\"bool\\"}],\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"},{\\"inputs\\":[{\\"internalType\\":\\"bytes32\\",\\"name\\":\\"node\\",\\"type\\":\\"bytes32\\"},{\\"internalType\\":\\"string\\",\\"name\\":\\"key\\",\\"type\\":\\"string\\"}],\\"name\\":\\"text\\",\\"outputs\\":[{\\"internalType\\":\\"string\\",\\"name\\":\\"\\",\\"type\\":\\"string\\"}],\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"},{\\"inputs\\":[{\\"internalType\\":\\"bytes32\\",\\"name\\":\\"node\\",\\"type\\":\\"bytes32\\"}],\\"name\\":\\"zonehash\\",\\"outputs\\":[{\\"internalType\\":\\"bytes\\",\\"name\\":\\"\\",\\"type\\":\\"bytes\\"}],\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"}],\\"devdoc\\":{\\"errors\\":{\\"InvalidEVMAddress(bytes)\\":[{\\"details\\":\\"Error selector: `0x8d666f60`\\"}]},\\"kind\\":\\"dev\\",\\"methods\\":{\\"ABI(bytes32,uint256)\\":{\\"params\\":{\\"contentTypes\\":\\"A bitwise OR of the ABI formats accepted by the caller.\\",\\"node\\":\\"The ENS node to query\\"},\\"returns\\":{\\"_0\\":\\"contentType The content type of the return value\\",\\"_1\\":\\"data The ABI data\\"}},\\"addr(bytes32)\\":{\\"params\\":{\\"node\\":\\"The node to query.\\"},\\"returns\\":{\\"_0\\":\\"The associated address.\\"}},\\"addr(bytes32,uint256)\\":{\\"params\\":{\\"coinType\\":\\"The coin type.\\",\\"node\\":\\"The node to query.\\"},\\"returns\\":{\\"addressBytes\\":\\"The assocated address.\\"}},\\"approve(bytes32,address,bool)\\":{\\"details\\":\\"Approve a delegate to be able to updated records on a node.\\"},\\"clearRecords(bytes32)\\":{\\"params\\":{\\"node\\":\\"The node to update.\\"}},\\"contenthash(bytes32)\\":{\\"params\\":{\\"node\\":\\"The ENS node to query.\\"},\\"returns\\":{\\"_0\\":\\"The associated contenthash.\\"}},\\"dnsRecord(bytes32,bytes32,uint16)\\":{\\"params\\":{\\"name\\":\\"the keccak-256 hash of the fully-qualified name for which to fetch the record\\",\\"node\\":\\"the namehash of the node for which to fetch the record\\",\\"resource\\":\\"the ID of the resource as per https://en.wikipedia.org/wiki/List_of_DNS_record_types\\"},\\"returns\\":{\\"_0\\":\\"the DNS record in wire format if present, otherwise empty\\"}},\\"hasAddr(bytes32,uint256)\\":{\\"params\\":{\\"coinType\\":\\"The coin type.\\",\\"node\\":\\"The node to query.\\"},\\"returns\\":{\\"_0\\":\\"True if the associated address is not empty.\\"}},\\"hasDNSRecords(bytes32,bytes32)\\":{\\"params\\":{\\"name\\":\\"the namehash of the node for which to check the records\\",\\"node\\":\\"the namehash of the node for which to check the records\\"}},\\"interfaceImplementer(bytes32,bytes4)\\":{\\"params\\":{\\"interfaceID\\":\\"The EIP 165 interface ID to check for.\\",\\"node\\":\\"The ENS node to query.\\"},\\"returns\\":{\\"_0\\":\\"The address that implements this interface, or 0 if the interface is unsupported.\\"}},\\"isApprovedFor(address,bytes32,address)\\":{\\"details\\":\\"Check to see if the delegate has been approved by the owner for the node.\\"},\\"isApprovedForAll(address,address)\\":{\\"details\\":\\"See {IERC1155-isApprovedForAll}.\\"},\\"name(bytes32)\\":{\\"params\\":{\\"node\\":\\"The ENS node to query.\\"},\\"returns\\":{\\"_0\\":\\"The associated name.\\"}},\\"pubkey(bytes32)\\":{\\"params\\":{\\"node\\":\\"The ENS node to query\\"},\\"returns\\":{\\"x\\":\\"The X coordinate of the curve point for the public key.\\",\\"y\\":\\"The Y coordinate of the curve point for the public key.\\"}},\\"setABI(bytes32,uint256,bytes)\\":{\\"params\\":{\\"contentType\\":\\"The content type of the ABI\\",\\"data\\":\\"The ABI data.\\",\\"node\\":\\"The node to update.\\"}},\\"setAddr(bytes32,address)\\":{\\"params\\":{\\"_addr\\":\\"The address to set.\\",\\"node\\":\\"The node to update.\\"}},\\"setAddr(bytes32,uint256,bytes)\\":{\\"params\\":{\\"addressBytes\\":\\"The address to set.\\",\\"coinType\\":\\"The coin type.\\",\\"node\\":\\"The node to update.\\"}},\\"setApprovalForAll(address,bool)\\":{\\"details\\":\\"See {IERC1155-setApprovalForAll}.\\"},\\"setContenthash(bytes32,bytes)\\":{\\"params\\":{\\"hash\\":\\"The contenthash to set\\",\\"node\\":\\"The node to update.\\"}},\\"setDNSRecords(bytes32,bytes)\\":{\\"params\\":{\\"data\\":\\"the DNS wire format records to set\\",\\"node\\":\\"the namehash of the node for which to set the records\\"}},\\"setInterface(bytes32,bytes4,address)\\":{\\"params\\":{\\"implementer\\":\\"The address of a contract that implements this interface for this node.\\",\\"interfaceID\\":\\"The EIP 165 interface ID.\\",\\"node\\":\\"The node to update.\\"}},\\"setName(bytes32,string)\\":{\\"params\\":{\\"node\\":\\"The node to update.\\"}},\\"setPubkey(bytes32,bytes32,bytes32)\\":{\\"params\\":{\\"node\\":\\"The ENS node to query\\",\\"x\\":\\"the X coordinate of the curve point for the public key.\\",\\"y\\":\\"the Y coordinate of the curve point for the public key.\\"}},\\"setText(bytes32,string,string)\\":{\\"params\\":{\\"key\\":\\"The key to set.\\",\\"node\\":\\"The node to update.\\",\\"value\\":\\"The text data value to set.\\"}},\\"setZonehash(bytes32,bytes)\\":{\\"params\\":{\\"hash\\":\\"The zonehash to set\\",\\"node\\":\\"The node to update.\\"}},\\"text(bytes32,string)\\":{\\"params\\":{\\"key\\":\\"The text data key to query.\\",\\"node\\":\\"The ENS node to query.\\"},\\"returns\\":{\\"_0\\":\\"The associated text data.\\"}},\\"zonehash(bytes32)\\":{\\"params\\":{\\"node\\":\\"The ENS node to query.\\"},\\"returns\\":{\\"_0\\":\\"The associated contenthash.\\"}}},\\"version\\":1},\\"userdoc\\":{\\"errors\\":{\\"InvalidEVMAddress(bytes)\\":[{\\"notice\\":\\"The supplied address could not be converted to `address`.\\"}]},\\"kind\\":\\"user\\",\\"methods\\":{\\"ABI(bytes32,uint256)\\":{\\"notice\\":\\"Returns the ABI associated with an ENS node. Defined in EIP205.\\"},\\"addr(bytes32)\\":{\\"notice\\":\\"Get `addr(60)` as `address` of the associated ENS node.\\"},\\"addr(bytes32,uint256)\\":{\\"notice\\":\\"Get the address for coin type of the associated ENS node.         If coin type is EVM and empty, defaults to `addr(COIN_TYPE_DEFAULT)`.\\"},\\"clearRecords(bytes32)\\":{\\"notice\\":\\"Increments the record version associated with an ENS node. May only be called by the owner of that node in the ENS registry.\\"},\\"contenthash(bytes32)\\":{\\"notice\\":\\"Returns the contenthash associated with an ENS node.\\"},\\"dnsRecord(bytes32,bytes32,uint16)\\":{\\"notice\\":\\"Obtain a DNS record.\\"},\\"hasAddr(bytes32,uint256)\\":{\\"notice\\":\\"Determine if an addresss is stored for the coin type of the associated ENS node.\\"},\\"hasDNSRecords(bytes32,bytes32)\\":{\\"notice\\":\\"Check if a given node has records.\\"},\\"interfaceImplementer(bytes32,bytes4)\\":{\\"notice\\":\\"Returns the address of a contract that implements the specified interface for this name. If an implementer has not been set for this interfaceID and name, the resolver will query the contract at `addr()`. If `addr()` is set, a contract exists at that address, and that contract implements EIP165 and returns `true` for the specified interfaceID, its address will be returned.\\"},\\"name(bytes32)\\":{\\"notice\\":\\"Returns the name associated with an ENS node, for reverse records. Defined in EIP181.\\"},\\"pubkey(bytes32)\\":{\\"notice\\":\\"Returns the SECP256k1 public key associated with an ENS node. Defined in EIP 619.\\"},\\"setABI(bytes32,uint256,bytes)\\":{\\"notice\\":\\"Sets the ABI associated with an ENS node. Nodes may have one ABI of each content type. To remove an ABI, set it to the empty string.\\"},\\"setAddr(bytes32,address)\\":{\\"notice\\":\\"Set `addr(60)` of the associated ENS node.         `address(0)` is stored as `new bytes(20)`.\\"},\\"setAddr(bytes32,uint256,bytes)\\":{\\"notice\\":\\"Set the address for coin type of the associated ENS node.         Reverts `InvalidEVMAddress` if coin type is EVM and not 0 or 20 bytes.\\"},\\"setContenthash(bytes32,bytes)\\":{\\"notice\\":\\"Sets the contenthash associated with an ENS node. May only be called by the owner of that node in the ENS registry.\\"},\\"setDNSRecords(bytes32,bytes)\\":{\\"notice\\":\\"Set one or more DNS records.  Records are supplied in wire-format. Records with the same node/name/resource must be supplied one after the other to ensure the data is updated correctly. For example, if the data was supplied:     a.example.com IN A 1.2.3.4     a.example.com IN A 5.6.7.8     www.example.com IN CNAME a.example.com. then this would store the two A records for a.example.com correctly as a single RRSET, however if the data was supplied:     a.example.com IN A 1.2.3.4     www.example.com IN CNAME a.example.com.     a.example.com IN A 5.6.7.8 then this would store the first A record, the CNAME, then the second A record which would overwrite the first.\\"},\\"setInterface(bytes32,bytes4,address)\\":{\\"notice\\":\\"Sets an interface associated with a name. Setting the address to 0 restores the default behaviour of querying the contract at `addr()` for interface support.\\"},\\"setName(bytes32,string)\\":{\\"notice\\":\\"Sets the name associated with an ENS node, for reverse records. May only be called by the owner of that node in the ENS registry.\\"},\\"setPubkey(bytes32,bytes32,bytes32)\\":{\\"notice\\":\\"Sets the SECP256k1 public key associated with an ENS node.\\"},\\"setText(bytes32,string,string)\\":{\\"notice\\":\\"Sets the text data associated with an ENS node and key. May only be called by the owner of that node in the ENS registry.\\"},\\"setZonehash(bytes32,bytes)\\":{\\"notice\\":\\"setZonehash sets the hash for the zone. May only be called by the owner of that node in the ENS registry.\\"},\\"text(bytes32,string)\\":{\\"notice\\":\\"Returns the text data associated with an ENS node and key.\\"},\\"zonehash(bytes32)\\":{\\"notice\\":\\"zonehash obtains the hash for the zone.\\"}},\\"notice\\":\\"A simple resolver anyone can use; only allows the owner of a node to set its address.\\",\\"version\\":1}},\\"settings\\":{\\"compilationTarget\\":{\\"contracts/resolvers/PublicResolver.sol\\":\\"PublicResolver\\"},\\"evmVersion\\":\\"paris\\",\\"libraries\\":{},\\"metadata\\":{\\"bytecodeHash\\":\\"ipfs\\",\\"useLiteralContent\\":true},\\"optimizer\\":{\\"enabled\\":true,\\"runs\\":1000000},\\"remappings\\":[]},\\"sources\\":{\\"@ensdomains/buffer/contracts/Buffer.sol\\":{\\"content\\":\\"// SPDX-License-Identifier: BSD-2-Clause\\\\npragma solidity ^0.8.4;\\\\n\\\\n/**\\\\n* @dev A library for working with mutable byte buffers in Solidity.\\\\n*\\\\n* Byte buffers are mutable and expandable, and provide a variety of primitives\\\\n* for appending to them. At any time you can fetch a bytes object containing the\\\\n* current contents of the buffer. The bytes object should not be stored between\\\\n* operations, as it may change due to resizing of the buffer.\\\\n*/\\\\nlibrary Buffer {\\\\n    /**\\\\n    * @dev Represents a mutable buffer. Buffers have a current value (buf) and\\\\n    *      a capacity. The capacity may be longer than the current value, in\\\\n    *      which case it can be extended without the need to allocate more memory.\\\\n    */\\\\n    struct buffer {\\\\n        bytes buf;\\\\n        uint capacity;\\\\n    }\\\\n\\\\n    /**\\\\n    * @dev Initializes a buffer with an initial capacity.\\\\n    * @param buf The buffer to initialize.\\\\n    * @param capacity The number of bytes of space to allocate the buffer.\\\\n    * @return The buffer, for chaining.\\\\n    */\\\\n    function init(buffer memory buf, uint capacity) internal pure returns(buffer memory) {\\\\n        if (capacity % 32 != 0) {\\\\n            capacity += 32 - (capacity % 32);\\\\n        }\\\\n        // Allocate space for the buffer data\\\\n        buf.capacity = capacity;\\\\n        assembly {\\\\n            let ptr := mload(0x40)\\\\n            mstore(buf, ptr)\\\\n            mstore(ptr, 0)\\\\n            let fpm := add(32, add(ptr, capacity))\\\\n            if lt(fpm, ptr) {\\\\n                revert(0, 0)\\\\n            }\\\\n            mstore(0x40, fpm)\\\\n        }\\\\n        return buf;\\\\n    }\\\\n\\\\n    /**\\\\n    * @dev Initializes a new buffer from an existing bytes object.\\\\n    *      Changes to the buffer may mutate the original value.\\\\n    * @param b The bytes object to initialize the buffer with.\\\\n    * @return A new buffer.\\\\n    */\\\\n    function fromBytes(bytes memory b) internal pure returns(buffer memory) {\\\\n        buffer memory buf;\\\\n        buf.buf = b;\\\\n        buf.capacity = b.length;\\\\n        return buf;\\\\n    }\\\\n\\\\n    function resize(buffer memory buf, uint capacity) private pure {\\\\n        bytes memory oldbuf = buf.buf;\\\\n        init(buf, capacity);\\\\n        append(buf, oldbuf);\\\\n    }\\\\n\\\\n    /**\\\\n    * @dev Sets buffer length to 0.\\\\n    * @param buf The buffer to truncate.\\\\n    * @return The original buffer, for chaining..\\\\n    */\\\\n    function truncate(buffer memory buf) internal pure returns (buffer memory) {\\\\n        assembly {\\\\n            let bufptr := mload(buf)\\\\n            mstore(bufptr, 0)\\\\n        }\\\\n        return buf;\\\\n    }\\\\n\\\\n    /**\\\\n    * @dev Appends len bytes of a byte string to a buffer. Resizes if doing so would exceed\\\\n    *      the capacity of the buffer.\\\\n    * @param buf The buffer to append to.\\\\n    * @param data The data to append.\\\\n    * @param len The number of bytes to copy.\\\\n    * @return The original buffer, for chaining.\\\\n    */\\\\n    function append(buffer memory buf, bytes memory data, uint len) internal pure returns(buffer memory) {\\\\n        require(len <= data.length);\\\\n\\\\n        uint off = buf.buf.length;\\\\n        uint newCapacity = off + len;\\\\n        if (newCapacity > buf.capacity) {\\\\n            resize(buf, newCapacity * 2);\\\\n        }\\\\n\\\\n        uint dest;\\\\n        uint src;\\\\n        assembly {\\\\n            // Memory address of the buffer data\\\\n            let bufptr := mload(buf)\\\\n            // Length of existing buffer data\\\\n            let buflen := mload(bufptr)\\\\n            // Start address = buffer address + offset + sizeof(buffer length)\\\\n            dest := add(add(bufptr, 32), off)\\\\n            // Update buffer length if we\'re extending it\\\\n            if gt(newCapacity, buflen) {\\\\n                mstore(bufptr, newCapacity)\\\\n            }\\\\n            src := add(data, 32)\\\\n        }\\\\n\\\\n        // Copy word-length chunks while possible\\\\n        for (; len >= 32; len -= 32) {\\\\n            assembly {\\\\n                mstore(dest, mload(src))\\\\n            }\\\\n            dest += 32;\\\\n            src += 32;\\\\n        }\\\\n\\\\n        // Copy remaining bytes\\\\n        unchecked {\\\\n            uint mask = (256 ** (32 - len)) - 1;\\\\n            assembly {\\\\n                let srcpart := and(mload(src), not(mask))\\\\n                let destpart := and(mload(dest), mask)\\\\n                mstore(dest, or(destpart, srcpart))\\\\n            }\\\\n        }\\\\n\\\\n        return buf;\\\\n    }\\\\n\\\\n    /**\\\\n    * @dev Appends a byte string to a buffer. Resizes if doing so would exceed\\\\n    *      the capacity of the buffer.\\\\n    * @param buf The buffer to append to.\\\\n    * @param data The data to append.\\\\n    * @return The original buffer, for chaining.\\\\n    */\\\\n    function append(buffer memory buf, bytes memory data) internal pure returns (buffer memory) {\\\\n        return append(buf, data, data.length);\\\\n    }\\\\n\\\\n    /**\\\\n    * @dev Appends a byte to the buffer. Resizes if doing so would exceed the\\\\n    *      capacity of the buffer.\\\\n    * @param buf The buffer to append to.\\\\n    * @param data The data to append.\\\\n    * @return The original buffer, for chaining.\\\\n    */\\\\n    function appendUint8(buffer memory buf, uint8 data) internal pure returns(buffer memory) {\\\\n        uint off = buf.buf.length;\\\\n        uint offPlusOne = off + 1;\\\\n        if (off >= buf.capacity) {\\\\n            resize(buf, offPlusOne * 2);\\\\n        }\\\\n\\\\n        assembly {\\\\n            // Memory address of the buffer data\\\\n            let bufptr := mload(buf)\\\\n            // Address = buffer address + sizeof(buffer length) + off\\\\n            let dest := add(add(bufptr, off), 32)\\\\n            mstore8(dest, data)\\\\n            // Update buffer length if we extended it\\\\n            if gt(offPlusOne, mload(bufptr)) {\\\\n                mstore(bufptr, offPlusOne)\\\\n            }\\\\n        }\\\\n\\\\n        return buf;\\\\n    }\\\\n\\\\n    /**\\\\n    * @dev Appends len bytes of bytes32 to a buffer. Resizes if doing so would\\\\n    *      exceed the capacity of the buffer.\\\\n    * @param buf The buffer to append to.\\\\n    * @param data The data to append.\\\\n    * @param len The number of bytes to write (left-aligned).\\\\n    * @return The original buffer, for chaining.\\\\n    */\\\\n    function append(buffer memory buf, bytes32 data, uint len) private pure returns(buffer memory) {\\\\n        uint off = buf.buf.length;\\\\n        uint newCapacity = len + off;\\\\n        if (newCapacity > buf.capacity) {\\\\n            resize(buf, newCapacity * 2);\\\\n        }\\\\n\\\\n        unchecked {\\\\n            uint mask = (256 ** len) - 1;\\\\n            // Right-align data\\\\n            data = data >> (8 * (32 - len));\\\\n            assembly {\\\\n                // Memory address of the buffer data\\\\n                let bufptr := mload(buf)\\\\n                // Address = buffer address + sizeof(buffer length) + newCapacity\\\\n                let dest := add(bufptr, newCapacity)\\\\n                mstore(dest, or(and(mload(dest), not(mask)), data))\\\\n                // Update buffer length if we extended it\\\\n                if gt(newCapacity, mload(bufptr)) {\\\\n                    mstore(bufptr, newCapacity)\\\\n                }\\\\n            }\\\\n        }\\\\n        return buf;\\\\n    }\\\\n\\\\n    /**\\\\n    * @dev Appends a bytes20 to the buffer. Resizes if doing so would exceed\\\\n    *      the capacity of the buffer.\\\\n    * @param buf The buffer to append to.\\\\n    * @param data The data to append.\\\\n    * @return The original buffer, for chhaining.\\\\n    */\\\\n    function appendBytes20(buffer memory buf, bytes20 data) internal pure returns (buffer memory) {\\\\n        return append(buf, bytes32(data), 20);\\\\n    }\\\\n\\\\n    /**\\\\n    * @dev Appends a bytes32 to the buffer. Resizes if doing so would exceed\\\\n    *      the capacity of the buffer.\\\\n    * @param buf The buffer to append to.\\\\n    * @param data The data to append.\\\\n    * @return The original buffer, for chaining.\\\\n    */\\\\n    function appendBytes32(buffer memory buf, bytes32 data) internal pure returns (buffer memory) {\\\\n        return append(buf, data, 32);\\\\n    }\\\\n\\\\n    /**\\\\n     * @dev Appends a byte to the end of the buffer. Resizes if doing so would\\\\n     *      exceed the capacity of the buffer.\\\\n     * @param buf The buffer to append to.\\\\n     * @param data The data to append.\\\\n     * @param len The number of bytes to write (right-aligned).\\\\n     * @return The original buffer.\\\\n     */\\\\n    function appendInt(buffer memory buf, uint data, uint len) internal pure returns(buffer memory) {\\\\n        uint off = buf.buf.length;\\\\n        uint newCapacity = len + off;\\\\n        if (newCapacity > buf.capacity) {\\\\n            resize(buf, newCapacity * 2);\\\\n        }\\\\n\\\\n        uint mask = (256 ** len) - 1;\\\\n        assembly {\\\\n            // Memory address of the buffer data\\\\n            let bufptr := mload(buf)\\\\n            // Address = buffer address + sizeof(buffer length) + newCapacity\\\\n            let dest := add(bufptr, newCapacity)\\\\n            mstore(dest, or(and(mload(dest), not(mask)), data))\\\\n            // Update buffer length if we extended it\\\\n            if gt(newCapacity, mload(bufptr)) {\\\\n                mstore(bufptr, newCapacity)\\\\n            }\\\\n        }\\\\n        return buf;\\\\n    }\\\\n}\\\\n\\",\\"keccak256\\":\\"0xd6dd3b0b327288f8e1b711a609f4040fea602e2ad4bba9febdf2f33b4e56eb0c\\",\\"license\\":\\"BSD-2-Clause\\"},\\"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\\":{\\"content\\":\\"// SPDX-License-Identifier: MIT\\\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC1155/IERC1155.sol)\\\\n\\\\npragma solidity ^0.8.0;\\\\n\\\\nimport \\\\\\"../../utils/introspection/IERC165.sol\\\\\\";\\\\n\\\\n/**\\\\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\\\\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\\\\n *\\\\n * _Available since v3.1._\\\\n */\\\\ninterface IERC1155 is IERC165 {\\\\n    /**\\\\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\\\\n     */\\\\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\\\\n\\\\n    /**\\\\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\\\\n     * transfers.\\\\n     */\\\\n    event TransferBatch(\\\\n        address indexed operator,\\\\n        address indexed from,\\\\n        address indexed to,\\\\n        uint256[] ids,\\\\n        uint256[] values\\\\n    );\\\\n\\\\n    /**\\\\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\\\\n     * `approved`.\\\\n     */\\\\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\\\\n\\\\n    /**\\\\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\\\\n     *\\\\n     * If an {URI} event was emitted for `id`, the standard\\\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\\\\n     * returned by {IERC1155MetadataURI-uri}.\\\\n     */\\\\n    event URI(string value, uint256 indexed id);\\\\n\\\\n    /**\\\\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\\\\n     *\\\\n     * Requirements:\\\\n     *\\\\n     * - `account` cannot be the zero address.\\\\n     */\\\\n    function balanceOf(address account, uint256 id) external view returns (uint256);\\\\n\\\\n    /**\\\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\\\\n     *\\\\n     * Requirements:\\\\n     *\\\\n     * - `accounts` and `ids` must have the same length.\\\\n     */\\\\n    function balanceOfBatch(\\\\n        address[] calldata accounts,\\\\n        uint256[] calldata ids\\\\n    ) external view returns (uint256[] memory);\\\\n\\\\n    /**\\\\n     * @dev Grants or revokes permission to `operator` to transfer the caller\'s tokens, according to `approved`,\\\\n     *\\\\n     * Emits an {ApprovalForAll} event.\\\\n     *\\\\n     * Requirements:\\\\n     *\\\\n     * - `operator` cannot be the caller.\\\\n     */\\\\n    function setApprovalForAll(address operator, bool approved) external;\\\\n\\\\n    /**\\\\n     * @dev Returns true if `operator` is approved to transfer ``account``\'s tokens.\\\\n     *\\\\n     * See {setApprovalForAll}.\\\\n     */\\\\n    function isApprovedForAll(address account, address operator) external view returns (bool);\\\\n\\\\n    /**\\\\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\\\\n     *\\\\n     * Emits a {TransferSingle} event.\\\\n     *\\\\n     * Requirements:\\\\n     *\\\\n     * - `to` cannot be the zero address.\\\\n     * - If the caller is not `from`, it must have been approved to spend ``from``\'s tokens via {setApprovalForAll}.\\\\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\\\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\\\n     * acceptance magic value.\\\\n     */\\\\n    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;\\\\n\\\\n    /**\\\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\\\\n     *\\\\n     * Emits a {TransferBatch} event.\\\\n     *\\\\n     * Requirements:\\\\n     *\\\\n     * - `ids` and `amounts` must have the same length.\\\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\\\n     * acceptance magic value.\\\\n     */\\\\n    function safeBatchTransferFrom(\\\\n        address from,\\\\n        address to,\\\\n        uint256[] calldata ids,\\\\n        uint256[] calldata amounts,\\\\n        bytes calldata data\\\\n    ) external;\\\\n}\\\\n\\",\\"keccak256\\":\\"0xcab667ddad478ff0d39c2053ca77fac778af8483c18ab07d810277b4216fd582\\",\\"license\\":\\"MIT\\"},\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\":{\\"content\\":\\"// SPDX-License-Identifier: MIT\\\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/IERC721.sol)\\\\n\\\\npragma solidity ^0.8.0;\\\\n\\\\nimport \\\\\\"../../utils/introspection/IERC165.sol\\\\\\";\\\\n\\\\n/**\\\\n * @dev Required interface of an ERC721 compliant contract.\\\\n */\\\\ninterface IERC721 is IERC165 {\\\\n    /**\\\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\\\n     */\\\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\\\n\\\\n    /**\\\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\\\n     */\\\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\\\n\\\\n    /**\\\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\\\n     */\\\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\\\n\\\\n    /**\\\\n     * @dev Returns the number of tokens in ``owner``\'s account.\\\\n     */\\\\n    function balanceOf(address owner) external view returns (uint256 balance);\\\\n\\\\n    /**\\\\n     * @dev Returns the owner of the `tokenId` token.\\\\n     *\\\\n     * Requirements:\\\\n     *\\\\n     * - `tokenId` must exist.\\\\n     */\\\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\\\n\\\\n    /**\\\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\\\n     *\\\\n     * Requirements:\\\\n     *\\\\n     * - `from` cannot be the zero address.\\\\n     * - `to` cannot be the zero address.\\\\n     * - `tokenId` token must exist and be owned by `from`.\\\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\\\n     *\\\\n     * Emits a {Transfer} event.\\\\n     */\\\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\\\n\\\\n    /**\\\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\\\n     *\\\\n     * Requirements:\\\\n     *\\\\n     * - `from` cannot be the zero address.\\\\n     * - `to` cannot be the zero address.\\\\n     * - `tokenId` token must exist and be owned by `from`.\\\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\\\n     *\\\\n     * Emits a {Transfer} event.\\\\n     */\\\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\\\n\\\\n    /**\\\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\\\n     *\\\\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\\\\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\\\\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\\\\n     *\\\\n     * Requirements:\\\\n     *\\\\n     * - `from` cannot be the zero address.\\\\n     * - `to` cannot be the zero address.\\\\n     * - `tokenId` token must be owned by `from`.\\\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\\\n     *\\\\n     * Emits a {Transfer} event.\\\\n     */\\\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\\\n\\\\n    /**\\\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\\\n     * The approval is cleared when the token is transferred.\\\\n     *\\\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\\\n     *\\\\n     * Requirements:\\\\n     *\\\\n     * - The caller must own the token or be an approved operator.\\\\n     * - `tokenId` must exist.\\\\n     *\\\\n     * Emits an {Approval} event.\\\\n     */\\\\n    function approve(address to, uint256 tokenId) external;\\\\n\\\\n    /**\\\\n     * @dev Approve or remove `operator` as an operator for the caller.\\\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\\\n     *\\\\n     * Requirements:\\\\n     *\\\\n     * - The `operator` cannot be the caller.\\\\n     *\\\\n     * Emits an {ApprovalForAll} event.\\\\n     */\\\\n    function setApprovalForAll(address operator, bool approved) external;\\\\n\\\\n    /**\\\\n     * @dev Returns the account approved for `tokenId` token.\\\\n     *\\\\n     * Requirements:\\\\n     *\\\\n     * - `tokenId` must exist.\\\\n     */\\\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\\\n\\\\n    /**\\\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\\\n     *\\\\n     * See {setApprovalForAll}\\\\n     */\\\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\\\n}\\\\n\\",\\"keccak256\\":\\"0x5bce51e11f7d194b79ea59fe00c9e8de9fa2c5530124960f29a24d4c740a3266\\",\\"license\\":\\"MIT\\"},\\"@openzeppelin/contracts/utils/introspection/ERC165.sol\\":{\\"content\\":\\"// SPDX-License-Identifier: MIT\\\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\\\n\\\\npragma solidity ^0.8.0;\\\\n\\\\nimport \\\\\\"./IERC165.sol\\\\\\";\\\\n\\\\n/**\\\\n * @dev Implementation of the {IERC165} interface.\\\\n *\\\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\\\n * for the additional interface id that will be supported. For example:\\\\n *\\\\n * ```solidity\\\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\\\n * }\\\\n * ```\\\\n *\\\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\\\n */\\\\nabstract contract ERC165 is IERC165 {\\\\n    /**\\\\n     * @dev See {IERC165-supportsInterface}.\\\\n     */\\\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\\\n        return interfaceId == type(IERC165).interfaceId;\\\\n    }\\\\n}\\\\n\\",\\"keccak256\\":\\"0xd10975de010d89fd1c78dc5e8a9a7e7f496198085c151648f20cba166b32582b\\",\\"license\\":\\"MIT\\"},\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\":{\\"content\\":\\"// SPDX-License-Identifier: MIT\\\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\\\n\\\\npragma solidity ^0.8.0;\\\\n\\\\n/**\\\\n * @dev Interface of the ERC165 standard, as defined in the\\\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\\\n *\\\\n * Implementers can declare support of contract interfaces, which can then be\\\\n * queried by others ({ERC165Checker}).\\\\n *\\\\n * For an implementation, see {ERC165}.\\\\n */\\\\ninterface IERC165 {\\\\n    /**\\\\n     * @dev Returns true if this contract implements the interface defined by\\\\n     * `interfaceId`. See the corresponding\\\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\\\n     * to learn more about how these ids are created.\\\\n     *\\\\n     * This function call must use less than 30 000 gas.\\\\n     */\\\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\\\n}\\\\n\\",\\"keccak256\\":\\"0x447a5f3ddc18419d41ff92b3773fb86471b1db25773e07f877f548918a185bf1\\",\\"license\\":\\"MIT\\"},\\"contracts/dnssec-oracle/RRUtils.sol\\":{\\"content\\":\\"//SPDX-License-Identifier: MIT\\\\npragma solidity ^0.8.4;\\\\n\\\\nimport \\\\\\"../utils/BytesUtils.sol\\\\\\";\\\\nimport \\\\\\"@ensdomains/buffer/contracts/Buffer.sol\\\\\\";\\\\n\\\\n/// @dev RRUtils is a library that provides utilities for parsing DNS resource records.\\\\nlibrary RRUtils {\\\\n    using BytesUtils for *;\\\\n    using Buffer for *;\\\\n\\\\n    /// @dev Returns the number of bytes in the DNS name at \'offset\' in \'self\'.\\\\n    /// @param self The byte array to read a name from.\\\\n    /// @param offset The offset to start reading at.\\\\n    /// @return The length of the DNS name at \'offset\', in bytes.\\\\n    function nameLength(\\\\n        bytes memory self,\\\\n        uint256 offset\\\\n    ) internal pure returns (uint256) {\\\\n        uint256 idx = offset;\\\\n        while (true) {\\\\n            assert(idx < self.length);\\\\n            uint256 labelLen = self.readUint8(idx);\\\\n            idx += labelLen + 1;\\\\n            if (labelLen == 0) {\\\\n                break;\\\\n            }\\\\n        }\\\\n        return idx - offset;\\\\n    }\\\\n\\\\n    /// @dev Returns a DNS format name at the specified offset of self.\\\\n    /// @param self The byte array to read a name from.\\\\n    /// @param offset The offset to start reading at.\\\\n    /// @return ret The name.\\\\n    function readName(\\\\n        bytes memory self,\\\\n        uint256 offset\\\\n    ) internal pure returns (bytes memory ret) {\\\\n        uint256 len = nameLength(self, offset);\\\\n        return self.substring(offset, len);\\\\n    }\\\\n\\\\n    /// @dev Returns the number of labels in the DNS name at \'offset\' in \'self\'.\\\\n    /// @param self The byte array to read a name from.\\\\n    /// @param offset The offset to start reading at.\\\\n    /// @return The number of labels in the DNS name at \'offset\', in bytes.\\\\n    function labelCount(\\\\n        bytes memory self,\\\\n        uint256 offset\\\\n    ) internal pure returns (uint256) {\\\\n        uint256 count = 0;\\\\n        while (true) {\\\\n            assert(offset < self.length);\\\\n            uint256 labelLen = self.readUint8(offset);\\\\n            offset += labelLen + 1;\\\\n            if (labelLen == 0) {\\\\n                break;\\\\n            }\\\\n            count += 1;\\\\n        }\\\\n        return count;\\\\n    }\\\\n\\\\n    uint256 constant RRSIG_TYPE = 0;\\\\n    uint256 constant RRSIG_ALGORITHM = 2;\\\\n    uint256 constant RRSIG_LABELS = 3;\\\\n    uint256 constant RRSIG_TTL = 4;\\\\n    uint256 constant RRSIG_EXPIRATION = 8;\\\\n    uint256 constant RRSIG_INCEPTION = 12;\\\\n    uint256 constant RRSIG_KEY_TAG = 16;\\\\n    uint256 constant RRSIG_SIGNER_NAME = 18;\\\\n\\\\n    struct SignedSet {\\\\n        uint16 typeCovered;\\\\n        uint8 algorithm;\\\\n        uint8 labels;\\\\n        uint32 ttl;\\\\n        uint32 expiration;\\\\n        uint32 inception;\\\\n        uint16 keytag;\\\\n        bytes signerName;\\\\n        bytes data;\\\\n        bytes name;\\\\n    }\\\\n\\\\n    function readSignedSet(\\\\n        bytes memory data\\\\n    ) internal pure returns (SignedSet memory self) {\\\\n        self.typeCovered = data.readUint16(RRSIG_TYPE);\\\\n        self.algorithm = data.readUint8(RRSIG_ALGORITHM);\\\\n        self.labels = data.readUint8(RRSIG_LABELS);\\\\n        self.ttl = data.readUint32(RRSIG_TTL);\\\\n        self.expiration = data.readUint32(RRSIG_EXPIRATION);\\\\n        self.inception = data.readUint32(RRSIG_INCEPTION);\\\\n        self.keytag = data.readUint16(RRSIG_KEY_TAG);\\\\n        self.signerName = readName(data, RRSIG_SIGNER_NAME);\\\\n        self.data = data.substring(\\\\n            RRSIG_SIGNER_NAME + self.signerName.length,\\\\n            data.length - RRSIG_SIGNER_NAME - self.signerName.length\\\\n        );\\\\n    }\\\\n\\\\n    function rrs(\\\\n        SignedSet memory rrset\\\\n    ) internal pure returns (RRIterator memory) {\\\\n        return iterateRRs(rrset.data, 0);\\\\n    }\\\\n\\\\n    /// @dev An iterator over resource records.\\\\n    struct RRIterator {\\\\n        bytes data;\\\\n        uint256 offset;\\\\n        uint16 dnstype;\\\\n        uint16 class;\\\\n        uint32 ttl;\\\\n        uint256 rdataOffset;\\\\n        uint256 nextOffset;\\\\n    }\\\\n\\\\n    /// @dev Begins iterating over resource records.\\\\n    /// @param self The byte string to read from.\\\\n    /// @param offset The offset to start reading at.\\\\n    /// @return ret An iterator object.\\\\n    function iterateRRs(\\\\n        bytes memory self,\\\\n        uint256 offset\\\\n    ) internal pure returns (RRIterator memory ret) {\\\\n        ret.data = self;\\\\n        ret.nextOffset = offset;\\\\n        next(ret);\\\\n    }\\\\n\\\\n    /// @dev Returns true iff there are more RRs to iterate.\\\\n    /// @param iter The iterator to check.\\\\n    /// @return True iff the iterator has finished.\\\\n    function done(RRIterator memory iter) internal pure returns (bool) {\\\\n        return iter.offset >= iter.data.length;\\\\n    }\\\\n\\\\n    /// @dev Moves the iterator to the next resource record.\\\\n    /// @param iter The iterator to advance.\\\\n    function next(RRIterator memory iter) internal pure {\\\\n        iter.offset = iter.nextOffset;\\\\n        if (iter.offset >= iter.data.length) {\\\\n            return;\\\\n        }\\\\n\\\\n        // Skip the name\\\\n        uint256 off = iter.offset + nameLength(iter.data, iter.offset);\\\\n\\\\n        // Read type, class, and ttl\\\\n        iter.dnstype = iter.data.readUint16(off);\\\\n        off += 2;\\\\n        iter.class = iter.data.readUint16(off);\\\\n        off += 2;\\\\n        iter.ttl = iter.data.readUint32(off);\\\\n        off += 4;\\\\n\\\\n        // Read the rdata\\\\n        uint256 rdataLength = iter.data.readUint16(off);\\\\n        off += 2;\\\\n        iter.rdataOffset = off;\\\\n        iter.nextOffset = off + rdataLength;\\\\n    }\\\\n\\\\n    /// @dev Returns the name of the current record.\\\\n    /// @param iter The iterator.\\\\n    /// @return A new bytes object containing the owner name from the RR.\\\\n    function name(RRIterator memory iter) internal pure returns (bytes memory) {\\\\n        return\\\\n            iter.data.substring(\\\\n                iter.offset,\\\\n                nameLength(iter.data, iter.offset)\\\\n            );\\\\n    }\\\\n\\\\n    /// @dev Returns the rdata portion of the current record.\\\\n    /// @param iter The iterator.\\\\n    /// @return A new bytes object containing the RR\'s RDATA.\\\\n    function rdata(\\\\n        RRIterator memory iter\\\\n    ) internal pure returns (bytes memory) {\\\\n        return\\\\n            iter.data.substring(\\\\n                iter.rdataOffset,\\\\n                iter.nextOffset - iter.rdataOffset\\\\n            );\\\\n    }\\\\n\\\\n    uint256 constant DNSKEY_FLAGS = 0;\\\\n    uint256 constant DNSKEY_PROTOCOL = 2;\\\\n    uint256 constant DNSKEY_ALGORITHM = 3;\\\\n    uint256 constant DNSKEY_PUBKEY = 4;\\\\n\\\\n    struct DNSKEY {\\\\n        uint16 flags;\\\\n        uint8 protocol;\\\\n        uint8 algorithm;\\\\n        bytes publicKey;\\\\n    }\\\\n\\\\n    function readDNSKEY(\\\\n        bytes memory data,\\\\n        uint256 offset,\\\\n        uint256 length\\\\n    ) internal pure returns (DNSKEY memory self) {\\\\n        self.flags = data.readUint16(offset + DNSKEY_FLAGS);\\\\n        self.protocol = data.readUint8(offset + DNSKEY_PROTOCOL);\\\\n        self.algorithm = data.readUint8(offset + DNSKEY_ALGORITHM);\\\\n        self.publicKey = data.substring(\\\\n            offset + DNSKEY_PUBKEY,\\\\n            length - DNSKEY_PUBKEY\\\\n        );\\\\n    }\\\\n\\\\n    uint256 constant DS_KEY_TAG = 0;\\\\n    uint256 constant DS_ALGORITHM = 2;\\\\n    uint256 constant DS_DIGEST_TYPE = 3;\\\\n    uint256 constant DS_DIGEST = 4;\\\\n\\\\n    struct DS {\\\\n        uint16 keytag;\\\\n        uint8 algorithm;\\\\n        uint8 digestType;\\\\n        bytes digest;\\\\n    }\\\\n\\\\n    function readDS(\\\\n        bytes memory data,\\\\n        uint256 offset,\\\\n        uint256 length\\\\n    ) internal pure returns (DS memory self) {\\\\n        self.keytag = data.readUint16(offset + DS_KEY_TAG);\\\\n        self.algorithm = data.readUint8(offset + DS_ALGORITHM);\\\\n        self.digestType = data.readUint8(offset + DS_DIGEST_TYPE);\\\\n        self.digest = data.substring(offset + DS_DIGEST, length - DS_DIGEST);\\\\n    }\\\\n\\\\n    function isSubdomainOf(\\\\n        bytes memory self,\\\\n        bytes memory other\\\\n    ) internal pure returns (bool) {\\\\n        uint256 off = 0;\\\\n        uint256 counts = labelCount(self, 0);\\\\n        uint256 othercounts = labelCount(other, 0);\\\\n\\\\n        while (counts > othercounts) {\\\\n            off = progress(self, off);\\\\n            counts--;\\\\n        }\\\\n\\\\n        return self.equals(off, other, 0);\\\\n    }\\\\n\\\\n    function compareNames(\\\\n        bytes memory self,\\\\n        bytes memory other\\\\n    ) internal pure returns (int256) {\\\\n        if (self.equals(other)) {\\\\n            return 0;\\\\n        }\\\\n\\\\n        uint256 off;\\\\n        uint256 otheroff;\\\\n        uint256 prevoff;\\\\n        uint256 otherprevoff;\\\\n        uint256 counts = labelCount(self, 0);\\\\n        uint256 othercounts = labelCount(other, 0);\\\\n\\\\n        // Keep removing labels from the front of the name until both names are equal length\\\\n        while (counts > othercounts) {\\\\n            prevoff = off;\\\\n            off = progress(self, off);\\\\n            counts--;\\\\n        }\\\\n\\\\n        while (othercounts > counts) {\\\\n            otherprevoff = otheroff;\\\\n            otheroff = progress(other, otheroff);\\\\n            othercounts--;\\\\n        }\\\\n\\\\n        // Compare the last nonequal labels to each other\\\\n        while (counts > 0 && !self.equals(off, other, otheroff)) {\\\\n            prevoff = off;\\\\n            off = progress(self, off);\\\\n            otherprevoff = otheroff;\\\\n            otheroff = progress(other, otheroff);\\\\n            counts -= 1;\\\\n        }\\\\n\\\\n        if (off == 0) {\\\\n            return -1;\\\\n        }\\\\n        if (otheroff == 0) {\\\\n            return 1;\\\\n        }\\\\n\\\\n        return\\\\n            self.compare(\\\\n                prevoff + 1,\\\\n                self.readUint8(prevoff),\\\\n                other,\\\\n                otherprevoff + 1,\\\\n                other.readUint8(otherprevoff)\\\\n            );\\\\n    }\\\\n\\\\n    /// @dev Compares two serial numbers using RFC1982 serial number math.\\\\n    function serialNumberGte(\\\\n        uint32 i1,\\\\n        uint32 i2\\\\n    ) internal pure returns (bool) {\\\\n        unchecked {\\\\n            return int32(i1) - int32(i2) >= 0;\\\\n        }\\\\n    }\\\\n\\\\n    function progress(\\\\n        bytes memory body,\\\\n        uint256 off\\\\n    ) internal pure returns (uint256) {\\\\n        return off + 1 + body.readUint8(off);\\\\n    }\\\\n\\\\n    /// @dev Computes the keytag for a chunk of data.\\\\n    /// @param data The data to compute a keytag for.\\\\n    /// @return The computed key tag.\\\\n    function computeKeytag(bytes memory data) internal pure returns (uint16) {\\\\n        /* This function probably deserves some explanation.\\\\n         * The DNSSEC keytag function is a checksum that relies on summing up individual bytes\\\\n         * from the input string, with some mild bitshifting. Here\'s a Naive solidity implementation:\\\\n         *\\\\n         *     function computeKeytag(bytes memory data) internal pure returns (uint16) {\\\\n         *         uint ac;\\\\n         *         for (uint i = 0; i < data.length; i++) {\\\\n         *             ac += i & 1 == 0 ? uint16(data.readUint8(i)) << 8 : data.readUint8(i);\\\\n         *         }\\\\n         *         return uint16(ac + (ac >> 16));\\\\n         *     }\\\\n         *\\\\n         * The EVM, with its 256 bit words, is exceedingly inefficient at doing byte-by-byte operations;\\\\n         * the code above, on reasonable length inputs, consumes over 100k gas. But we can make the EVM\'s\\\\n         * large words work in our favour.\\\\n         *\\\\n         * The code below works by treating the input as a series of 256 bit words. It first masks out\\\\n         * even and odd bytes from each input word, adding them to two separate accumulators `ac1` and `ac2`.\\\\n         * The bytes are separated by empty bytes, so as long as no individual sum exceeds 2^16-1, we\'re\\\\n         * effectively summing 16 different numbers with each EVM ADD opcode.\\\\n         *\\\\n         * Once it\'s added up all the inputs, it has to add all the 16 bit values in `ac1` and `ac2` together.\\\\n         * It does this using the same trick - mask out every other value, shift to align them, add them together.\\\\n         * After the first addition on both accumulators, there\'s enough room to add the two accumulators together,\\\\n         * and the remaining sums can be done just on ac1.\\\\n         */\\\\n        unchecked {\\\\n            require(data.length <= 8192, \\\\\\"Long keys not permitted\\\\\\");\\\\n            uint256 ac1;\\\\n            uint256 ac2;\\\\n            for (uint256 i = 0; i < data.length + 31; i += 32) {\\\\n                uint256 word;\\\\n                assembly {\\\\n                    word := mload(add(add(data, 32), i))\\\\n                }\\\\n                if (i + 32 > data.length) {\\\\n                    uint256 unused = 256 - (data.length - i) * 8;\\\\n                    word = (word >> unused) << unused;\\\\n                }\\\\n                ac1 +=\\\\n                    (word &\\\\n                        0xFF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00) >>\\\\n                    8;\\\\n                ac2 += (word &\\\\n                    0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF);\\\\n            }\\\\n            ac1 =\\\\n                (ac1 &\\\\n                    0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) +\\\\n                ((ac1 &\\\\n                    0xFFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000) >>\\\\n                    16);\\\\n            ac2 =\\\\n                (ac2 &\\\\n                    0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) +\\\\n                ((ac2 &\\\\n                    0xFFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000) >>\\\\n                    16);\\\\n            ac1 = (ac1 << 8) + ac2;\\\\n            ac1 =\\\\n                (ac1 &\\\\n                    0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) +\\\\n                ((ac1 &\\\\n                    0xFFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000) >>\\\\n                    32);\\\\n            ac1 =\\\\n                (ac1 &\\\\n                    0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) +\\\\n                ((ac1 &\\\\n                    0xFFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF0000000000000000) >>\\\\n                    64);\\\\n            ac1 =\\\\n                (ac1 &\\\\n                    0x00000000000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) +\\\\n                (ac1 >> 128);\\\\n            ac1 += (ac1 >> 16) & 0xFFFF;\\\\n            return uint16(ac1);\\\\n        }\\\\n    }\\\\n}\\\\n\\",\\"keccak256\\":\\"0xdbab10dde632a1a02ee1c706bd4a31f9fb6195bd15a360528f7f6615e8fc895a\\",\\"license\\":\\"MIT\\"},\\"contracts/ethregistrar/IBaseRegistrar.sol\\":{\\"content\\":\\"//SPDX-License-Identifier: MIT\\\\npragma solidity ^0.8.4;\\\\n\\\\nimport \\\\\\"../registry/ENS.sol\\\\\\";\\\\nimport \\\\\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\\\\";\\\\n\\\\ninterface IBaseRegistrar is IERC721 {\\\\n    event ControllerAdded(address indexed controller);\\\\n    event ControllerRemoved(address indexed controller);\\\\n    event NameMigrated(\\\\n        uint256 indexed id,\\\\n        address indexed owner,\\\\n        uint256 expires\\\\n    );\\\\n    event NameRegistered(\\\\n        uint256 indexed id,\\\\n        address indexed owner,\\\\n        uint256 expires\\\\n    );\\\\n    event NameRenewed(uint256 indexed id, uint256 expires);\\\\n\\\\n    // Authorises a controller, who can register and renew domains.\\\\n    function addController(address controller) external;\\\\n\\\\n    // Revoke controller permission for an address.\\\\n    function removeController(address controller) external;\\\\n\\\\n    // Set the resolver for the TLD this registrar manages.\\\\n    function setResolver(address resolver) external;\\\\n\\\\n    // Returns the expiration timestamp of the specified label hash.\\\\n    function nameExpires(uint256 id) external view returns (uint256);\\\\n\\\\n    // Returns true if the specified name is available for registration.\\\\n    function available(uint256 id) external view returns (bool);\\\\n\\\\n    /// @dev Register a name.\\\\n    function register(\\\\n        uint256 id,\\\\n        address owner,\\\\n        uint256 duration\\\\n    ) external returns (uint256);\\\\n\\\\n    function renew(uint256 id, uint256 duration) external returns (uint256);\\\\n\\\\n    /// @dev Reclaim ownership of a name in ENS, if you own it in the registrar.\\\\n    function reclaim(uint256 id, address owner) external;\\\\n}\\\\n\\",\\"keccak256\\":\\"0x984447817adfb8fc76447da9c24a492379bcfa4cd4e7ed8e795ea1981be3db83\\",\\"license\\":\\"MIT\\"},\\"contracts/registry/ENS.sol\\":{\\"content\\":\\"//SPDX-License-Identifier: MIT\\\\npragma solidity >=0.8.4;\\\\n\\\\ninterface ENS {\\\\n    // Logged when the owner of a node assigns a new owner to a subnode.\\\\n    event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\\\\n\\\\n    // Logged when the owner of a node transfers ownership to a new account.\\\\n    event Transfer(bytes32 indexed node, address owner);\\\\n\\\\n    // Logged when the resolver for a node changes.\\\\n    event NewResolver(bytes32 indexed node, address resolver);\\\\n\\\\n    // Logged when the TTL of a node changes\\\\n    event NewTTL(bytes32 indexed node, uint64 ttl);\\\\n\\\\n    // Logged when an operator is added or removed.\\\\n    event ApprovalForAll(\\\\n        address indexed owner,\\\\n        address indexed operator,\\\\n        bool approved\\\\n    );\\\\n\\\\n    function setRecord(\\\\n        bytes32 node,\\\\n        address owner,\\\\n        address resolver,\\\\n        uint64 ttl\\\\n    ) external;\\\\n\\\\n    function setSubnodeRecord(\\\\n        bytes32 node,\\\\n        bytes32 label,\\\\n        address owner,\\\\n        address resolver,\\\\n        uint64 ttl\\\\n    ) external;\\\\n\\\\n    function setSubnodeOwner(\\\\n        bytes32 node,\\\\n        bytes32 label,\\\\n        address owner\\\\n    ) external returns (bytes32);\\\\n\\\\n    function setResolver(bytes32 node, address resolver) external;\\\\n\\\\n    function setOwner(bytes32 node, address owner) external;\\\\n\\\\n    function setTTL(bytes32 node, uint64 ttl) external;\\\\n\\\\n    function setApprovalForAll(address operator, bool approved) external;\\\\n\\\\n    function owner(bytes32 node) external view returns (address);\\\\n\\\\n    function resolver(bytes32 node) external view returns (address);\\\\n\\\\n    function ttl(bytes32 node) external view returns (uint64);\\\\n\\\\n    function recordExists(bytes32 node) external view returns (bool);\\\\n\\\\n    function isApprovedForAll(\\\\n        address owner,\\\\n        address operator\\\\n    ) external view returns (bool);\\\\n}\\\\n\\",\\"keccak256\\":\\"0x8e208b44d5dbf22552fe72d79b45c640855b84fbc9ee21f4c3bb4bfe81cbe8db\\",\\"license\\":\\"MIT\\"},\\"contracts/resolvers/IMulticallable.sol\\":{\\"content\\":\\"// SPDX-License-Identifier: MIT\\\\npragma solidity ^0.8.4;\\\\n\\\\ninterface IMulticallable {\\\\n    function multicall(\\\\n        bytes[] calldata data\\\\n    ) external returns (bytes[] memory results);\\\\n\\\\n    function multicallWithNodeCheck(\\\\n        bytes32,\\\\n        bytes[] calldata data\\\\n    ) external returns (bytes[] memory results);\\\\n}\\\\n\\",\\"keccak256\\":\\"0x0334202e20bb11995997083d05963f5e8e7ed6194cba494e7f9371ab7bf4e2c3\\",\\"license\\":\\"MIT\\"},\\"contracts/resolvers/Multicallable.sol\\":{\\"content\\":\\"// SPDX-License-Identifier: MIT\\\\npragma solidity ^0.8.4;\\\\n\\\\nimport \\\\\\"./IMulticallable.sol\\\\\\";\\\\nimport \\\\\\"@openzeppelin/contracts/utils/introspection/ERC165.sol\\\\\\";\\\\n\\\\nabstract contract Multicallable is IMulticallable, ERC165 {\\\\n    function _multicall(\\\\n        bytes32 nodehash,\\\\n        bytes[] calldata data\\\\n    ) internal returns (bytes[] memory results) {\\\\n        results = new bytes[](data.length);\\\\n        for (uint256 i = 0; i < data.length; i++) {\\\\n            if (nodehash != bytes32(0)) {\\\\n                bytes32 txNamehash = bytes32(data[i][4:36]);\\\\n                require(\\\\n                    txNamehash == nodehash,\\\\n                    \\\\\\"multicall: All records must have a matching namehash\\\\\\"\\\\n                );\\\\n            }\\\\n            (bool success, bytes memory result) = address(this).delegatecall(\\\\n                data[i]\\\\n            );\\\\n            require(success);\\\\n            results[i] = result;\\\\n        }\\\\n        return results;\\\\n    }\\\\n\\\\n    // This function provides an extra security check when called\\\\n    // from priviledged contracts (such as EthRegistrarController)\\\\n    // that can set records on behalf of the node owners\\\\n    function multicallWithNodeCheck(\\\\n        bytes32 nodehash,\\\\n        bytes[] calldata data\\\\n    ) external returns (bytes[] memory results) {\\\\n        return _multicall(nodehash, data);\\\\n    }\\\\n\\\\n    function multicall(\\\\n        bytes[] calldata data\\\\n    ) public override returns (bytes[] memory results) {\\\\n        return _multicall(bytes32(0), data);\\\\n    }\\\\n\\\\n    function supportsInterface(\\\\n        bytes4 interfaceID\\\\n    ) public view virtual override returns (bool) {\\\\n        return\\\\n            interfaceID == type(IMulticallable).interfaceId ||\\\\n            super.supportsInterface(interfaceID);\\\\n    }\\\\n}\\\\n\\",\\"keccak256\\":\\"0x1063a9dd3b94ba304624d5ec6deb43c1916640758ae970eece4d4e3ef8b2fcb1\\",\\"license\\":\\"MIT\\"},\\"contracts/resolvers/PublicResolver.sol\\":{\\"content\\":\\"//SPDX-License-Identifier: MIT\\\\npragma solidity >=0.8.17 <0.9.0;\\\\n\\\\nimport \\\\\\"../registry/ENS.sol\\\\\\";\\\\nimport \\\\\\"./profiles/ABIResolver.sol\\\\\\";\\\\nimport \\\\\\"./profiles/AddrResolver.sol\\\\\\";\\\\nimport \\\\\\"./profiles/ContentHashResolver.sol\\\\\\";\\\\nimport \\\\\\"./profiles/DNSResolver.sol\\\\\\";\\\\nimport \\\\\\"./profiles/InterfaceResolver.sol\\\\\\";\\\\nimport \\\\\\"./profiles/NameResolver.sol\\\\\\";\\\\nimport \\\\\\"./profiles/PubkeyResolver.sol\\\\\\";\\\\nimport \\\\\\"./profiles/TextResolver.sol\\\\\\";\\\\nimport \\\\\\"./Multicallable.sol\\\\\\";\\\\nimport {ReverseClaimer} from \\\\\\"../reverseRegistrar/ReverseClaimer.sol\\\\\\";\\\\nimport {INameWrapper} from \\\\\\"../wrapper/INameWrapper.sol\\\\\\";\\\\n\\\\n/// A simple resolver anyone can use; only allows the owner of a node to set its\\\\n/// address.\\\\ncontract PublicResolver is\\\\n    Multicallable,\\\\n    ABIResolver,\\\\n    AddrResolver,\\\\n    ContentHashResolver,\\\\n    DNSResolver,\\\\n    InterfaceResolver,\\\\n    NameResolver,\\\\n    PubkeyResolver,\\\\n    TextResolver,\\\\n    ReverseClaimer\\\\n{\\\\n    ENS immutable ens;\\\\n    INameWrapper immutable nameWrapper;\\\\n    address immutable trustedETHController;\\\\n    address immutable trustedReverseRegistrar;\\\\n\\\\n    /// A mapping of operators. An address that is authorised for an address\\\\n    /// may make any changes to the name that the owner could, but may not update\\\\n    /// the set of authorisations.\\\\n    /// (owner, operator) => approved\\\\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\\\\n\\\\n    /// A mapping of delegates. A delegate that is authorised by an owner\\\\n    /// for a name may make changes to the name\'s resolver, but may not update\\\\n    /// the set of token approvals.\\\\n    /// (owner, name, delegate) => approved\\\\n    mapping(address => mapping(bytes32 => mapping(address => bool)))\\\\n        private _tokenApprovals;\\\\n\\\\n    // Logged when an operator is added or removed.\\\\n    event ApprovalForAll(\\\\n        address indexed owner,\\\\n        address indexed operator,\\\\n        bool approved\\\\n    );\\\\n\\\\n    // Logged when a delegate is approved or  an approval is revoked.\\\\n    event Approved(\\\\n        address owner,\\\\n        bytes32 indexed node,\\\\n        address indexed delegate,\\\\n        bool indexed approved\\\\n    );\\\\n\\\\n    constructor(\\\\n        ENS _ens,\\\\n        INameWrapper wrapperAddress,\\\\n        address _trustedETHController,\\\\n        address _trustedReverseRegistrar\\\\n    ) ReverseClaimer(_ens, msg.sender) {\\\\n        ens = _ens;\\\\n        nameWrapper = wrapperAddress;\\\\n        trustedETHController = _trustedETHController;\\\\n        trustedReverseRegistrar = _trustedReverseRegistrar;\\\\n    }\\\\n\\\\n    /// @dev See {IERC1155-setApprovalForAll}.\\\\n    function setApprovalForAll(address operator, bool approved) external {\\\\n        require(\\\\n            msg.sender != operator,\\\\n            \\\\\\"ERC1155: setting approval status for self\\\\\\"\\\\n        );\\\\n\\\\n        _operatorApprovals[msg.sender][operator] = approved;\\\\n        emit ApprovalForAll(msg.sender, operator, approved);\\\\n    }\\\\n\\\\n    /// @dev See {IERC1155-isApprovedForAll}.\\\\n    function isApprovedForAll(\\\\n        address account,\\\\n        address operator\\\\n    ) public view returns (bool) {\\\\n        return _operatorApprovals[account][operator];\\\\n    }\\\\n\\\\n    /// @dev Approve a delegate to be able to updated records on a node.\\\\n    function approve(bytes32 node, address delegate, bool approved) external {\\\\n        require(msg.sender != delegate, \\\\\\"Setting delegate status for self\\\\\\");\\\\n\\\\n        _tokenApprovals[msg.sender][node][delegate] = approved;\\\\n        emit Approved(msg.sender, node, delegate, approved);\\\\n    }\\\\n\\\\n    /// @dev Check to see if the delegate has been approved by the owner for the node.\\\\n    function isApprovedFor(\\\\n        address owner,\\\\n        bytes32 node,\\\\n        address delegate\\\\n    ) public view returns (bool) {\\\\n        return _tokenApprovals[owner][node][delegate];\\\\n    }\\\\n\\\\n    function isAuthorised(bytes32 node) internal view override returns (bool) {\\\\n        if (\\\\n            msg.sender == trustedETHController ||\\\\n            msg.sender == trustedReverseRegistrar\\\\n        ) {\\\\n            return true;\\\\n        }\\\\n        address owner = ens.owner(node);\\\\n        if (owner == address(nameWrapper)) {\\\\n            owner = nameWrapper.ownerOf(uint256(node));\\\\n        }\\\\n        return\\\\n            owner == msg.sender ||\\\\n            isApprovedForAll(owner, msg.sender) ||\\\\n            isApprovedFor(owner, node, msg.sender);\\\\n    }\\\\n\\\\n    function supportsInterface(\\\\n        bytes4 interfaceID\\\\n    )\\\\n        public\\\\n        view\\\\n        override(\\\\n            Multicallable,\\\\n            ABIResolver,\\\\n            AddrResolver,\\\\n            ContentHashResolver,\\\\n            DNSResolver,\\\\n            InterfaceResolver,\\\\n            NameResolver,\\\\n            PubkeyResolver,\\\\n            TextResolver\\\\n        )\\\\n        returns (bool)\\\\n    {\\\\n        return super.supportsInterface(interfaceID);\\\\n    }\\\\n}\\\\n\\",\\"keccak256\\":\\"0x65b478c405ac2742d9a6661cb62adb7b09bf2bf03cff7b8a0fe970e0aad3f4aa\\",\\"license\\":\\"MIT\\"},\\"contracts/resolvers/ResolverBase.sol\\":{\\"content\\":\\"// SPDX-License-Identifier: MIT\\\\npragma solidity >=0.8.4;\\\\n\\\\nimport \\\\\\"@openzeppelin/contracts/utils/introspection/ERC165.sol\\\\\\";\\\\nimport \\\\\\"./profiles/IVersionableResolver.sol\\\\\\";\\\\n\\\\nabstract contract ResolverBase is ERC165, IVersionableResolver {\\\\n    mapping(bytes32 => uint64) public recordVersions;\\\\n\\\\n    function isAuthorised(bytes32 node) internal view virtual returns (bool);\\\\n\\\\n    modifier authorised(bytes32 node) {\\\\n        require(isAuthorised(node));\\\\n        _;\\\\n    }\\\\n\\\\n    /// Increments the record version associated with an ENS node.\\\\n    /// May only be called by the owner of that node in the ENS registry.\\\\n    /// @param node The node to update.\\\\n    function clearRecords(bytes32 node) public virtual authorised(node) {\\\\n        recordVersions[node]++;\\\\n        emit VersionChanged(node, recordVersions[node]);\\\\n    }\\\\n\\\\n    function supportsInterface(\\\\n        bytes4 interfaceID\\\\n    ) public view virtual override returns (bool) {\\\\n        return\\\\n            interfaceID == type(IVersionableResolver).interfaceId ||\\\\n            super.supportsInterface(interfaceID);\\\\n    }\\\\n}\\\\n\\",\\"keccak256\\":\\"0xb063f86c1e75508779fd23762f20ebfbb2f3ef6d84328038e3de01cf59d18e4b\\",\\"license\\":\\"MIT\\"},\\"contracts/resolvers/profiles/ABIResolver.sol\\":{\\"content\\":\\"// SPDX-License-Identifier: MIT\\\\npragma solidity >=0.8.4;\\\\n\\\\nimport \\\\\\"./IABIResolver.sol\\\\\\";\\\\nimport \\\\\\"../ResolverBase.sol\\\\\\";\\\\n\\\\nabstract contract ABIResolver is IABIResolver, ResolverBase {\\\\n    mapping(uint64 => mapping(bytes32 => mapping(uint256 => bytes))) versionable_abis;\\\\n\\\\n    /// Sets the ABI associated with an ENS node.\\\\n    /// Nodes may have one ABI of each content type. To remove an ABI, set it to\\\\n    /// the empty string.\\\\n    /// @param node The node to update.\\\\n    /// @param contentType The content type of the ABI\\\\n    /// @param data The ABI data.\\\\n    function setABI(\\\\n        bytes32 node,\\\\n        uint256 contentType,\\\\n        bytes calldata data\\\\n    ) external virtual authorised(node) {\\\\n        // Content types must be powers of 2\\\\n        require(((contentType - 1) & contentType) == 0);\\\\n\\\\n        versionable_abis[recordVersions[node]][node][contentType] = data;\\\\n        emit ABIChanged(node, contentType);\\\\n    }\\\\n\\\\n    /// Returns the ABI associated with an ENS node.\\\\n    /// Defined in EIP205.\\\\n    /// @param node The ENS node to query\\\\n    /// @param contentTypes A bitwise OR of the ABI formats accepted by the caller.\\\\n    /// @return contentType The content type of the return value\\\\n    /// @return data The ABI data\\\\n    function ABI(\\\\n        bytes32 node,\\\\n        uint256 contentTypes\\\\n    ) external view virtual override returns (uint256, bytes memory) {\\\\n        mapping(uint256 => bytes) storage abiset = versionable_abis[\\\\n            recordVersions[node]\\\\n        ][node];\\\\n\\\\n        for (\\\\n            uint256 contentType = 1;\\\\n            contentType > 0 && contentType <= contentTypes;\\\\n            contentType <<= 1\\\\n        ) {\\\\n            if (\\\\n                (contentType & contentTypes) != 0 &&\\\\n                abiset[contentType].length > 0\\\\n            ) {\\\\n                return (contentType, abiset[contentType]);\\\\n            }\\\\n        }\\\\n\\\\n        return (0, bytes(\\\\\\"\\\\\\"));\\\\n    }\\\\n\\\\n    function supportsInterface(\\\\n        bytes4 interfaceID\\\\n    ) public view virtual override returns (bool) {\\\\n        return\\\\n            interfaceID == type(IABIResolver).interfaceId ||\\\\n            super.supportsInterface(interfaceID);\\\\n    }\\\\n}\\\\n\\",\\"keccak256\\":\\"0xf938b15d989964645a1aba2c151663fd63d2942c8daf46470ac7b15fe3d41641\\",\\"license\\":\\"MIT\\"},\\"contracts/resolvers/profiles/AddrResolver.sol\\":{\\"content\\":\\"// SPDX-License-Identifier: MIT\\\\npragma solidity >=0.8.4;\\\\n\\\\nimport {ResolverBase, IERC165} from \\\\\\"../ResolverBase.sol\\\\\\";\\\\nimport {IAddrResolver} from \\\\\\"./IAddrResolver.sol\\\\\\";\\\\nimport {IAddressResolver} from \\\\\\"./IAddressResolver.sol\\\\\\";\\\\nimport {IHasAddressResolver} from \\\\\\"./IHasAddressResolver.sol\\\\\\";\\\\nimport {ENSIP19, COIN_TYPE_ETH, COIN_TYPE_DEFAULT} from \\\\\\"../../utils/ENSIP19.sol\\\\\\";\\\\n\\\\nabstract contract AddrResolver is\\\\n    IAddrResolver,\\\\n    IAddressResolver,\\\\n    IHasAddressResolver,\\\\n    ResolverBase\\\\n{\\\\n    mapping(uint64 => mapping(bytes32 => mapping(uint256 => bytes))) versionable_addresses;\\\\n\\\\n    /// @notice The supplied address could not be converted to `address`.\\\\n    /// @dev Error selector: `0x8d666f60`\\\\n    error InvalidEVMAddress(bytes addressBytes);\\\\n\\\\n    /// @notice Set `addr(60)` of the associated ENS node.\\\\n    ///         `address(0)` is stored as `new bytes(20)`.\\\\n    /// @param node The node to update.\\\\n    /// @param _addr The address to set.\\\\n    function setAddr(\\\\n        bytes32 node,\\\\n        address _addr\\\\n    ) external virtual authorised(node) {\\\\n        setAddr(node, COIN_TYPE_ETH, abi.encodePacked(_addr));\\\\n    }\\\\n\\\\n    /// @notice Get `addr(60)` as `address` of the associated ENS node.\\\\n    /// @param node The node to query.\\\\n    /// @return The associated address.\\\\n    function addr(\\\\n        bytes32 node\\\\n    ) public view virtual override returns (address payable) {\\\\n        return payable(address(bytes20(addr(node, COIN_TYPE_ETH))));\\\\n    }\\\\n\\\\n    /// @notice Set the address for coin type of the associated ENS node.\\\\n    ///         Reverts `InvalidEVMAddress` if coin type is EVM and not 0 or 20 bytes.\\\\n    /// @param node The node to update.\\\\n    /// @param coinType The coin type.\\\\n    /// @param addressBytes The address to set.\\\\n    function setAddr(\\\\n        bytes32 node,\\\\n        uint256 coinType,\\\\n        bytes memory addressBytes\\\\n    ) public virtual authorised(node) {\\\\n        if (\\\\n            addressBytes.length != 0 &&\\\\n            addressBytes.length != 20 &&\\\\n            ENSIP19.isEVMCoinType(coinType)\\\\n        ) {\\\\n            revert InvalidEVMAddress(addressBytes);\\\\n        }\\\\n        emit AddressChanged(node, coinType, addressBytes);\\\\n        if (coinType == COIN_TYPE_ETH) {\\\\n            emit AddrChanged(node, address(bytes20(addressBytes)));\\\\n        }\\\\n        versionable_addresses[recordVersions[node]][node][\\\\n            coinType\\\\n        ] = addressBytes;\\\\n    }\\\\n\\\\n    /// @notice Get the address for coin type of the associated ENS node.\\\\n    ///         If coin type is EVM and empty, defaults to `addr(COIN_TYPE_DEFAULT)`.\\\\n    /// @param node The node to query.\\\\n    /// @param coinType The coin type.\\\\n    /// @return addressBytes The assocated address.\\\\n    function addr(\\\\n        bytes32 node,\\\\n        uint256 coinType\\\\n    ) public view virtual override returns (bytes memory addressBytes) {\\\\n        mapping(uint256 => bytes) storage addrs = versionable_addresses[\\\\n            recordVersions[node]\\\\n        ][node];\\\\n        addressBytes = addrs[coinType];\\\\n        if (\\\\n            addressBytes.length == 0 && ENSIP19.chainFromCoinType(coinType) > 0\\\\n        ) {\\\\n            addressBytes = addrs[COIN_TYPE_DEFAULT];\\\\n        }\\\\n    }\\\\n\\\\n    /// @inheritdoc IHasAddressResolver\\\\n    function hasAddr(\\\\n        bytes32 node,\\\\n        uint256 coinType\\\\n    ) external view returns (bool) {\\\\n        return\\\\n            versionable_addresses[recordVersions[node]][node][coinType].length >\\\\n            0;\\\\n    }\\\\n\\\\n    /// @inheritdoc IERC165\\\\n    function supportsInterface(\\\\n        bytes4 interfaceId\\\\n    ) public view virtual override returns (bool) {\\\\n        return\\\\n            type(IAddrResolver).interfaceId == interfaceId ||\\\\n            type(IAddressResolver).interfaceId == interfaceId ||\\\\n            type(IHasAddressResolver).interfaceId == interfaceId ||\\\\n            super.supportsInterface(interfaceId);\\\\n    }\\\\n}\\\\n\\",\\"keccak256\\":\\"0x2d214ea1213dbd8cc02d32355edf044a6551296df56e8a4931d3447092e8abcc\\",\\"license\\":\\"MIT\\"},\\"contracts/resolvers/profiles/ContentHashResolver.sol\\":{\\"content\\":\\"// SPDX-License-Identifier: MIT\\\\npragma solidity >=0.8.4;\\\\n\\\\nimport \\\\\\"../ResolverBase.sol\\\\\\";\\\\nimport \\\\\\"./IContentHashResolver.sol\\\\\\";\\\\n\\\\nabstract contract ContentHashResolver is IContentHashResolver, ResolverBase {\\\\n    mapping(uint64 => mapping(bytes32 => bytes)) versionable_hashes;\\\\n\\\\n    /// Sets the contenthash associated with an ENS node.\\\\n    /// May only be called by the owner of that node in the ENS registry.\\\\n    /// @param node The node to update.\\\\n    /// @param hash The contenthash to set\\\\n    function setContenthash(\\\\n        bytes32 node,\\\\n        bytes calldata hash\\\\n    ) external virtual authorised(node) {\\\\n        versionable_hashes[recordVersions[node]][node] = hash;\\\\n        emit ContenthashChanged(node, hash);\\\\n    }\\\\n\\\\n    /// Returns the contenthash associated with an ENS node.\\\\n    /// @param node The ENS node to query.\\\\n    /// @return The associated contenthash.\\\\n    function contenthash(\\\\n        bytes32 node\\\\n    ) external view virtual override returns (bytes memory) {\\\\n        return versionable_hashes[recordVersions[node]][node];\\\\n    }\\\\n\\\\n    function supportsInterface(\\\\n        bytes4 interfaceID\\\\n    ) public view virtual override returns (bool) {\\\\n        return\\\\n            interfaceID == type(IContentHashResolver).interfaceId ||\\\\n            super.supportsInterface(interfaceID);\\\\n    }\\\\n}\\\\n\\",\\"keccak256\\":\\"0x8eddfb712744906b41ad3458171438605982cdcd0c570d91fed49eca56bf7def\\",\\"license\\":\\"MIT\\"},\\"contracts/resolvers/profiles/DNSResolver.sol\\":{\\"content\\":\\"// SPDX-License-Identifier: MIT\\\\npragma solidity >=0.8.4;\\\\n\\\\nimport \\\\\\"../ResolverBase.sol\\\\\\";\\\\nimport \\\\\\"../../dnssec-oracle/RRUtils.sol\\\\\\";\\\\nimport \\\\\\"./IDNSRecordResolver.sol\\\\\\";\\\\nimport \\\\\\"./IDNSZoneResolver.sol\\\\\\";\\\\n\\\\nabstract contract DNSResolver is\\\\n    IDNSRecordResolver,\\\\n    IDNSZoneResolver,\\\\n    ResolverBase\\\\n{\\\\n    using RRUtils for *;\\\\n    using BytesUtils for bytes;\\\\n\\\\n    // Zone hashes for the domains.\\\\n    // A zone hash is an EIP-1577 content hash in binary format that should point to a\\\\n    // resource containing a single zonefile.\\\\n    // node => contenthash\\\\n    mapping(uint64 => mapping(bytes32 => bytes)) private versionable_zonehashes;\\\\n\\\\n    // The records themselves.  Stored as binary RRSETs\\\\n    // node => version => name => resource => data\\\\n    mapping(uint64 => mapping(bytes32 => mapping(bytes32 => mapping(uint16 => bytes))))\\\\n        private versionable_records;\\\\n\\\\n    // Count of number of entries for a given name.  Required for DNS resolvers\\\\n    // when resolving wildcards.\\\\n    // node => version => name => number of records\\\\n    mapping(uint64 => mapping(bytes32 => mapping(bytes32 => uint16)))\\\\n        private versionable_nameEntriesCount;\\\\n\\\\n    /// Set one or more DNS records.  Records are supplied in wire-format.\\\\n    /// Records with the same node/name/resource must be supplied one after the\\\\n    /// other to ensure the data is updated correctly. For example, if the data\\\\n    /// was supplied:\\\\n    ///     a.example.com IN A 1.2.3.4\\\\n    ///     a.example.com IN A 5.6.7.8\\\\n    ///     www.example.com IN CNAME a.example.com.\\\\n    /// then this would store the two A records for a.example.com correctly as a\\\\n    /// single RRSET, however if the data was supplied:\\\\n    ///     a.example.com IN A 1.2.3.4\\\\n    ///     www.example.com IN CNAME a.example.com.\\\\n    ///     a.example.com IN A 5.6.7.8\\\\n    /// then this would store the first A record, the CNAME, then the second A\\\\n    /// record which would overwrite the first.\\\\n    ///\\\\n    /// @param node the namehash of the node for which to set the records\\\\n    /// @param data the DNS wire format records to set\\\\n    function setDNSRecords(\\\\n        bytes32 node,\\\\n        bytes calldata data\\\\n    ) external virtual authorised(node) {\\\\n        uint16 resource = 0;\\\\n        uint256 offset = 0;\\\\n        bytes memory name;\\\\n        bytes memory value;\\\\n        bytes32 nameHash;\\\\n        uint64 version = recordVersions[node];\\\\n        // Iterate over the data to add the resource records\\\\n        for (\\\\n            RRUtils.RRIterator memory iter = data.iterateRRs(0);\\\\n            !iter.done();\\\\n            iter.next()\\\\n        ) {\\\\n            if (resource == 0) {\\\\n                resource = iter.dnstype;\\\\n                name = iter.name();\\\\n                nameHash = keccak256(abi.encodePacked(name));\\\\n                value = bytes(iter.rdata());\\\\n            } else {\\\\n                bytes memory newName = iter.name();\\\\n                if (resource != iter.dnstype || !name.equals(newName)) {\\\\n                    setDNSRRSet(\\\\n                        node,\\\\n                        name,\\\\n                        resource,\\\\n                        data,\\\\n                        offset,\\\\n                        iter.offset - offset,\\\\n                        value.length == 0,\\\\n                        version\\\\n                    );\\\\n                    resource = iter.dnstype;\\\\n                    offset = iter.offset;\\\\n                    name = newName;\\\\n                    nameHash = keccak256(name);\\\\n                    value = bytes(iter.rdata());\\\\n                }\\\\n            }\\\\n        }\\\\n        if (name.length > 0) {\\\\n            setDNSRRSet(\\\\n                node,\\\\n                name,\\\\n                resource,\\\\n                data,\\\\n                offset,\\\\n                data.length - offset,\\\\n                value.length == 0,\\\\n                version\\\\n            );\\\\n        }\\\\n    }\\\\n\\\\n    /// Obtain a DNS record.\\\\n    /// @param node the namehash of the node for which to fetch the record\\\\n    /// @param name the keccak-256 hash of the fully-qualified name for which to fetch the record\\\\n    /// @param resource the ID of the resource as per https://en.wikipedia.org/wiki/List_of_DNS_record_types\\\\n    /// @return the DNS record in wire format if present, otherwise empty\\\\n    function dnsRecord(\\\\n        bytes32 node,\\\\n        bytes32 name,\\\\n        uint16 resource\\\\n    ) public view virtual override returns (bytes memory) {\\\\n        return versionable_records[recordVersions[node]][node][name][resource];\\\\n    }\\\\n\\\\n    /// Check if a given node has records.\\\\n    /// @param node the namehash of the node for which to check the records\\\\n    /// @param name the namehash of the node for which to check the records\\\\n    function hasDNSRecords(\\\\n        bytes32 node,\\\\n        bytes32 name\\\\n    ) public view virtual returns (bool) {\\\\n        return (versionable_nameEntriesCount[recordVersions[node]][node][\\\\n            name\\\\n        ] != 0);\\\\n    }\\\\n\\\\n    /// setZonehash sets the hash for the zone.\\\\n    /// May only be called by the owner of that node in the ENS registry.\\\\n    /// @param node The node to update.\\\\n    /// @param hash The zonehash to set\\\\n    function setZonehash(\\\\n        bytes32 node,\\\\n        bytes calldata hash\\\\n    ) external virtual authorised(node) {\\\\n        uint64 currentRecordVersion = recordVersions[node];\\\\n        bytes memory oldhash = versionable_zonehashes[currentRecordVersion][\\\\n            node\\\\n        ];\\\\n        versionable_zonehashes[currentRecordVersion][node] = hash;\\\\n        emit DNSZonehashChanged(node, oldhash, hash);\\\\n    }\\\\n\\\\n    /// zonehash obtains the hash for the zone.\\\\n    /// @param node The ENS node to query.\\\\n    /// @return The associated contenthash.\\\\n    function zonehash(\\\\n        bytes32 node\\\\n    ) external view virtual override returns (bytes memory) {\\\\n        return versionable_zonehashes[recordVersions[node]][node];\\\\n    }\\\\n\\\\n    function supportsInterface(\\\\n        bytes4 interfaceID\\\\n    ) public view virtual override returns (bool) {\\\\n        return\\\\n            interfaceID == type(IDNSRecordResolver).interfaceId ||\\\\n            interfaceID == type(IDNSZoneResolver).interfaceId ||\\\\n            super.supportsInterface(interfaceID);\\\\n    }\\\\n\\\\n    function setDNSRRSet(\\\\n        bytes32 node,\\\\n        bytes memory name,\\\\n        uint16 resource,\\\\n        bytes memory data,\\\\n        uint256 offset,\\\\n        uint256 size,\\\\n        bool deleteRecord,\\\\n        uint64 version\\\\n    ) private {\\\\n        bytes32 nameHash = keccak256(name);\\\\n        bytes memory rrData = data.substring(offset, size);\\\\n        if (deleteRecord) {\\\\n            if (\\\\n                versionable_records[version][node][nameHash][resource].length !=\\\\n                0\\\\n            ) {\\\\n                versionable_nameEntriesCount[version][node][nameHash]--;\\\\n            }\\\\n            delete (versionable_records[version][node][nameHash][resource]);\\\\n            emit DNSRecordDeleted(node, name, resource);\\\\n        } else {\\\\n            if (\\\\n                versionable_records[version][node][nameHash][resource].length ==\\\\n                0\\\\n            ) {\\\\n                versionable_nameEntriesCount[version][node][nameHash]++;\\\\n            }\\\\n            versionable_records[version][node][nameHash][resource] = rrData;\\\\n            emit DNSRecordChanged(node, name, resource, rrData);\\\\n        }\\\\n    }\\\\n}\\\\n\\",\\"keccak256\\":\\"0x3f5344239a3461c06389c952ae8e6feb29f0fd72dea1baaf31be81ba8b6a194a\\",\\"license\\":\\"MIT\\"},\\"contracts/resolvers/profiles/IABIResolver.sol\\":{\\"content\\":\\"// SPDX-License-Identifier: MIT\\\\npragma solidity >=0.8.4;\\\\n\\\\ninterface IABIResolver {\\\\n    event ABIChanged(bytes32 indexed node, uint256 indexed contentType);\\\\n\\\\n    /// Returns the ABI associated with an ENS node.\\\\n    /// Defined in EIP205.\\\\n    /// @param node The ENS node to query\\\\n    /// @param contentTypes A bitwise OR of the ABI formats accepted by the caller.\\\\n    /// @return contentType The content type of the return value\\\\n    /// @return data The ABI data\\\\n    function ABI(\\\\n        bytes32 node,\\\\n        uint256 contentTypes\\\\n    ) external view returns (uint256, bytes memory);\\\\n}\\\\n\\",\\"keccak256\\":\\"0x3a7a763d7a4f0d196c4b628545b022b1d1d0e37baf84eaa6eecb1a57a1633cad\\",\\"license\\":\\"MIT\\"},\\"contracts/resolvers/profiles/IAddrResolver.sol\\":{\\"content\\":\\"// SPDX-License-Identifier: MIT\\\\npragma solidity >=0.8.4;\\\\n\\\\n/// Interface for the legacy (ETH-only) addr function.\\\\ninterface IAddrResolver {\\\\n    event AddrChanged(bytes32 indexed node, address a);\\\\n\\\\n    /// Returns the address associated with an ENS node.\\\\n    /// @param node The ENS node to query.\\\\n    /// @return The associated address.\\\\n    function addr(bytes32 node) external view returns (address payable);\\\\n}\\\\n\\",\\"keccak256\\":\\"0x91dd0c350698c505d6c7e4c919da9f981d4b8d7ad062e25073fa1f6af7cb79d1\\",\\"license\\":\\"MIT\\"},\\"contracts/resolvers/profiles/IAddressResolver.sol\\":{\\"content\\":\\"// SPDX-License-Identifier: MIT\\\\npragma solidity >=0.8.4;\\\\n\\\\n/// Interface for the new (multicoin) addr function.\\\\ninterface IAddressResolver {\\\\n    event AddressChanged(\\\\n        bytes32 indexed node,\\\\n        uint256 coinType,\\\\n        bytes newAddress\\\\n    );\\\\n\\\\n    function addr(\\\\n        bytes32 node,\\\\n        uint256 coinType\\\\n    ) external view returns (bytes memory);\\\\n}\\\\n\\",\\"keccak256\\":\\"0x8da5dd0fc1c5ab4f47e03c23126976a86d4b2dbeac161e70e3af9e2a13330cf0\\",\\"license\\":\\"MIT\\"},\\"contracts/resolvers/profiles/IContentHashResolver.sol\\":{\\"content\\":\\"// SPDX-License-Identifier: MIT\\\\npragma solidity >=0.8.4;\\\\n\\\\ninterface IContentHashResolver {\\\\n    event ContenthashChanged(bytes32 indexed node, bytes hash);\\\\n\\\\n    /// Returns the contenthash associated with an ENS node.\\\\n    /// @param node The ENS node to query.\\\\n    /// @return The associated contenthash.\\\\n    function contenthash(bytes32 node) external view returns (bytes memory);\\\\n}\\\\n\\",\\"keccak256\\":\\"0xaa978b1ee4c19e99c8aa409dc553e9b4c1bf9fe3c5bad718cd3589e6c9e6d121\\",\\"license\\":\\"MIT\\"},\\"contracts/resolvers/profiles/IDNSRecordResolver.sol\\":{\\"content\\":\\"// SPDX-License-Identifier: MIT\\\\npragma solidity >=0.8.4;\\\\n\\\\ninterface IDNSRecordResolver {\\\\n    // DNSRecordChanged is emitted whenever a given node/name/resource\'s RRSET is updated.\\\\n    event DNSRecordChanged(\\\\n        bytes32 indexed node,\\\\n        bytes name,\\\\n        uint16 resource,\\\\n        bytes record\\\\n    );\\\\n    // DNSRecordDeleted is emitted whenever a given node/name/resource\'s RRSET is deleted.\\\\n    event DNSRecordDeleted(bytes32 indexed node, bytes name, uint16 resource);\\\\n\\\\n    /// Obtain a DNS record.\\\\n    /// @param node the namehash of the node for which to fetch the record\\\\n    /// @param name the keccak-256 hash of the fully-qualified name for which to fetch the record\\\\n    /// @param resource the ID of the resource as per https://en.wikipedia.org/wiki/List_of_DNS_record_types\\\\n    /// @return the DNS record in wire format if present, otherwise empty\\\\n    function dnsRecord(\\\\n        bytes32 node,\\\\n        bytes32 name,\\\\n        uint16 resource\\\\n    ) external view returns (bytes memory);\\\\n}\\\\n\\",\\"keccak256\\":\\"0x434bf76bba71eed3e0f22b3a5b9f8aaed0ddd8b79f6a1e7c7447785be5924d3b\\",\\"license\\":\\"MIT\\"},\\"contracts/resolvers/profiles/IDNSZoneResolver.sol\\":{\\"content\\":\\"// SPDX-License-Identifier: MIT\\\\npragma solidity >=0.8.4;\\\\n\\\\ninterface IDNSZoneResolver {\\\\n    // DNSZonehashChanged is emitted whenever a given node\'s zone hash is updated.\\\\n    event DNSZonehashChanged(\\\\n        bytes32 indexed node,\\\\n        bytes lastzonehash,\\\\n        bytes zonehash\\\\n    );\\\\n\\\\n    /// zonehash obtains the hash for the zone.\\\\n    /// @param node The ENS node to query.\\\\n    /// @return The associated contenthash.\\\\n    function zonehash(bytes32 node) external view returns (bytes memory);\\\\n}\\\\n\\",\\"keccak256\\":\\"0x3a028c0b13721c7627c55bbf5a7d0762d5b1db1045fdc0f8e417011876bd2d29\\",\\"license\\":\\"MIT\\"},\\"contracts/resolvers/profiles/IHasAddressResolver.sol\\":{\\"content\\":\\"// SPDX-License-Identifier: MIT\\\\npragma solidity >=0.8.4;\\\\n\\\\ninterface IHasAddressResolver {\\\\n    /// @notice Determine if an addresss is stored for the coin type of the associated ENS node.\\\\n    /// @param node The node to query.\\\\n    /// @param coinType The coin type.\\\\n    /// @return True if the associated address is not empty.\\\\n    function hasAddr(\\\\n        bytes32 node,\\\\n        uint256 coinType\\\\n    ) external view returns (bool);\\\\n}\\\\n\\",\\"keccak256\\":\\"0xbe13530b8cc027517c235e422326abd36bb1152dac8546713471be2a7335cf2b\\",\\"license\\":\\"MIT\\"},\\"contracts/resolvers/profiles/IInterfaceResolver.sol\\":{\\"content\\":\\"// SPDX-License-Identifier: MIT\\\\npragma solidity >=0.8.4;\\\\n\\\\ninterface IInterfaceResolver {\\\\n    event InterfaceChanged(\\\\n        bytes32 indexed node,\\\\n        bytes4 indexed interfaceID,\\\\n        address implementer\\\\n    );\\\\n\\\\n    /// Returns the address of a contract that implements the specified interface for this name.\\\\n    /// If an implementer has not been set for this interfaceID and name, the resolver will query\\\\n    /// the contract at `addr()`. If `addr()` is set, a contract exists at that address, and that\\\\n    /// contract implements EIP165 and returns `true` for the specified interfaceID, its address\\\\n    /// will be returned.\\\\n    /// @param node The ENS node to query.\\\\n    /// @param interfaceID The EIP 165 interface ID to check for.\\\\n    /// @return The address that implements this interface, or 0 if the interface is unsupported.\\\\n    function interfaceImplementer(\\\\n        bytes32 node,\\\\n        bytes4 interfaceID\\\\n    ) external view returns (address);\\\\n}\\\\n\\",\\"keccak256\\":\\"0x510176a3fe60471775328756ab025d8bafda7063f52f218728ca559b8f61a357\\",\\"license\\":\\"MIT\\"},\\"contracts/resolvers/profiles/INameResolver.sol\\":{\\"content\\":\\"// SPDX-License-Identifier: MIT\\\\npragma solidity >=0.8.4;\\\\n\\\\ninterface INameResolver {\\\\n    event NameChanged(bytes32 indexed node, string name);\\\\n\\\\n    /// Returns the name associated with an ENS node, for reverse records.\\\\n    /// Defined in EIP181.\\\\n    /// @param node The ENS node to query.\\\\n    /// @return The associated name.\\\\n    function name(bytes32 node) external view returns (string memory);\\\\n}\\\\n\\",\\"keccak256\\":\\"0x3ab986332e0baad7aeb4b426aace3aa1c235be5efff8db4b6f1ce501bcdd9e68\\",\\"license\\":\\"MIT\\"},\\"contracts/resolvers/profiles/IPubkeyResolver.sol\\":{\\"content\\":\\"// SPDX-License-Identifier: MIT\\\\npragma solidity >=0.8.4;\\\\n\\\\ninterface IPubkeyResolver {\\\\n    event PubkeyChanged(bytes32 indexed node, bytes32 x, bytes32 y);\\\\n\\\\n    /// Returns the SECP256k1 public key associated with an ENS node.\\\\n    /// Defined in EIP 619.\\\\n    /// @param node The ENS node to query\\\\n    /// @return x The X coordinate of the curve point for the public key.\\\\n    /// @return y The Y coordinate of the curve point for the public key.\\\\n    function pubkey(bytes32 node) external view returns (bytes32 x, bytes32 y);\\\\n}\\\\n\\",\\"keccak256\\":\\"0x1a21561b58ce17db400c015882ff07f12f9bd0df0e7b9305841799aada441820\\",\\"license\\":\\"MIT\\"},\\"contracts/resolvers/profiles/ITextResolver.sol\\":{\\"content\\":\\"// SPDX-License-Identifier: MIT\\\\npragma solidity >=0.8.4;\\\\n\\\\ninterface ITextResolver {\\\\n    event TextChanged(\\\\n        bytes32 indexed node,\\\\n        string indexed indexedKey,\\\\n        string key,\\\\n        string value\\\\n    );\\\\n\\\\n    /// Returns the text data associated with an ENS node and key.\\\\n    /// @param node The ENS node to query.\\\\n    /// @param key The text data key to query.\\\\n    /// @return The associated text data.\\\\n    function text(\\\\n        bytes32 node,\\\\n        string calldata key\\\\n    ) external view returns (string memory);\\\\n}\\\\n\\",\\"keccak256\\":\\"0xe91c15697be2d20417cce3c58d4ecce34796986fdedc97be5b93a823be58e471\\",\\"license\\":\\"MIT\\"},\\"contracts/resolvers/profiles/IVersionableResolver.sol\\":{\\"content\\":\\"// SPDX-License-Identifier: MIT\\\\npragma solidity >=0.8.4;\\\\n\\\\ninterface IVersionableResolver {\\\\n    event VersionChanged(bytes32 indexed node, uint64 newVersion);\\\\n\\\\n    function recordVersions(bytes32 node) external view returns (uint64);\\\\n}\\\\n\\",\\"keccak256\\":\\"0xd0d09596f20c57bafb2ffa8521a8c57120e9af6c6b194f9c689d4da56f91a57c\\",\\"license\\":\\"MIT\\"},\\"contracts/resolvers/profiles/InterfaceResolver.sol\\":{\\"content\\":\\"// SPDX-License-Identifier: MIT\\\\npragma solidity >=0.8.4;\\\\n\\\\nimport \\\\\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\\\\";\\\\nimport \\\\\\"../ResolverBase.sol\\\\\\";\\\\nimport \\\\\\"./AddrResolver.sol\\\\\\";\\\\nimport \\\\\\"./IInterfaceResolver.sol\\\\\\";\\\\n\\\\nabstract contract InterfaceResolver is IInterfaceResolver, AddrResolver {\\\\n    mapping(uint64 => mapping(bytes32 => mapping(bytes4 => address))) versionable_interfaces;\\\\n\\\\n    /// Sets an interface associated with a name.\\\\n    /// Setting the address to 0 restores the default behaviour of querying the contract at `addr()` for interface support.\\\\n    /// @param node The node to update.\\\\n    /// @param interfaceID The EIP 165 interface ID.\\\\n    /// @param implementer The address of a contract that implements this interface for this node.\\\\n    function setInterface(\\\\n        bytes32 node,\\\\n        bytes4 interfaceID,\\\\n        address implementer\\\\n    ) external virtual authorised(node) {\\\\n        versionable_interfaces[recordVersions[node]][node][\\\\n            interfaceID\\\\n        ] = implementer;\\\\n        emit InterfaceChanged(node, interfaceID, implementer);\\\\n    }\\\\n\\\\n    /// Returns the address of a contract that implements the specified interface for this name.\\\\n    /// If an implementer has not been set for this interfaceID and name, the resolver will query\\\\n    /// the contract at `addr()`. If `addr()` is set, a contract exists at that address, and that\\\\n    /// contract implements EIP165 and returns `true` for the specified interfaceID, its address\\\\n    /// will be returned.\\\\n    /// @param node The ENS node to query.\\\\n    /// @param interfaceID The EIP 165 interface ID to check for.\\\\n    /// @return The address that implements this interface, or 0 if the interface is unsupported.\\\\n    function interfaceImplementer(\\\\n        bytes32 node,\\\\n        bytes4 interfaceID\\\\n    ) external view virtual override returns (address) {\\\\n        address implementer = versionable_interfaces[recordVersions[node]][\\\\n            node\\\\n        ][interfaceID];\\\\n        if (implementer != address(0)) {\\\\n            return implementer;\\\\n        }\\\\n\\\\n        address a = addr(node);\\\\n        if (a == address(0)) {\\\\n            return address(0);\\\\n        }\\\\n\\\\n        (bool success, bytes memory returnData) = a.staticcall(\\\\n            abi.encodeWithSignature(\\\\n                \\\\\\"supportsInterface(bytes4)\\\\\\",\\\\n                type(IERC165).interfaceId\\\\n            )\\\\n        );\\\\n        if (!success || returnData.length < 32 || returnData[31] == 0) {\\\\n            // EIP 165 not supported by target\\\\n            return address(0);\\\\n        }\\\\n\\\\n        (success, returnData) = a.staticcall(\\\\n            abi.encodeWithSignature(\\\\\\"supportsInterface(bytes4)\\\\\\", interfaceID)\\\\n        );\\\\n        if (!success || returnData.length < 32 || returnData[31] == 0) {\\\\n            // Specified interface not supported by target\\\\n            return address(0);\\\\n        }\\\\n\\\\n        return a;\\\\n    }\\\\n\\\\n    function supportsInterface(\\\\n        bytes4 interfaceID\\\\n    ) public view virtual override returns (bool) {\\\\n        return\\\\n            interfaceID == type(IInterfaceResolver).interfaceId ||\\\\n            super.supportsInterface(interfaceID);\\\\n    }\\\\n}\\\\n\\",\\"keccak256\\":\\"0x029b7f2fa0e763b914e2769c05b8b230aea7991f3947e5324499454e98310300\\",\\"license\\":\\"MIT\\"},\\"contracts/resolvers/profiles/NameResolver.sol\\":{\\"content\\":\\"// SPDX-License-Identifier: MIT\\\\npragma solidity >=0.8.4;\\\\n\\\\nimport \\\\\\"../ResolverBase.sol\\\\\\";\\\\nimport \\\\\\"./INameResolver.sol\\\\\\";\\\\n\\\\nabstract contract NameResolver is INameResolver, ResolverBase {\\\\n    mapping(uint64 => mapping(bytes32 => string)) versionable_names;\\\\n\\\\n    /// Sets the name associated with an ENS node, for reverse records.\\\\n    /// May only be called by the owner of that node in the ENS registry.\\\\n    /// @param node The node to update.\\\\n    function setName(\\\\n        bytes32 node,\\\\n        string calldata newName\\\\n    ) external virtual authorised(node) {\\\\n        versionable_names[recordVersions[node]][node] = newName;\\\\n        emit NameChanged(node, newName);\\\\n    }\\\\n\\\\n    /// Returns the name associated with an ENS node, for reverse records.\\\\n    /// Defined in EIP181.\\\\n    /// @param node The ENS node to query.\\\\n    /// @return The associated name.\\\\n    function name(\\\\n        bytes32 node\\\\n    ) external view virtual override returns (string memory) {\\\\n        return versionable_names[recordVersions[node]][node];\\\\n    }\\\\n\\\\n    function supportsInterface(\\\\n        bytes4 interfaceID\\\\n    ) public view virtual override returns (bool) {\\\\n        return\\\\n            interfaceID == type(INameResolver).interfaceId ||\\\\n            super.supportsInterface(interfaceID);\\\\n    }\\\\n}\\\\n\\",\\"keccak256\\":\\"0x2bee21414404629419db708bd8b8e284e702a175c17451c4b8f0f06ce5c7a250\\",\\"license\\":\\"MIT\\"},\\"contracts/resolvers/profiles/PubkeyResolver.sol\\":{\\"content\\":\\"// SPDX-License-Identifier: MIT\\\\npragma solidity >=0.8.4;\\\\n\\\\nimport \\\\\\"../ResolverBase.sol\\\\\\";\\\\nimport \\\\\\"./IPubkeyResolver.sol\\\\\\";\\\\n\\\\nabstract contract PubkeyResolver is IPubkeyResolver, ResolverBase {\\\\n    struct PublicKey {\\\\n        bytes32 x;\\\\n        bytes32 y;\\\\n    }\\\\n\\\\n    mapping(uint64 => mapping(bytes32 => PublicKey)) versionable_pubkeys;\\\\n\\\\n    /// Sets the SECP256k1 public key associated with an ENS node.\\\\n    /// @param node The ENS node to query\\\\n    /// @param x the X coordinate of the curve point for the public key.\\\\n    /// @param y the Y coordinate of the curve point for the public key.\\\\n    function setPubkey(\\\\n        bytes32 node,\\\\n        bytes32 x,\\\\n        bytes32 y\\\\n    ) external virtual authorised(node) {\\\\n        versionable_pubkeys[recordVersions[node]][node] = PublicKey(x, y);\\\\n        emit PubkeyChanged(node, x, y);\\\\n    }\\\\n\\\\n    /// Returns the SECP256k1 public key associated with an ENS node.\\\\n    /// Defined in EIP 619.\\\\n    /// @param node The ENS node to query\\\\n    /// @return x The X coordinate of the curve point for the public key.\\\\n    /// @return y The Y coordinate of the curve point for the public key.\\\\n    function pubkey(\\\\n        bytes32 node\\\\n    ) external view virtual override returns (bytes32 x, bytes32 y) {\\\\n        uint64 currentRecordVersion = recordVersions[node];\\\\n        return (\\\\n            versionable_pubkeys[currentRecordVersion][node].x,\\\\n            versionable_pubkeys[currentRecordVersion][node].y\\\\n        );\\\\n    }\\\\n\\\\n    function supportsInterface(\\\\n        bytes4 interfaceID\\\\n    ) public view virtual override returns (bool) {\\\\n        return\\\\n            interfaceID == type(IPubkeyResolver).interfaceId ||\\\\n            super.supportsInterface(interfaceID);\\\\n    }\\\\n}\\\\n\\",\\"keccak256\\":\\"0x697b350cd142af9ed401e1e73f395f039bb12cdb503bc6c3488482788d69587b\\",\\"license\\":\\"MIT\\"},\\"contracts/resolvers/profiles/TextResolver.sol\\":{\\"content\\":\\"// SPDX-License-Identifier: MIT\\\\npragma solidity >=0.8.4;\\\\n\\\\nimport \\\\\\"../ResolverBase.sol\\\\\\";\\\\nimport \\\\\\"./ITextResolver.sol\\\\\\";\\\\n\\\\nabstract contract TextResolver is ITextResolver, ResolverBase {\\\\n    mapping(uint64 => mapping(bytes32 => mapping(string => string))) versionable_texts;\\\\n\\\\n    /// Sets the text data associated with an ENS node and key.\\\\n    /// May only be called by the owner of that node in the ENS registry.\\\\n    /// @param node The node to update.\\\\n    /// @param key The key to set.\\\\n    /// @param value The text data value to set.\\\\n    function setText(\\\\n        bytes32 node,\\\\n        string calldata key,\\\\n        string calldata value\\\\n    ) external virtual authorised(node) {\\\\n        versionable_texts[recordVersions[node]][node][key] = value;\\\\n        emit TextChanged(node, key, key, value);\\\\n    }\\\\n\\\\n    /// Returns the text data associated with an ENS node and key.\\\\n    /// @param node The ENS node to query.\\\\n    /// @param key The text data key to query.\\\\n    /// @return The associated text data.\\\\n    function text(\\\\n        bytes32 node,\\\\n        string calldata key\\\\n    ) external view virtual override returns (string memory) {\\\\n        return versionable_texts[recordVersions[node]][node][key];\\\\n    }\\\\n\\\\n    function supportsInterface(\\\\n        bytes4 interfaceID\\\\n    ) public view virtual override returns (bool) {\\\\n        return\\\\n            interfaceID == type(ITextResolver).interfaceId ||\\\\n            super.supportsInterface(interfaceID);\\\\n    }\\\\n}\\\\n\\",\\"keccak256\\":\\"0x82a914dfe1b30634e729c03450e4c9ef4afd53919993231a92fb9cca2f8b3a83\\",\\"license\\":\\"MIT\\"},\\"contracts/reverseRegistrar/IReverseRegistrar.sol\\":{\\"content\\":\\"pragma solidity >=0.8.4;\\\\n\\\\ninterface IReverseRegistrar {\\\\n    function setDefaultResolver(address resolver) external;\\\\n\\\\n    function claim(address owner) external returns (bytes32);\\\\n\\\\n    function claimForAddr(\\\\n        address addr,\\\\n        address owner,\\\\n        address resolver\\\\n    ) external returns (bytes32);\\\\n\\\\n    function claimWithResolver(\\\\n        address owner,\\\\n        address resolver\\\\n    ) external returns (bytes32);\\\\n\\\\n    function setName(string memory name) external returns (bytes32);\\\\n\\\\n    function setNameForAddr(\\\\n        address addr,\\\\n        address owner,\\\\n        address resolver,\\\\n        string memory name\\\\n    ) external returns (bytes32);\\\\n\\\\n    function node(address addr) external pure returns (bytes32);\\\\n}\\\\n\\",\\"keccak256\\":\\"0x83adfcf6da72b1bcd1e3ac387afe5fc7fdf7f2ac28b7601544d2ca4b9d45d159\\"},\\"contracts/reverseRegistrar/ReverseClaimer.sol\\":{\\"content\\":\\"//SPDX-License-Identifier: MIT\\\\npragma solidity >=0.8.17 <0.9.0;\\\\n\\\\nimport {ENS} from \\\\\\"../registry/ENS.sol\\\\\\";\\\\nimport {IReverseRegistrar} from \\\\\\"../reverseRegistrar/IReverseRegistrar.sol\\\\\\";\\\\n\\\\ncontract ReverseClaimer {\\\\n    bytes32 constant ADDR_REVERSE_NODE =\\\\n        0x91d1777781884d03a6757a803996e38de2a42967fb37eeaca72729271025a9e2;\\\\n\\\\n    constructor(ENS ens, address claimant) {\\\\n        IReverseRegistrar reverseRegistrar = IReverseRegistrar(\\\\n            ens.owner(ADDR_REVERSE_NODE)\\\\n        );\\\\n        reverseRegistrar.claim(claimant);\\\\n    }\\\\n}\\\\n\\",\\"keccak256\\":\\"0x78a28627241535b595f6fff476a1fa7acc90c80684fe7784734920fc8af6fc22\\",\\"license\\":\\"MIT\\"},\\"contracts/utils/BytesUtils.sol\\":{\\"content\\":\\"//SPDX-License-Identifier: MIT\\\\npragma solidity ^0.8.4;\\\\n\\\\nlibrary BytesUtils {\\\\n    error OffsetOutOfBoundsError(uint256 offset, uint256 length);\\\\n\\\\n    /// @dev Returns the keccak-256 hash of a byte range.\\\\n    /// @param self The byte string to hash.\\\\n    /// @param offset The position to start hashing at.\\\\n    /// @param len The number of bytes to hash.\\\\n    /// @return ret The hash of the byte range.\\\\n    function keccak(\\\\n        bytes memory self,\\\\n        uint256 offset,\\\\n        uint256 len\\\\n    ) internal pure returns (bytes32 ret) {\\\\n        require(offset + len <= self.length);\\\\n        assembly {\\\\n            ret := keccak256(add(add(self, 32), offset), len)\\\\n        }\\\\n    }\\\\n\\\\n    /// @dev Returns a positive number if `other` comes lexicographically after\\\\n    ///      `self`, a negative number if it comes before, or zero if the\\\\n    ///      contents of the two bytes are equal.\\\\n    /// @param self The first bytes to compare.\\\\n    /// @param other The second bytes to compare.\\\\n    /// @return The result of the comparison.\\\\n    function compare(\\\\n        bytes memory self,\\\\n        bytes memory other\\\\n    ) internal pure returns (int256) {\\\\n        return compare(self, 0, self.length, other, 0, other.length);\\\\n    }\\\\n\\\\n    /// @dev Returns a positive number if `other` comes lexicographically after\\\\n    ///      `self`, a negative number if it comes before, or zero if the\\\\n    ///      contents of the two bytes are equal. Comparison is done per-rune,\\\\n    ///      on unicode codepoints.\\\\n    /// @param self The first bytes to compare.\\\\n    /// @param offset The offset of self.\\\\n    /// @param len    The length of self.\\\\n    /// @param other The second bytes to compare.\\\\n    /// @param otheroffset The offset of the other string.\\\\n    /// @param otherlen    The length of the other string.\\\\n    /// @return The result of the comparison.\\\\n    function compare(\\\\n        bytes memory self,\\\\n        uint256 offset,\\\\n        uint256 len,\\\\n        bytes memory other,\\\\n        uint256 otheroffset,\\\\n        uint256 otherlen\\\\n    ) internal pure returns (int256) {\\\\n        if (offset + len > self.length) {\\\\n            revert OffsetOutOfBoundsError(offset + len, self.length);\\\\n        }\\\\n        if (otheroffset + otherlen > other.length) {\\\\n            revert OffsetOutOfBoundsError(otheroffset + otherlen, other.length);\\\\n        }\\\\n\\\\n        uint256 shortest = len;\\\\n        if (otherlen < len) shortest = otherlen;\\\\n\\\\n        uint256 selfptr;\\\\n        uint256 otherptr;\\\\n\\\\n        assembly {\\\\n            selfptr := add(self, add(offset, 32))\\\\n            otherptr := add(other, add(otheroffset, 32))\\\\n        }\\\\n        for (uint256 idx = 0; idx < shortest; idx += 32) {\\\\n            uint256 a;\\\\n            uint256 b;\\\\n            assembly {\\\\n                a := mload(selfptr)\\\\n                b := mload(otherptr)\\\\n            }\\\\n            if (a != b) {\\\\n                uint256 rest = shortest - idx;\\\\n                if (rest < 32) {\\\\n                    // shift out the irrelevant bits\\\\n                    rest = (32 - rest) << 3; // bits to drop\\\\n                    a >>= rest;\\\\n                    b >>= rest;\\\\n                }\\\\n                if (a < b) {\\\\n                    return -1;\\\\n                } else if (a > b) {\\\\n                    return 1;\\\\n                }\\\\n            }\\\\n            selfptr += 32;\\\\n            otherptr += 32;\\\\n        }\\\\n\\\\n        return int256(len) - int256(otherlen);\\\\n    }\\\\n\\\\n    /// @dev Returns true if the two byte ranges are equal.\\\\n    /// @param self The first byte range to compare.\\\\n    /// @param offset The offset into the first byte range.\\\\n    /// @param other The second byte range to compare.\\\\n    /// @param otherOffset The offset into the second byte range.\\\\n    /// @param len The number of bytes to compare\\\\n    /// @return True if the byte ranges are equal, false otherwise.\\\\n    function equals(\\\\n        bytes memory self,\\\\n        uint256 offset,\\\\n        bytes memory other,\\\\n        uint256 otherOffset,\\\\n        uint256 len\\\\n    ) internal pure returns (bool) {\\\\n        return keccak(self, offset, len) == keccak(other, otherOffset, len);\\\\n    }\\\\n\\\\n    /// @dev Returns true if the two byte ranges are equal with offsets.\\\\n    /// @param self The first byte range to compare.\\\\n    /// @param offset The offset into the first byte range.\\\\n    /// @param other The second byte range to compare.\\\\n    /// @param otherOffset The offset into the second byte range.\\\\n    /// @return True if the byte ranges are equal, false otherwise.\\\\n    function equals(\\\\n        bytes memory self,\\\\n        uint256 offset,\\\\n        bytes memory other,\\\\n        uint256 otherOffset\\\\n    ) internal pure returns (bool) {\\\\n        return\\\\n            keccak(self, offset, self.length - offset) ==\\\\n            keccak(other, otherOffset, other.length - otherOffset);\\\\n    }\\\\n\\\\n    /// @dev Compares a range of \'self\' to all of \'other\' and returns True iff\\\\n    ///      they are equal.\\\\n    /// @param self The first byte range to compare.\\\\n    /// @param offset The offset into the first byte range.\\\\n    /// @param other The second byte range to compare.\\\\n    /// @return True if the byte ranges are equal, false otherwise.\\\\n    function equals(\\\\n        bytes memory self,\\\\n        uint256 offset,\\\\n        bytes memory other\\\\n    ) internal pure returns (bool) {\\\\n        return\\\\n            self.length == offset + other.length &&\\\\n            equals(self, offset, other, 0, other.length);\\\\n    }\\\\n\\\\n    /// @dev Returns true if the two byte ranges are equal.\\\\n    /// @param self The first byte range to compare.\\\\n    /// @param other The second byte range to compare.\\\\n    /// @return True if the byte ranges are equal, false otherwise.\\\\n    function equals(\\\\n        bytes memory self,\\\\n        bytes memory other\\\\n    ) internal pure returns (bool) {\\\\n        return\\\\n            self.length == other.length &&\\\\n            equals(self, 0, other, 0, self.length);\\\\n    }\\\\n\\\\n    /// @dev Returns the 8-bit number at the specified index of self.\\\\n    /// @param self The byte string.\\\\n    /// @param idx The index into the bytes\\\\n    /// @return ret The specified 8 bits of the string, interpreted as an integer.\\\\n    function readUint8(\\\\n        bytes memory self,\\\\n        uint256 idx\\\\n    ) internal pure returns (uint8 ret) {\\\\n        return uint8(self[idx]);\\\\n    }\\\\n\\\\n    /// @dev Returns the 16-bit number at the specified index of self.\\\\n    /// @param self The byte string.\\\\n    /// @param idx The index into the bytes\\\\n    /// @return ret The specified 16 bits of the string, interpreted as an integer.\\\\n    function readUint16(\\\\n        bytes memory self,\\\\n        uint256 idx\\\\n    ) internal pure returns (uint16 ret) {\\\\n        require(idx + 2 <= self.length);\\\\n        assembly {\\\\n            ret := and(mload(add(add(self, 2), idx)), 0xFFFF)\\\\n        }\\\\n    }\\\\n\\\\n    /// @dev Returns the 32-bit number at the specified index of self.\\\\n    /// @param self The byte string.\\\\n    /// @param idx The index into the bytes\\\\n    /// @return ret The specified 32 bits of the string, interpreted as an integer.\\\\n    function readUint32(\\\\n        bytes memory self,\\\\n        uint256 idx\\\\n    ) internal pure returns (uint32 ret) {\\\\n        require(idx + 4 <= self.length);\\\\n        assembly {\\\\n            ret := and(mload(add(add(self, 4), idx)), 0xFFFFFFFF)\\\\n        }\\\\n    }\\\\n\\\\n    /// @dev Returns the 32 byte value at the specified index of self.\\\\n    /// @param self The byte string.\\\\n    /// @param idx The index into the bytes\\\\n    /// @return ret The specified 32 bytes of the string.\\\\n    function readBytes32(\\\\n        bytes memory self,\\\\n        uint256 idx\\\\n    ) internal pure returns (bytes32 ret) {\\\\n        require(idx + 32 <= self.length);\\\\n        assembly {\\\\n            ret := mload(add(add(self, 32), idx))\\\\n        }\\\\n    }\\\\n\\\\n    /// @dev Returns the 32 byte value at the specified index of self.\\\\n    /// @param self The byte string.\\\\n    /// @param idx The index into the bytes\\\\n    /// @return ret The specified 32 bytes of the string.\\\\n    function readBytes20(\\\\n        bytes memory self,\\\\n        uint256 idx\\\\n    ) internal pure returns (bytes20 ret) {\\\\n        require(idx + 20 <= self.length);\\\\n        assembly {\\\\n            ret := and(\\\\n                mload(add(add(self, 32), idx)),\\\\n                0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000000\\\\n            )\\\\n        }\\\\n    }\\\\n\\\\n    /// @dev Returns the n byte value at the specified index of self.\\\\n    /// @param self The byte string.\\\\n    /// @param idx The index into the bytes.\\\\n    /// @param len The number of bytes.\\\\n    /// @return ret The specified 32 bytes of the string.\\\\n    function readBytesN(\\\\n        bytes memory self,\\\\n        uint256 idx,\\\\n        uint256 len\\\\n    ) internal pure returns (bytes32 ret) {\\\\n        require(len <= 32);\\\\n        require(idx + len <= self.length);\\\\n        assembly {\\\\n            let mask := not(sub(exp(256, sub(32, len)), 1))\\\\n            ret := and(mload(add(add(self, 32), idx)), mask)\\\\n        }\\\\n    }\\\\n\\\\n    function memcpy(uint256 dest, uint256 src, uint256 len) private pure {\\\\n        // Copy word-length chunks while possible\\\\n        for (; len >= 32; len -= 32) {\\\\n            assembly {\\\\n                mstore(dest, mload(src))\\\\n            }\\\\n            dest += 32;\\\\n            src += 32;\\\\n        }\\\\n\\\\n        // Copy remaining bytes\\\\n        unchecked {\\\\n            uint256 mask = (256 ** (32 - len)) - 1;\\\\n            assembly {\\\\n                let srcpart := and(mload(src), not(mask))\\\\n                let destpart := and(mload(dest), mask)\\\\n                mstore(dest, or(destpart, srcpart))\\\\n            }\\\\n        }\\\\n    }\\\\n\\\\n    /// @dev Copies a substring into a new byte string.\\\\n    /// @param self The byte string to copy from.\\\\n    /// @param offset The offset to start copying at.\\\\n    /// @param len The number of bytes to copy.\\\\n    function substring(\\\\n        bytes memory self,\\\\n        uint256 offset,\\\\n        uint256 len\\\\n    ) internal pure returns (bytes memory) {\\\\n        require(offset + len <= self.length);\\\\n\\\\n        bytes memory ret = new bytes(len);\\\\n        uint256 dest;\\\\n        uint256 src;\\\\n\\\\n        assembly {\\\\n            dest := add(ret, 32)\\\\n            src := add(add(self, 32), offset)\\\\n        }\\\\n        memcpy(dest, src, len);\\\\n\\\\n        return ret;\\\\n    }\\\\n\\\\n    // Maps characters from 0x30 to 0x7A to their base32 values.\\\\n    // 0xFF represents invalid characters in that range.\\\\n    bytes constant base32HexTable =\\\\n        hex\\\\\\"00010203040506070809FFFFFFFFFFFFFF0A0B0C0D0E0F101112131415161718191A1B1C1D1E1FFFFFFFFFFFFFFFFFFFFF0A0B0C0D0E0F101112131415161718191A1B1C1D1E1F\\\\\\";\\\\n\\\\n    /// @dev Decodes unpadded base32 data of up to one word in length.\\\\n    /// @param self The data to decode.\\\\n    /// @param off Offset into the string to start at.\\\\n    /// @param len Number of characters to decode.\\\\n    /// @return The decoded data, left aligned.\\\\n    function base32HexDecodeWord(\\\\n        bytes memory self,\\\\n        uint256 off,\\\\n        uint256 len\\\\n    ) internal pure returns (bytes32) {\\\\n        require(len <= 52);\\\\n\\\\n        uint256 ret = 0;\\\\n        uint8 decoded;\\\\n        for (uint256 i = 0; i < len; i++) {\\\\n            bytes1 char = self[off + i];\\\\n            require(char >= 0x30 && char <= 0x7A);\\\\n            decoded = uint8(base32HexTable[uint256(uint8(char)) - 0x30]);\\\\n            require(decoded <= 0x20);\\\\n            if (i == len - 1) {\\\\n                break;\\\\n            }\\\\n            ret = (ret << 5) | decoded;\\\\n        }\\\\n\\\\n        uint256 bitlen = len * 5;\\\\n        if (len % 8 == 0) {\\\\n            // Multiple of 8 characters, no padding\\\\n            ret = (ret << 5) | decoded;\\\\n        } else if (len % 8 == 2) {\\\\n            // Two extra characters - 1 byte\\\\n            ret = (ret << 3) | (decoded >> 2);\\\\n            bitlen -= 2;\\\\n        } else if (len % 8 == 4) {\\\\n            // Four extra characters - 2 bytes\\\\n            ret = (ret << 1) | (decoded >> 4);\\\\n            bitlen -= 4;\\\\n        } else if (len % 8 == 5) {\\\\n            // Five extra characters - 3 bytes\\\\n            ret = (ret << 4) | (decoded >> 1);\\\\n            bitlen -= 1;\\\\n        } else if (len % 8 == 7) {\\\\n            // Seven extra characters - 4 bytes\\\\n            ret = (ret << 2) | (decoded >> 3);\\\\n            bitlen -= 3;\\\\n        } else {\\\\n            revert();\\\\n        }\\\\n\\\\n        return bytes32(ret << (256 - bitlen));\\\\n    }\\\\n\\\\n    /// @dev Finds the first occurrence of the byte `needle` in `self`.\\\\n    /// @param self The string to search\\\\n    /// @param off The offset to start searching at\\\\n    /// @param len The number of bytes to search\\\\n    /// @param needle The byte to search for\\\\n    /// @return The offset of `needle` in `self`, or 2**256-1 if it was not found.\\\\n    function find(\\\\n        bytes memory self,\\\\n        uint256 off,\\\\n        uint256 len,\\\\n        bytes1 needle\\\\n    ) internal pure returns (uint256) {\\\\n        for (uint256 idx = off; idx < off + len; idx++) {\\\\n            if (self[idx] == needle) {\\\\n                return idx;\\\\n            }\\\\n        }\\\\n        return type(uint256).max;\\\\n    }\\\\n}\\\\n\\",\\"keccak256\\":\\"0x91aa93c6538538518436746a72ed262b677c5216209b7a7f32dbf5f87018ba52\\",\\"license\\":\\"MIT\\"},\\"contracts/utils/ENSIP19.sol\\":{\\"content\\":\\"//SPDX-License-Identifier: MIT\\\\npragma solidity ^0.8.0;\\\\n\\\\nimport {HexUtils} from \\\\\\"../utils/HexUtils.sol\\\\\\";\\\\nimport {NameCoder} from \\\\\\"../utils/NameCoder.sol\\\\\\";\\\\n\\\\nuint32 constant CHAIN_ID_ETH = 1;\\\\n\\\\nuint256 constant COIN_TYPE_ETH = 60;\\\\nuint256 constant COIN_TYPE_DEFAULT = 1 << 31; // 0x8000_0000\\\\n\\\\nstring constant SLUG_ETH = \\\\\\"addr\\\\\\"; // <=> COIN_TYPE_ETH\\\\nstring constant SLUG_DEFAULT = \\\\\\"default\\\\\\"; // <=> COIN_TYPE_DEFAULT\\\\nstring constant TLD_REVERSE = \\\\\\"reverse\\\\\\";\\\\n\\\\n/// @dev Library for generating reverse names according to ENSIP-19.\\\\n/// https://docs.ens.domains/ensip/19\\\\nlibrary ENSIP19 {\\\\n    /// @dev The supplied address was `0x`.\\\\n    error EmptyAddress();\\\\n\\\\n    /// @dev Extract Chain ID from `coinType`.\\\\n    /// @param coinType The coin type.\\\\n    /// @return The Chain ID or 0 if non-EVM Chain.\\\\n    function chainFromCoinType(\\\\n        uint256 coinType\\\\n    ) internal pure returns (uint32) {\\\\n        if (coinType == COIN_TYPE_ETH) return CHAIN_ID_ETH;\\\\n        coinType ^= COIN_TYPE_DEFAULT;\\\\n        return uint32(coinType < COIN_TYPE_DEFAULT ? coinType : 0);\\\\n    }\\\\n\\\\n    /// @dev Determine if Coin Type is for an EVM address.\\\\n    /// @param coinType The coin type.\\\\n    /// @return True if coin type represents an EVM address.\\\\n    function isEVMCoinType(uint256 coinType) internal pure returns (bool) {\\\\n        return coinType == COIN_TYPE_DEFAULT || chainFromCoinType(coinType) > 0;\\\\n    }\\\\n\\\\n    /// @dev Generate Reverse Name from Address + Coin Type.\\\\n    ///      Reverts `EmptyAddress` if `addressBytes` is `0x`.\\\\n    /// @param addressBytes The input address.\\\\n    /// @param coinType The coin type.\\\\n    /// @return The ENS reverse name, eg. `1234abcd.addr.reverse`.\\\\n    function reverseName(\\\\n        bytes memory addressBytes,\\\\n        uint256 coinType\\\\n    ) internal pure returns (string memory) {\\\\n        if (addressBytes.length == 0) {\\\\n            revert EmptyAddress();\\\\n        }\\\\n        return\\\\n            string(\\\\n                abi.encodePacked(\\\\n                    HexUtils.bytesToHex(addressBytes),\\\\n                    bytes1(\\\\\\".\\\\\\"),\\\\n                    coinType == COIN_TYPE_ETH\\\\n                        ? SLUG_ETH\\\\n                        : coinType == COIN_TYPE_DEFAULT\\\\n                            ? SLUG_DEFAULT\\\\n                            : HexUtils.unpaddedUintToHex(coinType, true),\\\\n                    bytes1(\\\\\\".\\\\\\"),\\\\n                    TLD_REVERSE\\\\n                )\\\\n            );\\\\n    }\\\\n\\\\n    /// @dev Parse Reverse Name into Address + Coin Type.\\\\n    ///      Matches: /^[0-9a-fA-F]+\\\\\\\\.([0-9a-f]{1,64}|addr|default)\\\\\\\\.reverse$/.\\\\n    ///      Reverts `DNSDecodingFailed`.\\\\n    /// @param name The DNS-encoded name.\\\\n    /// @return addressBytes The address or empty if invalid.\\\\n    /// @return coinType The coin type.\\\\n    function parse(\\\\n        bytes memory name\\\\n    ) internal pure returns (bytes memory addressBytes, uint256 coinType) {\\\\n        (, uint256 offset) = NameCoder.readLabel(name, 0);\\\\n        bool valid;\\\\n        (addressBytes, valid) = HexUtils.hexToBytes(name, 1, offset);\\\\n        if (!valid || addressBytes.length == 0) return (\\\\\\"\\\\\\", 0); // addressBytes not 1+ hex\\\\n        (valid, coinType) = parseNamespace(name, offset);\\\\n        if (!valid) return (\\\\\\"\\\\\\", 0); // invalid namespace\\\\n    }\\\\n\\\\n    /// @dev Parse Reverse Namespace into Coin Type.\\\\n    ///      Matches: /^([0-9a-f]{1,64}|addr|default)\\\\\\\\.reverse$/.\\\\n    ///      Reverts `DNSDecodingFailed`.\\\\n    /// @param name The DNS-encoded name.\\\\n    /// @param offset The offset to begin parsing.\\\\n    /// @return valid True if a valid reverse namespace.\\\\n    /// @return coinType The coin type.\\\\n    function parseNamespace(\\\\n        bytes memory name,\\\\n        uint256 offset\\\\n    ) internal pure returns (bool valid, uint256 coinType) {\\\\n        (bytes32 labelHash, uint256 offsetTLD) = NameCoder.readLabel(\\\\n            name,\\\\n            offset\\\\n        );\\\\n        if (labelHash == keccak256(bytes(SLUG_ETH))) {\\\\n            coinType = COIN_TYPE_ETH;\\\\n        } else if (labelHash == keccak256(bytes(SLUG_DEFAULT))) {\\\\n            coinType = COIN_TYPE_DEFAULT;\\\\n        } else if (labelHash == bytes32(0)) {\\\\n            return (false, 0); // no slug\\\\n        } else {\\\\n            (bytes32 word, bool validHex) = HexUtils.hexStringToBytes32(\\\\n                name,\\\\n                1 + offset,\\\\n                offsetTLD\\\\n            );\\\\n            if (!validHex) return (false, 0); // invalid coinType or too long\\\\n            coinType = uint256(word);\\\\n        }\\\\n        (labelHash, offset) = NameCoder.readLabel(name, offsetTLD);\\\\n        if (labelHash != keccak256(bytes(TLD_REVERSE))) return (false, 0); // invalid tld\\\\n        (labelHash, ) = NameCoder.readLabel(name, offset);\\\\n        if (labelHash != bytes32(0)) return (false, 0); // not tld\\\\n        valid = true;\\\\n    }\\\\n}\\\\n\\",\\"keccak256\\":\\"0x417e62b642c6a6c2efbb4601649b2fa1a9c46dc44c00869f687c074bfbe45945\\",\\"license\\":\\"MIT\\"},\\"contracts/utils/HexUtils.sol\\":{\\"content\\":\\"// SPDX-License-Identifier: MIT\\\\npragma solidity ^0.8.4;\\\\n\\\\nlibrary HexUtils {\\\\n    /// @dev Convert `hexString[pos:end]` to `bytes32`.\\\\n    ///      Accepts 0-64 hex-chars.\\\\n    ///      Uses right alignment: `1` &rarr; `0000000000000000000000000000000000000000000000000000000000000001`.\\\\n    /// @param hexString The string to parse.\\\\n    /// @param pos The index to start parsing.\\\\n    /// @param end The (exclusive) index to stop parsing.\\\\n    /// @return word The parsed bytes32.\\\\n    /// @return valid True if the parse was successful.\\\\n    function hexStringToBytes32(\\\\n        bytes memory hexString,\\\\n        uint256 pos,\\\\n        uint256 end\\\\n    ) internal pure returns (bytes32 word, bool valid) {\\\\n        uint256 nibbles = end - pos;\\\\n        if (nibbles > 64 || end > hexString.length) {\\\\n            return (bytes32(0), false); // too large or out of bounds\\\\n        }\\\\n        uint256 src;\\\\n        assembly {\\\\n            src := add(add(hexString, 32), pos)\\\\n        }\\\\n        valid = unsafeBytes(src, 0, nibbles);\\\\n        assembly {\\\\n            let pad := sub(32, shr(1, add(nibbles, 1))) // number of bytes\\\\n            word := shr(shl(3, pad), mload(0)) // right align\\\\n        }\\\\n    }\\\\n\\\\n    /// @dev Convert `hexString[pos:end]` to `address`.\\\\n    ///      Accepts exactly 40 hex-chars.\\\\n    /// @param hexString The string to parse.\\\\n    /// @param pos The index to start parsing.\\\\n    /// @param end The (exclusive) index to stop parsing.\\\\n    /// @return addr The parsed address.\\\\n    /// @return valid True if the parse was successful.\\\\n    function hexToAddress(\\\\n        bytes memory hexString,\\\\n        uint256 pos,\\\\n        uint256 end\\\\n    ) internal pure returns (address addr, bool valid) {\\\\n        if (end - pos != 40) return (address(0), false); // wrong length\\\\n        bytes32 word;\\\\n        (word, valid) = hexStringToBytes32(hexString, pos, end);\\\\n        addr = address(uint160(uint256(word)));\\\\n    }\\\\n\\\\n    /// @dev Convert `hexString[pos:end]` to `bytes`.\\\\n    ///      Accepts 0+ hex-chars.\\\\n    /// @param pos The index to start parsing.\\\\n    /// @param end The (exclusive) index to stop parsing.\\\\n    /// @return v The parsed bytes.\\\\n    /// @return valid True if the parse was successful.\\\\n    function hexToBytes(\\\\n        bytes memory hexString,\\\\n        uint256 pos,\\\\n        uint256 end\\\\n    ) internal pure returns (bytes memory v, bool valid) {\\\\n        uint256 nibbles = end - pos;\\\\n        v = new bytes((1 + nibbles) >> 1); // round up\\\\n        uint256 src;\\\\n        uint256 dst;\\\\n        assembly {\\\\n            src := add(add(hexString, 32), pos)\\\\n            dst := add(v, 32)\\\\n        }\\\\n        valid = unsafeBytes(src, dst, nibbles);\\\\n    }\\\\n\\\\n    /// @dev Convert arbitrary hex-encoded memory to bytes.\\\\n    ///      If nibbles is odd, leading hex-char is padded, eg. `F` &rarr; `0x0F`.\\\\n    ///      Matches: /^[0-9a-f]*$/i.\\\\n    /// @param src The memory offset of first hex-char of input.\\\\n    /// @param dst The memory offset of first byte of output (cannot alias `src`).\\\\n    /// @param nibbles The number of hex-chars to convert.\\\\n    /// @return valid True if all characters were hex.\\\\n    function unsafeBytes(\\\\n        uint256 src,\\\\n        uint256 dst,\\\\n        uint256 nibbles\\\\n    ) internal pure returns (bool valid) {\\\\n        assembly {\\\\n            function getHex(c, i) -> ascii {\\\\n                c := byte(i, c)\\\\n                // chars 48-57: 0-9\\\\n                if and(gt(c, 47), lt(c, 58)) {\\\\n                    ascii := sub(c, 48)\\\\n                    leave\\\\n                }\\\\n                // chars 65-70: A-F\\\\n                if and(gt(c, 64), lt(c, 71)) {\\\\n                    ascii := add(sub(c, 65), 10)\\\\n                    leave\\\\n                }\\\\n                // chars 97-102: a-f\\\\n                if and(gt(c, 96), lt(c, 103)) {\\\\n                    ascii := add(sub(c, 97), 10)\\\\n                    leave\\\\n                }\\\\n                // invalid char\\\\n                ascii := 0x100\\\\n            }\\\\n            valid := true\\\\n            let end := add(src, nibbles)\\\\n            if and(nibbles, 1) {\\\\n                let b := getHex(mload(src), 0) // \\\\\\"f\\\\\\" -> 15\\\\n                mstore8(dst, b) // write ascii byte\\\\n                src := add(src, 1) // update pointers\\\\n                dst := add(dst, 1)\\\\n                if gt(b, 255) {\\\\n                    valid := false\\\\n                    src := end // terminate loop\\\\n                }\\\\n            }\\\\n            for {} lt(src, end) {\\\\n                src := add(src, 2) // 2 nibbles\\\\n                dst := add(dst, 1) // per byte\\\\n            } {\\\\n                let word := mload(src) // read word (left aligned)\\\\n                let b := or(shl(4, getHex(word, 0)), getHex(word, 1)) // \\\\\\"ff\\\\\\" -> 255\\\\n                if gt(b, 255) {\\\\n                    valid := false\\\\n                    break\\\\n                }\\\\n                mstore8(dst, b) // write ascii byte\\\\n            }\\\\n        }\\\\n    }\\\\n\\\\n    /// @dev Format `address` as a hex string.\\\\n    /// @param addr The address to format.\\\\n    /// @return hexString The corresponding hex string w/o a 0x-prefix.\\\\n    function addressToHex(\\\\n        address addr\\\\n    ) internal pure returns (string memory hexString) {\\\\n        // return bytesToHex(abi.encodePacked(addr));\\\\n        hexString = new string(40);\\\\n        uint256 dst;\\\\n        assembly {\\\\n            mstore(0, addr)\\\\n            dst := add(hexString, 32)\\\\n        }\\\\n        unsafeHex(12, dst, 40);\\\\n    }\\\\n\\\\n    /// @dev Format `uint256` as a variable-length hex string without zero padding.\\\\n    /// * unpaddedUintToHex(0, true)  = \\\\\\"0\\\\\\"\\\\n    /// * unpaddedUintToHex(1, true)  = \\\\\\"1\\\\\\"\\\\n    /// * unpaddedUintToHex(0, false) = \\\\\\"00\\\\\\"\\\\n    /// * unpaddedUintToHex(1, false) = \\\\\\"01\\\\\\"\\\\n    /// @param value The number to format.\\\\n    /// @param dropZeroNibble If true, the leading byte will use one nibble if less than 16.\\\\n    /// @return hexString The corresponding hex string w/o an 0x-prefix.\\\\n    function unpaddedUintToHex(\\\\n        uint256 value,\\\\n        bool dropZeroNibble\\\\n    ) internal pure returns (string memory hexString) {\\\\n        uint256 temp = value;\\\\n        uint256 shift;\\\\n        for (uint256 b = 128; b >= 8; b >>= 1) {\\\\n            if (temp < (1 << b)) {\\\\n                shift += b; // number of zero upper bits\\\\n            } else {\\\\n                temp >>= b; // shift away lower half\\\\n            }\\\\n        }\\\\n        if (dropZeroNibble && temp < 16) shift += 4;\\\\n        uint256 nibbles = 64 - (shift >> 2);\\\\n        hexString = new string(nibbles);\\\\n        uint256 dst;\\\\n        assembly {\\\\n            mstore(0, shl(shift, value)) // left-align\\\\n            dst := add(hexString, 32)\\\\n        }\\\\n        unsafeHex(0, dst, nibbles);\\\\n    }\\\\n\\\\n    /// @dev Format `bytes` as a hex string.\\\\n    /// @param v The bytes to format.\\\\n    /// @return hexString The corresponding hex string w/o a 0x-prefix.\\\\n    function bytesToHex(\\\\n        bytes memory v\\\\n    ) internal pure returns (string memory hexString) {\\\\n        uint256 nibbles = v.length << 1;\\\\n        hexString = new string(nibbles);\\\\n        uint256 src;\\\\n        uint256 dst;\\\\n        assembly {\\\\n            src := add(v, 32)\\\\n            dst := add(hexString, 32)\\\\n        }\\\\n        unsafeHex(src, dst, nibbles);\\\\n    }\\\\n\\\\n    /// @dev Converts arbitrary memory to a hex string.\\\\n    /// @param src The memory offset of first nibble of input.\\\\n    /// @param dst The memory offset of first hex-char of output (can alias `src`).\\\\n    /// @param nibbles The number of nibbles to convert and the byte-length of the output.\\\\n    function unsafeHex(\\\\n        uint256 src,\\\\n        uint256 dst,\\\\n        uint256 nibbles\\\\n    ) internal pure {\\\\n        unchecked {\\\\n            for (uint256 end = dst + nibbles; dst < end; src += 32) {\\\\n                uint256 word;\\\\n                assembly {\\\\n                    word := mload(src)\\\\n                }\\\\n                for (uint256 shift = 256; dst < end && shift > 0; dst++) {\\\\n                    uint256 b = (word >> (shift -= 4)) & 15; // each nibble\\\\n                    b = b < 10 ? b + 0x30 : b + 0x57; // (\\\\\\"a\\\\\\" - 10) => 0x57\\\\n                    assembly {\\\\n                        mstore8(dst, b)\\\\n                    }\\\\n                }\\\\n            }\\\\n        }\\\\n    }\\\\n}\\\\n\\",\\"keccak256\\":\\"0x48e51ac631fabaa3e659cdc9f3c5743fa76e999213d65e931c486f9375dd2d4f\\",\\"license\\":\\"MIT\\"},\\"contracts/utils/NameCoder.sol\\":{\\"content\\":\\"// SPDX-License-Identifier: MIT\\\\npragma solidity ^0.8.0;\\\\n\\\\nimport {HexUtils} from \\\\\\"../utils/HexUtils.sol\\\\\\";\\\\n\\\\n/// @dev Library for encoding/decoding names.\\\\n///\\\\n/// An ENS name is stop-separated labels, eg. \\\\\\"aaa.bb.c\\\\\\".\\\\n///\\\\n/// A DNS-encoded name is composed of byte length-prefixed labels with a terminator byte.\\\\n/// eg. \\\\\\"\\\\\\\\x03aaa\\\\\\\\x02bb\\\\\\\\x01c\\\\\\\\x00\\\\\\".\\\\n/// - maximum label length is 255 bytes.\\\\n/// - length = 0 is reserved for the terminator (root).\\\\n///\\\\n/// To encode a label larger than 255 bytes, use a hashed label.\\\\n/// A label of any length can be converted to a hashed label.\\\\n///\\\\n/// A hashed label is encoded as \\\\\\"[\\\\\\" + toHex(keccak256(label)) + \\\\\\"]\\\\\\".\\\\n/// eg. [af2caa1c2ca1d027f1ac823b529d0a67cd144264b2789fa2ea4d63a67c7103cc] = \\\\\\"vitalik\\\\\\".\\\\n/// - always 66 bytes.\\\\n/// - matches: `/^\\\\\\\\[[0-9a-f]{64}\\\\\\\\]$/`.\\\\n///\\\\n/// w/o hashed labels: `dns.length == 2 + ens.length` and the mapping is injective.\\\\n///  w/ hashed labels: `dns.length == 2 + ens.split(\'.\').map(x => x.utf8Length).sum(n => n > 255 ? 66 : n)`.\\\\nlibrary NameCoder {\\\\n    /// @dev The DNS-encoded name is malformed.\\\\n    error DNSDecodingFailed(bytes dns);\\\\n\\\\n    /// @dev A label of the ENS name has an invalid size.\\\\n    error DNSEncodingFailed(string ens);\\\\n\\\\n    /// @dev Same as `BytesUtils.readLabel()` but supports hashed labels.\\\\n    ///      Only the last labelHash is zero.\\\\n    ///      Disallows hashed label of zero (eg. `[0..0]`) to prevent confusion with terminator.\\\\n    ///      Reverts `DNSDecodingFailed`.\\\\n    /// @param name The DNS-encoded name.\\\\n    /// @param idx The offset into `name` to start reading.\\\\n    /// @return labelHash The resulting labelhash.\\\\n    /// @return newIdx The offset into `name` of the next label.\\\\n    function readLabel(\\\\n        bytes memory name,\\\\n        uint256 idx\\\\n    ) internal pure returns (bytes32 labelHash, uint256 newIdx) {\\\\n        if (idx >= name.length) revert DNSDecodingFailed(name); // \\\\\\"readLabel: expected length\\\\\\"\\\\n        uint256 len = uint256(uint8(name[idx++]));\\\\n        newIdx = idx + len;\\\\n        if (newIdx > name.length) revert DNSDecodingFailed(name); // \\\\\\"readLabel: expected label\\\\\\"\\\\n        if (len == 66 && name[idx] == \\\\\\"[\\\\\\" && name[newIdx - 1] == \\\\\\"]\\\\\\") {\\\\n            bool valid;\\\\n            (labelHash, valid) = HexUtils.hexStringToBytes32(\\\\n                name,\\\\n                idx + 1,\\\\n                newIdx - 1\\\\n            ); // will not revert\\\\n            if (!valid || labelHash == bytes32(0)) {\\\\n                revert DNSDecodingFailed(name); // \\\\\\"readLabel: malformed\\\\\\" or null literal\\\\n            }\\\\n        } else if (len > 0) {\\\\n            assembly {\\\\n                labelHash := keccak256(add(add(name, idx), 32), len)\\\\n            }\\\\n        }\\\\n    }\\\\n\\\\n    /// @dev Same as `BytesUtils.namehash()` but supports hashed labels.\\\\n    ///      Reverts `DNSDecodingFailed`.\\\\n    /// @param name The DNS-encoded name.\\\\n    /// @param idx The offset into name start hashing.\\\\n    /// @return hash The resulting namehash.\\\\n    function namehash(\\\\n        bytes memory name,\\\\n        uint256 idx\\\\n    ) internal pure returns (bytes32 hash) {\\\\n        (hash, idx) = readLabel(name, idx);\\\\n        if (hash == bytes32(0)) {\\\\n            if (idx != name.length) revert DNSDecodingFailed(name); // \\\\\\"namehash: Junk at end of name\\\\\\"\\\\n        } else {\\\\n            bytes32 parent = namehash(name, idx);\\\\n            assembly {\\\\n                mstore(0, parent)\\\\n                mstore(32, hash)\\\\n                hash := keccak256(0, 64)\\\\n            }\\\\n        }\\\\n    }\\\\n\\\\n    /// @dev Convert DNS-encoded name to ENS name.\\\\n    ///      Reverts `DNSDecodingFailed`.\\\\n    /// @param dns The DNS-encoded name to convert, eg. `\\\\\\\\x03aaa\\\\\\\\x02bb\\\\\\\\x01c\\\\\\\\x00`.\\\\n    /// @return ens The equivalent ENS name, eg. `aaa.bb.c`.\\\\n    function decode(\\\\n        bytes memory dns\\\\n    ) internal pure returns (string memory ens) {\\\\n        unchecked {\\\\n            uint256 n = dns.length;\\\\n            if (n == 1 && dns[0] == 0) return \\\\\\"\\\\\\"; // only valid answer is root\\\\n            if (n < 3) revert DNSDecodingFailed(dns);\\\\n            bytes memory v = new bytes(n - 2); // always 2-shorter\\\\n            uint256 src;\\\\n            uint256 dst;\\\\n            while (src < n) {\\\\n                uint8 len = uint8(dns[src++]);\\\\n                if (len == 0) break;\\\\n                uint256 end = src + len;\\\\n                if (end > dns.length) revert DNSDecodingFailed(dns); // overflow\\\\n                if (dst > 0) v[dst++] = \\\\\\".\\\\\\"; // skip first stop\\\\n                while (src < end) {\\\\n                    bytes1 x = dns[src++]; // read byte\\\\n                    if (x == \\\\\\".\\\\\\") revert DNSDecodingFailed(dns); // malicious label\\\\n                    v[dst++] = x; // write byte\\\\n                }\\\\n            }\\\\n            if (src != dns.length) revert DNSDecodingFailed(dns); // junk at end\\\\n            return string(v);\\\\n        }\\\\n    }\\\\n\\\\n    /// @dev Convert ENS name to DNS-encoded name.\\\\n    ///      Hashes labels longer than 255 bytes.\\\\n    ///      Reverts `DNSEncodingFailed`.\\\\n    /// @param ens The ENS name to convert, eg. `aaa.bb.c`.\\\\n    /// @return dns The corresponding DNS-encoded name, eg. `\\\\\\\\x03aaa\\\\\\\\x02bb\\\\\\\\x01c\\\\\\\\x00`.\\\\n    function encode(\\\\n        string memory ens\\\\n    ) internal pure returns (bytes memory dns) {\\\\n        unchecked {\\\\n            uint256 n = bytes(ens).length;\\\\n            if (n == 0) return hex\\\\\\"00\\\\\\"; // root\\\\n            dns = new bytes(n + 2);\\\\n            uint256 start;\\\\n            assembly {\\\\n                start := add(dns, 32) // first byte of output\\\\n            }\\\\n            uint256 end = start; // remember position to write length\\\\n            for (uint256 i; i < n; i++) {\\\\n                bytes1 x = bytes(ens)[i]; // read byte\\\\n                if (x == \\\\\\".\\\\\\") {\\\\n                    start = _createHashedLabel(start, end);\\\\n                    if (start == 0) revert DNSEncodingFailed(ens);\\\\n                    end = start; // jump to next position\\\\n                } else {\\\\n                    assembly {\\\\n                        end := add(end, 1) // increase length\\\\n                        mstore(end, x) // write byte\\\\n                    }\\\\n                }\\\\n            }\\\\n            start = _createHashedLabel(start, end);\\\\n            if (start == 0) revert DNSEncodingFailed(ens);\\\\n            assembly {\\\\n                mstore8(start, 0) // terminal byte\\\\n                mstore(dns, sub(start, add(dns, 31))) // truncate length\\\\n            }\\\\n        }\\\\n    }\\\\n\\\\n    /// @dev Write the label length.\\\\n    ///      If longer than 255, writes a hashed label instead.\\\\n    /// @param start The memory offset of the length-prefixed label.\\\\n    /// @param end The memory offset at the end of the label.\\\\n    /// @return next The memory offset for the next label.\\\\n    ///              Returns 0 if label is empty (handled by caller).\\\\n    function _createHashedLabel(\\\\n        uint256 start,\\\\n        uint256 end\\\\n    ) internal pure returns (uint256 next) {\\\\n        uint256 size = end - start; // length of label\\\\n        if (size > 255) {\\\\n            assembly {\\\\n                mstore(0, keccak256(add(start, 1), size)) // compute hash of label\\\\n            }\\\\n            HexUtils.unsafeHex(0, start + 2, 64); // override label with hex(hash)\\\\n            assembly {\\\\n                mstore8(add(start, 1), 0x5B) // \\\\\\"[\\\\\\"\\\\n                mstore8(add(start, 66), 0x5D) // \\\\\\"]\\\\\\"\\\\n            }\\\\n            size = 66;\\\\n        }\\\\n        if (size > 0) {\\\\n            assembly {\\\\n                mstore8(start, size) // update length\\\\n            }\\\\n            next = start + 1 + size; // advance\\\\n        }\\\\n    }\\\\n}\\\\n\\",\\"keccak256\\":\\"0x8fd7af9cec38612e8041c13d4c3eb9c11fccdcbed4fac40020a4b84672f0aa85\\",\\"license\\":\\"MIT\\"},\\"contracts/wrapper/IMetadataService.sol\\":{\\"content\\":\\"//SPDX-License-Identifier: MIT\\\\npragma solidity ~0.8.17;\\\\n\\\\ninterface IMetadataService {\\\\n    function uri(uint256) external view returns (string memory);\\\\n}\\\\n\\",\\"keccak256\\":\\"0xb3f1cf6df01ed7b15e5f2318f6823afbdb586ca38c2124c67955c645647ae9a2\\",\\"license\\":\\"MIT\\"},\\"contracts/wrapper/INameWrapper.sol\\":{\\"content\\":\\"//SPDX-License-Identifier: MIT\\\\npragma solidity ~0.8.17;\\\\n\\\\nimport \\\\\\"../registry/ENS.sol\\\\\\";\\\\nimport \\\\\\"../ethregistrar/IBaseRegistrar.sol\\\\\\";\\\\nimport \\\\\\"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\\\\\\";\\\\nimport \\\\\\"./IMetadataService.sol\\\\\\";\\\\nimport \\\\\\"./INameWrapperUpgrade.sol\\\\\\";\\\\n\\\\nuint32 constant CANNOT_UNWRAP = 1;\\\\nuint32 constant CANNOT_BURN_FUSES = 2;\\\\nuint32 constant CANNOT_TRANSFER = 4;\\\\nuint32 constant CANNOT_SET_RESOLVER = 8;\\\\nuint32 constant CANNOT_SET_TTL = 16;\\\\nuint32 constant CANNOT_CREATE_SUBDOMAIN = 32;\\\\nuint32 constant CANNOT_APPROVE = 64;\\\\n//uint16 reserved for parent controlled fuses from bit 17 to bit 32\\\\nuint32 constant PARENT_CANNOT_CONTROL = 1 << 16;\\\\nuint32 constant IS_DOT_ETH = 1 << 17;\\\\nuint32 constant CAN_EXTEND_EXPIRY = 1 << 18;\\\\nuint32 constant CAN_DO_EVERYTHING = 0;\\\\nuint32 constant PARENT_CONTROLLED_FUSES = 0xFFFF0000;\\\\n// all fuses apart from IS_DOT_ETH\\\\nuint32 constant USER_SETTABLE_FUSES = 0xFFFDFFFF;\\\\n\\\\ninterface INameWrapper is IERC1155 {\\\\n    event NameWrapped(\\\\n        bytes32 indexed node,\\\\n        bytes name,\\\\n        address owner,\\\\n        uint32 fuses,\\\\n        uint64 expiry\\\\n    );\\\\n\\\\n    event NameUnwrapped(bytes32 indexed node, address owner);\\\\n\\\\n    event FusesSet(bytes32 indexed node, uint32 fuses);\\\\n    event ExpiryExtended(bytes32 indexed node, uint64 expiry);\\\\n\\\\n    function ens() external view returns (ENS);\\\\n\\\\n    function registrar() external view returns (IBaseRegistrar);\\\\n\\\\n    function metadataService() external view returns (IMetadataService);\\\\n\\\\n    function names(bytes32) external view returns (bytes memory);\\\\n\\\\n    function name() external view returns (string memory);\\\\n\\\\n    function upgradeContract() external view returns (INameWrapperUpgrade);\\\\n\\\\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\\\\n\\\\n    function wrap(\\\\n        bytes calldata name,\\\\n        address wrappedOwner,\\\\n        address resolver\\\\n    ) external;\\\\n\\\\n    function wrapETH2LD(\\\\n        string calldata label,\\\\n        address wrappedOwner,\\\\n        uint16 ownerControlledFuses,\\\\n        address resolver\\\\n    ) external returns (uint64 expires);\\\\n\\\\n    function registerAndWrapETH2LD(\\\\n        string calldata label,\\\\n        address wrappedOwner,\\\\n        uint256 duration,\\\\n        address resolver,\\\\n        uint16 ownerControlledFuses\\\\n    ) external returns (uint256 registrarExpiry);\\\\n\\\\n    function renew(\\\\n        uint256 labelHash,\\\\n        uint256 duration\\\\n    ) external returns (uint256 expires);\\\\n\\\\n    function unwrap(bytes32 node, bytes32 label, address owner) external;\\\\n\\\\n    function unwrapETH2LD(\\\\n        bytes32 label,\\\\n        address newRegistrant,\\\\n        address newController\\\\n    ) external;\\\\n\\\\n    function upgrade(bytes calldata name, bytes calldata extraData) external;\\\\n\\\\n    function setFuses(\\\\n        bytes32 node,\\\\n        uint16 ownerControlledFuses\\\\n    ) external returns (uint32 newFuses);\\\\n\\\\n    function setChildFuses(\\\\n        bytes32 parentNode,\\\\n        bytes32 labelhash,\\\\n        uint32 fuses,\\\\n        uint64 expiry\\\\n    ) external;\\\\n\\\\n    function setSubnodeRecord(\\\\n        bytes32 node,\\\\n        string calldata label,\\\\n        address owner,\\\\n        address resolver,\\\\n        uint64 ttl,\\\\n        uint32 fuses,\\\\n        uint64 expiry\\\\n    ) external returns (bytes32);\\\\n\\\\n    function setRecord(\\\\n        bytes32 node,\\\\n        address owner,\\\\n        address resolver,\\\\n        uint64 ttl\\\\n    ) external;\\\\n\\\\n    function setSubnodeOwner(\\\\n        bytes32 node,\\\\n        string calldata label,\\\\n        address newOwner,\\\\n        uint32 fuses,\\\\n        uint64 expiry\\\\n    ) external returns (bytes32);\\\\n\\\\n    function extendExpiry(\\\\n        bytes32 node,\\\\n        bytes32 labelhash,\\\\n        uint64 expiry\\\\n    ) external returns (uint64);\\\\n\\\\n    function canModifyName(\\\\n        bytes32 node,\\\\n        address addr\\\\n    ) external view returns (bool);\\\\n\\\\n    function setResolver(bytes32 node, address resolver) external;\\\\n\\\\n    function setTTL(bytes32 node, uint64 ttl) external;\\\\n\\\\n    function ownerOf(uint256 id) external view returns (address owner);\\\\n\\\\n    function approve(address to, uint256 tokenId) external;\\\\n\\\\n    function getApproved(uint256 tokenId) external view returns (address);\\\\n\\\\n    function getData(\\\\n        uint256 id\\\\n    ) external view returns (address, uint32, uint64);\\\\n\\\\n    function setMetadataService(IMetadataService _metadataService) external;\\\\n\\\\n    function uri(uint256 tokenId) external view returns (string memory);\\\\n\\\\n    function setUpgradeContract(INameWrapperUpgrade _upgradeAddress) external;\\\\n\\\\n    function allFusesBurned(\\\\n        bytes32 node,\\\\n        uint32 fuseMask\\\\n    ) external view returns (bool);\\\\n\\\\n    function isWrapped(bytes32) external view returns (bool);\\\\n\\\\n    function isWrapped(bytes32, bytes32) external view returns (bool);\\\\n}\\\\n\\",\\"keccak256\\":\\"0x70310eb67146d7290731c31841399640ac3b6a949eadc6598bc150123d185c57\\",\\"license\\":\\"MIT\\"},\\"contracts/wrapper/INameWrapperUpgrade.sol\\":{\\"content\\":\\"//SPDX-License-Identifier: MIT\\\\npragma solidity ~0.8.17;\\\\n\\\\ninterface INameWrapperUpgrade {\\\\n    function wrapFromUpgrade(\\\\n        bytes calldata name,\\\\n        address wrappedOwner,\\\\n        uint32 fuses,\\\\n        uint64 expiry,\\\\n        address approved,\\\\n        bytes calldata extraData\\\\n    ) external;\\\\n}\\\\n\\",\\"keccak256\\":\\"0x42e0cec6cd9d1a62d51d45b678f69d3e4ad5555e659b197e41257b308346bb8a\\",\\"license\\":\\"MIT\\"}},\\"version\\":1}","bytecode":"0x61010060405234801561001157600080fd5b50604051613af9380380613af98339810160408190526100309161016d565b6040516302571be360e01b81527f91d1777781884d03a6757a803996e38de2a42967fb37eeaca72729271025a9e26004820152849033906000906001600160a01b038416906302571be390602401602060405180830381865afa15801561009b573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906100bf91906101cc565b604051630f41a04d60e11b81526001600160a01b03848116600483015291925090821690631e83409a906024016020604051808303816000875af115801561010b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061012f91906101f0565b5050506001600160a01b039485166080525091831660a052821660c0521660e052610209565b6001600160a01b038116811461016a57600080fd5b50565b6000806000806080858703121561018357600080fd5b845161018e81610155565b602086015190945061019f81610155565b60408601519093506101b081610155565b60608601519092506101c181610155565b939692955090935050565b6000602082840312156101de57600080fd5b81516101e981610155565b9392505050565b60006020828403121561020257600080fd5b5051919050565b60805160a05160c05160e0516138b06102496000396000611bb101526000611b72015260008181611c960152611d1601526000611c1201526138b06000f3fe608060405234801561001057600080fd5b50600436106101e55760003560e01c8063773722131161010f578063c8690233116100a2578063e32954eb11610071578063e32954eb1461053c578063e59d895d1461054f578063e985e9c514610562578063f1cb7e06146105ab57600080fd5b8063c86902331461047a578063ce3decdc146104d3578063d5fa2b00146104e6578063d700ff33146104f957600080fd5b8063a8fa5682116100de578063a8fa5682146103e3578063a9784b3e146103f6578063ac9650d814610447578063bc1c58d11461046757600080fd5b806377372213146103975780638b95dd71146103aa578063a22cb465146103bd578063a4b91a01146103d057600080fd5b806332f111d71161018757806359d1d43c1161015657806359d1d43c1461033e5780635c98042b1461035e578063623195b014610371578063691f34311461038457600080fd5b806332f111d7146102b95780633603d758146102cc5780633b3b57de146102df5780634cbf6ba4146102f257600080fd5b8063124a319c116101c3578063124a319c1461023a5780632203ab561461027257806329cd62ea14610293578063304e6ade146102a657600080fd5b806301ffc9a7146101ea5780630af179d71461021257806310f13a8c14610227575b600080fd5b6101fd6101f8366004612b16565b6105be565b60405190151581526020015b60405180910390f35b610225610220366004612b73565b6105cf565b005b610225610235366004612bbf565b6107d9565b61024d610248366004612c3e565b6108a6565b60405173ffffffffffffffffffffffffffffffffffffffff9091168152602001610209565b610285610280366004612c6a565b610c3d565b604051610209929190612cfa565b6102256102a1366004612d13565b610d82565b6102256102b4366004612b73565b610e1d565b6101fd6102c7366004612c6a565b610e99565b6102256102da366004612d3f565b610ee5565b61024d6102ed366004612d3f565b610f88565b6101fd610300366004612c6a565b6000828152602081815260408083205467ffffffffffffffff1683526006825280832094835293815283822092825291909152205461ffff16151590565b61035161034c366004612b73565b610fa7565b6040516102099190612d58565b61035161036c366004612d3f565b611087565b61022561037f366004612d6b565b611146565b610351610392366004612d3f565b6111e3565b6102256103a5366004612b73565b61121d565b6102256103b8366004612ded565b611299565b6102256103cb366004612f28565b6113d8565b6102256103de366004612f54565b611514565b6103516103f1366004612f92565b611633565b6101fd610404366004612fd2565b73ffffffffffffffffffffffffffffffffffffffff9283166000908152600c60209081526040808320948352938152838220929094168152925290205460ff1690565b61045a61045536600461304e565b611681565b6040516102099190613090565b610351610475366004612d3f565b611696565b6104be610488366004612d3f565b6000818152602081815260408083205467ffffffffffffffff168352600982528083209383529290522080546001909101549091565b60408051928352602083019190915201610209565b6102256104e1366004612b73565b6116d0565b6102256104f4366004613113565b611813565b610523610507366004612d3f565b60006020819052908152604090205467ffffffffffffffff1681565b60405167ffffffffffffffff9091168152602001610209565b61045a61054a366004613143565b61187a565b61022561055d366004613182565b61188f565b6101fd6105703660046131b7565b73ffffffffffffffffffffffffffffffffffffffff9182166000908152600b6020908152604080832093909416825291909152205460ff1690565b6103516105b9366004612c6a565b611973565b60006105c982611b02565b92915050565b826105d981611b58565b6105e257600080fd5b600084815260208181526040808320548151601f870184900484028101840190925285825283926060928392859267ffffffffffffffff9091169183916106489183918d908d90819084018382808284376000920191909152509293925050611e349050565b90505b80515160208201511015610772578661ffff166000036106b0578060400151965061067581611e95565b94508460405160200161068891906131e5565b6040516020818303038152906040528051906020012092506106a981611eb6565b9350610764565b60006106bb82611e95565b9050816040015161ffff168861ffff161415806106df57506106dd8682611ed2565b155b156107625761073b8c878a8e8e8080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250505060208801518d9150610732908290613230565b8b51158a611ef0565b81604001519750816020015196508095508580519060200120935061075f82611eb6565b94505b505b61076d8161215d565b61064b565b508351156107cd576107cd8a85888c8c8080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920191909152508c92506107c491508290508f613230565b89511588611ef0565b50505050505050505050565b846107e381611b58565b6107ec57600080fd5b6000868152602081815260408083205467ffffffffffffffff168352600a82528083208984529091529081902090518491849161082c9089908990613243565b908152602001604051809103902091826108479291906132ed565b508484604051610858929190613243565b6040518091039020867f448bc014f1536726cf8d54ff3d6481ed3cbc683c2591ca204274009afa09b1a1878787876040516108969493929190613450565b60405180910390a3505050505050565b6000828152602081815260408083205467ffffffffffffffff1683526007825280832085845282528083207fffffffff000000000000000000000000000000000000000000000000000000008516845290915281205473ffffffffffffffffffffffffffffffffffffffff16801561091f5790506105c9565b600061092a85610f88565b905073ffffffffffffffffffffffffffffffffffffffff8116610952576000925050506105c9565b6040517f01ffc9a7000000000000000000000000000000000000000000000000000000006024820152600090819073ffffffffffffffffffffffffffffffffffffffff841690604401604080517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08184030181529181526020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167f01ffc9a70000000000000000000000000000000000000000000000000000000017905251610a1c91906131e5565b600060405180830381855afa9150503d8060008114610a57576040519150601f19603f3d011682016040523d82523d6000602084013e610a5c565b606091505b5091509150811580610a6f575060208151105b80610ab1575080601f81518110610a8857610a88613482565b01602001517fff0000000000000000000000000000000000000000000000000000000000000016155b15610ac35760009450505050506105c9565b6040517fffffffff000000000000000000000000000000000000000000000000000000008716602482015273ffffffffffffffffffffffffffffffffffffffff841690604401604080517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08184030181529181526020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167f01ffc9a70000000000000000000000000000000000000000000000000000000017905251610b8a91906131e5565b600060405180830381855afa9150503d8060008114610bc5576040519150601f19603f3d011682016040523d82523d6000602084013e610bca565b606091505b509092509050811580610bde575060208151105b80610c20575080601f81518110610bf757610bf7613482565b01602001517fff0000000000000000000000000000000000000000000000000000000000000016155b15610c325760009450505050506105c9565b509095945050505050565b6000828152602081815260408083205467ffffffffffffffff168352600180835281842086855290925282206060915b600081118015610c7d5750848111155b15610d625780851615801590610cab575060008181526020839052604081208054610ca790613253565b9050115b15610d5a5780826000838152602001908152602001600020808054610ccf90613253565b80601f0160208091040260200160405190810160405280929190818152602001828054610cfb90613253565b8015610d485780601f10610d1d57610100808354040283529160200191610d48565b820191906000526020600020905b815481529060010190602001808311610d2b57829003601f168201915b50505050509050935093505050610d7b565b60011b610c6d565b5060006040518060200160405280600081525092509250505b9250929050565b82610d8c81611b58565b610d9557600080fd5b604080518082018252848152602080820185815260008881528083528481205467ffffffffffffffff1681526009835284812089825283528490209251835551600190920191909155815185815290810184905285917f1d6f5e03d3f63eb58751986629a5439baee5079ff04f345becb66e23eb154e4691015b60405180910390a250505050565b82610e2781611b58565b610e3057600080fd5b6000848152602081815260408083205467ffffffffffffffff168352600382528083208784529091529020610e668385836132ed565b50837fe379c1624ed7e714cc0937528a32359d69d5281337765313dba4e081b72d75788484604051610e0f9291906134b1565b6000828152602081815260408083205467ffffffffffffffff16835260028252808320858452825280832084845290915281208054829190610eda90613253565b905011905092915050565b80610eef81611b58565b610ef857600080fd5b6000828152602081905260408120805467ffffffffffffffff1691610f1c836134c5565b82546101009290920a67ffffffffffffffff818102199093169183160217909155600084815260208181526040918290205491519190921681528492507fc6621ccb8f3f5a04bb6502154b2caf6adf5983fe76dfef1cfc9c42e3579db444910160405180910390a25050565b6000610f9582603c611973565b610f9e906134f2565b60601c92915050565b6000838152602081815260408083205467ffffffffffffffff168352600a825280832086845290915290819020905160609190610fe79085908590613243565b9081526020016040518091039020805461100090613253565b80601f016020809104026020016040519081016040528092919081815260200182805461102c90613253565b80156110795780601f1061104e57610100808354040283529160200191611079565b820191906000526020600020905b81548152906001019060200180831161105c57829003601f168201915b505050505090509392505050565b6000818152602081815260408083205467ffffffffffffffff1683526004825280832084845290915290208054606091906110c190613253565b80601f01602080910402602001604051908101604052809291908181526020018280546110ed90613253565b801561113a5780601f1061110f5761010080835404028352916020019161113a565b820191906000526020600020905b81548152906001019060200180831161111d57829003601f168201915b50505050509050919050565b8361115081611b58565b61115957600080fd5b83611165600182613230565b161561117057600080fd5b6000858152602081815260408083205467ffffffffffffffff16835260018252808320888452825280832087845290915290206111ae8385836132ed565b50604051849086907faa121bbeef5f32f5961a2a28966e769023910fc9479059ee3495d4c1a696efe390600090a35050505050565b6000818152602081815260408083205467ffffffffffffffff1683526008825280832084845290915290208054606091906110c190613253565b8261122781611b58565b61123057600080fd5b6000848152602081815260408083205467ffffffffffffffff1683526008825280832087845290915290206112668385836132ed565b50837fb7d29e911041e8d9b843369e890bcb72c9388692ba48b65ac54e7214c4c348f78484604051610e0f9291906134b1565b826112a381611b58565b6112ac57600080fd5b8151158015906112be57508151601414155b80156112ce57506112ce83612245565b1561131057816040517f8d666f600000000000000000000000000000000000000000000000000000000081526004016113079190612d58565b60405180910390fd5b837f65412581168e88a1e60c6459d7f44ae83ad0832e670826c05a4e2476b57af7528484604051611342929190612cfa565b60405180910390a2603c830361139457837f52d7d861f09ab3d26239d492e8968629f95e9e318cf0b73bfddc441522a15fd261137d846134f2565b60405160609190911c815260200160405180910390a25b6000848152602081815260408083205467ffffffffffffffff16835260028252808320878452825280832086845290915290206113d1838261355e565b5050505050565b73ffffffffffffffffffffffffffffffffffffffff8216330361147d576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602960248201527f455243313135353a2073657474696e6720617070726f76616c2073746174757360448201527f20666f722073656c6600000000000000000000000000000000000000000000006064820152608401611307565b336000818152600b6020908152604080832073ffffffffffffffffffffffffffffffffffffffff87168085529083529281902080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff001686151590811790915590519081529192917f17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31910160405180910390a35050565b73ffffffffffffffffffffffffffffffffffffffff82163303611593576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820181905260248201527f53657474696e672064656c65676174652073746174757320666f722073656c666044820152606401611307565b336000818152600c60209081526040808320878452825280832073ffffffffffffffffffffffffffffffffffffffff87168085529083529281902080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff001686151590811790915590519384529286917ff0ddb3b04746704017f9aa8bd728fcc2c1d11675041205350018915f5e4750a0910160405180910390a4505050565b6000838152602081815260408083205467ffffffffffffffff168352600582528083208684528252808320858452825280832061ffff85168452909152902080546060919061100090613253565b606061168f6000848461226c565b9392505050565b6000818152602081815260408083205467ffffffffffffffff1683526003825280832084845290915290208054606091906110c190613253565b826116da81611b58565b6116e357600080fd5b6000848152602081815260408083205467ffffffffffffffff16808452600483528184208885529092528220805491929161171d90613253565b80601f016020809104026020016040519081016040528092919081815260200182805461174990613253565b80156117965780601f1061176b57610100808354040283529160200191611796565b820191906000526020600020905b81548152906001019060200180831161177957829003601f168201915b5050505067ffffffffffffffff841660009081526004602090815260408083208b845290915290209192506117ce90508587836132ed565b50857f8f15ed4b723ef428f250961da8315675b507046737e19319fc1a4d81bfe87f8582878760405161180393929190613677565b60405180910390a2505050505050565b8161181d81611b58565b61182657600080fd5b6040517fffffffffffffffffffffffffffffffffffffffff000000000000000000000000606084901b166020820152611875908490603c90603401604051602081830303815290604052611299565b505050565b606061188784848461226c565b949350505050565b8261189981611b58565b6118a257600080fd5b6000848152602081815260408083205467ffffffffffffffff1683526007825280832087845282528083207fffffffff0000000000000000000000000000000000000000000000000000000087168085529083529281902080547fffffffffffffffffffffffff00000000000000000000000000000000000000001673ffffffffffffffffffffffffffffffffffffffff8716908117909155905190815286917f7c69f06bea0bdef565b709e93a147836b0063ba2dd89f02d0b7e8d931e6a6daa910160405180910390a350505050565b6000828152602081815260408083205467ffffffffffffffff16835260028252808320858452825280832084845291829052909120805460609291906119b890613253565b80601f01602080910402602001604051908101604052809291908181526020018280546119e490613253565b8015611a315780601f10611a0657610100808354040283529160200191611a31565b820191906000526020600020905b815481529060010190602001808311611a1457829003601f168201915b5050505050915081516000148015611a5757506000611a4f84612454565b63ffffffff16115b15611afb57638000000060009081526020829052604090208054611a7a90613253565b80601f0160208091040260200160405190810160405280929190818152602001828054611aa690613253565b8015611af35780601f10611ac857610100808354040283529160200191611af3565b820191906000526020600020905b815481529060010190602001808311611ad657829003601f168201915b505050505091505b5092915050565b60007fffffffff0000000000000000000000000000000000000000000000000000000082167f59d1d43c0000000000000000000000000000000000000000000000000000000014806105c957506105c982612480565b60003373ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000161480611bd357503373ffffffffffffffffffffffffffffffffffffffff7f000000000000000000000000000000000000000000000000000000000000000016145b15611be057506001919050565b6040517f02571be3000000000000000000000000000000000000000000000000000000008152600481018390526000907f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff16906302571be390602401602060405180830381865afa158015611c6e573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611c9291906136a7565b90507f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff1603611d99576040517f6352211e000000000000000000000000000000000000000000000000000000008152600481018490527f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1690636352211e90602401602060405180830381865afa158015611d72573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611d9691906136a7565b90505b73ffffffffffffffffffffffffffffffffffffffff8116331480611ded575073ffffffffffffffffffffffffffffffffffffffff81166000908152600b6020908152604080832033845290915290205460ff165b8061168f575073ffffffffffffffffffffffffffffffffffffffff81166000908152600c60209081526040808320868452825280832033845290915290205460ff1661168f565b611e826040518060e001604052806060815260200160008152602001600061ffff168152602001600061ffff168152602001600063ffffffff16815260200160008152602001600081525090565b82815260c081018290526105c98161215d565b602081015181516060916105c991611ead90826124d6565b84519190612530565b60a081015160c08201516060916105c991611ead908290613230565b60008151835114801561168f575061168f83600084600087516125a7565b865160208801206000611f04878787612530565b9050831561202e5767ffffffffffffffff831660009081526005602090815260408083208d84528252808320858452825280832061ffff8c16845290915290208054611f4f90613253565b159050611fae5767ffffffffffffffff831660009081526006602090815260408083208d845282528083208584529091528120805461ffff1691611f92836136c4565b91906101000a81548161ffff021916908361ffff160217905550505b67ffffffffffffffff831660009081526005602090815260408083208d84528252808320858452825280832061ffff8c1684529091528120611fef91612a8f565b897f03528ed0c2a3ebc993b12ce3c16bb382f9c7d88ef7d8a1bf290eaf35955a12078a8a604051612021929190613700565b60405180910390a26107cd565b67ffffffffffffffff831660009081526005602090815260408083208d84528252808320858452825280832061ffff8c1684529091529020805461207190613253565b90506000036120d25767ffffffffffffffff831660009081526006602090815260408083208d845282528083208584529091528120805461ffff16916120b683613726565b91906101000a81548161ffff021916908361ffff160217905550505b67ffffffffffffffff831660009081526005602090815260408083208d84528252808320858452825280832061ffff8c1684529091529020612114828261355e565b50897f52a608b3303a48862d07a73d82fa221318c0027fbbcfb1b2329bface3f19ff2b8a8a846040516121499392919061373e565b60405180910390a250505050505050505050565b60c081015160208201819052815151116121745750565b6000612188826000015183602001516124d6565b8260200151612197919061376d565b82519091506121a690826125ca565b61ffff1660408301526121ba60028261376d565b82519091506121c990826125ca565b61ffff1660608301526121dd60028261376d565b82519091506121ec90826125f2565b63ffffffff16608083015261220260048261376d565b825190915060009061221490836125ca565b61ffff16905061222560028361376d565b60a084018190529150612238818361376d565b60c0909301929092525050565b600063800000008214806105c95750600061225f83612454565b63ffffffff161192915050565b60608167ffffffffffffffff81111561228757612287612dbe565b6040519080825280602002602001820160405280156122ba57816020015b60608152602001906001900390816122a55790505b50905060005b8281101561244c57841561239f5760008484838181106122e2576122e2613482565b90506020028101906122f49190613780565b612303916024916004916137e5565b61230c9161380f565b905085811461239d576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152603460248201527f6d756c746963616c6c3a20416c6c207265636f726473206d757374206861766560448201527f2061206d61746368696e67206e616d65686173680000000000000000000000006064820152608401611307565b505b600080308686858181106123b5576123b5613482565b90506020028101906123c79190613780565b6040516123d5929190613243565b600060405180830381855af49150503d8060008114612410576040519150601f19603f3d011682016040523d82523d6000602084013e612415565b606091505b50915091508161242457600080fd5b8084848151811061243757612437613482565b602090810291909101015250506001016122c0565b509392505050565b6000603c820361246657506001919050565b638000000091821891821061247c5760006105c9565b5090565b60007fffffffff0000000000000000000000000000000000000000000000000000000082167fc86902330000000000000000000000000000000000000000000000000000000014806105c957506105c98261261c565b6000815b835181106124ea576124ea61384b565b60006124f68583612672565b60ff16905061250681600161376d565b612510908361376d565b9150806000036125205750612526565b506124da565b6118878382613230565b825160609061253f838561376d565b111561254a57600080fd5b60008267ffffffffffffffff81111561256557612565612dbe565b6040519080825280601f01601f19166020018201604052801561258f576020820181803683370190505b50905060208082019086860101610c32828287612696565b60006125b484848461270a565b6125bf87878561270a565b149695505050505050565b81516000906125da83600261376d565b11156125e557600080fd5b50016002015161ffff1690565b815160009061260283600461376d565b111561260d57600080fd5b50016004015163ffffffff1690565b60007fffffffff0000000000000000000000000000000000000000000000000000000082167f691f34310000000000000000000000000000000000000000000000000000000014806105c957506105c98261272e565b600082828151811061268657612686613482565b016020015160f81c905092915050565b602081106126ce57815183526126ad60208461376d565b92506126ba60208361376d565b91506126c7602082613230565b9050612696565b905182516020929092036101000a7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0180199091169116179052565b8251600090612719838561376d565b111561272457600080fd5b5091016020012090565b60007fffffffff0000000000000000000000000000000000000000000000000000000082167f124a319c0000000000000000000000000000000000000000000000000000000014806105c957506105c98260007fffffffff0000000000000000000000000000000000000000000000000000000082167fa8fa568200000000000000000000000000000000000000000000000000000000148061281257507fffffffff0000000000000000000000000000000000000000000000000000000082167f5c98042b00000000000000000000000000000000000000000000000000000000145b806105c957506105c98260007fffffffff0000000000000000000000000000000000000000000000000000000082167fbc1c58d10000000000000000000000000000000000000000000000000000000014806105c957506105c98260007f3b3b57de000000000000000000000000000000000000000000000000000000007fffffffff000000000000000000000000000000000000000000000000000000008316148061290057507ff1cb7e06000000000000000000000000000000000000000000000000000000007fffffffff000000000000000000000000000000000000000000000000000000008316145b8061294c57507f32f111d7000000000000000000000000000000000000000000000000000000007fffffffff000000000000000000000000000000000000000000000000000000008316145b806105c957506105c98260007fffffffff0000000000000000000000000000000000000000000000000000000082167f2203ab560000000000000000000000000000000000000000000000000000000014806105c957506105c98260007fffffffff0000000000000000000000000000000000000000000000000000000082167fd700ff330000000000000000000000000000000000000000000000000000000014806105c957506105c98260007fffffffff0000000000000000000000000000000000000000000000000000000082167f4fbf04330000000000000000000000000000000000000000000000000000000014806105c957507f01ffc9a7000000000000000000000000000000000000000000000000000000007fffffffff000000000000000000000000000000000000000000000000000000008316146105c9565b508054612a9b90613253565b6000825580601f10612aab575050565b601f016020900490600052602060002090810190612ac99190612acc565b50565b5b8082111561247c5760008155600101612acd565b80357fffffffff0000000000000000000000000000000000000000000000000000000081168114612b1157600080fd5b919050565b600060208284031215612b2857600080fd5b61168f82612ae1565b60008083601f840112612b4357600080fd5b50813567ffffffffffffffff811115612b5b57600080fd5b602083019150836020828501011115610d7b57600080fd5b600080600060408486031215612b8857600080fd5b83359250602084013567ffffffffffffffff811115612ba657600080fd5b612bb286828701612b31565b9497909650939450505050565b600080600080600060608688031215612bd757600080fd5b85359450602086013567ffffffffffffffff811115612bf557600080fd5b612c0188828901612b31565b909550935050604086013567ffffffffffffffff811115612c2157600080fd5b612c2d88828901612b31565b969995985093965092949392505050565b60008060408385031215612c5157600080fd5b82359150612c6160208401612ae1565b90509250929050565b60008060408385031215612c7d57600080fd5b50508035926020909101359150565b60005b83811015612ca7578181015183820152602001612c8f565b50506000910152565b60008151808452612cc8816020860160208601612c8c565b601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0169290920160200192915050565b8281526040602082015260006118876040830184612cb0565b600080600060608486031215612d2857600080fd5b505081359360208301359350604090920135919050565b600060208284031215612d5157600080fd5b5035919050565b60208152600061168f6020830184612cb0565b60008060008060608587031215612d8157600080fd5b8435935060208501359250604085013567ffffffffffffffff811115612da657600080fd5b612db287828801612b31565b95989497509550505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b600080600060608486031215612e0257600080fd5b8335925060208401359150604084013567ffffffffffffffff811115612e2757600080fd5b8401601f81018613612e3857600080fd5b803567ffffffffffffffff811115612e5257612e52612dbe565b6040517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0603f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f8501160116810181811067ffffffffffffffff82111715612ebe57612ebe612dbe565b604052818152828201602001881015612ed657600080fd5b816020840160208301376000602083830101528093505050509250925092565b73ffffffffffffffffffffffffffffffffffffffff81168114612ac957600080fd5b80358015158114612b1157600080fd5b60008060408385031215612f3b57600080fd5b8235612f4681612ef6565b9150612c6160208401612f18565b600080600060608486031215612f6957600080fd5b833592506020840135612f7b81612ef6565b9150612f8960408501612f18565b90509250925092565b600080600060608486031215612fa757600080fd5b8335925060208401359150604084013561ffff81168114612fc757600080fd5b809150509250925092565b600080600060608486031215612fe757600080fd5b8335612ff281612ef6565b9250602084013591506040840135612fc781612ef6565b60008083601f84011261301b57600080fd5b50813567ffffffffffffffff81111561303357600080fd5b6020830191508360208260051b8501011115610d7b57600080fd5b6000806020838503121561306157600080fd5b823567ffffffffffffffff81111561307857600080fd5b61308485828601613009565b90969095509350505050565b6000602082016020835280845180835260408501915060408160051b86010192506020860160005b82811015613107577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc08786030184526130f2858351612cb0565b945060209384019391909101906001016130b8565b50929695505050505050565b6000806040838503121561312657600080fd5b82359150602083013561313881612ef6565b809150509250929050565b60008060006040848603121561315857600080fd5b83359250602084013567ffffffffffffffff81111561317657600080fd5b612bb286828701613009565b60008060006060848603121561319757600080fd5b833592506131a760208501612ae1565b91506040840135612fc781612ef6565b600080604083850312156131ca57600080fd5b82356131d581612ef6565b9150602083013561313881612ef6565b600082516131f7818460208701612c8c565b9190910192915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b818103818111156105c9576105c9613201565b8183823760009101908152919050565b600181811c9082168061326757607f821691505b6020821081036132a0577f4e487b7100000000000000000000000000000000000000000000000000000000600052602260045260246000fd5b50919050565b601f82111561187557806000526020600020601f840160051c810160208510156132cd5750805b601f840160051c820191505b818110156113d157600081556001016132d9565b67ffffffffffffffff83111561330557613305612dbe565b613319836133138354613253565b836132a6565b6000601f84116001811461336b57600085156133355750838201355b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff600387901b1c1916600186901b1783556113d1565b6000838152602090207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0861690835b828110156133ba578685013582556020948501946001909201910161339a565b50868210156133f5577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff60f88860031b161c19848701351681555b505060018560011b0183555050505050565b8183528181602085013750600060208284010152600060207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f840116840101905092915050565b604081526000613464604083018688613407565b8281036020840152613477818587613407565b979650505050505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b602081526000611887602083018486613407565b600067ffffffffffffffff821667ffffffffffffffff81036134e9576134e9613201565b60010192915050565b805160208201517fffffffffffffffffffffffffffffffffffffffff000000000000000000000000811691906014821015613557577fffffffffffffffffffffffffffffffffffffffff000000000000000000000000808360140360031b1b82161692505b5050919050565b815167ffffffffffffffff81111561357857613578612dbe565b61358c816135868454613253565b846132a6565b6020601f8211600181146135de57600083156135a85750848201515b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff600385901b1c1916600184901b1784556113d1565b6000848152602081207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08516915b8281101561362c578785015182556020948501946001909201910161360c565b508482101561366857868401517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff600387901b60f8161c191681555b50505050600190811b01905550565b60408152600061368a6040830186612cb0565b828103602084015261369d818587613407565b9695505050505050565b6000602082840312156136b957600080fd5b815161168f81612ef6565b600061ffff8216806136d8576136d8613201565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0192915050565b6040815260006137136040830185612cb0565b905061ffff831660208301529392505050565b600061ffff821661ffff81036134e9576134e9613201565b6060815260006137516060830186612cb0565b61ffff85166020840152828103604084015261369d8185612cb0565b808201808211156105c9576105c9613201565b60008083357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe18436030181126137b557600080fd5b83018035915067ffffffffffffffff8211156137d057600080fd5b602001915036819003821315610d7b57600080fd5b600080858511156137f557600080fd5b8386111561380257600080fd5b5050820193919092039150565b803560208310156105c9577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff602084900360031b1b1692915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052600160045260246000fdfea264697066735822122075a7658084d4def9f6cce391e839ba4adcd596c5ae93e2d00f29a82163695c2f64736f6c634300081a0033","deployedBytecode":"0x608060405234801561001057600080fd5b50600436106101e55760003560e01c8063773722131161010f578063c8690233116100a2578063e32954eb11610071578063e32954eb1461053c578063e59d895d1461054f578063e985e9c514610562578063f1cb7e06146105ab57600080fd5b8063c86902331461047a578063ce3decdc146104d3578063d5fa2b00146104e6578063d700ff33146104f957600080fd5b8063a8fa5682116100de578063a8fa5682146103e3578063a9784b3e146103f6578063ac9650d814610447578063bc1c58d11461046757600080fd5b806377372213146103975780638b95dd71146103aa578063a22cb465146103bd578063a4b91a01146103d057600080fd5b806332f111d71161018757806359d1d43c1161015657806359d1d43c1461033e5780635c98042b1461035e578063623195b014610371578063691f34311461038457600080fd5b806332f111d7146102b95780633603d758146102cc5780633b3b57de146102df5780634cbf6ba4146102f257600080fd5b8063124a319c116101c3578063124a319c1461023a5780632203ab561461027257806329cd62ea14610293578063304e6ade146102a657600080fd5b806301ffc9a7146101ea5780630af179d71461021257806310f13a8c14610227575b600080fd5b6101fd6101f8366004612b16565b6105be565b60405190151581526020015b60405180910390f35b610225610220366004612b73565b6105cf565b005b610225610235366004612bbf565b6107d9565b61024d610248366004612c3e565b6108a6565b60405173ffffffffffffffffffffffffffffffffffffffff9091168152602001610209565b610285610280366004612c6a565b610c3d565b604051610209929190612cfa565b6102256102a1366004612d13565b610d82565b6102256102b4366004612b73565b610e1d565b6101fd6102c7366004612c6a565b610e99565b6102256102da366004612d3f565b610ee5565b61024d6102ed366004612d3f565b610f88565b6101fd610300366004612c6a565b6000828152602081815260408083205467ffffffffffffffff1683526006825280832094835293815283822092825291909152205461ffff16151590565b61035161034c366004612b73565b610fa7565b6040516102099190612d58565b61035161036c366004612d3f565b611087565b61022561037f366004612d6b565b611146565b610351610392366004612d3f565b6111e3565b6102256103a5366004612b73565b61121d565b6102256103b8366004612ded565b611299565b6102256103cb366004612f28565b6113d8565b6102256103de366004612f54565b611514565b6103516103f1366004612f92565b611633565b6101fd610404366004612fd2565b73ffffffffffffffffffffffffffffffffffffffff9283166000908152600c60209081526040808320948352938152838220929094168152925290205460ff1690565b61045a61045536600461304e565b611681565b6040516102099190613090565b610351610475366004612d3f565b611696565b6104be610488366004612d3f565b6000818152602081815260408083205467ffffffffffffffff168352600982528083209383529290522080546001909101549091565b60408051928352602083019190915201610209565b6102256104e1366004612b73565b6116d0565b6102256104f4366004613113565b611813565b610523610507366004612d3f565b60006020819052908152604090205467ffffffffffffffff1681565b60405167ffffffffffffffff9091168152602001610209565b61045a61054a366004613143565b61187a565b61022561055d366004613182565b61188f565b6101fd6105703660046131b7565b73ffffffffffffffffffffffffffffffffffffffff9182166000908152600b6020908152604080832093909416825291909152205460ff1690565b6103516105b9366004612c6a565b611973565b60006105c982611b02565b92915050565b826105d981611b58565b6105e257600080fd5b600084815260208181526040808320548151601f870184900484028101840190925285825283926060928392859267ffffffffffffffff9091169183916106489183918d908d90819084018382808284376000920191909152509293925050611e349050565b90505b80515160208201511015610772578661ffff166000036106b0578060400151965061067581611e95565b94508460405160200161068891906131e5565b6040516020818303038152906040528051906020012092506106a981611eb6565b9350610764565b60006106bb82611e95565b9050816040015161ffff168861ffff161415806106df57506106dd8682611ed2565b155b156107625761073b8c878a8e8e8080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250505060208801518d9150610732908290613230565b8b51158a611ef0565b81604001519750816020015196508095508580519060200120935061075f82611eb6565b94505b505b61076d8161215d565b61064b565b508351156107cd576107cd8a85888c8c8080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920191909152508c92506107c491508290508f613230565b89511588611ef0565b50505050505050505050565b846107e381611b58565b6107ec57600080fd5b6000868152602081815260408083205467ffffffffffffffff168352600a82528083208984529091529081902090518491849161082c9089908990613243565b908152602001604051809103902091826108479291906132ed565b508484604051610858929190613243565b6040518091039020867f448bc014f1536726cf8d54ff3d6481ed3cbc683c2591ca204274009afa09b1a1878787876040516108969493929190613450565b60405180910390a3505050505050565b6000828152602081815260408083205467ffffffffffffffff1683526007825280832085845282528083207fffffffff000000000000000000000000000000000000000000000000000000008516845290915281205473ffffffffffffffffffffffffffffffffffffffff16801561091f5790506105c9565b600061092a85610f88565b905073ffffffffffffffffffffffffffffffffffffffff8116610952576000925050506105c9565b6040517f01ffc9a7000000000000000000000000000000000000000000000000000000006024820152600090819073ffffffffffffffffffffffffffffffffffffffff841690604401604080517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08184030181529181526020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167f01ffc9a70000000000000000000000000000000000000000000000000000000017905251610a1c91906131e5565b600060405180830381855afa9150503d8060008114610a57576040519150601f19603f3d011682016040523d82523d6000602084013e610a5c565b606091505b5091509150811580610a6f575060208151105b80610ab1575080601f81518110610a8857610a88613482565b01602001517fff0000000000000000000000000000000000000000000000000000000000000016155b15610ac35760009450505050506105c9565b6040517fffffffff000000000000000000000000000000000000000000000000000000008716602482015273ffffffffffffffffffffffffffffffffffffffff841690604401604080517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08184030181529181526020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167f01ffc9a70000000000000000000000000000000000000000000000000000000017905251610b8a91906131e5565b600060405180830381855afa9150503d8060008114610bc5576040519150601f19603f3d011682016040523d82523d6000602084013e610bca565b606091505b509092509050811580610bde575060208151105b80610c20575080601f81518110610bf757610bf7613482565b01602001517fff0000000000000000000000000000000000000000000000000000000000000016155b15610c325760009450505050506105c9565b509095945050505050565b6000828152602081815260408083205467ffffffffffffffff168352600180835281842086855290925282206060915b600081118015610c7d5750848111155b15610d625780851615801590610cab575060008181526020839052604081208054610ca790613253565b9050115b15610d5a5780826000838152602001908152602001600020808054610ccf90613253565b80601f0160208091040260200160405190810160405280929190818152602001828054610cfb90613253565b8015610d485780601f10610d1d57610100808354040283529160200191610d48565b820191906000526020600020905b815481529060010190602001808311610d2b57829003601f168201915b50505050509050935093505050610d7b565b60011b610c6d565b5060006040518060200160405280600081525092509250505b9250929050565b82610d8c81611b58565b610d9557600080fd5b604080518082018252848152602080820185815260008881528083528481205467ffffffffffffffff1681526009835284812089825283528490209251835551600190920191909155815185815290810184905285917f1d6f5e03d3f63eb58751986629a5439baee5079ff04f345becb66e23eb154e4691015b60405180910390a250505050565b82610e2781611b58565b610e3057600080fd5b6000848152602081815260408083205467ffffffffffffffff168352600382528083208784529091529020610e668385836132ed565b50837fe379c1624ed7e714cc0937528a32359d69d5281337765313dba4e081b72d75788484604051610e0f9291906134b1565b6000828152602081815260408083205467ffffffffffffffff16835260028252808320858452825280832084845290915281208054829190610eda90613253565b905011905092915050565b80610eef81611b58565b610ef857600080fd5b6000828152602081905260408120805467ffffffffffffffff1691610f1c836134c5565b82546101009290920a67ffffffffffffffff818102199093169183160217909155600084815260208181526040918290205491519190921681528492507fc6621ccb8f3f5a04bb6502154b2caf6adf5983fe76dfef1cfc9c42e3579db444910160405180910390a25050565b6000610f9582603c611973565b610f9e906134f2565b60601c92915050565b6000838152602081815260408083205467ffffffffffffffff168352600a825280832086845290915290819020905160609190610fe79085908590613243565b9081526020016040518091039020805461100090613253565b80601f016020809104026020016040519081016040528092919081815260200182805461102c90613253565b80156110795780601f1061104e57610100808354040283529160200191611079565b820191906000526020600020905b81548152906001019060200180831161105c57829003601f168201915b505050505090509392505050565b6000818152602081815260408083205467ffffffffffffffff1683526004825280832084845290915290208054606091906110c190613253565b80601f01602080910402602001604051908101604052809291908181526020018280546110ed90613253565b801561113a5780601f1061110f5761010080835404028352916020019161113a565b820191906000526020600020905b81548152906001019060200180831161111d57829003601f168201915b50505050509050919050565b8361115081611b58565b61115957600080fd5b83611165600182613230565b161561117057600080fd5b6000858152602081815260408083205467ffffffffffffffff16835260018252808320888452825280832087845290915290206111ae8385836132ed565b50604051849086907faa121bbeef5f32f5961a2a28966e769023910fc9479059ee3495d4c1a696efe390600090a35050505050565b6000818152602081815260408083205467ffffffffffffffff1683526008825280832084845290915290208054606091906110c190613253565b8261122781611b58565b61123057600080fd5b6000848152602081815260408083205467ffffffffffffffff1683526008825280832087845290915290206112668385836132ed565b50837fb7d29e911041e8d9b843369e890bcb72c9388692ba48b65ac54e7214c4c348f78484604051610e0f9291906134b1565b826112a381611b58565b6112ac57600080fd5b8151158015906112be57508151601414155b80156112ce57506112ce83612245565b1561131057816040517f8d666f600000000000000000000000000000000000000000000000000000000081526004016113079190612d58565b60405180910390fd5b837f65412581168e88a1e60c6459d7f44ae83ad0832e670826c05a4e2476b57af7528484604051611342929190612cfa565b60405180910390a2603c830361139457837f52d7d861f09ab3d26239d492e8968629f95e9e318cf0b73bfddc441522a15fd261137d846134f2565b60405160609190911c815260200160405180910390a25b6000848152602081815260408083205467ffffffffffffffff16835260028252808320878452825280832086845290915290206113d1838261355e565b5050505050565b73ffffffffffffffffffffffffffffffffffffffff8216330361147d576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602960248201527f455243313135353a2073657474696e6720617070726f76616c2073746174757360448201527f20666f722073656c6600000000000000000000000000000000000000000000006064820152608401611307565b336000818152600b6020908152604080832073ffffffffffffffffffffffffffffffffffffffff87168085529083529281902080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff001686151590811790915590519081529192917f17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31910160405180910390a35050565b73ffffffffffffffffffffffffffffffffffffffff82163303611593576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820181905260248201527f53657474696e672064656c65676174652073746174757320666f722073656c666044820152606401611307565b336000818152600c60209081526040808320878452825280832073ffffffffffffffffffffffffffffffffffffffff87168085529083529281902080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff001686151590811790915590519384529286917ff0ddb3b04746704017f9aa8bd728fcc2c1d11675041205350018915f5e4750a0910160405180910390a4505050565b6000838152602081815260408083205467ffffffffffffffff168352600582528083208684528252808320858452825280832061ffff85168452909152902080546060919061100090613253565b606061168f6000848461226c565b9392505050565b6000818152602081815260408083205467ffffffffffffffff1683526003825280832084845290915290208054606091906110c190613253565b826116da81611b58565b6116e357600080fd5b6000848152602081815260408083205467ffffffffffffffff16808452600483528184208885529092528220805491929161171d90613253565b80601f016020809104026020016040519081016040528092919081815260200182805461174990613253565b80156117965780601f1061176b57610100808354040283529160200191611796565b820191906000526020600020905b81548152906001019060200180831161177957829003601f168201915b5050505067ffffffffffffffff841660009081526004602090815260408083208b845290915290209192506117ce90508587836132ed565b50857f8f15ed4b723ef428f250961da8315675b507046737e19319fc1a4d81bfe87f8582878760405161180393929190613677565b60405180910390a2505050505050565b8161181d81611b58565b61182657600080fd5b6040517fffffffffffffffffffffffffffffffffffffffff000000000000000000000000606084901b166020820152611875908490603c90603401604051602081830303815290604052611299565b505050565b606061188784848461226c565b949350505050565b8261189981611b58565b6118a257600080fd5b6000848152602081815260408083205467ffffffffffffffff1683526007825280832087845282528083207fffffffff0000000000000000000000000000000000000000000000000000000087168085529083529281902080547fffffffffffffffffffffffff00000000000000000000000000000000000000001673ffffffffffffffffffffffffffffffffffffffff8716908117909155905190815286917f7c69f06bea0bdef565b709e93a147836b0063ba2dd89f02d0b7e8d931e6a6daa910160405180910390a350505050565b6000828152602081815260408083205467ffffffffffffffff16835260028252808320858452825280832084845291829052909120805460609291906119b890613253565b80601f01602080910402602001604051908101604052809291908181526020018280546119e490613253565b8015611a315780601f10611a0657610100808354040283529160200191611a31565b820191906000526020600020905b815481529060010190602001808311611a1457829003601f168201915b5050505050915081516000148015611a5757506000611a4f84612454565b63ffffffff16115b15611afb57638000000060009081526020829052604090208054611a7a90613253565b80601f0160208091040260200160405190810160405280929190818152602001828054611aa690613253565b8015611af35780601f10611ac857610100808354040283529160200191611af3565b820191906000526020600020905b815481529060010190602001808311611ad657829003601f168201915b505050505091505b5092915050565b60007fffffffff0000000000000000000000000000000000000000000000000000000082167f59d1d43c0000000000000000000000000000000000000000000000000000000014806105c957506105c982612480565b60003373ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000161480611bd357503373ffffffffffffffffffffffffffffffffffffffff7f000000000000000000000000000000000000000000000000000000000000000016145b15611be057506001919050565b6040517f02571be3000000000000000000000000000000000000000000000000000000008152600481018390526000907f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff16906302571be390602401602060405180830381865afa158015611c6e573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611c9291906136a7565b90507f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff1603611d99576040517f6352211e000000000000000000000000000000000000000000000000000000008152600481018490527f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1690636352211e90602401602060405180830381865afa158015611d72573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611d9691906136a7565b90505b73ffffffffffffffffffffffffffffffffffffffff8116331480611ded575073ffffffffffffffffffffffffffffffffffffffff81166000908152600b6020908152604080832033845290915290205460ff165b8061168f575073ffffffffffffffffffffffffffffffffffffffff81166000908152600c60209081526040808320868452825280832033845290915290205460ff1661168f565b611e826040518060e001604052806060815260200160008152602001600061ffff168152602001600061ffff168152602001600063ffffffff16815260200160008152602001600081525090565b82815260c081018290526105c98161215d565b602081015181516060916105c991611ead90826124d6565b84519190612530565b60a081015160c08201516060916105c991611ead908290613230565b60008151835114801561168f575061168f83600084600087516125a7565b865160208801206000611f04878787612530565b9050831561202e5767ffffffffffffffff831660009081526005602090815260408083208d84528252808320858452825280832061ffff8c16845290915290208054611f4f90613253565b159050611fae5767ffffffffffffffff831660009081526006602090815260408083208d845282528083208584529091528120805461ffff1691611f92836136c4565b91906101000a81548161ffff021916908361ffff160217905550505b67ffffffffffffffff831660009081526005602090815260408083208d84528252808320858452825280832061ffff8c1684529091528120611fef91612a8f565b897f03528ed0c2a3ebc993b12ce3c16bb382f9c7d88ef7d8a1bf290eaf35955a12078a8a604051612021929190613700565b60405180910390a26107cd565b67ffffffffffffffff831660009081526005602090815260408083208d84528252808320858452825280832061ffff8c1684529091529020805461207190613253565b90506000036120d25767ffffffffffffffff831660009081526006602090815260408083208d845282528083208584529091528120805461ffff16916120b683613726565b91906101000a81548161ffff021916908361ffff160217905550505b67ffffffffffffffff831660009081526005602090815260408083208d84528252808320858452825280832061ffff8c1684529091529020612114828261355e565b50897f52a608b3303a48862d07a73d82fa221318c0027fbbcfb1b2329bface3f19ff2b8a8a846040516121499392919061373e565b60405180910390a250505050505050505050565b60c081015160208201819052815151116121745750565b6000612188826000015183602001516124d6565b8260200151612197919061376d565b82519091506121a690826125ca565b61ffff1660408301526121ba60028261376d565b82519091506121c990826125ca565b61ffff1660608301526121dd60028261376d565b82519091506121ec90826125f2565b63ffffffff16608083015261220260048261376d565b825190915060009061221490836125ca565b61ffff16905061222560028361376d565b60a084018190529150612238818361376d565b60c0909301929092525050565b600063800000008214806105c95750600061225f83612454565b63ffffffff161192915050565b60608167ffffffffffffffff81111561228757612287612dbe565b6040519080825280602002602001820160405280156122ba57816020015b60608152602001906001900390816122a55790505b50905060005b8281101561244c57841561239f5760008484838181106122e2576122e2613482565b90506020028101906122f49190613780565b612303916024916004916137e5565b61230c9161380f565b905085811461239d576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152603460248201527f6d756c746963616c6c3a20416c6c207265636f726473206d757374206861766560448201527f2061206d61746368696e67206e616d65686173680000000000000000000000006064820152608401611307565b505b600080308686858181106123b5576123b5613482565b90506020028101906123c79190613780565b6040516123d5929190613243565b600060405180830381855af49150503d8060008114612410576040519150601f19603f3d011682016040523d82523d6000602084013e612415565b606091505b50915091508161242457600080fd5b8084848151811061243757612437613482565b602090810291909101015250506001016122c0565b509392505050565b6000603c820361246657506001919050565b638000000091821891821061247c5760006105c9565b5090565b60007fffffffff0000000000000000000000000000000000000000000000000000000082167fc86902330000000000000000000000000000000000000000000000000000000014806105c957506105c98261261c565b6000815b835181106124ea576124ea61384b565b60006124f68583612672565b60ff16905061250681600161376d565b612510908361376d565b9150806000036125205750612526565b506124da565b6118878382613230565b825160609061253f838561376d565b111561254a57600080fd5b60008267ffffffffffffffff81111561256557612565612dbe565b6040519080825280601f01601f19166020018201604052801561258f576020820181803683370190505b50905060208082019086860101610c32828287612696565b60006125b484848461270a565b6125bf87878561270a565b149695505050505050565b81516000906125da83600261376d565b11156125e557600080fd5b50016002015161ffff1690565b815160009061260283600461376d565b111561260d57600080fd5b50016004015163ffffffff1690565b60007fffffffff0000000000000000000000000000000000000000000000000000000082167f691f34310000000000000000000000000000000000000000000000000000000014806105c957506105c98261272e565b600082828151811061268657612686613482565b016020015160f81c905092915050565b602081106126ce57815183526126ad60208461376d565b92506126ba60208361376d565b91506126c7602082613230565b9050612696565b905182516020929092036101000a7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0180199091169116179052565b8251600090612719838561376d565b111561272457600080fd5b5091016020012090565b60007fffffffff0000000000000000000000000000000000000000000000000000000082167f124a319c0000000000000000000000000000000000000000000000000000000014806105c957506105c98260007fffffffff0000000000000000000000000000000000000000000000000000000082167fa8fa568200000000000000000000000000000000000000000000000000000000148061281257507fffffffff0000000000000000000000000000000000000000000000000000000082167f5c98042b00000000000000000000000000000000000000000000000000000000145b806105c957506105c98260007fffffffff0000000000000000000000000000000000000000000000000000000082167fbc1c58d10000000000000000000000000000000000000000000000000000000014806105c957506105c98260007f3b3b57de000000000000000000000000000000000000000000000000000000007fffffffff000000000000000000000000000000000000000000000000000000008316148061290057507ff1cb7e06000000000000000000000000000000000000000000000000000000007fffffffff000000000000000000000000000000000000000000000000000000008316145b8061294c57507f32f111d7000000000000000000000000000000000000000000000000000000007fffffffff000000000000000000000000000000000000000000000000000000008316145b806105c957506105c98260007fffffffff0000000000000000000000000000000000000000000000000000000082167f2203ab560000000000000000000000000000000000000000000000000000000014806105c957506105c98260007fffffffff0000000000000000000000000000000000000000000000000000000082167fd700ff330000000000000000000000000000000000000000000000000000000014806105c957506105c98260007fffffffff0000000000000000000000000000000000000000000000000000000082167f4fbf04330000000000000000000000000000000000000000000000000000000014806105c957507f01ffc9a7000000000000000000000000000000000000000000000000000000007fffffffff000000000000000000000000000000000000000000000000000000008316146105c9565b508054612a9b90613253565b6000825580601f10612aab575050565b601f016020900490600052602060002090810190612ac99190612acc565b50565b5b8082111561247c5760008155600101612acd565b80357fffffffff0000000000000000000000000000000000000000000000000000000081168114612b1157600080fd5b919050565b600060208284031215612b2857600080fd5b61168f82612ae1565b60008083601f840112612b4357600080fd5b50813567ffffffffffffffff811115612b5b57600080fd5b602083019150836020828501011115610d7b57600080fd5b600080600060408486031215612b8857600080fd5b83359250602084013567ffffffffffffffff811115612ba657600080fd5b612bb286828701612b31565b9497909650939450505050565b600080600080600060608688031215612bd757600080fd5b85359450602086013567ffffffffffffffff811115612bf557600080fd5b612c0188828901612b31565b909550935050604086013567ffffffffffffffff811115612c2157600080fd5b612c2d88828901612b31565b969995985093965092949392505050565b60008060408385031215612c5157600080fd5b82359150612c6160208401612ae1565b90509250929050565b60008060408385031215612c7d57600080fd5b50508035926020909101359150565b60005b83811015612ca7578181015183820152602001612c8f565b50506000910152565b60008151808452612cc8816020860160208601612c8c565b601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0169290920160200192915050565b8281526040602082015260006118876040830184612cb0565b600080600060608486031215612d2857600080fd5b505081359360208301359350604090920135919050565b600060208284031215612d5157600080fd5b5035919050565b60208152600061168f6020830184612cb0565b60008060008060608587031215612d8157600080fd5b8435935060208501359250604085013567ffffffffffffffff811115612da657600080fd5b612db287828801612b31565b95989497509550505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b600080600060608486031215612e0257600080fd5b8335925060208401359150604084013567ffffffffffffffff811115612e2757600080fd5b8401601f81018613612e3857600080fd5b803567ffffffffffffffff811115612e5257612e52612dbe565b6040517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0603f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f8501160116810181811067ffffffffffffffff82111715612ebe57612ebe612dbe565b604052818152828201602001881015612ed657600080fd5b816020840160208301376000602083830101528093505050509250925092565b73ffffffffffffffffffffffffffffffffffffffff81168114612ac957600080fd5b80358015158114612b1157600080fd5b60008060408385031215612f3b57600080fd5b8235612f4681612ef6565b9150612c6160208401612f18565b600080600060608486031215612f6957600080fd5b833592506020840135612f7b81612ef6565b9150612f8960408501612f18565b90509250925092565b600080600060608486031215612fa757600080fd5b8335925060208401359150604084013561ffff81168114612fc757600080fd5b809150509250925092565b600080600060608486031215612fe757600080fd5b8335612ff281612ef6565b9250602084013591506040840135612fc781612ef6565b60008083601f84011261301b57600080fd5b50813567ffffffffffffffff81111561303357600080fd5b6020830191508360208260051b8501011115610d7b57600080fd5b6000806020838503121561306157600080fd5b823567ffffffffffffffff81111561307857600080fd5b61308485828601613009565b90969095509350505050565b6000602082016020835280845180835260408501915060408160051b86010192506020860160005b82811015613107577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc08786030184526130f2858351612cb0565b945060209384019391909101906001016130b8565b50929695505050505050565b6000806040838503121561312657600080fd5b82359150602083013561313881612ef6565b809150509250929050565b60008060006040848603121561315857600080fd5b83359250602084013567ffffffffffffffff81111561317657600080fd5b612bb286828701613009565b60008060006060848603121561319757600080fd5b833592506131a760208501612ae1565b91506040840135612fc781612ef6565b600080604083850312156131ca57600080fd5b82356131d581612ef6565b9150602083013561313881612ef6565b600082516131f7818460208701612c8c565b9190910192915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b818103818111156105c9576105c9613201565b8183823760009101908152919050565b600181811c9082168061326757607f821691505b6020821081036132a0577f4e487b7100000000000000000000000000000000000000000000000000000000600052602260045260246000fd5b50919050565b601f82111561187557806000526020600020601f840160051c810160208510156132cd5750805b601f840160051c820191505b818110156113d157600081556001016132d9565b67ffffffffffffffff83111561330557613305612dbe565b613319836133138354613253565b836132a6565b6000601f84116001811461336b57600085156133355750838201355b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff600387901b1c1916600186901b1783556113d1565b6000838152602090207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0861690835b828110156133ba578685013582556020948501946001909201910161339a565b50868210156133f5577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff60f88860031b161c19848701351681555b505060018560011b0183555050505050565b8183528181602085013750600060208284010152600060207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f840116840101905092915050565b604081526000613464604083018688613407565b8281036020840152613477818587613407565b979650505050505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b602081526000611887602083018486613407565b600067ffffffffffffffff821667ffffffffffffffff81036134e9576134e9613201565b60010192915050565b805160208201517fffffffffffffffffffffffffffffffffffffffff000000000000000000000000811691906014821015613557577fffffffffffffffffffffffffffffffffffffffff000000000000000000000000808360140360031b1b82161692505b5050919050565b815167ffffffffffffffff81111561357857613578612dbe565b61358c816135868454613253565b846132a6565b6020601f8211600181146135de57600083156135a85750848201515b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff600385901b1c1916600184901b1784556113d1565b6000848152602081207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08516915b8281101561362c578785015182556020948501946001909201910161360c565b508482101561366857868401517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff600387901b60f8161c191681555b50505050600190811b01905550565b60408152600061368a6040830186612cb0565b828103602084015261369d818587613407565b9695505050505050565b6000602082840312156136b957600080fd5b815161168f81612ef6565b600061ffff8216806136d8576136d8613201565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0192915050565b6040815260006137136040830185612cb0565b905061ffff831660208301529392505050565b600061ffff821661ffff81036134e9576134e9613201565b6060815260006137516060830186612cb0565b61ffff85166020840152828103604084015261369d8185612cb0565b808201808211156105c9576105c9613201565b60008083357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe18436030181126137b557600080fd5b83018035915067ffffffffffffffff8211156137d057600080fd5b602001915036819003821315610d7b57600080fd5b600080858511156137f557600080fd5b8386111561380257600080fd5b5050820193919092039150565b803560208310156105c9577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff602084900360031b1b1692915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052600160045260246000fdfea264697066735822122075a7658084d4def9f6cce391e839ba4adcd596c5ae93e2d00f29a82163695c2f64736f6c634300081a0033","devdoc":{"errors":{"InvalidEVMAddress(bytes)":[{"details":"Error selector: `0x8d666f60`"}]},"kind":"dev","methods":{"ABI(bytes32,uint256)":{"params":{"contentTypes":"A bitwise OR of the ABI formats accepted by the caller.","node":"The ENS node to query"},"returns":{"_0":"contentType The content type of the return value","_1":"data The ABI data"}},"addr(bytes32)":{"params":{"node":"The node to query."},"returns":{"_0":"The associated address."}},"addr(bytes32,uint256)":{"params":{"coinType":"The coin type.","node":"The node to query."},"returns":{"addressBytes":"The assocated address."}},"approve(bytes32,address,bool)":{"details":"Approve a delegate to be able to updated records on a node."},"clearRecords(bytes32)":{"params":{"node":"The node to update."}},"contenthash(bytes32)":{"params":{"node":"The ENS node to query."},"returns":{"_0":"The associated contenthash."}},"dnsRecord(bytes32,bytes32,uint16)":{"params":{"name":"the keccak-256 hash of the fully-qualified name for which to fetch the record","node":"the namehash of the node for which to fetch the record","resource":"the ID of the resource as per https://en.wikipedia.org/wiki/List_of_DNS_record_types"},"returns":{"_0":"the DNS record in wire format if present, otherwise empty"}},"hasAddr(bytes32,uint256)":{"params":{"coinType":"The coin type.","node":"The node to query."},"returns":{"_0":"True if the associated address is not empty."}},"hasDNSRecords(bytes32,bytes32)":{"params":{"name":"the namehash of the node for which to check the records","node":"the namehash of the node for which to check the records"}},"interfaceImplementer(bytes32,bytes4)":{"params":{"interfaceID":"The EIP 165 interface ID to check for.","node":"The ENS node to query."},"returns":{"_0":"The address that implements this interface, or 0 if the interface is unsupported."}},"isApprovedFor(address,bytes32,address)":{"details":"Check to see if the delegate has been approved by the owner for the node."},"isApprovedForAll(address,address)":{"details":"See {IERC1155-isApprovedForAll}."},"name(bytes32)":{"params":{"node":"The ENS node to query."},"returns":{"_0":"The associated name."}},"pubkey(bytes32)":{"params":{"node":"The ENS node to query"},"returns":{"x":"The X coordinate of the curve point for the public key.","y":"The Y coordinate of the curve point for the public key."}},"setABI(bytes32,uint256,bytes)":{"params":{"contentType":"The content type of the ABI","data":"The ABI data.","node":"The node to update."}},"setAddr(bytes32,address)":{"params":{"_addr":"The address to set.","node":"The node to update."}},"setAddr(bytes32,uint256,bytes)":{"params":{"addressBytes":"The address to set.","coinType":"The coin type.","node":"The node to update."}},"setApprovalForAll(address,bool)":{"details":"See {IERC1155-setApprovalForAll}."},"setContenthash(bytes32,bytes)":{"params":{"hash":"The contenthash to set","node":"The node to update."}},"setDNSRecords(bytes32,bytes)":{"params":{"data":"the DNS wire format records to set","node":"the namehash of the node for which to set the records"}},"setInterface(bytes32,bytes4,address)":{"params":{"implementer":"The address of a contract that implements this interface for this node.","interfaceID":"The EIP 165 interface ID.","node":"The node to update."}},"setName(bytes32,string)":{"params":{"node":"The node to update."}},"setPubkey(bytes32,bytes32,bytes32)":{"params":{"node":"The ENS node to query","x":"the X coordinate of the curve point for the public key.","y":"the Y coordinate of the curve point for the public key."}},"setText(bytes32,string,string)":{"params":{"key":"The key to set.","node":"The node to update.","value":"The text data value to set."}},"setZonehash(bytes32,bytes)":{"params":{"hash":"The zonehash to set","node":"The node to update."}},"text(bytes32,string)":{"params":{"key":"The text data key to query.","node":"The ENS node to query."},"returns":{"_0":"The associated text data."}},"zonehash(bytes32)":{"params":{"node":"The ENS node to query."},"returns":{"_0":"The associated contenthash."}}},"version":1},"userdoc":{"errors":{"InvalidEVMAddress(bytes)":[{"notice":"The supplied address could not be converted to `address`."}]},"kind":"user","methods":{"ABI(bytes32,uint256)":{"notice":"Returns the ABI associated with an ENS node. Defined in EIP205."},"addr(bytes32)":{"notice":"Get `addr(60)` as `address` of the associated ENS node."},"addr(bytes32,uint256)":{"notice":"Get the address for coin type of the associated ENS node.         If coin type is EVM and empty, defaults to `addr(COIN_TYPE_DEFAULT)`."},"clearRecords(bytes32)":{"notice":"Increments the record version associated with an ENS node. May only be called by the owner of that node in the ENS registry."},"contenthash(bytes32)":{"notice":"Returns the contenthash associated with an ENS node."},"dnsRecord(bytes32,bytes32,uint16)":{"notice":"Obtain a DNS record."},"hasAddr(bytes32,uint256)":{"notice":"Determine if an addresss is stored for the coin type of the associated ENS node."},"hasDNSRecords(bytes32,bytes32)":{"notice":"Check if a given node has records."},"interfaceImplementer(bytes32,bytes4)":{"notice":"Returns the address of a contract that implements the specified interface for this name. If an implementer has not been set for this interfaceID and name, the resolver will query the contract at `addr()`. If `addr()` is set, a contract exists at that address, and that contract implements EIP165 and returns `true` for the specified interfaceID, its address will be returned."},"name(bytes32)":{"notice":"Returns the name associated with an ENS node, for reverse records. Defined in EIP181."},"pubkey(bytes32)":{"notice":"Returns the SECP256k1 public key associated with an ENS node. Defined in EIP 619."},"setABI(bytes32,uint256,bytes)":{"notice":"Sets the ABI associated with an ENS node. Nodes may have one ABI of each content type. To remove an ABI, set it to the empty string."},"setAddr(bytes32,address)":{"notice":"Set `addr(60)` of the associated ENS node.         `address(0)` is stored as `new bytes(20)`."},"setAddr(bytes32,uint256,bytes)":{"notice":"Set the address for coin type of the associated ENS node.         Reverts `InvalidEVMAddress` if coin type is EVM and not 0 or 20 bytes."},"setContenthash(bytes32,bytes)":{"notice":"Sets the contenthash associated with an ENS node. May only be called by the owner of that node in the ENS registry."},"setDNSRecords(bytes32,bytes)":{"notice":"Set one or more DNS records.  Records are supplied in wire-format. Records with the same node/name/resource must be supplied one after the other to ensure the data is updated correctly. For example, if the data was supplied:     a.example.com IN A 1.2.3.4     a.example.com IN A 5.6.7.8     www.example.com IN CNAME a.example.com. then this would store the two A records for a.example.com correctly as a single RRSET, however if the data was supplied:     a.example.com IN A 1.2.3.4     www.example.com IN CNAME a.example.com.     a.example.com IN A 5.6.7.8 then this would store the first A record, the CNAME, then the second A record which would overwrite the first."},"setInterface(bytes32,bytes4,address)":{"notice":"Sets an interface associated with a name. Setting the address to 0 restores the default behaviour of querying the contract at `addr()` for interface support."},"setName(bytes32,string)":{"notice":"Sets the name associated with an ENS node, for reverse records. May only be called by the owner of that node in the ENS registry."},"setPubkey(bytes32,bytes32,bytes32)":{"notice":"Sets the SECP256k1 public key associated with an ENS node."},"setText(bytes32,string,string)":{"notice":"Sets the text data associated with an ENS node and key. May only be called by the owner of that node in the ENS registry."},"setZonehash(bytes32,bytes)":{"notice":"setZonehash sets the hash for the zone. May only be called by the owner of that node in the ENS registry."},"text(bytes32,string)":{"notice":"Returns the text data associated with an ENS node and key."},"zonehash(bytes32)":{"notice":"zonehash obtains the hash for the zone."}},"notice":"A simple resolver anyone can use; only allows the owner of a node to set its address.","version":1},"storageLayout":{"storage":[{"astId":23702,"contract":"contracts/resolvers/PublicResolver.sol:PublicResolver","label":"recordVersions","offset":0,"slot":"0","type":"t_mapping(t_bytes32,t_uint64)"},{"astId":23796,"contract":"contracts/resolvers/PublicResolver.sol:PublicResolver","label":"versionable_abis","offset":0,"slot":"1","type":"t_mapping(t_uint64,t_mapping(t_bytes32,t_mapping(t_uint256,t_bytes_storage)))"},{"astId":23963,"contract":"contracts/resolvers/PublicResolver.sol:PublicResolver","label":"versionable_addresses","offset":0,"slot":"2","type":"t_mapping(t_uint64,t_mapping(t_bytes32,t_mapping(t_uint256,t_bytes_storage)))"},{"astId":24205,"contract":"contracts/resolvers/PublicResolver.sol:PublicResolver","label":"versionable_hashes","offset":0,"slot":"3","type":"t_mapping(t_uint64,t_mapping(t_bytes32,t_bytes_storage))"},{"astId":24295,"contract":"contracts/resolvers/PublicResolver.sol:PublicResolver","label":"versionable_zonehashes","offset":0,"slot":"4","type":"t_mapping(t_uint64,t_mapping(t_bytes32,t_bytes_storage))"},{"astId":24305,"contract":"contracts/resolvers/PublicResolver.sol:PublicResolver","label":"versionable_records","offset":0,"slot":"5","type":"t_mapping(t_uint64,t_mapping(t_bytes32,t_mapping(t_bytes32,t_mapping(t_uint16,t_bytes_storage))))"},{"astId":24313,"contract":"contracts/resolvers/PublicResolver.sol:PublicResolver","label":"versionable_nameEntriesCount","offset":0,"slot":"6","type":"t_mapping(t_uint64,t_mapping(t_bytes32,t_mapping(t_bytes32,t_uint16)))"},{"astId":25814,"contract":"contracts/resolvers/PublicResolver.sol:PublicResolver","label":"versionable_interfaces","offset":0,"slot":"7","type":"t_mapping(t_uint64,t_mapping(t_bytes32,t_mapping(t_bytes4,t_address)))"},{"astId":26006,"contract":"contracts/resolvers/PublicResolver.sol:PublicResolver","label":"versionable_names","offset":0,"slot":"8","type":"t_mapping(t_uint64,t_mapping(t_bytes32,t_string_storage))"},{"astId":26093,"contract":"contracts/resolvers/PublicResolver.sol:PublicResolver","label":"versionable_pubkeys","offset":0,"slot":"9","type":"t_mapping(t_uint64,t_mapping(t_bytes32,t_struct(PublicKey)26086_storage))"},{"astId":26196,"contract":"contracts/resolvers/PublicResolver.sol:PublicResolver","label":"versionable_texts","offset":0,"slot":"10","type":"t_mapping(t_uint64,t_mapping(t_bytes32,t_mapping(t_string_memory_ptr,t_string_storage)))"},{"astId":23231,"contract":"contracts/resolvers/PublicResolver.sol:PublicResolver","label":"_operatorApprovals","offset":0,"slot":"11","type":"t_mapping(t_address,t_mapping(t_address,t_bool))"},{"astId":23240,"contract":"contracts/resolvers/PublicResolver.sol:PublicResolver","label":"_tokenApprovals","offset":0,"slot":"12","type":"t_mapping(t_address,t_mapping(t_bytes32,t_mapping(t_address,t_bool)))"}],"types":{"t_address":{"encoding":"inplace","label":"address","numberOfBytes":"20"},"t_bool":{"encoding":"inplace","label":"bool","numberOfBytes":"1"},"t_bytes32":{"encoding":"inplace","label":"bytes32","numberOfBytes":"32"},"t_bytes4":{"encoding":"inplace","label":"bytes4","numberOfBytes":"4"},"t_bytes_storage":{"encoding":"bytes","label":"bytes","numberOfBytes":"32"},"t_mapping(t_address,t_bool)":{"encoding":"mapping","key":"t_address","label":"mapping(address => bool)","numberOfBytes":"32","value":"t_bool"},"t_mapping(t_address,t_mapping(t_address,t_bool))":{"encoding":"mapping","key":"t_address","label":"mapping(address => mapping(address => bool))","numberOfBytes":"32","value":"t_mapping(t_address,t_bool)"},"t_mapping(t_address,t_mapping(t_bytes32,t_mapping(t_address,t_bool)))":{"encoding":"mapping","key":"t_address","label":"mapping(address => mapping(bytes32 => mapping(address => bool)))","numberOfBytes":"32","value":"t_mapping(t_bytes32,t_mapping(t_address,t_bool))"},"t_mapping(t_bytes32,t_bytes_storage)":{"encoding":"mapping","key":"t_bytes32","label":"mapping(bytes32 => bytes)","numberOfBytes":"32","value":"t_bytes_storage"},"t_mapping(t_bytes32,t_mapping(t_address,t_bool))":{"encoding":"mapping","key":"t_bytes32","label":"mapping(bytes32 => mapping(address => bool))","numberOfBytes":"32","value":"t_mapping(t_address,t_bool)"},"t_mapping(t_bytes32,t_mapping(t_bytes32,t_mapping(t_uint16,t_bytes_storage)))":{"encoding":"mapping","key":"t_bytes32","label":"mapping(bytes32 => mapping(bytes32 => mapping(uint16 => bytes)))","numberOfBytes":"32","value":"t_mapping(t_bytes32,t_mapping(t_uint16,t_bytes_storage))"},"t_mapping(t_bytes32,t_mapping(t_bytes32,t_uint16))":{"encoding":"mapping","key":"t_bytes32","label":"mapping(bytes32 => mapping(bytes32 => uint16))","numberOfBytes":"32","value":"t_mapping(t_bytes32,t_uint16)"},"t_mapping(t_bytes32,t_mapping(t_bytes4,t_address))":{"encoding":"mapping","key":"t_bytes32","label":"mapping(bytes32 => mapping(bytes4 => address))","numberOfBytes":"32","value":"t_mapping(t_bytes4,t_address)"},"t_mapping(t_bytes32,t_mapping(t_string_memory_ptr,t_string_storage))":{"encoding":"mapping","key":"t_bytes32","label":"mapping(bytes32 => mapping(string => string))","numberOfBytes":"32","value":"t_mapping(t_string_memory_ptr,t_string_storage)"},"t_mapping(t_bytes32,t_mapping(t_uint16,t_bytes_storage))":{"encoding":"mapping","key":"t_bytes32","label":"mapping(bytes32 => mapping(uint16 => bytes))","numberOfBytes":"32","value":"t_mapping(t_uint16,t_bytes_storage)"},"t_mapping(t_bytes32,t_mapping(t_uint256,t_bytes_storage))":{"encoding":"mapping","key":"t_bytes32","label":"mapping(bytes32 => mapping(uint256 => bytes))","numberOfBytes":"32","value":"t_mapping(t_uint256,t_bytes_storage)"},"t_mapping(t_bytes32,t_string_storage)":{"encoding":"mapping","key":"t_bytes32","label":"mapping(bytes32 => string)","numberOfBytes":"32","value":"t_string_storage"},"t_mapping(t_bytes32,t_struct(PublicKey)26086_storage)":{"encoding":"mapping","key":"t_bytes32","label":"mapping(bytes32 => struct PubkeyResolver.PublicKey)","numberOfBytes":"32","value":"t_struct(PublicKey)26086_storage"},"t_mapping(t_bytes32,t_uint16)":{"encoding":"mapping","key":"t_bytes32","label":"mapping(bytes32 => uint16)","numberOfBytes":"32","value":"t_uint16"},"t_mapping(t_bytes32,t_uint64)":{"encoding":"mapping","key":"t_bytes32","label":"mapping(bytes32 => uint64)","numberOfBytes":"32","value":"t_uint64"},"t_mapping(t_bytes4,t_address)":{"encoding":"mapping","key":"t_bytes4","label":"mapping(bytes4 => address)","numberOfBytes":"32","value":"t_address"},"t_mapping(t_string_memory_ptr,t_string_storage)":{"encoding":"mapping","key":"t_string_memory_ptr","label":"mapping(string => string)","numberOfBytes":"32","value":"t_string_storage"},"t_mapping(t_uint16,t_bytes_storage)":{"encoding":"mapping","key":"t_uint16","label":"mapping(uint16 => bytes)","numberOfBytes":"32","value":"t_bytes_storage"},"t_mapping(t_uint256,t_bytes_storage)":{"encoding":"mapping","key":"t_uint256","label":"mapping(uint256 => bytes)","numberOfBytes":"32","value":"t_bytes_storage"},"t_mapping(t_uint64,t_mapping(t_bytes32,t_bytes_storage))":{"encoding":"mapping","key":"t_uint64","label":"mapping(uint64 => mapping(bytes32 => bytes))","numberOfBytes":"32","value":"t_mapping(t_bytes32,t_bytes_storage)"},"t_mapping(t_uint64,t_mapping(t_bytes32,t_mapping(t_bytes32,t_mapping(t_uint16,t_bytes_storage))))":{"encoding":"mapping","key":"t_uint64","label":"mapping(uint64 => mapping(bytes32 => mapping(bytes32 => mapping(uint16 => bytes))))","numberOfBytes":"32","value":"t_mapping(t_bytes32,t_mapping(t_bytes32,t_mapping(t_uint16,t_bytes_storage)))"},"t_mapping(t_uint64,t_mapping(t_bytes32,t_mapping(t_bytes32,t_uint16)))":{"encoding":"mapping","key":"t_uint64","label":"mapping(uint64 => mapping(bytes32 => mapping(bytes32 => uint16)))","numberOfBytes":"32","value":"t_mapping(t_bytes32,t_mapping(t_bytes32,t_uint16))"},"t_mapping(t_uint64,t_mapping(t_bytes32,t_mapping(t_bytes4,t_address)))":{"encoding":"mapping","key":"t_uint64","label":"mapping(uint64 => mapping(bytes32 => mapping(bytes4 => address)))","numberOfBytes":"32","value":"t_mapping(t_bytes32,t_mapping(t_bytes4,t_address))"},"t_mapping(t_uint64,t_mapping(t_bytes32,t_mapping(t_string_memory_ptr,t_string_storage)))":{"encoding":"mapping","key":"t_uint64","label":"mapping(uint64 => mapping(bytes32 => mapping(string => string)))","numberOfBytes":"32","value":"t_mapping(t_bytes32,t_mapping(t_string_memory_ptr,t_string_storage))"},"t_mapping(t_uint64,t_mapping(t_bytes32,t_mapping(t_uint256,t_bytes_storage)))":{"encoding":"mapping","key":"t_uint64","label":"mapping(uint64 => mapping(bytes32 => mapping(uint256 => bytes)))","numberOfBytes":"32","value":"t_mapping(t_bytes32,t_mapping(t_uint256,t_bytes_storage))"},"t_mapping(t_uint64,t_mapping(t_bytes32,t_string_storage))":{"encoding":"mapping","key":"t_uint64","label":"mapping(uint64 => mapping(bytes32 => string))","numberOfBytes":"32","value":"t_mapping(t_bytes32,t_string_storage)"},"t_mapping(t_uint64,t_mapping(t_bytes32,t_struct(PublicKey)26086_storage))":{"encoding":"mapping","key":"t_uint64","label":"mapping(uint64 => mapping(bytes32 => struct PubkeyResolver.PublicKey))","numberOfBytes":"32","value":"t_mapping(t_bytes32,t_struct(PublicKey)26086_storage)"},"t_string_memory_ptr":{"encoding":"bytes","label":"string","numberOfBytes":"32"},"t_string_storage":{"encoding":"bytes","label":"string","numberOfBytes":"32"},"t_struct(PublicKey)26086_storage":{"encoding":"inplace","label":"struct PubkeyResolver.PublicKey","members":[{"astId":26083,"contract":"contracts/resolvers/PublicResolver.sol:PublicResolver","label":"x","offset":0,"slot":"0","type":"t_bytes32"},{"astId":26085,"contract":"contracts/resolvers/PublicResolver.sol:PublicResolver","label":"y","offset":0,"slot":"1","type":"t_bytes32"}],"numberOfBytes":"64"},"t_uint16":{"encoding":"inplace","label":"uint16","numberOfBytes":"2"},"t_uint256":{"encoding":"inplace","label":"uint256","numberOfBytes":"32"},"t_uint64":{"encoding":"inplace","label":"uint64","numberOfBytes":"8"}}}}');

/***/ }),

/***/ "(rsc)/../../node_modules/@agentic-trust/8004-ext-sdk/dist/abis/ReputationRegistry.json":
/*!****************************************************************************************!*\
  !*** ../../node_modules/@agentic-trust/8004-ext-sdk/dist/abis/ReputationRegistry.json ***!
  \****************************************************************************************/
/***/ ((module) => {

module.exports = /*#__PURE__*/JSON.parse('[{"inputs":[],"stateMutability":"nonpayable","type":"constructor"},{"inputs":[{"internalType":"address","name":"target","type":"address"}],"name":"AddressEmptyCode","type":"error"},{"inputs":[{"internalType":"address","name":"implementation","type":"address"}],"name":"ERC1967InvalidImplementation","type":"error"},{"inputs":[],"name":"ERC1967NonPayable","type":"error"},{"inputs":[],"name":"FailedCall","type":"error"},{"inputs":[],"name":"InvalidInitialization","type":"error"},{"inputs":[],"name":"NotInitializing","type":"error"},{"inputs":[{"internalType":"address","name":"owner","type":"address"}],"name":"OwnableInvalidOwner","type":"error"},{"inputs":[{"internalType":"address","name":"account","type":"address"}],"name":"OwnableUnauthorizedAccount","type":"error"},{"inputs":[],"name":"UUPSUnauthorizedCallContext","type":"error"},{"inputs":[{"internalType":"bytes32","name":"slot","type":"bytes32"}],"name":"UUPSUnsupportedProxiableUUID","type":"error"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"uint256","name":"agentId","type":"uint256"},{"indexed":true,"internalType":"address","name":"clientAddress","type":"address"},{"indexed":true,"internalType":"uint64","name":"feedbackIndex","type":"uint64"}],"name":"FeedbackRevoked","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint64","name":"version","type":"uint64"}],"name":"Initialized","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"uint256","name":"agentId","type":"uint256"},{"indexed":true,"internalType":"address","name":"clientAddress","type":"address"},{"indexed":false,"internalType":"uint64","name":"feedbackIndex","type":"uint64"},{"indexed":false,"internalType":"uint8","name":"score","type":"uint8"},{"indexed":true,"internalType":"string","name":"tag1","type":"string"},{"indexed":false,"internalType":"string","name":"tag2","type":"string"},{"indexed":false,"internalType":"string","name":"endpoint","type":"string"},{"indexed":false,"internalType":"string","name":"feedbackURI","type":"string"},{"indexed":false,"internalType":"bytes32","name":"feedbackHash","type":"bytes32"}],"name":"NewFeedback","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"previousOwner","type":"address"},{"indexed":true,"internalType":"address","name":"newOwner","type":"address"}],"name":"OwnershipTransferred","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"uint256","name":"agentId","type":"uint256"},{"indexed":true,"internalType":"address","name":"clientAddress","type":"address"},{"indexed":false,"internalType":"uint64","name":"feedbackIndex","type":"uint64"},{"indexed":true,"internalType":"address","name":"responder","type":"address"},{"indexed":false,"internalType":"string","name":"responseURI","type":"string"},{"indexed":false,"internalType":"bytes32","name":"responseHash","type":"bytes32"}],"name":"ResponseAppended","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"implementation","type":"address"}],"name":"Upgraded","type":"event"},{"inputs":[],"name":"UPGRADE_INTERFACE_VERSION","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"agentId","type":"uint256"},{"internalType":"address","name":"clientAddress","type":"address"},{"internalType":"uint64","name":"feedbackIndex","type":"uint64"},{"internalType":"string","name":"responseURI","type":"string"},{"internalType":"bytes32","name":"responseHash","type":"bytes32"}],"name":"appendResponse","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"agentId","type":"uint256"}],"name":"getClients","outputs":[{"internalType":"address[]","name":"","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getIdentityRegistry","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"agentId","type":"uint256"},{"internalType":"address","name":"clientAddress","type":"address"}],"name":"getLastIndex","outputs":[{"internalType":"uint64","name":"","type":"uint64"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"agentId","type":"uint256"},{"internalType":"address","name":"clientAddress","type":"address"},{"internalType":"uint64","name":"feedbackIndex","type":"uint64"},{"internalType":"address[]","name":"responders","type":"address[]"}],"name":"getResponseCount","outputs":[{"internalType":"uint64","name":"count","type":"uint64"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"agentId","type":"uint256"},{"internalType":"address[]","name":"clientAddresses","type":"address[]"},{"internalType":"string","name":"tag1","type":"string"},{"internalType":"string","name":"tag2","type":"string"}],"name":"getSummary","outputs":[{"internalType":"uint64","name":"count","type":"uint64"},{"internalType":"uint8","name":"averageScore","type":"uint8"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getVersion","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"uint256","name":"agentId","type":"uint256"},{"internalType":"uint8","name":"score","type":"uint8"},{"internalType":"string","name":"tag1","type":"string"},{"internalType":"string","name":"tag2","type":"string"},{"internalType":"string","name":"endpoint","type":"string"},{"internalType":"string","name":"feedbackURI","type":"string"},{"internalType":"bytes32","name":"feedbackHash","type":"bytes32"}],"name":"giveFeedback","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"identityRegistry_","type":"address"}],"name":"initialize","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"owner","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"proxiableUUID","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"agentId","type":"uint256"},{"internalType":"address[]","name":"clientAddresses","type":"address[]"},{"internalType":"string","name":"tag1","type":"string"},{"internalType":"string","name":"tag2","type":"string"},{"internalType":"bool","name":"includeRevoked","type":"bool"}],"name":"readAllFeedback","outputs":[{"internalType":"address[]","name":"clients","type":"address[]"},{"internalType":"uint64[]","name":"feedbackIndexes","type":"uint64[]"},{"internalType":"uint8[]","name":"scores","type":"uint8[]"},{"internalType":"string[]","name":"tag1s","type":"string[]"},{"internalType":"string[]","name":"tag2s","type":"string[]"},{"internalType":"bool[]","name":"revokedStatuses","type":"bool[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"agentId","type":"uint256"},{"internalType":"address","name":"clientAddress","type":"address"},{"internalType":"uint64","name":"index","type":"uint64"}],"name":"readFeedback","outputs":[{"internalType":"uint8","name":"score","type":"uint8"},{"internalType":"string","name":"tag1","type":"string"},{"internalType":"string","name":"tag2","type":"string"},{"internalType":"bool","name":"isRevoked","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"renounceOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"agentId","type":"uint256"},{"internalType":"uint64","name":"feedbackIndex","type":"uint64"}],"name":"revokeFeedback","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"newOwner","type":"address"}],"name":"transferOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"newImplementation","type":"address"},{"internalType":"bytes","name":"data","type":"bytes"}],"name":"upgradeToAndCall","outputs":[],"stateMutability":"payable","type":"function"}]');

/***/ }),

/***/ "(rsc)/../../node_modules/@agentic-trust/8004-ext-sdk/dist/abis/ValidationRegistry.json":
/*!****************************************************************************************!*\
  !*** ../../node_modules/@agentic-trust/8004-ext-sdk/dist/abis/ValidationRegistry.json ***!
  \****************************************************************************************/
/***/ ((module) => {

module.exports = /*#__PURE__*/JSON.parse('[{"inputs":[],"stateMutability":"nonpayable","type":"constructor"},{"inputs":[{"internalType":"address","name":"target","type":"address"}],"name":"AddressEmptyCode","type":"error"},{"inputs":[{"internalType":"address","name":"implementation","type":"address"}],"name":"ERC1967InvalidImplementation","type":"error"},{"inputs":[],"name":"ERC1967NonPayable","type":"error"},{"inputs":[],"name":"FailedCall","type":"error"},{"inputs":[],"name":"InvalidInitialization","type":"error"},{"inputs":[],"name":"NotInitializing","type":"error"},{"inputs":[{"internalType":"address","name":"owner","type":"address"}],"name":"OwnableInvalidOwner","type":"error"},{"inputs":[{"internalType":"address","name":"account","type":"address"}],"name":"OwnableUnauthorizedAccount","type":"error"},{"inputs":[],"name":"UUPSUnauthorizedCallContext","type":"error"},{"inputs":[{"internalType":"bytes32","name":"slot","type":"bytes32"}],"name":"UUPSUnsupportedProxiableUUID","type":"error"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint64","name":"version","type":"uint64"}],"name":"Initialized","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"previousOwner","type":"address"},{"indexed":true,"internalType":"address","name":"newOwner","type":"address"}],"name":"OwnershipTransferred","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"implementation","type":"address"}],"name":"Upgraded","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"validatorAddress","type":"address"},{"indexed":true,"internalType":"uint256","name":"agentId","type":"uint256"},{"indexed":false,"internalType":"string","name":"requestURI","type":"string"},{"indexed":true,"internalType":"bytes32","name":"requestHash","type":"bytes32"}],"name":"ValidationRequest","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"validatorAddress","type":"address"},{"indexed":true,"internalType":"uint256","name":"agentId","type":"uint256"},{"indexed":true,"internalType":"bytes32","name":"requestHash","type":"bytes32"},{"indexed":false,"internalType":"uint8","name":"response","type":"uint8"},{"indexed":false,"internalType":"string","name":"responseURI","type":"string"},{"indexed":false,"internalType":"bytes32","name":"responseHash","type":"bytes32"},{"indexed":false,"internalType":"string","name":"tag","type":"string"}],"name":"ValidationResponse","type":"event"},{"inputs":[],"name":"UPGRADE_INTERFACE_VERSION","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"agentId","type":"uint256"}],"name":"getAgentValidations","outputs":[{"internalType":"bytes32[]","name":"","type":"bytes32[]"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getIdentityRegistry","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"agentId","type":"uint256"},{"internalType":"address[]","name":"validatorAddresses","type":"address[]"},{"internalType":"string","name":"tag","type":"string"}],"name":"getSummary","outputs":[{"internalType":"uint64","name":"count","type":"uint64"},{"internalType":"uint8","name":"avgResponse","type":"uint8"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"requestHash","type":"bytes32"}],"name":"getValidationStatus","outputs":[{"internalType":"address","name":"validatorAddress","type":"address"},{"internalType":"uint256","name":"agentId","type":"uint256"},{"internalType":"uint8","name":"response","type":"uint8"},{"internalType":"bytes32","name":"responseHash","type":"bytes32"},{"internalType":"string","name":"tag","type":"string"},{"internalType":"uint256","name":"lastUpdate","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"validatorAddress","type":"address"}],"name":"getValidatorRequests","outputs":[{"internalType":"bytes32[]","name":"","type":"bytes32[]"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getVersion","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"address","name":"identityRegistry_","type":"address"}],"name":"initialize","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"owner","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"proxiableUUID","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"renounceOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"newOwner","type":"address"}],"name":"transferOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"newImplementation","type":"address"},{"internalType":"bytes","name":"data","type":"bytes"}],"name":"upgradeToAndCall","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"address","name":"validatorAddress","type":"address"},{"internalType":"uint256","name":"agentId","type":"uint256"},{"internalType":"string","name":"requestURI","type":"string"},{"internalType":"bytes32","name":"requestHash","type":"bytes32"}],"name":"validationRequest","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"requestHash","type":"bytes32"},{"internalType":"uint8","name":"response","type":"uint8"},{"internalType":"string","name":"responseURI","type":"string"},{"internalType":"bytes32","name":"responseHash","type":"bytes32"},{"internalType":"string","name":"tag","type":"string"}],"name":"validationResponse","outputs":[],"stateMutability":"nonpayable","type":"function"}]');

/***/ }),

/***/ "(rsc)/../../node_modules/@agentic-trust/8004-ext-sdk/dist/index.js":
/*!********************************************************************!*\
  !*** ../../node_modules/@agentic-trust/8004-ext-sdk/dist/index.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AIAgentAssociationClient: () => (/* reexport safe */ _AIAgentAssociationClient__WEBPACK_IMPORTED_MODULE_6__.AIAgentAssociationClient),\n/* harmony export */   AIAgentDiscoveryClient: () => (/* reexport safe */ _AIAgentDiscoveryClient__WEBPACK_IMPORTED_MODULE_8__.AIAgentDiscoveryClient),\n/* harmony export */   AIAgentENSClient: () => (/* reexport safe */ _AIAgentENSClient__WEBPACK_IMPORTED_MODULE_0__.AIAgentENSClient),\n/* harmony export */   AIAgentIdentityClient: () => (/* reexport safe */ _AIAgentIdentityClient__WEBPACK_IMPORTED_MODULE_3__.AIAgentIdentityClient),\n/* harmony export */   AIAgentL2ENSDurenClient: () => (/* reexport safe */ _AIAgentL2ENSDurenClient__WEBPACK_IMPORTED_MODULE_1__.AIAgentL2ENSDurenClient),\n/* harmony export */   AIAgentL2ENSNamespaceClient: () => (/* reexport safe */ _AIAgentL2ENSNamespaceClient__WEBPACK_IMPORTED_MODULE_2__.AIAgentL2ENSNamespaceClient),\n/* harmony export */   AIAgentReputationClient: () => (/* reexport safe */ _AIAgentReputationClient__WEBPACK_IMPORTED_MODULE_4__.AIAgentReputationClient),\n/* harmony export */   AIAgentValidationClient: () => (/* reexport safe */ _AIAgentValidationClient__WEBPACK_IMPORTED_MODULE_5__.AIAgentValidationClient),\n/* harmony export */   OrgIdentityClient: () => (/* reexport safe */ _OrgIdentityClient__WEBPACK_IMPORTED_MODULE_7__.OrgIdentityClient),\n/* harmony export */   ViemAccountProvider: () => (/* reexport safe */ _agentic_trust_8004_sdk__WEBPACK_IMPORTED_MODULE_9__.ViemAccountProvider),\n/* harmony export */   buildDid8004: () => (/* reexport safe */ _utils_did8004__WEBPACK_IMPORTED_MODULE_10__.buildDid8004),\n/* harmony export */   buildEnsDid: () => (/* reexport safe */ _utils_didEns__WEBPACK_IMPORTED_MODULE_11__.buildEnsDid),\n/* harmony export */   buildEnsDidFromAgentAndOrg: () => (/* reexport safe */ _utils_didEns__WEBPACK_IMPORTED_MODULE_11__.buildEnsDidFromAgentAndOrg),\n/* harmony export */   buildEthrDid: () => (/* reexport safe */ _utils_didEthr__WEBPACK_IMPORTED_MODULE_12__.buildEthrDid),\n/* harmony export */   parseDid8004: () => (/* reexport safe */ _utils_did8004__WEBPACK_IMPORTED_MODULE_10__.parseDid8004),\n/* harmony export */   parseEnsDid: () => (/* reexport safe */ _utils_didEns__WEBPACK_IMPORTED_MODULE_11__.parseEnsDid),\n/* harmony export */   parseEthrDid: () => (/* reexport safe */ _utils_didEthr__WEBPACK_IMPORTED_MODULE_12__.parseEthrDid),\n/* harmony export */   resolveDid8004: () => (/* reexport safe */ _utils_did8004__WEBPACK_IMPORTED_MODULE_10__.resolveDid8004)\n/* harmony export */ });\n/* harmony import */ var _AIAgentENSClient__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AIAgentENSClient */ \"(rsc)/../../node_modules/@agentic-trust/8004-ext-sdk/dist/AIAgentENSClient.js\");\n/* harmony import */ var _AIAgentL2ENSDurenClient__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./AIAgentL2ENSDurenClient */ \"(rsc)/../../node_modules/@agentic-trust/8004-ext-sdk/dist/AIAgentL2ENSDurenClient.js\");\n/* harmony import */ var _AIAgentL2ENSNamespaceClient__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./AIAgentL2ENSNamespaceClient */ \"(rsc)/../../node_modules/@agentic-trust/8004-ext-sdk/dist/AIAgentL2ENSNamespaceClient.js\");\n/* harmony import */ var _AIAgentIdentityClient__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./AIAgentIdentityClient */ \"(rsc)/../../node_modules/@agentic-trust/8004-ext-sdk/dist/AIAgentIdentityClient.js\");\n/* harmony import */ var _AIAgentReputationClient__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./AIAgentReputationClient */ \"(rsc)/../../node_modules/@agentic-trust/8004-ext-sdk/dist/AIAgentReputationClient.js\");\n/* harmony import */ var _AIAgentValidationClient__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./AIAgentValidationClient */ \"(rsc)/../../node_modules/@agentic-trust/8004-ext-sdk/dist/AIAgentValidationClient.js\");\n/* harmony import */ var _AIAgentAssociationClient__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./AIAgentAssociationClient */ \"(rsc)/../../node_modules/@agentic-trust/8004-ext-sdk/dist/AIAgentAssociationClient.js\");\n/* harmony import */ var _OrgIdentityClient__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./OrgIdentityClient */ \"(rsc)/../../node_modules/@agentic-trust/8004-ext-sdk/dist/OrgIdentityClient.js\");\n/* harmony import */ var _AIAgentDiscoveryClient__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./AIAgentDiscoveryClient */ \"(rsc)/../../node_modules/@agentic-trust/8004-ext-sdk/dist/AIAgentDiscoveryClient.js\");\n/* harmony import */ var _agentic_trust_8004_sdk__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @agentic-trust/8004-sdk */ \"(rsc)/../../node_modules/@agentic-trust/8004-sdk/dist/index.js\");\n/* harmony import */ var _utils_did8004__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./utils/did8004 */ \"(rsc)/../../node_modules/@agentic-trust/8004-ext-sdk/dist/utils/did8004.js\");\n/* harmony import */ var _utils_didEns__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./utils/didEns */ \"(rsc)/../../node_modules/@agentic-trust/8004-ext-sdk/dist/utils/didEns.js\");\n/* harmony import */ var _utils_didEthr__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./utils/didEthr */ \"(rsc)/../../node_modules/@agentic-trust/8004-ext-sdk/dist/utils/didEthr.js\");\n/**\n * ERC8004 Agentic Trust SDK\n *\n * A TypeScript SDK for managing AI agents with ENS integration,\n * identity management, and reputation systems on Ethereum L1 and L2.\n *\n * Uses AccountProvider (Ports & Adapters pattern) for chain I/O.\n */\n\n\n\n\n\n\n\n\n\n\n\n\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BhZ2VudGljLXRydXN0LzgwMDQtZXh0LXNkay9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ3NEO0FBQ2M7QUFDUTtBQUNaO0FBQ0k7QUFDQTtBQUNFO0FBQ2Q7QUFDVztBQUNKO0FBQ2U7QUFDUztBQUN6QjtBQUM5RCIsInNvdXJjZXMiOlsiL2hvbWUvYmFyYi9hYS9Bc3NvY2lhdGVkQWNjb3VudHMvbm9kZV9tb2R1bGVzL0BhZ2VudGljLXRydXN0LzgwMDQtZXh0LXNkay9kaXN0L2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogRVJDODAwNCBBZ2VudGljIFRydXN0IFNES1xuICpcbiAqIEEgVHlwZVNjcmlwdCBTREsgZm9yIG1hbmFnaW5nIEFJIGFnZW50cyB3aXRoIEVOUyBpbnRlZ3JhdGlvbixcbiAqIGlkZW50aXR5IG1hbmFnZW1lbnQsIGFuZCByZXB1dGF0aW9uIHN5c3RlbXMgb24gRXRoZXJldW0gTDEgYW5kIEwyLlxuICpcbiAqIFVzZXMgQWNjb3VudFByb3ZpZGVyIChQb3J0cyAmIEFkYXB0ZXJzIHBhdHRlcm4pIGZvciBjaGFpbiBJL08uXG4gKi9cbmV4cG9ydCB7IEFJQWdlbnRFTlNDbGllbnQgfSBmcm9tICcuL0FJQWdlbnRFTlNDbGllbnQnO1xuZXhwb3J0IHsgQUlBZ2VudEwyRU5TRHVyZW5DbGllbnQgfSBmcm9tICcuL0FJQWdlbnRMMkVOU0R1cmVuQ2xpZW50JztcbmV4cG9ydCB7IEFJQWdlbnRMMkVOU05hbWVzcGFjZUNsaWVudCB9IGZyb20gJy4vQUlBZ2VudEwyRU5TTmFtZXNwYWNlQ2xpZW50JztcbmV4cG9ydCB7IEFJQWdlbnRJZGVudGl0eUNsaWVudCB9IGZyb20gJy4vQUlBZ2VudElkZW50aXR5Q2xpZW50JztcbmV4cG9ydCB7IEFJQWdlbnRSZXB1dGF0aW9uQ2xpZW50IH0gZnJvbSAnLi9BSUFnZW50UmVwdXRhdGlvbkNsaWVudCc7XG5leHBvcnQgeyBBSUFnZW50VmFsaWRhdGlvbkNsaWVudCB9IGZyb20gJy4vQUlBZ2VudFZhbGlkYXRpb25DbGllbnQnO1xuZXhwb3J0IHsgQUlBZ2VudEFzc29jaWF0aW9uQ2xpZW50IH0gZnJvbSAnLi9BSUFnZW50QXNzb2NpYXRpb25DbGllbnQnO1xuZXhwb3J0IHsgT3JnSWRlbnRpdHlDbGllbnQgfSBmcm9tICcuL09yZ0lkZW50aXR5Q2xpZW50JztcbmV4cG9ydCB7IEFJQWdlbnREaXNjb3ZlcnlDbGllbnQsIH0gZnJvbSAnLi9BSUFnZW50RGlzY292ZXJ5Q2xpZW50JztcbmV4cG9ydCB7IFZpZW1BY2NvdW50UHJvdmlkZXIsIH0gZnJvbSAnQGFnZW50aWMtdHJ1c3QvODAwNC1zZGsnO1xuZXhwb3J0IHsgYnVpbGREaWQ4MDA0LCBwYXJzZURpZDgwMDQsIHJlc29sdmVEaWQ4MDA0LCB9IGZyb20gJy4vdXRpbHMvZGlkODAwNCc7XG5leHBvcnQgeyBidWlsZEVuc0RpZCwgYnVpbGRFbnNEaWRGcm9tQWdlbnRBbmRPcmcsIHBhcnNlRW5zRGlkLCB9IGZyb20gJy4vdXRpbHMvZGlkRW5zJztcbmV4cG9ydCB7IGJ1aWxkRXRockRpZCwgcGFyc2VFdGhyRGlkLCB9IGZyb20gJy4vdXRpbHMvZGlkRXRocic7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@agentic-trust/8004-ext-sdk/dist/index.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@agentic-trust/8004-ext-sdk/dist/utils/did8004.js":
/*!****************************************************************************!*\
  !*** ../../node_modules/@agentic-trust/8004-ext-sdk/dist/utils/did8004.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   buildDid8004: () => (/* binding */ buildDid8004),\n/* harmony export */   parseDid8004: () => (/* binding */ parseDid8004),\n/* harmony export */   resolveDid8004: () => (/* binding */ resolveDid8004)\n/* harmony export */ });\nconst DID_8004_PREFIX = 'did:8004:';\nfunction normaliseComponent(value, label) {\n    const stringValue = typeof value === 'number' ? Number.isFinite(value) ? value.toString(10) : '' : value?.toString() ?? '';\n    const trimmed = stringValue.trim();\n    if (!trimmed) {\n        throw new Error(`${label} is required to build did:8004 identifier`);\n    }\n    return trimmed;\n}\nfunction encodeIfNeeded(value, encode) {\n    return encode === false ? value : encodeURIComponent(value);\n}\n/**\n * Construct a did:8004 identifier.\n *\n * @param chainId - numeric or string chain id\n * @param agentId - agent identifier (string or number)\n * @param namespaceOrOptions - optional namespace string or options bag\n * @param options - optional options when namespace is provided as third argument\n */\nfunction buildDid8004(chainId, agentId, namespaceOrOptions, options) {\n    let namespace;\n    let opts;\n    if (typeof namespaceOrOptions === 'object' && namespaceOrOptions !== null) {\n        opts = namespaceOrOptions;\n    }\n    else {\n        namespace = namespaceOrOptions;\n        opts = options;\n    }\n    const chainComponent = normaliseComponent(chainId, 'Chain ID');\n    const agentComponent = normaliseComponent(agentId, 'Agent ID');\n    const encode = opts?.encode ?? true;\n    const fragment = opts?.fragment ? opts.fragment.replace(/^#/, '').trim() : undefined;\n    const prefix = DID_8004_PREFIX.slice(0, -1); // \"did:8004\"\n    const segments = namespace\n        ? [prefix, namespace, chainComponent, agentComponent]\n        : [prefix, chainComponent, agentComponent];\n    const baseDid = segments.join(':');\n    const didWithFragment = fragment ? `${baseDid}#${fragment}` : baseDid;\n    return encodeIfNeeded(didWithFragment, encode);\n}\n/**\n * Parse a did:8004 identifier.\n *\n * Accepts encoded or decoded strings and supports identifiers with or without\n * an intermediate namespace (e.g. did:8004:11155111:724).\n */\nfunction parseDid8004(raw) {\n    const encodedInput = (raw ?? '').toString().trim();\n    if (!encodedInput) {\n        throw new Error('Missing did:8004 identifier');\n    }\n    let decoded;\n    try {\n        decoded = decodeURIComponent(encodedInput);\n    }\n    catch (error) {\n        throw new Error(`Invalid percent-encoding in did:8004 identifier: ${error.message}`);\n    }\n    const [baseDidRaw, fragment] = decoded.split('#', 2);\n    const baseDid = baseDidRaw ?? '';\n    if (!baseDid) {\n        throw new Error(`Invalid did:8004 identifier: ${decoded}`);\n    }\n    if (!baseDid.startsWith(DID_8004_PREFIX)) {\n        throw new Error(`Invalid did:8004 identifier: ${decoded}`);\n    }\n    const parts = baseDid.split(':');\n    if (parts.length < 4 || parts[0] !== 'did' || parts[1] !== '8004') {\n        throw new Error(`Malformed did:8004 identifier: ${decoded}`);\n    }\n    let namespace;\n    let chainIndex = 2;\n    if (parts.length >= 5) {\n        namespace = parts[2];\n        chainIndex = 3;\n    }\n    const chainComponent = parts[chainIndex];\n    const agentComponent = parts.slice(chainIndex + 1).join(':');\n    if (!chainComponent) {\n        throw new Error(`Chain id missing in did:8004 identifier: ${decoded}`);\n    }\n    const chainId = Number.parseInt(chainComponent, 10);\n    if (!Number.isFinite(chainId)) {\n        throw new Error(`Invalid chain id in did:8004 identifier: ${decoded}`);\n    }\n    const agentId = agentComponent.trim();\n    if (!agentId) {\n        throw new Error(`Agent id missing in did:8004 identifier: ${decoded}`);\n    }\n    return {\n        did: baseDid,\n        method: '8004',\n        namespace,\n        chainId,\n        agentId,\n        fragment: fragment?.trim() || undefined,\n        encoded: encodeIfNeeded(baseDid + (fragment ? `#${fragment}` : ''), true),\n    };\n}\nfunction resolveDid8004(did) {\n    console.info(`Resolving DID 222: ${did}`);\n    const parts = did.split(':').slice(1);\n    const [method, networkId, agentId] = parts;\n    if (method !== 'contract') {\n        throw new Error(`Unsupported DID method: ${method}`);\n    }\n    if (!agentId) {\n        throw new Error(`Missing agentId in DID: ${did}`);\n    }\n    const controllerAddress = agentId.toLowerCase();\n    return {\n        '@context': ['https://www.w3.org/ns/did/v1'],\n        id: did,\n        verificationMethod: [\n            {\n                id: `${did}#controller`,\n                type: 'EcdsaSecp256k1RecoveryMethod2020',\n                controller: did,\n                agentId: `${controllerAddress}@eip155:${networkId}`,\n            },\n        ],\n        authentication: [`${did}#controller`],\n    };\n}\n//# sourceMappingURL=did8004.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BhZ2VudGljLXRydXN0LzgwMDQtZXh0LXNkay9kaXN0L3V0aWxzL2RpZDgwMDQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixPQUFPO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFFBQVEsR0FBRyxTQUFTO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RSxjQUFjO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELFFBQVE7QUFDaEU7QUFDQTtBQUNBLHdEQUF3RCxRQUFRO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxRQUFRO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FLFFBQVE7QUFDNUU7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FLFFBQVE7QUFDNUU7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FLFFBQVE7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxTQUFTO0FBQ25FO0FBQ0E7QUFDTztBQUNQLHVDQUF1QyxJQUFJO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxPQUFPO0FBQzFEO0FBQ0E7QUFDQSxtREFBbUQsSUFBSTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixJQUFJO0FBQzNCO0FBQ0E7QUFDQSw0QkFBNEIsa0JBQWtCLFVBQVUsVUFBVTtBQUNsRSxhQUFhO0FBQ2I7QUFDQSw0QkFBNEIsSUFBSTtBQUNoQztBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL2JhcmIvYWEvQXNzb2NpYXRlZEFjY291bnRzL25vZGVfbW9kdWxlcy9AYWdlbnRpYy10cnVzdC84MDA0LWV4dC1zZGsvZGlzdC91dGlscy9kaWQ4MDA0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IERJRF84MDA0X1BSRUZJWCA9ICdkaWQ6ODAwNDonO1xuZnVuY3Rpb24gbm9ybWFsaXNlQ29tcG9uZW50KHZhbHVlLCBsYWJlbCkge1xuICAgIGNvbnN0IHN0cmluZ1ZhbHVlID0gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyA/IE51bWJlci5pc0Zpbml0ZSh2YWx1ZSkgPyB2YWx1ZS50b1N0cmluZygxMCkgOiAnJyA6IHZhbHVlPy50b1N0cmluZygpID8/ICcnO1xuICAgIGNvbnN0IHRyaW1tZWQgPSBzdHJpbmdWYWx1ZS50cmltKCk7XG4gICAgaWYgKCF0cmltbWVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtsYWJlbH0gaXMgcmVxdWlyZWQgdG8gYnVpbGQgZGlkOjgwMDQgaWRlbnRpZmllcmApO1xuICAgIH1cbiAgICByZXR1cm4gdHJpbW1lZDtcbn1cbmZ1bmN0aW9uIGVuY29kZUlmTmVlZGVkKHZhbHVlLCBlbmNvZGUpIHtcbiAgICByZXR1cm4gZW5jb2RlID09PSBmYWxzZSA/IHZhbHVlIDogZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKTtcbn1cbi8qKlxuICogQ29uc3RydWN0IGEgZGlkOjgwMDQgaWRlbnRpZmllci5cbiAqXG4gKiBAcGFyYW0gY2hhaW5JZCAtIG51bWVyaWMgb3Igc3RyaW5nIGNoYWluIGlkXG4gKiBAcGFyYW0gYWdlbnRJZCAtIGFnZW50IGlkZW50aWZpZXIgKHN0cmluZyBvciBudW1iZXIpXG4gKiBAcGFyYW0gbmFtZXNwYWNlT3JPcHRpb25zIC0gb3B0aW9uYWwgbmFtZXNwYWNlIHN0cmluZyBvciBvcHRpb25zIGJhZ1xuICogQHBhcmFtIG9wdGlvbnMgLSBvcHRpb25hbCBvcHRpb25zIHdoZW4gbmFtZXNwYWNlIGlzIHByb3ZpZGVkIGFzIHRoaXJkIGFyZ3VtZW50XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBidWlsZERpZDgwMDQoY2hhaW5JZCwgYWdlbnRJZCwgbmFtZXNwYWNlT3JPcHRpb25zLCBvcHRpb25zKSB7XG4gICAgbGV0IG5hbWVzcGFjZTtcbiAgICBsZXQgb3B0cztcbiAgICBpZiAodHlwZW9mIG5hbWVzcGFjZU9yT3B0aW9ucyA9PT0gJ29iamVjdCcgJiYgbmFtZXNwYWNlT3JPcHRpb25zICE9PSBudWxsKSB7XG4gICAgICAgIG9wdHMgPSBuYW1lc3BhY2VPck9wdGlvbnM7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBuYW1lc3BhY2UgPSBuYW1lc3BhY2VPck9wdGlvbnM7XG4gICAgICAgIG9wdHMgPSBvcHRpb25zO1xuICAgIH1cbiAgICBjb25zdCBjaGFpbkNvbXBvbmVudCA9IG5vcm1hbGlzZUNvbXBvbmVudChjaGFpbklkLCAnQ2hhaW4gSUQnKTtcbiAgICBjb25zdCBhZ2VudENvbXBvbmVudCA9IG5vcm1hbGlzZUNvbXBvbmVudChhZ2VudElkLCAnQWdlbnQgSUQnKTtcbiAgICBjb25zdCBlbmNvZGUgPSBvcHRzPy5lbmNvZGUgPz8gdHJ1ZTtcbiAgICBjb25zdCBmcmFnbWVudCA9IG9wdHM/LmZyYWdtZW50ID8gb3B0cy5mcmFnbWVudC5yZXBsYWNlKC9eIy8sICcnKS50cmltKCkgOiB1bmRlZmluZWQ7XG4gICAgY29uc3QgcHJlZml4ID0gRElEXzgwMDRfUFJFRklYLnNsaWNlKDAsIC0xKTsgLy8gXCJkaWQ6ODAwNFwiXG4gICAgY29uc3Qgc2VnbWVudHMgPSBuYW1lc3BhY2VcbiAgICAgICAgPyBbcHJlZml4LCBuYW1lc3BhY2UsIGNoYWluQ29tcG9uZW50LCBhZ2VudENvbXBvbmVudF1cbiAgICAgICAgOiBbcHJlZml4LCBjaGFpbkNvbXBvbmVudCwgYWdlbnRDb21wb25lbnRdO1xuICAgIGNvbnN0IGJhc2VEaWQgPSBzZWdtZW50cy5qb2luKCc6Jyk7XG4gICAgY29uc3QgZGlkV2l0aEZyYWdtZW50ID0gZnJhZ21lbnQgPyBgJHtiYXNlRGlkfSMke2ZyYWdtZW50fWAgOiBiYXNlRGlkO1xuICAgIHJldHVybiBlbmNvZGVJZk5lZWRlZChkaWRXaXRoRnJhZ21lbnQsIGVuY29kZSk7XG59XG4vKipcbiAqIFBhcnNlIGEgZGlkOjgwMDQgaWRlbnRpZmllci5cbiAqXG4gKiBBY2NlcHRzIGVuY29kZWQgb3IgZGVjb2RlZCBzdHJpbmdzIGFuZCBzdXBwb3J0cyBpZGVudGlmaWVycyB3aXRoIG9yIHdpdGhvdXRcbiAqIGFuIGludGVybWVkaWF0ZSBuYW1lc3BhY2UgKGUuZy4gZGlkOjgwMDQ6MTExNTUxMTE6NzI0KS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlRGlkODAwNChyYXcpIHtcbiAgICBjb25zdCBlbmNvZGVkSW5wdXQgPSAocmF3ID8/ICcnKS50b1N0cmluZygpLnRyaW0oKTtcbiAgICBpZiAoIWVuY29kZWRJbnB1dCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgZGlkOjgwMDQgaWRlbnRpZmllcicpO1xuICAgIH1cbiAgICBsZXQgZGVjb2RlZDtcbiAgICB0cnkge1xuICAgICAgICBkZWNvZGVkID0gZGVjb2RlVVJJQ29tcG9uZW50KGVuY29kZWRJbnB1dCk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgcGVyY2VudC1lbmNvZGluZyBpbiBkaWQ6ODAwNCBpZGVudGlmaWVyOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgfVxuICAgIGNvbnN0IFtiYXNlRGlkUmF3LCBmcmFnbWVudF0gPSBkZWNvZGVkLnNwbGl0KCcjJywgMik7XG4gICAgY29uc3QgYmFzZURpZCA9IGJhc2VEaWRSYXcgPz8gJyc7XG4gICAgaWYgKCFiYXNlRGlkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBkaWQ6ODAwNCBpZGVudGlmaWVyOiAke2RlY29kZWR9YCk7XG4gICAgfVxuICAgIGlmICghYmFzZURpZC5zdGFydHNXaXRoKERJRF84MDA0X1BSRUZJWCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGRpZDo4MDA0IGlkZW50aWZpZXI6ICR7ZGVjb2RlZH1gKTtcbiAgICB9XG4gICAgY29uc3QgcGFydHMgPSBiYXNlRGlkLnNwbGl0KCc6Jyk7XG4gICAgaWYgKHBhcnRzLmxlbmd0aCA8IDQgfHwgcGFydHNbMF0gIT09ICdkaWQnIHx8IHBhcnRzWzFdICE9PSAnODAwNCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBNYWxmb3JtZWQgZGlkOjgwMDQgaWRlbnRpZmllcjogJHtkZWNvZGVkfWApO1xuICAgIH1cbiAgICBsZXQgbmFtZXNwYWNlO1xuICAgIGxldCBjaGFpbkluZGV4ID0gMjtcbiAgICBpZiAocGFydHMubGVuZ3RoID49IDUpIHtcbiAgICAgICAgbmFtZXNwYWNlID0gcGFydHNbMl07XG4gICAgICAgIGNoYWluSW5kZXggPSAzO1xuICAgIH1cbiAgICBjb25zdCBjaGFpbkNvbXBvbmVudCA9IHBhcnRzW2NoYWluSW5kZXhdO1xuICAgIGNvbnN0IGFnZW50Q29tcG9uZW50ID0gcGFydHMuc2xpY2UoY2hhaW5JbmRleCArIDEpLmpvaW4oJzonKTtcbiAgICBpZiAoIWNoYWluQ29tcG9uZW50KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2hhaW4gaWQgbWlzc2luZyBpbiBkaWQ6ODAwNCBpZGVudGlmaWVyOiAke2RlY29kZWR9YCk7XG4gICAgfVxuICAgIGNvbnN0IGNoYWluSWQgPSBOdW1iZXIucGFyc2VJbnQoY2hhaW5Db21wb25lbnQsIDEwKTtcbiAgICBpZiAoIU51bWJlci5pc0Zpbml0ZShjaGFpbklkKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgY2hhaW4gaWQgaW4gZGlkOjgwMDQgaWRlbnRpZmllcjogJHtkZWNvZGVkfWApO1xuICAgIH1cbiAgICBjb25zdCBhZ2VudElkID0gYWdlbnRDb21wb25lbnQudHJpbSgpO1xuICAgIGlmICghYWdlbnRJZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEFnZW50IGlkIG1pc3NpbmcgaW4gZGlkOjgwMDQgaWRlbnRpZmllcjogJHtkZWNvZGVkfWApO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBkaWQ6IGJhc2VEaWQsXG4gICAgICAgIG1ldGhvZDogJzgwMDQnLFxuICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgIGNoYWluSWQsXG4gICAgICAgIGFnZW50SWQsXG4gICAgICAgIGZyYWdtZW50OiBmcmFnbWVudD8udHJpbSgpIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgZW5jb2RlZDogZW5jb2RlSWZOZWVkZWQoYmFzZURpZCArIChmcmFnbWVudCA/IGAjJHtmcmFnbWVudH1gIDogJycpLCB0cnVlKSxcbiAgICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIHJlc29sdmVEaWQ4MDA0KGRpZCkge1xuICAgIGNvbnNvbGUuaW5mbyhgUmVzb2x2aW5nIERJRCAyMjI6ICR7ZGlkfWApO1xuICAgIGNvbnN0IHBhcnRzID0gZGlkLnNwbGl0KCc6Jykuc2xpY2UoMSk7XG4gICAgY29uc3QgW21ldGhvZCwgbmV0d29ya0lkLCBhZ2VudElkXSA9IHBhcnRzO1xuICAgIGlmIChtZXRob2QgIT09ICdjb250cmFjdCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBESUQgbWV0aG9kOiAke21ldGhvZH1gKTtcbiAgICB9XG4gICAgaWYgKCFhZ2VudElkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgTWlzc2luZyBhZ2VudElkIGluIERJRDogJHtkaWR9YCk7XG4gICAgfVxuICAgIGNvbnN0IGNvbnRyb2xsZXJBZGRyZXNzID0gYWdlbnRJZC50b0xvd2VyQ2FzZSgpO1xuICAgIHJldHVybiB7XG4gICAgICAgICdAY29udGV4dCc6IFsnaHR0cHM6Ly93d3cudzMub3JnL25zL2RpZC92MSddLFxuICAgICAgICBpZDogZGlkLFxuICAgICAgICB2ZXJpZmljYXRpb25NZXRob2Q6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZDogYCR7ZGlkfSNjb250cm9sbGVyYCxcbiAgICAgICAgICAgICAgICB0eXBlOiAnRWNkc2FTZWNwMjU2azFSZWNvdmVyeU1ldGhvZDIwMjAnLFxuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXI6IGRpZCxcbiAgICAgICAgICAgICAgICBhZ2VudElkOiBgJHtjb250cm9sbGVyQWRkcmVzc31AZWlwMTU1OiR7bmV0d29ya0lkfWAsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgICAgICBhdXRoZW50aWNhdGlvbjogW2Ake2RpZH0jY29udHJvbGxlcmBdLFxuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kaWQ4MDA0LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@agentic-trust/8004-ext-sdk/dist/utils/did8004.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@agentic-trust/8004-ext-sdk/dist/utils/didEns.js":
/*!***************************************************************************!*\
  !*** ../../node_modules/@agentic-trust/8004-ext-sdk/dist/utils/didEns.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   buildEnsDid: () => (/* binding */ buildEnsDid),\n/* harmony export */   buildEnsDidFromAgentAndOrg: () => (/* binding */ buildEnsDidFromAgentAndOrg),\n/* harmony export */   parseEnsDid: () => (/* binding */ parseEnsDid)\n/* harmony export */ });\nconst ENS_DID_PREFIX = 'did:ens:';\nfunction encodeIfNeeded(value, encode) {\n    return encode === false ? value : encodeURIComponent(value);\n}\n/**\n * Parse a did:ens identifier.\n *\n * Accepts encoded or decoded strings and expects format:\n *   did:ens:chainId:ensname\n */\nfunction parseEnsDid(raw) {\n    const encodedInput = (raw ?? '').toString().trim();\n    if (!encodedInput) {\n        throw new Error('Missing ENS DID parameter');\n    }\n    let decoded;\n    try {\n        decoded = decodeURIComponent(encodedInput);\n    }\n    catch (error) {\n        throw new Error(`Invalid percent-encoding in ENS DID: ${error.message}`);\n    }\n    if (!decoded.startsWith(ENS_DID_PREFIX)) {\n        throw new Error(`Invalid ENS DID format: ${decoded}. Expected format: did:ens:chainId:ensname`);\n    }\n    const parts = decoded.split(':');\n    if (parts.length < 4) {\n        throw new Error(`ENS DID missing components: ${decoded}. Expected format: did:ens:chainId:ensname`);\n    }\n    const chainIdPart = parts[2] ?? '';\n    const ensNamePart = parts.slice(3).join(':').trim();\n    const chainId = Number.parseInt(chainIdPart, 10);\n    if (!Number.isFinite(chainId) || chainId <= 0) {\n        throw new Error(`Invalid chainId in ENS DID: ${decoded}`);\n    }\n    if (!ensNamePart) {\n        throw new Error(`Invalid ENS name in ENS DID: ${decoded}`);\n    }\n    // Validate that ENS name ends with .eth\n    if (!ensNamePart.toLowerCase().endsWith('.eth')) {\n        throw new Error(`Invalid ENS name in ENS DID: ${decoded}. ENS name must end with .eth`);\n    }\n    const did = `${ENS_DID_PREFIX}${chainId}:${ensNamePart}`;\n    return {\n        did,\n        method: 'ens',\n        chainId,\n        ensName: ensNamePart,\n        encoded: encodeIfNeeded(did, true),\n    };\n}\n/**\n * Build a did:ens identifier from chain id and ENS name.\n */\nfunction buildEnsDid(chainId, ensName, options) {\n    const chainIdStr = typeof chainId === 'number'\n        ? chainId.toString(10)\n        : chainId?.toString() ?? '';\n    const ensNameStr = ensName?.toString() ?? '';\n    const normalizedChainId = chainIdStr.trim();\n    const normalizedEnsName = ensNameStr.trim();\n    if (!normalizedChainId) {\n        throw new Error('Chain ID is required to build ENS DID');\n    }\n    if (!normalizedEnsName) {\n        throw new Error('ENS name is required to build ENS DID');\n    }\n    const chainIdNum = Number.parseInt(normalizedChainId, 10);\n    if (!Number.isFinite(chainIdNum) || chainIdNum <= 0) {\n        throw new Error(`Invalid chain ID: ${normalizedChainId}`);\n    }\n    // Ensure ENS name ends with .eth (case-insensitive check)\n    const lowerEnsName = normalizedEnsName.toLowerCase();\n    if (!lowerEnsName.endsWith('.eth')) {\n        throw new Error(`Invalid ENS name: ${normalizedEnsName}. ENS name must end with .eth to be a valid did:ens`);\n    }\n    const did = `${ENS_DID_PREFIX}${chainIdNum}:${normalizedEnsName}`;\n    const encode = options?.encode ?? true;\n    return encodeIfNeeded(did, encode);\n}\n/**\n * Build an ENS DID from agent name and organization name.\n * e.g. agentName = \"my-agent\", orgName = \"org\", chainId = 11155111\n *   did:ens:11155111:my-agent.org.eth\n */\nfunction buildEnsDidFromAgentAndOrg(chainId, agentName, orgName, options) {\n    if (!agentName || typeof agentName !== 'string') {\n        throw new Error('Agent name is required');\n    }\n    if (!orgName || typeof orgName !== 'string') {\n        throw new Error('Organization name is required');\n    }\n    // Normalize agent name: lowercase and replace spaces with hyphens\n    const agentNameLabel = agentName.trim().toLowerCase().replace(/\\s+/g, '-');\n    if (!agentNameLabel) {\n        throw new Error('Agent name cannot be empty');\n    }\n    // Normalize org name: lowercase and remove .eth suffix if present\n    const orgNameClean = orgName.trim().toLowerCase().replace(/\\.eth$/i, '');\n    if (!orgNameClean) {\n        throw new Error('Organization name cannot be empty');\n    }\n    // Construct full ENS name: agentName.orgName.eth\n    const fullEnsName = `${agentNameLabel}.${orgNameClean}.eth`;\n    return buildEnsDid(chainId, fullEnsName, options);\n}\n//# sourceMappingURL=didEns.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BhZ2VudGljLXRydXN0LzgwMDQtZXh0LXNkay9kaXN0L3V0aWxzL2RpZEVucy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLGNBQWM7QUFDOUU7QUFDQTtBQUNBLG1EQUFtRCxRQUFRO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxRQUFRO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsUUFBUTtBQUMvRDtBQUNBO0FBQ0Esd0RBQXdELFFBQVE7QUFDaEU7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELFFBQVE7QUFDaEU7QUFDQSxtQkFBbUIsZUFBZSxFQUFFLFFBQVEsR0FBRyxZQUFZO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsa0JBQWtCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLGtCQUFrQjtBQUMvRDtBQUNBLG1CQUFtQixlQUFlLEVBQUUsV0FBVyxHQUFHLGtCQUFrQjtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGVBQWUsR0FBRyxhQUFhO0FBQzFEO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvYmFyYi9hYS9Bc3NvY2lhdGVkQWNjb3VudHMvbm9kZV9tb2R1bGVzL0BhZ2VudGljLXRydXN0LzgwMDQtZXh0LXNkay9kaXN0L3V0aWxzL2RpZEVucy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBFTlNfRElEX1BSRUZJWCA9ICdkaWQ6ZW5zOic7XG5mdW5jdGlvbiBlbmNvZGVJZk5lZWRlZCh2YWx1ZSwgZW5jb2RlKSB7XG4gICAgcmV0dXJuIGVuY29kZSA9PT0gZmFsc2UgPyB2YWx1ZSA6IGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSk7XG59XG4vKipcbiAqIFBhcnNlIGEgZGlkOmVucyBpZGVudGlmaWVyLlxuICpcbiAqIEFjY2VwdHMgZW5jb2RlZCBvciBkZWNvZGVkIHN0cmluZ3MgYW5kIGV4cGVjdHMgZm9ybWF0OlxuICogICBkaWQ6ZW5zOmNoYWluSWQ6ZW5zbmFtZVxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VFbnNEaWQocmF3KSB7XG4gICAgY29uc3QgZW5jb2RlZElucHV0ID0gKHJhdyA/PyAnJykudG9TdHJpbmcoKS50cmltKCk7XG4gICAgaWYgKCFlbmNvZGVkSW5wdXQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIEVOUyBESUQgcGFyYW1ldGVyJyk7XG4gICAgfVxuICAgIGxldCBkZWNvZGVkO1xuICAgIHRyeSB7XG4gICAgICAgIGRlY29kZWQgPSBkZWNvZGVVUklDb21wb25lbnQoZW5jb2RlZElucHV0KTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBwZXJjZW50LWVuY29kaW5nIGluIEVOUyBESUQ6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICB9XG4gICAgaWYgKCFkZWNvZGVkLnN0YXJ0c1dpdGgoRU5TX0RJRF9QUkVGSVgpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBFTlMgRElEIGZvcm1hdDogJHtkZWNvZGVkfS4gRXhwZWN0ZWQgZm9ybWF0OiBkaWQ6ZW5zOmNoYWluSWQ6ZW5zbmFtZWApO1xuICAgIH1cbiAgICBjb25zdCBwYXJ0cyA9IGRlY29kZWQuc3BsaXQoJzonKTtcbiAgICBpZiAocGFydHMubGVuZ3RoIDwgNCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEVOUyBESUQgbWlzc2luZyBjb21wb25lbnRzOiAke2RlY29kZWR9LiBFeHBlY3RlZCBmb3JtYXQ6IGRpZDplbnM6Y2hhaW5JZDplbnNuYW1lYCk7XG4gICAgfVxuICAgIGNvbnN0IGNoYWluSWRQYXJ0ID0gcGFydHNbMl0gPz8gJyc7XG4gICAgY29uc3QgZW5zTmFtZVBhcnQgPSBwYXJ0cy5zbGljZSgzKS5qb2luKCc6JykudHJpbSgpO1xuICAgIGNvbnN0IGNoYWluSWQgPSBOdW1iZXIucGFyc2VJbnQoY2hhaW5JZFBhcnQsIDEwKTtcbiAgICBpZiAoIU51bWJlci5pc0Zpbml0ZShjaGFpbklkKSB8fCBjaGFpbklkIDw9IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGNoYWluSWQgaW4gRU5TIERJRDogJHtkZWNvZGVkfWApO1xuICAgIH1cbiAgICBpZiAoIWVuc05hbWVQYXJ0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBFTlMgbmFtZSBpbiBFTlMgRElEOiAke2RlY29kZWR9YCk7XG4gICAgfVxuICAgIC8vIFZhbGlkYXRlIHRoYXQgRU5TIG5hbWUgZW5kcyB3aXRoIC5ldGhcbiAgICBpZiAoIWVuc05hbWVQYXJ0LnRvTG93ZXJDYXNlKCkuZW5kc1dpdGgoJy5ldGgnKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgRU5TIG5hbWUgaW4gRU5TIERJRDogJHtkZWNvZGVkfS4gRU5TIG5hbWUgbXVzdCBlbmQgd2l0aCAuZXRoYCk7XG4gICAgfVxuICAgIGNvbnN0IGRpZCA9IGAke0VOU19ESURfUFJFRklYfSR7Y2hhaW5JZH06JHtlbnNOYW1lUGFydH1gO1xuICAgIHJldHVybiB7XG4gICAgICAgIGRpZCxcbiAgICAgICAgbWV0aG9kOiAnZW5zJyxcbiAgICAgICAgY2hhaW5JZCxcbiAgICAgICAgZW5zTmFtZTogZW5zTmFtZVBhcnQsXG4gICAgICAgIGVuY29kZWQ6IGVuY29kZUlmTmVlZGVkKGRpZCwgdHJ1ZSksXG4gICAgfTtcbn1cbi8qKlxuICogQnVpbGQgYSBkaWQ6ZW5zIGlkZW50aWZpZXIgZnJvbSBjaGFpbiBpZCBhbmQgRU5TIG5hbWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBidWlsZEVuc0RpZChjaGFpbklkLCBlbnNOYW1lLCBvcHRpb25zKSB7XG4gICAgY29uc3QgY2hhaW5JZFN0ciA9IHR5cGVvZiBjaGFpbklkID09PSAnbnVtYmVyJ1xuICAgICAgICA/IGNoYWluSWQudG9TdHJpbmcoMTApXG4gICAgICAgIDogY2hhaW5JZD8udG9TdHJpbmcoKSA/PyAnJztcbiAgICBjb25zdCBlbnNOYW1lU3RyID0gZW5zTmFtZT8udG9TdHJpbmcoKSA/PyAnJztcbiAgICBjb25zdCBub3JtYWxpemVkQ2hhaW5JZCA9IGNoYWluSWRTdHIudHJpbSgpO1xuICAgIGNvbnN0IG5vcm1hbGl6ZWRFbnNOYW1lID0gZW5zTmFtZVN0ci50cmltKCk7XG4gICAgaWYgKCFub3JtYWxpemVkQ2hhaW5JZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NoYWluIElEIGlzIHJlcXVpcmVkIHRvIGJ1aWxkIEVOUyBESUQnKTtcbiAgICB9XG4gICAgaWYgKCFub3JtYWxpemVkRW5zTmFtZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VOUyBuYW1lIGlzIHJlcXVpcmVkIHRvIGJ1aWxkIEVOUyBESUQnKTtcbiAgICB9XG4gICAgY29uc3QgY2hhaW5JZE51bSA9IE51bWJlci5wYXJzZUludChub3JtYWxpemVkQ2hhaW5JZCwgMTApO1xuICAgIGlmICghTnVtYmVyLmlzRmluaXRlKGNoYWluSWROdW0pIHx8IGNoYWluSWROdW0gPD0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgY2hhaW4gSUQ6ICR7bm9ybWFsaXplZENoYWluSWR9YCk7XG4gICAgfVxuICAgIC8vIEVuc3VyZSBFTlMgbmFtZSBlbmRzIHdpdGggLmV0aCAoY2FzZS1pbnNlbnNpdGl2ZSBjaGVjaylcbiAgICBjb25zdCBsb3dlckVuc05hbWUgPSBub3JtYWxpemVkRW5zTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIGlmICghbG93ZXJFbnNOYW1lLmVuZHNXaXRoKCcuZXRoJykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIEVOUyBuYW1lOiAke25vcm1hbGl6ZWRFbnNOYW1lfS4gRU5TIG5hbWUgbXVzdCBlbmQgd2l0aCAuZXRoIHRvIGJlIGEgdmFsaWQgZGlkOmVuc2ApO1xuICAgIH1cbiAgICBjb25zdCBkaWQgPSBgJHtFTlNfRElEX1BSRUZJWH0ke2NoYWluSWROdW19OiR7bm9ybWFsaXplZEVuc05hbWV9YDtcbiAgICBjb25zdCBlbmNvZGUgPSBvcHRpb25zPy5lbmNvZGUgPz8gdHJ1ZTtcbiAgICByZXR1cm4gZW5jb2RlSWZOZWVkZWQoZGlkLCBlbmNvZGUpO1xufVxuLyoqXG4gKiBCdWlsZCBhbiBFTlMgRElEIGZyb20gYWdlbnQgbmFtZSBhbmQgb3JnYW5pemF0aW9uIG5hbWUuXG4gKiBlLmcuIGFnZW50TmFtZSA9IFwibXktYWdlbnRcIiwgb3JnTmFtZSA9IFwib3JnXCIsIGNoYWluSWQgPSAxMTE1NTExMVxuICogIOKGkiBkaWQ6ZW5zOjExMTU1MTExOm15LWFnZW50Lm9yZy5ldGhcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkRW5zRGlkRnJvbUFnZW50QW5kT3JnKGNoYWluSWQsIGFnZW50TmFtZSwgb3JnTmFtZSwgb3B0aW9ucykge1xuICAgIGlmICghYWdlbnROYW1lIHx8IHR5cGVvZiBhZ2VudE5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQWdlbnQgbmFtZSBpcyByZXF1aXJlZCcpO1xuICAgIH1cbiAgICBpZiAoIW9yZ05hbWUgfHwgdHlwZW9mIG9yZ05hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignT3JnYW5pemF0aW9uIG5hbWUgaXMgcmVxdWlyZWQnKTtcbiAgICB9XG4gICAgLy8gTm9ybWFsaXplIGFnZW50IG5hbWU6IGxvd2VyY2FzZSBhbmQgcmVwbGFjZSBzcGFjZXMgd2l0aCBoeXBoZW5zXG4gICAgY29uc3QgYWdlbnROYW1lTGFiZWwgPSBhZ2VudE5hbWUudHJpbSgpLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvXFxzKy9nLCAnLScpO1xuICAgIGlmICghYWdlbnROYW1lTGFiZWwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBZ2VudCBuYW1lIGNhbm5vdCBiZSBlbXB0eScpO1xuICAgIH1cbiAgICAvLyBOb3JtYWxpemUgb3JnIG5hbWU6IGxvd2VyY2FzZSBhbmQgcmVtb3ZlIC5ldGggc3VmZml4IGlmIHByZXNlbnRcbiAgICBjb25zdCBvcmdOYW1lQ2xlYW4gPSBvcmdOYW1lLnRyaW0oKS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL1xcLmV0aCQvaSwgJycpO1xuICAgIGlmICghb3JnTmFtZUNsZWFuKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignT3JnYW5pemF0aW9uIG5hbWUgY2Fubm90IGJlIGVtcHR5Jyk7XG4gICAgfVxuICAgIC8vIENvbnN0cnVjdCBmdWxsIEVOUyBuYW1lOiBhZ2VudE5hbWUub3JnTmFtZS5ldGhcbiAgICBjb25zdCBmdWxsRW5zTmFtZSA9IGAke2FnZW50TmFtZUxhYmVsfS4ke29yZ05hbWVDbGVhbn0uZXRoYDtcbiAgICByZXR1cm4gYnVpbGRFbnNEaWQoY2hhaW5JZCwgZnVsbEVuc05hbWUsIG9wdGlvbnMpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGlkRW5zLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@agentic-trust/8004-ext-sdk/dist/utils/didEns.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@agentic-trust/8004-ext-sdk/dist/utils/didEthr.js":
/*!****************************************************************************!*\
  !*** ../../node_modules/@agentic-trust/8004-ext-sdk/dist/utils/didEthr.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   buildEthrDid: () => (/* binding */ buildEthrDid),\n/* harmony export */   parseEthrDid: () => (/* binding */ parseEthrDid)\n/* harmony export */ });\nconst ETHR_DID_PREFIX = 'did:ethr:';\nfunction encodeIfNeeded(value, encode) {\n    return encode === false ? value : encodeURIComponent(value);\n}\n/**\n * Parse a did:ethr identifier.\n *\n * Accepts encoded or decoded strings and supports:\n *   did:ethr:chainId:0x..., did:ethr:0x...\n */\nfunction parseEthrDid(raw) {\n    const encodedInput = (raw ?? '').toString().trim();\n    if (!encodedInput) {\n        throw new Error('Missing ETHR DID parameter');\n    }\n    let decoded;\n    try {\n        decoded = decodeURIComponent(encodedInput);\n    }\n    catch (error) {\n        throw new Error(`Invalid percent-encoding in ETHR DID: ${error.message}`);\n    }\n    if (!decoded.startsWith(ETHR_DID_PREFIX)) {\n        throw new Error(`Invalid ETHR DID format: ${decoded}. Expected format: did:ethr:chainId:account or did:ethr:account`);\n    }\n    const segments = decoded.split(':');\n    const accountCandidate = segments[segments.length - 1];\n    if (!accountCandidate || !accountCandidate.startsWith('0x')) {\n        throw new Error('ETHR DID is missing account component');\n    }\n    const remaining = segments.slice(2, -1);\n    let chainId = 0;\n    for (let i = remaining.length - 1; i >= 0; i -= 1) {\n        const value = remaining[i];\n        if (value && /^\\d+$/.test(value)) {\n            const parsed = Number.parseInt(value, 10);\n            if (Number.isFinite(parsed) && parsed > 0) {\n                chainId = parsed;\n                break;\n            }\n        }\n    }\n    if (!chainId) {\n        throw new Error(`Missing or invalid chainId in ETHR DID: ${decoded}`);\n    }\n    if (accountCandidate.length !== 42 ||\n        !/^0x[a-fA-F0-9]{40}$/.test(accountCandidate)) {\n        throw new Error('Invalid account address in ETHR DID');\n    }\n    const did = `${ETHR_DID_PREFIX}${chainId}:${accountCandidate}`;\n    return {\n        did,\n        method: 'ethr',\n        chainId,\n        account: accountCandidate,\n        encoded: encodeIfNeeded(did, true),\n    };\n}\n/**\n * Build a did:ethr identifier from chain id and account address.\n */\nfunction buildEthrDid(chainId, account, options) {\n    const chainIdStr = typeof chainId === 'number'\n        ? chainId.toString(10)\n        : chainId?.toString() ?? '';\n    const accountStr = account?.toString() ?? '';\n    const normalizedChainId = chainIdStr.trim();\n    const normalizedAccount = accountStr.trim();\n    if (!normalizedChainId) {\n        throw new Error('Chain ID is required to build ETHR DID');\n    }\n    if (!normalizedAccount) {\n        throw new Error('Account address is required to build ETHR DID');\n    }\n    const chainIdNum = Number.parseInt(normalizedChainId, 10);\n    if (!Number.isFinite(chainIdNum) || chainIdNum <= 0) {\n        throw new Error(`Invalid chain ID: ${normalizedChainId}`);\n    }\n    if (normalizedAccount.length !== 42 ||\n        !/^0x[a-fA-F0-9]{40}$/.test(normalizedAccount)) {\n        throw new Error(`Invalid account address: ${normalizedAccount}`);\n    }\n    const did = `${ETHR_DID_PREFIX}${chainIdNum}:${normalizedAccount}`;\n    const encode = options?.encode ?? true;\n    return encodeIfNeeded(did, encode);\n}\n//# sourceMappingURL=didEthr.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BhZ2VudGljLXRydXN0LzgwMDQtZXh0LXNkay9kaXN0L3V0aWxzL2RpZEV0aHIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLGNBQWM7QUFDL0U7QUFDQTtBQUNBLG9EQUFvRCxRQUFRO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsUUFBUTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSxRQUFRO0FBQzNFO0FBQ0E7QUFDQSx5QkFBeUIsR0FBRztBQUM1QjtBQUNBO0FBQ0EsbUJBQW1CLGdCQUFnQixFQUFFLFFBQVEsR0FBRyxpQkFBaUI7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxrQkFBa0I7QUFDL0Q7QUFDQTtBQUNBLHlCQUF5QixHQUFHO0FBQzVCLG9EQUFvRCxrQkFBa0I7QUFDdEU7QUFDQSxtQkFBbUIsZ0JBQWdCLEVBQUUsV0FBVyxHQUFHLGtCQUFrQjtBQUNyRTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvYmFyYi9hYS9Bc3NvY2lhdGVkQWNjb3VudHMvbm9kZV9tb2R1bGVzL0BhZ2VudGljLXRydXN0LzgwMDQtZXh0LXNkay9kaXN0L3V0aWxzL2RpZEV0aHIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgRVRIUl9ESURfUFJFRklYID0gJ2RpZDpldGhyOic7XG5mdW5jdGlvbiBlbmNvZGVJZk5lZWRlZCh2YWx1ZSwgZW5jb2RlKSB7XG4gICAgcmV0dXJuIGVuY29kZSA9PT0gZmFsc2UgPyB2YWx1ZSA6IGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSk7XG59XG4vKipcbiAqIFBhcnNlIGEgZGlkOmV0aHIgaWRlbnRpZmllci5cbiAqXG4gKiBBY2NlcHRzIGVuY29kZWQgb3IgZGVjb2RlZCBzdHJpbmdzIGFuZCBzdXBwb3J0czpcbiAqICAgZGlkOmV0aHI6Y2hhaW5JZDoweC4uLiwgZGlkOmV0aHI6MHguLi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlRXRockRpZChyYXcpIHtcbiAgICBjb25zdCBlbmNvZGVkSW5wdXQgPSAocmF3ID8/ICcnKS50b1N0cmluZygpLnRyaW0oKTtcbiAgICBpZiAoIWVuY29kZWRJbnB1dCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgRVRIUiBESUQgcGFyYW1ldGVyJyk7XG4gICAgfVxuICAgIGxldCBkZWNvZGVkO1xuICAgIHRyeSB7XG4gICAgICAgIGRlY29kZWQgPSBkZWNvZGVVUklDb21wb25lbnQoZW5jb2RlZElucHV0KTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBwZXJjZW50LWVuY29kaW5nIGluIEVUSFIgRElEOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgfVxuICAgIGlmICghZGVjb2RlZC5zdGFydHNXaXRoKEVUSFJfRElEX1BSRUZJWCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIEVUSFIgRElEIGZvcm1hdDogJHtkZWNvZGVkfS4gRXhwZWN0ZWQgZm9ybWF0OiBkaWQ6ZXRocjpjaGFpbklkOmFjY291bnQgb3IgZGlkOmV0aHI6YWNjb3VudGApO1xuICAgIH1cbiAgICBjb25zdCBzZWdtZW50cyA9IGRlY29kZWQuc3BsaXQoJzonKTtcbiAgICBjb25zdCBhY2NvdW50Q2FuZGlkYXRlID0gc2VnbWVudHNbc2VnbWVudHMubGVuZ3RoIC0gMV07XG4gICAgaWYgKCFhY2NvdW50Q2FuZGlkYXRlIHx8ICFhY2NvdW50Q2FuZGlkYXRlLnN0YXJ0c1dpdGgoJzB4JykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFVEhSIERJRCBpcyBtaXNzaW5nIGFjY291bnQgY29tcG9uZW50Jyk7XG4gICAgfVxuICAgIGNvbnN0IHJlbWFpbmluZyA9IHNlZ21lbnRzLnNsaWNlKDIsIC0xKTtcbiAgICBsZXQgY2hhaW5JZCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IHJlbWFpbmluZy5sZW5ndGggLSAxOyBpID49IDA7IGkgLT0gMSkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHJlbWFpbmluZ1tpXTtcbiAgICAgICAgaWYgKHZhbHVlICYmIC9eXFxkKyQvLnRlc3QodmFsdWUpKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJzZWQgPSBOdW1iZXIucGFyc2VJbnQodmFsdWUsIDEwKTtcbiAgICAgICAgICAgIGlmIChOdW1iZXIuaXNGaW5pdGUocGFyc2VkKSAmJiBwYXJzZWQgPiAwKSB7XG4gICAgICAgICAgICAgICAgY2hhaW5JZCA9IHBhcnNlZDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWNoYWluSWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBNaXNzaW5nIG9yIGludmFsaWQgY2hhaW5JZCBpbiBFVEhSIERJRDogJHtkZWNvZGVkfWApO1xuICAgIH1cbiAgICBpZiAoYWNjb3VudENhbmRpZGF0ZS5sZW5ndGggIT09IDQyIHx8XG4gICAgICAgICEvXjB4W2EtZkEtRjAtOV17NDB9JC8udGVzdChhY2NvdW50Q2FuZGlkYXRlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYWNjb3VudCBhZGRyZXNzIGluIEVUSFIgRElEJyk7XG4gICAgfVxuICAgIGNvbnN0IGRpZCA9IGAke0VUSFJfRElEX1BSRUZJWH0ke2NoYWluSWR9OiR7YWNjb3VudENhbmRpZGF0ZX1gO1xuICAgIHJldHVybiB7XG4gICAgICAgIGRpZCxcbiAgICAgICAgbWV0aG9kOiAnZXRocicsXG4gICAgICAgIGNoYWluSWQsXG4gICAgICAgIGFjY291bnQ6IGFjY291bnRDYW5kaWRhdGUsXG4gICAgICAgIGVuY29kZWQ6IGVuY29kZUlmTmVlZGVkKGRpZCwgdHJ1ZSksXG4gICAgfTtcbn1cbi8qKlxuICogQnVpbGQgYSBkaWQ6ZXRociBpZGVudGlmaWVyIGZyb20gY2hhaW4gaWQgYW5kIGFjY291bnQgYWRkcmVzcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkRXRockRpZChjaGFpbklkLCBhY2NvdW50LCBvcHRpb25zKSB7XG4gICAgY29uc3QgY2hhaW5JZFN0ciA9IHR5cGVvZiBjaGFpbklkID09PSAnbnVtYmVyJ1xuICAgICAgICA/IGNoYWluSWQudG9TdHJpbmcoMTApXG4gICAgICAgIDogY2hhaW5JZD8udG9TdHJpbmcoKSA/PyAnJztcbiAgICBjb25zdCBhY2NvdW50U3RyID0gYWNjb3VudD8udG9TdHJpbmcoKSA/PyAnJztcbiAgICBjb25zdCBub3JtYWxpemVkQ2hhaW5JZCA9IGNoYWluSWRTdHIudHJpbSgpO1xuICAgIGNvbnN0IG5vcm1hbGl6ZWRBY2NvdW50ID0gYWNjb3VudFN0ci50cmltKCk7XG4gICAgaWYgKCFub3JtYWxpemVkQ2hhaW5JZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NoYWluIElEIGlzIHJlcXVpcmVkIHRvIGJ1aWxkIEVUSFIgRElEJyk7XG4gICAgfVxuICAgIGlmICghbm9ybWFsaXplZEFjY291bnQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBY2NvdW50IGFkZHJlc3MgaXMgcmVxdWlyZWQgdG8gYnVpbGQgRVRIUiBESUQnKTtcbiAgICB9XG4gICAgY29uc3QgY2hhaW5JZE51bSA9IE51bWJlci5wYXJzZUludChub3JtYWxpemVkQ2hhaW5JZCwgMTApO1xuICAgIGlmICghTnVtYmVyLmlzRmluaXRlKGNoYWluSWROdW0pIHx8IGNoYWluSWROdW0gPD0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgY2hhaW4gSUQ6ICR7bm9ybWFsaXplZENoYWluSWR9YCk7XG4gICAgfVxuICAgIGlmIChub3JtYWxpemVkQWNjb3VudC5sZW5ndGggIT09IDQyIHx8XG4gICAgICAgICEvXjB4W2EtZkEtRjAtOV17NDB9JC8udGVzdChub3JtYWxpemVkQWNjb3VudCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGFjY291bnQgYWRkcmVzczogJHtub3JtYWxpemVkQWNjb3VudH1gKTtcbiAgICB9XG4gICAgY29uc3QgZGlkID0gYCR7RVRIUl9ESURfUFJFRklYfSR7Y2hhaW5JZE51bX06JHtub3JtYWxpemVkQWNjb3VudH1gO1xuICAgIGNvbnN0IGVuY29kZSA9IG9wdGlvbnM/LmVuY29kZSA/PyB0cnVlO1xuICAgIHJldHVybiBlbmNvZGVJZk5lZWRlZChkaWQsIGVuY29kZSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kaWRFdGhyLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@agentic-trust/8004-ext-sdk/dist/utils/didEthr.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@agentic-trust/8004-sdk/dist/ERC8004Client.js":
/*!************************************************************************!*\
  !*** ../../node_modules/@agentic-trust/8004-sdk/dist/ERC8004Client.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ERC8004Client: () => (/* binding */ ERC8004Client)\n/* harmony export */ });\n/* harmony import */ var _IdentityClient__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./IdentityClient */ \"(rsc)/../../node_modules/@agentic-trust/8004-sdk/dist/IdentityClient.js\");\n/* harmony import */ var _ReputationClient__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ReputationClient */ \"(rsc)/../../node_modules/@agentic-trust/8004-sdk/dist/ReputationClient.js\");\n/* harmony import */ var _ValidationClient__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ValidationClient */ \"(rsc)/../../node_modules/@agentic-trust/8004-sdk/dist/ValidationClient.js\");\n/**\n * ERC-8004 Trustless Agents Client\n *\n * This SDK makes ZERO assumptions about implementations beyond what the spec says.\n * All \"MAY\" fields in the spec are treated as optional, not mandatory.\n *\n * Uses adapter pattern to support any blockchain library (ethers, viem, etc.)\n *\n * Usage example:\n * ```typescript\n * import { ERC8004Client, EthersAdapter } from 'erc-8004-js';\n * import { ethers } from 'ethers';\n *\n * const provider = new ethers.JsonRpcProvider('http://localhost:8545');\n * const signer = await provider.getSigner();\n * const adapter = new EthersAdapter(provider, signer);\n *\n * const client = new ERC8004Client({\n *   adapter,\n *   addresses: {\n *     identityRegistry: '0x...',\n *     reputationRegistry: '0x...',\n *     validationRegistry: '0x...',\n *     chainId: 31337\n *   }\n * });\n * ```\n */\n\n\n\nclass ERC8004Client {\n    identity;\n    reputation;\n    validation;\n    adapter;\n    addresses;\n    constructor(config) {\n        this.adapter = config.adapter;\n        this.addresses = config.addresses;\n        // Initialize Identity Client\n        this.identity = new _IdentityClient__WEBPACK_IMPORTED_MODULE_0__.IdentityClient(this.adapter, this.addresses.identityRegistry);\n        // Initialize Reputation Client\n        this.reputation = new _ReputationClient__WEBPACK_IMPORTED_MODULE_1__.ReputationClient(this.adapter, this.addresses.reputationRegistry, this.addresses.identityRegistry);\n        // Initialize Validation Client\n        this.validation = new _ValidationClient__WEBPACK_IMPORTED_MODULE_2__.ValidationClient(this.adapter, this.addresses.validationRegistry);\n    }\n    /**\n     * Get the current signer/wallet address\n     * Returns null if no signer configured (read-only mode)\n     */\n    async getAddress() {\n        return await this.adapter.getAddress();\n    }\n    /**\n     * Get the chain ID\n     */\n    async getChainId() {\n        return await this.adapter.getChainId();\n    }\n    /**\n     * Get the configured contract addresses\n     */\n    getAddresses() {\n        return { ...this.addresses };\n    }\n}\n//# sourceMappingURL=ERC8004Client.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BhZ2VudGljLXRydXN0LzgwMDQtc2RrL2Rpc3QvRVJDODAwNENsaWVudC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLCtCQUErQjtBQUMzQyxZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNrRDtBQUNJO0FBQ0E7QUFDL0M7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsMkRBQWM7QUFDMUM7QUFDQSw4QkFBOEIsK0RBQWdCO0FBQzlDO0FBQ0EsOEJBQThCLCtEQUFnQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9iYXJiL2FhL0Fzc29jaWF0ZWRBY2NvdW50cy9ub2RlX21vZHVsZXMvQGFnZW50aWMtdHJ1c3QvODAwNC1zZGsvZGlzdC9FUkM4MDA0Q2xpZW50LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogRVJDLTgwMDQgVHJ1c3RsZXNzIEFnZW50cyBDbGllbnRcbiAqXG4gKiBUaGlzIFNESyBtYWtlcyBaRVJPIGFzc3VtcHRpb25zIGFib3V0IGltcGxlbWVudGF0aW9ucyBiZXlvbmQgd2hhdCB0aGUgc3BlYyBzYXlzLlxuICogQWxsIFwiTUFZXCIgZmllbGRzIGluIHRoZSBzcGVjIGFyZSB0cmVhdGVkIGFzIG9wdGlvbmFsLCBub3QgbWFuZGF0b3J5LlxuICpcbiAqIFVzZXMgYWRhcHRlciBwYXR0ZXJuIHRvIHN1cHBvcnQgYW55IGJsb2NrY2hhaW4gbGlicmFyeSAoZXRoZXJzLCB2aWVtLCBldGMuKVxuICpcbiAqIFVzYWdlIGV4YW1wbGU6XG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBpbXBvcnQgeyBFUkM4MDA0Q2xpZW50LCBFdGhlcnNBZGFwdGVyIH0gZnJvbSAnZXJjLTgwMDQtanMnO1xuICogaW1wb3J0IHsgZXRoZXJzIH0gZnJvbSAnZXRoZXJzJztcbiAqXG4gKiBjb25zdCBwcm92aWRlciA9IG5ldyBldGhlcnMuSnNvblJwY1Byb3ZpZGVyKCdodHRwOi8vbG9jYWxob3N0Ojg1NDUnKTtcbiAqIGNvbnN0IHNpZ25lciA9IGF3YWl0IHByb3ZpZGVyLmdldFNpZ25lcigpO1xuICogY29uc3QgYWRhcHRlciA9IG5ldyBFdGhlcnNBZGFwdGVyKHByb3ZpZGVyLCBzaWduZXIpO1xuICpcbiAqIGNvbnN0IGNsaWVudCA9IG5ldyBFUkM4MDA0Q2xpZW50KHtcbiAqICAgYWRhcHRlcixcbiAqICAgYWRkcmVzc2VzOiB7XG4gKiAgICAgaWRlbnRpdHlSZWdpc3RyeTogJzB4Li4uJyxcbiAqICAgICByZXB1dGF0aW9uUmVnaXN0cnk6ICcweC4uLicsXG4gKiAgICAgdmFsaWRhdGlvblJlZ2lzdHJ5OiAnMHguLi4nLFxuICogICAgIGNoYWluSWQ6IDMxMzM3XG4gKiAgIH1cbiAqIH0pO1xuICogYGBgXG4gKi9cbmltcG9ydCB7IElkZW50aXR5Q2xpZW50IH0gZnJvbSAnLi9JZGVudGl0eUNsaWVudCc7XG5pbXBvcnQgeyBSZXB1dGF0aW9uQ2xpZW50IH0gZnJvbSAnLi9SZXB1dGF0aW9uQ2xpZW50JztcbmltcG9ydCB7IFZhbGlkYXRpb25DbGllbnQgfSBmcm9tICcuL1ZhbGlkYXRpb25DbGllbnQnO1xuZXhwb3J0IGNsYXNzIEVSQzgwMDRDbGllbnQge1xuICAgIGlkZW50aXR5O1xuICAgIHJlcHV0YXRpb247XG4gICAgdmFsaWRhdGlvbjtcbiAgICBhZGFwdGVyO1xuICAgIGFkZHJlc3NlcztcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAgICAgdGhpcy5hZGFwdGVyID0gY29uZmlnLmFkYXB0ZXI7XG4gICAgICAgIHRoaXMuYWRkcmVzc2VzID0gY29uZmlnLmFkZHJlc3NlcztcbiAgICAgICAgLy8gSW5pdGlhbGl6ZSBJZGVudGl0eSBDbGllbnRcbiAgICAgICAgdGhpcy5pZGVudGl0eSA9IG5ldyBJZGVudGl0eUNsaWVudCh0aGlzLmFkYXB0ZXIsIHRoaXMuYWRkcmVzc2VzLmlkZW50aXR5UmVnaXN0cnkpO1xuICAgICAgICAvLyBJbml0aWFsaXplIFJlcHV0YXRpb24gQ2xpZW50XG4gICAgICAgIHRoaXMucmVwdXRhdGlvbiA9IG5ldyBSZXB1dGF0aW9uQ2xpZW50KHRoaXMuYWRhcHRlciwgdGhpcy5hZGRyZXNzZXMucmVwdXRhdGlvblJlZ2lzdHJ5LCB0aGlzLmFkZHJlc3Nlcy5pZGVudGl0eVJlZ2lzdHJ5KTtcbiAgICAgICAgLy8gSW5pdGlhbGl6ZSBWYWxpZGF0aW9uIENsaWVudFxuICAgICAgICB0aGlzLnZhbGlkYXRpb24gPSBuZXcgVmFsaWRhdGlvbkNsaWVudCh0aGlzLmFkYXB0ZXIsIHRoaXMuYWRkcmVzc2VzLnZhbGlkYXRpb25SZWdpc3RyeSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY3VycmVudCBzaWduZXIvd2FsbGV0IGFkZHJlc3NcbiAgICAgKiBSZXR1cm5zIG51bGwgaWYgbm8gc2lnbmVyIGNvbmZpZ3VyZWQgKHJlYWQtb25seSBtb2RlKVxuICAgICAqL1xuICAgIGFzeW5jIGdldEFkZHJlc3MoKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmFkYXB0ZXIuZ2V0QWRkcmVzcygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGNoYWluIElEXG4gICAgICovXG4gICAgYXN5bmMgZ2V0Q2hhaW5JZCgpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuYWRhcHRlci5nZXRDaGFpbklkKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY29uZmlndXJlZCBjb250cmFjdCBhZGRyZXNzZXNcbiAgICAgKi9cbiAgICBnZXRBZGRyZXNzZXMoKSB7XG4gICAgICAgIHJldHVybiB7IC4uLnRoaXMuYWRkcmVzc2VzIH07XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RVJDODAwNENsaWVudC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@agentic-trust/8004-sdk/dist/ERC8004Client.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@agentic-trust/8004-sdk/dist/IdentityClient.js":
/*!*************************************************************************!*\
  !*** ../../node_modules/@agentic-trust/8004-sdk/dist/IdentityClient.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IdentityClient: () => (/* binding */ IdentityClient)\n/* harmony export */ });\n/* harmony import */ var _abis_IdentityRegistry_json__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abis/IdentityRegistry.json */ \"(rsc)/../../node_modules/@agentic-trust/8004-sdk/dist/abis/IdentityRegistry.json\");\n/**\n * Identity Client for ERC-8004\n * Handles agent registration and identity management\n */\n\nclass IdentityClient {\n    adapter;\n    contractAddress;\n    constructor(adapter, contractAddress) {\n        this.adapter = adapter;\n        this.contractAddress = contractAddress;\n    }\n    /**\n     * Register a new agent with no URI (URI can be set later)\n     * Spec: function register() returns (uint256 agentId)\n     */\n    async register() {\n        const result = await this.adapter.send(this.contractAddress, _abis_IdentityRegistry_json__WEBPACK_IMPORTED_MODULE_0__, 'register', []);\n        // Parse agentId from receipt logs\n        // This is implementation-agnostic - we just need to find the Registered event\n        const agentId = this.extractAgentIdFromReceipt(result);\n        return {\n            agentId,\n            txHash: result.hash || result.txHash,\n        };\n    }\n    /**\n     * Register a new agent with a token URI\n     * Spec: function register(string tokenURI) returns (uint256 agentId)\n     * @param tokenUri - URI pointing to agent registration file (MAY use ipfs://, https://, etc.)\n     */\n    async registerWithURI(tokenUri) {\n        const result = await this.adapter.send(this.contractAddress, _abis_IdentityRegistry_json__WEBPACK_IMPORTED_MODULE_0__, 'register(string)', [tokenUri]);\n        const agentId = this.extractAgentIdFromReceipt(result);\n        return {\n            agentId,\n            txHash: result.hash || result.txHash,\n        };\n    }\n    /**\n     * Register a new agent with URI and optional on-chain metadata\n     * Spec: function register(string tokenURI, MetadataEntry[] calldata metadata) returns (uint256 agentId)\n     * @param tokenUri - URI pointing to agent registration file\n     * @param metadata - OPTIONAL on-chain metadata entries\n     */\n    async registerWithMetadata(tokenUri, metadata = []) {\n        console.log('********************* registerWithMetadata: metadata', metadata);\n        // Convert metadata to contract format\n        // For viem, bytes need to be hex strings, not Uint8Array\n        const metadataFormatted = metadata.map(m => {\n            const bytes = this.stringToBytes(m.value);\n            // Convert Uint8Array to hex string for viem compatibility\n            const hexString = this.bytesToHex(bytes);\n            return {\n                // Updated ABI uses struct fields: { metadataKey, metadataValue }\n                metadataKey: m.key,\n                metadataValue: hexString\n            };\n        });\n        console.log('********************* registerWithMetadata: metadataFormatted', metadataFormatted);\n        const result = await this.adapter.send(this.contractAddress, _abis_IdentityRegistry_json__WEBPACK_IMPORTED_MODULE_0__, \n        // Updated ABI uses tuple[] with struct fields (metadataKey, metadataValue)\n        'register(string,(string,bytes)[])', [tokenUri, metadataFormatted]);\n        const agentId = this.extractAgentIdFromReceipt(result);\n        return {\n            agentId,\n            txHash: result.hash || result.txHash,\n        };\n    }\n    /**\n     * Get the token URI for an agent\n     * Spec: Standard ERC-721 tokenURI function\n     * @param agentId - The agent's ID\n     * @returns URI string (MAY be ipfs://, https://, etc.)\n     */\n    async getTokenURI(agentId) {\n        console.log('********************* getTokenURI: agentId', agentId);\n        return await this.adapter.call(this.contractAddress, _abis_IdentityRegistry_json__WEBPACK_IMPORTED_MODULE_0__, 'tokenURI', [agentId]);\n    }\n    /**\n     * Set the token URI for an agent\n     * Note: This is an implementation-specific extension (not in base spec).\n     * Assumes implementation exposes setAgentUri with owner/operator checks.\n     * @param agentId - The agent's ID\n     * @param uri - New URI string\n     */\n    async setAgentUri(agentId, uri) {\n        const result = await this.adapter.send(this.contractAddress, _abis_IdentityRegistry_json__WEBPACK_IMPORTED_MODULE_0__, \n        // Updated ABI name is setAgentURI (capital URI)\n        'setAgentURI', [agentId, uri]);\n        return { txHash: result.hash || result.txHash };\n    }\n    /**\n     * Get the owner of an agent\n     * Spec: Standard ERC-721 ownerOf function\n     * @param agentId - The agent's ID\n     */\n    async getOwner(agentId) {\n        return await this.adapter.call(this.contractAddress, _abis_IdentityRegistry_json__WEBPACK_IMPORTED_MODULE_0__, 'ownerOf', [agentId]);\n    }\n    /**\n     * Get on-chain metadata for an agent\n     * Spec: function getMetadata(uint256 agentId, string key) returns (bytes)\n     * @param agentId - The agent's ID\n     * @param key - Metadata key\n     */\n    async getMetadata(agentId, key) {\n        const bytes = await this.adapter.call(this.contractAddress, _abis_IdentityRegistry_json__WEBPACK_IMPORTED_MODULE_0__, 'getMetadata', [agentId, key]);\n        return this.bytesToString(bytes);\n    }\n    /**\n     * Set on-chain metadata for an agent\n     * Spec: function setMetadata(uint256 agentId, string key, bytes value)\n     * @param agentId - The agent's ID\n     * @param key - Metadata key\n     * @param value - Metadata value\n     */\n    async setMetadata(agentId, key, value) {\n        const result = await this.adapter.send(this.contractAddress, _abis_IdentityRegistry_json__WEBPACK_IMPORTED_MODULE_0__, 'setMetadata', [agentId, key, this.stringToBytes(value)]);\n        return { txHash: result.hash || result.txHash };\n    }\n    /**\n     * Fetch and parse the agent registration file from the token URI\n     * This is a convenience function that fetches the URI and parses it\n     * Note: Does not validate - spec says ERC-8004 cannot cryptographically guarantee\n     * that advertised capabilities are functional\n     * @param agentId - The agent's ID\n     */\n    async getRegistrationFile(agentId) {\n        const uri = await this.getTokenURI(agentId);\n        console.log('********************* getRegistrationFile: uri', uri);\n        // Handle different URI schemes\n        if (uri.startsWith('ipfs://')) {\n            // IPFS gateway - implementation specific, using public gateway\n            const cid = uri.replace('ipfs://', '');\n            const httpUri = `https://ipfs.io/ipfs/${cid}`;\n            const response = await fetch(httpUri);\n            return await response.json();\n        }\n        else if (uri.startsWith('https://') || uri.startsWith('http://')) {\n            const response = await fetch(uri);\n            return await response.json();\n        }\n        else {\n            throw new Error(`Unsupported URI scheme: ${uri}`);\n        }\n    }\n    /**\n     * Helper: Extract agentId from transaction receipt\n     * Looks for the Registered event which contains the agentId\n     */\n    extractAgentIdFromReceipt(result) {\n        // Look for Registered event in parsed events\n        if (result.events && result.events.length > 0) {\n            const registeredEvent = result.events.find((e) => e.name === 'Registered');\n            if (registeredEvent && registeredEvent.args) {\n                return BigInt(registeredEvent.args.agentId || registeredEvent.args[0]);\n            }\n        }\n        throw new Error('Could not extract agentId from transaction receipt - Registered event not found. ' +\n            'This usually means the contract is not deployed or the ABI does not match the deployed contract.');\n    }\n    /**\n     * Helper: Convert string to bytes (adapter-agnostic)\n     */\n    stringToBytes(value) {\n        return new TextEncoder().encode(value);\n    }\n    /**\n     * Helper: Convert bytes to string (adapter-agnostic)\n     */\n    bytesToString(bytes) {\n        if (bytes instanceof Uint8Array) {\n            return new TextDecoder().decode(bytes);\n        }\n        // Handle hex string format (ethers returns this)\n        if (typeof bytes === 'string' && bytes.startsWith('0x')) {\n            const hex = bytes.slice(2);\n            const arr = new Uint8Array(hex.length / 2);\n            for (let i = 0; i < hex.length; i += 2) {\n                arr[i / 2] = parseInt(hex.slice(i, i + 2), 16);\n            }\n            return new TextDecoder().decode(arr);\n        }\n        return bytes.toString();\n    }\n    /**\n     * Helper: Convert Uint8Array to hex string (for viem compatibility)\n     */\n    bytesToHex(bytes) {\n        return '0x' + Array.from(bytes)\n            .map(b => b.toString(16).padStart(2, '0'))\n            .join('');\n    }\n}\n//# sourceMappingURL=IdentityClient.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BhZ2VudGljLXRydXN0LzgwMDQtc2RrL2Rpc3QvSWRlbnRpdHlDbGllbnQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUMrRDtBQUN4RDtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsd0RBQW1CO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsd0RBQW1CO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxxRUFBcUUsd0RBQW1CO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELHdEQUFtQjtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsd0RBQW1CO0FBQ3hGO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsd0RBQW1CO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0Usd0RBQW1CO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLHdEQUFtQjtBQUN4RixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELElBQUk7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxJQUFJO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGdCQUFnQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvYmFyYi9hYS9Bc3NvY2lhdGVkQWNjb3VudHMvbm9kZV9tb2R1bGVzL0BhZ2VudGljLXRydXN0LzgwMDQtc2RrL2Rpc3QvSWRlbnRpdHlDbGllbnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBJZGVudGl0eSBDbGllbnQgZm9yIEVSQy04MDA0XG4gKiBIYW5kbGVzIGFnZW50IHJlZ2lzdHJhdGlvbiBhbmQgaWRlbnRpdHkgbWFuYWdlbWVudFxuICovXG5pbXBvcnQgSWRlbnRpdHlSZWdpc3RyeUFCSSBmcm9tICcuL2FiaXMvSWRlbnRpdHlSZWdpc3RyeS5qc29uJztcbmV4cG9ydCBjbGFzcyBJZGVudGl0eUNsaWVudCB7XG4gICAgYWRhcHRlcjtcbiAgICBjb250cmFjdEFkZHJlc3M7XG4gICAgY29uc3RydWN0b3IoYWRhcHRlciwgY29udHJhY3RBZGRyZXNzKSB7XG4gICAgICAgIHRoaXMuYWRhcHRlciA9IGFkYXB0ZXI7XG4gICAgICAgIHRoaXMuY29udHJhY3RBZGRyZXNzID0gY29udHJhY3RBZGRyZXNzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlciBhIG5ldyBhZ2VudCB3aXRoIG5vIFVSSSAoVVJJIGNhbiBiZSBzZXQgbGF0ZXIpXG4gICAgICogU3BlYzogZnVuY3Rpb24gcmVnaXN0ZXIoKSByZXR1cm5zICh1aW50MjU2IGFnZW50SWQpXG4gICAgICovXG4gICAgYXN5bmMgcmVnaXN0ZXIoKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuYWRhcHRlci5zZW5kKHRoaXMuY29udHJhY3RBZGRyZXNzLCBJZGVudGl0eVJlZ2lzdHJ5QUJJLCAncmVnaXN0ZXInLCBbXSk7XG4gICAgICAgIC8vIFBhcnNlIGFnZW50SWQgZnJvbSByZWNlaXB0IGxvZ3NcbiAgICAgICAgLy8gVGhpcyBpcyBpbXBsZW1lbnRhdGlvbi1hZ25vc3RpYyAtIHdlIGp1c3QgbmVlZCB0byBmaW5kIHRoZSBSZWdpc3RlcmVkIGV2ZW50XG4gICAgICAgIGNvbnN0IGFnZW50SWQgPSB0aGlzLmV4dHJhY3RBZ2VudElkRnJvbVJlY2VpcHQocmVzdWx0KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFnZW50SWQsXG4gICAgICAgICAgICB0eEhhc2g6IHJlc3VsdC5oYXNoIHx8IHJlc3VsdC50eEhhc2gsXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVyIGEgbmV3IGFnZW50IHdpdGggYSB0b2tlbiBVUklcbiAgICAgKiBTcGVjOiBmdW5jdGlvbiByZWdpc3RlcihzdHJpbmcgdG9rZW5VUkkpIHJldHVybnMgKHVpbnQyNTYgYWdlbnRJZClcbiAgICAgKiBAcGFyYW0gdG9rZW5VcmkgLSBVUkkgcG9pbnRpbmcgdG8gYWdlbnQgcmVnaXN0cmF0aW9uIGZpbGUgKE1BWSB1c2UgaXBmczovLywgaHR0cHM6Ly8sIGV0Yy4pXG4gICAgICovXG4gICAgYXN5bmMgcmVnaXN0ZXJXaXRoVVJJKHRva2VuVXJpKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuYWRhcHRlci5zZW5kKHRoaXMuY29udHJhY3RBZGRyZXNzLCBJZGVudGl0eVJlZ2lzdHJ5QUJJLCAncmVnaXN0ZXIoc3RyaW5nKScsIFt0b2tlblVyaV0pO1xuICAgICAgICBjb25zdCBhZ2VudElkID0gdGhpcy5leHRyYWN0QWdlbnRJZEZyb21SZWNlaXB0KHJlc3VsdCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhZ2VudElkLFxuICAgICAgICAgICAgdHhIYXNoOiByZXN1bHQuaGFzaCB8fCByZXN1bHQudHhIYXNoLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlciBhIG5ldyBhZ2VudCB3aXRoIFVSSSBhbmQgb3B0aW9uYWwgb24tY2hhaW4gbWV0YWRhdGFcbiAgICAgKiBTcGVjOiBmdW5jdGlvbiByZWdpc3RlcihzdHJpbmcgdG9rZW5VUkksIE1ldGFkYXRhRW50cnlbXSBjYWxsZGF0YSBtZXRhZGF0YSkgcmV0dXJucyAodWludDI1NiBhZ2VudElkKVxuICAgICAqIEBwYXJhbSB0b2tlblVyaSAtIFVSSSBwb2ludGluZyB0byBhZ2VudCByZWdpc3RyYXRpb24gZmlsZVxuICAgICAqIEBwYXJhbSBtZXRhZGF0YSAtIE9QVElPTkFMIG9uLWNoYWluIG1ldGFkYXRhIGVudHJpZXNcbiAgICAgKi9cbiAgICBhc3luYyByZWdpc3RlcldpdGhNZXRhZGF0YSh0b2tlblVyaSwgbWV0YWRhdGEgPSBbXSkge1xuICAgICAgICBjb25zb2xlLmxvZygnKioqKioqKioqKioqKioqKioqKioqIHJlZ2lzdGVyV2l0aE1ldGFkYXRhOiBtZXRhZGF0YScsIG1ldGFkYXRhKTtcbiAgICAgICAgLy8gQ29udmVydCBtZXRhZGF0YSB0byBjb250cmFjdCBmb3JtYXRcbiAgICAgICAgLy8gRm9yIHZpZW0sIGJ5dGVzIG5lZWQgdG8gYmUgaGV4IHN0cmluZ3MsIG5vdCBVaW50OEFycmF5XG4gICAgICAgIGNvbnN0IG1ldGFkYXRhRm9ybWF0dGVkID0gbWV0YWRhdGEubWFwKG0gPT4ge1xuICAgICAgICAgICAgY29uc3QgYnl0ZXMgPSB0aGlzLnN0cmluZ1RvQnl0ZXMobS52YWx1ZSk7XG4gICAgICAgICAgICAvLyBDb252ZXJ0IFVpbnQ4QXJyYXkgdG8gaGV4IHN0cmluZyBmb3IgdmllbSBjb21wYXRpYmlsaXR5XG4gICAgICAgICAgICBjb25zdCBoZXhTdHJpbmcgPSB0aGlzLmJ5dGVzVG9IZXgoYnl0ZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAvLyBVcGRhdGVkIEFCSSB1c2VzIHN0cnVjdCBmaWVsZHM6IHsgbWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUgfVxuICAgICAgICAgICAgICAgIG1ldGFkYXRhS2V5OiBtLmtleSxcbiAgICAgICAgICAgICAgICBtZXRhZGF0YVZhbHVlOiBoZXhTdHJpbmdcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zb2xlLmxvZygnKioqKioqKioqKioqKioqKioqKioqIHJlZ2lzdGVyV2l0aE1ldGFkYXRhOiBtZXRhZGF0YUZvcm1hdHRlZCcsIG1ldGFkYXRhRm9ybWF0dGVkKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5hZGFwdGVyLnNlbmQodGhpcy5jb250cmFjdEFkZHJlc3MsIElkZW50aXR5UmVnaXN0cnlBQkksIFxuICAgICAgICAvLyBVcGRhdGVkIEFCSSB1c2VzIHR1cGxlW10gd2l0aCBzdHJ1Y3QgZmllbGRzIChtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSlcbiAgICAgICAgJ3JlZ2lzdGVyKHN0cmluZywoc3RyaW5nLGJ5dGVzKVtdKScsIFt0b2tlblVyaSwgbWV0YWRhdGFGb3JtYXR0ZWRdKTtcbiAgICAgICAgY29uc3QgYWdlbnRJZCA9IHRoaXMuZXh0cmFjdEFnZW50SWRGcm9tUmVjZWlwdChyZXN1bHQpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYWdlbnRJZCxcbiAgICAgICAgICAgIHR4SGFzaDogcmVzdWx0Lmhhc2ggfHwgcmVzdWx0LnR4SGFzaCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSB0b2tlbiBVUkkgZm9yIGFuIGFnZW50XG4gICAgICogU3BlYzogU3RhbmRhcmQgRVJDLTcyMSB0b2tlblVSSSBmdW5jdGlvblxuICAgICAqIEBwYXJhbSBhZ2VudElkIC0gVGhlIGFnZW50J3MgSURcbiAgICAgKiBAcmV0dXJucyBVUkkgc3RyaW5nIChNQVkgYmUgaXBmczovLywgaHR0cHM6Ly8sIGV0Yy4pXG4gICAgICovXG4gICAgYXN5bmMgZ2V0VG9rZW5VUkkoYWdlbnRJZCkge1xuICAgICAgICBjb25zb2xlLmxvZygnKioqKioqKioqKioqKioqKioqKioqIGdldFRva2VuVVJJOiBhZ2VudElkJywgYWdlbnRJZCk7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmFkYXB0ZXIuY2FsbCh0aGlzLmNvbnRyYWN0QWRkcmVzcywgSWRlbnRpdHlSZWdpc3RyeUFCSSwgJ3Rva2VuVVJJJywgW2FnZW50SWRdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSB0b2tlbiBVUkkgZm9yIGFuIGFnZW50XG4gICAgICogTm90ZTogVGhpcyBpcyBhbiBpbXBsZW1lbnRhdGlvbi1zcGVjaWZpYyBleHRlbnNpb24gKG5vdCBpbiBiYXNlIHNwZWMpLlxuICAgICAqIEFzc3VtZXMgaW1wbGVtZW50YXRpb24gZXhwb3NlcyBzZXRBZ2VudFVyaSB3aXRoIG93bmVyL29wZXJhdG9yIGNoZWNrcy5cbiAgICAgKiBAcGFyYW0gYWdlbnRJZCAtIFRoZSBhZ2VudCdzIElEXG4gICAgICogQHBhcmFtIHVyaSAtIE5ldyBVUkkgc3RyaW5nXG4gICAgICovXG4gICAgYXN5bmMgc2V0QWdlbnRVcmkoYWdlbnRJZCwgdXJpKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuYWRhcHRlci5zZW5kKHRoaXMuY29udHJhY3RBZGRyZXNzLCBJZGVudGl0eVJlZ2lzdHJ5QUJJLCBcbiAgICAgICAgLy8gVXBkYXRlZCBBQkkgbmFtZSBpcyBzZXRBZ2VudFVSSSAoY2FwaXRhbCBVUkkpXG4gICAgICAgICdzZXRBZ2VudFVSSScsIFthZ2VudElkLCB1cmldKTtcbiAgICAgICAgcmV0dXJuIHsgdHhIYXNoOiByZXN1bHQuaGFzaCB8fCByZXN1bHQudHhIYXNoIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgb3duZXIgb2YgYW4gYWdlbnRcbiAgICAgKiBTcGVjOiBTdGFuZGFyZCBFUkMtNzIxIG93bmVyT2YgZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0gYWdlbnRJZCAtIFRoZSBhZ2VudCdzIElEXG4gICAgICovXG4gICAgYXN5bmMgZ2V0T3duZXIoYWdlbnRJZCkge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5hZGFwdGVyLmNhbGwodGhpcy5jb250cmFjdEFkZHJlc3MsIElkZW50aXR5UmVnaXN0cnlBQkksICdvd25lck9mJywgW2FnZW50SWRdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IG9uLWNoYWluIG1ldGFkYXRhIGZvciBhbiBhZ2VudFxuICAgICAqIFNwZWM6IGZ1bmN0aW9uIGdldE1ldGFkYXRhKHVpbnQyNTYgYWdlbnRJZCwgc3RyaW5nIGtleSkgcmV0dXJucyAoYnl0ZXMpXG4gICAgICogQHBhcmFtIGFnZW50SWQgLSBUaGUgYWdlbnQncyBJRFxuICAgICAqIEBwYXJhbSBrZXkgLSBNZXRhZGF0YSBrZXlcbiAgICAgKi9cbiAgICBhc3luYyBnZXRNZXRhZGF0YShhZ2VudElkLCBrZXkpIHtcbiAgICAgICAgY29uc3QgYnl0ZXMgPSBhd2FpdCB0aGlzLmFkYXB0ZXIuY2FsbCh0aGlzLmNvbnRyYWN0QWRkcmVzcywgSWRlbnRpdHlSZWdpc3RyeUFCSSwgJ2dldE1ldGFkYXRhJywgW2FnZW50SWQsIGtleV0pO1xuICAgICAgICByZXR1cm4gdGhpcy5ieXRlc1RvU3RyaW5nKGJ5dGVzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IG9uLWNoYWluIG1ldGFkYXRhIGZvciBhbiBhZ2VudFxuICAgICAqIFNwZWM6IGZ1bmN0aW9uIHNldE1ldGFkYXRhKHVpbnQyNTYgYWdlbnRJZCwgc3RyaW5nIGtleSwgYnl0ZXMgdmFsdWUpXG4gICAgICogQHBhcmFtIGFnZW50SWQgLSBUaGUgYWdlbnQncyBJRFxuICAgICAqIEBwYXJhbSBrZXkgLSBNZXRhZGF0YSBrZXlcbiAgICAgKiBAcGFyYW0gdmFsdWUgLSBNZXRhZGF0YSB2YWx1ZVxuICAgICAqL1xuICAgIGFzeW5jIHNldE1ldGFkYXRhKGFnZW50SWQsIGtleSwgdmFsdWUpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5hZGFwdGVyLnNlbmQodGhpcy5jb250cmFjdEFkZHJlc3MsIElkZW50aXR5UmVnaXN0cnlBQkksICdzZXRNZXRhZGF0YScsIFthZ2VudElkLCBrZXksIHRoaXMuc3RyaW5nVG9CeXRlcyh2YWx1ZSldKTtcbiAgICAgICAgcmV0dXJuIHsgdHhIYXNoOiByZXN1bHQuaGFzaCB8fCByZXN1bHQudHhIYXNoIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZldGNoIGFuZCBwYXJzZSB0aGUgYWdlbnQgcmVnaXN0cmF0aW9uIGZpbGUgZnJvbSB0aGUgdG9rZW4gVVJJXG4gICAgICogVGhpcyBpcyBhIGNvbnZlbmllbmNlIGZ1bmN0aW9uIHRoYXQgZmV0Y2hlcyB0aGUgVVJJIGFuZCBwYXJzZXMgaXRcbiAgICAgKiBOb3RlOiBEb2VzIG5vdCB2YWxpZGF0ZSAtIHNwZWMgc2F5cyBFUkMtODAwNCBjYW5ub3QgY3J5cHRvZ3JhcGhpY2FsbHkgZ3VhcmFudGVlXG4gICAgICogdGhhdCBhZHZlcnRpc2VkIGNhcGFiaWxpdGllcyBhcmUgZnVuY3Rpb25hbFxuICAgICAqIEBwYXJhbSBhZ2VudElkIC0gVGhlIGFnZW50J3MgSURcbiAgICAgKi9cbiAgICBhc3luYyBnZXRSZWdpc3RyYXRpb25GaWxlKGFnZW50SWQpIHtcbiAgICAgICAgY29uc3QgdXJpID0gYXdhaXQgdGhpcy5nZXRUb2tlblVSSShhZ2VudElkKTtcbiAgICAgICAgY29uc29sZS5sb2coJyoqKioqKioqKioqKioqKioqKioqKiBnZXRSZWdpc3RyYXRpb25GaWxlOiB1cmknLCB1cmkpO1xuICAgICAgICAvLyBIYW5kbGUgZGlmZmVyZW50IFVSSSBzY2hlbWVzXG4gICAgICAgIGlmICh1cmkuc3RhcnRzV2l0aCgnaXBmczovLycpKSB7XG4gICAgICAgICAgICAvLyBJUEZTIGdhdGV3YXkgLSBpbXBsZW1lbnRhdGlvbiBzcGVjaWZpYywgdXNpbmcgcHVibGljIGdhdGV3YXlcbiAgICAgICAgICAgIGNvbnN0IGNpZCA9IHVyaS5yZXBsYWNlKCdpcGZzOi8vJywgJycpO1xuICAgICAgICAgICAgY29uc3QgaHR0cFVyaSA9IGBodHRwczovL2lwZnMuaW8vaXBmcy8ke2NpZH1gO1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChodHRwVXJpKTtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodXJpLnN0YXJ0c1dpdGgoJ2h0dHBzOi8vJykgfHwgdXJpLnN0YXJ0c1dpdGgoJ2h0dHA6Ly8nKSkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmkpO1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgVVJJIHNjaGVtZTogJHt1cml9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogSGVscGVyOiBFeHRyYWN0IGFnZW50SWQgZnJvbSB0cmFuc2FjdGlvbiByZWNlaXB0XG4gICAgICogTG9va3MgZm9yIHRoZSBSZWdpc3RlcmVkIGV2ZW50IHdoaWNoIGNvbnRhaW5zIHRoZSBhZ2VudElkXG4gICAgICovXG4gICAgZXh0cmFjdEFnZW50SWRGcm9tUmVjZWlwdChyZXN1bHQpIHtcbiAgICAgICAgLy8gTG9vayBmb3IgUmVnaXN0ZXJlZCBldmVudCBpbiBwYXJzZWQgZXZlbnRzXG4gICAgICAgIGlmIChyZXN1bHQuZXZlbnRzICYmIHJlc3VsdC5ldmVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3QgcmVnaXN0ZXJlZEV2ZW50ID0gcmVzdWx0LmV2ZW50cy5maW5kKChlKSA9PiBlLm5hbWUgPT09ICdSZWdpc3RlcmVkJyk7XG4gICAgICAgICAgICBpZiAocmVnaXN0ZXJlZEV2ZW50ICYmIHJlZ2lzdGVyZWRFdmVudC5hcmdzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEJpZ0ludChyZWdpc3RlcmVkRXZlbnQuYXJncy5hZ2VudElkIHx8IHJlZ2lzdGVyZWRFdmVudC5hcmdzWzBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBleHRyYWN0IGFnZW50SWQgZnJvbSB0cmFuc2FjdGlvbiByZWNlaXB0IC0gUmVnaXN0ZXJlZCBldmVudCBub3QgZm91bmQuICcgK1xuICAgICAgICAgICAgJ1RoaXMgdXN1YWxseSBtZWFucyB0aGUgY29udHJhY3QgaXMgbm90IGRlcGxveWVkIG9yIHRoZSBBQkkgZG9lcyBub3QgbWF0Y2ggdGhlIGRlcGxveWVkIGNvbnRyYWN0LicpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIZWxwZXI6IENvbnZlcnQgc3RyaW5nIHRvIGJ5dGVzIChhZGFwdGVyLWFnbm9zdGljKVxuICAgICAqL1xuICAgIHN0cmluZ1RvQnl0ZXModmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZSh2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhlbHBlcjogQ29udmVydCBieXRlcyB0byBzdHJpbmcgKGFkYXB0ZXItYWdub3N0aWMpXG4gICAgICovXG4gICAgYnl0ZXNUb1N0cmluZyhieXRlcykge1xuICAgICAgICBpZiAoYnl0ZXMgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKGJ5dGVzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBIYW5kbGUgaGV4IHN0cmluZyBmb3JtYXQgKGV0aGVycyByZXR1cm5zIHRoaXMpXG4gICAgICAgIGlmICh0eXBlb2YgYnl0ZXMgPT09ICdzdHJpbmcnICYmIGJ5dGVzLnN0YXJ0c1dpdGgoJzB4JykpIHtcbiAgICAgICAgICAgIGNvbnN0IGhleCA9IGJ5dGVzLnNsaWNlKDIpO1xuICAgICAgICAgICAgY29uc3QgYXJyID0gbmV3IFVpbnQ4QXJyYXkoaGV4Lmxlbmd0aCAvIDIpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBoZXgubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICAgICAgICBhcnJbaSAvIDJdID0gcGFyc2VJbnQoaGV4LnNsaWNlKGksIGkgKyAyKSwgMTYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZShhcnIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBieXRlcy50b1N0cmluZygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIZWxwZXI6IENvbnZlcnQgVWludDhBcnJheSB0byBoZXggc3RyaW5nIChmb3IgdmllbSBjb21wYXRpYmlsaXR5KVxuICAgICAqL1xuICAgIGJ5dGVzVG9IZXgoYnl0ZXMpIHtcbiAgICAgICAgcmV0dXJuICcweCcgKyBBcnJheS5mcm9tKGJ5dGVzKVxuICAgICAgICAgICAgLm1hcChiID0+IGIudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsICcwJykpXG4gICAgICAgICAgICAuam9pbignJyk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SWRlbnRpdHlDbGllbnQuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@agentic-trust/8004-sdk/dist/IdentityClient.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@agentic-trust/8004-sdk/dist/ReputationClient.js":
/*!***************************************************************************!*\
  !*** ../../node_modules/@agentic-trust/8004-sdk/dist/ReputationClient.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ReputationClient: () => (/* binding */ ReputationClient)\n/* harmony export */ });\n/* harmony import */ var _abis_ReputationRegistry_json__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abis/ReputationRegistry.json */ \"(rsc)/../../node_modules/@agentic-trust/8004-sdk/dist/abis/ReputationRegistry.json\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ethers */ \"(rsc)/../../node_modules/ethers/lib.esm/abi/abi-coder.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ethers */ \"(rsc)/../../node_modules/ethers/lib.esm/crypto/keccak.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ethers */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ethers */ \"(rsc)/../../node_modules/ethers/lib.esm/constants/hashes.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ethers */ \"(rsc)/../../node_modules/ethers/lib.esm/constants/addresses.js\");\n/**\n * Reputation Client for ERC-8004\n * Handles feedback submission and reputation queries\n */\n\n\nclass ReputationClient {\n    adapter;\n    contractAddress;\n    identityRegistryAddress;\n    constructor(adapter, contractAddress, identityRegistryAddress) {\n        this.adapter = adapter;\n        this.contractAddress = contractAddress;\n        this.identityRegistryAddress = identityRegistryAddress;\n    }\n    /**\n     * Create a feedbackAuth structure to be signed\n     * Spec: tuple (agentId, clientAddress, indexLimit, expiry, chainId, identityRegistry, signerAddress)\n     *\n     * @param agentId - The agent ID\n     * @param clientAddress - Address authorized to give feedback\n     * @param indexLimit - Must be > last feedback index from this client (typically lastIndex + 1)\n     * @param expiry - Unix timestamp when authorization expires\n     * @param chainId - Chain ID where feedback will be submitted\n     * @param signerAddress - Address of the signer (agent owner/operator)\n     */\n    createFeedbackAuth(agentId, clientAddress, indexLimit, expiry, chainId, signerAddress) {\n        return {\n            agentId,\n            clientAddress,\n            indexLimit,\n            expiry,\n            chainId,\n            identityRegistry: this.identityRegistryAddress,\n            signerAddress,\n        };\n    }\n    /**\n     * Sign a feedbackAuth using EIP-191\n     * The agent owner/operator signs to authorize a client to give feedback\n     *\n     * @param auth - The feedbackAuth structure\n     * @returns Signed authorization as bytes (encoded tuple + signature)\n     */\n    async signFeedbackAuth(auth) {\n        // Encode the feedbackAuth tuple\n        // Spec: (agentId, clientAddress, indexLimit, expiry, chainId, identityRegistry, signerAddress)\n        const encoded = ethers__WEBPACK_IMPORTED_MODULE_1__.AbiCoder.defaultAbiCoder().encode(['uint256', 'address', 'uint256', 'uint256', 'uint256', 'address', 'address'], [\n            auth.agentId,\n            auth.clientAddress,\n            auth.indexLimit,\n            auth.expiry,\n            auth.chainId,\n            auth.identityRegistry,\n            auth.signerAddress,\n        ]);\n        // Hash the encoded data\n        const messageHash = ethers__WEBPACK_IMPORTED_MODULE_2__.keccak256(encoded);\n        // Sign using EIP-191 (personal_sign)\n        // This prefixes the message with \"\\x19Ethereum Signed Message:\\n32\"\n        const signature = await this.adapter.signMessage(ethers__WEBPACK_IMPORTED_MODULE_3__.getBytes(messageHash));\n        // Return encoded tuple + signature concatenated\n        // Contract will decode the tuple and verify the signature\n        return ethers__WEBPACK_IMPORTED_MODULE_3__.concat([encoded, signature]);\n    }\n    /**\n     * Submit feedback for an agent\n     * Updated ABI:\n     *   giveFeedback(uint256 agentId, uint8 score, string tag1, string tag2, string endpoint, string feedbackURI, bytes32 feedbackHash)\n     *\n     * @param params - Feedback parameters (score is MUST, others are OPTIONAL)\n     * @returns Transaction result\n     */\n    async giveFeedback(params) {\n        // Validate score is 0-100 (MUST per spec)\n        if (params.score < 0 || params.score > 100) {\n            throw new Error('Score MUST be between 0 and 100');\n        }\n        const tag1 = params.tag1 || '';\n        const tag2 = params.tag2 || '';\n        const endpoint = params.endpoint || '';\n        const feedbackHash = params.feedbackHash || ethers__WEBPACK_IMPORTED_MODULE_4__.ZeroHash;\n        const feedbackUri = params.feedbackUri || '';\n        const result = await this.adapter.send(this.contractAddress, _abis_ReputationRegistry_json__WEBPACK_IMPORTED_MODULE_0__, 'giveFeedback', [\n            params.agentId,\n            params.score,\n            tag1,\n            tag2,\n            endpoint,\n            feedbackUri,\n            feedbackHash,\n        ]);\n        return { txHash: result.hash || result.txHash };\n    }\n    /**\n     * Revoke previously submitted feedback\n     * Spec: function revokeFeedback(uint256 agentId, uint64 feedbackIndex)\n     *\n     * @param agentId - The agent ID\n     * @param feedbackIndex - Index of feedback to revoke\n     */\n    async revokeFeedback(agentId, feedbackIndex) {\n        const result = await this.adapter.send(this.contractAddress, _abis_ReputationRegistry_json__WEBPACK_IMPORTED_MODULE_0__, 'revokeFeedback', [agentId, feedbackIndex]);\n        return { txHash: result.hash || result.txHash };\n    }\n    /**\n     * Append a response to existing feedback\n     * Spec: function appendResponse(uint256 agentId, address clientAddress, uint64 feedbackIndex, string calldata responseUri, bytes32 calldata responseHash)\n     *\n     * @param agentId - The agent ID\n     * @param clientAddress - Client who gave the feedback\n     * @param feedbackIndex - Index of the feedback\n     * @param responseUri - URI to response content\n     * @param responseHash - OPTIONAL hash of response content (KECCAK-256)\n     */\n    async appendResponse(agentId, clientAddress, feedbackIndex, responseUri, responseHash) {\n        const hash = responseHash || ethers__WEBPACK_IMPORTED_MODULE_4__.ZeroHash;\n        const result = await this.adapter.send(this.contractAddress, _abis_ReputationRegistry_json__WEBPACK_IMPORTED_MODULE_0__, 'appendResponse', [agentId, clientAddress, feedbackIndex, responseUri, hash]);\n        return { txHash: result.hash || result.txHash };\n    }\n    /**\n     * Get the identity registry address\n     * Spec: function getIdentityRegistry() external view returns (address identityRegistry)\n     */\n    async getIdentityRegistry() {\n        return await this.adapter.call(this.contractAddress, _abis_ReputationRegistry_json__WEBPACK_IMPORTED_MODULE_0__, 'getIdentityRegistry', []);\n    }\n    /**\n     * Get reputation summary for an agent\n     * Updated ABI: getSummary(uint256 agentId, address[] clientAddresses, string tag1, string tag2)\n     * Note: agentId is ONLY mandatory parameter, others are OPTIONAL filters\n     *\n     * @param agentId - The agent ID (MANDATORY)\n     * @param clientAddresses - OPTIONAL filter by specific clients\n     * @param tag1 - OPTIONAL filter by tag1\n     * @param tag2 - OPTIONAL filter by tag2\n     */\n    async getSummary(agentId, clientAddresses, tag1, tag2) {\n        const clients = clientAddresses || [];\n        const t1 = tag1 || '';\n        const t2 = tag2 || '';\n        // Some deployed ReputationRegistry implementations revert on edge cases\n        // (e.g. empty clientAddresses / empty tags). Treat that as \"no summary available\"\n        // instead of failing the entire API response.\n        let result;\n        try {\n            result = await this.adapter.call(this.contractAddress, _abis_ReputationRegistry_json__WEBPACK_IMPORTED_MODULE_0__, 'getSummary', [agentId, clients, t1, t2]);\n        }\n        catch (error) {\n            // eslint-disable-next-line no-console\n            console.warn('[ReputationClient.getSummary] getSummary reverted; returning default summary', {\n                agentId: agentId.toString(),\n                clientCount: clients.length,\n                tag1: t1,\n                tag2: t2,\n                error: error instanceof Error ? error.message : String(error),\n            });\n            return { count: 0n, averageScore: 0 };\n        }\n        return {\n            count: BigInt(result.count || result[0]),\n            averageScore: Number(result.averageScore || result[1]),\n        };\n    }\n    /**\n     * Read a specific feedback entry\n     * Updated ABI: readFeedback(...) returns (uint8 score, string tag1, string tag2, bool isRevoked)\n     *\n     * @param agentId - The agent ID\n     * @param clientAddress - Client who gave feedback\n     * @param index - Feedback index\n     */\n    async readFeedback(agentId, clientAddress, index) {\n        const result = await this.adapter.call(this.contractAddress, _abis_ReputationRegistry_json__WEBPACK_IMPORTED_MODULE_0__, 'readFeedback', [agentId, clientAddress, index]);\n        return {\n            score: Number(result.score || result[0]),\n            tag1: String(result.tag1 || result[1] || ''),\n            tag2: String(result.tag2 || result[2] || ''),\n            isRevoked: Boolean(result.isRevoked || result[3]),\n        };\n    }\n    /**\n     * Read all feedback for an agent with optional filters\n     * Updated ABI:\n     *   readAllFeedback(uint256 agentId, address[] clientAddresses, string tag1, string tag2, bool includeRevoked)\n     *   returns (address[] clients, uint64[] feedbackIndexes, uint8[] scores, string[] tag1s, string[] tag2s, bool[] revokedStatuses)\n     * Note: agentId is ONLY mandatory parameter\n     *\n     * @param agentId - The agent ID (MANDATORY)\n     * @param clientAddresses - OPTIONAL filter by clients\n     * @param tag1 - OPTIONAL filter by tag1\n     * @param tag2 - OPTIONAL filter by tag2\n     * @param includeRevoked - OPTIONAL include revoked feedback\n     */\n    async readAllFeedback(agentId, clientAddresses, tag1, tag2, includeRevoked) {\n        const clients = clientAddresses || [];\n        const t1 = tag1 || '';\n        const t2 = tag2 || '';\n        const includeRev = includeRevoked || false;\n        const result = await this.adapter.call(this.contractAddress, _abis_ReputationRegistry_json__WEBPACK_IMPORTED_MODULE_0__, 'readAllFeedback', [agentId, clients, t1, t2, includeRev]);\n        return {\n            clientAddresses: (result.clients || result[0]),\n            indexes: (result.feedbackIndexes || result[1]).map((i) => BigInt(i)),\n            scores: (result.scores || result[2]).map((s) => Number(s)),\n            tag1s: (result.tag1s || result[3]).map((t) => String(t ?? '')),\n            tag2s: (result.tag2s || result[4]).map((t) => String(t ?? '')),\n            revokedStatuses: (result.revokedStatuses || result[5]).map((b) => Boolean(b)),\n        };\n    }\n    /**\n     * Get response count for a feedback entry\n     * Spec: function getResponseCount(uint256 agentId, address clientAddress, uint64 feedbackIndex, address[] responders) returns (uint64)\n     * Note: agentId is ONLY mandatory parameter\n     */\n    async getResponseCount(agentId, clientAddress, feedbackIndex, responders) {\n        const client = clientAddress || ethers__WEBPACK_IMPORTED_MODULE_5__.ZeroAddress;\n        const index = feedbackIndex || BigInt(0);\n        const resp = responders || [];\n        const result = await this.adapter.call(this.contractAddress, _abis_ReputationRegistry_json__WEBPACK_IMPORTED_MODULE_0__, 'getResponseCount', [agentId, client, index, resp]);\n        return BigInt(result);\n    }\n    /**\n     * Get all clients who have given feedback to an agent\n     * Spec: function getClients(uint256 agentId) returns (address[] memory)\n     */\n    async getClients(agentId) {\n        return await this.adapter.call(this.contractAddress, _abis_ReputationRegistry_json__WEBPACK_IMPORTED_MODULE_0__, 'getClients', [agentId]);\n    }\n    /**\n     * Get the last feedback index from a client for an agent\n     * Spec: function getLastIndex(uint256 agentId, address clientAddress) returns (uint64)\n     *\n     * @param agentId - The agent ID\n     * @param clientAddress - Client address\n     * @returns Last feedback index (0 if no feedback yet)\n     */\n    async getLastIndex(agentId, clientAddress) {\n        const result = await this.adapter.call(this.contractAddress, _abis_ReputationRegistry_json__WEBPACK_IMPORTED_MODULE_0__, 'getLastIndex', [agentId, clientAddress]);\n        return BigInt(result);\n    }\n}\n//# sourceMappingURL=ReputationClient.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BhZ2VudGljLXRydXN0LzgwMDQtc2RrL2Rpc3QvUmVwdXRhdGlvbkNsaWVudC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDbUU7QUFDbkM7QUFDekI7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qiw0Q0FBZTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsNkNBQWdCO0FBQzVDO0FBQ0E7QUFDQSx5REFBeUQsNENBQWU7QUFDeEU7QUFDQTtBQUNBLGVBQWUsMENBQWE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCw0Q0FBZTtBQUNuRTtBQUNBLHFFQUFxRSwwREFBcUI7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsMERBQXFCO0FBQzFGLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsNENBQWU7QUFDcEQscUVBQXFFLDBEQUFxQjtBQUMxRixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELDBEQUFxQjtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLDBEQUFxQjtBQUN4RjtBQUNBO0FBQ0E7QUFDQSw2RUFBNkU7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLDBEQUFxQjtBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRSwwREFBcUI7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLCtDQUFrQjtBQUMxRDtBQUNBO0FBQ0EscUVBQXFFLDBEQUFxQjtBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCwwREFBcUI7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsMERBQXFCO0FBQzFGO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9iYXJiL2FhL0Fzc29jaWF0ZWRBY2NvdW50cy9ub2RlX21vZHVsZXMvQGFnZW50aWMtdHJ1c3QvODAwNC1zZGsvZGlzdC9SZXB1dGF0aW9uQ2xpZW50LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogUmVwdXRhdGlvbiBDbGllbnQgZm9yIEVSQy04MDA0XG4gKiBIYW5kbGVzIGZlZWRiYWNrIHN1Ym1pc3Npb24gYW5kIHJlcHV0YXRpb24gcXVlcmllc1xuICovXG5pbXBvcnQgUmVwdXRhdGlvblJlZ2lzdHJ5QUJJIGZyb20gJy4vYWJpcy9SZXB1dGF0aW9uUmVnaXN0cnkuanNvbic7XG5pbXBvcnQgeyBldGhlcnMgfSBmcm9tICdldGhlcnMnO1xuZXhwb3J0IGNsYXNzIFJlcHV0YXRpb25DbGllbnQge1xuICAgIGFkYXB0ZXI7XG4gICAgY29udHJhY3RBZGRyZXNzO1xuICAgIGlkZW50aXR5UmVnaXN0cnlBZGRyZXNzO1xuICAgIGNvbnN0cnVjdG9yKGFkYXB0ZXIsIGNvbnRyYWN0QWRkcmVzcywgaWRlbnRpdHlSZWdpc3RyeUFkZHJlc3MpIHtcbiAgICAgICAgdGhpcy5hZGFwdGVyID0gYWRhcHRlcjtcbiAgICAgICAgdGhpcy5jb250cmFjdEFkZHJlc3MgPSBjb250cmFjdEFkZHJlc3M7XG4gICAgICAgIHRoaXMuaWRlbnRpdHlSZWdpc3RyeUFkZHJlc3MgPSBpZGVudGl0eVJlZ2lzdHJ5QWRkcmVzcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgZmVlZGJhY2tBdXRoIHN0cnVjdHVyZSB0byBiZSBzaWduZWRcbiAgICAgKiBTcGVjOiB0dXBsZSAoYWdlbnRJZCwgY2xpZW50QWRkcmVzcywgaW5kZXhMaW1pdCwgZXhwaXJ5LCBjaGFpbklkLCBpZGVudGl0eVJlZ2lzdHJ5LCBzaWduZXJBZGRyZXNzKVxuICAgICAqXG4gICAgICogQHBhcmFtIGFnZW50SWQgLSBUaGUgYWdlbnQgSURcbiAgICAgKiBAcGFyYW0gY2xpZW50QWRkcmVzcyAtIEFkZHJlc3MgYXV0aG9yaXplZCB0byBnaXZlIGZlZWRiYWNrXG4gICAgICogQHBhcmFtIGluZGV4TGltaXQgLSBNdXN0IGJlID4gbGFzdCBmZWVkYmFjayBpbmRleCBmcm9tIHRoaXMgY2xpZW50ICh0eXBpY2FsbHkgbGFzdEluZGV4ICsgMSlcbiAgICAgKiBAcGFyYW0gZXhwaXJ5IC0gVW5peCB0aW1lc3RhbXAgd2hlbiBhdXRob3JpemF0aW9uIGV4cGlyZXNcbiAgICAgKiBAcGFyYW0gY2hhaW5JZCAtIENoYWluIElEIHdoZXJlIGZlZWRiYWNrIHdpbGwgYmUgc3VibWl0dGVkXG4gICAgICogQHBhcmFtIHNpZ25lckFkZHJlc3MgLSBBZGRyZXNzIG9mIHRoZSBzaWduZXIgKGFnZW50IG93bmVyL29wZXJhdG9yKVxuICAgICAqL1xuICAgIGNyZWF0ZUZlZWRiYWNrQXV0aChhZ2VudElkLCBjbGllbnRBZGRyZXNzLCBpbmRleExpbWl0LCBleHBpcnksIGNoYWluSWQsIHNpZ25lckFkZHJlc3MpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFnZW50SWQsXG4gICAgICAgICAgICBjbGllbnRBZGRyZXNzLFxuICAgICAgICAgICAgaW5kZXhMaW1pdCxcbiAgICAgICAgICAgIGV4cGlyeSxcbiAgICAgICAgICAgIGNoYWluSWQsXG4gICAgICAgICAgICBpZGVudGl0eVJlZ2lzdHJ5OiB0aGlzLmlkZW50aXR5UmVnaXN0cnlBZGRyZXNzLFxuICAgICAgICAgICAgc2lnbmVyQWRkcmVzcyxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2lnbiBhIGZlZWRiYWNrQXV0aCB1c2luZyBFSVAtMTkxXG4gICAgICogVGhlIGFnZW50IG93bmVyL29wZXJhdG9yIHNpZ25zIHRvIGF1dGhvcml6ZSBhIGNsaWVudCB0byBnaXZlIGZlZWRiYWNrXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYXV0aCAtIFRoZSBmZWVkYmFja0F1dGggc3RydWN0dXJlXG4gICAgICogQHJldHVybnMgU2lnbmVkIGF1dGhvcml6YXRpb24gYXMgYnl0ZXMgKGVuY29kZWQgdHVwbGUgKyBzaWduYXR1cmUpXG4gICAgICovXG4gICAgYXN5bmMgc2lnbkZlZWRiYWNrQXV0aChhdXRoKSB7XG4gICAgICAgIC8vIEVuY29kZSB0aGUgZmVlZGJhY2tBdXRoIHR1cGxlXG4gICAgICAgIC8vIFNwZWM6IChhZ2VudElkLCBjbGllbnRBZGRyZXNzLCBpbmRleExpbWl0LCBleHBpcnksIGNoYWluSWQsIGlkZW50aXR5UmVnaXN0cnksIHNpZ25lckFkZHJlc3MpXG4gICAgICAgIGNvbnN0IGVuY29kZWQgPSBldGhlcnMuQWJpQ29kZXIuZGVmYXVsdEFiaUNvZGVyKCkuZW5jb2RlKFsndWludDI1NicsICdhZGRyZXNzJywgJ3VpbnQyNTYnLCAndWludDI1NicsICd1aW50MjU2JywgJ2FkZHJlc3MnLCAnYWRkcmVzcyddLCBbXG4gICAgICAgICAgICBhdXRoLmFnZW50SWQsXG4gICAgICAgICAgICBhdXRoLmNsaWVudEFkZHJlc3MsXG4gICAgICAgICAgICBhdXRoLmluZGV4TGltaXQsXG4gICAgICAgICAgICBhdXRoLmV4cGlyeSxcbiAgICAgICAgICAgIGF1dGguY2hhaW5JZCxcbiAgICAgICAgICAgIGF1dGguaWRlbnRpdHlSZWdpc3RyeSxcbiAgICAgICAgICAgIGF1dGguc2lnbmVyQWRkcmVzcyxcbiAgICAgICAgXSk7XG4gICAgICAgIC8vIEhhc2ggdGhlIGVuY29kZWQgZGF0YVxuICAgICAgICBjb25zdCBtZXNzYWdlSGFzaCA9IGV0aGVycy5rZWNjYWsyNTYoZW5jb2RlZCk7XG4gICAgICAgIC8vIFNpZ24gdXNpbmcgRUlQLTE5MSAocGVyc29uYWxfc2lnbilcbiAgICAgICAgLy8gVGhpcyBwcmVmaXhlcyB0aGUgbWVzc2FnZSB3aXRoIFwiXFx4MTlFdGhlcmV1bSBTaWduZWQgTWVzc2FnZTpcXG4zMlwiXG4gICAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IGF3YWl0IHRoaXMuYWRhcHRlci5zaWduTWVzc2FnZShldGhlcnMuZ2V0Qnl0ZXMobWVzc2FnZUhhc2gpKTtcbiAgICAgICAgLy8gUmV0dXJuIGVuY29kZWQgdHVwbGUgKyBzaWduYXR1cmUgY29uY2F0ZW5hdGVkXG4gICAgICAgIC8vIENvbnRyYWN0IHdpbGwgZGVjb2RlIHRoZSB0dXBsZSBhbmQgdmVyaWZ5IHRoZSBzaWduYXR1cmVcbiAgICAgICAgcmV0dXJuIGV0aGVycy5jb25jYXQoW2VuY29kZWQsIHNpZ25hdHVyZV0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdWJtaXQgZmVlZGJhY2sgZm9yIGFuIGFnZW50XG4gICAgICogVXBkYXRlZCBBQkk6XG4gICAgICogICBnaXZlRmVlZGJhY2sodWludDI1NiBhZ2VudElkLCB1aW50OCBzY29yZSwgc3RyaW5nIHRhZzEsIHN0cmluZyB0YWcyLCBzdHJpbmcgZW5kcG9pbnQsIHN0cmluZyBmZWVkYmFja1VSSSwgYnl0ZXMzMiBmZWVkYmFja0hhc2gpXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyYW1zIC0gRmVlZGJhY2sgcGFyYW1ldGVycyAoc2NvcmUgaXMgTVVTVCwgb3RoZXJzIGFyZSBPUFRJT05BTClcbiAgICAgKiBAcmV0dXJucyBUcmFuc2FjdGlvbiByZXN1bHRcbiAgICAgKi9cbiAgICBhc3luYyBnaXZlRmVlZGJhY2socGFyYW1zKSB7XG4gICAgICAgIC8vIFZhbGlkYXRlIHNjb3JlIGlzIDAtMTAwIChNVVNUIHBlciBzcGVjKVxuICAgICAgICBpZiAocGFyYW1zLnNjb3JlIDwgMCB8fCBwYXJhbXMuc2NvcmUgPiAxMDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU2NvcmUgTVVTVCBiZSBiZXR3ZWVuIDAgYW5kIDEwMCcpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRhZzEgPSBwYXJhbXMudGFnMSB8fCAnJztcbiAgICAgICAgY29uc3QgdGFnMiA9IHBhcmFtcy50YWcyIHx8ICcnO1xuICAgICAgICBjb25zdCBlbmRwb2ludCA9IHBhcmFtcy5lbmRwb2ludCB8fCAnJztcbiAgICAgICAgY29uc3QgZmVlZGJhY2tIYXNoID0gcGFyYW1zLmZlZWRiYWNrSGFzaCB8fCBldGhlcnMuWmVyb0hhc2g7XG4gICAgICAgIGNvbnN0IGZlZWRiYWNrVXJpID0gcGFyYW1zLmZlZWRiYWNrVXJpIHx8ICcnO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmFkYXB0ZXIuc2VuZCh0aGlzLmNvbnRyYWN0QWRkcmVzcywgUmVwdXRhdGlvblJlZ2lzdHJ5QUJJLCAnZ2l2ZUZlZWRiYWNrJywgW1xuICAgICAgICAgICAgcGFyYW1zLmFnZW50SWQsXG4gICAgICAgICAgICBwYXJhbXMuc2NvcmUsXG4gICAgICAgICAgICB0YWcxLFxuICAgICAgICAgICAgdGFnMixcbiAgICAgICAgICAgIGVuZHBvaW50LFxuICAgICAgICAgICAgZmVlZGJhY2tVcmksXG4gICAgICAgICAgICBmZWVkYmFja0hhc2gsXG4gICAgICAgIF0pO1xuICAgICAgICByZXR1cm4geyB0eEhhc2g6IHJlc3VsdC5oYXNoIHx8IHJlc3VsdC50eEhhc2ggfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV2b2tlIHByZXZpb3VzbHkgc3VibWl0dGVkIGZlZWRiYWNrXG4gICAgICogU3BlYzogZnVuY3Rpb24gcmV2b2tlRmVlZGJhY2sodWludDI1NiBhZ2VudElkLCB1aW50NjQgZmVlZGJhY2tJbmRleClcbiAgICAgKlxuICAgICAqIEBwYXJhbSBhZ2VudElkIC0gVGhlIGFnZW50IElEXG4gICAgICogQHBhcmFtIGZlZWRiYWNrSW5kZXggLSBJbmRleCBvZiBmZWVkYmFjayB0byByZXZva2VcbiAgICAgKi9cbiAgICBhc3luYyByZXZva2VGZWVkYmFjayhhZ2VudElkLCBmZWVkYmFja0luZGV4KSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuYWRhcHRlci5zZW5kKHRoaXMuY29udHJhY3RBZGRyZXNzLCBSZXB1dGF0aW9uUmVnaXN0cnlBQkksICdyZXZva2VGZWVkYmFjaycsIFthZ2VudElkLCBmZWVkYmFja0luZGV4XSk7XG4gICAgICAgIHJldHVybiB7IHR4SGFzaDogcmVzdWx0Lmhhc2ggfHwgcmVzdWx0LnR4SGFzaCB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBcHBlbmQgYSByZXNwb25zZSB0byBleGlzdGluZyBmZWVkYmFja1xuICAgICAqIFNwZWM6IGZ1bmN0aW9uIGFwcGVuZFJlc3BvbnNlKHVpbnQyNTYgYWdlbnRJZCwgYWRkcmVzcyBjbGllbnRBZGRyZXNzLCB1aW50NjQgZmVlZGJhY2tJbmRleCwgc3RyaW5nIGNhbGxkYXRhIHJlc3BvbnNlVXJpLCBieXRlczMyIGNhbGxkYXRhIHJlc3BvbnNlSGFzaClcbiAgICAgKlxuICAgICAqIEBwYXJhbSBhZ2VudElkIC0gVGhlIGFnZW50IElEXG4gICAgICogQHBhcmFtIGNsaWVudEFkZHJlc3MgLSBDbGllbnQgd2hvIGdhdmUgdGhlIGZlZWRiYWNrXG4gICAgICogQHBhcmFtIGZlZWRiYWNrSW5kZXggLSBJbmRleCBvZiB0aGUgZmVlZGJhY2tcbiAgICAgKiBAcGFyYW0gcmVzcG9uc2VVcmkgLSBVUkkgdG8gcmVzcG9uc2UgY29udGVudFxuICAgICAqIEBwYXJhbSByZXNwb25zZUhhc2ggLSBPUFRJT05BTCBoYXNoIG9mIHJlc3BvbnNlIGNvbnRlbnQgKEtFQ0NBSy0yNTYpXG4gICAgICovXG4gICAgYXN5bmMgYXBwZW5kUmVzcG9uc2UoYWdlbnRJZCwgY2xpZW50QWRkcmVzcywgZmVlZGJhY2tJbmRleCwgcmVzcG9uc2VVcmksIHJlc3BvbnNlSGFzaCkge1xuICAgICAgICBjb25zdCBoYXNoID0gcmVzcG9uc2VIYXNoIHx8IGV0aGVycy5aZXJvSGFzaDtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5hZGFwdGVyLnNlbmQodGhpcy5jb250cmFjdEFkZHJlc3MsIFJlcHV0YXRpb25SZWdpc3RyeUFCSSwgJ2FwcGVuZFJlc3BvbnNlJywgW2FnZW50SWQsIGNsaWVudEFkZHJlc3MsIGZlZWRiYWNrSW5kZXgsIHJlc3BvbnNlVXJpLCBoYXNoXSk7XG4gICAgICAgIHJldHVybiB7IHR4SGFzaDogcmVzdWx0Lmhhc2ggfHwgcmVzdWx0LnR4SGFzaCB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGlkZW50aXR5IHJlZ2lzdHJ5IGFkZHJlc3NcbiAgICAgKiBTcGVjOiBmdW5jdGlvbiBnZXRJZGVudGl0eVJlZ2lzdHJ5KCkgZXh0ZXJuYWwgdmlldyByZXR1cm5zIChhZGRyZXNzIGlkZW50aXR5UmVnaXN0cnkpXG4gICAgICovXG4gICAgYXN5bmMgZ2V0SWRlbnRpdHlSZWdpc3RyeSgpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuYWRhcHRlci5jYWxsKHRoaXMuY29udHJhY3RBZGRyZXNzLCBSZXB1dGF0aW9uUmVnaXN0cnlBQkksICdnZXRJZGVudGl0eVJlZ2lzdHJ5JywgW10pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgcmVwdXRhdGlvbiBzdW1tYXJ5IGZvciBhbiBhZ2VudFxuICAgICAqIFVwZGF0ZWQgQUJJOiBnZXRTdW1tYXJ5KHVpbnQyNTYgYWdlbnRJZCwgYWRkcmVzc1tdIGNsaWVudEFkZHJlc3Nlcywgc3RyaW5nIHRhZzEsIHN0cmluZyB0YWcyKVxuICAgICAqIE5vdGU6IGFnZW50SWQgaXMgT05MWSBtYW5kYXRvcnkgcGFyYW1ldGVyLCBvdGhlcnMgYXJlIE9QVElPTkFMIGZpbHRlcnNcbiAgICAgKlxuICAgICAqIEBwYXJhbSBhZ2VudElkIC0gVGhlIGFnZW50IElEIChNQU5EQVRPUlkpXG4gICAgICogQHBhcmFtIGNsaWVudEFkZHJlc3NlcyAtIE9QVElPTkFMIGZpbHRlciBieSBzcGVjaWZpYyBjbGllbnRzXG4gICAgICogQHBhcmFtIHRhZzEgLSBPUFRJT05BTCBmaWx0ZXIgYnkgdGFnMVxuICAgICAqIEBwYXJhbSB0YWcyIC0gT1BUSU9OQUwgZmlsdGVyIGJ5IHRhZzJcbiAgICAgKi9cbiAgICBhc3luYyBnZXRTdW1tYXJ5KGFnZW50SWQsIGNsaWVudEFkZHJlc3NlcywgdGFnMSwgdGFnMikge1xuICAgICAgICBjb25zdCBjbGllbnRzID0gY2xpZW50QWRkcmVzc2VzIHx8IFtdO1xuICAgICAgICBjb25zdCB0MSA9IHRhZzEgfHwgJyc7XG4gICAgICAgIGNvbnN0IHQyID0gdGFnMiB8fCAnJztcbiAgICAgICAgLy8gU29tZSBkZXBsb3llZCBSZXB1dGF0aW9uUmVnaXN0cnkgaW1wbGVtZW50YXRpb25zIHJldmVydCBvbiBlZGdlIGNhc2VzXG4gICAgICAgIC8vIChlLmcuIGVtcHR5IGNsaWVudEFkZHJlc3NlcyAvIGVtcHR5IHRhZ3MpLiBUcmVhdCB0aGF0IGFzIFwibm8gc3VtbWFyeSBhdmFpbGFibGVcIlxuICAgICAgICAvLyBpbnN0ZWFkIG9mIGZhaWxpbmcgdGhlIGVudGlyZSBBUEkgcmVzcG9uc2UuXG4gICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXN1bHQgPSBhd2FpdCB0aGlzLmFkYXB0ZXIuY2FsbCh0aGlzLmNvbnRyYWN0QWRkcmVzcywgUmVwdXRhdGlvblJlZ2lzdHJ5QUJJLCAnZ2V0U3VtbWFyeScsIFthZ2VudElkLCBjbGllbnRzLCB0MSwgdDJdKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ1tSZXB1dGF0aW9uQ2xpZW50LmdldFN1bW1hcnldIGdldFN1bW1hcnkgcmV2ZXJ0ZWQ7IHJldHVybmluZyBkZWZhdWx0IHN1bW1hcnknLCB7XG4gICAgICAgICAgICAgICAgYWdlbnRJZDogYWdlbnRJZC50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgIGNsaWVudENvdW50OiBjbGllbnRzLmxlbmd0aCxcbiAgICAgICAgICAgICAgICB0YWcxOiB0MSxcbiAgICAgICAgICAgICAgICB0YWcyOiB0MixcbiAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4geyBjb3VudDogMG4sIGF2ZXJhZ2VTY29yZTogMCB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb3VudDogQmlnSW50KHJlc3VsdC5jb3VudCB8fCByZXN1bHRbMF0pLFxuICAgICAgICAgICAgYXZlcmFnZVNjb3JlOiBOdW1iZXIocmVzdWx0LmF2ZXJhZ2VTY29yZSB8fCByZXN1bHRbMV0pLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWFkIGEgc3BlY2lmaWMgZmVlZGJhY2sgZW50cnlcbiAgICAgKiBVcGRhdGVkIEFCSTogcmVhZEZlZWRiYWNrKC4uLikgcmV0dXJucyAodWludDggc2NvcmUsIHN0cmluZyB0YWcxLCBzdHJpbmcgdGFnMiwgYm9vbCBpc1Jldm9rZWQpXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYWdlbnRJZCAtIFRoZSBhZ2VudCBJRFxuICAgICAqIEBwYXJhbSBjbGllbnRBZGRyZXNzIC0gQ2xpZW50IHdobyBnYXZlIGZlZWRiYWNrXG4gICAgICogQHBhcmFtIGluZGV4IC0gRmVlZGJhY2sgaW5kZXhcbiAgICAgKi9cbiAgICBhc3luYyByZWFkRmVlZGJhY2soYWdlbnRJZCwgY2xpZW50QWRkcmVzcywgaW5kZXgpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5hZGFwdGVyLmNhbGwodGhpcy5jb250cmFjdEFkZHJlc3MsIFJlcHV0YXRpb25SZWdpc3RyeUFCSSwgJ3JlYWRGZWVkYmFjaycsIFthZ2VudElkLCBjbGllbnRBZGRyZXNzLCBpbmRleF0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc2NvcmU6IE51bWJlcihyZXN1bHQuc2NvcmUgfHwgcmVzdWx0WzBdKSxcbiAgICAgICAgICAgIHRhZzE6IFN0cmluZyhyZXN1bHQudGFnMSB8fCByZXN1bHRbMV0gfHwgJycpLFxuICAgICAgICAgICAgdGFnMjogU3RyaW5nKHJlc3VsdC50YWcyIHx8IHJlc3VsdFsyXSB8fCAnJyksXG4gICAgICAgICAgICBpc1Jldm9rZWQ6IEJvb2xlYW4ocmVzdWx0LmlzUmV2b2tlZCB8fCByZXN1bHRbM10pLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWFkIGFsbCBmZWVkYmFjayBmb3IgYW4gYWdlbnQgd2l0aCBvcHRpb25hbCBmaWx0ZXJzXG4gICAgICogVXBkYXRlZCBBQkk6XG4gICAgICogICByZWFkQWxsRmVlZGJhY2sodWludDI1NiBhZ2VudElkLCBhZGRyZXNzW10gY2xpZW50QWRkcmVzc2VzLCBzdHJpbmcgdGFnMSwgc3RyaW5nIHRhZzIsIGJvb2wgaW5jbHVkZVJldm9rZWQpXG4gICAgICogICByZXR1cm5zIChhZGRyZXNzW10gY2xpZW50cywgdWludDY0W10gZmVlZGJhY2tJbmRleGVzLCB1aW50OFtdIHNjb3Jlcywgc3RyaW5nW10gdGFnMXMsIHN0cmluZ1tdIHRhZzJzLCBib29sW10gcmV2b2tlZFN0YXR1c2VzKVxuICAgICAqIE5vdGU6IGFnZW50SWQgaXMgT05MWSBtYW5kYXRvcnkgcGFyYW1ldGVyXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYWdlbnRJZCAtIFRoZSBhZ2VudCBJRCAoTUFOREFUT1JZKVxuICAgICAqIEBwYXJhbSBjbGllbnRBZGRyZXNzZXMgLSBPUFRJT05BTCBmaWx0ZXIgYnkgY2xpZW50c1xuICAgICAqIEBwYXJhbSB0YWcxIC0gT1BUSU9OQUwgZmlsdGVyIGJ5IHRhZzFcbiAgICAgKiBAcGFyYW0gdGFnMiAtIE9QVElPTkFMIGZpbHRlciBieSB0YWcyXG4gICAgICogQHBhcmFtIGluY2x1ZGVSZXZva2VkIC0gT1BUSU9OQUwgaW5jbHVkZSByZXZva2VkIGZlZWRiYWNrXG4gICAgICovXG4gICAgYXN5bmMgcmVhZEFsbEZlZWRiYWNrKGFnZW50SWQsIGNsaWVudEFkZHJlc3NlcywgdGFnMSwgdGFnMiwgaW5jbHVkZVJldm9rZWQpIHtcbiAgICAgICAgY29uc3QgY2xpZW50cyA9IGNsaWVudEFkZHJlc3NlcyB8fCBbXTtcbiAgICAgICAgY29uc3QgdDEgPSB0YWcxIHx8ICcnO1xuICAgICAgICBjb25zdCB0MiA9IHRhZzIgfHwgJyc7XG4gICAgICAgIGNvbnN0IGluY2x1ZGVSZXYgPSBpbmNsdWRlUmV2b2tlZCB8fCBmYWxzZTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5hZGFwdGVyLmNhbGwodGhpcy5jb250cmFjdEFkZHJlc3MsIFJlcHV0YXRpb25SZWdpc3RyeUFCSSwgJ3JlYWRBbGxGZWVkYmFjaycsIFthZ2VudElkLCBjbGllbnRzLCB0MSwgdDIsIGluY2x1ZGVSZXZdKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNsaWVudEFkZHJlc3NlczogKHJlc3VsdC5jbGllbnRzIHx8IHJlc3VsdFswXSksXG4gICAgICAgICAgICBpbmRleGVzOiAocmVzdWx0LmZlZWRiYWNrSW5kZXhlcyB8fCByZXN1bHRbMV0pLm1hcCgoaSkgPT4gQmlnSW50KGkpKSxcbiAgICAgICAgICAgIHNjb3JlczogKHJlc3VsdC5zY29yZXMgfHwgcmVzdWx0WzJdKS5tYXAoKHMpID0+IE51bWJlcihzKSksXG4gICAgICAgICAgICB0YWcxczogKHJlc3VsdC50YWcxcyB8fCByZXN1bHRbM10pLm1hcCgodCkgPT4gU3RyaW5nKHQgPz8gJycpKSxcbiAgICAgICAgICAgIHRhZzJzOiAocmVzdWx0LnRhZzJzIHx8IHJlc3VsdFs0XSkubWFwKCh0KSA9PiBTdHJpbmcodCA/PyAnJykpLFxuICAgICAgICAgICAgcmV2b2tlZFN0YXR1c2VzOiAocmVzdWx0LnJldm9rZWRTdGF0dXNlcyB8fCByZXN1bHRbNV0pLm1hcCgoYikgPT4gQm9vbGVhbihiKSksXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCByZXNwb25zZSBjb3VudCBmb3IgYSBmZWVkYmFjayBlbnRyeVxuICAgICAqIFNwZWM6IGZ1bmN0aW9uIGdldFJlc3BvbnNlQ291bnQodWludDI1NiBhZ2VudElkLCBhZGRyZXNzIGNsaWVudEFkZHJlc3MsIHVpbnQ2NCBmZWVkYmFja0luZGV4LCBhZGRyZXNzW10gcmVzcG9uZGVycykgcmV0dXJucyAodWludDY0KVxuICAgICAqIE5vdGU6IGFnZW50SWQgaXMgT05MWSBtYW5kYXRvcnkgcGFyYW1ldGVyXG4gICAgICovXG4gICAgYXN5bmMgZ2V0UmVzcG9uc2VDb3VudChhZ2VudElkLCBjbGllbnRBZGRyZXNzLCBmZWVkYmFja0luZGV4LCByZXNwb25kZXJzKSB7XG4gICAgICAgIGNvbnN0IGNsaWVudCA9IGNsaWVudEFkZHJlc3MgfHwgZXRoZXJzLlplcm9BZGRyZXNzO1xuICAgICAgICBjb25zdCBpbmRleCA9IGZlZWRiYWNrSW5kZXggfHwgQmlnSW50KDApO1xuICAgICAgICBjb25zdCByZXNwID0gcmVzcG9uZGVycyB8fCBbXTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5hZGFwdGVyLmNhbGwodGhpcy5jb250cmFjdEFkZHJlc3MsIFJlcHV0YXRpb25SZWdpc3RyeUFCSSwgJ2dldFJlc3BvbnNlQ291bnQnLCBbYWdlbnRJZCwgY2xpZW50LCBpbmRleCwgcmVzcF0pO1xuICAgICAgICByZXR1cm4gQmlnSW50KHJlc3VsdCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhbGwgY2xpZW50cyB3aG8gaGF2ZSBnaXZlbiBmZWVkYmFjayB0byBhbiBhZ2VudFxuICAgICAqIFNwZWM6IGZ1bmN0aW9uIGdldENsaWVudHModWludDI1NiBhZ2VudElkKSByZXR1cm5zIChhZGRyZXNzW10gbWVtb3J5KVxuICAgICAqL1xuICAgIGFzeW5jIGdldENsaWVudHMoYWdlbnRJZCkge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5hZGFwdGVyLmNhbGwodGhpcy5jb250cmFjdEFkZHJlc3MsIFJlcHV0YXRpb25SZWdpc3RyeUFCSSwgJ2dldENsaWVudHMnLCBbYWdlbnRJZF0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGxhc3QgZmVlZGJhY2sgaW5kZXggZnJvbSBhIGNsaWVudCBmb3IgYW4gYWdlbnRcbiAgICAgKiBTcGVjOiBmdW5jdGlvbiBnZXRMYXN0SW5kZXgodWludDI1NiBhZ2VudElkLCBhZGRyZXNzIGNsaWVudEFkZHJlc3MpIHJldHVybnMgKHVpbnQ2NClcbiAgICAgKlxuICAgICAqIEBwYXJhbSBhZ2VudElkIC0gVGhlIGFnZW50IElEXG4gICAgICogQHBhcmFtIGNsaWVudEFkZHJlc3MgLSBDbGllbnQgYWRkcmVzc1xuICAgICAqIEByZXR1cm5zIExhc3QgZmVlZGJhY2sgaW5kZXggKDAgaWYgbm8gZmVlZGJhY2sgeWV0KVxuICAgICAqL1xuICAgIGFzeW5jIGdldExhc3RJbmRleChhZ2VudElkLCBjbGllbnRBZGRyZXNzKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuYWRhcHRlci5jYWxsKHRoaXMuY29udHJhY3RBZGRyZXNzLCBSZXB1dGF0aW9uUmVnaXN0cnlBQkksICdnZXRMYXN0SW5kZXgnLCBbYWdlbnRJZCwgY2xpZW50QWRkcmVzc10pO1xuICAgICAgICByZXR1cm4gQmlnSW50KHJlc3VsdCk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UmVwdXRhdGlvbkNsaWVudC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@agentic-trust/8004-sdk/dist/ReputationClient.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@agentic-trust/8004-sdk/dist/ValidationClient.js":
/*!***************************************************************************!*\
  !*** ../../node_modules/@agentic-trust/8004-sdk/dist/ValidationClient.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ValidationClient: () => (/* binding */ ValidationClient)\n/* harmony export */ });\n/* harmony import */ var _abis_ValidationRegistry_json__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abis/ValidationRegistry.json */ \"(rsc)/../../node_modules/@agentic-trust/8004-sdk/dist/abis/ValidationRegistry.json\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ethers */ \"(rsc)/../../node_modules/ethers/lib.esm/constants/hashes.js\");\n/**\n * Validation Client for ERC-8004\n * Handles validation requests and responses\n */\n\n\nclass ValidationClient {\n    adapter;\n    contractAddress;\n    constructor(adapter, contractAddress) {\n        this.adapter = adapter;\n        this.contractAddress = contractAddress;\n    }\n    /**\n     * Request validation from a validator\n     * Spec: function validationRequest(address validatorAddress, uint256 agentId, string requestUri, bytes32 requestHash)\n     * Note: MUST be called by owner or operator of agentId\n     * Note: requestHash MUST be keccak256 of the content at requestUri\n     *\n     * @param params - Validation request parameters\n     * @returns Transaction result with requestHash\n     */\n    async validationRequest(params) {\n        const result = await this.adapter.send(this.contractAddress, _abis_ValidationRegistry_json__WEBPACK_IMPORTED_MODULE_0__, 'validationRequest', [params.validatorAddress, params.agentId, params.requestUri, params.requestHash]);\n        return {\n            txHash: result.hash || result.txHash,\n            requestHash: params.requestHash,\n        };\n    }\n    /**\n     * Provide a validation response\n     * Spec: function validationResponse(bytes32 requestHash, uint8 response, string responseUri, bytes32 responseHash, bytes32 tag)\n     * Note: MUST be called by the validatorAddress specified in the original request\n     * Note: Can be called multiple times for the same requestHash\n     *\n     * @param params - Validation response parameters\n     * @returns Transaction result\n     */\n    async validationResponse(params) {\n        // Validate response is 0-100\n        if (params.response < 0 || params.response > 100) {\n            throw new Error('Response MUST be between 0 and 100');\n        }\n        // Convert optional parameters to proper format\n        const responseUri = params.responseUri || '';\n        const responseHash = params.responseHash || ethers__WEBPACK_IMPORTED_MODULE_1__.ZeroHash;\n        const tag = params.tag || '';\n        const result = await this.adapter.send(this.contractAddress, _abis_ValidationRegistry_json__WEBPACK_IMPORTED_MODULE_0__, 'validationResponse', \n        // Updated ABI: (bytes32 requestHash, uint8 response, string responseURI, bytes32 responseHash, string tag)\n        [params.requestHash, params.response, responseUri, responseHash, tag]);\n        return { txHash: result.hash || result.txHash };\n    }\n    /**\n     * Get the identity registry address\n     * Spec: function getIdentityRegistry() external view returns (address identityRegistry)\n     */\n    async getIdentityRegistry() {\n        return await this.adapter.call(this.contractAddress, _abis_ValidationRegistry_json__WEBPACK_IMPORTED_MODULE_0__, 'getIdentityRegistry', []);\n    }\n    /**\n     * Get validation status for a request\n     * Spec (new): function getValidationStatus(bytes32 requestHash) returns (address validatorAddress, uint256 agentId, uint8 response, bytes32 responseHash, bytes32 tag, uint256 lastUpdate)\n     * Spec (old): function getValidationStatus(bytes32 requestHash) returns (address validatorAddress, uint256 agentId, uint8 response, bytes32 tag, uint256 lastUpdate)\n     * Note: Backward compatible with both old and new contract versions\n     *\n     * @param requestHash - The request hash (bytes32)\n     * @returns Validation status\n     */\n    async getValidationStatus(requestHash) {\n        try {\n            // Try with new ABI first (6 return values)\n            const result = await this.adapter.call(this.contractAddress, _abis_ValidationRegistry_json__WEBPACK_IMPORTED_MODULE_0__, 'getValidationStatus', [requestHash]);\n            return {\n                validatorAddress: result.validatorAddress || result[0],\n                agentId: BigInt(result.agentId || result[1]),\n                response: Number(result.response || result[2]),\n                responseHash: result.responseHash || result[3],\n                tag: String(result.tag ?? result[4] ?? ''),\n                lastUpdate: BigInt(result.lastUpdate || result[5]),\n            };\n        }\n        catch (error) {\n            // If decoding fails, try with old ABI (5 return values, no responseHash)\n            if (error.code === 'BAD_DATA' || error.message?.includes('could not decode result data')) {\n                // Create old ABI for getValidationStatus without responseHash\n                const oldABI = [\n                    {\n                        inputs: [{ internalType: 'bytes32', name: 'requestHash', type: 'bytes32' }],\n                        name: 'getValidationStatus',\n                        outputs: [\n                            { internalType: 'address', name: 'validatorAddress', type: 'address' },\n                            { internalType: 'uint256', name: 'agentId', type: 'uint256' },\n                            { internalType: 'uint8', name: 'response', type: 'uint8' },\n                            // Old contracts used bytes32 tag\n                            { internalType: 'bytes32', name: 'tag', type: 'bytes32' },\n                            { internalType: 'uint256', name: 'lastUpdate', type: 'uint256' }\n                        ],\n                        stateMutability: 'view',\n                        type: 'function'\n                    }\n                ];\n                const result = await this.adapter.call(this.contractAddress, oldABI, 'getValidationStatus', [requestHash]);\n                return {\n                    validatorAddress: result.validatorAddress || result[0],\n                    agentId: BigInt(result.agentId || result[1]),\n                    response: Number(result.response || result[2]),\n                    responseHash: ethers__WEBPACK_IMPORTED_MODULE_1__.ZeroHash, // Default for old contracts\n                    tag: String(result.tag ?? result[3] ?? ''),\n                    lastUpdate: BigInt(result.lastUpdate || result[4]),\n                };\n            }\n            // Re-throw other errors\n            throw error;\n        }\n    }\n    /**\n     * Get validation summary for an agent\n     * Spec: function getSummary(uint256 agentId, address[] validatorAddresses, bytes32 tag) returns (uint64 count, uint8 avgResponse)\n     * Note: agentId is ONLY mandatory parameter, validatorAddresses and tag are OPTIONAL filters\n     *\n     * @param agentId - The agent ID (MANDATORY)\n     * @param validatorAddresses - OPTIONAL filter by specific validators\n     * @param tag - OPTIONAL filter by tag\n     * @returns Summary statistics\n     */\n    async getSummary(agentId, validatorAddresses, tag) {\n        const validators = validatorAddresses || [];\n        const tagValue = tag || '';\n        const result = await this.adapter.call(this.contractAddress, _abis_ValidationRegistry_json__WEBPACK_IMPORTED_MODULE_0__, 'getSummary', \n        // Updated ABI: tag is string\n        [agentId, validators, tagValue]);\n        return {\n            count: BigInt(result.count || result[0]),\n            avgResponse: Number(result.avgResponse || result[1]),\n        };\n    }\n    /**\n     * Get all validation request hashes for an agent\n     * Spec: function getAgentValidations(uint256 agentId) returns (bytes32[] requestHashes)\n     *\n     * @param agentId - The agent ID\n     * @returns Array of request hashes\n     */\n    async getAgentValidations(agentId) {\n        return await this.adapter.call(this.contractAddress, _abis_ValidationRegistry_json__WEBPACK_IMPORTED_MODULE_0__, 'getAgentValidations', [agentId]);\n    }\n    /**\n     * Get all request hashes for a validator\n     * Spec: function getValidatorRequests(address validatorAddress) returns (bytes32[] requestHashes)\n     *\n     * @param validatorAddress - The validator address\n     * @returns Array of request hashes\n     */\n    async getValidatorRequests(validatorAddress) {\n        return await this.adapter.call(this.contractAddress, _abis_ValidationRegistry_json__WEBPACK_IMPORTED_MODULE_0__, 'getValidatorRequests', [validatorAddress]);\n    }\n}\n//# sourceMappingURL=ValidationClient.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BhZ2VudGljLXRydXN0LzgwMDQtc2RrL2Rpc3QvVmFsaWRhdGlvbkNsaWVudC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNtRTtBQUNuQztBQUN6QjtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLDBEQUFxQjtBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsNENBQWU7QUFDbkU7QUFDQSxxRUFBcUUsMERBQXFCO0FBQzFGO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELDBEQUFxQjtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSwwREFBcUI7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLCtEQUErRDtBQUNsRztBQUNBO0FBQ0EsOEJBQThCLG9FQUFvRTtBQUNsRyw4QkFBOEIsMkRBQTJEO0FBQ3pGLDhCQUE4Qix3REFBd0Q7QUFDdEY7QUFDQSw4QkFBOEIsdURBQXVEO0FBQ3JGLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyw0Q0FBZTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsMERBQXFCO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCwwREFBcUI7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELDBEQUFxQjtBQUNsRjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL2JhcmIvYWEvQXNzb2NpYXRlZEFjY291bnRzL25vZGVfbW9kdWxlcy9AYWdlbnRpYy10cnVzdC84MDA0LXNkay9kaXN0L1ZhbGlkYXRpb25DbGllbnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBWYWxpZGF0aW9uIENsaWVudCBmb3IgRVJDLTgwMDRcbiAqIEhhbmRsZXMgdmFsaWRhdGlvbiByZXF1ZXN0cyBhbmQgcmVzcG9uc2VzXG4gKi9cbmltcG9ydCBWYWxpZGF0aW9uUmVnaXN0cnlBQkkgZnJvbSAnLi9hYmlzL1ZhbGlkYXRpb25SZWdpc3RyeS5qc29uJztcbmltcG9ydCB7IGV0aGVycyB9IGZyb20gJ2V0aGVycyc7XG5leHBvcnQgY2xhc3MgVmFsaWRhdGlvbkNsaWVudCB7XG4gICAgYWRhcHRlcjtcbiAgICBjb250cmFjdEFkZHJlc3M7XG4gICAgY29uc3RydWN0b3IoYWRhcHRlciwgY29udHJhY3RBZGRyZXNzKSB7XG4gICAgICAgIHRoaXMuYWRhcHRlciA9IGFkYXB0ZXI7XG4gICAgICAgIHRoaXMuY29udHJhY3RBZGRyZXNzID0gY29udHJhY3RBZGRyZXNzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXF1ZXN0IHZhbGlkYXRpb24gZnJvbSBhIHZhbGlkYXRvclxuICAgICAqIFNwZWM6IGZ1bmN0aW9uIHZhbGlkYXRpb25SZXF1ZXN0KGFkZHJlc3MgdmFsaWRhdG9yQWRkcmVzcywgdWludDI1NiBhZ2VudElkLCBzdHJpbmcgcmVxdWVzdFVyaSwgYnl0ZXMzMiByZXF1ZXN0SGFzaClcbiAgICAgKiBOb3RlOiBNVVNUIGJlIGNhbGxlZCBieSBvd25lciBvciBvcGVyYXRvciBvZiBhZ2VudElkXG4gICAgICogTm90ZTogcmVxdWVzdEhhc2ggTVVTVCBiZSBrZWNjYWsyNTYgb2YgdGhlIGNvbnRlbnQgYXQgcmVxdWVzdFVyaVxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmFtcyAtIFZhbGlkYXRpb24gcmVxdWVzdCBwYXJhbWV0ZXJzXG4gICAgICogQHJldHVybnMgVHJhbnNhY3Rpb24gcmVzdWx0IHdpdGggcmVxdWVzdEhhc2hcbiAgICAgKi9cbiAgICBhc3luYyB2YWxpZGF0aW9uUmVxdWVzdChwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5hZGFwdGVyLnNlbmQodGhpcy5jb250cmFjdEFkZHJlc3MsIFZhbGlkYXRpb25SZWdpc3RyeUFCSSwgJ3ZhbGlkYXRpb25SZXF1ZXN0JywgW3BhcmFtcy52YWxpZGF0b3JBZGRyZXNzLCBwYXJhbXMuYWdlbnRJZCwgcGFyYW1zLnJlcXVlc3RVcmksIHBhcmFtcy5yZXF1ZXN0SGFzaF0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHhIYXNoOiByZXN1bHQuaGFzaCB8fCByZXN1bHQudHhIYXNoLFxuICAgICAgICAgICAgcmVxdWVzdEhhc2g6IHBhcmFtcy5yZXF1ZXN0SGFzaCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJvdmlkZSBhIHZhbGlkYXRpb24gcmVzcG9uc2VcbiAgICAgKiBTcGVjOiBmdW5jdGlvbiB2YWxpZGF0aW9uUmVzcG9uc2UoYnl0ZXMzMiByZXF1ZXN0SGFzaCwgdWludDggcmVzcG9uc2UsIHN0cmluZyByZXNwb25zZVVyaSwgYnl0ZXMzMiByZXNwb25zZUhhc2gsIGJ5dGVzMzIgdGFnKVxuICAgICAqIE5vdGU6IE1VU1QgYmUgY2FsbGVkIGJ5IHRoZSB2YWxpZGF0b3JBZGRyZXNzIHNwZWNpZmllZCBpbiB0aGUgb3JpZ2luYWwgcmVxdWVzdFxuICAgICAqIE5vdGU6IENhbiBiZSBjYWxsZWQgbXVsdGlwbGUgdGltZXMgZm9yIHRoZSBzYW1lIHJlcXVlc3RIYXNoXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyYW1zIC0gVmFsaWRhdGlvbiByZXNwb25zZSBwYXJhbWV0ZXJzXG4gICAgICogQHJldHVybnMgVHJhbnNhY3Rpb24gcmVzdWx0XG4gICAgICovXG4gICAgYXN5bmMgdmFsaWRhdGlvblJlc3BvbnNlKHBhcmFtcykge1xuICAgICAgICAvLyBWYWxpZGF0ZSByZXNwb25zZSBpcyAwLTEwMFxuICAgICAgICBpZiAocGFyYW1zLnJlc3BvbnNlIDwgMCB8fCBwYXJhbXMucmVzcG9uc2UgPiAxMDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUmVzcG9uc2UgTVVTVCBiZSBiZXR3ZWVuIDAgYW5kIDEwMCcpO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbnZlcnQgb3B0aW9uYWwgcGFyYW1ldGVycyB0byBwcm9wZXIgZm9ybWF0XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlVXJpID0gcGFyYW1zLnJlc3BvbnNlVXJpIHx8ICcnO1xuICAgICAgICBjb25zdCByZXNwb25zZUhhc2ggPSBwYXJhbXMucmVzcG9uc2VIYXNoIHx8IGV0aGVycy5aZXJvSGFzaDtcbiAgICAgICAgY29uc3QgdGFnID0gcGFyYW1zLnRhZyB8fCAnJztcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5hZGFwdGVyLnNlbmQodGhpcy5jb250cmFjdEFkZHJlc3MsIFZhbGlkYXRpb25SZWdpc3RyeUFCSSwgJ3ZhbGlkYXRpb25SZXNwb25zZScsIFxuICAgICAgICAvLyBVcGRhdGVkIEFCSTogKGJ5dGVzMzIgcmVxdWVzdEhhc2gsIHVpbnQ4IHJlc3BvbnNlLCBzdHJpbmcgcmVzcG9uc2VVUkksIGJ5dGVzMzIgcmVzcG9uc2VIYXNoLCBzdHJpbmcgdGFnKVxuICAgICAgICBbcGFyYW1zLnJlcXVlc3RIYXNoLCBwYXJhbXMucmVzcG9uc2UsIHJlc3BvbnNlVXJpLCByZXNwb25zZUhhc2gsIHRhZ10pO1xuICAgICAgICByZXR1cm4geyB0eEhhc2g6IHJlc3VsdC5oYXNoIHx8IHJlc3VsdC50eEhhc2ggfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBpZGVudGl0eSByZWdpc3RyeSBhZGRyZXNzXG4gICAgICogU3BlYzogZnVuY3Rpb24gZ2V0SWRlbnRpdHlSZWdpc3RyeSgpIGV4dGVybmFsIHZpZXcgcmV0dXJucyAoYWRkcmVzcyBpZGVudGl0eVJlZ2lzdHJ5KVxuICAgICAqL1xuICAgIGFzeW5jIGdldElkZW50aXR5UmVnaXN0cnkoKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmFkYXB0ZXIuY2FsbCh0aGlzLmNvbnRyYWN0QWRkcmVzcywgVmFsaWRhdGlvblJlZ2lzdHJ5QUJJLCAnZ2V0SWRlbnRpdHlSZWdpc3RyeScsIFtdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHZhbGlkYXRpb24gc3RhdHVzIGZvciBhIHJlcXVlc3RcbiAgICAgKiBTcGVjIChuZXcpOiBmdW5jdGlvbiBnZXRWYWxpZGF0aW9uU3RhdHVzKGJ5dGVzMzIgcmVxdWVzdEhhc2gpIHJldHVybnMgKGFkZHJlc3MgdmFsaWRhdG9yQWRkcmVzcywgdWludDI1NiBhZ2VudElkLCB1aW50OCByZXNwb25zZSwgYnl0ZXMzMiByZXNwb25zZUhhc2gsIGJ5dGVzMzIgdGFnLCB1aW50MjU2IGxhc3RVcGRhdGUpXG4gICAgICogU3BlYyAob2xkKTogZnVuY3Rpb24gZ2V0VmFsaWRhdGlvblN0YXR1cyhieXRlczMyIHJlcXVlc3RIYXNoKSByZXR1cm5zIChhZGRyZXNzIHZhbGlkYXRvckFkZHJlc3MsIHVpbnQyNTYgYWdlbnRJZCwgdWludDggcmVzcG9uc2UsIGJ5dGVzMzIgdGFnLCB1aW50MjU2IGxhc3RVcGRhdGUpXG4gICAgICogTm90ZTogQmFja3dhcmQgY29tcGF0aWJsZSB3aXRoIGJvdGggb2xkIGFuZCBuZXcgY29udHJhY3QgdmVyc2lvbnNcbiAgICAgKlxuICAgICAqIEBwYXJhbSByZXF1ZXN0SGFzaCAtIFRoZSByZXF1ZXN0IGhhc2ggKGJ5dGVzMzIpXG4gICAgICogQHJldHVybnMgVmFsaWRhdGlvbiBzdGF0dXNcbiAgICAgKi9cbiAgICBhc3luYyBnZXRWYWxpZGF0aW9uU3RhdHVzKHJlcXVlc3RIYXNoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBUcnkgd2l0aCBuZXcgQUJJIGZpcnN0ICg2IHJldHVybiB2YWx1ZXMpXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmFkYXB0ZXIuY2FsbCh0aGlzLmNvbnRyYWN0QWRkcmVzcywgVmFsaWRhdGlvblJlZ2lzdHJ5QUJJLCAnZ2V0VmFsaWRhdGlvblN0YXR1cycsIFtyZXF1ZXN0SGFzaF0pO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB2YWxpZGF0b3JBZGRyZXNzOiByZXN1bHQudmFsaWRhdG9yQWRkcmVzcyB8fCByZXN1bHRbMF0sXG4gICAgICAgICAgICAgICAgYWdlbnRJZDogQmlnSW50KHJlc3VsdC5hZ2VudElkIHx8IHJlc3VsdFsxXSksXG4gICAgICAgICAgICAgICAgcmVzcG9uc2U6IE51bWJlcihyZXN1bHQucmVzcG9uc2UgfHwgcmVzdWx0WzJdKSxcbiAgICAgICAgICAgICAgICByZXNwb25zZUhhc2g6IHJlc3VsdC5yZXNwb25zZUhhc2ggfHwgcmVzdWx0WzNdLFxuICAgICAgICAgICAgICAgIHRhZzogU3RyaW5nKHJlc3VsdC50YWcgPz8gcmVzdWx0WzRdID8/ICcnKSxcbiAgICAgICAgICAgICAgICBsYXN0VXBkYXRlOiBCaWdJbnQocmVzdWx0Lmxhc3RVcGRhdGUgfHwgcmVzdWx0WzVdKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAvLyBJZiBkZWNvZGluZyBmYWlscywgdHJ5IHdpdGggb2xkIEFCSSAoNSByZXR1cm4gdmFsdWVzLCBubyByZXNwb25zZUhhc2gpXG4gICAgICAgICAgICBpZiAoZXJyb3IuY29kZSA9PT0gJ0JBRF9EQVRBJyB8fCBlcnJvci5tZXNzYWdlPy5pbmNsdWRlcygnY291bGQgbm90IGRlY29kZSByZXN1bHQgZGF0YScpKSB7XG4gICAgICAgICAgICAgICAgLy8gQ3JlYXRlIG9sZCBBQkkgZm9yIGdldFZhbGlkYXRpb25TdGF0dXMgd2l0aG91dCByZXNwb25zZUhhc2hcbiAgICAgICAgICAgICAgICBjb25zdCBvbGRBQkkgPSBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0czogW3sgaW50ZXJuYWxUeXBlOiAnYnl0ZXMzMicsIG5hbWU6ICdyZXF1ZXN0SGFzaCcsIHR5cGU6ICdieXRlczMyJyB9XSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdnZXRWYWxpZGF0aW9uU3RhdHVzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dHM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IGludGVybmFsVHlwZTogJ2FkZHJlc3MnLCBuYW1lOiAndmFsaWRhdG9yQWRkcmVzcycsIHR5cGU6ICdhZGRyZXNzJyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgaW50ZXJuYWxUeXBlOiAndWludDI1NicsIG5hbWU6ICdhZ2VudElkJywgdHlwZTogJ3VpbnQyNTYnIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBpbnRlcm5hbFR5cGU6ICd1aW50OCcsIG5hbWU6ICdyZXNwb25zZScsIHR5cGU6ICd1aW50OCcgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBPbGQgY29udHJhY3RzIHVzZWQgYnl0ZXMzMiB0YWdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IGludGVybmFsVHlwZTogJ2J5dGVzMzInLCBuYW1lOiAndGFnJywgdHlwZTogJ2J5dGVzMzInIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBpbnRlcm5hbFR5cGU6ICd1aW50MjU2JywgbmFtZTogJ2xhc3RVcGRhdGUnLCB0eXBlOiAndWludDI1NicgfVxuICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlTXV0YWJpbGl0eTogJ3ZpZXcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmFkYXB0ZXIuY2FsbCh0aGlzLmNvbnRyYWN0QWRkcmVzcywgb2xkQUJJLCAnZ2V0VmFsaWRhdGlvblN0YXR1cycsIFtyZXF1ZXN0SGFzaF0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHZhbGlkYXRvckFkZHJlc3M6IHJlc3VsdC52YWxpZGF0b3JBZGRyZXNzIHx8IHJlc3VsdFswXSxcbiAgICAgICAgICAgICAgICAgICAgYWdlbnRJZDogQmlnSW50KHJlc3VsdC5hZ2VudElkIHx8IHJlc3VsdFsxXSksXG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlOiBOdW1iZXIocmVzdWx0LnJlc3BvbnNlIHx8IHJlc3VsdFsyXSksXG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlSGFzaDogZXRoZXJzLlplcm9IYXNoLCAvLyBEZWZhdWx0IGZvciBvbGQgY29udHJhY3RzXG4gICAgICAgICAgICAgICAgICAgIHRhZzogU3RyaW5nKHJlc3VsdC50YWcgPz8gcmVzdWx0WzNdID8/ICcnKSxcbiAgICAgICAgICAgICAgICAgICAgbGFzdFVwZGF0ZTogQmlnSW50KHJlc3VsdC5sYXN0VXBkYXRlIHx8IHJlc3VsdFs0XSksXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFJlLXRocm93IG90aGVyIGVycm9yc1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHZhbGlkYXRpb24gc3VtbWFyeSBmb3IgYW4gYWdlbnRcbiAgICAgKiBTcGVjOiBmdW5jdGlvbiBnZXRTdW1tYXJ5KHVpbnQyNTYgYWdlbnRJZCwgYWRkcmVzc1tdIHZhbGlkYXRvckFkZHJlc3NlcywgYnl0ZXMzMiB0YWcpIHJldHVybnMgKHVpbnQ2NCBjb3VudCwgdWludDggYXZnUmVzcG9uc2UpXG4gICAgICogTm90ZTogYWdlbnRJZCBpcyBPTkxZIG1hbmRhdG9yeSBwYXJhbWV0ZXIsIHZhbGlkYXRvckFkZHJlc3NlcyBhbmQgdGFnIGFyZSBPUFRJT05BTCBmaWx0ZXJzXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYWdlbnRJZCAtIFRoZSBhZ2VudCBJRCAoTUFOREFUT1JZKVxuICAgICAqIEBwYXJhbSB2YWxpZGF0b3JBZGRyZXNzZXMgLSBPUFRJT05BTCBmaWx0ZXIgYnkgc3BlY2lmaWMgdmFsaWRhdG9yc1xuICAgICAqIEBwYXJhbSB0YWcgLSBPUFRJT05BTCBmaWx0ZXIgYnkgdGFnXG4gICAgICogQHJldHVybnMgU3VtbWFyeSBzdGF0aXN0aWNzXG4gICAgICovXG4gICAgYXN5bmMgZ2V0U3VtbWFyeShhZ2VudElkLCB2YWxpZGF0b3JBZGRyZXNzZXMsIHRhZykge1xuICAgICAgICBjb25zdCB2YWxpZGF0b3JzID0gdmFsaWRhdG9yQWRkcmVzc2VzIHx8IFtdO1xuICAgICAgICBjb25zdCB0YWdWYWx1ZSA9IHRhZyB8fCAnJztcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5hZGFwdGVyLmNhbGwodGhpcy5jb250cmFjdEFkZHJlc3MsIFZhbGlkYXRpb25SZWdpc3RyeUFCSSwgJ2dldFN1bW1hcnknLCBcbiAgICAgICAgLy8gVXBkYXRlZCBBQkk6IHRhZyBpcyBzdHJpbmdcbiAgICAgICAgW2FnZW50SWQsIHZhbGlkYXRvcnMsIHRhZ1ZhbHVlXSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb3VudDogQmlnSW50KHJlc3VsdC5jb3VudCB8fCByZXN1bHRbMF0pLFxuICAgICAgICAgICAgYXZnUmVzcG9uc2U6IE51bWJlcihyZXN1bHQuYXZnUmVzcG9uc2UgfHwgcmVzdWx0WzFdKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGFsbCB2YWxpZGF0aW9uIHJlcXVlc3QgaGFzaGVzIGZvciBhbiBhZ2VudFxuICAgICAqIFNwZWM6IGZ1bmN0aW9uIGdldEFnZW50VmFsaWRhdGlvbnModWludDI1NiBhZ2VudElkKSByZXR1cm5zIChieXRlczMyW10gcmVxdWVzdEhhc2hlcylcbiAgICAgKlxuICAgICAqIEBwYXJhbSBhZ2VudElkIC0gVGhlIGFnZW50IElEXG4gICAgICogQHJldHVybnMgQXJyYXkgb2YgcmVxdWVzdCBoYXNoZXNcbiAgICAgKi9cbiAgICBhc3luYyBnZXRBZ2VudFZhbGlkYXRpb25zKGFnZW50SWQpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuYWRhcHRlci5jYWxsKHRoaXMuY29udHJhY3RBZGRyZXNzLCBWYWxpZGF0aW9uUmVnaXN0cnlBQkksICdnZXRBZ2VudFZhbGlkYXRpb25zJywgW2FnZW50SWRdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGFsbCByZXF1ZXN0IGhhc2hlcyBmb3IgYSB2YWxpZGF0b3JcbiAgICAgKiBTcGVjOiBmdW5jdGlvbiBnZXRWYWxpZGF0b3JSZXF1ZXN0cyhhZGRyZXNzIHZhbGlkYXRvckFkZHJlc3MpIHJldHVybnMgKGJ5dGVzMzJbXSByZXF1ZXN0SGFzaGVzKVxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbGlkYXRvckFkZHJlc3MgLSBUaGUgdmFsaWRhdG9yIGFkZHJlc3NcbiAgICAgKiBAcmV0dXJucyBBcnJheSBvZiByZXF1ZXN0IGhhc2hlc1xuICAgICAqL1xuICAgIGFzeW5jIGdldFZhbGlkYXRvclJlcXVlc3RzKHZhbGlkYXRvckFkZHJlc3MpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuYWRhcHRlci5jYWxsKHRoaXMuY29udHJhY3RBZGRyZXNzLCBWYWxpZGF0aW9uUmVnaXN0cnlBQkksICdnZXRWYWxpZGF0b3JSZXF1ZXN0cycsIFt2YWxpZGF0b3JBZGRyZXNzXSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VmFsaWRhdGlvbkNsaWVudC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@agentic-trust/8004-sdk/dist/ValidationClient.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@agentic-trust/8004-sdk/dist/abis/IdentityRegistry.json":
/*!**********************************************************************************!*\
  !*** ../../node_modules/@agentic-trust/8004-sdk/dist/abis/IdentityRegistry.json ***!
  \**********************************************************************************/
/***/ ((module) => {

module.exports = /*#__PURE__*/JSON.parse('[{"inputs":[],"stateMutability":"nonpayable","type":"constructor"},{"inputs":[{"internalType":"address","name":"target","type":"address"}],"name":"AddressEmptyCode","type":"error"},{"inputs":[],"name":"ECDSAInvalidSignature","type":"error"},{"inputs":[{"internalType":"uint256","name":"length","type":"uint256"}],"name":"ECDSAInvalidSignatureLength","type":"error"},{"inputs":[{"internalType":"bytes32","name":"s","type":"bytes32"}],"name":"ECDSAInvalidSignatureS","type":"error"},{"inputs":[{"internalType":"address","name":"implementation","type":"address"}],"name":"ERC1967InvalidImplementation","type":"error"},{"inputs":[],"name":"ERC1967NonPayable","type":"error"},{"inputs":[{"internalType":"address","name":"sender","type":"address"},{"internalType":"uint256","name":"tokenId","type":"uint256"},{"internalType":"address","name":"owner","type":"address"}],"name":"ERC721IncorrectOwner","type":"error"},{"inputs":[{"internalType":"address","name":"operator","type":"address"},{"internalType":"uint256","name":"tokenId","type":"uint256"}],"name":"ERC721InsufficientApproval","type":"error"},{"inputs":[{"internalType":"address","name":"approver","type":"address"}],"name":"ERC721InvalidApprover","type":"error"},{"inputs":[{"internalType":"address","name":"operator","type":"address"}],"name":"ERC721InvalidOperator","type":"error"},{"inputs":[{"internalType":"address","name":"owner","type":"address"}],"name":"ERC721InvalidOwner","type":"error"},{"inputs":[{"internalType":"address","name":"receiver","type":"address"}],"name":"ERC721InvalidReceiver","type":"error"},{"inputs":[{"internalType":"address","name":"sender","type":"address"}],"name":"ERC721InvalidSender","type":"error"},{"inputs":[{"internalType":"uint256","name":"tokenId","type":"uint256"}],"name":"ERC721NonexistentToken","type":"error"},{"inputs":[],"name":"FailedCall","type":"error"},{"inputs":[],"name":"InvalidInitialization","type":"error"},{"inputs":[],"name":"NotInitializing","type":"error"},{"inputs":[{"internalType":"address","name":"owner","type":"address"}],"name":"OwnableInvalidOwner","type":"error"},{"inputs":[{"internalType":"address","name":"account","type":"address"}],"name":"OwnableUnauthorizedAccount","type":"error"},{"inputs":[],"name":"UUPSUnauthorizedCallContext","type":"error"},{"inputs":[{"internalType":"bytes32","name":"slot","type":"bytes32"}],"name":"UUPSUnsupportedProxiableUUID","type":"error"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"owner","type":"address"},{"indexed":true,"internalType":"address","name":"approved","type":"address"},{"indexed":true,"internalType":"uint256","name":"tokenId","type":"uint256"}],"name":"Approval","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"owner","type":"address"},{"indexed":true,"internalType":"address","name":"operator","type":"address"},{"indexed":false,"internalType":"bool","name":"approved","type":"bool"}],"name":"ApprovalForAll","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"_fromTokenId","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"_toTokenId","type":"uint256"}],"name":"BatchMetadataUpdate","type":"event"},{"anonymous":false,"inputs":[],"name":"EIP712DomainChanged","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint64","name":"version","type":"uint64"}],"name":"Initialized","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"uint256","name":"agentId","type":"uint256"},{"indexed":true,"internalType":"string","name":"indexedMetadataKey","type":"string"},{"indexed":false,"internalType":"string","name":"metadataKey","type":"string"},{"indexed":false,"internalType":"bytes","name":"metadataValue","type":"bytes"}],"name":"MetadataSet","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"_tokenId","type":"uint256"}],"name":"MetadataUpdate","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"previousOwner","type":"address"},{"indexed":true,"internalType":"address","name":"newOwner","type":"address"}],"name":"OwnershipTransferred","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"uint256","name":"agentId","type":"uint256"},{"indexed":false,"internalType":"string","name":"agentURI","type":"string"},{"indexed":true,"internalType":"address","name":"owner","type":"address"}],"name":"Registered","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"from","type":"address"},{"indexed":true,"internalType":"address","name":"to","type":"address"},{"indexed":true,"internalType":"uint256","name":"tokenId","type":"uint256"}],"name":"Transfer","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"uint256","name":"agentId","type":"uint256"},{"indexed":false,"internalType":"string","name":"newURI","type":"string"},{"indexed":true,"internalType":"address","name":"updatedBy","type":"address"}],"name":"URIUpdated","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"implementation","type":"address"}],"name":"Upgraded","type":"event"},{"inputs":[],"name":"UPGRADE_INTERFACE_VERSION","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"tokenId","type":"uint256"}],"name":"approve","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"owner","type":"address"}],"name":"balanceOf","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"eip712Domain","outputs":[{"internalType":"bytes1","name":"fields","type":"bytes1"},{"internalType":"string","name":"name","type":"string"},{"internalType":"string","name":"version","type":"string"},{"internalType":"uint256","name":"chainId","type":"uint256"},{"internalType":"address","name":"verifyingContract","type":"address"},{"internalType":"bytes32","name":"salt","type":"bytes32"},{"internalType":"uint256[]","name":"extensions","type":"uint256[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"agentId","type":"uint256"}],"name":"getAgentWallet","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"tokenId","type":"uint256"}],"name":"getApproved","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"agentId","type":"uint256"},{"internalType":"string","name":"metadataKey","type":"string"}],"name":"getMetadata","outputs":[{"internalType":"bytes","name":"","type":"bytes"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getVersion","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"pure","type":"function"},{"inputs":[],"name":"initialize","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"owner","type":"address"},{"internalType":"address","name":"operator","type":"address"}],"name":"isApprovedForAll","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"name","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"owner","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"tokenId","type":"uint256"}],"name":"ownerOf","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"proxiableUUID","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"register","outputs":[{"internalType":"uint256","name":"agentId","type":"uint256"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"string","name":"agentURI","type":"string"},{"components":[{"internalType":"string","name":"metadataKey","type":"string"},{"internalType":"bytes","name":"metadataValue","type":"bytes"}],"internalType":"struct IdentityRegistryUpgradeable.MetadataEntry[]","name":"metadata","type":"tuple[]"}],"name":"register","outputs":[{"internalType":"uint256","name":"agentId","type":"uint256"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"string","name":"agentURI","type":"string"}],"name":"register","outputs":[{"internalType":"uint256","name":"agentId","type":"uint256"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"renounceOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"from","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"tokenId","type":"uint256"}],"name":"safeTransferFrom","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"from","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"tokenId","type":"uint256"},{"internalType":"bytes","name":"data","type":"bytes"}],"name":"safeTransferFrom","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"agentId","type":"uint256"},{"internalType":"string","name":"newURI","type":"string"}],"name":"setAgentURI","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"agentId","type":"uint256"},{"internalType":"address","name":"newWallet","type":"address"},{"internalType":"uint256","name":"deadline","type":"uint256"},{"internalType":"bytes","name":"signature","type":"bytes"}],"name":"setAgentWallet","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"operator","type":"address"},{"internalType":"bool","name":"approved","type":"bool"}],"name":"setApprovalForAll","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"agentId","type":"uint256"},{"internalType":"string","name":"metadataKey","type":"string"},{"internalType":"bytes","name":"metadataValue","type":"bytes"}],"name":"setMetadata","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes4","name":"interfaceId","type":"bytes4"}],"name":"supportsInterface","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"symbol","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"tokenId","type":"uint256"}],"name":"tokenURI","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"from","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"tokenId","type":"uint256"}],"name":"transferFrom","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"newOwner","type":"address"}],"name":"transferOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"newImplementation","type":"address"},{"internalType":"bytes","name":"data","type":"bytes"}],"name":"upgradeToAndCall","outputs":[],"stateMutability":"payable","type":"function"}]');

/***/ }),

/***/ "(rsc)/../../node_modules/@agentic-trust/8004-sdk/dist/abis/ReputationRegistry.json":
/*!************************************************************************************!*\
  !*** ../../node_modules/@agentic-trust/8004-sdk/dist/abis/ReputationRegistry.json ***!
  \************************************************************************************/
/***/ ((module) => {

module.exports = /*#__PURE__*/JSON.parse('[{"inputs":[],"stateMutability":"nonpayable","type":"constructor"},{"inputs":[{"internalType":"address","name":"target","type":"address"}],"name":"AddressEmptyCode","type":"error"},{"inputs":[{"internalType":"address","name":"implementation","type":"address"}],"name":"ERC1967InvalidImplementation","type":"error"},{"inputs":[],"name":"ERC1967NonPayable","type":"error"},{"inputs":[],"name":"FailedCall","type":"error"},{"inputs":[],"name":"InvalidInitialization","type":"error"},{"inputs":[],"name":"NotInitializing","type":"error"},{"inputs":[{"internalType":"address","name":"owner","type":"address"}],"name":"OwnableInvalidOwner","type":"error"},{"inputs":[{"internalType":"address","name":"account","type":"address"}],"name":"OwnableUnauthorizedAccount","type":"error"},{"inputs":[],"name":"UUPSUnauthorizedCallContext","type":"error"},{"inputs":[{"internalType":"bytes32","name":"slot","type":"bytes32"}],"name":"UUPSUnsupportedProxiableUUID","type":"error"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"uint256","name":"agentId","type":"uint256"},{"indexed":true,"internalType":"address","name":"clientAddress","type":"address"},{"indexed":true,"internalType":"uint64","name":"feedbackIndex","type":"uint64"}],"name":"FeedbackRevoked","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint64","name":"version","type":"uint64"}],"name":"Initialized","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"uint256","name":"agentId","type":"uint256"},{"indexed":true,"internalType":"address","name":"clientAddress","type":"address"},{"indexed":false,"internalType":"uint64","name":"feedbackIndex","type":"uint64"},{"indexed":false,"internalType":"uint8","name":"score","type":"uint8"},{"indexed":true,"internalType":"string","name":"tag1","type":"string"},{"indexed":false,"internalType":"string","name":"tag2","type":"string"},{"indexed":false,"internalType":"string","name":"endpoint","type":"string"},{"indexed":false,"internalType":"string","name":"feedbackURI","type":"string"},{"indexed":false,"internalType":"bytes32","name":"feedbackHash","type":"bytes32"}],"name":"NewFeedback","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"previousOwner","type":"address"},{"indexed":true,"internalType":"address","name":"newOwner","type":"address"}],"name":"OwnershipTransferred","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"uint256","name":"agentId","type":"uint256"},{"indexed":true,"internalType":"address","name":"clientAddress","type":"address"},{"indexed":false,"internalType":"uint64","name":"feedbackIndex","type":"uint64"},{"indexed":true,"internalType":"address","name":"responder","type":"address"},{"indexed":false,"internalType":"string","name":"responseURI","type":"string"},{"indexed":false,"internalType":"bytes32","name":"responseHash","type":"bytes32"}],"name":"ResponseAppended","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"implementation","type":"address"}],"name":"Upgraded","type":"event"},{"inputs":[],"name":"UPGRADE_INTERFACE_VERSION","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"agentId","type":"uint256"},{"internalType":"address","name":"clientAddress","type":"address"},{"internalType":"uint64","name":"feedbackIndex","type":"uint64"},{"internalType":"string","name":"responseURI","type":"string"},{"internalType":"bytes32","name":"responseHash","type":"bytes32"}],"name":"appendResponse","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"agentId","type":"uint256"}],"name":"getClients","outputs":[{"internalType":"address[]","name":"","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getIdentityRegistry","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"agentId","type":"uint256"},{"internalType":"address","name":"clientAddress","type":"address"}],"name":"getLastIndex","outputs":[{"internalType":"uint64","name":"","type":"uint64"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"agentId","type":"uint256"},{"internalType":"address","name":"clientAddress","type":"address"},{"internalType":"uint64","name":"feedbackIndex","type":"uint64"},{"internalType":"address[]","name":"responders","type":"address[]"}],"name":"getResponseCount","outputs":[{"internalType":"uint64","name":"count","type":"uint64"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"agentId","type":"uint256"},{"internalType":"address[]","name":"clientAddresses","type":"address[]"},{"internalType":"string","name":"tag1","type":"string"},{"internalType":"string","name":"tag2","type":"string"}],"name":"getSummary","outputs":[{"internalType":"uint64","name":"count","type":"uint64"},{"internalType":"uint8","name":"averageScore","type":"uint8"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getVersion","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"uint256","name":"agentId","type":"uint256"},{"internalType":"uint8","name":"score","type":"uint8"},{"internalType":"string","name":"tag1","type":"string"},{"internalType":"string","name":"tag2","type":"string"},{"internalType":"string","name":"endpoint","type":"string"},{"internalType":"string","name":"feedbackURI","type":"string"},{"internalType":"bytes32","name":"feedbackHash","type":"bytes32"}],"name":"giveFeedback","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"identityRegistry_","type":"address"}],"name":"initialize","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"owner","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"proxiableUUID","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"agentId","type":"uint256"},{"internalType":"address[]","name":"clientAddresses","type":"address[]"},{"internalType":"string","name":"tag1","type":"string"},{"internalType":"string","name":"tag2","type":"string"},{"internalType":"bool","name":"includeRevoked","type":"bool"}],"name":"readAllFeedback","outputs":[{"internalType":"address[]","name":"clients","type":"address[]"},{"internalType":"uint64[]","name":"feedbackIndexes","type":"uint64[]"},{"internalType":"uint8[]","name":"scores","type":"uint8[]"},{"internalType":"string[]","name":"tag1s","type":"string[]"},{"internalType":"string[]","name":"tag2s","type":"string[]"},{"internalType":"bool[]","name":"revokedStatuses","type":"bool[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"agentId","type":"uint256"},{"internalType":"address","name":"clientAddress","type":"address"},{"internalType":"uint64","name":"index","type":"uint64"}],"name":"readFeedback","outputs":[{"internalType":"uint8","name":"score","type":"uint8"},{"internalType":"string","name":"tag1","type":"string"},{"internalType":"string","name":"tag2","type":"string"},{"internalType":"bool","name":"isRevoked","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"renounceOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"agentId","type":"uint256"},{"internalType":"uint64","name":"feedbackIndex","type":"uint64"}],"name":"revokeFeedback","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"newOwner","type":"address"}],"name":"transferOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"newImplementation","type":"address"},{"internalType":"bytes","name":"data","type":"bytes"}],"name":"upgradeToAndCall","outputs":[],"stateMutability":"payable","type":"function"}]');

/***/ }),

/***/ "(rsc)/../../node_modules/@agentic-trust/8004-sdk/dist/abis/ValidationRegistry.json":
/*!************************************************************************************!*\
  !*** ../../node_modules/@agentic-trust/8004-sdk/dist/abis/ValidationRegistry.json ***!
  \************************************************************************************/
/***/ ((module) => {

module.exports = /*#__PURE__*/JSON.parse('[{"inputs":[],"stateMutability":"nonpayable","type":"constructor"},{"inputs":[{"internalType":"address","name":"target","type":"address"}],"name":"AddressEmptyCode","type":"error"},{"inputs":[{"internalType":"address","name":"implementation","type":"address"}],"name":"ERC1967InvalidImplementation","type":"error"},{"inputs":[],"name":"ERC1967NonPayable","type":"error"},{"inputs":[],"name":"FailedCall","type":"error"},{"inputs":[],"name":"InvalidInitialization","type":"error"},{"inputs":[],"name":"NotInitializing","type":"error"},{"inputs":[{"internalType":"address","name":"owner","type":"address"}],"name":"OwnableInvalidOwner","type":"error"},{"inputs":[{"internalType":"address","name":"account","type":"address"}],"name":"OwnableUnauthorizedAccount","type":"error"},{"inputs":[],"name":"UUPSUnauthorizedCallContext","type":"error"},{"inputs":[{"internalType":"bytes32","name":"slot","type":"bytes32"}],"name":"UUPSUnsupportedProxiableUUID","type":"error"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint64","name":"version","type":"uint64"}],"name":"Initialized","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"previousOwner","type":"address"},{"indexed":true,"internalType":"address","name":"newOwner","type":"address"}],"name":"OwnershipTransferred","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"implementation","type":"address"}],"name":"Upgraded","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"validatorAddress","type":"address"},{"indexed":true,"internalType":"uint256","name":"agentId","type":"uint256"},{"indexed":false,"internalType":"string","name":"requestURI","type":"string"},{"indexed":true,"internalType":"bytes32","name":"requestHash","type":"bytes32"}],"name":"ValidationRequest","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"validatorAddress","type":"address"},{"indexed":true,"internalType":"uint256","name":"agentId","type":"uint256"},{"indexed":true,"internalType":"bytes32","name":"requestHash","type":"bytes32"},{"indexed":false,"internalType":"uint8","name":"response","type":"uint8"},{"indexed":false,"internalType":"string","name":"responseURI","type":"string"},{"indexed":false,"internalType":"bytes32","name":"responseHash","type":"bytes32"},{"indexed":false,"internalType":"string","name":"tag","type":"string"}],"name":"ValidationResponse","type":"event"},{"inputs":[],"name":"UPGRADE_INTERFACE_VERSION","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"agentId","type":"uint256"}],"name":"getAgentValidations","outputs":[{"internalType":"bytes32[]","name":"","type":"bytes32[]"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getIdentityRegistry","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"agentId","type":"uint256"},{"internalType":"address[]","name":"validatorAddresses","type":"address[]"},{"internalType":"string","name":"tag","type":"string"}],"name":"getSummary","outputs":[{"internalType":"uint64","name":"count","type":"uint64"},{"internalType":"uint8","name":"avgResponse","type":"uint8"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"requestHash","type":"bytes32"}],"name":"getValidationStatus","outputs":[{"internalType":"address","name":"validatorAddress","type":"address"},{"internalType":"uint256","name":"agentId","type":"uint256"},{"internalType":"uint8","name":"response","type":"uint8"},{"internalType":"bytes32","name":"responseHash","type":"bytes32"},{"internalType":"string","name":"tag","type":"string"},{"internalType":"uint256","name":"lastUpdate","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"validatorAddress","type":"address"}],"name":"getValidatorRequests","outputs":[{"internalType":"bytes32[]","name":"","type":"bytes32[]"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getVersion","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"address","name":"identityRegistry_","type":"address"}],"name":"initialize","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"owner","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"proxiableUUID","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"renounceOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"newOwner","type":"address"}],"name":"transferOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"newImplementation","type":"address"},{"internalType":"bytes","name":"data","type":"bytes"}],"name":"upgradeToAndCall","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"address","name":"validatorAddress","type":"address"},{"internalType":"uint256","name":"agentId","type":"uint256"},{"internalType":"string","name":"requestURI","type":"string"},{"internalType":"bytes32","name":"requestHash","type":"bytes32"}],"name":"validationRequest","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"requestHash","type":"bytes32"},{"internalType":"uint8","name":"response","type":"uint8"},{"internalType":"string","name":"responseURI","type":"string"},{"internalType":"bytes32","name":"responseHash","type":"bytes32"},{"internalType":"string","name":"tag","type":"string"}],"name":"validationResponse","outputs":[],"stateMutability":"nonpayable","type":"function"}]');

/***/ }),

/***/ "(rsc)/../../node_modules/@agentic-trust/8004-sdk/dist/adapters/ethers.js":
/*!**************************************************************************!*\
  !*** ../../node_modules/@agentic-trust/8004-sdk/dist/adapters/ethers.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EthersAdapter: () => (/* binding */ EthersAdapter)\n/* harmony export */ });\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ethers */ \"(rsc)/../../node_modules/ethers/lib.esm/contract/contract.js\");\n/**\n * Ethers.js v6 adapter implementation\n */\n\nclass EthersAdapter {\n    provider;\n    signer;\n    constructor(provider, signer) {\n        this.provider = provider;\n        this.signer = signer;\n    }\n    // Public getters to access the private provider and signer\n    getProvider() {\n        return this.provider;\n    }\n    getSigner() {\n        return this.signer;\n    }\n    async call(contractAddress, abi, functionName, args) {\n        const contract = new ethers__WEBPACK_IMPORTED_MODULE_0__.Contract(contractAddress, abi, this.provider);\n        const fn = contract[functionName];\n        if (!fn || typeof fn !== 'function') {\n            throw new Error(`Function ${functionName} not found in contract`);\n        }\n        return await fn(...(args || []));\n    }\n    async send(contractAddress, abi, functionName, args, overrides) {\n        if (!this.signer) {\n            throw new Error('Signer required for write operations');\n        }\n        const contract = new ethers__WEBPACK_IMPORTED_MODULE_0__.Contract(contractAddress, abi, this.signer);\n        const fn = contract[functionName];\n        if (!fn || typeof fn !== 'function') {\n            throw new Error(`Function ${functionName} not found in contract`);\n        }\n        // Build transaction options from overrides\n        const txOptions = {};\n        if (overrides?.value !== undefined) {\n            txOptions.value = overrides.value;\n        }\n        if (overrides?.gas !== undefined) {\n            txOptions.gasLimit = overrides.gas;\n        }\n        if (overrides?.gasPrice !== undefined) {\n            txOptions.gasPrice = overrides.gasPrice;\n        }\n        if (overrides?.maxFeePerGas !== undefined) {\n            txOptions.maxFeePerGas = overrides.maxFeePerGas;\n        }\n        if (overrides?.maxPriorityFeePerGas !== undefined) {\n            txOptions.maxPriorityFeePerGas = overrides.maxPriorityFeePerGas;\n        }\n        if (overrides?.nonce !== undefined) {\n            txOptions.nonce = overrides.nonce;\n        }\n        const tx = await fn(...(args || []), Object.keys(txOptions).length > 0 ? txOptions : undefined);\n        if (!tx || typeof tx.wait !== 'function') {\n            throw new Error('Transaction failed to be created');\n        }\n        const receipt = await tx.wait();\n        // Parse events from the receipt\n        const events = [];\n        if (receipt && receipt.logs) {\n            for (const log of receipt.logs) {\n                try {\n                    const parsed = contract.interface.parseLog({\n                        topics: [...log.topics],\n                        data: log.data,\n                    });\n                    if (parsed) {\n                        events.push({\n                            name: parsed.name,\n                            args: parsed.args,\n                        });\n                    }\n                }\n                catch (error) {\n                    // Skip logs that don't match this contract's ABI\n                    // This is normal for logs from other contracts\n                }\n            }\n        }\n        return {\n            hash: receipt.hash,\n            blockNumber: BigInt(receipt.blockNumber),\n            receipt,\n            events,\n            // Legacy support - also include txHash for backward compatibility\n            txHash: receipt.hash,\n        };\n    }\n    async encodeFunctionData(contractAddress, abi, functionName, args) {\n        const contract = new ethers__WEBPACK_IMPORTED_MODULE_0__.Contract(contractAddress, abi);\n        const iface = contract.interface;\n        // Strip function signature if present\n        const cleanFunctionName = functionName.includes('(')\n            ? functionName.substring(0, functionName.indexOf('('))\n            : functionName;\n        const encoded = iface.encodeFunctionData(cleanFunctionName, args || []);\n        return encoded;\n    }\n    async getAddress() {\n        if (!this.signer) {\n            return null;\n        }\n        return (await this.signer.getAddress());\n    }\n    async getChainId() {\n        const network = await this.provider.getNetwork();\n        return Number(network.chainId);\n    }\n    async signMessage(message) {\n        if (!this.signer) {\n            throw new Error('Signer required for signing');\n        }\n        return (await this.signer.signMessage(message));\n    }\n    async signTypedData(domain, types, value) {\n        if (!this.signer) {\n            throw new Error('Signer required for signing');\n        }\n        // Check if signer supports signTypedData (Wallet does, but not all signers)\n        if ('signTypedData' in this.signer && typeof this.signer.signTypedData === 'function') {\n            return (await this.signer.signTypedData(domain, types, value));\n        }\n        throw new Error('Signer does not support EIP-712 typed data signing');\n    }\n}\n//# sourceMappingURL=ethers.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BhZ2VudGljLXRydXN0LzgwMDQtc2RrL2Rpc3QvYWRhcHRlcnMvZXRoZXJzLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ2tDO0FBQzNCO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw0Q0FBUTtBQUNyQztBQUNBO0FBQ0Esd0NBQXdDLGNBQWM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsNENBQVE7QUFDckM7QUFDQTtBQUNBLHdDQUF3QyxjQUFjO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw0Q0FBUTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL2JhcmIvYWEvQXNzb2NpYXRlZEFjY291bnRzL25vZGVfbW9kdWxlcy9AYWdlbnRpYy10cnVzdC84MDA0LXNkay9kaXN0L2FkYXB0ZXJzL2V0aGVycy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEV0aGVycy5qcyB2NiBhZGFwdGVyIGltcGxlbWVudGF0aW9uXG4gKi9cbmltcG9ydCB7IENvbnRyYWN0IH0gZnJvbSAnZXRoZXJzJztcbmV4cG9ydCBjbGFzcyBFdGhlcnNBZGFwdGVyIHtcbiAgICBwcm92aWRlcjtcbiAgICBzaWduZXI7XG4gICAgY29uc3RydWN0b3IocHJvdmlkZXIsIHNpZ25lcikge1xuICAgICAgICB0aGlzLnByb3ZpZGVyID0gcHJvdmlkZXI7XG4gICAgICAgIHRoaXMuc2lnbmVyID0gc2lnbmVyO1xuICAgIH1cbiAgICAvLyBQdWJsaWMgZ2V0dGVycyB0byBhY2Nlc3MgdGhlIHByaXZhdGUgcHJvdmlkZXIgYW5kIHNpZ25lclxuICAgIGdldFByb3ZpZGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcm92aWRlcjtcbiAgICB9XG4gICAgZ2V0U2lnbmVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaWduZXI7XG4gICAgfVxuICAgIGFzeW5jIGNhbGwoY29udHJhY3RBZGRyZXNzLCBhYmksIGZ1bmN0aW9uTmFtZSwgYXJncykge1xuICAgICAgICBjb25zdCBjb250cmFjdCA9IG5ldyBDb250cmFjdChjb250cmFjdEFkZHJlc3MsIGFiaSwgdGhpcy5wcm92aWRlcik7XG4gICAgICAgIGNvbnN0IGZuID0gY29udHJhY3RbZnVuY3Rpb25OYW1lXTtcbiAgICAgICAgaWYgKCFmbiB8fCB0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRnVuY3Rpb24gJHtmdW5jdGlvbk5hbWV9IG5vdCBmb3VuZCBpbiBjb250cmFjdGApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhd2FpdCBmbiguLi4oYXJncyB8fCBbXSkpO1xuICAgIH1cbiAgICBhc3luYyBzZW5kKGNvbnRyYWN0QWRkcmVzcywgYWJpLCBmdW5jdGlvbk5hbWUsIGFyZ3MsIG92ZXJyaWRlcykge1xuICAgICAgICBpZiAoIXRoaXMuc2lnbmVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NpZ25lciByZXF1aXJlZCBmb3Igd3JpdGUgb3BlcmF0aW9ucycpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbnRyYWN0ID0gbmV3IENvbnRyYWN0KGNvbnRyYWN0QWRkcmVzcywgYWJpLCB0aGlzLnNpZ25lcik7XG4gICAgICAgIGNvbnN0IGZuID0gY29udHJhY3RbZnVuY3Rpb25OYW1lXTtcbiAgICAgICAgaWYgKCFmbiB8fCB0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRnVuY3Rpb24gJHtmdW5jdGlvbk5hbWV9IG5vdCBmb3VuZCBpbiBjb250cmFjdGApO1xuICAgICAgICB9XG4gICAgICAgIC8vIEJ1aWxkIHRyYW5zYWN0aW9uIG9wdGlvbnMgZnJvbSBvdmVycmlkZXNcbiAgICAgICAgY29uc3QgdHhPcHRpb25zID0ge307XG4gICAgICAgIGlmIChvdmVycmlkZXM/LnZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHR4T3B0aW9ucy52YWx1ZSA9IG92ZXJyaWRlcy52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3ZlcnJpZGVzPy5nYXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdHhPcHRpb25zLmdhc0xpbWl0ID0gb3ZlcnJpZGVzLmdhcztcbiAgICAgICAgfVxuICAgICAgICBpZiAob3ZlcnJpZGVzPy5nYXNQcmljZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0eE9wdGlvbnMuZ2FzUHJpY2UgPSBvdmVycmlkZXMuZ2FzUHJpY2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG92ZXJyaWRlcz8ubWF4RmVlUGVyR2FzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHR4T3B0aW9ucy5tYXhGZWVQZXJHYXMgPSBvdmVycmlkZXMubWF4RmVlUGVyR2FzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvdmVycmlkZXM/Lm1heFByaW9yaXR5RmVlUGVyR2FzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHR4T3B0aW9ucy5tYXhQcmlvcml0eUZlZVBlckdhcyA9IG92ZXJyaWRlcy5tYXhQcmlvcml0eUZlZVBlckdhcztcbiAgICAgICAgfVxuICAgICAgICBpZiAob3ZlcnJpZGVzPy5ub25jZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0eE9wdGlvbnMubm9uY2UgPSBvdmVycmlkZXMubm9uY2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdHggPSBhd2FpdCBmbiguLi4oYXJncyB8fCBbXSksIE9iamVjdC5rZXlzKHR4T3B0aW9ucykubGVuZ3RoID4gMCA/IHR4T3B0aW9ucyA6IHVuZGVmaW5lZCk7XG4gICAgICAgIGlmICghdHggfHwgdHlwZW9mIHR4LndhaXQgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVHJhbnNhY3Rpb24gZmFpbGVkIHRvIGJlIGNyZWF0ZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZWNlaXB0ID0gYXdhaXQgdHgud2FpdCgpO1xuICAgICAgICAvLyBQYXJzZSBldmVudHMgZnJvbSB0aGUgcmVjZWlwdFxuICAgICAgICBjb25zdCBldmVudHMgPSBbXTtcbiAgICAgICAgaWYgKHJlY2VpcHQgJiYgcmVjZWlwdC5sb2dzKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGxvZyBvZiByZWNlaXB0LmxvZ3MpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWQgPSBjb250cmFjdC5pbnRlcmZhY2UucGFyc2VMb2coe1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9waWNzOiBbLi4ubG9nLnRvcGljc10sXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBsb2cuZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJzZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50cy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBwYXJzZWQubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzOiBwYXJzZWQuYXJncyxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAvLyBTa2lwIGxvZ3MgdGhhdCBkb24ndCBtYXRjaCB0aGlzIGNvbnRyYWN0J3MgQUJJXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgbm9ybWFsIGZvciBsb2dzIGZyb20gb3RoZXIgY29udHJhY3RzXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBoYXNoOiByZWNlaXB0Lmhhc2gsXG4gICAgICAgICAgICBibG9ja051bWJlcjogQmlnSW50KHJlY2VpcHQuYmxvY2tOdW1iZXIpLFxuICAgICAgICAgICAgcmVjZWlwdCxcbiAgICAgICAgICAgIGV2ZW50cyxcbiAgICAgICAgICAgIC8vIExlZ2FjeSBzdXBwb3J0IC0gYWxzbyBpbmNsdWRlIHR4SGFzaCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eVxuICAgICAgICAgICAgdHhIYXNoOiByZWNlaXB0Lmhhc2gsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGFzeW5jIGVuY29kZUZ1bmN0aW9uRGF0YShjb250cmFjdEFkZHJlc3MsIGFiaSwgZnVuY3Rpb25OYW1lLCBhcmdzKSB7XG4gICAgICAgIGNvbnN0IGNvbnRyYWN0ID0gbmV3IENvbnRyYWN0KGNvbnRyYWN0QWRkcmVzcywgYWJpKTtcbiAgICAgICAgY29uc3QgaWZhY2UgPSBjb250cmFjdC5pbnRlcmZhY2U7XG4gICAgICAgIC8vIFN0cmlwIGZ1bmN0aW9uIHNpZ25hdHVyZSBpZiBwcmVzZW50XG4gICAgICAgIGNvbnN0IGNsZWFuRnVuY3Rpb25OYW1lID0gZnVuY3Rpb25OYW1lLmluY2x1ZGVzKCcoJylcbiAgICAgICAgICAgID8gZnVuY3Rpb25OYW1lLnN1YnN0cmluZygwLCBmdW5jdGlvbk5hbWUuaW5kZXhPZignKCcpKVxuICAgICAgICAgICAgOiBmdW5jdGlvbk5hbWU7XG4gICAgICAgIGNvbnN0IGVuY29kZWQgPSBpZmFjZS5lbmNvZGVGdW5jdGlvbkRhdGEoY2xlYW5GdW5jdGlvbk5hbWUsIGFyZ3MgfHwgW10pO1xuICAgICAgICByZXR1cm4gZW5jb2RlZDtcbiAgICB9XG4gICAgYXN5bmMgZ2V0QWRkcmVzcygpIHtcbiAgICAgICAgaWYgKCF0aGlzLnNpZ25lcikge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChhd2FpdCB0aGlzLnNpZ25lci5nZXRBZGRyZXNzKCkpO1xuICAgIH1cbiAgICBhc3luYyBnZXRDaGFpbklkKCkge1xuICAgICAgICBjb25zdCBuZXR3b3JrID0gYXdhaXQgdGhpcy5wcm92aWRlci5nZXROZXR3b3JrKCk7XG4gICAgICAgIHJldHVybiBOdW1iZXIobmV0d29yay5jaGFpbklkKTtcbiAgICB9XG4gICAgYXN5bmMgc2lnbk1lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICBpZiAoIXRoaXMuc2lnbmVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NpZ25lciByZXF1aXJlZCBmb3Igc2lnbmluZycpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoYXdhaXQgdGhpcy5zaWduZXIuc2lnbk1lc3NhZ2UobWVzc2FnZSkpO1xuICAgIH1cbiAgICBhc3luYyBzaWduVHlwZWREYXRhKGRvbWFpbiwgdHlwZXMsIHZhbHVlKSB7XG4gICAgICAgIGlmICghdGhpcy5zaWduZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU2lnbmVyIHJlcXVpcmVkIGZvciBzaWduaW5nJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2hlY2sgaWYgc2lnbmVyIHN1cHBvcnRzIHNpZ25UeXBlZERhdGEgKFdhbGxldCBkb2VzLCBidXQgbm90IGFsbCBzaWduZXJzKVxuICAgICAgICBpZiAoJ3NpZ25UeXBlZERhdGEnIGluIHRoaXMuc2lnbmVyICYmIHR5cGVvZiB0aGlzLnNpZ25lci5zaWduVHlwZWREYXRhID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gKGF3YWl0IHRoaXMuc2lnbmVyLnNpZ25UeXBlZERhdGEoZG9tYWluLCB0eXBlcywgdmFsdWUpKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NpZ25lciBkb2VzIG5vdCBzdXBwb3J0IEVJUC03MTIgdHlwZWQgZGF0YSBzaWduaW5nJyk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXRoZXJzLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@agentic-trust/8004-sdk/dist/adapters/ethers.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@agentic-trust/8004-sdk/dist/adapters/types.js":
/*!*************************************************************************!*\
  !*** ../../node_modules/@agentic-trust/8004-sdk/dist/adapters/types.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/**\n * Adapter interface for blockchain interactions\n * Allows SDK to work with any blockchain library (ethers, viem, etc.)\n */\n\n//# sourceMappingURL=types.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BhZ2VudGljLXRydXN0LzgwMDQtc2RrL2Rpc3QvYWRhcHRlcnMvdHlwZXMuanMiLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ1U7QUFDViIsInNvdXJjZXMiOlsiL2hvbWUvYmFyYi9hYS9Bc3NvY2lhdGVkQWNjb3VudHMvbm9kZV9tb2R1bGVzL0BhZ2VudGljLXRydXN0LzgwMDQtc2RrL2Rpc3QvYWRhcHRlcnMvdHlwZXMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBBZGFwdGVyIGludGVyZmFjZSBmb3IgYmxvY2tjaGFpbiBpbnRlcmFjdGlvbnNcbiAqIEFsbG93cyBTREsgdG8gd29yayB3aXRoIGFueSBibG9ja2NoYWluIGxpYnJhcnkgKGV0aGVycywgdmllbSwgZXRjLilcbiAqL1xuZXhwb3J0IHt9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHlwZXMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@agentic-trust/8004-sdk/dist/adapters/types.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@agentic-trust/8004-sdk/dist/adapters/viem.js":
/*!************************************************************************!*\
  !*** ../../node_modules/@agentic-trust/8004-sdk/dist/adapters/viem.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ViemAdapter: () => (/* binding */ ViemAdapter)\n/* harmony export */ });\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! viem */ \"(rsc)/../../node_modules/viem/_esm/utils/address/getAddress.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! viem */ \"(rsc)/../../node_modules/viem/_esm/utils/abi/decodeEventLog.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! viem */ \"(rsc)/../../node_modules/viem/_esm/utils/abi/encodeFunctionData.js\");\n/**\n * Viem adapter implementation\n * Viem is a modern TypeScript-first Ethereum library\n */\n\nclass ViemAdapter {\n    publicClient;\n    walletClient;\n    account;\n    constructor(publicClientOrOptions, walletClient, account) {\n        // Support both constructor patterns\n        if (publicClientOrOptions && typeof publicClientOrOptions === 'object' && 'publicClient' in publicClientOrOptions) {\n            // Options pattern\n            this.publicClient = publicClientOrOptions.publicClient;\n            this.walletClient = publicClientOrOptions.walletClient ?? null;\n            // Extract account from walletClient if available\n            if (this.walletClient && 'account' in this.walletClient && this.walletClient.account) {\n                this.account = this.walletClient.account;\n            }\n        }\n        else {\n            // Legacy pattern\n            this.publicClient = publicClientOrOptions;\n            this.walletClient = walletClient ?? null;\n            this.account = account;\n        }\n    }\n    async call(contractAddress, abi, functionName, args) {\n        // Strip function signature if present (ethers format compatibility)\n        // Viem auto-matches based on args, ethers uses \"functionName(types)\"\n        const cleanFunctionName = functionName.includes('(')\n            ? functionName.substring(0, functionName.indexOf('('))\n            : functionName;\n        // ABI is already in proper JSON format, use directly\n        const result = await this.publicClient.readContract({\n            address: contractAddress,\n            abi: abi,\n            functionName: cleanFunctionName,\n            args: args,\n        });\n        return result;\n    }\n    async send(contractAddress, abi, functionName, args, overrides) {\n        if (!this.walletClient) {\n            throw new Error('Wallet client required for write operations. Provide walletClient (not private key) when creating the adapter.');\n        }\n        // Use override account if provided, otherwise use configured account\n        // walletClient can provide account from wallet provider (MetaMask, Web3Auth, etc.)\n        // No private key needed - walletClient handles signing via wallet provider\n        const account = overrides?.account\n            ? (await (0,viem__WEBPACK_IMPORTED_MODULE_0__.getAddress)(overrides.account))\n            : (this.account\n                ? (typeof this.account === 'string' ? await (0,viem__WEBPACK_IMPORTED_MODULE_0__.getAddress)(this.account) : this.account)\n                : (this.walletClient && 'account' in this.walletClient && this.walletClient.account\n                    ? (typeof this.walletClient.account === 'string'\n                        ? await (0,viem__WEBPACK_IMPORTED_MODULE_0__.getAddress)(this.walletClient.account)\n                        : this.walletClient.account)\n                    : null));\n        if (!account) {\n            throw new Error('Account required for write operations. Provide account in walletClient (e.g., from MetaMask/Web3Auth wallet provider), constructor, or overrides.');\n        }\n        // Strip function signature if present (ethers format compatibility)\n        const cleanFunctionName = functionName.includes('(')\n            ? functionName.substring(0, functionName.indexOf('('))\n            : functionName;\n        // Build request options\n        const requestOptions = {\n            address: contractAddress,\n            abi: abi,\n            functionName: cleanFunctionName,\n            args: args,\n            account,\n        };\n        // Add override values\n        if (overrides?.value !== undefined) {\n            requestOptions.value = overrides.value;\n        }\n        if (overrides?.gas !== undefined) {\n            requestOptions.gas = overrides.gas;\n        }\n        if (overrides?.maxFeePerGas !== undefined) {\n            requestOptions.maxFeePerGas = overrides.maxFeePerGas;\n        }\n        if (overrides?.maxPriorityFeePerGas !== undefined) {\n            requestOptions.maxPriorityFeePerGas = overrides.maxPriorityFeePerGas;\n        }\n        if (overrides?.nonce !== undefined) {\n            requestOptions.nonce = overrides.nonce;\n        }\n        // Simulate the transaction first\n        console.info('Simulating transaction...');\n        const { request } = await this.publicClient.simulateContract(requestOptions);\n        // Write the transaction\n        // walletClient.writeContract should sign locally when account is set on walletClient\n        console.info('Writing transaction...');\n        // Use override chain if provided, otherwise use walletClient's chain\n        const chain = overrides?.chain || this.walletClient.chain;\n        // Remove account from request if walletClient already has account configured\n        // This ensures Viem signs locally using walletClient's account\n        const { account: _, ...requestWithoutAccount } = request;\n        const hash = await this.walletClient.writeContract({\n            ...requestWithoutAccount,\n            chain,\n            // Don't pass account here - let walletClient use its configured account or the one we determined\n        });\n        // Wait for transaction receipt\n        console.info('Waiting for transaction receipt...');\n        const receipt = await this.publicClient.waitForTransactionReceipt({\n            hash,\n        });\n        // Parse events from the receipt\n        console.info('Parsing events from receipt...');\n        const events = [];\n        for (const log of receipt.logs) {\n            try {\n                const decoded = (0,viem__WEBPACK_IMPORTED_MODULE_1__.decodeEventLog)({\n                    abi: abi,\n                    data: log.data,\n                    topics: log.topics,\n                });\n                events.push({\n                    name: decoded.eventName,\n                    args: decoded.args,\n                });\n            }\n            catch {\n                // Skip logs that can't be decoded with this ABI\n            }\n        }\n        return {\n            hash: receipt.transactionHash,\n            blockNumber: receipt.blockNumber,\n            receipt,\n            events,\n        };\n    }\n    async encodeFunctionData(contractAddress, abi, functionName, args) {\n        // Strip function signature if present (ethers format compatibility)\n        const cleanFunctionName = functionName.includes('(')\n            ? functionName.substring(0, functionName.indexOf('('))\n            : functionName;\n        // Encode the function call data\n        const encoded = (0,viem__WEBPACK_IMPORTED_MODULE_2__.encodeFunctionData)({\n            abi: abi,\n            functionName: cleanFunctionName,\n            args: args,\n        });\n        return encoded;\n    }\n    async getAddress() {\n        if (!this.account) {\n            // Try to get from walletClient if available\n            if (this.walletClient && 'account' in this.walletClient && this.walletClient.account) {\n                const account = this.walletClient.account;\n                return typeof account === 'string' ? await (0,viem__WEBPACK_IMPORTED_MODULE_0__.getAddress)(account) : account.address;\n            }\n            return null;\n        }\n        // Handle both Account objects and raw addresses\n        if (typeof this.account === 'string') {\n            return await (0,viem__WEBPACK_IMPORTED_MODULE_0__.getAddress)(this.account);\n        }\n        return this.account.address;\n    }\n    async getChainId() {\n        const chainId = await this.publicClient.getChainId();\n        return chainId;\n    }\n    async signMessage(message) {\n        if (!this.walletClient) {\n            throw new Error('Wallet client required for signing. Provide walletClient (not private key) when creating the adapter.');\n        }\n        // Determine account to use - walletClient can provide account from wallet provider (MetaMask, etc.)\n        const account = this.account\n            ? (typeof this.account === 'string' ? await (0,viem__WEBPACK_IMPORTED_MODULE_0__.getAddress)(this.account) : this.account)\n            : (this.walletClient.account || null);\n        if (!account) {\n            throw new Error('Account required for signing. Provide account in walletClient (e.g., from MetaMask/Web3Auth wallet provider) or constructor.');\n        }\n        // walletClient.signMessage works with wallet providers (MetaMask, Web3Auth, etc.)\n        // No private key needed - the wallet provider handles signing\n        const signature = await this.walletClient.signMessage({\n            account,\n            message: typeof message === 'string' ? message : { raw: message },\n        });\n        return signature;\n    }\n    async signTypedData(domain, types, value) {\n        if (!this.walletClient) {\n            throw new Error('Wallet client required for signing. Provide walletClient (not private key) when creating the adapter.');\n        }\n        // Determine account to use - walletClient can provide account from wallet provider (MetaMask, etc.)\n        const account = this.account\n            ? (typeof this.account === 'string' ? await (0,viem__WEBPACK_IMPORTED_MODULE_0__.getAddress)(this.account) : this.account)\n            : (this.walletClient.account || null);\n        if (!account) {\n            throw new Error('Account required for signing. Provide account in walletClient (e.g., from MetaMask/Web3Auth wallet provider) or constructor.');\n        }\n        const primaryType = Object.keys(types)[0];\n        if (!primaryType) {\n            throw new Error('Types object must have at least one key for primaryType');\n        }\n        const signature = await this.walletClient.signTypedData({\n            account,\n            domain,\n            types,\n            primaryType, // Viem requires primaryType\n            message: value,\n        });\n        return signature;\n    }\n}\n//# sourceMappingURL=viem.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BhZ2VudGljLXRydXN0LzgwMDQtc2RrL2Rpc3QvYWRhcHRlcnMvdmllbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDaUc7QUFDMUY7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsZ0RBQVU7QUFDL0I7QUFDQSw0REFBNEQsZ0RBQVU7QUFDdEU7QUFDQTtBQUNBLGdDQUFnQyxnREFBVTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFVBQVU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsdUNBQXVDO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0Msb0RBQWM7QUFDOUM7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isd0RBQXNCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxnREFBVTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGdEQUFVO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELGdEQUFVO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0QsY0FBYztBQUM3RSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxnREFBVTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9iYXJiL2FhL0Fzc29jaWF0ZWRBY2NvdW50cy9ub2RlX21vZHVsZXMvQGFnZW50aWMtdHJ1c3QvODAwNC1zZGsvZGlzdC9hZGFwdGVycy92aWVtLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogVmllbSBhZGFwdGVyIGltcGxlbWVudGF0aW9uXG4gKiBWaWVtIGlzIGEgbW9kZXJuIFR5cGVTY3JpcHQtZmlyc3QgRXRoZXJldW0gbGlicmFyeVxuICovXG5pbXBvcnQgeyBkZWNvZGVFdmVudExvZywgZW5jb2RlRnVuY3Rpb25EYXRhIGFzIHZpZW1FbmNvZGVGdW5jdGlvbkRhdGEsIGdldEFkZHJlc3MsIH0gZnJvbSAndmllbSc7XG5leHBvcnQgY2xhc3MgVmllbUFkYXB0ZXIge1xuICAgIHB1YmxpY0NsaWVudDtcbiAgICB3YWxsZXRDbGllbnQ7XG4gICAgYWNjb3VudDtcbiAgICBjb25zdHJ1Y3RvcihwdWJsaWNDbGllbnRPck9wdGlvbnMsIHdhbGxldENsaWVudCwgYWNjb3VudCkge1xuICAgICAgICAvLyBTdXBwb3J0IGJvdGggY29uc3RydWN0b3IgcGF0dGVybnNcbiAgICAgICAgaWYgKHB1YmxpY0NsaWVudE9yT3B0aW9ucyAmJiB0eXBlb2YgcHVibGljQ2xpZW50T3JPcHRpb25zID09PSAnb2JqZWN0JyAmJiAncHVibGljQ2xpZW50JyBpbiBwdWJsaWNDbGllbnRPck9wdGlvbnMpIHtcbiAgICAgICAgICAgIC8vIE9wdGlvbnMgcGF0dGVyblxuICAgICAgICAgICAgdGhpcy5wdWJsaWNDbGllbnQgPSBwdWJsaWNDbGllbnRPck9wdGlvbnMucHVibGljQ2xpZW50O1xuICAgICAgICAgICAgdGhpcy53YWxsZXRDbGllbnQgPSBwdWJsaWNDbGllbnRPck9wdGlvbnMud2FsbGV0Q2xpZW50ID8/IG51bGw7XG4gICAgICAgICAgICAvLyBFeHRyYWN0IGFjY291bnQgZnJvbSB3YWxsZXRDbGllbnQgaWYgYXZhaWxhYmxlXG4gICAgICAgICAgICBpZiAodGhpcy53YWxsZXRDbGllbnQgJiYgJ2FjY291bnQnIGluIHRoaXMud2FsbGV0Q2xpZW50ICYmIHRoaXMud2FsbGV0Q2xpZW50LmFjY291bnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFjY291bnQgPSB0aGlzLndhbGxldENsaWVudC5hY2NvdW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gTGVnYWN5IHBhdHRlcm5cbiAgICAgICAgICAgIHRoaXMucHVibGljQ2xpZW50ID0gcHVibGljQ2xpZW50T3JPcHRpb25zO1xuICAgICAgICAgICAgdGhpcy53YWxsZXRDbGllbnQgPSB3YWxsZXRDbGllbnQgPz8gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuYWNjb3VudCA9IGFjY291bnQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgY2FsbChjb250cmFjdEFkZHJlc3MsIGFiaSwgZnVuY3Rpb25OYW1lLCBhcmdzKSB7XG4gICAgICAgIC8vIFN0cmlwIGZ1bmN0aW9uIHNpZ25hdHVyZSBpZiBwcmVzZW50IChldGhlcnMgZm9ybWF0IGNvbXBhdGliaWxpdHkpXG4gICAgICAgIC8vIFZpZW0gYXV0by1tYXRjaGVzIGJhc2VkIG9uIGFyZ3MsIGV0aGVycyB1c2VzIFwiZnVuY3Rpb25OYW1lKHR5cGVzKVwiXG4gICAgICAgIGNvbnN0IGNsZWFuRnVuY3Rpb25OYW1lID0gZnVuY3Rpb25OYW1lLmluY2x1ZGVzKCcoJylcbiAgICAgICAgICAgID8gZnVuY3Rpb25OYW1lLnN1YnN0cmluZygwLCBmdW5jdGlvbk5hbWUuaW5kZXhPZignKCcpKVxuICAgICAgICAgICAgOiBmdW5jdGlvbk5hbWU7XG4gICAgICAgIC8vIEFCSSBpcyBhbHJlYWR5IGluIHByb3BlciBKU09OIGZvcm1hdCwgdXNlIGRpcmVjdGx5XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMucHVibGljQ2xpZW50LnJlYWRDb250cmFjdCh7XG4gICAgICAgICAgICBhZGRyZXNzOiBjb250cmFjdEFkZHJlc3MsXG4gICAgICAgICAgICBhYmk6IGFiaSxcbiAgICAgICAgICAgIGZ1bmN0aW9uTmFtZTogY2xlYW5GdW5jdGlvbk5hbWUsXG4gICAgICAgICAgICBhcmdzOiBhcmdzLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgYXN5bmMgc2VuZChjb250cmFjdEFkZHJlc3MsIGFiaSwgZnVuY3Rpb25OYW1lLCBhcmdzLCBvdmVycmlkZXMpIHtcbiAgICAgICAgaWYgKCF0aGlzLndhbGxldENsaWVudCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXYWxsZXQgY2xpZW50IHJlcXVpcmVkIGZvciB3cml0ZSBvcGVyYXRpb25zLiBQcm92aWRlIHdhbGxldENsaWVudCAobm90IHByaXZhdGUga2V5KSB3aGVuIGNyZWF0aW5nIHRoZSBhZGFwdGVyLicpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFVzZSBvdmVycmlkZSBhY2NvdW50IGlmIHByb3ZpZGVkLCBvdGhlcndpc2UgdXNlIGNvbmZpZ3VyZWQgYWNjb3VudFxuICAgICAgICAvLyB3YWxsZXRDbGllbnQgY2FuIHByb3ZpZGUgYWNjb3VudCBmcm9tIHdhbGxldCBwcm92aWRlciAoTWV0YU1hc2ssIFdlYjNBdXRoLCBldGMuKVxuICAgICAgICAvLyBObyBwcml2YXRlIGtleSBuZWVkZWQgLSB3YWxsZXRDbGllbnQgaGFuZGxlcyBzaWduaW5nIHZpYSB3YWxsZXQgcHJvdmlkZXJcbiAgICAgICAgY29uc3QgYWNjb3VudCA9IG92ZXJyaWRlcz8uYWNjb3VudFxuICAgICAgICAgICAgPyAoYXdhaXQgZ2V0QWRkcmVzcyhvdmVycmlkZXMuYWNjb3VudCkpXG4gICAgICAgICAgICA6ICh0aGlzLmFjY291bnRcbiAgICAgICAgICAgICAgICA/ICh0eXBlb2YgdGhpcy5hY2NvdW50ID09PSAnc3RyaW5nJyA/IGF3YWl0IGdldEFkZHJlc3ModGhpcy5hY2NvdW50KSA6IHRoaXMuYWNjb3VudClcbiAgICAgICAgICAgICAgICA6ICh0aGlzLndhbGxldENsaWVudCAmJiAnYWNjb3VudCcgaW4gdGhpcy53YWxsZXRDbGllbnQgJiYgdGhpcy53YWxsZXRDbGllbnQuYWNjb3VudFxuICAgICAgICAgICAgICAgICAgICA/ICh0eXBlb2YgdGhpcy53YWxsZXRDbGllbnQuYWNjb3VudCA9PT0gJ3N0cmluZydcbiAgICAgICAgICAgICAgICAgICAgICAgID8gYXdhaXQgZ2V0QWRkcmVzcyh0aGlzLndhbGxldENsaWVudC5hY2NvdW50KVxuICAgICAgICAgICAgICAgICAgICAgICAgOiB0aGlzLndhbGxldENsaWVudC5hY2NvdW50KVxuICAgICAgICAgICAgICAgICAgICA6IG51bGwpKTtcbiAgICAgICAgaWYgKCFhY2NvdW50KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FjY291bnQgcmVxdWlyZWQgZm9yIHdyaXRlIG9wZXJhdGlvbnMuIFByb3ZpZGUgYWNjb3VudCBpbiB3YWxsZXRDbGllbnQgKGUuZy4sIGZyb20gTWV0YU1hc2svV2ViM0F1dGggd2FsbGV0IHByb3ZpZGVyKSwgY29uc3RydWN0b3IsIG9yIG92ZXJyaWRlcy4nKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTdHJpcCBmdW5jdGlvbiBzaWduYXR1cmUgaWYgcHJlc2VudCAoZXRoZXJzIGZvcm1hdCBjb21wYXRpYmlsaXR5KVxuICAgICAgICBjb25zdCBjbGVhbkZ1bmN0aW9uTmFtZSA9IGZ1bmN0aW9uTmFtZS5pbmNsdWRlcygnKCcpXG4gICAgICAgICAgICA/IGZ1bmN0aW9uTmFtZS5zdWJzdHJpbmcoMCwgZnVuY3Rpb25OYW1lLmluZGV4T2YoJygnKSlcbiAgICAgICAgICAgIDogZnVuY3Rpb25OYW1lO1xuICAgICAgICAvLyBCdWlsZCByZXF1ZXN0IG9wdGlvbnNcbiAgICAgICAgY29uc3QgcmVxdWVzdE9wdGlvbnMgPSB7XG4gICAgICAgICAgICBhZGRyZXNzOiBjb250cmFjdEFkZHJlc3MsXG4gICAgICAgICAgICBhYmk6IGFiaSxcbiAgICAgICAgICAgIGZ1bmN0aW9uTmFtZTogY2xlYW5GdW5jdGlvbk5hbWUsXG4gICAgICAgICAgICBhcmdzOiBhcmdzLFxuICAgICAgICAgICAgYWNjb3VudCxcbiAgICAgICAgfTtcbiAgICAgICAgLy8gQWRkIG92ZXJyaWRlIHZhbHVlc1xuICAgICAgICBpZiAob3ZlcnJpZGVzPy52YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXF1ZXN0T3B0aW9ucy52YWx1ZSA9IG92ZXJyaWRlcy52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3ZlcnJpZGVzPy5nYXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVxdWVzdE9wdGlvbnMuZ2FzID0gb3ZlcnJpZGVzLmdhcztcbiAgICAgICAgfVxuICAgICAgICBpZiAob3ZlcnJpZGVzPy5tYXhGZWVQZXJHYXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVxdWVzdE9wdGlvbnMubWF4RmVlUGVyR2FzID0gb3ZlcnJpZGVzLm1heEZlZVBlckdhcztcbiAgICAgICAgfVxuICAgICAgICBpZiAob3ZlcnJpZGVzPy5tYXhQcmlvcml0eUZlZVBlckdhcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXF1ZXN0T3B0aW9ucy5tYXhQcmlvcml0eUZlZVBlckdhcyA9IG92ZXJyaWRlcy5tYXhQcmlvcml0eUZlZVBlckdhcztcbiAgICAgICAgfVxuICAgICAgICBpZiAob3ZlcnJpZGVzPy5ub25jZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXF1ZXN0T3B0aW9ucy5ub25jZSA9IG92ZXJyaWRlcy5ub25jZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTaW11bGF0ZSB0aGUgdHJhbnNhY3Rpb24gZmlyc3RcbiAgICAgICAgY29uc29sZS5pbmZvKCdTaW11bGF0aW5nIHRyYW5zYWN0aW9uLi4uJyk7XG4gICAgICAgIGNvbnN0IHsgcmVxdWVzdCB9ID0gYXdhaXQgdGhpcy5wdWJsaWNDbGllbnQuc2ltdWxhdGVDb250cmFjdChyZXF1ZXN0T3B0aW9ucyk7XG4gICAgICAgIC8vIFdyaXRlIHRoZSB0cmFuc2FjdGlvblxuICAgICAgICAvLyB3YWxsZXRDbGllbnQud3JpdGVDb250cmFjdCBzaG91bGQgc2lnbiBsb2NhbGx5IHdoZW4gYWNjb3VudCBpcyBzZXQgb24gd2FsbGV0Q2xpZW50XG4gICAgICAgIGNvbnNvbGUuaW5mbygnV3JpdGluZyB0cmFuc2FjdGlvbi4uLicpO1xuICAgICAgICAvLyBVc2Ugb3ZlcnJpZGUgY2hhaW4gaWYgcHJvdmlkZWQsIG90aGVyd2lzZSB1c2Ugd2FsbGV0Q2xpZW50J3MgY2hhaW5cbiAgICAgICAgY29uc3QgY2hhaW4gPSBvdmVycmlkZXM/LmNoYWluIHx8IHRoaXMud2FsbGV0Q2xpZW50LmNoYWluO1xuICAgICAgICAvLyBSZW1vdmUgYWNjb3VudCBmcm9tIHJlcXVlc3QgaWYgd2FsbGV0Q2xpZW50IGFscmVhZHkgaGFzIGFjY291bnQgY29uZmlndXJlZFxuICAgICAgICAvLyBUaGlzIGVuc3VyZXMgVmllbSBzaWducyBsb2NhbGx5IHVzaW5nIHdhbGxldENsaWVudCdzIGFjY291bnRcbiAgICAgICAgY29uc3QgeyBhY2NvdW50OiBfLCAuLi5yZXF1ZXN0V2l0aG91dEFjY291bnQgfSA9IHJlcXVlc3Q7XG4gICAgICAgIGNvbnN0IGhhc2ggPSBhd2FpdCB0aGlzLndhbGxldENsaWVudC53cml0ZUNvbnRyYWN0KHtcbiAgICAgICAgICAgIC4uLnJlcXVlc3RXaXRob3V0QWNjb3VudCxcbiAgICAgICAgICAgIGNoYWluLFxuICAgICAgICAgICAgLy8gRG9uJ3QgcGFzcyBhY2NvdW50IGhlcmUgLSBsZXQgd2FsbGV0Q2xpZW50IHVzZSBpdHMgY29uZmlndXJlZCBhY2NvdW50IG9yIHRoZSBvbmUgd2UgZGV0ZXJtaW5lZFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gV2FpdCBmb3IgdHJhbnNhY3Rpb24gcmVjZWlwdFxuICAgICAgICBjb25zb2xlLmluZm8oJ1dhaXRpbmcgZm9yIHRyYW5zYWN0aW9uIHJlY2VpcHQuLi4nKTtcbiAgICAgICAgY29uc3QgcmVjZWlwdCA9IGF3YWl0IHRoaXMucHVibGljQ2xpZW50LndhaXRGb3JUcmFuc2FjdGlvblJlY2VpcHQoe1xuICAgICAgICAgICAgaGFzaCxcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFBhcnNlIGV2ZW50cyBmcm9tIHRoZSByZWNlaXB0XG4gICAgICAgIGNvbnNvbGUuaW5mbygnUGFyc2luZyBldmVudHMgZnJvbSByZWNlaXB0Li4uJyk7XG4gICAgICAgIGNvbnN0IGV2ZW50cyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGxvZyBvZiByZWNlaXB0LmxvZ3MpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGVjb2RlZCA9IGRlY29kZUV2ZW50TG9nKHtcbiAgICAgICAgICAgICAgICAgICAgYWJpOiBhYmksXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGxvZy5kYXRhLFxuICAgICAgICAgICAgICAgICAgICB0b3BpY3M6IGxvZy50b3BpY3MsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgZXZlbnRzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBkZWNvZGVkLmV2ZW50TmFtZSxcbiAgICAgICAgICAgICAgICAgICAgYXJnczogZGVjb2RlZC5hcmdzLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2gge1xuICAgICAgICAgICAgICAgIC8vIFNraXAgbG9ncyB0aGF0IGNhbid0IGJlIGRlY29kZWQgd2l0aCB0aGlzIEFCSVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBoYXNoOiByZWNlaXB0LnRyYW5zYWN0aW9uSGFzaCxcbiAgICAgICAgICAgIGJsb2NrTnVtYmVyOiByZWNlaXB0LmJsb2NrTnVtYmVyLFxuICAgICAgICAgICAgcmVjZWlwdCxcbiAgICAgICAgICAgIGV2ZW50cyxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYXN5bmMgZW5jb2RlRnVuY3Rpb25EYXRhKGNvbnRyYWN0QWRkcmVzcywgYWJpLCBmdW5jdGlvbk5hbWUsIGFyZ3MpIHtcbiAgICAgICAgLy8gU3RyaXAgZnVuY3Rpb24gc2lnbmF0dXJlIGlmIHByZXNlbnQgKGV0aGVycyBmb3JtYXQgY29tcGF0aWJpbGl0eSlcbiAgICAgICAgY29uc3QgY2xlYW5GdW5jdGlvbk5hbWUgPSBmdW5jdGlvbk5hbWUuaW5jbHVkZXMoJygnKVxuICAgICAgICAgICAgPyBmdW5jdGlvbk5hbWUuc3Vic3RyaW5nKDAsIGZ1bmN0aW9uTmFtZS5pbmRleE9mKCcoJykpXG4gICAgICAgICAgICA6IGZ1bmN0aW9uTmFtZTtcbiAgICAgICAgLy8gRW5jb2RlIHRoZSBmdW5jdGlvbiBjYWxsIGRhdGFcbiAgICAgICAgY29uc3QgZW5jb2RlZCA9IHZpZW1FbmNvZGVGdW5jdGlvbkRhdGEoe1xuICAgICAgICAgICAgYWJpOiBhYmksXG4gICAgICAgICAgICBmdW5jdGlvbk5hbWU6IGNsZWFuRnVuY3Rpb25OYW1lLFxuICAgICAgICAgICAgYXJnczogYXJncyxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBlbmNvZGVkO1xuICAgIH1cbiAgICBhc3luYyBnZXRBZGRyZXNzKCkge1xuICAgICAgICBpZiAoIXRoaXMuYWNjb3VudCkge1xuICAgICAgICAgICAgLy8gVHJ5IHRvIGdldCBmcm9tIHdhbGxldENsaWVudCBpZiBhdmFpbGFibGVcbiAgICAgICAgICAgIGlmICh0aGlzLndhbGxldENsaWVudCAmJiAnYWNjb3VudCcgaW4gdGhpcy53YWxsZXRDbGllbnQgJiYgdGhpcy53YWxsZXRDbGllbnQuYWNjb3VudCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFjY291bnQgPSB0aGlzLndhbGxldENsaWVudC5hY2NvdW50O1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlb2YgYWNjb3VudCA9PT0gJ3N0cmluZycgPyBhd2FpdCBnZXRBZGRyZXNzKGFjY291bnQpIDogYWNjb3VudC5hZGRyZXNzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSGFuZGxlIGJvdGggQWNjb3VudCBvYmplY3RzIGFuZCByYXcgYWRkcmVzc2VzXG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5hY2NvdW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IGdldEFkZHJlc3ModGhpcy5hY2NvdW50KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5hY2NvdW50LmFkZHJlc3M7XG4gICAgfVxuICAgIGFzeW5jIGdldENoYWluSWQoKSB7XG4gICAgICAgIGNvbnN0IGNoYWluSWQgPSBhd2FpdCB0aGlzLnB1YmxpY0NsaWVudC5nZXRDaGFpbklkKCk7XG4gICAgICAgIHJldHVybiBjaGFpbklkO1xuICAgIH1cbiAgICBhc3luYyBzaWduTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICAgIGlmICghdGhpcy53YWxsZXRDbGllbnQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignV2FsbGV0IGNsaWVudCByZXF1aXJlZCBmb3Igc2lnbmluZy4gUHJvdmlkZSB3YWxsZXRDbGllbnQgKG5vdCBwcml2YXRlIGtleSkgd2hlbiBjcmVhdGluZyB0aGUgYWRhcHRlci4nKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBEZXRlcm1pbmUgYWNjb3VudCB0byB1c2UgLSB3YWxsZXRDbGllbnQgY2FuIHByb3ZpZGUgYWNjb3VudCBmcm9tIHdhbGxldCBwcm92aWRlciAoTWV0YU1hc2ssIGV0Yy4pXG4gICAgICAgIGNvbnN0IGFjY291bnQgPSB0aGlzLmFjY291bnRcbiAgICAgICAgICAgID8gKHR5cGVvZiB0aGlzLmFjY291bnQgPT09ICdzdHJpbmcnID8gYXdhaXQgZ2V0QWRkcmVzcyh0aGlzLmFjY291bnQpIDogdGhpcy5hY2NvdW50KVxuICAgICAgICAgICAgOiAodGhpcy53YWxsZXRDbGllbnQuYWNjb3VudCB8fCBudWxsKTtcbiAgICAgICAgaWYgKCFhY2NvdW50KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FjY291bnQgcmVxdWlyZWQgZm9yIHNpZ25pbmcuIFByb3ZpZGUgYWNjb3VudCBpbiB3YWxsZXRDbGllbnQgKGUuZy4sIGZyb20gTWV0YU1hc2svV2ViM0F1dGggd2FsbGV0IHByb3ZpZGVyKSBvciBjb25zdHJ1Y3Rvci4nKTtcbiAgICAgICAgfVxuICAgICAgICAvLyB3YWxsZXRDbGllbnQuc2lnbk1lc3NhZ2Ugd29ya3Mgd2l0aCB3YWxsZXQgcHJvdmlkZXJzIChNZXRhTWFzaywgV2ViM0F1dGgsIGV0Yy4pXG4gICAgICAgIC8vIE5vIHByaXZhdGUga2V5IG5lZWRlZCAtIHRoZSB3YWxsZXQgcHJvdmlkZXIgaGFuZGxlcyBzaWduaW5nXG4gICAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IGF3YWl0IHRoaXMud2FsbGV0Q2xpZW50LnNpZ25NZXNzYWdlKHtcbiAgICAgICAgICAgIGFjY291bnQsXG4gICAgICAgICAgICBtZXNzYWdlOiB0eXBlb2YgbWVzc2FnZSA9PT0gJ3N0cmluZycgPyBtZXNzYWdlIDogeyByYXc6IG1lc3NhZ2UgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBzaWduYXR1cmU7XG4gICAgfVxuICAgIGFzeW5jIHNpZ25UeXBlZERhdGEoZG9tYWluLCB0eXBlcywgdmFsdWUpIHtcbiAgICAgICAgaWYgKCF0aGlzLndhbGxldENsaWVudCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXYWxsZXQgY2xpZW50IHJlcXVpcmVkIGZvciBzaWduaW5nLiBQcm92aWRlIHdhbGxldENsaWVudCAobm90IHByaXZhdGUga2V5KSB3aGVuIGNyZWF0aW5nIHRoZSBhZGFwdGVyLicpO1xuICAgICAgICB9XG4gICAgICAgIC8vIERldGVybWluZSBhY2NvdW50IHRvIHVzZSAtIHdhbGxldENsaWVudCBjYW4gcHJvdmlkZSBhY2NvdW50IGZyb20gd2FsbGV0IHByb3ZpZGVyIChNZXRhTWFzaywgZXRjLilcbiAgICAgICAgY29uc3QgYWNjb3VudCA9IHRoaXMuYWNjb3VudFxuICAgICAgICAgICAgPyAodHlwZW9mIHRoaXMuYWNjb3VudCA9PT0gJ3N0cmluZycgPyBhd2FpdCBnZXRBZGRyZXNzKHRoaXMuYWNjb3VudCkgOiB0aGlzLmFjY291bnQpXG4gICAgICAgICAgICA6ICh0aGlzLndhbGxldENsaWVudC5hY2NvdW50IHx8IG51bGwpO1xuICAgICAgICBpZiAoIWFjY291bnQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQWNjb3VudCByZXF1aXJlZCBmb3Igc2lnbmluZy4gUHJvdmlkZSBhY2NvdW50IGluIHdhbGxldENsaWVudCAoZS5nLiwgZnJvbSBNZXRhTWFzay9XZWIzQXV0aCB3YWxsZXQgcHJvdmlkZXIpIG9yIGNvbnN0cnVjdG9yLicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByaW1hcnlUeXBlID0gT2JqZWN0LmtleXModHlwZXMpWzBdO1xuICAgICAgICBpZiAoIXByaW1hcnlUeXBlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1R5cGVzIG9iamVjdCBtdXN0IGhhdmUgYXQgbGVhc3Qgb25lIGtleSBmb3IgcHJpbWFyeVR5cGUnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzaWduYXR1cmUgPSBhd2FpdCB0aGlzLndhbGxldENsaWVudC5zaWduVHlwZWREYXRhKHtcbiAgICAgICAgICAgIGFjY291bnQsXG4gICAgICAgICAgICBkb21haW4sXG4gICAgICAgICAgICB0eXBlcyxcbiAgICAgICAgICAgIHByaW1hcnlUeXBlLCAvLyBWaWVtIHJlcXVpcmVzIHByaW1hcnlUeXBlXG4gICAgICAgICAgICBtZXNzYWdlOiB2YWx1ZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBzaWduYXR1cmU7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmllbS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@agentic-trust/8004-sdk/dist/adapters/viem.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@agentic-trust/8004-sdk/dist/index.js":
/*!****************************************************************!*\
  !*** ../../node_modules/@agentic-trust/8004-sdk/dist/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseIdentityClient: () => (/* reexport safe */ _ports_BaseIdentityClient__WEBPACK_IMPORTED_MODULE_9__.BaseIdentityClient),\n/* harmony export */   ERC8004Client: () => (/* reexport safe */ _ERC8004Client__WEBPACK_IMPORTED_MODULE_0__.ERC8004Client),\n/* harmony export */   EthersAdapter: () => (/* reexport safe */ _adapters_ethers__WEBPACK_IMPORTED_MODULE_5__.EthersAdapter),\n/* harmony export */   IdentityClient: () => (/* reexport safe */ _IdentityClient__WEBPACK_IMPORTED_MODULE_1__.IdentityClient),\n/* harmony export */   ReputationClient: () => (/* reexport safe */ _ReputationClient__WEBPACK_IMPORTED_MODULE_2__.ReputationClient),\n/* harmony export */   ValidationClient: () => (/* reexport safe */ _ValidationClient__WEBPACK_IMPORTED_MODULE_3__.ValidationClient),\n/* harmony export */   ViemAccountProvider: () => (/* reexport safe */ _ports__WEBPACK_IMPORTED_MODULE_8__.ViemAccountProvider),\n/* harmony export */   ViemAdapter: () => (/* reexport safe */ _adapters_viem__WEBPACK_IMPORTED_MODULE_6__.ViemAdapter)\n/* harmony export */ });\n/* harmony import */ var _ERC8004Client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ERC8004Client */ \"(rsc)/../../node_modules/@agentic-trust/8004-sdk/dist/ERC8004Client.js\");\n/* harmony import */ var _IdentityClient__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./IdentityClient */ \"(rsc)/../../node_modules/@agentic-trust/8004-sdk/dist/IdentityClient.js\");\n/* harmony import */ var _ReputationClient__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ReputationClient */ \"(rsc)/../../node_modules/@agentic-trust/8004-sdk/dist/ReputationClient.js\");\n/* harmony import */ var _ValidationClient__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ValidationClient */ \"(rsc)/../../node_modules/@agentic-trust/8004-sdk/dist/ValidationClient.js\");\n/* harmony import */ var _adapters_types__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./adapters/types */ \"(rsc)/../../node_modules/@agentic-trust/8004-sdk/dist/adapters/types.js\");\n/* harmony import */ var _adapters_ethers__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./adapters/ethers */ \"(rsc)/../../node_modules/@agentic-trust/8004-sdk/dist/adapters/ethers.js\");\n/* harmony import */ var _adapters_viem__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./adapters/viem */ \"(rsc)/../../node_modules/@agentic-trust/8004-sdk/dist/adapters/viem.js\");\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./types */ \"(rsc)/../../node_modules/@agentic-trust/8004-sdk/dist/types.js\");\n/* harmony import */ var _ports__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./ports */ \"(rsc)/../../node_modules/@agentic-trust/8004-sdk/dist/ports/index.js\");\n/* harmony import */ var _ports_BaseIdentityClient__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./ports/BaseIdentityClient */ \"(rsc)/../../node_modules/@agentic-trust/8004-sdk/dist/ports/BaseIdentityClient.js\");\n/**\n * ERC-8004 Trustless Agents SDK\n *\n * A TypeScript SDK for interacting with ERC-8004 compliant implementations.\n * Makes zero assumptions beyond what the spec says.\n * All \"MAY\" fields are optional, not mandatory.\n *\n * Uses adapter pattern to support any blockchain library.\n */\n\n\n\n\n\n\n // Re-enabled for reputation client support\n\n// Ports & Adapters architecture (new pattern)\n\n\n// IPFS utilities temporarily disabled due to TypeScript compatibility issues\n// export {\n//   cidToBytes32,\n//   ipfsUriToBytes32,\n//   IPFSClient,\n//   createIPFSClient,\n//   type IPFSClientConfig,\n//   type IPFSUploadResult\n// } from './utils/ipfs';\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BhZ2VudGljLXRydXN0LzgwMDQtc2RrL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2dEO0FBQ0U7QUFDSTtBQUNBO0FBQ3JCO0FBQ0M7QUFDRixDQUFDO0FBQ1Q7QUFDeEI7QUFDd0I7QUFDd0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCIsInNvdXJjZXMiOlsiL2hvbWUvYmFyYi9hYS9Bc3NvY2lhdGVkQWNjb3VudHMvbm9kZV9tb2R1bGVzL0BhZ2VudGljLXRydXN0LzgwMDQtc2RrL2Rpc3QvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBFUkMtODAwNCBUcnVzdGxlc3MgQWdlbnRzIFNES1xuICpcbiAqIEEgVHlwZVNjcmlwdCBTREsgZm9yIGludGVyYWN0aW5nIHdpdGggRVJDLTgwMDQgY29tcGxpYW50IGltcGxlbWVudGF0aW9ucy5cbiAqIE1ha2VzIHplcm8gYXNzdW1wdGlvbnMgYmV5b25kIHdoYXQgdGhlIHNwZWMgc2F5cy5cbiAqIEFsbCBcIk1BWVwiIGZpZWxkcyBhcmUgb3B0aW9uYWwsIG5vdCBtYW5kYXRvcnkuXG4gKlxuICogVXNlcyBhZGFwdGVyIHBhdHRlcm4gdG8gc3VwcG9ydCBhbnkgYmxvY2tjaGFpbiBsaWJyYXJ5LlxuICovXG5leHBvcnQgeyBFUkM4MDA0Q2xpZW50IH0gZnJvbSAnLi9FUkM4MDA0Q2xpZW50JztcbmV4cG9ydCB7IElkZW50aXR5Q2xpZW50IH0gZnJvbSAnLi9JZGVudGl0eUNsaWVudCc7XG5leHBvcnQgeyBSZXB1dGF0aW9uQ2xpZW50IH0gZnJvbSAnLi9SZXB1dGF0aW9uQ2xpZW50JztcbmV4cG9ydCB7IFZhbGlkYXRpb25DbGllbnQgfSBmcm9tICcuL1ZhbGlkYXRpb25DbGllbnQnO1xuZXhwb3J0ICogZnJvbSAnLi9hZGFwdGVycy90eXBlcyc7XG5leHBvcnQgKiBmcm9tICcuL2FkYXB0ZXJzL2V0aGVycyc7XG5leHBvcnQgKiBmcm9tICcuL2FkYXB0ZXJzL3ZpZW0nOyAvLyBSZS1lbmFibGVkIGZvciByZXB1dGF0aW9uIGNsaWVudCBzdXBwb3J0XG5leHBvcnQgKiBmcm9tICcuL3R5cGVzJztcbi8vIFBvcnRzICYgQWRhcHRlcnMgYXJjaGl0ZWN0dXJlIChuZXcgcGF0dGVybilcbmV4cG9ydCAqIGZyb20gJy4vcG9ydHMnO1xuZXhwb3J0IHsgQmFzZUlkZW50aXR5Q2xpZW50IH0gZnJvbSAnLi9wb3J0cy9CYXNlSWRlbnRpdHlDbGllbnQnO1xuLy8gSVBGUyB1dGlsaXRpZXMgdGVtcG9yYXJpbHkgZGlzYWJsZWQgZHVlIHRvIFR5cGVTY3JpcHQgY29tcGF0aWJpbGl0eSBpc3N1ZXNcbi8vIGV4cG9ydCB7XG4vLyAgIGNpZFRvQnl0ZXMzMixcbi8vICAgaXBmc1VyaVRvQnl0ZXMzMixcbi8vICAgSVBGU0NsaWVudCxcbi8vICAgY3JlYXRlSVBGU0NsaWVudCxcbi8vICAgdHlwZSBJUEZTQ2xpZW50Q29uZmlnLFxuLy8gICB0eXBlIElQRlNVcGxvYWRSZXN1bHRcbi8vIH0gZnJvbSAnLi91dGlscy9pcGZzJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@agentic-trust/8004-sdk/dist/index.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@agentic-trust/8004-sdk/dist/ports/BaseIdentityClient.js":
/*!***********************************************************************************!*\
  !*** ../../node_modules/@agentic-trust/8004-sdk/dist/ports/BaseIdentityClient.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseIdentityClient: () => (/* binding */ BaseIdentityClient)\n/* harmony export */ });\n/* harmony import */ var _abis_IdentityRegistry_json__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../abis/IdentityRegistry.json */ \"(rsc)/../../node_modules/@agentic-trust/8004-sdk/dist/abis/IdentityRegistry.json\");\n/**\n * Base Identity Client using Ports & Adapters pattern\n *\n * Uses AccountProvider (ReadClient + Signer + TxSender) instead of monolithic adapter\n * Supports prepareCalls for server-side preparation and client-side signing\n */\n\nclass BaseIdentityClient {\n    accountProvider;\n    contractAddress;\n    constructor(accountProvider, contractAddress) {\n        this.accountProvider = accountProvider;\n        this.contractAddress = contractAddress;\n    }\n    /**\n     * Prepare a register call (server-side, no signing)\n     * Returns PreparedCall that can be serialized and sent to client\n     */\n    async prepareRegisterCall(tokenUri, metadata = []) {\n        // Format metadata\n        const metadataFormatted = metadata.map(m => {\n            const bytes = this.stringToBytes(m.value);\n            const hexString = this.bytesToHex(bytes);\n            return {\n                // Updated ABI uses struct fields: { metadataKey, metadataValue }\n                metadataKey: m.key,\n                metadataValue: hexString,\n            };\n        });\n        // Encode function data\n        // Ensure ABI is loaded (handle potential bundling issues)\n        const abi = _abis_IdentityRegistry_json__WEBPACK_IMPORTED_MODULE_0__ || (await Promise.resolve(/*! import() */).then(__webpack_require__.t.bind(__webpack_require__, /*! ../abis/IdentityRegistry.json */ \"(rsc)/../../node_modules/@agentic-trust/8004-sdk/dist/abis/IdentityRegistry.json\", 17))).default;\n        if (!abi || !Array.isArray(abi)) {\n            throw new Error('IdentityRegistryABI is not loaded correctly. ABI must be an array.');\n        }\n        const data = await this.accountProvider.encodeFunctionData({\n            abi: abi,\n            functionName: 'register',\n            args: [tokenUri, metadataFormatted],\n        });\n        const chainId = await this.accountProvider.chainId();\n        return {\n            chainId,\n            description: `Register agent with URI: ${tokenUri}`,\n            steps: [\n                {\n                    to: this.contractAddress,\n                    data,\n                    value: 0n,\n                },\n            ],\n        };\n    }\n    /**\n     * Register agent (requires AccountProvider with TxSender)\n     */\n    async registerWithMetadata(tokenUri, metadata = []) {\n        // Format metadata\n        const metadataFormatted = metadata.map(m => {\n            const bytes = this.stringToBytes(m.value);\n            const hexString = this.bytesToHex(bytes);\n            return {\n                // Updated ABI uses struct fields: { metadataKey, metadataValue }\n                metadataKey: m.key,\n                metadataValue: hexString,\n            };\n        });\n        // Encode function data\n        // Ensure ABI is loaded (handle potential bundling issues)\n        const abi = _abis_IdentityRegistry_json__WEBPACK_IMPORTED_MODULE_0__ || (await Promise.resolve(/*! import() */).then(__webpack_require__.t.bind(__webpack_require__, /*! ../abis/IdentityRegistry.json */ \"(rsc)/../../node_modules/@agentic-trust/8004-sdk/dist/abis/IdentityRegistry.json\", 17))).default;\n        if (!abi || !Array.isArray(abi)) {\n            throw new Error('IdentityRegistryABI is not loaded correctly. ABI must be an array.');\n        }\n        const data = await this.accountProvider.encodeFunctionData({\n            abi: abi,\n            functionName: 'register',\n            args: [tokenUri, metadataFormatted],\n        });\n        // Estimate gas and get nonce for better transaction preparation\n        const fromAddress = await this.accountProvider.getAddress();\n        let gasEstimate;\n        let nonce;\n        let maxFeePerGas;\n        let maxPriorityFeePerGas;\n        let gasPrice;\n        try {\n            // Get block to check for EIP-1559 support\n            const block = await this.accountProvider.getBlock('latest');\n            if (block && 'baseFeePerGas' in block && block.baseFeePerGas) {\n                // EIP-1559\n                maxPriorityFeePerGas = 1000000000n; // 1 gwei\n                maxFeePerGas = (block.baseFeePerGas * 2n) + maxPriorityFeePerGas;\n            }\n            else {\n                // Legacy\n                gasPrice = await this.accountProvider.getGasPrice();\n            }\n            // Estimate gas\n            gasEstimate = await this.accountProvider.estimateGas({\n                to: this.contractAddress,\n                data,\n                value: 0n,\n                account: fromAddress,\n            });\n            // Get nonce\n            nonce = await this.accountProvider.getTransactionCount(fromAddress, 'pending');\n        }\n        catch (error) {\n            console.warn('Could not estimate gas or get transaction parameters:', error);\n            // Continue without estimates\n        }\n        // Prepare transaction request with gas estimates\n        const txRequest = {\n            to: this.contractAddress,\n            data,\n            value: 0n,\n            gas: gasEstimate,\n            nonce,\n        };\n        if (maxFeePerGas && maxPriorityFeePerGas) {\n            txRequest.maxFeePerGas = maxFeePerGas;\n            txRequest.maxPriorityFeePerGas = maxPriorityFeePerGas;\n        }\n        else if (gasPrice) {\n            txRequest.gasPrice = gasPrice;\n        }\n        // Send transaction\n        const result = await this.accountProvider.send(txRequest, {\n            simulation: true,\n        });\n        // Extract agentId from receipt\n        const agentId = this.extractAgentIdFromReceipt(result.receipt);\n        return {\n            agentId,\n            txHash: result.hash,\n        };\n    }\n    // Helper methods\n    stringToBytes(value) {\n        return new TextEncoder().encode(value);\n    }\n    bytesToHex(bytes) {\n        return '0x' + Array.from(bytes)\n            .map(b => b.toString(16).padStart(2, '0'))\n            .join('');\n    }\n    extractAgentIdFromReceipt(receipt) {\n        // Look for Registered event or Transfer event from zero address\n        if (receipt?.events) {\n            const registeredEvent = receipt.events.find((e) => e.name === 'Registered');\n            if (registeredEvent?.args) {\n                const val = registeredEvent.args.agentId ?? registeredEvent.args[0];\n                if (val !== undefined)\n                    return BigInt(val);\n            }\n            const transferEvent = receipt.events.find((e) => e.name === 'Transfer' && (e.args.from === '0x0000000000000000000000000000000000000000' || e.args.from === 0 || e.args.from === 0n));\n            if (transferEvent?.args) {\n                const val = transferEvent.args.tokenId ?? transferEvent.args[2];\n                if (val !== undefined)\n                    return BigInt(val);\n            }\n        }\n        if (receipt?.logs && Array.isArray(receipt.logs)) {\n            for (const log of receipt.logs) {\n                if (log.topics && log.topics[0] === '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef') {\n                    const from = log.topics[1];\n                    if (from === '0x0000000000000000000000000000000000000000000000000000000000000000') {\n                        const tokenId = BigInt(log.topics[3] || log.data);\n                        return tokenId;\n                    }\n                }\n            }\n        }\n        throw new Error('Could not extract agentId from transaction receipt - Registered or Transfer event not found');\n    }\n    /**\n     * Set the token URI for an agent\n     * Note: This is an implementation-specific extension (not in base spec).\n     * Assumes implementation exposes setAgentUri with owner/operator checks.\n     * @param agentId - The agent's ID\n     * @param uri - New URI string\n     */\n    async setAgentUri(agentId, uri) {\n        // Ensure ABI is loaded (handle potential bundling issues)\n        if (!_abis_IdentityRegistry_json__WEBPACK_IMPORTED_MODULE_0__ || !Array.isArray(_abis_IdentityRegistry_json__WEBPACK_IMPORTED_MODULE_0__)) {\n            throw new Error('IdentityRegistryABI is not loaded correctly. ABI must be an array.');\n        }\n        const data = await this.accountProvider.encodeFunctionData({\n            abi: _abis_IdentityRegistry_json__WEBPACK_IMPORTED_MODULE_0__,\n            // Updated ABI name is setAgentURI (capital URI)\n            functionName: 'setAgentURI',\n            args: [agentId, uri],\n        });\n        const txRequest = {\n            to: this.contractAddress,\n            data,\n            value: 0n,\n        };\n        const result = await this.accountProvider.send(txRequest, {\n            simulation: true,\n        });\n        return { txHash: result.hash };\n    }\n    /**\n     * Set on-chain metadata for an agent\n     * Spec: function setMetadata(uint256 agentId, string key, bytes value)\n     * @param agentId - The agent's ID\n     * @param key - Metadata key\n     * @param value - Metadata value\n     */\n    async setMetadata(agentId, key, value) {\n        const bytes = this.stringToBytes(value);\n        const hexString = this.bytesToHex(bytes);\n        // Ensure ABI is loaded (handle potential bundling issues)\n        if (!_abis_IdentityRegistry_json__WEBPACK_IMPORTED_MODULE_0__ || !Array.isArray(_abis_IdentityRegistry_json__WEBPACK_IMPORTED_MODULE_0__)) {\n            throw new Error('IdentityRegistryABI is not loaded correctly. ABI must be an array.');\n        }\n        const data = await this.accountProvider.encodeFunctionData({\n            abi: _abis_IdentityRegistry_json__WEBPACK_IMPORTED_MODULE_0__,\n            functionName: 'setMetadata',\n            args: [agentId, key, hexString],\n        });\n        const txRequest = {\n            to: this.contractAddress,\n            data,\n            value: 0n,\n        };\n        const result = await this.accountProvider.send(txRequest, {\n            simulation: true,\n        });\n        return { txHash: result.hash };\n    }\n    /**\n     * Get the owner of an agent\n     * Spec: Standard ERC-721 ownerOf function\n     * @param agentId - The agent's ID\n     */\n    async getOwner(agentId) {\n        // Ensure ABI is loaded (handle potential bundling issues)\n        if (!_abis_IdentityRegistry_json__WEBPACK_IMPORTED_MODULE_0__ || !Array.isArray(_abis_IdentityRegistry_json__WEBPACK_IMPORTED_MODULE_0__)) {\n            throw new Error('IdentityRegistryABI is not loaded correctly. ABI must be an array.');\n        }\n        return await this.accountProvider.call({\n            to: this.contractAddress,\n            abi: _abis_IdentityRegistry_json__WEBPACK_IMPORTED_MODULE_0__,\n            functionName: 'ownerOf',\n            args: [agentId],\n        });\n    }\n    /**\n     * Get the token URI for an agent\n     * Spec: Standard ERC-721 tokenURI function\n     * @param agentId - The agent's ID\n     */\n    async getTokenURI(agentId) {\n        // Ensure ABI is loaded (handle potential bundling issues)\n        if (!_abis_IdentityRegistry_json__WEBPACK_IMPORTED_MODULE_0__ || !Array.isArray(_abis_IdentityRegistry_json__WEBPACK_IMPORTED_MODULE_0__)) {\n            throw new Error('IdentityRegistryABI is not loaded correctly. ABI must be an array.');\n        }\n        return await this.accountProvider.call({\n            to: this.contractAddress,\n            abi: _abis_IdentityRegistry_json__WEBPACK_IMPORTED_MODULE_0__,\n            functionName: 'tokenURI',\n            args: [agentId],\n        });\n    }\n}\n//# sourceMappingURL=BaseIdentityClient.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BhZ2VudGljLXRydXN0LzgwMDQtc2RrL2Rpc3QvcG9ydHMvQmFzZUlkZW50aXR5Q2xpZW50LmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2dFO0FBQ3pEO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxvQkFBb0Isd0RBQW1CLFdBQVcsbU5BQXVDO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxTQUFTO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esb0JBQW9CLHdEQUFtQixXQUFXLG1OQUF1QztBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsd0RBQW1CLG1CQUFtQix3REFBbUI7QUFDdEU7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHdEQUFtQjtBQUNwQztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsd0RBQW1CLG1CQUFtQix3REFBbUI7QUFDdEU7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHdEQUFtQjtBQUNwQztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSx3REFBbUIsbUJBQW1CLHdEQUFtQjtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQix3REFBbUI7QUFDcEM7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSx3REFBbUIsbUJBQW1CLHdEQUFtQjtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQix3REFBbUI7QUFDcEM7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL2JhcmIvYWEvQXNzb2NpYXRlZEFjY291bnRzL25vZGVfbW9kdWxlcy9AYWdlbnRpYy10cnVzdC84MDA0LXNkay9kaXN0L3BvcnRzL0Jhc2VJZGVudGl0eUNsaWVudC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEJhc2UgSWRlbnRpdHkgQ2xpZW50IHVzaW5nIFBvcnRzICYgQWRhcHRlcnMgcGF0dGVyblxuICpcbiAqIFVzZXMgQWNjb3VudFByb3ZpZGVyIChSZWFkQ2xpZW50ICsgU2lnbmVyICsgVHhTZW5kZXIpIGluc3RlYWQgb2YgbW9ub2xpdGhpYyBhZGFwdGVyXG4gKiBTdXBwb3J0cyBwcmVwYXJlQ2FsbHMgZm9yIHNlcnZlci1zaWRlIHByZXBhcmF0aW9uIGFuZCBjbGllbnQtc2lkZSBzaWduaW5nXG4gKi9cbmltcG9ydCBJZGVudGl0eVJlZ2lzdHJ5QUJJIGZyb20gJy4uL2FiaXMvSWRlbnRpdHlSZWdpc3RyeS5qc29uJztcbmV4cG9ydCBjbGFzcyBCYXNlSWRlbnRpdHlDbGllbnQge1xuICAgIGFjY291bnRQcm92aWRlcjtcbiAgICBjb250cmFjdEFkZHJlc3M7XG4gICAgY29uc3RydWN0b3IoYWNjb3VudFByb3ZpZGVyLCBjb250cmFjdEFkZHJlc3MpIHtcbiAgICAgICAgdGhpcy5hY2NvdW50UHJvdmlkZXIgPSBhY2NvdW50UHJvdmlkZXI7XG4gICAgICAgIHRoaXMuY29udHJhY3RBZGRyZXNzID0gY29udHJhY3RBZGRyZXNzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcmVwYXJlIGEgcmVnaXN0ZXIgY2FsbCAoc2VydmVyLXNpZGUsIG5vIHNpZ25pbmcpXG4gICAgICogUmV0dXJucyBQcmVwYXJlZENhbGwgdGhhdCBjYW4gYmUgc2VyaWFsaXplZCBhbmQgc2VudCB0byBjbGllbnRcbiAgICAgKi9cbiAgICBhc3luYyBwcmVwYXJlUmVnaXN0ZXJDYWxsKHRva2VuVXJpLCBtZXRhZGF0YSA9IFtdKSB7XG4gICAgICAgIC8vIEZvcm1hdCBtZXRhZGF0YVxuICAgICAgICBjb25zdCBtZXRhZGF0YUZvcm1hdHRlZCA9IG1ldGFkYXRhLm1hcChtID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGJ5dGVzID0gdGhpcy5zdHJpbmdUb0J5dGVzKG0udmFsdWUpO1xuICAgICAgICAgICAgY29uc3QgaGV4U3RyaW5nID0gdGhpcy5ieXRlc1RvSGV4KGJ5dGVzKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlZCBBQkkgdXNlcyBzdHJ1Y3QgZmllbGRzOiB7IG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlIH1cbiAgICAgICAgICAgICAgICBtZXRhZGF0YUtleTogbS5rZXksXG4gICAgICAgICAgICAgICAgbWV0YWRhdGFWYWx1ZTogaGV4U3RyaW5nLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIEVuY29kZSBmdW5jdGlvbiBkYXRhXG4gICAgICAgIC8vIEVuc3VyZSBBQkkgaXMgbG9hZGVkIChoYW5kbGUgcG90ZW50aWFsIGJ1bmRsaW5nIGlzc3VlcylcbiAgICAgICAgY29uc3QgYWJpID0gSWRlbnRpdHlSZWdpc3RyeUFCSSB8fCAoYXdhaXQgaW1wb3J0KCcuLi9hYmlzL0lkZW50aXR5UmVnaXN0cnkuanNvbicpKS5kZWZhdWx0O1xuICAgICAgICBpZiAoIWFiaSB8fCAhQXJyYXkuaXNBcnJheShhYmkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lkZW50aXR5UmVnaXN0cnlBQkkgaXMgbm90IGxvYWRlZCBjb3JyZWN0bHkuIEFCSSBtdXN0IGJlIGFuIGFycmF5LicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLmFjY291bnRQcm92aWRlci5lbmNvZGVGdW5jdGlvbkRhdGEoe1xuICAgICAgICAgICAgYWJpOiBhYmksXG4gICAgICAgICAgICBmdW5jdGlvbk5hbWU6ICdyZWdpc3RlcicsXG4gICAgICAgICAgICBhcmdzOiBbdG9rZW5VcmksIG1ldGFkYXRhRm9ybWF0dGVkXSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGNoYWluSWQgPSBhd2FpdCB0aGlzLmFjY291bnRQcm92aWRlci5jaGFpbklkKCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjaGFpbklkLFxuICAgICAgICAgICAgZGVzY3JpcHRpb246IGBSZWdpc3RlciBhZ2VudCB3aXRoIFVSSTogJHt0b2tlblVyaX1gLFxuICAgICAgICAgICAgc3RlcHM6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHRvOiB0aGlzLmNvbnRyYWN0QWRkcmVzcyxcbiAgICAgICAgICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IDBuLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlciBhZ2VudCAocmVxdWlyZXMgQWNjb3VudFByb3ZpZGVyIHdpdGggVHhTZW5kZXIpXG4gICAgICovXG4gICAgYXN5bmMgcmVnaXN0ZXJXaXRoTWV0YWRhdGEodG9rZW5VcmksIG1ldGFkYXRhID0gW10pIHtcbiAgICAgICAgLy8gRm9ybWF0IG1ldGFkYXRhXG4gICAgICAgIGNvbnN0IG1ldGFkYXRhRm9ybWF0dGVkID0gbWV0YWRhdGEubWFwKG0gPT4ge1xuICAgICAgICAgICAgY29uc3QgYnl0ZXMgPSB0aGlzLnN0cmluZ1RvQnl0ZXMobS52YWx1ZSk7XG4gICAgICAgICAgICBjb25zdCBoZXhTdHJpbmcgPSB0aGlzLmJ5dGVzVG9IZXgoYnl0ZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAvLyBVcGRhdGVkIEFCSSB1c2VzIHN0cnVjdCBmaWVsZHM6IHsgbWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUgfVxuICAgICAgICAgICAgICAgIG1ldGFkYXRhS2V5OiBtLmtleSxcbiAgICAgICAgICAgICAgICBtZXRhZGF0YVZhbHVlOiBoZXhTdHJpbmcsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gRW5jb2RlIGZ1bmN0aW9uIGRhdGFcbiAgICAgICAgLy8gRW5zdXJlIEFCSSBpcyBsb2FkZWQgKGhhbmRsZSBwb3RlbnRpYWwgYnVuZGxpbmcgaXNzdWVzKVxuICAgICAgICBjb25zdCBhYmkgPSBJZGVudGl0eVJlZ2lzdHJ5QUJJIHx8IChhd2FpdCBpbXBvcnQoJy4uL2FiaXMvSWRlbnRpdHlSZWdpc3RyeS5qc29uJykpLmRlZmF1bHQ7XG4gICAgICAgIGlmICghYWJpIHx8ICFBcnJheS5pc0FycmF5KGFiaSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSWRlbnRpdHlSZWdpc3RyeUFCSSBpcyBub3QgbG9hZGVkIGNvcnJlY3RseS4gQUJJIG11c3QgYmUgYW4gYXJyYXkuJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHRoaXMuYWNjb3VudFByb3ZpZGVyLmVuY29kZUZ1bmN0aW9uRGF0YSh7XG4gICAgICAgICAgICBhYmk6IGFiaSxcbiAgICAgICAgICAgIGZ1bmN0aW9uTmFtZTogJ3JlZ2lzdGVyJyxcbiAgICAgICAgICAgIGFyZ3M6IFt0b2tlblVyaSwgbWV0YWRhdGFGb3JtYXR0ZWRdLFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gRXN0aW1hdGUgZ2FzIGFuZCBnZXQgbm9uY2UgZm9yIGJldHRlciB0cmFuc2FjdGlvbiBwcmVwYXJhdGlvblxuICAgICAgICBjb25zdCBmcm9tQWRkcmVzcyA9IGF3YWl0IHRoaXMuYWNjb3VudFByb3ZpZGVyLmdldEFkZHJlc3MoKTtcbiAgICAgICAgbGV0IGdhc0VzdGltYXRlO1xuICAgICAgICBsZXQgbm9uY2U7XG4gICAgICAgIGxldCBtYXhGZWVQZXJHYXM7XG4gICAgICAgIGxldCBtYXhQcmlvcml0eUZlZVBlckdhcztcbiAgICAgICAgbGV0IGdhc1ByaWNlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gR2V0IGJsb2NrIHRvIGNoZWNrIGZvciBFSVAtMTU1OSBzdXBwb3J0XG4gICAgICAgICAgICBjb25zdCBibG9jayA9IGF3YWl0IHRoaXMuYWNjb3VudFByb3ZpZGVyLmdldEJsb2NrKCdsYXRlc3QnKTtcbiAgICAgICAgICAgIGlmIChibG9jayAmJiAnYmFzZUZlZVBlckdhcycgaW4gYmxvY2sgJiYgYmxvY2suYmFzZUZlZVBlckdhcykge1xuICAgICAgICAgICAgICAgIC8vIEVJUC0xNTU5XG4gICAgICAgICAgICAgICAgbWF4UHJpb3JpdHlGZWVQZXJHYXMgPSAxMDAwMDAwMDAwbjsgLy8gMSBnd2VpXG4gICAgICAgICAgICAgICAgbWF4RmVlUGVyR2FzID0gKGJsb2NrLmJhc2VGZWVQZXJHYXMgKiAybikgKyBtYXhQcmlvcml0eUZlZVBlckdhcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIExlZ2FjeVxuICAgICAgICAgICAgICAgIGdhc1ByaWNlID0gYXdhaXQgdGhpcy5hY2NvdW50UHJvdmlkZXIuZ2V0R2FzUHJpY2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEVzdGltYXRlIGdhc1xuICAgICAgICAgICAgZ2FzRXN0aW1hdGUgPSBhd2FpdCB0aGlzLmFjY291bnRQcm92aWRlci5lc3RpbWF0ZUdhcyh7XG4gICAgICAgICAgICAgICAgdG86IHRoaXMuY29udHJhY3RBZGRyZXNzLFxuICAgICAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICAgICAgdmFsdWU6IDBuLFxuICAgICAgICAgICAgICAgIGFjY291bnQ6IGZyb21BZGRyZXNzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBHZXQgbm9uY2VcbiAgICAgICAgICAgIG5vbmNlID0gYXdhaXQgdGhpcy5hY2NvdW50UHJvdmlkZXIuZ2V0VHJhbnNhY3Rpb25Db3VudChmcm9tQWRkcmVzcywgJ3BlbmRpbmcnKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignQ291bGQgbm90IGVzdGltYXRlIGdhcyBvciBnZXQgdHJhbnNhY3Rpb24gcGFyYW1ldGVyczonLCBlcnJvcik7XG4gICAgICAgICAgICAvLyBDb250aW51ZSB3aXRob3V0IGVzdGltYXRlc1xuICAgICAgICB9XG4gICAgICAgIC8vIFByZXBhcmUgdHJhbnNhY3Rpb24gcmVxdWVzdCB3aXRoIGdhcyBlc3RpbWF0ZXNcbiAgICAgICAgY29uc3QgdHhSZXF1ZXN0ID0ge1xuICAgICAgICAgICAgdG86IHRoaXMuY29udHJhY3RBZGRyZXNzLFxuICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgIHZhbHVlOiAwbixcbiAgICAgICAgICAgIGdhczogZ2FzRXN0aW1hdGUsXG4gICAgICAgICAgICBub25jZSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKG1heEZlZVBlckdhcyAmJiBtYXhQcmlvcml0eUZlZVBlckdhcykge1xuICAgICAgICAgICAgdHhSZXF1ZXN0Lm1heEZlZVBlckdhcyA9IG1heEZlZVBlckdhcztcbiAgICAgICAgICAgIHR4UmVxdWVzdC5tYXhQcmlvcml0eUZlZVBlckdhcyA9IG1heFByaW9yaXR5RmVlUGVyR2FzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGdhc1ByaWNlKSB7XG4gICAgICAgICAgICB0eFJlcXVlc3QuZ2FzUHJpY2UgPSBnYXNQcmljZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTZW5kIHRyYW5zYWN0aW9uXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuYWNjb3VudFByb3ZpZGVyLnNlbmQodHhSZXF1ZXN0LCB7XG4gICAgICAgICAgICBzaW11bGF0aW9uOiB0cnVlLFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gRXh0cmFjdCBhZ2VudElkIGZyb20gcmVjZWlwdFxuICAgICAgICBjb25zdCBhZ2VudElkID0gdGhpcy5leHRyYWN0QWdlbnRJZEZyb21SZWNlaXB0KHJlc3VsdC5yZWNlaXB0KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFnZW50SWQsXG4gICAgICAgICAgICB0eEhhc2g6IHJlc3VsdC5oYXNoLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBIZWxwZXIgbWV0aG9kc1xuICAgIHN0cmluZ1RvQnl0ZXModmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZSh2YWx1ZSk7XG4gICAgfVxuICAgIGJ5dGVzVG9IZXgoYnl0ZXMpIHtcbiAgICAgICAgcmV0dXJuICcweCcgKyBBcnJheS5mcm9tKGJ5dGVzKVxuICAgICAgICAgICAgLm1hcChiID0+IGIudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsICcwJykpXG4gICAgICAgICAgICAuam9pbignJyk7XG4gICAgfVxuICAgIGV4dHJhY3RBZ2VudElkRnJvbVJlY2VpcHQocmVjZWlwdCkge1xuICAgICAgICAvLyBMb29rIGZvciBSZWdpc3RlcmVkIGV2ZW50IG9yIFRyYW5zZmVyIGV2ZW50IGZyb20gemVybyBhZGRyZXNzXG4gICAgICAgIGlmIChyZWNlaXB0Py5ldmVudHMpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlZ2lzdGVyZWRFdmVudCA9IHJlY2VpcHQuZXZlbnRzLmZpbmQoKGUpID0+IGUubmFtZSA9PT0gJ1JlZ2lzdGVyZWQnKTtcbiAgICAgICAgICAgIGlmIChyZWdpc3RlcmVkRXZlbnQ/LmFyZ3MpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWwgPSByZWdpc3RlcmVkRXZlbnQuYXJncy5hZ2VudElkID8/IHJlZ2lzdGVyZWRFdmVudC5hcmdzWzBdO1xuICAgICAgICAgICAgICAgIGlmICh2YWwgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEJpZ0ludCh2YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdHJhbnNmZXJFdmVudCA9IHJlY2VpcHQuZXZlbnRzLmZpbmQoKGUpID0+IGUubmFtZSA9PT0gJ1RyYW5zZmVyJyAmJiAoZS5hcmdzLmZyb20gPT09ICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnIHx8IGUuYXJncy5mcm9tID09PSAwIHx8IGUuYXJncy5mcm9tID09PSAwbikpO1xuICAgICAgICAgICAgaWYgKHRyYW5zZmVyRXZlbnQ/LmFyZ3MpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWwgPSB0cmFuc2ZlckV2ZW50LmFyZ3MudG9rZW5JZCA/PyB0cmFuc2ZlckV2ZW50LmFyZ3NbMl07XG4gICAgICAgICAgICAgICAgaWYgKHZhbCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQmlnSW50KHZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlY2VpcHQ/LmxvZ3MgJiYgQXJyYXkuaXNBcnJheShyZWNlaXB0LmxvZ3MpKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGxvZyBvZiByZWNlaXB0LmxvZ3MpIHtcbiAgICAgICAgICAgICAgICBpZiAobG9nLnRvcGljcyAmJiBsb2cudG9waWNzWzBdID09PSAnMHhkZGYyNTJhZDFiZTJjODliNjljMmIwNjhmYzM3OGRhYTk1MmJhN2YxNjNjNGExMTYyOGY1NWE0ZGY1MjNiM2VmJykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBmcm9tID0gbG9nLnRvcGljc1sxXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZyb20gPT09ICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0b2tlbklkID0gQmlnSW50KGxvZy50b3BpY3NbM10gfHwgbG9nLmRhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuSWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgZXh0cmFjdCBhZ2VudElkIGZyb20gdHJhbnNhY3Rpb24gcmVjZWlwdCAtIFJlZ2lzdGVyZWQgb3IgVHJhbnNmZXIgZXZlbnQgbm90IGZvdW5kJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgdG9rZW4gVVJJIGZvciBhbiBhZ2VudFxuICAgICAqIE5vdGU6IFRoaXMgaXMgYW4gaW1wbGVtZW50YXRpb24tc3BlY2lmaWMgZXh0ZW5zaW9uIChub3QgaW4gYmFzZSBzcGVjKS5cbiAgICAgKiBBc3N1bWVzIGltcGxlbWVudGF0aW9uIGV4cG9zZXMgc2V0QWdlbnRVcmkgd2l0aCBvd25lci9vcGVyYXRvciBjaGVja3MuXG4gICAgICogQHBhcmFtIGFnZW50SWQgLSBUaGUgYWdlbnQncyBJRFxuICAgICAqIEBwYXJhbSB1cmkgLSBOZXcgVVJJIHN0cmluZ1xuICAgICAqL1xuICAgIGFzeW5jIHNldEFnZW50VXJpKGFnZW50SWQsIHVyaSkge1xuICAgICAgICAvLyBFbnN1cmUgQUJJIGlzIGxvYWRlZCAoaGFuZGxlIHBvdGVudGlhbCBidW5kbGluZyBpc3N1ZXMpXG4gICAgICAgIGlmICghSWRlbnRpdHlSZWdpc3RyeUFCSSB8fCAhQXJyYXkuaXNBcnJheShJZGVudGl0eVJlZ2lzdHJ5QUJJKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJZGVudGl0eVJlZ2lzdHJ5QUJJIGlzIG5vdCBsb2FkZWQgY29ycmVjdGx5LiBBQkkgbXVzdCBiZSBhbiBhcnJheS4nKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy5hY2NvdW50UHJvdmlkZXIuZW5jb2RlRnVuY3Rpb25EYXRhKHtcbiAgICAgICAgICAgIGFiaTogSWRlbnRpdHlSZWdpc3RyeUFCSSxcbiAgICAgICAgICAgIC8vIFVwZGF0ZWQgQUJJIG5hbWUgaXMgc2V0QWdlbnRVUkkgKGNhcGl0YWwgVVJJKVxuICAgICAgICAgICAgZnVuY3Rpb25OYW1lOiAnc2V0QWdlbnRVUkknLFxuICAgICAgICAgICAgYXJnczogW2FnZW50SWQsIHVyaV0sXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB0eFJlcXVlc3QgPSB7XG4gICAgICAgICAgICB0bzogdGhpcy5jb250cmFjdEFkZHJlc3MsXG4gICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgdmFsdWU6IDBuLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmFjY291bnRQcm92aWRlci5zZW5kKHR4UmVxdWVzdCwge1xuICAgICAgICAgICAgc2ltdWxhdGlvbjogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7IHR4SGFzaDogcmVzdWx0Lmhhc2ggfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IG9uLWNoYWluIG1ldGFkYXRhIGZvciBhbiBhZ2VudFxuICAgICAqIFNwZWM6IGZ1bmN0aW9uIHNldE1ldGFkYXRhKHVpbnQyNTYgYWdlbnRJZCwgc3RyaW5nIGtleSwgYnl0ZXMgdmFsdWUpXG4gICAgICogQHBhcmFtIGFnZW50SWQgLSBUaGUgYWdlbnQncyBJRFxuICAgICAqIEBwYXJhbSBrZXkgLSBNZXRhZGF0YSBrZXlcbiAgICAgKiBAcGFyYW0gdmFsdWUgLSBNZXRhZGF0YSB2YWx1ZVxuICAgICAqL1xuICAgIGFzeW5jIHNldE1ldGFkYXRhKGFnZW50SWQsIGtleSwgdmFsdWUpIHtcbiAgICAgICAgY29uc3QgYnl0ZXMgPSB0aGlzLnN0cmluZ1RvQnl0ZXModmFsdWUpO1xuICAgICAgICBjb25zdCBoZXhTdHJpbmcgPSB0aGlzLmJ5dGVzVG9IZXgoYnl0ZXMpO1xuICAgICAgICAvLyBFbnN1cmUgQUJJIGlzIGxvYWRlZCAoaGFuZGxlIHBvdGVudGlhbCBidW5kbGluZyBpc3N1ZXMpXG4gICAgICAgIGlmICghSWRlbnRpdHlSZWdpc3RyeUFCSSB8fCAhQXJyYXkuaXNBcnJheShJZGVudGl0eVJlZ2lzdHJ5QUJJKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJZGVudGl0eVJlZ2lzdHJ5QUJJIGlzIG5vdCBsb2FkZWQgY29ycmVjdGx5LiBBQkkgbXVzdCBiZSBhbiBhcnJheS4nKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy5hY2NvdW50UHJvdmlkZXIuZW5jb2RlRnVuY3Rpb25EYXRhKHtcbiAgICAgICAgICAgIGFiaTogSWRlbnRpdHlSZWdpc3RyeUFCSSxcbiAgICAgICAgICAgIGZ1bmN0aW9uTmFtZTogJ3NldE1ldGFkYXRhJyxcbiAgICAgICAgICAgIGFyZ3M6IFthZ2VudElkLCBrZXksIGhleFN0cmluZ10sXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB0eFJlcXVlc3QgPSB7XG4gICAgICAgICAgICB0bzogdGhpcy5jb250cmFjdEFkZHJlc3MsXG4gICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgdmFsdWU6IDBuLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmFjY291bnRQcm92aWRlci5zZW5kKHR4UmVxdWVzdCwge1xuICAgICAgICAgICAgc2ltdWxhdGlvbjogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7IHR4SGFzaDogcmVzdWx0Lmhhc2ggfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBvd25lciBvZiBhbiBhZ2VudFxuICAgICAqIFNwZWM6IFN0YW5kYXJkIEVSQy03MjEgb3duZXJPZiBmdW5jdGlvblxuICAgICAqIEBwYXJhbSBhZ2VudElkIC0gVGhlIGFnZW50J3MgSURcbiAgICAgKi9cbiAgICBhc3luYyBnZXRPd25lcihhZ2VudElkKSB7XG4gICAgICAgIC8vIEVuc3VyZSBBQkkgaXMgbG9hZGVkIChoYW5kbGUgcG90ZW50aWFsIGJ1bmRsaW5nIGlzc3VlcylcbiAgICAgICAgaWYgKCFJZGVudGl0eVJlZ2lzdHJ5QUJJIHx8ICFBcnJheS5pc0FycmF5KElkZW50aXR5UmVnaXN0cnlBQkkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lkZW50aXR5UmVnaXN0cnlBQkkgaXMgbm90IGxvYWRlZCBjb3JyZWN0bHkuIEFCSSBtdXN0IGJlIGFuIGFycmF5LicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmFjY291bnRQcm92aWRlci5jYWxsKHtcbiAgICAgICAgICAgIHRvOiB0aGlzLmNvbnRyYWN0QWRkcmVzcyxcbiAgICAgICAgICAgIGFiaTogSWRlbnRpdHlSZWdpc3RyeUFCSSxcbiAgICAgICAgICAgIGZ1bmN0aW9uTmFtZTogJ293bmVyT2YnLFxuICAgICAgICAgICAgYXJnczogW2FnZW50SWRdLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSB0b2tlbiBVUkkgZm9yIGFuIGFnZW50XG4gICAgICogU3BlYzogU3RhbmRhcmQgRVJDLTcyMSB0b2tlblVSSSBmdW5jdGlvblxuICAgICAqIEBwYXJhbSBhZ2VudElkIC0gVGhlIGFnZW50J3MgSURcbiAgICAgKi9cbiAgICBhc3luYyBnZXRUb2tlblVSSShhZ2VudElkKSB7XG4gICAgICAgIC8vIEVuc3VyZSBBQkkgaXMgbG9hZGVkIChoYW5kbGUgcG90ZW50aWFsIGJ1bmRsaW5nIGlzc3VlcylcbiAgICAgICAgaWYgKCFJZGVudGl0eVJlZ2lzdHJ5QUJJIHx8ICFBcnJheS5pc0FycmF5KElkZW50aXR5UmVnaXN0cnlBQkkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lkZW50aXR5UmVnaXN0cnlBQkkgaXMgbm90IGxvYWRlZCBjb3JyZWN0bHkuIEFCSSBtdXN0IGJlIGFuIGFycmF5LicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmFjY291bnRQcm92aWRlci5jYWxsKHtcbiAgICAgICAgICAgIHRvOiB0aGlzLmNvbnRyYWN0QWRkcmVzcyxcbiAgICAgICAgICAgIGFiaTogSWRlbnRpdHlSZWdpc3RyeUFCSSxcbiAgICAgICAgICAgIGZ1bmN0aW9uTmFtZTogJ3Rva2VuVVJJJyxcbiAgICAgICAgICAgIGFyZ3M6IFthZ2VudElkXSxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QmFzZUlkZW50aXR5Q2xpZW50LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@agentic-trust/8004-sdk/dist/ports/BaseIdentityClient.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@agentic-trust/8004-sdk/dist/ports/adapters/ViemAccountProvider.js":
/*!*********************************************************************************************!*\
  !*** ../../node_modules/@agentic-trust/8004-sdk/dist/ports/adapters/ViemAccountProvider.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ViemAccountProvider: () => (/* binding */ ViemAccountProvider)\n/* harmony export */ });\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! viem */ \"(rsc)/../../node_modules/viem/_esm/utils/address/getAddress.js\");\n/**\n * Viem-based AccountProvider implementation\n * Implements ReadClient, Signer, and TxSender using Viem\n */\n\n/**\n * Viem-based AccountProvider\n * Composes ReadClient, Signer, and TxSender using Viem clients\n */\nclass ViemAccountProvider {\n    publicClient;\n    walletClient;\n    account;\n    chainConfig;\n    constructor(options) {\n        this.publicClient = options.publicClient;\n        this.walletClient = options.walletClient ?? null;\n        this.account = options.account;\n        this.chainConfig = options.chainConfig;\n        // Extract account from walletClient if available\n        if (this.walletClient && 'account' in this.walletClient && this.walletClient.account) {\n            this.account = this.walletClient.account;\n        }\n    }\n    // ChainConfig\n    chain() {\n        return this.chainConfig;\n    }\n    // ReadClient implementation\n    async chainId() {\n        return this.publicClient.getChainId();\n    }\n    async call(args) {\n        const cleanFunctionName = args.functionName.includes('(')\n            ? args.functionName.substring(0, args.functionName.indexOf('('))\n            : args.functionName;\n        const result = await this.publicClient.readContract({\n            address: args.to,\n            abi: args.abi,\n            functionName: cleanFunctionName,\n            args: args.args,\n            blockTag: args.blockTag,\n        });\n        return result;\n    }\n    async getBlockNumber() {\n        return this.publicClient.getBlockNumber();\n    }\n    async getBlock(blockTag) {\n        const tag = blockTag === undefined ? 'latest' : (typeof blockTag === 'bigint' ? blockTag : blockTag);\n        return this.publicClient.getBlock({ blockTag: tag });\n    }\n    async getTransactionCount(address, blockTag = 'pending') {\n        return this.publicClient.getTransactionCount({ address, blockTag });\n    }\n    async estimateGas(args) {\n        return this.publicClient.estimateGas({\n            account: args.account || (await this.getAddress()),\n            to: args.to,\n            data: args.data,\n            value: args.value,\n        });\n    }\n    async getGasPrice() {\n        return this.publicClient.getGasPrice();\n    }\n    async encodeFunctionData(args) {\n        const { encodeFunctionData } = await Promise.all(/*! import() */[__webpack_require__.e(\"vendor-chunks/viem\"), __webpack_require__.e(\"vendor-chunks/abitype\")]).then(__webpack_require__.bind(__webpack_require__, /*! viem */ \"(rsc)/../../node_modules/viem/_esm/index.js\"));\n        const cleanFunctionName = args.functionName.includes('(')\n            ? args.functionName.substring(0, args.functionName.indexOf('('))\n            : args.functionName;\n        return encodeFunctionData({\n            abi: args.abi,\n            functionName: cleanFunctionName,\n            args: args.args,\n        });\n    }\n    // Signer implementation\n    async getAddress() {\n        if (!this.walletClient) {\n            throw new Error('Wallet client required for signing. Provide walletClient when creating the provider.');\n        }\n        if (this.account) {\n            if (typeof this.account === 'string') {\n                return await (0,viem__WEBPACK_IMPORTED_MODULE_0__.getAddress)(this.account);\n            }\n            return this.account.address;\n        }\n        if (this.walletClient && 'account' in this.walletClient && this.walletClient.account) {\n            const account = this.walletClient.account;\n            return typeof account === 'string' ? await (0,viem__WEBPACK_IMPORTED_MODULE_0__.getAddress)(account) : account.address;\n        }\n        throw new Error('No account available for signing. Provide account in walletClient or constructor.');\n    }\n    async signMessage(message) {\n        if (!this.walletClient) {\n            throw new Error('Wallet client required for signing. Provide walletClient when creating the provider.');\n        }\n        const account = await this.getAddress();\n        const accountObj = this.account\n            ? (typeof this.account === 'string' ? null : this.account)\n            : (this.walletClient.account || null);\n        if (!accountObj) {\n            throw new Error('Account object required for signing. Provide account in walletClient.');\n        }\n        return this.walletClient.signMessage({\n            account: accountObj,\n            message: typeof message === 'string' ? message : { raw: message },\n        });\n    }\n    async signTypedData(args) {\n        if (!this.walletClient) {\n            throw new Error('Wallet client required for signing. Provide walletClient when creating the provider.');\n        }\n        const accountObj = this.account\n            ? (typeof this.account === 'string' ? null : this.account)\n            : (this.walletClient.account || null);\n        if (!accountObj) {\n            throw new Error('Account object required for signing. Provide account in walletClient.');\n        }\n        return this.walletClient.signTypedData({\n            account: accountObj,\n            domain: args.domain,\n            types: args.types,\n            primaryType: args.primaryType,\n            message: args.message,\n        });\n    }\n    async isContractSigner() {\n        // Check if address is a contract (has code)\n        try {\n            const address = await this.getAddress();\n            const code = await this.publicClient.getBytecode({ address });\n            return code !== undefined && code !== '0x';\n        }\n        catch {\n            return false;\n        }\n    }\n    // TxSender implementation\n    async send(tx, opts) {\n        if (!this.walletClient) {\n            throw new Error('Wallet client required for sending transactions. Provide walletClient when creating the provider.');\n        }\n        const account = await this.getAddress();\n        const accountObj = this.account\n            ? (typeof this.account === 'string' ? null : this.account)\n            : (this.walletClient.account || null);\n        if (!accountObj) {\n            throw new Error('Account object required for sending. Provide account in walletClient.');\n        }\n        // Simulate if requested (using estimateGas for basic validation)\n        if (opts?.simulation !== false) {\n            try {\n                await this.estimateGas({\n                    to: tx.to,\n                    data: tx.data,\n                    value: tx.value,\n                    account: accountObj.address,\n                });\n            }\n            catch (simError) {\n                console.warn('Transaction simulation failed:', simError);\n                // Continue anyway if simulation fails\n            }\n        }\n        // Prepare transaction request\n        const request = {\n            account: accountObj,\n            to: tx.to,\n            data: tx.data,\n            value: tx.value || 0n,\n        };\n        if (tx.gas) {\n            request.gas = tx.gas;\n        }\n        if (tx.maxFeePerGas) {\n            request.maxFeePerGas = tx.maxFeePerGas;\n        }\n        if (tx.maxPriorityFeePerGas) {\n            request.maxPriorityFeePerGas = tx.maxPriorityFeePerGas;\n        }\n        if (tx.gasPrice) {\n            request.gasPrice = tx.gasPrice;\n        }\n        if (tx.nonce !== undefined) {\n            request.nonce = tx.nonce;\n        }\n        // Send transaction\n        // Use sendTransaction since data is already encoded (not writeContract which expects ABI)\n        const hash = await this.walletClient.sendTransaction({\n            ...request,\n            chain: this.walletClient.chain,\n        });\n        // Wait for receipt\n        const receipt = await this.publicClient.waitForTransactionReceipt({ hash });\n        // Parse events if ABI is available (would need to be passed in metadata)\n        const events = [];\n        // Events parsing would require ABI from metadata - simplified for now\n        return {\n            hash,\n            kind: 'tx',\n            blockNumber: receipt.blockNumber,\n            receipt,\n            events,\n        };\n    }\n    async sendBatch(txs, opts) {\n        // For EOA, send sequentially\n        // For AA, this would be a single UserOperation with multiple calls\n        // For now, implement sequential sends\n        if (txs.length === 0) {\n            throw new Error('Cannot send empty batch');\n        }\n        if (txs.length === 1) {\n            return this.send(txs[0], opts);\n        }\n        // Sequential sends (could be optimized with multicall or AA)\n        let lastResult = null;\n        for (const tx of txs) {\n            lastResult = await this.send(tx, opts);\n        }\n        if (!lastResult) {\n            throw new Error('Batch send failed');\n        }\n        return lastResult;\n    }\n}\n//# sourceMappingURL=ViemAccountProvider.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BhZ2VudGljLXRydXN0LzgwMDQtc2RrL2Rpc3QvcG9ydHMvYWRhcHRlcnMvVmllbUFjY291bnRQcm92aWRlci5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ21DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLGVBQWU7QUFDM0Q7QUFDQTtBQUNBLHVEQUF1RCxtQkFBbUI7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixxQkFBcUIsUUFBUSx3T0FBYztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGdEQUFVO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsZ0RBQVU7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0QsY0FBYztBQUM3RSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELFNBQVM7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSw0RUFBNEUsTUFBTTtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL2JhcmIvYWEvQXNzb2NpYXRlZEFjY291bnRzL25vZGVfbW9kdWxlcy9AYWdlbnRpYy10cnVzdC84MDA0LXNkay9kaXN0L3BvcnRzL2FkYXB0ZXJzL1ZpZW1BY2NvdW50UHJvdmlkZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBWaWVtLWJhc2VkIEFjY291bnRQcm92aWRlciBpbXBsZW1lbnRhdGlvblxuICogSW1wbGVtZW50cyBSZWFkQ2xpZW50LCBTaWduZXIsIGFuZCBUeFNlbmRlciB1c2luZyBWaWVtXG4gKi9cbmltcG9ydCB7IGdldEFkZHJlc3MsIH0gZnJvbSAndmllbSc7XG4vKipcbiAqIFZpZW0tYmFzZWQgQWNjb3VudFByb3ZpZGVyXG4gKiBDb21wb3NlcyBSZWFkQ2xpZW50LCBTaWduZXIsIGFuZCBUeFNlbmRlciB1c2luZyBWaWVtIGNsaWVudHNcbiAqL1xuZXhwb3J0IGNsYXNzIFZpZW1BY2NvdW50UHJvdmlkZXIge1xuICAgIHB1YmxpY0NsaWVudDtcbiAgICB3YWxsZXRDbGllbnQ7XG4gICAgYWNjb3VudDtcbiAgICBjaGFpbkNvbmZpZztcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHRoaXMucHVibGljQ2xpZW50ID0gb3B0aW9ucy5wdWJsaWNDbGllbnQ7XG4gICAgICAgIHRoaXMud2FsbGV0Q2xpZW50ID0gb3B0aW9ucy53YWxsZXRDbGllbnQgPz8gbnVsbDtcbiAgICAgICAgdGhpcy5hY2NvdW50ID0gb3B0aW9ucy5hY2NvdW50O1xuICAgICAgICB0aGlzLmNoYWluQ29uZmlnID0gb3B0aW9ucy5jaGFpbkNvbmZpZztcbiAgICAgICAgLy8gRXh0cmFjdCBhY2NvdW50IGZyb20gd2FsbGV0Q2xpZW50IGlmIGF2YWlsYWJsZVxuICAgICAgICBpZiAodGhpcy53YWxsZXRDbGllbnQgJiYgJ2FjY291bnQnIGluIHRoaXMud2FsbGV0Q2xpZW50ICYmIHRoaXMud2FsbGV0Q2xpZW50LmFjY291bnQpIHtcbiAgICAgICAgICAgIHRoaXMuYWNjb3VudCA9IHRoaXMud2FsbGV0Q2xpZW50LmFjY291bnQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQ2hhaW5Db25maWdcbiAgICBjaGFpbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hhaW5Db25maWc7XG4gICAgfVxuICAgIC8vIFJlYWRDbGllbnQgaW1wbGVtZW50YXRpb25cbiAgICBhc3luYyBjaGFpbklkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wdWJsaWNDbGllbnQuZ2V0Q2hhaW5JZCgpO1xuICAgIH1cbiAgICBhc3luYyBjYWxsKGFyZ3MpIHtcbiAgICAgICAgY29uc3QgY2xlYW5GdW5jdGlvbk5hbWUgPSBhcmdzLmZ1bmN0aW9uTmFtZS5pbmNsdWRlcygnKCcpXG4gICAgICAgICAgICA/IGFyZ3MuZnVuY3Rpb25OYW1lLnN1YnN0cmluZygwLCBhcmdzLmZ1bmN0aW9uTmFtZS5pbmRleE9mKCcoJykpXG4gICAgICAgICAgICA6IGFyZ3MuZnVuY3Rpb25OYW1lO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLnB1YmxpY0NsaWVudC5yZWFkQ29udHJhY3Qoe1xuICAgICAgICAgICAgYWRkcmVzczogYXJncy50byxcbiAgICAgICAgICAgIGFiaTogYXJncy5hYmksXG4gICAgICAgICAgICBmdW5jdGlvbk5hbWU6IGNsZWFuRnVuY3Rpb25OYW1lLFxuICAgICAgICAgICAgYXJnczogYXJncy5hcmdzLFxuICAgICAgICAgICAgYmxvY2tUYWc6IGFyZ3MuYmxvY2tUYWcsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBhc3luYyBnZXRCbG9ja051bWJlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHVibGljQ2xpZW50LmdldEJsb2NrTnVtYmVyKCk7XG4gICAgfVxuICAgIGFzeW5jIGdldEJsb2NrKGJsb2NrVGFnKSB7XG4gICAgICAgIGNvbnN0IHRhZyA9IGJsb2NrVGFnID09PSB1bmRlZmluZWQgPyAnbGF0ZXN0JyA6ICh0eXBlb2YgYmxvY2tUYWcgPT09ICdiaWdpbnQnID8gYmxvY2tUYWcgOiBibG9ja1RhZyk7XG4gICAgICAgIHJldHVybiB0aGlzLnB1YmxpY0NsaWVudC5nZXRCbG9jayh7IGJsb2NrVGFnOiB0YWcgfSk7XG4gICAgfVxuICAgIGFzeW5jIGdldFRyYW5zYWN0aW9uQ291bnQoYWRkcmVzcywgYmxvY2tUYWcgPSAncGVuZGluZycpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHVibGljQ2xpZW50LmdldFRyYW5zYWN0aW9uQ291bnQoeyBhZGRyZXNzLCBibG9ja1RhZyB9KTtcbiAgICB9XG4gICAgYXN5bmMgZXN0aW1hdGVHYXMoYXJncykge1xuICAgICAgICByZXR1cm4gdGhpcy5wdWJsaWNDbGllbnQuZXN0aW1hdGVHYXMoe1xuICAgICAgICAgICAgYWNjb3VudDogYXJncy5hY2NvdW50IHx8IChhd2FpdCB0aGlzLmdldEFkZHJlc3MoKSksXG4gICAgICAgICAgICB0bzogYXJncy50byxcbiAgICAgICAgICAgIGRhdGE6IGFyZ3MuZGF0YSxcbiAgICAgICAgICAgIHZhbHVlOiBhcmdzLnZhbHVlLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0R2FzUHJpY2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnB1YmxpY0NsaWVudC5nZXRHYXNQcmljZSgpO1xuICAgIH1cbiAgICBhc3luYyBlbmNvZGVGdW5jdGlvbkRhdGEoYXJncykge1xuICAgICAgICBjb25zdCB7IGVuY29kZUZ1bmN0aW9uRGF0YSB9ID0gYXdhaXQgaW1wb3J0KCd2aWVtJyk7XG4gICAgICAgIGNvbnN0IGNsZWFuRnVuY3Rpb25OYW1lID0gYXJncy5mdW5jdGlvbk5hbWUuaW5jbHVkZXMoJygnKVxuICAgICAgICAgICAgPyBhcmdzLmZ1bmN0aW9uTmFtZS5zdWJzdHJpbmcoMCwgYXJncy5mdW5jdGlvbk5hbWUuaW5kZXhPZignKCcpKVxuICAgICAgICAgICAgOiBhcmdzLmZ1bmN0aW9uTmFtZTtcbiAgICAgICAgcmV0dXJuIGVuY29kZUZ1bmN0aW9uRGF0YSh7XG4gICAgICAgICAgICBhYmk6IGFyZ3MuYWJpLFxuICAgICAgICAgICAgZnVuY3Rpb25OYW1lOiBjbGVhbkZ1bmN0aW9uTmFtZSxcbiAgICAgICAgICAgIGFyZ3M6IGFyZ3MuYXJncyxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIFNpZ25lciBpbXBsZW1lbnRhdGlvblxuICAgIGFzeW5jIGdldEFkZHJlc3MoKSB7XG4gICAgICAgIGlmICghdGhpcy53YWxsZXRDbGllbnQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignV2FsbGV0IGNsaWVudCByZXF1aXJlZCBmb3Igc2lnbmluZy4gUHJvdmlkZSB3YWxsZXRDbGllbnQgd2hlbiBjcmVhdGluZyB0aGUgcHJvdmlkZXIuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuYWNjb3VudCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmFjY291bnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IGdldEFkZHJlc3ModGhpcy5hY2NvdW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFjY291bnQuYWRkcmVzcztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy53YWxsZXRDbGllbnQgJiYgJ2FjY291bnQnIGluIHRoaXMud2FsbGV0Q2xpZW50ICYmIHRoaXMud2FsbGV0Q2xpZW50LmFjY291bnQpIHtcbiAgICAgICAgICAgIGNvbnN0IGFjY291bnQgPSB0aGlzLndhbGxldENsaWVudC5hY2NvdW50O1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBhY2NvdW50ID09PSAnc3RyaW5nJyA/IGF3YWl0IGdldEFkZHJlc3MoYWNjb3VudCkgOiBhY2NvdW50LmFkZHJlc3M7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBhY2NvdW50IGF2YWlsYWJsZSBmb3Igc2lnbmluZy4gUHJvdmlkZSBhY2NvdW50IGluIHdhbGxldENsaWVudCBvciBjb25zdHJ1Y3Rvci4nKTtcbiAgICB9XG4gICAgYXN5bmMgc2lnbk1lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICBpZiAoIXRoaXMud2FsbGV0Q2xpZW50KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dhbGxldCBjbGllbnQgcmVxdWlyZWQgZm9yIHNpZ25pbmcuIFByb3ZpZGUgd2FsbGV0Q2xpZW50IHdoZW4gY3JlYXRpbmcgdGhlIHByb3ZpZGVyLicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFjY291bnQgPSBhd2FpdCB0aGlzLmdldEFkZHJlc3MoKTtcbiAgICAgICAgY29uc3QgYWNjb3VudE9iaiA9IHRoaXMuYWNjb3VudFxuICAgICAgICAgICAgPyAodHlwZW9mIHRoaXMuYWNjb3VudCA9PT0gJ3N0cmluZycgPyBudWxsIDogdGhpcy5hY2NvdW50KVxuICAgICAgICAgICAgOiAodGhpcy53YWxsZXRDbGllbnQuYWNjb3VudCB8fCBudWxsKTtcbiAgICAgICAgaWYgKCFhY2NvdW50T2JqKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FjY291bnQgb2JqZWN0IHJlcXVpcmVkIGZvciBzaWduaW5nLiBQcm92aWRlIGFjY291bnQgaW4gd2FsbGV0Q2xpZW50LicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLndhbGxldENsaWVudC5zaWduTWVzc2FnZSh7XG4gICAgICAgICAgICBhY2NvdW50OiBhY2NvdW50T2JqLFxuICAgICAgICAgICAgbWVzc2FnZTogdHlwZW9mIG1lc3NhZ2UgPT09ICdzdHJpbmcnID8gbWVzc2FnZSA6IHsgcmF3OiBtZXNzYWdlIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBzaWduVHlwZWREYXRhKGFyZ3MpIHtcbiAgICAgICAgaWYgKCF0aGlzLndhbGxldENsaWVudCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXYWxsZXQgY2xpZW50IHJlcXVpcmVkIGZvciBzaWduaW5nLiBQcm92aWRlIHdhbGxldENsaWVudCB3aGVuIGNyZWF0aW5nIHRoZSBwcm92aWRlci4nKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhY2NvdW50T2JqID0gdGhpcy5hY2NvdW50XG4gICAgICAgICAgICA/ICh0eXBlb2YgdGhpcy5hY2NvdW50ID09PSAnc3RyaW5nJyA/IG51bGwgOiB0aGlzLmFjY291bnQpXG4gICAgICAgICAgICA6ICh0aGlzLndhbGxldENsaWVudC5hY2NvdW50IHx8IG51bGwpO1xuICAgICAgICBpZiAoIWFjY291bnRPYmopIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQWNjb3VudCBvYmplY3QgcmVxdWlyZWQgZm9yIHNpZ25pbmcuIFByb3ZpZGUgYWNjb3VudCBpbiB3YWxsZXRDbGllbnQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMud2FsbGV0Q2xpZW50LnNpZ25UeXBlZERhdGEoe1xuICAgICAgICAgICAgYWNjb3VudDogYWNjb3VudE9iaixcbiAgICAgICAgICAgIGRvbWFpbjogYXJncy5kb21haW4sXG4gICAgICAgICAgICB0eXBlczogYXJncy50eXBlcyxcbiAgICAgICAgICAgIHByaW1hcnlUeXBlOiBhcmdzLnByaW1hcnlUeXBlLFxuICAgICAgICAgICAgbWVzc2FnZTogYXJncy5tZXNzYWdlLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgaXNDb250cmFjdFNpZ25lcigpIHtcbiAgICAgICAgLy8gQ2hlY2sgaWYgYWRkcmVzcyBpcyBhIGNvbnRyYWN0IChoYXMgY29kZSlcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGFkZHJlc3MgPSBhd2FpdCB0aGlzLmdldEFkZHJlc3MoKTtcbiAgICAgICAgICAgIGNvbnN0IGNvZGUgPSBhd2FpdCB0aGlzLnB1YmxpY0NsaWVudC5nZXRCeXRlY29kZSh7IGFkZHJlc3MgfSk7XG4gICAgICAgICAgICByZXR1cm4gY29kZSAhPT0gdW5kZWZpbmVkICYmIGNvZGUgIT09ICcweCc7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2gge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFR4U2VuZGVyIGltcGxlbWVudGF0aW9uXG4gICAgYXN5bmMgc2VuZCh0eCwgb3B0cykge1xuICAgICAgICBpZiAoIXRoaXMud2FsbGV0Q2xpZW50KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dhbGxldCBjbGllbnQgcmVxdWlyZWQgZm9yIHNlbmRpbmcgdHJhbnNhY3Rpb25zLiBQcm92aWRlIHdhbGxldENsaWVudCB3aGVuIGNyZWF0aW5nIHRoZSBwcm92aWRlci4nKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhY2NvdW50ID0gYXdhaXQgdGhpcy5nZXRBZGRyZXNzKCk7XG4gICAgICAgIGNvbnN0IGFjY291bnRPYmogPSB0aGlzLmFjY291bnRcbiAgICAgICAgICAgID8gKHR5cGVvZiB0aGlzLmFjY291bnQgPT09ICdzdHJpbmcnID8gbnVsbCA6IHRoaXMuYWNjb3VudClcbiAgICAgICAgICAgIDogKHRoaXMud2FsbGV0Q2xpZW50LmFjY291bnQgfHwgbnVsbCk7XG4gICAgICAgIGlmICghYWNjb3VudE9iaikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBY2NvdW50IG9iamVjdCByZXF1aXJlZCBmb3Igc2VuZGluZy4gUHJvdmlkZSBhY2NvdW50IGluIHdhbGxldENsaWVudC4nKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTaW11bGF0ZSBpZiByZXF1ZXN0ZWQgKHVzaW5nIGVzdGltYXRlR2FzIGZvciBiYXNpYyB2YWxpZGF0aW9uKVxuICAgICAgICBpZiAob3B0cz8uc2ltdWxhdGlvbiAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5lc3RpbWF0ZUdhcyh7XG4gICAgICAgICAgICAgICAgICAgIHRvOiB0eC50byxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogdHguZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHR4LnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBhY2NvdW50OiBhY2NvdW50T2JqLmFkZHJlc3MsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoc2ltRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1RyYW5zYWN0aW9uIHNpbXVsYXRpb24gZmFpbGVkOicsIHNpbUVycm9yKTtcbiAgICAgICAgICAgICAgICAvLyBDb250aW51ZSBhbnl3YXkgaWYgc2ltdWxhdGlvbiBmYWlsc1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFByZXBhcmUgdHJhbnNhY3Rpb24gcmVxdWVzdFxuICAgICAgICBjb25zdCByZXF1ZXN0ID0ge1xuICAgICAgICAgICAgYWNjb3VudDogYWNjb3VudE9iaixcbiAgICAgICAgICAgIHRvOiB0eC50byxcbiAgICAgICAgICAgIGRhdGE6IHR4LmRhdGEsXG4gICAgICAgICAgICB2YWx1ZTogdHgudmFsdWUgfHwgMG4sXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0eC5nYXMpIHtcbiAgICAgICAgICAgIHJlcXVlc3QuZ2FzID0gdHguZ2FzO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eC5tYXhGZWVQZXJHYXMpIHtcbiAgICAgICAgICAgIHJlcXVlc3QubWF4RmVlUGVyR2FzID0gdHgubWF4RmVlUGVyR2FzO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eC5tYXhQcmlvcml0eUZlZVBlckdhcykge1xuICAgICAgICAgICAgcmVxdWVzdC5tYXhQcmlvcml0eUZlZVBlckdhcyA9IHR4Lm1heFByaW9yaXR5RmVlUGVyR2FzO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eC5nYXNQcmljZSkge1xuICAgICAgICAgICAgcmVxdWVzdC5nYXNQcmljZSA9IHR4Lmdhc1ByaWNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eC5ub25jZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXF1ZXN0Lm5vbmNlID0gdHgubm9uY2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2VuZCB0cmFuc2FjdGlvblxuICAgICAgICAvLyBVc2Ugc2VuZFRyYW5zYWN0aW9uIHNpbmNlIGRhdGEgaXMgYWxyZWFkeSBlbmNvZGVkIChub3Qgd3JpdGVDb250cmFjdCB3aGljaCBleHBlY3RzIEFCSSlcbiAgICAgICAgY29uc3QgaGFzaCA9IGF3YWl0IHRoaXMud2FsbGV0Q2xpZW50LnNlbmRUcmFuc2FjdGlvbih7XG4gICAgICAgICAgICAuLi5yZXF1ZXN0LFxuICAgICAgICAgICAgY2hhaW46IHRoaXMud2FsbGV0Q2xpZW50LmNoYWluLFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gV2FpdCBmb3IgcmVjZWlwdFxuICAgICAgICBjb25zdCByZWNlaXB0ID0gYXdhaXQgdGhpcy5wdWJsaWNDbGllbnQud2FpdEZvclRyYW5zYWN0aW9uUmVjZWlwdCh7IGhhc2ggfSk7XG4gICAgICAgIC8vIFBhcnNlIGV2ZW50cyBpZiBBQkkgaXMgYXZhaWxhYmxlICh3b3VsZCBuZWVkIHRvIGJlIHBhc3NlZCBpbiBtZXRhZGF0YSlcbiAgICAgICAgY29uc3QgZXZlbnRzID0gW107XG4gICAgICAgIC8vIEV2ZW50cyBwYXJzaW5nIHdvdWxkIHJlcXVpcmUgQUJJIGZyb20gbWV0YWRhdGEgLSBzaW1wbGlmaWVkIGZvciBub3dcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGhhc2gsXG4gICAgICAgICAgICBraW5kOiAndHgnLFxuICAgICAgICAgICAgYmxvY2tOdW1iZXI6IHJlY2VpcHQuYmxvY2tOdW1iZXIsXG4gICAgICAgICAgICByZWNlaXB0LFxuICAgICAgICAgICAgZXZlbnRzLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBhc3luYyBzZW5kQmF0Y2godHhzLCBvcHRzKSB7XG4gICAgICAgIC8vIEZvciBFT0EsIHNlbmQgc2VxdWVudGlhbGx5XG4gICAgICAgIC8vIEZvciBBQSwgdGhpcyB3b3VsZCBiZSBhIHNpbmdsZSBVc2VyT3BlcmF0aW9uIHdpdGggbXVsdGlwbGUgY2FsbHNcbiAgICAgICAgLy8gRm9yIG5vdywgaW1wbGVtZW50IHNlcXVlbnRpYWwgc2VuZHNcbiAgICAgICAgaWYgKHR4cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHNlbmQgZW1wdHkgYmF0Y2gnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHhzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VuZCh0eHNbMF0sIG9wdHMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNlcXVlbnRpYWwgc2VuZHMgKGNvdWxkIGJlIG9wdGltaXplZCB3aXRoIG11bHRpY2FsbCBvciBBQSlcbiAgICAgICAgbGV0IGxhc3RSZXN1bHQgPSBudWxsO1xuICAgICAgICBmb3IgKGNvbnN0IHR4IG9mIHR4cykge1xuICAgICAgICAgICAgbGFzdFJlc3VsdCA9IGF3YWl0IHRoaXMuc2VuZCh0eCwgb3B0cyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFsYXN0UmVzdWx0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0JhdGNoIHNlbmQgZmFpbGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxhc3RSZXN1bHQ7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VmllbUFjY291bnRQcm92aWRlci5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@agentic-trust/8004-sdk/dist/ports/adapters/ViemAccountProvider.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@agentic-trust/8004-sdk/dist/ports/index.js":
/*!**********************************************************************!*\
  !*** ../../node_modules/@agentic-trust/8004-sdk/dist/ports/index.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ViemAccountProvider: () => (/* reexport safe */ _adapters_ViemAccountProvider__WEBPACK_IMPORTED_MODULE_0__.ViemAccountProvider)\n/* harmony export */ });\n/* harmony import */ var _adapters_ViemAccountProvider__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./adapters/ViemAccountProvider */ \"(rsc)/../../node_modules/@agentic-trust/8004-sdk/dist/ports/adapters/ViemAccountProvider.js\");\n/**\n * Ports & Adapters exports\n *\n * Core interfaces for chain I/O that business logic depends on\n */\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BhZ2VudGljLXRydXN0LzgwMDQtc2RrL2Rpc3QvcG9ydHMvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ3FFO0FBQ3JFIiwic291cmNlcyI6WyIvaG9tZS9iYXJiL2FhL0Fzc29jaWF0ZWRBY2NvdW50cy9ub2RlX21vZHVsZXMvQGFnZW50aWMtdHJ1c3QvODAwNC1zZGsvZGlzdC9wb3J0cy9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFBvcnRzICYgQWRhcHRlcnMgZXhwb3J0c1xuICpcbiAqIENvcmUgaW50ZXJmYWNlcyBmb3IgY2hhaW4gSS9PIHRoYXQgYnVzaW5lc3MgbG9naWMgZGVwZW5kcyBvblxuICovXG5leHBvcnQgeyBWaWVtQWNjb3VudFByb3ZpZGVyIH0gZnJvbSAnLi9hZGFwdGVycy9WaWVtQWNjb3VudFByb3ZpZGVyJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@agentic-trust/8004-sdk/dist/ports/index.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@agentic-trust/8004-sdk/dist/types.js":
/*!****************************************************************!*\
  !*** ../../node_modules/@agentic-trust/8004-sdk/dist/types.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/**\n * ERC-8004 SDK Types\n * All types strictly follow the ERC-8004 specification\n */\n\n//# sourceMappingURL=types.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BhZ2VudGljLXRydXN0LzgwMDQtc2RrL2Rpc3QvdHlwZXMuanMiLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ1U7QUFDViIsInNvdXJjZXMiOlsiL2hvbWUvYmFyYi9hYS9Bc3NvY2lhdGVkQWNjb3VudHMvbm9kZV9tb2R1bGVzL0BhZ2VudGljLXRydXN0LzgwMDQtc2RrL2Rpc3QvdHlwZXMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBFUkMtODAwNCBTREsgVHlwZXNcbiAqIEFsbCB0eXBlcyBzdHJpY3RseSBmb2xsb3cgdGhlIEVSQy04MDA0IHNwZWNpZmljYXRpb25cbiAqL1xuZXhwb3J0IHt9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHlwZXMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@agentic-trust/8004-sdk/dist/types.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@agentic-trust/core/dist/api/agents/client.js":
/*!************************************************************************!*\
  !*** ../../node_modules/@agentic-trust/core/dist/api/agents/client.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createAgent: () => (/* binding */ createAgent),\n/* harmony export */   updateAgentRegistration: () => (/* binding */ updateAgentRegistration)\n/* harmony export */ });\nconst DEFAULT_BASE_PATH = '/api/agents';\nfunction getFetch(config) {\n    if (config?.fetch)\n        return config.fetch;\n    if (typeof fetch !== 'undefined')\n        return fetch;\n    throw new Error('Global fetch is not available. Provide a custom fetch implementation via config.fetch.');\n}\nfunction getBasePath(config) {\n    return config?.basePath ?? DEFAULT_BASE_PATH;\n}\nasync function createAgent(input, config) {\n    const fetchImpl = getFetch(config);\n    const basePath = getBasePath(config);\n    const response = await fetchImpl(`${basePath}/create`, {\n        method: 'POST',\n        headers: {\n            'Content-Type': 'application/json',\n        },\n        body: JSON.stringify(input),\n    });\n    const body = await response.json().catch(() => ({}));\n    if (!response.ok) {\n        const message = body?.message || body?.error || 'Failed to create agent';\n        throw new Error(message);\n    }\n    return body;\n}\nasync function updateAgentRegistration(input, config) {\n    const fetchImpl = getFetch(config);\n    const basePath = getBasePath(config);\n    const encodedDid = encodeURIComponent(input.did8004);\n    const response = await fetchImpl(`${basePath}/${encodedDid}/registration`, {\n        method: 'PUT',\n        headers: {\n            'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({\n            registration: input.registration,\n        }),\n    });\n    const body = await response.json().catch(() => ({}));\n    if (!response.ok) {\n        const message = body?.message || body?.error || 'Failed to update agent registration';\n        throw new Error(message);\n    }\n    return body;\n}\n//# sourceMappingURL=client.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BhZ2VudGljLXRydXN0L2NvcmUvZGlzdC9hcGkvYWdlbnRzL2NsaWVudC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSx3Q0FBd0MsU0FBUztBQUNqRDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0wsc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFNBQVMsR0FBRyxXQUFXO0FBQy9EO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTCxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL2JhcmIvYWEvQXNzb2NpYXRlZEFjY291bnRzL25vZGVfbW9kdWxlcy9AYWdlbnRpYy10cnVzdC9jb3JlL2Rpc3QvYXBpL2FnZW50cy9jbGllbnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgREVGQVVMVF9CQVNFX1BBVEggPSAnL2FwaS9hZ2VudHMnO1xuZnVuY3Rpb24gZ2V0RmV0Y2goY29uZmlnKSB7XG4gICAgaWYgKGNvbmZpZz8uZmV0Y2gpXG4gICAgICAgIHJldHVybiBjb25maWcuZmV0Y2g7XG4gICAgaWYgKHR5cGVvZiBmZXRjaCAhPT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgIHJldHVybiBmZXRjaDtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0dsb2JhbCBmZXRjaCBpcyBub3QgYXZhaWxhYmxlLiBQcm92aWRlIGEgY3VzdG9tIGZldGNoIGltcGxlbWVudGF0aW9uIHZpYSBjb25maWcuZmV0Y2guJyk7XG59XG5mdW5jdGlvbiBnZXRCYXNlUGF0aChjb25maWcpIHtcbiAgICByZXR1cm4gY29uZmlnPy5iYXNlUGF0aCA/PyBERUZBVUxUX0JBU0VfUEFUSDtcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjcmVhdGVBZ2VudChpbnB1dCwgY29uZmlnKSB7XG4gICAgY29uc3QgZmV0Y2hJbXBsID0gZ2V0RmV0Y2goY29uZmlnKTtcbiAgICBjb25zdCBiYXNlUGF0aCA9IGdldEJhc2VQYXRoKGNvbmZpZyk7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaEltcGwoYCR7YmFzZVBhdGh9L2NyZWF0ZWAsIHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGlucHV0KSxcbiAgICB9KTtcbiAgICBjb25zdCBib2R5ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpLmNhdGNoKCgpID0+ICh7fSkpO1xuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGJvZHk/Lm1lc3NhZ2UgfHwgYm9keT8uZXJyb3IgfHwgJ0ZhaWxlZCB0byBjcmVhdGUgYWdlbnQnO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgfVxuICAgIHJldHVybiBib2R5O1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHVwZGF0ZUFnZW50UmVnaXN0cmF0aW9uKGlucHV0LCBjb25maWcpIHtcbiAgICBjb25zdCBmZXRjaEltcGwgPSBnZXRGZXRjaChjb25maWcpO1xuICAgIGNvbnN0IGJhc2VQYXRoID0gZ2V0QmFzZVBhdGgoY29uZmlnKTtcbiAgICBjb25zdCBlbmNvZGVkRGlkID0gZW5jb2RlVVJJQ29tcG9uZW50KGlucHV0LmRpZDgwMDQpO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2hJbXBsKGAke2Jhc2VQYXRofS8ke2VuY29kZWREaWR9L3JlZ2lzdHJhdGlvbmAsIHtcbiAgICAgICAgbWV0aG9kOiAnUFVUJyxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgcmVnaXN0cmF0aW9uOiBpbnB1dC5yZWdpc3RyYXRpb24sXG4gICAgICAgIH0pLFxuICAgIH0pO1xuICAgIGNvbnN0IGJvZHkgPSBhd2FpdCByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gKHt9KSk7XG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gYm9keT8ubWVzc2FnZSB8fCBib2R5Py5lcnJvciB8fCAnRmFpbGVkIHRvIHVwZGF0ZSBhZ2VudCByZWdpc3RyYXRpb24nO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgfVxuICAgIHJldHVybiBib2R5O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2xpZW50LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@agentic-trust/core/dist/api/agents/client.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@agentic-trust/core/dist/api/agents/core.js":
/*!**********************************************************************!*\
  !*** ../../node_modules/@agentic-trust/core/dist/api/agents/core.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AgentApiError: () => (/* binding */ AgentApiError),\n/* harmony export */   createAgentCore: () => (/* binding */ createAgentCore),\n/* harmony export */   getFeedbackCore: () => (/* binding */ getFeedbackCore),\n/* harmony export */   prepareAssociationRequestCore: () => (/* binding */ prepareAssociationRequestCore),\n/* harmony export */   prepareFeedbackCore: () => (/* binding */ prepareFeedbackCore),\n/* harmony export */   prepareValidationRequestCore: () => (/* binding */ prepareValidationRequestCore),\n/* harmony export */   requestFeedbackAuthCore: () => (/* binding */ requestFeedbackAuthCore),\n/* harmony export */   submitFeedbackDirectCore: () => (/* binding */ submitFeedbackDirectCore),\n/* harmony export */   updateAgentRegistrationCore: () => (/* binding */ updateAgentRegistrationCore)\n/* harmony export */ });\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! viem */ \"(rsc)/../../node_modules/viem/_esm/constants/address.js\");\n/* harmony import */ var _server_lib_agentRegistration__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../server/lib/agentRegistration */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/lib/agentRegistration.js\");\n/* harmony import */ var _server_lib_agenticTrust__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../server/lib/agenticTrust */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/lib/agenticTrust.js\");\n/* harmony import */ var _shared_did8004__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../shared/did8004 */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/shared/did8004.js\");\n/* harmony import */ var _server_lib_chainConfig__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../server/lib/chainConfig */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/lib/chainConfig.js\");\n\n\n\n\n\n\nconst ADDRESS_REGEX = /^0x[a-fA-F0-9]{40}$/;\nclass AgentApiError extends Error {\n    status;\n    details;\n    constructor(message, status = 400, details) {\n        super(message);\n        this.status = status;\n        this.details = details;\n        this.name = 'AgentApiError';\n    }\n}\nasync function resolveClient(ctx) {\n    if (ctx?.getClient) {\n        return ctx.getClient();\n    }\n    return (0,_server_lib_agenticTrust__WEBPACK_IMPORTED_MODULE_1__.getAgenticTrustClient)();\n}\nfunction assertAddress(value, field) {\n    if (typeof value !== 'string' || !ADDRESS_REGEX.test(value)) {\n        throw new AgentApiError(`${field} must be a valid Ethereum address (0x...)`, 400);\n    }\n}\nfunction assertMode(mode) {\n    if (mode !== 'smartAccount' && mode !== 'eoa') {\n        throw new AgentApiError('mode must be either \"smartAccount\" or \"eoa\"', 400);\n    }\n}\nfunction normalizeCallValue(value) {\n    if (typeof value === 'bigint') {\n        return value.toString();\n    }\n    if (typeof value === 'number') {\n        return value.toString();\n    }\n    if (typeof value === 'string') {\n        return value;\n    }\n    return '0';\n}\nfunction normalizeCalls(rawCalls) {\n    if (!Array.isArray(rawCalls)) {\n        return [];\n    }\n    return rawCalls.map((call) => {\n        if (!call?.to || !call?.data) {\n            throw new AgentApiError('Invalid call returned from agent preparation', 500, {\n                call,\n            });\n        }\n        return {\n            to: call.to,\n            data: call.data,\n            value: normalizeCallValue(call.value),\n        };\n    });\n}\nfunction normalizeTransactionPayload(tx, fallbackChainId) {\n    if (!tx ||\n        typeof tx !== 'object' ||\n        !tx.to ||\n        !tx.data) {\n        throw new AgentApiError('Invalid transaction payload produced by server', 500, {\n            tx,\n        });\n    }\n    const payload = tx;\n    const chainId = typeof payload.chainId === 'number' && Number.isFinite(payload.chainId)\n        ? payload.chainId\n        : fallbackChainId;\n    return {\n        to: payload.to,\n        data: payload.data,\n        value: normalizeCallValue(payload.value),\n        gas: typeof payload.gas === 'string' ? payload.gas : undefined,\n        gasPrice: typeof payload.gasPrice === 'string' ? payload.gasPrice : undefined,\n        maxFeePerGas: typeof payload.maxFeePerGas === 'string' ? payload.maxFeePerGas : undefined,\n        maxPriorityFeePerGas: typeof payload.maxPriorityFeePerGas === 'string'\n            ? payload.maxPriorityFeePerGas\n            : undefined,\n        nonce: typeof payload.nonce === 'number' ? payload.nonce : undefined,\n        chainId,\n    };\n}\nasync function createAgentCore(ctx, input) {\n    if (!input.agentName?.trim()) {\n        throw new AgentApiError('agentName is required', 400);\n    }\n    if (!input.agentAccount) {\n        throw new AgentApiError('agentAccount is required', 400);\n    }\n    assertAddress(input.agentAccount, 'agentAccount');\n    assertMode(input.mode);\n    const mode = input.mode;\n    const chainId = typeof input.chainId === 'number' && Number.isFinite(input.chainId)\n        ? input.chainId\n        : _server_lib_chainConfig__WEBPACK_IMPORTED_MODULE_3__.DEFAULT_CHAIN_ID;\n    const client = await resolveClient(ctx);\n    if (mode === 'smartAccount') {\n        if (!input.account) {\n            throw new AgentApiError('account is required for SmartAccount creation', 400);\n        }\n        assertAddress(input.account, 'account');\n        const result = await client.agents.createAgentWithSmartAccountOwnerUsingWallet({\n            agentName: input.agentName,\n            agentAccount: input.agentAccount,\n            agentCategory: input.agentCategory,\n            description: input.description,\n            image: input.image,\n            agentUrl: input.agentUrl,\n            supportedTrust: input.supportedTrust,\n            endpoints: input.endpoints,\n            chainId,\n        });\n        return {\n            success: true,\n            operation: 'create',\n            mode: 'smartAccount',\n            chainId: result.chainId,\n            tokenUri: result.tokenUri,\n            bundlerUrl: result.bundlerUrl,\n            calls: normalizeCalls(result.calls),\n            transaction: null,\n        };\n    }\n    const createResult = await client.createAgent({\n        ownerType: 'eoa',\n        executionMode: 'client',\n        agentName: input.agentName,\n        agentAccount: input.agentAccount,\n        agentCategory: input.agentCategory,\n        description: input.description,\n        image: input.image,\n        agentUrl: input.agentUrl,\n        supportedTrust: input.supportedTrust,\n        endpoints: input.endpoints,\n        chainId,\n    });\n    const clientResult = createResult;\n    if (!clientResult.requiresClientSigning || !clientResult.transaction) {\n        throw new AgentApiError('Server was unable to generate client-side transaction for EOA agent creation', 500, clientResult);\n    }\n    const transaction = normalizeTransactionPayload(clientResult.transaction, chainId);\n    return {\n        success: true,\n        operation: 'create',\n        mode: 'eoa',\n        chainId: transaction.chainId,\n        tokenUri: clientResult.tokenUri,\n        calls: [],\n        transaction,\n    };\n}\nconst SUPPORTED_UPDATE_MODES = ['smartAccount'];\nfunction normalizeRegistrationPayload(registration) {\n    if (!registration) {\n        throw new AgentApiError('registration payload is required', 400);\n    }\n    if (typeof registration === 'string') {\n        try {\n            return JSON.parse(registration);\n        }\n        catch (error) {\n            throw new AgentApiError(`Invalid registration JSON string: ${error instanceof Error ? error.message : 'Unknown error'}`, 400);\n        }\n    }\n    if (typeof registration === 'object') {\n        return registration;\n    }\n    throw new AgentApiError('registration must be a JSON object or stringified JSON', 400);\n}\nasync function updateAgentRegistrationCore(ctx, input) {\n    if (!input.did8004?.trim()) {\n        throw new AgentApiError('did8004 parameter is required', 400);\n    }\n    const mode = input.mode ?? 'smartAccount';\n    if (!SUPPORTED_UPDATE_MODES.includes(mode)) {\n        throw new AgentApiError(`mode \"${mode}\" is not supported for registration updates`, 400);\n    }\n    const parsed = (() => {\n        try {\n            return (0,_shared_did8004__WEBPACK_IMPORTED_MODULE_2__.parseDid8004)(input.did8004);\n        }\n        catch (error) {\n            throw new AgentApiError(`Invalid did:8004 identifier: ${error instanceof Error ? error.message : 'Unknown error'}`, 400);\n        }\n    })();\n    const registrationObject = normalizeRegistrationPayload(input.registration);\n    // Enforce: never include MCP endpoint entries in registration JSON.\n    try {\n        const maybeEndpoints = registrationObject?.endpoints;\n        if (Array.isArray(maybeEndpoints)) {\n            registrationObject.endpoints = maybeEndpoints.filter((e) => e?.name !== 'MCP');\n        }\n    }\n    catch {\n        // best-effort only\n    }\n    // If the caller is updating a registration JSON that already includes a registrations[]\n    // array, ensure the agentId is populated (common for \"finalize after create\" flows).\n    try {\n        const maybeRegistrations = registrationObject?.registrations;\n        if (Array.isArray(maybeRegistrations)) {\n            for (const entry of maybeRegistrations) {\n                if (!entry || typeof entry !== 'object')\n                    continue;\n                if (entry.agentId === null || typeof entry.agentId === 'undefined') {\n                    entry.agentId = parsed.agentId;\n                }\n            }\n        }\n        else {\n            // If registrations[] is missing entirely, create it so agentId is persisted in tokenUri JSON.\n            const registryAddress = (0,_server_lib_chainConfig__WEBPACK_IMPORTED_MODULE_3__.getChainContractAddress)('AGENTIC_TRUST_IDENTITY_REGISTRY', parsed.chainId);\n            if (registryAddress) {\n                registrationObject.registrations = [\n                    {\n                        agentId: parsed.agentId,\n                        agentRegistry: `eip155:${parsed.chainId}:${String(registryAddress)}`,\n                        registeredAt: new Date().toISOString(),\n                    },\n                ];\n            }\n        }\n    }\n    catch {\n        // best-effort only; never fail the update due to payload shape\n    }\n    const uploadResult = await (0,_server_lib_agentRegistration__WEBPACK_IMPORTED_MODULE_0__.uploadRegistration)(registrationObject);\n    const client = await resolveClient(ctx);\n    const prepared = await client.prepareUpdateAgent({\n        agentId: parsed.agentId,\n        chainId: parsed.chainId,\n        tokenUri: uploadResult.tokenUri,\n    });\n    return {\n        success: true,\n        operation: 'update',\n        mode: 'smartAccount',\n        chainId: prepared.chainId,\n        cid: uploadResult.cid,\n        tokenUri: uploadResult.tokenUri,\n        identityRegistry: prepared.identityRegistry,\n        bundlerUrl: prepared.bundlerUrl,\n        calls: normalizeCalls(prepared.calls),\n        transaction: null,\n    };\n}\nasync function requestFeedbackAuthCore(ctx, input) {\n    const clientAddress = input.clientAddress?.toLowerCase();\n    if (!clientAddress ||\n        typeof clientAddress !== 'string' ||\n        !ADDRESS_REGEX.test(clientAddress)) {\n        throw new AgentApiError('clientAddress must be a valid 0x-prefixed 20-byte address', 400);\n    }\n    const agentId = input.agentId?.toString().trim();\n    if (!agentId) {\n        throw new AgentApiError('agentId is required', 400);\n    }\n    const chainId = typeof input.chainId === 'number' && Number.isFinite(input.chainId)\n        ? input.chainId\n        : _server_lib_chainConfig__WEBPACK_IMPORTED_MODULE_3__.DEFAULT_CHAIN_ID;\n    const client = await resolveClient(ctx);\n    const agent = await client.getAgent(agentId, chainId);\n    if (!agent) {\n        throw new AgentApiError('Agent not found', 404, { agentId, chainId });\n    }\n    try {\n        const feedbackAuth = await agent.getFeedbackAuth({\n            clientAddress: clientAddress,\n            agentId,\n            chainId,\n            indexLimit: input.indexLimit,\n            expirySeconds: input.expirySeconds,\n            delegationSar: input.delegationSar,\n        });\n        return {\n            feedbackAuthId: feedbackAuth.feedbackAuthId,\n            agentId: feedbackAuth.agentId,\n            chainId: feedbackAuth.chainId,\n            delegationAssociation: feedbackAuth.payload?.delegationAssociation,\n        };\n    }\n    catch (error) {\n        return {\n            feedbackAuthId: \"0x0\",\n            agentId: \"0x0\",\n            chainId: 0,\n        };\n    }\n}\nasync function prepareFeedbackCore(ctx, input) {\n    if (!input.did8004?.trim()) {\n        throw new AgentApiError('did8004 parameter is required', 400);\n    }\n    const mode = input.mode ?? 'eoa';\n    if (mode !== 'eoa') {\n        throw new AgentApiError(`mode \"${mode}\" is not supported for feedback submission. Only \"eoa\" mode is supported.`, 400);\n    }\n    const parsed = (() => {\n        try {\n            return (0,_shared_did8004__WEBPACK_IMPORTED_MODULE_2__.parseDid8004)(input.did8004);\n        }\n        catch (error) {\n            throw new AgentApiError(`Invalid did:8004 identifier: ${error instanceof Error ? error.message : 'Unknown error'}`, 400);\n        }\n    })();\n    const client = await resolveClient(ctx);\n    const agent = await client.getAgent(parsed.agentId.toString(), parsed.chainId);\n    if (!agent) {\n        throw new AgentApiError('Agent not found', 404, { did8004: input.did8004 });\n    }\n    // Prepare the feedback transaction (EOA-friendly payload)\n    const { chainId, transaction } = await agent.prepareGiveFeedback({\n        score: input.score,\n        feedback: input.feedback,\n        feedbackAuth: input.feedbackAuth,\n        ...(input.clientAddress && {\n            clientAddress: input.clientAddress,\n        }),\n        tag1: input.tag1,\n        tag2: input.tag2,\n        feedbackUri: input.feedbackUri,\n        feedbackHash: input.feedbackHash,\n        skill: input.skill,\n        context: input.context,\n        capability: input.capability,\n    });\n    // Map PreparedTransaction into AgentPreparedTransactionPayload\n    const txPayload = {\n        to: transaction.to,\n        data: transaction.data,\n        value: transaction.value || '0x0',\n        gas: transaction.gas,\n        gasPrice: transaction.gasPrice,\n        maxFeePerGas: transaction.maxFeePerGas,\n        maxPriorityFeePerGas: transaction.maxPriorityFeePerGas,\n        nonce: transaction.nonce,\n        chainId,\n    };\n    return {\n        success: true,\n        operation: 'update',\n        mode: 'eoa',\n        chainId,\n        calls: [],\n        transaction: txPayload,\n    };\n}\nasync function prepareValidationRequestCore(ctx, input) {\n    if (!input.did8004?.trim()) {\n        throw new AgentApiError('did8004 parameter is required', 400);\n    }\n    const mode = input.mode ?? 'smartAccount';\n    if (mode !== 'smartAccount' && mode !== 'eoa') {\n        throw new AgentApiError(`Invalid mode \"${String(mode)}\"`, 400);\n    }\n    const parsed = (() => {\n        try {\n            return (0,_shared_did8004__WEBPACK_IMPORTED_MODULE_2__.parseDid8004)(input.did8004);\n        }\n        catch (error) {\n            throw new AgentApiError(`Invalid did:8004 identifier: ${error instanceof Error ? error.message : 'Unknown error'}`, 400);\n        }\n    })();\n    const client = await resolveClient(ctx);\n    const agent = await client.getAgent(parsed.agentId.toString(), parsed.chainId);\n    if (!agent) {\n        throw new AgentApiError('Agent not found', 404, { did8004: input.did8004 });\n    }\n    // Get validation client\n    const { getValidationRegistryClient } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ../../server/singletons/validationClient */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/singletons/validationClient.js\"));\n    const validationClient = await getValidationRegistryClient(parsed.chainId);\n    if (!input.validatorAddress?.trim()) {\n        throw new AgentApiError('validatorAddress parameter is required', 400);\n    }\n    const validatorAddress = input.validatorAddress;\n    // Prepare the validation request transaction\n    // Type assertion needed because TypeScript may not see the method on the base class type\n    const { txRequest, requestHash } = await validationClient.prepareValidationRequestTx({\n        agentId: parsed.agentId, // agentId requesting validation (the agent being validated)\n        validatorAddress, // validatorAddress that performs the validation (the validator)\n        requestUri: input.requestUri, // URI of the request (e.g. https://agentic-trust.org/validation/1)\n        requestHash: input.requestHash, // hash of the request (e.g. keccak256 of the requestUri)\n    });\n    try {\n        const existing = await validationClient.getValidationStatus(requestHash);\n        const existingValidator = existing?.validatorAddress?.toLowerCase?.();\n        if (existingValidator && existingValidator !== viem__WEBPACK_IMPORTED_MODULE_4__.zeroAddress && existingValidator !== viem__WEBPACK_IMPORTED_MODULE_4__.zeroAddress.toLowerCase()) {\n            throw new AgentApiError(existingValidator === validatorAddress.toLowerCase()\n                ? 'Validation request already exists for this agent and validator. Await the existing request to be processed before submitting another.'\n                : 'Validation request with this request hash already exists for a different validator. Provide a unique requestUri/requestHash before retrying.', 409, {\n                requestHash,\n                existingValidator: existing.validatorAddress,\n                existingAgentId: existing.agentId?.toString?.(),\n                response: existing.response,\n            });\n        }\n    }\n    catch (error) {\n        if (error instanceof AgentApiError) {\n            throw error;\n        }\n        // Ignore read errors (some chains may not support the call yet, or requestHash may not exist yet)\n        const err = error;\n        const short = err?.shortMessage ||\n            err?.cause?.shortMessage ||\n            err?.cause?.reason ||\n            err?.reason ||\n            err?.message ||\n            'Unknown error';\n        const name = String(err?.name || err?.cause?.name || '').toLowerCase();\n        const msg = String(short).toLowerCase();\n        const looksLikeRevert = name.includes('contractfunctionexecutionerror') ||\n            name.includes('contractfunctionrevertederror') ||\n            msg.includes('revert') ||\n            msg.includes('reverted');\n        // Reverts are expected when there is no prior validation request for this hash.\n        if (!looksLikeRevert) {\n            console.warn(`[prepareValidationRequestCore] Unable to check existing validation status for requestHash=${requestHash}: ${short}`);\n        }\n    }\n    // EOA mode: return a direct transaction payload (no bundler / AA).\n    if (mode === 'eoa') {\n        const txPayload = {\n            to: txRequest.to,\n            data: txRequest.data,\n            value: normalizeCallValue(txRequest.value),\n            chainId: parsed.chainId,\n        };\n        return {\n            success: true,\n            operation: 'update',\n            mode: 'eoa',\n            chainId: parsed.chainId,\n            calls: [],\n            transaction: txPayload,\n            metadata: {\n                validatorAddress,\n                requestHash,\n            },\n        };\n    }\n    // SmartAccount mode: return calls + bundlerUrl for a sponsored UserOp.\n    const bundlerUrl = (0,_server_lib_chainConfig__WEBPACK_IMPORTED_MODULE_3__.getChainBundlerUrl)(parsed.chainId);\n    if (!bundlerUrl) {\n        throw new AgentApiError(`Bundler URL not configured for chain ${parsed.chainId}`, 500);\n    }\n    const call = {\n        to: txRequest.to,\n        data: txRequest.data,\n        value: normalizeCallValue(txRequest.value),\n    };\n    return {\n        success: true,\n        operation: 'update',\n        mode: 'smartAccount',\n        chainId: parsed.chainId,\n        bundlerUrl,\n        calls: [call],\n        transaction: undefined,\n        metadata: {\n            validatorAddress,\n            requestHash,\n        },\n    };\n}\nasync function prepareAssociationRequestCore(ctx, input) {\n    if (!input.did8004?.trim()) {\n        throw new AgentApiError('did8004 parameter is required', 400);\n    }\n    const mode = input.mode ?? 'smartAccount';\n    if (mode !== 'smartAccount' && mode !== 'eoa') {\n        throw new AgentApiError(`Invalid mode \"${String(mode)}\"`, 400);\n    }\n    const parsed = (() => {\n        try {\n            return (0,_shared_did8004__WEBPACK_IMPORTED_MODULE_2__.parseDid8004)(input.did8004);\n        }\n        catch (error) {\n            throw new AgentApiError(`Invalid did:8004 identifier: ${error instanceof Error ? error.message : 'Unknown error'}`, 400);\n        }\n    })();\n    const client = await resolveClient(ctx);\n    const agent = await client.getAgent(parsed.agentId.toString(), parsed.chainId);\n    if (!agent) {\n        throw new AgentApiError('Agent not found', 404, { did8004: input.did8004 });\n    }\n    if (!agent.agentAccount && !input.initiatorAddress) {\n        throw new AgentApiError('Agent must have an agentAccount address', 400);\n    }\n    // Validate approver address\n    if (!input.approverAddress?.trim()) {\n        throw new AgentApiError('approverAddress parameter is required', 400);\n    }\n    const ADDRESS_REGEX = /^0x[a-fA-F0-9]{40}$/;\n    if (!ADDRESS_REGEX.test(input.approverAddress)) {\n        throw new AgentApiError('approverAddress must be a valid Ethereum address (0x...)', 400);\n    }\n    const initiatorAddress = (input.initiatorAddress ?? agent.agentAccount);\n    const approverAddress = input.approverAddress;\n    // Get associations client\n    const { getAssociationsClient } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ../../server/singletons/associationClient */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/singletons/associationClient.js\"));\n    const associationsClient = await getAssociationsClient(parsed.chainId);\n    // Encode association metadata if provided\n    const { encodeAssociationData } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ../../server/lib/association */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/lib/association.js\"));\n    let associationData = input.data ?? '0x';\n    if (!input.data && input.assocType !== undefined && typeof input.description !== 'undefined') {\n        associationData = encodeAssociationData({\n            assocType: input.assocType,\n            description: input.description ?? '',\n        });\n    }\n    // Build the signed association record\n    // Note: For smart accounts, signatures are handled via ERC-1271\n    // The transaction will be signed client-side using the account abstraction\n    // We create the record structure here, but the actual signature happens during execution\n    const now = typeof input.validAt === 'number' ? input.validAt : Math.floor(Date.now() / 1000);\n    // formatEvmV1: Create ERC-7930 interoperable address format using ethers\n    // Format: 0x00010000 || uint8(chainRef.length) || chainRef || uint8(20) || address\n    const { ethers } = await __webpack_require__.e(/*! import() */ \"vendor-chunks/ethers\").then(__webpack_require__.bind(__webpack_require__, /*! ethers */ \"(rsc)/../../node_modules/ethers/lib.esm/index.js\"));\n    const toMinimalBigEndianBytes = (n) => {\n        if (n === 0n)\n            return new Uint8Array([0]);\n        let hex = n.toString(16);\n        if (hex.length % 2)\n            hex = `0${hex}`;\n        return ethers.getBytes(`0x${hex}`);\n    };\n    const formatEvmV1 = (chainId, address) => {\n        const addr = ethers.getAddress(address);\n        const chainRef = toMinimalBigEndianBytes(BigInt(chainId));\n        const head = ethers.getBytes('0x00010000');\n        const out = ethers.concat([\n            head,\n            new Uint8Array([chainRef.length]),\n            chainRef,\n            new Uint8Array([20]),\n            ethers.getBytes(addr),\n        ]);\n        return ethers.hexlify(out);\n    };\n    const initiator = formatEvmV1(parsed.chainId, initiatorAddress);\n    const approver = formatEvmV1(parsed.chainId, approverAddress);\n    const record = {\n        initiator,\n        approver,\n        validAt: now,\n        validUntil: 0, // No expiry by default\n        interfaceId: '0x00000000',\n        data: associationData,\n    };\n    // Create SignedAssociationRecord with empty signatures (will be signed client-side via AA)\n    const sar = {\n        revokedAt: 0,\n        // IMPORTANT:\n        // Use K1 (0x0001) so the ERC-8092 reference implementation validates signatures via\n        // OpenZeppelin SignatureChecker, which supports both EOAs and standard ERC-1271 smart accounts.\n        // The ERC-8092 POC's ERC1271 keytype uses a bool-returning IERC1271 interface, which is not\n        // compatible with the widely-used bytes4-magic ERC-1271 implementations.\n        initiatorKeyType: '0x0001', // K1 / ECDSA secp256k1\n        approverKeyType: '0x0001', // K1 / ECDSA secp256k1\n        initiatorSignature: input.initiatorSignature ?? '0x',\n        approverSignature: input.approverSignature ?? '0x',\n        record,\n    };\n    // Prepare the storeAssociation transaction\n    // The association client will encode the call, but signatures happen during AA execution\n    const { txRequest } = await associationsClient.prepareStoreAssociationTx({ sar });\n    // EOA mode: return a direct transaction payload (no bundler / AA).\n    if (mode === 'eoa') {\n        const txPayload = {\n            to: txRequest.to,\n            data: txRequest.data,\n            value: normalizeCallValue(txRequest.value),\n            chainId: parsed.chainId,\n        };\n        return {\n            success: true,\n            operation: 'update',\n            mode: 'eoa',\n            chainId: parsed.chainId,\n            calls: [],\n            transaction: txPayload,\n            metadata: {\n                initiatorAddress,\n                approverAddress,\n                assocType: input.assocType,\n                description: input.description,\n            },\n        };\n    }\n    // SmartAccount mode: return calls + bundlerUrl for a sponsored UserOp.\n    const bundlerUrl = (0,_server_lib_chainConfig__WEBPACK_IMPORTED_MODULE_3__.getChainBundlerUrl)(parsed.chainId);\n    if (!bundlerUrl) {\n        throw new AgentApiError(`Bundler URL not configured for chain ${parsed.chainId}`, 500);\n    }\n    const call = {\n        to: txRequest.to,\n        data: txRequest.data,\n        value: normalizeCallValue(txRequest.value),\n    };\n    return {\n        success: true,\n        operation: 'update',\n        mode: 'smartAccount',\n        chainId: parsed.chainId,\n        bundlerUrl,\n        calls: [call],\n        transaction: undefined,\n        metadata: {\n            initiatorAddress,\n            approverAddress,\n            assocType: input.assocType,\n            description: input.description,\n        },\n    };\n}\nfunction jsonSafeDeep(value) {\n    if (typeof value === 'bigint') {\n        return value.toString();\n    }\n    if (Array.isArray(value)) {\n        return value.map((item) => jsonSafeDeep(item));\n    }\n    if (value && typeof value === 'object') {\n        const result = {};\n        for (const [key, v] of Object.entries(value)) {\n            result[key] = jsonSafeDeep(v);\n        }\n        return result;\n    }\n    return value;\n}\nasync function getFeedbackCore(ctx, input) {\n    if (!input.did8004?.trim()) {\n        throw new AgentApiError('did8004 parameter is required', 400);\n    }\n    const parsed = (() => {\n        try {\n            return (0,_shared_did8004__WEBPACK_IMPORTED_MODULE_2__.parseDid8004)(input.did8004);\n        }\n        catch (error) {\n            throw new AgentApiError(`Invalid did:8004 identifier: ${error instanceof Error ? error.message : 'Unknown error'}`, 400);\n        }\n    })();\n    const includeRevoked = !!input.includeRevoked;\n    const limit = typeof input.limit === 'number' && Number.isFinite(input.limit)\n        ? input.limit\n        : 100;\n    const offset = typeof input.offset === 'number' && Number.isFinite(input.offset)\n        ? input.offset\n        : 0;\n    const client = await resolveClient(ctx);\n    const [feedback, summary] = await Promise.all([\n        client.getAgentFeedback({\n            agentId: parsed.agentId,\n            chainId: parsed.chainId,\n            includeRevoked,\n            limit,\n            offset,\n        }),\n        client\n            .getReputationSummary({\n            agentId: parsed.agentId,\n            chainId: parsed.chainId,\n        })\n            .catch((error) => {\n            // Preserve previous behavior: log and return null on summary failure\n            // eslint-disable-next-line no-console\n            console.warn('[AgenticTrust][Core] getReputationSummary failed:', error);\n            return null;\n        }),\n    ]);\n    return {\n        feedback: jsonSafeDeep(feedback),\n        summary: jsonSafeDeep(summary),\n    };\n}\nasync function submitFeedbackDirectCore(ctx, input) {\n    const client = await resolveClient(ctx);\n    let agentId = typeof input.agentId === 'number'\n        ? input.agentId.toString()\n        : input.agentId?.toString();\n    let chainId = typeof input.chainId === 'number' && Number.isFinite(input.chainId)\n        ? input.chainId\n        : undefined;\n    if (input.did8004 && input.did8004.trim()) {\n        const parsed = (() => {\n            try {\n                return (0,_shared_did8004__WEBPACK_IMPORTED_MODULE_2__.parseDid8004)(input.did8004);\n            }\n            catch (error) {\n                throw new AgentApiError(`Invalid did:8004 identifier: ${error instanceof Error ? error.message : 'Unknown error'}`, 400);\n            }\n        })();\n        agentId = parsed.agentId.toString();\n        chainId = parsed.chainId;\n    }\n    if (!agentId) {\n        throw new AgentApiError('agentId or did8004 is required', 400);\n    }\n    const resolvedChainId = typeof chainId === 'number' && Number.isFinite(chainId)\n        ? chainId\n        : _server_lib_chainConfig__WEBPACK_IMPORTED_MODULE_3__.DEFAULT_CHAIN_ID;\n    const agent = await client.getAgent(agentId.toString(), resolvedChainId);\n    if (!agent) {\n        throw new AgentApiError('Agent not found', 404, {\n            agentId,\n            chainId: resolvedChainId,\n        });\n    }\n    const numericScore = typeof input.score === 'number'\n        ? input.score\n        : Number.parseInt(input.score, 10);\n    if (!Number.isFinite(numericScore)) {\n        throw new AgentApiError('Invalid score value', 400);\n    }\n    try {\n        const feedbackResult = await agent.giveFeedback({\n            ...(input.clientAddress && {\n                clientAddress: input.clientAddress,\n            }),\n            score: numericScore,\n            feedback: input.feedback && input.feedback.length > 0\n                ? input.feedback\n                : 'Feedback submitted via direct endpoint',\n            feedbackAuth: input.feedbackAuth,\n            tag1: input.tag1,\n            tag2: input.tag2,\n            feedbackUri: input.feedbackUri,\n            feedbackHash: input.feedbackHash,\n            skill: input.skill,\n            context: input.context,\n            capability: input.capability,\n        });\n        return {\n            success: true,\n            txHash: feedbackResult.txHash,\n        };\n    }\n    catch (error) {\n        throw new AgentApiError(error instanceof Error ? error.message : 'Failed to submit feedback', 502, {\n            agentId,\n            chainId: resolvedChainId,\n        });\n    }\n}\n//# sourceMappingURL=core.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BhZ2VudGljLXRydXN0L2NvcmUvZGlzdC9hcGkvYWdlbnRzL2NvcmUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBbUM7QUFDcUM7QUFDRjtBQUNsQjtBQUNtQjtBQUNhO0FBQ3BGLHNDQUFzQyxHQUFHO0FBQ2xDO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLCtFQUFxQjtBQUNoQztBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsT0FBTztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHFFQUFnQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFLHlEQUF5RDtBQUNsSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxLQUFLO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiw2REFBWTtBQUMvQjtBQUNBO0FBQ0Esb0VBQW9FLHlEQUF5RDtBQUM3SDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGdGQUF1QjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxlQUFlLEdBQUcsd0JBQXdCO0FBQzNGO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQSwrQkFBK0IsaUZBQWtCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUscUVBQWdCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxrQkFBa0I7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxLQUFLO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiw2REFBWTtBQUMvQjtBQUNBO0FBQ0Esb0VBQW9FLHlEQUF5RDtBQUM3SDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsd0JBQXdCO0FBQ2xGO0FBQ0E7QUFDQSxZQUFZLHVCQUF1QjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxhQUFhO0FBQzlEO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiw2REFBWTtBQUMvQjtBQUNBO0FBQ0Esb0VBQW9FLHlEQUF5RDtBQUM3SDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsd0JBQXdCO0FBQ2xGO0FBQ0E7QUFDQSxZQUFZLDhCQUE4QixRQUFRLCtOQUFrRDtBQUNwRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkseUJBQXlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCw2Q0FBVywwQkFBMEIsNkNBQVc7QUFDdkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzSEFBc0gsWUFBWSxJQUFJLE1BQU07QUFDNUk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsMkVBQWtCO0FBQ3pDO0FBQ0Esd0VBQXdFLGVBQWU7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELGFBQWE7QUFDOUQ7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDZEQUFZO0FBQy9CO0FBQ0E7QUFDQSxvRUFBb0UseURBQXlEO0FBQzdIO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCx3QkFBd0I7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxHQUFHO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksd0JBQXdCLFFBQVEsaU9BQW1EO0FBQy9GO0FBQ0E7QUFDQSxZQUFZLHdCQUF3QixRQUFRLHVNQUFzQztBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFNBQVMsUUFBUSxtTEFBZ0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixJQUFJO0FBQzFCLG9DQUFvQyxJQUFJO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxZQUFZLHVEQUF1RCxLQUFLO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDJFQUFrQjtBQUN6QztBQUNBLHdFQUF3RSxlQUFlO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiw2REFBWTtBQUMvQjtBQUNBO0FBQ0Esb0VBQW9FLHlEQUF5RDtBQUM3SDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDZEQUFZO0FBQ25DO0FBQ0E7QUFDQSx3RUFBd0UseURBQXlEO0FBQ2pJO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHFFQUFnQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL2JhcmIvYWEvQXNzb2NpYXRlZEFjY291bnRzL25vZGVfbW9kdWxlcy9AYWdlbnRpYy10cnVzdC9jb3JlL2Rpc3QvYXBpL2FnZW50cy9jb3JlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHplcm9BZGRyZXNzIH0gZnJvbSAndmllbSc7XG5pbXBvcnQgeyB1cGxvYWRSZWdpc3RyYXRpb24gfSBmcm9tICcuLi8uLi9zZXJ2ZXIvbGliL2FnZW50UmVnaXN0cmF0aW9uJztcbmltcG9ydCB7IGdldEFnZW50aWNUcnVzdENsaWVudCB9IGZyb20gJy4uLy4uL3NlcnZlci9saWIvYWdlbnRpY1RydXN0JztcbmltcG9ydCB7IHBhcnNlRGlkODAwNCB9IGZyb20gJy4uLy4uL3NoYXJlZC9kaWQ4MDA0JztcbmltcG9ydCB7IGdldENoYWluQ29udHJhY3RBZGRyZXNzIH0gZnJvbSAnLi4vLi4vc2VydmVyL2xpYi9jaGFpbkNvbmZpZyc7XG5pbXBvcnQgeyBERUZBVUxUX0NIQUlOX0lELCBnZXRDaGFpbkJ1bmRsZXJVcmwgfSBmcm9tICcuLi8uLi9zZXJ2ZXIvbGliL2NoYWluQ29uZmlnJztcbmNvbnN0IEFERFJFU1NfUkVHRVggPSAvXjB4W2EtZkEtRjAtOV17NDB9JC87XG5leHBvcnQgY2xhc3MgQWdlbnRBcGlFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBzdGF0dXM7XG4gICAgZGV0YWlscztcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBzdGF0dXMgPSA0MDAsIGRldGFpbHMpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgIHRoaXMuc3RhdHVzID0gc3RhdHVzO1xuICAgICAgICB0aGlzLmRldGFpbHMgPSBkZXRhaWxzO1xuICAgICAgICB0aGlzLm5hbWUgPSAnQWdlbnRBcGlFcnJvcic7XG4gICAgfVxufVxuYXN5bmMgZnVuY3Rpb24gcmVzb2x2ZUNsaWVudChjdHgpIHtcbiAgICBpZiAoY3R4Py5nZXRDbGllbnQpIHtcbiAgICAgICAgcmV0dXJuIGN0eC5nZXRDbGllbnQoKTtcbiAgICB9XG4gICAgcmV0dXJuIGdldEFnZW50aWNUcnVzdENsaWVudCgpO1xufVxuZnVuY3Rpb24gYXNzZXJ0QWRkcmVzcyh2YWx1ZSwgZmllbGQpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJyB8fCAhQUREUkVTU19SRUdFWC50ZXN0KHZhbHVlKSkge1xuICAgICAgICB0aHJvdyBuZXcgQWdlbnRBcGlFcnJvcihgJHtmaWVsZH0gbXVzdCBiZSBhIHZhbGlkIEV0aGVyZXVtIGFkZHJlc3MgKDB4Li4uKWAsIDQwMCk7XG4gICAgfVxufVxuZnVuY3Rpb24gYXNzZXJ0TW9kZShtb2RlKSB7XG4gICAgaWYgKG1vZGUgIT09ICdzbWFydEFjY291bnQnICYmIG1vZGUgIT09ICdlb2EnKSB7XG4gICAgICAgIHRocm93IG5ldyBBZ2VudEFwaUVycm9yKCdtb2RlIG11c3QgYmUgZWl0aGVyIFwic21hcnRBY2NvdW50XCIgb3IgXCJlb2FcIicsIDQwMCk7XG4gICAgfVxufVxuZnVuY3Rpb24gbm9ybWFsaXplQ2FsbFZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2JpZ2ludCcpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiAnMCc7XG59XG5mdW5jdGlvbiBub3JtYWxpemVDYWxscyhyYXdDYWxscykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShyYXdDYWxscykpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICByZXR1cm4gcmF3Q2FsbHMubWFwKChjYWxsKSA9PiB7XG4gICAgICAgIGlmICghY2FsbD8udG8gfHwgIWNhbGw/LmRhdGEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBZ2VudEFwaUVycm9yKCdJbnZhbGlkIGNhbGwgcmV0dXJuZWQgZnJvbSBhZ2VudCBwcmVwYXJhdGlvbicsIDUwMCwge1xuICAgICAgICAgICAgICAgIGNhbGwsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdG86IGNhbGwudG8sXG4gICAgICAgICAgICBkYXRhOiBjYWxsLmRhdGEsXG4gICAgICAgICAgICB2YWx1ZTogbm9ybWFsaXplQ2FsbFZhbHVlKGNhbGwudmFsdWUpLFxuICAgICAgICB9O1xuICAgIH0pO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplVHJhbnNhY3Rpb25QYXlsb2FkKHR4LCBmYWxsYmFja0NoYWluSWQpIHtcbiAgICBpZiAoIXR4IHx8XG4gICAgICAgIHR5cGVvZiB0eCAhPT0gJ29iamVjdCcgfHxcbiAgICAgICAgIXR4LnRvIHx8XG4gICAgICAgICF0eC5kYXRhKSB7XG4gICAgICAgIHRocm93IG5ldyBBZ2VudEFwaUVycm9yKCdJbnZhbGlkIHRyYW5zYWN0aW9uIHBheWxvYWQgcHJvZHVjZWQgYnkgc2VydmVyJywgNTAwLCB7XG4gICAgICAgICAgICB0eCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IHBheWxvYWQgPSB0eDtcbiAgICBjb25zdCBjaGFpbklkID0gdHlwZW9mIHBheWxvYWQuY2hhaW5JZCA9PT0gJ251bWJlcicgJiYgTnVtYmVyLmlzRmluaXRlKHBheWxvYWQuY2hhaW5JZClcbiAgICAgICAgPyBwYXlsb2FkLmNoYWluSWRcbiAgICAgICAgOiBmYWxsYmFja0NoYWluSWQ7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdG86IHBheWxvYWQudG8sXG4gICAgICAgIGRhdGE6IHBheWxvYWQuZGF0YSxcbiAgICAgICAgdmFsdWU6IG5vcm1hbGl6ZUNhbGxWYWx1ZShwYXlsb2FkLnZhbHVlKSxcbiAgICAgICAgZ2FzOiB0eXBlb2YgcGF5bG9hZC5nYXMgPT09ICdzdHJpbmcnID8gcGF5bG9hZC5nYXMgOiB1bmRlZmluZWQsXG4gICAgICAgIGdhc1ByaWNlOiB0eXBlb2YgcGF5bG9hZC5nYXNQcmljZSA9PT0gJ3N0cmluZycgPyBwYXlsb2FkLmdhc1ByaWNlIDogdW5kZWZpbmVkLFxuICAgICAgICBtYXhGZWVQZXJHYXM6IHR5cGVvZiBwYXlsb2FkLm1heEZlZVBlckdhcyA9PT0gJ3N0cmluZycgPyBwYXlsb2FkLm1heEZlZVBlckdhcyA6IHVuZGVmaW5lZCxcbiAgICAgICAgbWF4UHJpb3JpdHlGZWVQZXJHYXM6IHR5cGVvZiBwYXlsb2FkLm1heFByaW9yaXR5RmVlUGVyR2FzID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgPyBwYXlsb2FkLm1heFByaW9yaXR5RmVlUGVyR2FzXG4gICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgbm9uY2U6IHR5cGVvZiBwYXlsb2FkLm5vbmNlID09PSAnbnVtYmVyJyA/IHBheWxvYWQubm9uY2UgOiB1bmRlZmluZWQsXG4gICAgICAgIGNoYWluSWQsXG4gICAgfTtcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjcmVhdGVBZ2VudENvcmUoY3R4LCBpbnB1dCkge1xuICAgIGlmICghaW5wdXQuYWdlbnROYW1lPy50cmltKCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEFnZW50QXBpRXJyb3IoJ2FnZW50TmFtZSBpcyByZXF1aXJlZCcsIDQwMCk7XG4gICAgfVxuICAgIGlmICghaW5wdXQuYWdlbnRBY2NvdW50KSB7XG4gICAgICAgIHRocm93IG5ldyBBZ2VudEFwaUVycm9yKCdhZ2VudEFjY291bnQgaXMgcmVxdWlyZWQnLCA0MDApO1xuICAgIH1cbiAgICBhc3NlcnRBZGRyZXNzKGlucHV0LmFnZW50QWNjb3VudCwgJ2FnZW50QWNjb3VudCcpO1xuICAgIGFzc2VydE1vZGUoaW5wdXQubW9kZSk7XG4gICAgY29uc3QgbW9kZSA9IGlucHV0Lm1vZGU7XG4gICAgY29uc3QgY2hhaW5JZCA9IHR5cGVvZiBpbnB1dC5jaGFpbklkID09PSAnbnVtYmVyJyAmJiBOdW1iZXIuaXNGaW5pdGUoaW5wdXQuY2hhaW5JZClcbiAgICAgICAgPyBpbnB1dC5jaGFpbklkXG4gICAgICAgIDogREVGQVVMVF9DSEFJTl9JRDtcbiAgICBjb25zdCBjbGllbnQgPSBhd2FpdCByZXNvbHZlQ2xpZW50KGN0eCk7XG4gICAgaWYgKG1vZGUgPT09ICdzbWFydEFjY291bnQnKSB7XG4gICAgICAgIGlmICghaW5wdXQuYWNjb3VudCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFnZW50QXBpRXJyb3IoJ2FjY291bnQgaXMgcmVxdWlyZWQgZm9yIFNtYXJ0QWNjb3VudCBjcmVhdGlvbicsIDQwMCk7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0QWRkcmVzcyhpbnB1dC5hY2NvdW50LCAnYWNjb3VudCcpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjbGllbnQuYWdlbnRzLmNyZWF0ZUFnZW50V2l0aFNtYXJ0QWNjb3VudE93bmVyVXNpbmdXYWxsZXQoe1xuICAgICAgICAgICAgYWdlbnROYW1lOiBpbnB1dC5hZ2VudE5hbWUsXG4gICAgICAgICAgICBhZ2VudEFjY291bnQ6IGlucHV0LmFnZW50QWNjb3VudCxcbiAgICAgICAgICAgIGFnZW50Q2F0ZWdvcnk6IGlucHV0LmFnZW50Q2F0ZWdvcnksXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogaW5wdXQuZGVzY3JpcHRpb24sXG4gICAgICAgICAgICBpbWFnZTogaW5wdXQuaW1hZ2UsXG4gICAgICAgICAgICBhZ2VudFVybDogaW5wdXQuYWdlbnRVcmwsXG4gICAgICAgICAgICBzdXBwb3J0ZWRUcnVzdDogaW5wdXQuc3VwcG9ydGVkVHJ1c3QsXG4gICAgICAgICAgICBlbmRwb2ludHM6IGlucHV0LmVuZHBvaW50cyxcbiAgICAgICAgICAgIGNoYWluSWQsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgICAgIG9wZXJhdGlvbjogJ2NyZWF0ZScsXG4gICAgICAgICAgICBtb2RlOiAnc21hcnRBY2NvdW50JyxcbiAgICAgICAgICAgIGNoYWluSWQ6IHJlc3VsdC5jaGFpbklkLFxuICAgICAgICAgICAgdG9rZW5Vcmk6IHJlc3VsdC50b2tlblVyaSxcbiAgICAgICAgICAgIGJ1bmRsZXJVcmw6IHJlc3VsdC5idW5kbGVyVXJsLFxuICAgICAgICAgICAgY2FsbHM6IG5vcm1hbGl6ZUNhbGxzKHJlc3VsdC5jYWxscyksXG4gICAgICAgICAgICB0cmFuc2FjdGlvbjogbnVsbCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgY3JlYXRlUmVzdWx0ID0gYXdhaXQgY2xpZW50LmNyZWF0ZUFnZW50KHtcbiAgICAgICAgb3duZXJUeXBlOiAnZW9hJyxcbiAgICAgICAgZXhlY3V0aW9uTW9kZTogJ2NsaWVudCcsXG4gICAgICAgIGFnZW50TmFtZTogaW5wdXQuYWdlbnROYW1lLFxuICAgICAgICBhZ2VudEFjY291bnQ6IGlucHV0LmFnZW50QWNjb3VudCxcbiAgICAgICAgYWdlbnRDYXRlZ29yeTogaW5wdXQuYWdlbnRDYXRlZ29yeSxcbiAgICAgICAgZGVzY3JpcHRpb246IGlucHV0LmRlc2NyaXB0aW9uLFxuICAgICAgICBpbWFnZTogaW5wdXQuaW1hZ2UsXG4gICAgICAgIGFnZW50VXJsOiBpbnB1dC5hZ2VudFVybCxcbiAgICAgICAgc3VwcG9ydGVkVHJ1c3Q6IGlucHV0LnN1cHBvcnRlZFRydXN0LFxuICAgICAgICBlbmRwb2ludHM6IGlucHV0LmVuZHBvaW50cyxcbiAgICAgICAgY2hhaW5JZCxcbiAgICB9KTtcbiAgICBjb25zdCBjbGllbnRSZXN1bHQgPSBjcmVhdGVSZXN1bHQ7XG4gICAgaWYgKCFjbGllbnRSZXN1bHQucmVxdWlyZXNDbGllbnRTaWduaW5nIHx8ICFjbGllbnRSZXN1bHQudHJhbnNhY3Rpb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEFnZW50QXBpRXJyb3IoJ1NlcnZlciB3YXMgdW5hYmxlIHRvIGdlbmVyYXRlIGNsaWVudC1zaWRlIHRyYW5zYWN0aW9uIGZvciBFT0EgYWdlbnQgY3JlYXRpb24nLCA1MDAsIGNsaWVudFJlc3VsdCk7XG4gICAgfVxuICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gbm9ybWFsaXplVHJhbnNhY3Rpb25QYXlsb2FkKGNsaWVudFJlc3VsdC50cmFuc2FjdGlvbiwgY2hhaW5JZCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgb3BlcmF0aW9uOiAnY3JlYXRlJyxcbiAgICAgICAgbW9kZTogJ2VvYScsXG4gICAgICAgIGNoYWluSWQ6IHRyYW5zYWN0aW9uLmNoYWluSWQsXG4gICAgICAgIHRva2VuVXJpOiBjbGllbnRSZXN1bHQudG9rZW5VcmksXG4gICAgICAgIGNhbGxzOiBbXSxcbiAgICAgICAgdHJhbnNhY3Rpb24sXG4gICAgfTtcbn1cbmNvbnN0IFNVUFBPUlRFRF9VUERBVEVfTU9ERVMgPSBbJ3NtYXJ0QWNjb3VudCddO1xuZnVuY3Rpb24gbm9ybWFsaXplUmVnaXN0cmF0aW9uUGF5bG9hZChyZWdpc3RyYXRpb24pIHtcbiAgICBpZiAoIXJlZ2lzdHJhdGlvbikge1xuICAgICAgICB0aHJvdyBuZXcgQWdlbnRBcGlFcnJvcigncmVnaXN0cmF0aW9uIHBheWxvYWQgaXMgcmVxdWlyZWQnLCA0MDApO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHJlZ2lzdHJhdGlvbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBKU09OLnBhcnNlKHJlZ2lzdHJhdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQWdlbnRBcGlFcnJvcihgSW52YWxpZCByZWdpc3RyYXRpb24gSlNPTiBzdHJpbmc6ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvcid9YCwgNDAwKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAodHlwZW9mIHJlZ2lzdHJhdGlvbiA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIHJlZ2lzdHJhdGlvbjtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEFnZW50QXBpRXJyb3IoJ3JlZ2lzdHJhdGlvbiBtdXN0IGJlIGEgSlNPTiBvYmplY3Qgb3Igc3RyaW5naWZpZWQgSlNPTicsIDQwMCk7XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdXBkYXRlQWdlbnRSZWdpc3RyYXRpb25Db3JlKGN0eCwgaW5wdXQpIHtcbiAgICBpZiAoIWlucHV0LmRpZDgwMDQ/LnRyaW0oKSkge1xuICAgICAgICB0aHJvdyBuZXcgQWdlbnRBcGlFcnJvcignZGlkODAwNCBwYXJhbWV0ZXIgaXMgcmVxdWlyZWQnLCA0MDApO1xuICAgIH1cbiAgICBjb25zdCBtb2RlID0gaW5wdXQubW9kZSA/PyAnc21hcnRBY2NvdW50JztcbiAgICBpZiAoIVNVUFBPUlRFRF9VUERBVEVfTU9ERVMuaW5jbHVkZXMobW9kZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEFnZW50QXBpRXJyb3IoYG1vZGUgXCIke21vZGV9XCIgaXMgbm90IHN1cHBvcnRlZCBmb3IgcmVnaXN0cmF0aW9uIHVwZGF0ZXNgLCA0MDApO1xuICAgIH1cbiAgICBjb25zdCBwYXJzZWQgPSAoKCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlRGlkODAwNChpbnB1dC5kaWQ4MDA0KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBZ2VudEFwaUVycm9yKGBJbnZhbGlkIGRpZDo4MDA0IGlkZW50aWZpZXI6ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvcid9YCwgNDAwKTtcbiAgICAgICAgfVxuICAgIH0pKCk7XG4gICAgY29uc3QgcmVnaXN0cmF0aW9uT2JqZWN0ID0gbm9ybWFsaXplUmVnaXN0cmF0aW9uUGF5bG9hZChpbnB1dC5yZWdpc3RyYXRpb24pO1xuICAgIC8vIEVuZm9yY2U6IG5ldmVyIGluY2x1ZGUgTUNQIGVuZHBvaW50IGVudHJpZXMgaW4gcmVnaXN0cmF0aW9uIEpTT04uXG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgbWF5YmVFbmRwb2ludHMgPSByZWdpc3RyYXRpb25PYmplY3Q/LmVuZHBvaW50cztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobWF5YmVFbmRwb2ludHMpKSB7XG4gICAgICAgICAgICByZWdpc3RyYXRpb25PYmplY3QuZW5kcG9pbnRzID0gbWF5YmVFbmRwb2ludHMuZmlsdGVyKChlKSA9PiBlPy5uYW1lICE9PSAnTUNQJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2gge1xuICAgICAgICAvLyBiZXN0LWVmZm9ydCBvbmx5XG4gICAgfVxuICAgIC8vIElmIHRoZSBjYWxsZXIgaXMgdXBkYXRpbmcgYSByZWdpc3RyYXRpb24gSlNPTiB0aGF0IGFscmVhZHkgaW5jbHVkZXMgYSByZWdpc3RyYXRpb25zW11cbiAgICAvLyBhcnJheSwgZW5zdXJlIHRoZSBhZ2VudElkIGlzIHBvcHVsYXRlZCAoY29tbW9uIGZvciBcImZpbmFsaXplIGFmdGVyIGNyZWF0ZVwiIGZsb3dzKS5cbiAgICB0cnkge1xuICAgICAgICBjb25zdCBtYXliZVJlZ2lzdHJhdGlvbnMgPSByZWdpc3RyYXRpb25PYmplY3Q/LnJlZ2lzdHJhdGlvbnM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KG1heWJlUmVnaXN0cmF0aW9ucykpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZW50cnkgb2YgbWF5YmVSZWdpc3RyYXRpb25zKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFlbnRyeSB8fCB0eXBlb2YgZW50cnkgIT09ICdvYmplY3QnKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBpZiAoZW50cnkuYWdlbnRJZCA9PT0gbnVsbCB8fCB0eXBlb2YgZW50cnkuYWdlbnRJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgZW50cnkuYWdlbnRJZCA9IHBhcnNlZC5hZ2VudElkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIElmIHJlZ2lzdHJhdGlvbnNbXSBpcyBtaXNzaW5nIGVudGlyZWx5LCBjcmVhdGUgaXQgc28gYWdlbnRJZCBpcyBwZXJzaXN0ZWQgaW4gdG9rZW5VcmkgSlNPTi5cbiAgICAgICAgICAgIGNvbnN0IHJlZ2lzdHJ5QWRkcmVzcyA9IGdldENoYWluQ29udHJhY3RBZGRyZXNzKCdBR0VOVElDX1RSVVNUX0lERU5USVRZX1JFR0lTVFJZJywgcGFyc2VkLmNoYWluSWQpO1xuICAgICAgICAgICAgaWYgKHJlZ2lzdHJ5QWRkcmVzcykge1xuICAgICAgICAgICAgICAgIHJlZ2lzdHJhdGlvbk9iamVjdC5yZWdpc3RyYXRpb25zID0gW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZ2VudElkOiBwYXJzZWQuYWdlbnRJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFnZW50UmVnaXN0cnk6IGBlaXAxNTU6JHtwYXJzZWQuY2hhaW5JZH06JHtTdHJpbmcocmVnaXN0cnlBZGRyZXNzKX1gLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVnaXN0ZXJlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCB7XG4gICAgICAgIC8vIGJlc3QtZWZmb3J0IG9ubHk7IG5ldmVyIGZhaWwgdGhlIHVwZGF0ZSBkdWUgdG8gcGF5bG9hZCBzaGFwZVxuICAgIH1cbiAgICBjb25zdCB1cGxvYWRSZXN1bHQgPSBhd2FpdCB1cGxvYWRSZWdpc3RyYXRpb24ocmVnaXN0cmF0aW9uT2JqZWN0KTtcbiAgICBjb25zdCBjbGllbnQgPSBhd2FpdCByZXNvbHZlQ2xpZW50KGN0eCk7XG4gICAgY29uc3QgcHJlcGFyZWQgPSBhd2FpdCBjbGllbnQucHJlcGFyZVVwZGF0ZUFnZW50KHtcbiAgICAgICAgYWdlbnRJZDogcGFyc2VkLmFnZW50SWQsXG4gICAgICAgIGNoYWluSWQ6IHBhcnNlZC5jaGFpbklkLFxuICAgICAgICB0b2tlblVyaTogdXBsb2FkUmVzdWx0LnRva2VuVXJpLFxuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgIG9wZXJhdGlvbjogJ3VwZGF0ZScsXG4gICAgICAgIG1vZGU6ICdzbWFydEFjY291bnQnLFxuICAgICAgICBjaGFpbklkOiBwcmVwYXJlZC5jaGFpbklkLFxuICAgICAgICBjaWQ6IHVwbG9hZFJlc3VsdC5jaWQsXG4gICAgICAgIHRva2VuVXJpOiB1cGxvYWRSZXN1bHQudG9rZW5VcmksXG4gICAgICAgIGlkZW50aXR5UmVnaXN0cnk6IHByZXBhcmVkLmlkZW50aXR5UmVnaXN0cnksXG4gICAgICAgIGJ1bmRsZXJVcmw6IHByZXBhcmVkLmJ1bmRsZXJVcmwsXG4gICAgICAgIGNhbGxzOiBub3JtYWxpemVDYWxscyhwcmVwYXJlZC5jYWxscyksXG4gICAgICAgIHRyYW5zYWN0aW9uOiBudWxsLFxuICAgIH07XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVxdWVzdEZlZWRiYWNrQXV0aENvcmUoY3R4LCBpbnB1dCkge1xuICAgIGNvbnN0IGNsaWVudEFkZHJlc3MgPSBpbnB1dC5jbGllbnRBZGRyZXNzPy50b0xvd2VyQ2FzZSgpO1xuICAgIGlmICghY2xpZW50QWRkcmVzcyB8fFxuICAgICAgICB0eXBlb2YgY2xpZW50QWRkcmVzcyAhPT0gJ3N0cmluZycgfHxcbiAgICAgICAgIUFERFJFU1NfUkVHRVgudGVzdChjbGllbnRBZGRyZXNzKSkge1xuICAgICAgICB0aHJvdyBuZXcgQWdlbnRBcGlFcnJvcignY2xpZW50QWRkcmVzcyBtdXN0IGJlIGEgdmFsaWQgMHgtcHJlZml4ZWQgMjAtYnl0ZSBhZGRyZXNzJywgNDAwKTtcbiAgICB9XG4gICAgY29uc3QgYWdlbnRJZCA9IGlucHV0LmFnZW50SWQ/LnRvU3RyaW5nKCkudHJpbSgpO1xuICAgIGlmICghYWdlbnRJZCkge1xuICAgICAgICB0aHJvdyBuZXcgQWdlbnRBcGlFcnJvcignYWdlbnRJZCBpcyByZXF1aXJlZCcsIDQwMCk7XG4gICAgfVxuICAgIGNvbnN0IGNoYWluSWQgPSB0eXBlb2YgaW5wdXQuY2hhaW5JZCA9PT0gJ251bWJlcicgJiYgTnVtYmVyLmlzRmluaXRlKGlucHV0LmNoYWluSWQpXG4gICAgICAgID8gaW5wdXQuY2hhaW5JZFxuICAgICAgICA6IERFRkFVTFRfQ0hBSU5fSUQ7XG4gICAgY29uc3QgY2xpZW50ID0gYXdhaXQgcmVzb2x2ZUNsaWVudChjdHgpO1xuICAgIGNvbnN0IGFnZW50ID0gYXdhaXQgY2xpZW50LmdldEFnZW50KGFnZW50SWQsIGNoYWluSWQpO1xuICAgIGlmICghYWdlbnQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEFnZW50QXBpRXJyb3IoJ0FnZW50IG5vdCBmb3VuZCcsIDQwNCwgeyBhZ2VudElkLCBjaGFpbklkIH0pO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBjb25zdCBmZWVkYmFja0F1dGggPSBhd2FpdCBhZ2VudC5nZXRGZWVkYmFja0F1dGgoe1xuICAgICAgICAgICAgY2xpZW50QWRkcmVzczogY2xpZW50QWRkcmVzcyxcbiAgICAgICAgICAgIGFnZW50SWQsXG4gICAgICAgICAgICBjaGFpbklkLFxuICAgICAgICAgICAgaW5kZXhMaW1pdDogaW5wdXQuaW5kZXhMaW1pdCxcbiAgICAgICAgICAgIGV4cGlyeVNlY29uZHM6IGlucHV0LmV4cGlyeVNlY29uZHMsXG4gICAgICAgICAgICBkZWxlZ2F0aW9uU2FyOiBpbnB1dC5kZWxlZ2F0aW9uU2FyLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGZlZWRiYWNrQXV0aElkOiBmZWVkYmFja0F1dGguZmVlZGJhY2tBdXRoSWQsXG4gICAgICAgICAgICBhZ2VudElkOiBmZWVkYmFja0F1dGguYWdlbnRJZCxcbiAgICAgICAgICAgIGNoYWluSWQ6IGZlZWRiYWNrQXV0aC5jaGFpbklkLFxuICAgICAgICAgICAgZGVsZWdhdGlvbkFzc29jaWF0aW9uOiBmZWVkYmFja0F1dGgucGF5bG9hZD8uZGVsZWdhdGlvbkFzc29jaWF0aW9uLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGZlZWRiYWNrQXV0aElkOiBcIjB4MFwiLFxuICAgICAgICAgICAgYWdlbnRJZDogXCIweDBcIixcbiAgICAgICAgICAgIGNoYWluSWQ6IDAsXG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHByZXBhcmVGZWVkYmFja0NvcmUoY3R4LCBpbnB1dCkge1xuICAgIGlmICghaW5wdXQuZGlkODAwND8udHJpbSgpKSB7XG4gICAgICAgIHRocm93IG5ldyBBZ2VudEFwaUVycm9yKCdkaWQ4MDA0IHBhcmFtZXRlciBpcyByZXF1aXJlZCcsIDQwMCk7XG4gICAgfVxuICAgIGNvbnN0IG1vZGUgPSBpbnB1dC5tb2RlID8/ICdlb2EnO1xuICAgIGlmIChtb2RlICE9PSAnZW9hJykge1xuICAgICAgICB0aHJvdyBuZXcgQWdlbnRBcGlFcnJvcihgbW9kZSBcIiR7bW9kZX1cIiBpcyBub3Qgc3VwcG9ydGVkIGZvciBmZWVkYmFjayBzdWJtaXNzaW9uLiBPbmx5IFwiZW9hXCIgbW9kZSBpcyBzdXBwb3J0ZWQuYCwgNDAwKTtcbiAgICB9XG4gICAgY29uc3QgcGFyc2VkID0gKCgpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZURpZDgwMDQoaW5wdXQuZGlkODAwNCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQWdlbnRBcGlFcnJvcihgSW52YWxpZCBkaWQ6ODAwNCBpZGVudGlmaWVyOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InfWAsIDQwMCk7XG4gICAgICAgIH1cbiAgICB9KSgpO1xuICAgIGNvbnN0IGNsaWVudCA9IGF3YWl0IHJlc29sdmVDbGllbnQoY3R4KTtcbiAgICBjb25zdCBhZ2VudCA9IGF3YWl0IGNsaWVudC5nZXRBZ2VudChwYXJzZWQuYWdlbnRJZC50b1N0cmluZygpLCBwYXJzZWQuY2hhaW5JZCk7XG4gICAgaWYgKCFhZ2VudCkge1xuICAgICAgICB0aHJvdyBuZXcgQWdlbnRBcGlFcnJvcignQWdlbnQgbm90IGZvdW5kJywgNDA0LCB7IGRpZDgwMDQ6IGlucHV0LmRpZDgwMDQgfSk7XG4gICAgfVxuICAgIC8vIFByZXBhcmUgdGhlIGZlZWRiYWNrIHRyYW5zYWN0aW9uIChFT0EtZnJpZW5kbHkgcGF5bG9hZClcbiAgICBjb25zdCB7IGNoYWluSWQsIHRyYW5zYWN0aW9uIH0gPSBhd2FpdCBhZ2VudC5wcmVwYXJlR2l2ZUZlZWRiYWNrKHtcbiAgICAgICAgc2NvcmU6IGlucHV0LnNjb3JlLFxuICAgICAgICBmZWVkYmFjazogaW5wdXQuZmVlZGJhY2ssXG4gICAgICAgIGZlZWRiYWNrQXV0aDogaW5wdXQuZmVlZGJhY2tBdXRoLFxuICAgICAgICAuLi4oaW5wdXQuY2xpZW50QWRkcmVzcyAmJiB7XG4gICAgICAgICAgICBjbGllbnRBZGRyZXNzOiBpbnB1dC5jbGllbnRBZGRyZXNzLFxuICAgICAgICB9KSxcbiAgICAgICAgdGFnMTogaW5wdXQudGFnMSxcbiAgICAgICAgdGFnMjogaW5wdXQudGFnMixcbiAgICAgICAgZmVlZGJhY2tVcmk6IGlucHV0LmZlZWRiYWNrVXJpLFxuICAgICAgICBmZWVkYmFja0hhc2g6IGlucHV0LmZlZWRiYWNrSGFzaCxcbiAgICAgICAgc2tpbGw6IGlucHV0LnNraWxsLFxuICAgICAgICBjb250ZXh0OiBpbnB1dC5jb250ZXh0LFxuICAgICAgICBjYXBhYmlsaXR5OiBpbnB1dC5jYXBhYmlsaXR5LFxuICAgIH0pO1xuICAgIC8vIE1hcCBQcmVwYXJlZFRyYW5zYWN0aW9uIGludG8gQWdlbnRQcmVwYXJlZFRyYW5zYWN0aW9uUGF5bG9hZFxuICAgIGNvbnN0IHR4UGF5bG9hZCA9IHtcbiAgICAgICAgdG86IHRyYW5zYWN0aW9uLnRvLFxuICAgICAgICBkYXRhOiB0cmFuc2FjdGlvbi5kYXRhLFxuICAgICAgICB2YWx1ZTogdHJhbnNhY3Rpb24udmFsdWUgfHwgJzB4MCcsXG4gICAgICAgIGdhczogdHJhbnNhY3Rpb24uZ2FzLFxuICAgICAgICBnYXNQcmljZTogdHJhbnNhY3Rpb24uZ2FzUHJpY2UsXG4gICAgICAgIG1heEZlZVBlckdhczogdHJhbnNhY3Rpb24ubWF4RmVlUGVyR2FzLFxuICAgICAgICBtYXhQcmlvcml0eUZlZVBlckdhczogdHJhbnNhY3Rpb24ubWF4UHJpb3JpdHlGZWVQZXJHYXMsXG4gICAgICAgIG5vbmNlOiB0cmFuc2FjdGlvbi5ub25jZSxcbiAgICAgICAgY2hhaW5JZCxcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgIG9wZXJhdGlvbjogJ3VwZGF0ZScsXG4gICAgICAgIG1vZGU6ICdlb2EnLFxuICAgICAgICBjaGFpbklkLFxuICAgICAgICBjYWxsczogW10sXG4gICAgICAgIHRyYW5zYWN0aW9uOiB0eFBheWxvYWQsXG4gICAgfTtcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwcmVwYXJlVmFsaWRhdGlvblJlcXVlc3RDb3JlKGN0eCwgaW5wdXQpIHtcbiAgICBpZiAoIWlucHV0LmRpZDgwMDQ/LnRyaW0oKSkge1xuICAgICAgICB0aHJvdyBuZXcgQWdlbnRBcGlFcnJvcignZGlkODAwNCBwYXJhbWV0ZXIgaXMgcmVxdWlyZWQnLCA0MDApO1xuICAgIH1cbiAgICBjb25zdCBtb2RlID0gaW5wdXQubW9kZSA/PyAnc21hcnRBY2NvdW50JztcbiAgICBpZiAobW9kZSAhPT0gJ3NtYXJ0QWNjb3VudCcgJiYgbW9kZSAhPT0gJ2VvYScpIHtcbiAgICAgICAgdGhyb3cgbmV3IEFnZW50QXBpRXJyb3IoYEludmFsaWQgbW9kZSBcIiR7U3RyaW5nKG1vZGUpfVwiYCwgNDAwKTtcbiAgICB9XG4gICAgY29uc3QgcGFyc2VkID0gKCgpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZURpZDgwMDQoaW5wdXQuZGlkODAwNCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQWdlbnRBcGlFcnJvcihgSW52YWxpZCBkaWQ6ODAwNCBpZGVudGlmaWVyOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InfWAsIDQwMCk7XG4gICAgICAgIH1cbiAgICB9KSgpO1xuICAgIGNvbnN0IGNsaWVudCA9IGF3YWl0IHJlc29sdmVDbGllbnQoY3R4KTtcbiAgICBjb25zdCBhZ2VudCA9IGF3YWl0IGNsaWVudC5nZXRBZ2VudChwYXJzZWQuYWdlbnRJZC50b1N0cmluZygpLCBwYXJzZWQuY2hhaW5JZCk7XG4gICAgaWYgKCFhZ2VudCkge1xuICAgICAgICB0aHJvdyBuZXcgQWdlbnRBcGlFcnJvcignQWdlbnQgbm90IGZvdW5kJywgNDA0LCB7IGRpZDgwMDQ6IGlucHV0LmRpZDgwMDQgfSk7XG4gICAgfVxuICAgIC8vIEdldCB2YWxpZGF0aW9uIGNsaWVudFxuICAgIGNvbnN0IHsgZ2V0VmFsaWRhdGlvblJlZ2lzdHJ5Q2xpZW50IH0gPSBhd2FpdCBpbXBvcnQoJy4uLy4uL3NlcnZlci9zaW5nbGV0b25zL3ZhbGlkYXRpb25DbGllbnQnKTtcbiAgICBjb25zdCB2YWxpZGF0aW9uQ2xpZW50ID0gYXdhaXQgZ2V0VmFsaWRhdGlvblJlZ2lzdHJ5Q2xpZW50KHBhcnNlZC5jaGFpbklkKTtcbiAgICBpZiAoIWlucHV0LnZhbGlkYXRvckFkZHJlc3M/LnRyaW0oKSkge1xuICAgICAgICB0aHJvdyBuZXcgQWdlbnRBcGlFcnJvcigndmFsaWRhdG9yQWRkcmVzcyBwYXJhbWV0ZXIgaXMgcmVxdWlyZWQnLCA0MDApO1xuICAgIH1cbiAgICBjb25zdCB2YWxpZGF0b3JBZGRyZXNzID0gaW5wdXQudmFsaWRhdG9yQWRkcmVzcztcbiAgICAvLyBQcmVwYXJlIHRoZSB2YWxpZGF0aW9uIHJlcXVlc3QgdHJhbnNhY3Rpb25cbiAgICAvLyBUeXBlIGFzc2VydGlvbiBuZWVkZWQgYmVjYXVzZSBUeXBlU2NyaXB0IG1heSBub3Qgc2VlIHRoZSBtZXRob2Qgb24gdGhlIGJhc2UgY2xhc3MgdHlwZVxuICAgIGNvbnN0IHsgdHhSZXF1ZXN0LCByZXF1ZXN0SGFzaCB9ID0gYXdhaXQgdmFsaWRhdGlvbkNsaWVudC5wcmVwYXJlVmFsaWRhdGlvblJlcXVlc3RUeCh7XG4gICAgICAgIGFnZW50SWQ6IHBhcnNlZC5hZ2VudElkLCAvLyBhZ2VudElkIHJlcXVlc3RpbmcgdmFsaWRhdGlvbiAodGhlIGFnZW50IGJlaW5nIHZhbGlkYXRlZClcbiAgICAgICAgdmFsaWRhdG9yQWRkcmVzcywgLy8gdmFsaWRhdG9yQWRkcmVzcyB0aGF0IHBlcmZvcm1zIHRoZSB2YWxpZGF0aW9uICh0aGUgdmFsaWRhdG9yKVxuICAgICAgICByZXF1ZXN0VXJpOiBpbnB1dC5yZXF1ZXN0VXJpLCAvLyBVUkkgb2YgdGhlIHJlcXVlc3QgKGUuZy4gaHR0cHM6Ly9hZ2VudGljLXRydXN0Lm9yZy92YWxpZGF0aW9uLzEpXG4gICAgICAgIHJlcXVlc3RIYXNoOiBpbnB1dC5yZXF1ZXN0SGFzaCwgLy8gaGFzaCBvZiB0aGUgcmVxdWVzdCAoZS5nLiBrZWNjYWsyNTYgb2YgdGhlIHJlcXVlc3RVcmkpXG4gICAgfSk7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgZXhpc3RpbmcgPSBhd2FpdCB2YWxpZGF0aW9uQ2xpZW50LmdldFZhbGlkYXRpb25TdGF0dXMocmVxdWVzdEhhc2gpO1xuICAgICAgICBjb25zdCBleGlzdGluZ1ZhbGlkYXRvciA9IGV4aXN0aW5nPy52YWxpZGF0b3JBZGRyZXNzPy50b0xvd2VyQ2FzZT8uKCk7XG4gICAgICAgIGlmIChleGlzdGluZ1ZhbGlkYXRvciAmJiBleGlzdGluZ1ZhbGlkYXRvciAhPT0gemVyb0FkZHJlc3MgJiYgZXhpc3RpbmdWYWxpZGF0b3IgIT09IHplcm9BZGRyZXNzLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBZ2VudEFwaUVycm9yKGV4aXN0aW5nVmFsaWRhdG9yID09PSB2YWxpZGF0b3JBZGRyZXNzLnRvTG93ZXJDYXNlKClcbiAgICAgICAgICAgICAgICA/ICdWYWxpZGF0aW9uIHJlcXVlc3QgYWxyZWFkeSBleGlzdHMgZm9yIHRoaXMgYWdlbnQgYW5kIHZhbGlkYXRvci4gQXdhaXQgdGhlIGV4aXN0aW5nIHJlcXVlc3QgdG8gYmUgcHJvY2Vzc2VkIGJlZm9yZSBzdWJtaXR0aW5nIGFub3RoZXIuJ1xuICAgICAgICAgICAgICAgIDogJ1ZhbGlkYXRpb24gcmVxdWVzdCB3aXRoIHRoaXMgcmVxdWVzdCBoYXNoIGFscmVhZHkgZXhpc3RzIGZvciBhIGRpZmZlcmVudCB2YWxpZGF0b3IuIFByb3ZpZGUgYSB1bmlxdWUgcmVxdWVzdFVyaS9yZXF1ZXN0SGFzaCBiZWZvcmUgcmV0cnlpbmcuJywgNDA5LCB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdEhhc2gsXG4gICAgICAgICAgICAgICAgZXhpc3RpbmdWYWxpZGF0b3I6IGV4aXN0aW5nLnZhbGlkYXRvckFkZHJlc3MsXG4gICAgICAgICAgICAgICAgZXhpc3RpbmdBZ2VudElkOiBleGlzdGluZy5hZ2VudElkPy50b1N0cmluZz8uKCksXG4gICAgICAgICAgICAgICAgcmVzcG9uc2U6IGV4aXN0aW5nLnJlc3BvbnNlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEFnZW50QXBpRXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIC8vIElnbm9yZSByZWFkIGVycm9ycyAoc29tZSBjaGFpbnMgbWF5IG5vdCBzdXBwb3J0IHRoZSBjYWxsIHlldCwgb3IgcmVxdWVzdEhhc2ggbWF5IG5vdCBleGlzdCB5ZXQpXG4gICAgICAgIGNvbnN0IGVyciA9IGVycm9yO1xuICAgICAgICBjb25zdCBzaG9ydCA9IGVycj8uc2hvcnRNZXNzYWdlIHx8XG4gICAgICAgICAgICBlcnI/LmNhdXNlPy5zaG9ydE1lc3NhZ2UgfHxcbiAgICAgICAgICAgIGVycj8uY2F1c2U/LnJlYXNvbiB8fFxuICAgICAgICAgICAgZXJyPy5yZWFzb24gfHxcbiAgICAgICAgICAgIGVycj8ubWVzc2FnZSB8fFxuICAgICAgICAgICAgJ1Vua25vd24gZXJyb3InO1xuICAgICAgICBjb25zdCBuYW1lID0gU3RyaW5nKGVycj8ubmFtZSB8fCBlcnI/LmNhdXNlPy5uYW1lIHx8ICcnKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBjb25zdCBtc2cgPSBTdHJpbmcoc2hvcnQpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGNvbnN0IGxvb2tzTGlrZVJldmVydCA9IG5hbWUuaW5jbHVkZXMoJ2NvbnRyYWN0ZnVuY3Rpb25leGVjdXRpb25lcnJvcicpIHx8XG4gICAgICAgICAgICBuYW1lLmluY2x1ZGVzKCdjb250cmFjdGZ1bmN0aW9ucmV2ZXJ0ZWRlcnJvcicpIHx8XG4gICAgICAgICAgICBtc2cuaW5jbHVkZXMoJ3JldmVydCcpIHx8XG4gICAgICAgICAgICBtc2cuaW5jbHVkZXMoJ3JldmVydGVkJyk7XG4gICAgICAgIC8vIFJldmVydHMgYXJlIGV4cGVjdGVkIHdoZW4gdGhlcmUgaXMgbm8gcHJpb3IgdmFsaWRhdGlvbiByZXF1ZXN0IGZvciB0aGlzIGhhc2guXG4gICAgICAgIGlmICghbG9va3NMaWtlUmV2ZXJ0KSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYFtwcmVwYXJlVmFsaWRhdGlvblJlcXVlc3RDb3JlXSBVbmFibGUgdG8gY2hlY2sgZXhpc3RpbmcgdmFsaWRhdGlvbiBzdGF0dXMgZm9yIHJlcXVlc3RIYXNoPSR7cmVxdWVzdEhhc2h9OiAke3Nob3J0fWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEVPQSBtb2RlOiByZXR1cm4gYSBkaXJlY3QgdHJhbnNhY3Rpb24gcGF5bG9hZCAobm8gYnVuZGxlciAvIEFBKS5cbiAgICBpZiAobW9kZSA9PT0gJ2VvYScpIHtcbiAgICAgICAgY29uc3QgdHhQYXlsb2FkID0ge1xuICAgICAgICAgICAgdG86IHR4UmVxdWVzdC50byxcbiAgICAgICAgICAgIGRhdGE6IHR4UmVxdWVzdC5kYXRhLFxuICAgICAgICAgICAgdmFsdWU6IG5vcm1hbGl6ZUNhbGxWYWx1ZSh0eFJlcXVlc3QudmFsdWUpLFxuICAgICAgICAgICAgY2hhaW5JZDogcGFyc2VkLmNoYWluSWQsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICAgICAgb3BlcmF0aW9uOiAndXBkYXRlJyxcbiAgICAgICAgICAgIG1vZGU6ICdlb2EnLFxuICAgICAgICAgICAgY2hhaW5JZDogcGFyc2VkLmNoYWluSWQsXG4gICAgICAgICAgICBjYWxsczogW10sXG4gICAgICAgICAgICB0cmFuc2FjdGlvbjogdHhQYXlsb2FkLFxuICAgICAgICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgICAgICAgICB2YWxpZGF0b3JBZGRyZXNzLFxuICAgICAgICAgICAgICAgIHJlcXVlc3RIYXNoLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gU21hcnRBY2NvdW50IG1vZGU6IHJldHVybiBjYWxscyArIGJ1bmRsZXJVcmwgZm9yIGEgc3BvbnNvcmVkIFVzZXJPcC5cbiAgICBjb25zdCBidW5kbGVyVXJsID0gZ2V0Q2hhaW5CdW5kbGVyVXJsKHBhcnNlZC5jaGFpbklkKTtcbiAgICBpZiAoIWJ1bmRsZXJVcmwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEFnZW50QXBpRXJyb3IoYEJ1bmRsZXIgVVJMIG5vdCBjb25maWd1cmVkIGZvciBjaGFpbiAke3BhcnNlZC5jaGFpbklkfWAsIDUwMCk7XG4gICAgfVxuICAgIGNvbnN0IGNhbGwgPSB7XG4gICAgICAgIHRvOiB0eFJlcXVlc3QudG8sXG4gICAgICAgIGRhdGE6IHR4UmVxdWVzdC5kYXRhLFxuICAgICAgICB2YWx1ZTogbm9ybWFsaXplQ2FsbFZhbHVlKHR4UmVxdWVzdC52YWx1ZSksXG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICBvcGVyYXRpb246ICd1cGRhdGUnLFxuICAgICAgICBtb2RlOiAnc21hcnRBY2NvdW50JyxcbiAgICAgICAgY2hhaW5JZDogcGFyc2VkLmNoYWluSWQsXG4gICAgICAgIGJ1bmRsZXJVcmwsXG4gICAgICAgIGNhbGxzOiBbY2FsbF0sXG4gICAgICAgIHRyYW5zYWN0aW9uOiB1bmRlZmluZWQsXG4gICAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgICAgICB2YWxpZGF0b3JBZGRyZXNzLFxuICAgICAgICAgICAgcmVxdWVzdEhhc2gsXG4gICAgICAgIH0sXG4gICAgfTtcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwcmVwYXJlQXNzb2NpYXRpb25SZXF1ZXN0Q29yZShjdHgsIGlucHV0KSB7XG4gICAgaWYgKCFpbnB1dC5kaWQ4MDA0Py50cmltKCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEFnZW50QXBpRXJyb3IoJ2RpZDgwMDQgcGFyYW1ldGVyIGlzIHJlcXVpcmVkJywgNDAwKTtcbiAgICB9XG4gICAgY29uc3QgbW9kZSA9IGlucHV0Lm1vZGUgPz8gJ3NtYXJ0QWNjb3VudCc7XG4gICAgaWYgKG1vZGUgIT09ICdzbWFydEFjY291bnQnICYmIG1vZGUgIT09ICdlb2EnKSB7XG4gICAgICAgIHRocm93IG5ldyBBZ2VudEFwaUVycm9yKGBJbnZhbGlkIG1vZGUgXCIke1N0cmluZyhtb2RlKX1cImAsIDQwMCk7XG4gICAgfVxuICAgIGNvbnN0IHBhcnNlZCA9ICgoKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VEaWQ4MDA0KGlucHV0LmRpZDgwMDQpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFnZW50QXBpRXJyb3IoYEludmFsaWQgZGlkOjgwMDQgaWRlbnRpZmllcjogJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdVbmtub3duIGVycm9yJ31gLCA0MDApO1xuICAgICAgICB9XG4gICAgfSkoKTtcbiAgICBjb25zdCBjbGllbnQgPSBhd2FpdCByZXNvbHZlQ2xpZW50KGN0eCk7XG4gICAgY29uc3QgYWdlbnQgPSBhd2FpdCBjbGllbnQuZ2V0QWdlbnQocGFyc2VkLmFnZW50SWQudG9TdHJpbmcoKSwgcGFyc2VkLmNoYWluSWQpO1xuICAgIGlmICghYWdlbnQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEFnZW50QXBpRXJyb3IoJ0FnZW50IG5vdCBmb3VuZCcsIDQwNCwgeyBkaWQ4MDA0OiBpbnB1dC5kaWQ4MDA0IH0pO1xuICAgIH1cbiAgICBpZiAoIWFnZW50LmFnZW50QWNjb3VudCAmJiAhaW5wdXQuaW5pdGlhdG9yQWRkcmVzcykge1xuICAgICAgICB0aHJvdyBuZXcgQWdlbnRBcGlFcnJvcignQWdlbnQgbXVzdCBoYXZlIGFuIGFnZW50QWNjb3VudCBhZGRyZXNzJywgNDAwKTtcbiAgICB9XG4gICAgLy8gVmFsaWRhdGUgYXBwcm92ZXIgYWRkcmVzc1xuICAgIGlmICghaW5wdXQuYXBwcm92ZXJBZGRyZXNzPy50cmltKCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEFnZW50QXBpRXJyb3IoJ2FwcHJvdmVyQWRkcmVzcyBwYXJhbWV0ZXIgaXMgcmVxdWlyZWQnLCA0MDApO1xuICAgIH1cbiAgICBjb25zdCBBRERSRVNTX1JFR0VYID0gL14weFthLWZBLUYwLTldezQwfSQvO1xuICAgIGlmICghQUREUkVTU19SRUdFWC50ZXN0KGlucHV0LmFwcHJvdmVyQWRkcmVzcykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEFnZW50QXBpRXJyb3IoJ2FwcHJvdmVyQWRkcmVzcyBtdXN0IGJlIGEgdmFsaWQgRXRoZXJldW0gYWRkcmVzcyAoMHguLi4pJywgNDAwKTtcbiAgICB9XG4gICAgY29uc3QgaW5pdGlhdG9yQWRkcmVzcyA9IChpbnB1dC5pbml0aWF0b3JBZGRyZXNzID8/IGFnZW50LmFnZW50QWNjb3VudCk7XG4gICAgY29uc3QgYXBwcm92ZXJBZGRyZXNzID0gaW5wdXQuYXBwcm92ZXJBZGRyZXNzO1xuICAgIC8vIEdldCBhc3NvY2lhdGlvbnMgY2xpZW50XG4gICAgY29uc3QgeyBnZXRBc3NvY2lhdGlvbnNDbGllbnQgfSA9IGF3YWl0IGltcG9ydCgnLi4vLi4vc2VydmVyL3NpbmdsZXRvbnMvYXNzb2NpYXRpb25DbGllbnQnKTtcbiAgICBjb25zdCBhc3NvY2lhdGlvbnNDbGllbnQgPSBhd2FpdCBnZXRBc3NvY2lhdGlvbnNDbGllbnQocGFyc2VkLmNoYWluSWQpO1xuICAgIC8vIEVuY29kZSBhc3NvY2lhdGlvbiBtZXRhZGF0YSBpZiBwcm92aWRlZFxuICAgIGNvbnN0IHsgZW5jb2RlQXNzb2NpYXRpb25EYXRhIH0gPSBhd2FpdCBpbXBvcnQoJy4uLy4uL3NlcnZlci9saWIvYXNzb2NpYXRpb24nKTtcbiAgICBsZXQgYXNzb2NpYXRpb25EYXRhID0gaW5wdXQuZGF0YSA/PyAnMHgnO1xuICAgIGlmICghaW5wdXQuZGF0YSAmJiBpbnB1dC5hc3NvY1R5cGUgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgaW5wdXQuZGVzY3JpcHRpb24gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGFzc29jaWF0aW9uRGF0YSA9IGVuY29kZUFzc29jaWF0aW9uRGF0YSh7XG4gICAgICAgICAgICBhc3NvY1R5cGU6IGlucHV0LmFzc29jVHlwZSxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBpbnB1dC5kZXNjcmlwdGlvbiA/PyAnJyxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIEJ1aWxkIHRoZSBzaWduZWQgYXNzb2NpYXRpb24gcmVjb3JkXG4gICAgLy8gTm90ZTogRm9yIHNtYXJ0IGFjY291bnRzLCBzaWduYXR1cmVzIGFyZSBoYW5kbGVkIHZpYSBFUkMtMTI3MVxuICAgIC8vIFRoZSB0cmFuc2FjdGlvbiB3aWxsIGJlIHNpZ25lZCBjbGllbnQtc2lkZSB1c2luZyB0aGUgYWNjb3VudCBhYnN0cmFjdGlvblxuICAgIC8vIFdlIGNyZWF0ZSB0aGUgcmVjb3JkIHN0cnVjdHVyZSBoZXJlLCBidXQgdGhlIGFjdHVhbCBzaWduYXR1cmUgaGFwcGVucyBkdXJpbmcgZXhlY3V0aW9uXG4gICAgY29uc3Qgbm93ID0gdHlwZW9mIGlucHV0LnZhbGlkQXQgPT09ICdudW1iZXInID8gaW5wdXQudmFsaWRBdCA6IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDEwMDApO1xuICAgIC8vIGZvcm1hdEV2bVYxOiBDcmVhdGUgRVJDLTc5MzAgaW50ZXJvcGVyYWJsZSBhZGRyZXNzIGZvcm1hdCB1c2luZyBldGhlcnNcbiAgICAvLyBGb3JtYXQ6IDB4MDAwMTAwMDAgfHwgdWludDgoY2hhaW5SZWYubGVuZ3RoKSB8fCBjaGFpblJlZiB8fCB1aW50OCgyMCkgfHwgYWRkcmVzc1xuICAgIGNvbnN0IHsgZXRoZXJzIH0gPSBhd2FpdCBpbXBvcnQoJ2V0aGVycycpO1xuICAgIGNvbnN0IHRvTWluaW1hbEJpZ0VuZGlhbkJ5dGVzID0gKG4pID0+IHtcbiAgICAgICAgaWYgKG4gPT09IDBuKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFswXSk7XG4gICAgICAgIGxldCBoZXggPSBuLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgaWYgKGhleC5sZW5ndGggJSAyKVxuICAgICAgICAgICAgaGV4ID0gYDAke2hleH1gO1xuICAgICAgICByZXR1cm4gZXRoZXJzLmdldEJ5dGVzKGAweCR7aGV4fWApO1xuICAgIH07XG4gICAgY29uc3QgZm9ybWF0RXZtVjEgPSAoY2hhaW5JZCwgYWRkcmVzcykgPT4ge1xuICAgICAgICBjb25zdCBhZGRyID0gZXRoZXJzLmdldEFkZHJlc3MoYWRkcmVzcyk7XG4gICAgICAgIGNvbnN0IGNoYWluUmVmID0gdG9NaW5pbWFsQmlnRW5kaWFuQnl0ZXMoQmlnSW50KGNoYWluSWQpKTtcbiAgICAgICAgY29uc3QgaGVhZCA9IGV0aGVycy5nZXRCeXRlcygnMHgwMDAxMDAwMCcpO1xuICAgICAgICBjb25zdCBvdXQgPSBldGhlcnMuY29uY2F0KFtcbiAgICAgICAgICAgIGhlYWQsXG4gICAgICAgICAgICBuZXcgVWludDhBcnJheShbY2hhaW5SZWYubGVuZ3RoXSksXG4gICAgICAgICAgICBjaGFpblJlZixcbiAgICAgICAgICAgIG5ldyBVaW50OEFycmF5KFsyMF0pLFxuICAgICAgICAgICAgZXRoZXJzLmdldEJ5dGVzKGFkZHIpLFxuICAgICAgICBdKTtcbiAgICAgICAgcmV0dXJuIGV0aGVycy5oZXhsaWZ5KG91dCk7XG4gICAgfTtcbiAgICBjb25zdCBpbml0aWF0b3IgPSBmb3JtYXRFdm1WMShwYXJzZWQuY2hhaW5JZCwgaW5pdGlhdG9yQWRkcmVzcyk7XG4gICAgY29uc3QgYXBwcm92ZXIgPSBmb3JtYXRFdm1WMShwYXJzZWQuY2hhaW5JZCwgYXBwcm92ZXJBZGRyZXNzKTtcbiAgICBjb25zdCByZWNvcmQgPSB7XG4gICAgICAgIGluaXRpYXRvcixcbiAgICAgICAgYXBwcm92ZXIsXG4gICAgICAgIHZhbGlkQXQ6IG5vdyxcbiAgICAgICAgdmFsaWRVbnRpbDogMCwgLy8gTm8gZXhwaXJ5IGJ5IGRlZmF1bHRcbiAgICAgICAgaW50ZXJmYWNlSWQ6ICcweDAwMDAwMDAwJyxcbiAgICAgICAgZGF0YTogYXNzb2NpYXRpb25EYXRhLFxuICAgIH07XG4gICAgLy8gQ3JlYXRlIFNpZ25lZEFzc29jaWF0aW9uUmVjb3JkIHdpdGggZW1wdHkgc2lnbmF0dXJlcyAod2lsbCBiZSBzaWduZWQgY2xpZW50LXNpZGUgdmlhIEFBKVxuICAgIGNvbnN0IHNhciA9IHtcbiAgICAgICAgcmV2b2tlZEF0OiAwLFxuICAgICAgICAvLyBJTVBPUlRBTlQ6XG4gICAgICAgIC8vIFVzZSBLMSAoMHgwMDAxKSBzbyB0aGUgRVJDLTgwOTIgcmVmZXJlbmNlIGltcGxlbWVudGF0aW9uIHZhbGlkYXRlcyBzaWduYXR1cmVzIHZpYVxuICAgICAgICAvLyBPcGVuWmVwcGVsaW4gU2lnbmF0dXJlQ2hlY2tlciwgd2hpY2ggc3VwcG9ydHMgYm90aCBFT0FzIGFuZCBzdGFuZGFyZCBFUkMtMTI3MSBzbWFydCBhY2NvdW50cy5cbiAgICAgICAgLy8gVGhlIEVSQy04MDkyIFBPQydzIEVSQzEyNzEga2V5dHlwZSB1c2VzIGEgYm9vbC1yZXR1cm5pbmcgSUVSQzEyNzEgaW50ZXJmYWNlLCB3aGljaCBpcyBub3RcbiAgICAgICAgLy8gY29tcGF0aWJsZSB3aXRoIHRoZSB3aWRlbHktdXNlZCBieXRlczQtbWFnaWMgRVJDLTEyNzEgaW1wbGVtZW50YXRpb25zLlxuICAgICAgICBpbml0aWF0b3JLZXlUeXBlOiAnMHgwMDAxJywgLy8gSzEgLyBFQ0RTQSBzZWNwMjU2azFcbiAgICAgICAgYXBwcm92ZXJLZXlUeXBlOiAnMHgwMDAxJywgLy8gSzEgLyBFQ0RTQSBzZWNwMjU2azFcbiAgICAgICAgaW5pdGlhdG9yU2lnbmF0dXJlOiBpbnB1dC5pbml0aWF0b3JTaWduYXR1cmUgPz8gJzB4JyxcbiAgICAgICAgYXBwcm92ZXJTaWduYXR1cmU6IGlucHV0LmFwcHJvdmVyU2lnbmF0dXJlID8/ICcweCcsXG4gICAgICAgIHJlY29yZCxcbiAgICB9O1xuICAgIC8vIFByZXBhcmUgdGhlIHN0b3JlQXNzb2NpYXRpb24gdHJhbnNhY3Rpb25cbiAgICAvLyBUaGUgYXNzb2NpYXRpb24gY2xpZW50IHdpbGwgZW5jb2RlIHRoZSBjYWxsLCBidXQgc2lnbmF0dXJlcyBoYXBwZW4gZHVyaW5nIEFBIGV4ZWN1dGlvblxuICAgIGNvbnN0IHsgdHhSZXF1ZXN0IH0gPSBhd2FpdCBhc3NvY2lhdGlvbnNDbGllbnQucHJlcGFyZVN0b3JlQXNzb2NpYXRpb25UeCh7IHNhciB9KTtcbiAgICAvLyBFT0EgbW9kZTogcmV0dXJuIGEgZGlyZWN0IHRyYW5zYWN0aW9uIHBheWxvYWQgKG5vIGJ1bmRsZXIgLyBBQSkuXG4gICAgaWYgKG1vZGUgPT09ICdlb2EnKSB7XG4gICAgICAgIGNvbnN0IHR4UGF5bG9hZCA9IHtcbiAgICAgICAgICAgIHRvOiB0eFJlcXVlc3QudG8sXG4gICAgICAgICAgICBkYXRhOiB0eFJlcXVlc3QuZGF0YSxcbiAgICAgICAgICAgIHZhbHVlOiBub3JtYWxpemVDYWxsVmFsdWUodHhSZXF1ZXN0LnZhbHVlKSxcbiAgICAgICAgICAgIGNoYWluSWQ6IHBhcnNlZC5jaGFpbklkLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgICAgIG9wZXJhdGlvbjogJ3VwZGF0ZScsXG4gICAgICAgICAgICBtb2RlOiAnZW9hJyxcbiAgICAgICAgICAgIGNoYWluSWQ6IHBhcnNlZC5jaGFpbklkLFxuICAgICAgICAgICAgY2FsbHM6IFtdLFxuICAgICAgICAgICAgdHJhbnNhY3Rpb246IHR4UGF5bG9hZCxcbiAgICAgICAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgICAgICAgICAgaW5pdGlhdG9yQWRkcmVzcyxcbiAgICAgICAgICAgICAgICBhcHByb3ZlckFkZHJlc3MsXG4gICAgICAgICAgICAgICAgYXNzb2NUeXBlOiBpbnB1dC5hc3NvY1R5cGUsXG4gICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IGlucHV0LmRlc2NyaXB0aW9uLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gU21hcnRBY2NvdW50IG1vZGU6IHJldHVybiBjYWxscyArIGJ1bmRsZXJVcmwgZm9yIGEgc3BvbnNvcmVkIFVzZXJPcC5cbiAgICBjb25zdCBidW5kbGVyVXJsID0gZ2V0Q2hhaW5CdW5kbGVyVXJsKHBhcnNlZC5jaGFpbklkKTtcbiAgICBpZiAoIWJ1bmRsZXJVcmwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEFnZW50QXBpRXJyb3IoYEJ1bmRsZXIgVVJMIG5vdCBjb25maWd1cmVkIGZvciBjaGFpbiAke3BhcnNlZC5jaGFpbklkfWAsIDUwMCk7XG4gICAgfVxuICAgIGNvbnN0IGNhbGwgPSB7XG4gICAgICAgIHRvOiB0eFJlcXVlc3QudG8sXG4gICAgICAgIGRhdGE6IHR4UmVxdWVzdC5kYXRhLFxuICAgICAgICB2YWx1ZTogbm9ybWFsaXplQ2FsbFZhbHVlKHR4UmVxdWVzdC52YWx1ZSksXG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICBvcGVyYXRpb246ICd1cGRhdGUnLFxuICAgICAgICBtb2RlOiAnc21hcnRBY2NvdW50JyxcbiAgICAgICAgY2hhaW5JZDogcGFyc2VkLmNoYWluSWQsXG4gICAgICAgIGJ1bmRsZXJVcmwsXG4gICAgICAgIGNhbGxzOiBbY2FsbF0sXG4gICAgICAgIHRyYW5zYWN0aW9uOiB1bmRlZmluZWQsXG4gICAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgICAgICBpbml0aWF0b3JBZGRyZXNzLFxuICAgICAgICAgICAgYXBwcm92ZXJBZGRyZXNzLFxuICAgICAgICAgICAgYXNzb2NUeXBlOiBpbnB1dC5hc3NvY1R5cGUsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogaW5wdXQuZGVzY3JpcHRpb24sXG4gICAgICAgIH0sXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGpzb25TYWZlRGVlcCh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdiaWdpbnQnKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLm1hcCgoaXRlbSkgPT4ganNvblNhZmVEZWVwKGl0ZW0pKTtcbiAgICB9XG4gICAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdl0gb2YgT2JqZWN0LmVudHJpZXModmFsdWUpKSB7XG4gICAgICAgICAgICByZXN1bHRba2V5XSA9IGpzb25TYWZlRGVlcCh2KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0RmVlZGJhY2tDb3JlKGN0eCwgaW5wdXQpIHtcbiAgICBpZiAoIWlucHV0LmRpZDgwMDQ/LnRyaW0oKSkge1xuICAgICAgICB0aHJvdyBuZXcgQWdlbnRBcGlFcnJvcignZGlkODAwNCBwYXJhbWV0ZXIgaXMgcmVxdWlyZWQnLCA0MDApO1xuICAgIH1cbiAgICBjb25zdCBwYXJzZWQgPSAoKCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlRGlkODAwNChpbnB1dC5kaWQ4MDA0KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBZ2VudEFwaUVycm9yKGBJbnZhbGlkIGRpZDo4MDA0IGlkZW50aWZpZXI6ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvcid9YCwgNDAwKTtcbiAgICAgICAgfVxuICAgIH0pKCk7XG4gICAgY29uc3QgaW5jbHVkZVJldm9rZWQgPSAhIWlucHV0LmluY2x1ZGVSZXZva2VkO1xuICAgIGNvbnN0IGxpbWl0ID0gdHlwZW9mIGlucHV0LmxpbWl0ID09PSAnbnVtYmVyJyAmJiBOdW1iZXIuaXNGaW5pdGUoaW5wdXQubGltaXQpXG4gICAgICAgID8gaW5wdXQubGltaXRcbiAgICAgICAgOiAxMDA7XG4gICAgY29uc3Qgb2Zmc2V0ID0gdHlwZW9mIGlucHV0Lm9mZnNldCA9PT0gJ251bWJlcicgJiYgTnVtYmVyLmlzRmluaXRlKGlucHV0Lm9mZnNldClcbiAgICAgICAgPyBpbnB1dC5vZmZzZXRcbiAgICAgICAgOiAwO1xuICAgIGNvbnN0IGNsaWVudCA9IGF3YWl0IHJlc29sdmVDbGllbnQoY3R4KTtcbiAgICBjb25zdCBbZmVlZGJhY2ssIHN1bW1hcnldID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICBjbGllbnQuZ2V0QWdlbnRGZWVkYmFjayh7XG4gICAgICAgICAgICBhZ2VudElkOiBwYXJzZWQuYWdlbnRJZCxcbiAgICAgICAgICAgIGNoYWluSWQ6IHBhcnNlZC5jaGFpbklkLFxuICAgICAgICAgICAgaW5jbHVkZVJldm9rZWQsXG4gICAgICAgICAgICBsaW1pdCxcbiAgICAgICAgICAgIG9mZnNldCxcbiAgICAgICAgfSksXG4gICAgICAgIGNsaWVudFxuICAgICAgICAgICAgLmdldFJlcHV0YXRpb25TdW1tYXJ5KHtcbiAgICAgICAgICAgIGFnZW50SWQ6IHBhcnNlZC5hZ2VudElkLFxuICAgICAgICAgICAgY2hhaW5JZDogcGFyc2VkLmNoYWluSWQsXG4gICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAvLyBQcmVzZXJ2ZSBwcmV2aW91cyBiZWhhdmlvcjogbG9nIGFuZCByZXR1cm4gbnVsbCBvbiBzdW1tYXJ5IGZhaWx1cmVcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ1tBZ2VudGljVHJ1c3RdW0NvcmVdIGdldFJlcHV0YXRpb25TdW1tYXJ5IGZhaWxlZDonLCBlcnJvcik7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSksXG4gICAgXSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZmVlZGJhY2s6IGpzb25TYWZlRGVlcChmZWVkYmFjayksXG4gICAgICAgIHN1bW1hcnk6IGpzb25TYWZlRGVlcChzdW1tYXJ5KSxcbiAgICB9O1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHN1Ym1pdEZlZWRiYWNrRGlyZWN0Q29yZShjdHgsIGlucHV0KSB7XG4gICAgY29uc3QgY2xpZW50ID0gYXdhaXQgcmVzb2x2ZUNsaWVudChjdHgpO1xuICAgIGxldCBhZ2VudElkID0gdHlwZW9mIGlucHV0LmFnZW50SWQgPT09ICdudW1iZXInXG4gICAgICAgID8gaW5wdXQuYWdlbnRJZC50b1N0cmluZygpXG4gICAgICAgIDogaW5wdXQuYWdlbnRJZD8udG9TdHJpbmcoKTtcbiAgICBsZXQgY2hhaW5JZCA9IHR5cGVvZiBpbnB1dC5jaGFpbklkID09PSAnbnVtYmVyJyAmJiBOdW1iZXIuaXNGaW5pdGUoaW5wdXQuY2hhaW5JZClcbiAgICAgICAgPyBpbnB1dC5jaGFpbklkXG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgIGlmIChpbnB1dC5kaWQ4MDA0ICYmIGlucHV0LmRpZDgwMDQudHJpbSgpKSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZCA9ICgoKSA9PiB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZURpZDgwMDQoaW5wdXQuZGlkODAwNCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQWdlbnRBcGlFcnJvcihgSW52YWxpZCBkaWQ6ODAwNCBpZGVudGlmaWVyOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InfWAsIDQwMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKCk7XG4gICAgICAgIGFnZW50SWQgPSBwYXJzZWQuYWdlbnRJZC50b1N0cmluZygpO1xuICAgICAgICBjaGFpbklkID0gcGFyc2VkLmNoYWluSWQ7XG4gICAgfVxuICAgIGlmICghYWdlbnRJZCkge1xuICAgICAgICB0aHJvdyBuZXcgQWdlbnRBcGlFcnJvcignYWdlbnRJZCBvciBkaWQ4MDA0IGlzIHJlcXVpcmVkJywgNDAwKTtcbiAgICB9XG4gICAgY29uc3QgcmVzb2x2ZWRDaGFpbklkID0gdHlwZW9mIGNoYWluSWQgPT09ICdudW1iZXInICYmIE51bWJlci5pc0Zpbml0ZShjaGFpbklkKVxuICAgICAgICA/IGNoYWluSWRcbiAgICAgICAgOiBERUZBVUxUX0NIQUlOX0lEO1xuICAgIGNvbnN0IGFnZW50ID0gYXdhaXQgY2xpZW50LmdldEFnZW50KGFnZW50SWQudG9TdHJpbmcoKSwgcmVzb2x2ZWRDaGFpbklkKTtcbiAgICBpZiAoIWFnZW50KSB7XG4gICAgICAgIHRocm93IG5ldyBBZ2VudEFwaUVycm9yKCdBZ2VudCBub3QgZm91bmQnLCA0MDQsIHtcbiAgICAgICAgICAgIGFnZW50SWQsXG4gICAgICAgICAgICBjaGFpbklkOiByZXNvbHZlZENoYWluSWQsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBudW1lcmljU2NvcmUgPSB0eXBlb2YgaW5wdXQuc2NvcmUgPT09ICdudW1iZXInXG4gICAgICAgID8gaW5wdXQuc2NvcmVcbiAgICAgICAgOiBOdW1iZXIucGFyc2VJbnQoaW5wdXQuc2NvcmUsIDEwKTtcbiAgICBpZiAoIU51bWJlci5pc0Zpbml0ZShudW1lcmljU2NvcmUpKSB7XG4gICAgICAgIHRocm93IG5ldyBBZ2VudEFwaUVycm9yKCdJbnZhbGlkIHNjb3JlIHZhbHVlJywgNDAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgZmVlZGJhY2tSZXN1bHQgPSBhd2FpdCBhZ2VudC5naXZlRmVlZGJhY2soe1xuICAgICAgICAgICAgLi4uKGlucHV0LmNsaWVudEFkZHJlc3MgJiYge1xuICAgICAgICAgICAgICAgIGNsaWVudEFkZHJlc3M6IGlucHV0LmNsaWVudEFkZHJlc3MsXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHNjb3JlOiBudW1lcmljU2NvcmUsXG4gICAgICAgICAgICBmZWVkYmFjazogaW5wdXQuZmVlZGJhY2sgJiYgaW5wdXQuZmVlZGJhY2subGVuZ3RoID4gMFxuICAgICAgICAgICAgICAgID8gaW5wdXQuZmVlZGJhY2tcbiAgICAgICAgICAgICAgICA6ICdGZWVkYmFjayBzdWJtaXR0ZWQgdmlhIGRpcmVjdCBlbmRwb2ludCcsXG4gICAgICAgICAgICBmZWVkYmFja0F1dGg6IGlucHV0LmZlZWRiYWNrQXV0aCxcbiAgICAgICAgICAgIHRhZzE6IGlucHV0LnRhZzEsXG4gICAgICAgICAgICB0YWcyOiBpbnB1dC50YWcyLFxuICAgICAgICAgICAgZmVlZGJhY2tVcmk6IGlucHV0LmZlZWRiYWNrVXJpLFxuICAgICAgICAgICAgZmVlZGJhY2tIYXNoOiBpbnB1dC5mZWVkYmFja0hhc2gsXG4gICAgICAgICAgICBza2lsbDogaW5wdXQuc2tpbGwsXG4gICAgICAgICAgICBjb250ZXh0OiBpbnB1dC5jb250ZXh0LFxuICAgICAgICAgICAgY2FwYWJpbGl0eTogaW5wdXQuY2FwYWJpbGl0eSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICAgICAgdHhIYXNoOiBmZWVkYmFja1Jlc3VsdC50eEhhc2gsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICB0aHJvdyBuZXcgQWdlbnRBcGlFcnJvcihlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdGYWlsZWQgdG8gc3VibWl0IGZlZWRiYWNrJywgNTAyLCB7XG4gICAgICAgICAgICBhZ2VudElkLFxuICAgICAgICAgICAgY2hhaW5JZDogcmVzb2x2ZWRDaGFpbklkLFxuICAgICAgICB9KTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb3JlLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@agentic-trust/core/dist/api/agents/core.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@agentic-trust/core/dist/api/agents/directClient.js":
/*!******************************************************************************!*\
  !*** ../../node_modules/@agentic-trust/core/dist/api/agents/directClient.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createAgentDirect: () => (/* binding */ createAgentDirect)\n/* harmony export */ });\nconst DEFAULT_BASE_PATH = '/api/agents';\nfunction getFetch(config) {\n    if (config?.fetch)\n        return config.fetch;\n    if (typeof fetch !== 'undefined')\n        return fetch;\n    throw new Error('Global fetch is not available. Provide a custom fetch implementation via config.fetch.');\n}\nfunction getBasePath(config) {\n    return config?.basePath ?? DEFAULT_BASE_PATH;\n}\nasync function createAgentDirect(input, config) {\n    const fetchImpl = getFetch(config);\n    const basePath = getBasePath(config);\n    const response = await fetchImpl(`${basePath}/create-direct`, {\n        method: 'POST',\n        headers: {\n            'Content-Type': 'application/json',\n        },\n        body: JSON.stringify(input),\n    });\n    const body = await response.json().catch(() => ({}));\n    if (!response.ok) {\n        const message = body?.message || body?.error || 'Failed to create agent (direct)';\n        throw new Error(message);\n    }\n    return body;\n}\n//# sourceMappingURL=directClient.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BhZ2VudGljLXRydXN0L2NvcmUvZGlzdC9hcGkvYWdlbnRzL2RpcmVjdENsaWVudC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLHdDQUF3QyxTQUFTO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTCxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL2JhcmIvYWEvQXNzb2NpYXRlZEFjY291bnRzL25vZGVfbW9kdWxlcy9AYWdlbnRpYy10cnVzdC9jb3JlL2Rpc3QvYXBpL2FnZW50cy9kaXJlY3RDbGllbnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgREVGQVVMVF9CQVNFX1BBVEggPSAnL2FwaS9hZ2VudHMnO1xuZnVuY3Rpb24gZ2V0RmV0Y2goY29uZmlnKSB7XG4gICAgaWYgKGNvbmZpZz8uZmV0Y2gpXG4gICAgICAgIHJldHVybiBjb25maWcuZmV0Y2g7XG4gICAgaWYgKHR5cGVvZiBmZXRjaCAhPT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgIHJldHVybiBmZXRjaDtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0dsb2JhbCBmZXRjaCBpcyBub3QgYXZhaWxhYmxlLiBQcm92aWRlIGEgY3VzdG9tIGZldGNoIGltcGxlbWVudGF0aW9uIHZpYSBjb25maWcuZmV0Y2guJyk7XG59XG5mdW5jdGlvbiBnZXRCYXNlUGF0aChjb25maWcpIHtcbiAgICByZXR1cm4gY29uZmlnPy5iYXNlUGF0aCA/PyBERUZBVUxUX0JBU0VfUEFUSDtcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjcmVhdGVBZ2VudERpcmVjdChpbnB1dCwgY29uZmlnKSB7XG4gICAgY29uc3QgZmV0Y2hJbXBsID0gZ2V0RmV0Y2goY29uZmlnKTtcbiAgICBjb25zdCBiYXNlUGF0aCA9IGdldEJhc2VQYXRoKGNvbmZpZyk7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaEltcGwoYCR7YmFzZVBhdGh9L2NyZWF0ZS1kaXJlY3RgLCB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShpbnB1dCksXG4gICAgfSk7XG4gICAgY29uc3QgYm9keSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKS5jYXRjaCgoKSA9PiAoe30pKTtcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBib2R5Py5tZXNzYWdlIHx8IGJvZHk/LmVycm9yIHx8ICdGYWlsZWQgdG8gY3JlYXRlIGFnZW50IChkaXJlY3QpJztcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIH1cbiAgICByZXR1cm4gYm9keTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRpcmVjdENsaWVudC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@agentic-trust/core/dist/api/agents/directClient.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@agentic-trust/core/dist/api/agents/directExpress.js":
/*!*******************************************************************************!*\
  !*** ../../node_modules/@agentic-trust/core/dist/api/agents/directExpress.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createAgentDirectExpressHandler: () => (/* binding */ createAgentDirectExpressHandler)\n/* harmony export */ });\n/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/api/agents/core.js\");\n/* harmony import */ var _directServer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./directServer */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/api/agents/directServer.js\");\n\n\nconst defaultContextFactory = () => ({});\nfunction sendJson(res, status, payload) {\n    res.status(status).json(payload);\n}\nfunction handleExpressError(res, error) {\n    if (error instanceof _core__WEBPACK_IMPORTED_MODULE_0__.AgentApiError) {\n        sendJson(res, error.status ?? 400, {\n            error: error.message,\n            details: error.details,\n        });\n        return;\n    }\n    console.error('[AgenticTrust][Express][Direct] Unexpected error:', error);\n    sendJson(res, 500, {\n        error: 'Internal server error',\n        message: error instanceof Error ? error.message : 'Unknown error',\n    });\n}\nfunction assertMode(mode) {\n    return mode === 'smartAccount' || mode === 'eoa';\n}\nfunction createAgentDirectExpressHandler(defaultMode, getContext = defaultContextFactory) {\n    return async (req, res) => {\n        try {\n            const ctx = getContext(req);\n            const body = (req.body ?? {});\n            const modeFromBody = typeof body.mode === 'string' ? body.mode : undefined;\n            const modeToUse = modeFromBody ?? defaultMode;\n            if (!assertMode(modeToUse)) {\n                throw new _core__WEBPACK_IMPORTED_MODULE_0__.AgentApiError('mode must be either \"smartAccount\" or \"eoa\"', 400);\n            }\n            const result = await (0,_directServer__WEBPACK_IMPORTED_MODULE_1__.createAgentDirectCore)(ctx, {\n                ...body,\n                mode: modeToUse,\n            });\n            sendJson(res, 200, result);\n        }\n        catch (error) {\n            handleExpressError(res, error);\n        }\n    };\n}\n//# sourceMappingURL=directExpress.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BhZ2VudGljLXRydXN0L2NvcmUvZGlzdC9hcGkvYWdlbnRzL2RpcmVjdEV4cHJlc3MuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQXVDO0FBQ2lCO0FBQ3hELHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixnREFBYTtBQUN0QztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGdEQUFhO0FBQ3ZDO0FBQ0EsaUNBQWlDLG9FQUFxQjtBQUN0RDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL2JhcmIvYWEvQXNzb2NpYXRlZEFjY291bnRzL25vZGVfbW9kdWxlcy9AYWdlbnRpYy10cnVzdC9jb3JlL2Rpc3QvYXBpL2FnZW50cy9kaXJlY3RFeHByZXNzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEFnZW50QXBpRXJyb3IgfSBmcm9tICcuL2NvcmUnO1xuaW1wb3J0IHsgY3JlYXRlQWdlbnREaXJlY3RDb3JlLCB9IGZyb20gJy4vZGlyZWN0U2VydmVyJztcbmNvbnN0IGRlZmF1bHRDb250ZXh0RmFjdG9yeSA9ICgpID0+ICh7fSk7XG5mdW5jdGlvbiBzZW5kSnNvbihyZXMsIHN0YXR1cywgcGF5bG9hZCkge1xuICAgIHJlcy5zdGF0dXMoc3RhdHVzKS5qc29uKHBheWxvYWQpO1xufVxuZnVuY3Rpb24gaGFuZGxlRXhwcmVzc0Vycm9yKHJlcywgZXJyb3IpIHtcbiAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBBZ2VudEFwaUVycm9yKSB7XG4gICAgICAgIHNlbmRKc29uKHJlcywgZXJyb3Iuc3RhdHVzID8/IDQwMCwge1xuICAgICAgICAgICAgZXJyb3I6IGVycm9yLm1lc3NhZ2UsXG4gICAgICAgICAgICBkZXRhaWxzOiBlcnJvci5kZXRhaWxzLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zb2xlLmVycm9yKCdbQWdlbnRpY1RydXN0XVtFeHByZXNzXVtEaXJlY3RdIFVuZXhwZWN0ZWQgZXJyb3I6JywgZXJyb3IpO1xuICAgIHNlbmRKc29uKHJlcywgNTAwLCB7XG4gICAgICAgIGVycm9yOiAnSW50ZXJuYWwgc2VydmVyIGVycm9yJyxcbiAgICAgICAgbWVzc2FnZTogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvcicsXG4gICAgfSk7XG59XG5mdW5jdGlvbiBhc3NlcnRNb2RlKG1vZGUpIHtcbiAgICByZXR1cm4gbW9kZSA9PT0gJ3NtYXJ0QWNjb3VudCcgfHwgbW9kZSA9PT0gJ2VvYSc7XG59XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQWdlbnREaXJlY3RFeHByZXNzSGFuZGxlcihkZWZhdWx0TW9kZSwgZ2V0Q29udGV4dCA9IGRlZmF1bHRDb250ZXh0RmFjdG9yeSkge1xuICAgIHJldHVybiBhc3luYyAocmVxLCByZXMpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IGdldENvbnRleHQocmVxKTtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSAocmVxLmJvZHkgPz8ge30pO1xuICAgICAgICAgICAgY29uc3QgbW9kZUZyb21Cb2R5ID0gdHlwZW9mIGJvZHkubW9kZSA9PT0gJ3N0cmluZycgPyBib2R5Lm1vZGUgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjb25zdCBtb2RlVG9Vc2UgPSBtb2RlRnJvbUJvZHkgPz8gZGVmYXVsdE1vZGU7XG4gICAgICAgICAgICBpZiAoIWFzc2VydE1vZGUobW9kZVRvVXNlKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBZ2VudEFwaUVycm9yKCdtb2RlIG11c3QgYmUgZWl0aGVyIFwic21hcnRBY2NvdW50XCIgb3IgXCJlb2FcIicsIDQwMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjcmVhdGVBZ2VudERpcmVjdENvcmUoY3R4LCB7XG4gICAgICAgICAgICAgICAgLi4uYm9keSxcbiAgICAgICAgICAgICAgICBtb2RlOiBtb2RlVG9Vc2UsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNlbmRKc29uKHJlcywgMjAwLCByZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaGFuZGxlRXhwcmVzc0Vycm9yKHJlcywgZXJyb3IpO1xuICAgICAgICB9XG4gICAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRpcmVjdEV4cHJlc3MuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@agentic-trust/core/dist/api/agents/directExpress.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@agentic-trust/core/dist/api/agents/directNext.js":
/*!****************************************************************************!*\
  !*** ../../node_modules/@agentic-trust/core/dist/api/agents/directNext.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createAgentDirectRouteHandler: () => (/* binding */ createAgentDirectRouteHandler)\n/* harmony export */ });\n/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/api/agents/core.js\");\n/* harmony import */ var _directServer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./directServer */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/api/agents/directServer.js\");\n\n\nconst hasNativeResponse = typeof globalThis !== 'undefined' &&\n    typeof globalThis.Response === 'function';\nconst defaultContextFactory = () => ({});\nfunction jsonResponse(body, status = 200) {\n    if (hasNativeResponse) {\n        const ResponseCtor = globalThis.Response;\n        return new ResponseCtor(JSON.stringify(body), {\n            status,\n            headers: {\n                'content-type': 'application/json',\n            },\n        });\n    }\n    return {\n        status,\n        body,\n        headers: { 'content-type': 'application/json' },\n    };\n}\nfunction handleError(error) {\n    if (error instanceof _core__WEBPACK_IMPORTED_MODULE_0__.AgentApiError) {\n        return jsonResponse({\n            error: error.message,\n            details: error.details,\n        }, error.status ?? 400);\n    }\n    console.error('[AgenticTrust][Next][Direct] Unexpected error:', error);\n    return jsonResponse({\n        error: 'Internal server error',\n        message: error instanceof Error ? error.message : 'Unknown error',\n    }, 500);\n}\nfunction assertMode(mode) {\n    return mode === 'smartAccount' || mode === 'eoa';\n}\nfunction createAgentDirectRouteHandler(defaultMode, createContext = defaultContextFactory) {\n    return async (req) => {\n        try {\n            const body = (await req.json());\n            const ctx = createContext(req);\n            const modeFromBody = typeof body.mode === 'string' ? body.mode : undefined;\n            const modeToUse = modeFromBody ?? defaultMode;\n            if (!assertMode(modeToUse)) {\n                throw new _core__WEBPACK_IMPORTED_MODULE_0__.AgentApiError('mode must be either \"smartAccount\" or \"eoa\"', 400);\n            }\n            const result = await (0,_directServer__WEBPACK_IMPORTED_MODULE_1__.createAgentDirectCore)(ctx, {\n                ...body,\n                mode: modeToUse,\n            });\n            return jsonResponse(result);\n        }\n        catch (error) {\n            return handleError(error);\n        }\n    };\n}\n//# sourceMappingURL=directNext.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BhZ2VudGljLXRydXN0L2NvcmUvZGlzdC9hcGkvYWdlbnRzL2RpcmVjdE5leHQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQXVDO0FBQ2lCO0FBQ3hEO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG9DQUFvQztBQUN2RDtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsZ0RBQWE7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGdEQUFhO0FBQ3ZDO0FBQ0EsaUNBQWlDLG9FQUFxQjtBQUN0RDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL2JhcmIvYWEvQXNzb2NpYXRlZEFjY291bnRzL25vZGVfbW9kdWxlcy9AYWdlbnRpYy10cnVzdC9jb3JlL2Rpc3QvYXBpL2FnZW50cy9kaXJlY3ROZXh0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEFnZW50QXBpRXJyb3IgfSBmcm9tICcuL2NvcmUnO1xuaW1wb3J0IHsgY3JlYXRlQWdlbnREaXJlY3RDb3JlLCB9IGZyb20gJy4vZGlyZWN0U2VydmVyJztcbmNvbnN0IGhhc05hdGl2ZVJlc3BvbnNlID0gdHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnICYmXG4gICAgdHlwZW9mIGdsb2JhbFRoaXMuUmVzcG9uc2UgPT09ICdmdW5jdGlvbic7XG5jb25zdCBkZWZhdWx0Q29udGV4dEZhY3RvcnkgPSAoKSA9PiAoe30pO1xuZnVuY3Rpb24ganNvblJlc3BvbnNlKGJvZHksIHN0YXR1cyA9IDIwMCkge1xuICAgIGlmIChoYXNOYXRpdmVSZXNwb25zZSkge1xuICAgICAgICBjb25zdCBSZXNwb25zZUN0b3IgPSBnbG9iYWxUaGlzLlJlc3BvbnNlO1xuICAgICAgICByZXR1cm4gbmV3IFJlc3BvbnNlQ3RvcihKU09OLnN0cmluZ2lmeShib2R5KSwge1xuICAgICAgICAgICAgc3RhdHVzLFxuICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3RhdHVzLFxuICAgICAgICBib2R5LFxuICAgICAgICBoZWFkZXJzOiB7ICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcbiAgICB9O1xufVxuZnVuY3Rpb24gaGFuZGxlRXJyb3IoZXJyb3IpIHtcbiAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBBZ2VudEFwaUVycm9yKSB7XG4gICAgICAgIHJldHVybiBqc29uUmVzcG9uc2Uoe1xuICAgICAgICAgICAgZXJyb3I6IGVycm9yLm1lc3NhZ2UsXG4gICAgICAgICAgICBkZXRhaWxzOiBlcnJvci5kZXRhaWxzLFxuICAgICAgICB9LCBlcnJvci5zdGF0dXMgPz8gNDAwKTtcbiAgICB9XG4gICAgY29uc29sZS5lcnJvcignW0FnZW50aWNUcnVzdF1bTmV4dF1bRGlyZWN0XSBVbmV4cGVjdGVkIGVycm9yOicsIGVycm9yKTtcbiAgICByZXR1cm4ganNvblJlc3BvbnNlKHtcbiAgICAgICAgZXJyb3I6ICdJbnRlcm5hbCBzZXJ2ZXIgZXJyb3InLFxuICAgICAgICBtZXNzYWdlOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdVbmtub3duIGVycm9yJyxcbiAgICB9LCA1MDApO1xufVxuZnVuY3Rpb24gYXNzZXJ0TW9kZShtb2RlKSB7XG4gICAgcmV0dXJuIG1vZGUgPT09ICdzbWFydEFjY291bnQnIHx8IG1vZGUgPT09ICdlb2EnO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUFnZW50RGlyZWN0Um91dGVIYW5kbGVyKGRlZmF1bHRNb2RlLCBjcmVhdGVDb250ZXh0ID0gZGVmYXVsdENvbnRleHRGYWN0b3J5KSB7XG4gICAgcmV0dXJuIGFzeW5jIChyZXEpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSAoYXdhaXQgcmVxLmpzb24oKSk7XG4gICAgICAgICAgICBjb25zdCBjdHggPSBjcmVhdGVDb250ZXh0KHJlcSk7XG4gICAgICAgICAgICBjb25zdCBtb2RlRnJvbUJvZHkgPSB0eXBlb2YgYm9keS5tb2RlID09PSAnc3RyaW5nJyA/IGJvZHkubW9kZSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGNvbnN0IG1vZGVUb1VzZSA9IG1vZGVGcm9tQm9keSA/PyBkZWZhdWx0TW9kZTtcbiAgICAgICAgICAgIGlmICghYXNzZXJ0TW9kZShtb2RlVG9Vc2UpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFnZW50QXBpRXJyb3IoJ21vZGUgbXVzdCBiZSBlaXRoZXIgXCJzbWFydEFjY291bnRcIiBvciBcImVvYVwiJywgNDAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNyZWF0ZUFnZW50RGlyZWN0Q29yZShjdHgsIHtcbiAgICAgICAgICAgICAgICAuLi5ib2R5LFxuICAgICAgICAgICAgICAgIG1vZGU6IG1vZGVUb1VzZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGpzb25SZXNwb25zZShyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZUVycm9yKGVycm9yKTtcbiAgICAgICAgfVxuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kaXJlY3ROZXh0LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@agentic-trust/core/dist/api/agents/directNext.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@agentic-trust/core/dist/api/agents/directServer.js":
/*!******************************************************************************!*\
  !*** ../../node_modules/@agentic-trust/core/dist/api/agents/directServer.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createAgentDirectCore: () => (/* binding */ createAgentDirectCore)\n/* harmony export */ });\n/* harmony import */ var _server_lib_agenticTrust__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../server/lib/agenticTrust */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/lib/agenticTrust.js\");\n/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./core */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/api/agents/core.js\");\n/* harmony import */ var _server_lib_chainConfig__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../server/lib/chainConfig */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/lib/chainConfig.js\");\n\n\n\nfunction assertAddress(value, field) {\n    if (!value || typeof value !== 'string' || !/^0x[a-fA-F0-9]{40}$/.test(value)) {\n        throw new _core__WEBPACK_IMPORTED_MODULE_1__.AgentApiError(`${field} must be a valid Ethereum address (0x...)`, 400);\n    }\n}\nasync function resolveClient(ctx) {\n    if (ctx?.getClient) {\n        return ctx.getClient();\n    }\n    return (0,_server_lib_agenticTrust__WEBPACK_IMPORTED_MODULE_0__.getAgenticTrustClient)();\n}\nasync function createAgentDirectCore(ctx, input) {\n    const client = await resolveClient(ctx);\n    const chainId = input.chainId ?? _server_lib_chainConfig__WEBPACK_IMPORTED_MODULE_2__.DEFAULT_CHAIN_ID;\n    if (!input.agentName?.trim()) {\n        throw new _core__WEBPACK_IMPORTED_MODULE_1__.AgentApiError('agentName is required', 400);\n    }\n    assertAddress(input.agentAccount, 'agentAccount');\n    if (input.mode === 'smartAccount') {\n        const result = await client.createAgent({\n            ownerType: 'smartAccount',\n            executionMode: 'server',\n            agentName: input.agentName,\n            agentAccount: input.agentAccount,\n            agentCategory: input.agentCategory,\n            description: input.description,\n            image: input.image,\n            agentUrl: input.agentUrl,\n            supportedTrust: input.supportedTrust,\n            endpoints: input.endpoints,\n            chainId,\n            ensOptions: input.ensOptions,\n        });\n        const typedResult = result;\n        if (!typedResult.txHash) {\n            throw new _core__WEBPACK_IMPORTED_MODULE_1__.AgentApiError('Server createAgent did not return txHash', 500, result);\n        }\n        return {\n            success: true,\n            operation: 'create',\n            mode: 'smartAccount',\n            chainId,\n            tokenUri: undefined,\n            bundlerUrl: undefined,\n            calls: [],\n            transaction: null,\n            agentId: typedResult.agentId\n                ? typedResult.agentId.toString()\n                : undefined,\n            txHash: typedResult.txHash,\n        };\n    }\n    const eoaResult = await client.createAgent({\n        ownerType: 'eoa',\n        executionMode: 'server',\n        agentName: input.agentName,\n        agentAccount: input.agentAccount,\n        description: input.description,\n        image: input.image,\n        agentUrl: input.agentUrl,\n        supportedTrust: input.supportedTrust,\n        endpoints: input.endpoints,\n        chainId,\n    });\n    const typed = eoaResult;\n    return {\n        success: true,\n        operation: 'create',\n        mode: 'eoa',\n        chainId,\n        tokenUri: undefined,\n        calls: [],\n        transaction: null,\n        agentId: typed.agentId ? typed.agentId.toString() : undefined,\n        txHash: typed.txHash,\n    };\n}\n//# sourceMappingURL=directServer.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BhZ2VudGljLXRydXN0L2NvcmUvZGlzdC9hcGkvYWdlbnRzL2RpcmVjdFNlcnZlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQXNFO0FBQy9CO0FBQ3lCO0FBQ2hFO0FBQ0EsZ0VBQWdFLEdBQUc7QUFDbkUsa0JBQWtCLGdEQUFhLElBQUksT0FBTztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLCtFQUFxQjtBQUNoQztBQUNPO0FBQ1A7QUFDQSxxQ0FBcUMscUVBQWdCO0FBQ3JEO0FBQ0Esa0JBQWtCLGdEQUFhO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxzQkFBc0IsZ0RBQWE7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL2JhcmIvYWEvQXNzb2NpYXRlZEFjY291bnRzL25vZGVfbW9kdWxlcy9AYWdlbnRpYy10cnVzdC9jb3JlL2Rpc3QvYXBpL2FnZW50cy9kaXJlY3RTZXJ2ZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZ2V0QWdlbnRpY1RydXN0Q2xpZW50IH0gZnJvbSAnLi4vLi4vc2VydmVyL2xpYi9hZ2VudGljVHJ1c3QnO1xuaW1wb3J0IHsgQWdlbnRBcGlFcnJvciB9IGZyb20gJy4vY29yZSc7XG5pbXBvcnQgeyBERUZBVUxUX0NIQUlOX0lEIH0gZnJvbSAnLi4vLi4vc2VydmVyL2xpYi9jaGFpbkNvbmZpZyc7XG5mdW5jdGlvbiBhc3NlcnRBZGRyZXNzKHZhbHVlLCBmaWVsZCkge1xuICAgIGlmICghdmFsdWUgfHwgdHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJyB8fCAhL14weFthLWZBLUYwLTldezQwfSQvLnRlc3QodmFsdWUpKSB7XG4gICAgICAgIHRocm93IG5ldyBBZ2VudEFwaUVycm9yKGAke2ZpZWxkfSBtdXN0IGJlIGEgdmFsaWQgRXRoZXJldW0gYWRkcmVzcyAoMHguLi4pYCwgNDAwKTtcbiAgICB9XG59XG5hc3luYyBmdW5jdGlvbiByZXNvbHZlQ2xpZW50KGN0eCkge1xuICAgIGlmIChjdHg/LmdldENsaWVudCkge1xuICAgICAgICByZXR1cm4gY3R4LmdldENsaWVudCgpO1xuICAgIH1cbiAgICByZXR1cm4gZ2V0QWdlbnRpY1RydXN0Q2xpZW50KCk7XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY3JlYXRlQWdlbnREaXJlY3RDb3JlKGN0eCwgaW5wdXQpIHtcbiAgICBjb25zdCBjbGllbnQgPSBhd2FpdCByZXNvbHZlQ2xpZW50KGN0eCk7XG4gICAgY29uc3QgY2hhaW5JZCA9IGlucHV0LmNoYWluSWQgPz8gREVGQVVMVF9DSEFJTl9JRDtcbiAgICBpZiAoIWlucHV0LmFnZW50TmFtZT8udHJpbSgpKSB7XG4gICAgICAgIHRocm93IG5ldyBBZ2VudEFwaUVycm9yKCdhZ2VudE5hbWUgaXMgcmVxdWlyZWQnLCA0MDApO1xuICAgIH1cbiAgICBhc3NlcnRBZGRyZXNzKGlucHV0LmFnZW50QWNjb3VudCwgJ2FnZW50QWNjb3VudCcpO1xuICAgIGlmIChpbnB1dC5tb2RlID09PSAnc21hcnRBY2NvdW50Jykge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjbGllbnQuY3JlYXRlQWdlbnQoe1xuICAgICAgICAgICAgb3duZXJUeXBlOiAnc21hcnRBY2NvdW50JyxcbiAgICAgICAgICAgIGV4ZWN1dGlvbk1vZGU6ICdzZXJ2ZXInLFxuICAgICAgICAgICAgYWdlbnROYW1lOiBpbnB1dC5hZ2VudE5hbWUsXG4gICAgICAgICAgICBhZ2VudEFjY291bnQ6IGlucHV0LmFnZW50QWNjb3VudCxcbiAgICAgICAgICAgIGFnZW50Q2F0ZWdvcnk6IGlucHV0LmFnZW50Q2F0ZWdvcnksXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogaW5wdXQuZGVzY3JpcHRpb24sXG4gICAgICAgICAgICBpbWFnZTogaW5wdXQuaW1hZ2UsXG4gICAgICAgICAgICBhZ2VudFVybDogaW5wdXQuYWdlbnRVcmwsXG4gICAgICAgICAgICBzdXBwb3J0ZWRUcnVzdDogaW5wdXQuc3VwcG9ydGVkVHJ1c3QsXG4gICAgICAgICAgICBlbmRwb2ludHM6IGlucHV0LmVuZHBvaW50cyxcbiAgICAgICAgICAgIGNoYWluSWQsXG4gICAgICAgICAgICBlbnNPcHRpb25zOiBpbnB1dC5lbnNPcHRpb25zLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgdHlwZWRSZXN1bHQgPSByZXN1bHQ7XG4gICAgICAgIGlmICghdHlwZWRSZXN1bHQudHhIYXNoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQWdlbnRBcGlFcnJvcignU2VydmVyIGNyZWF0ZUFnZW50IGRpZCBub3QgcmV0dXJuIHR4SGFzaCcsIDUwMCwgcmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgICAgIG9wZXJhdGlvbjogJ2NyZWF0ZScsXG4gICAgICAgICAgICBtb2RlOiAnc21hcnRBY2NvdW50JyxcbiAgICAgICAgICAgIGNoYWluSWQsXG4gICAgICAgICAgICB0b2tlblVyaTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgYnVuZGxlclVybDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgY2FsbHM6IFtdLFxuICAgICAgICAgICAgdHJhbnNhY3Rpb246IG51bGwsXG4gICAgICAgICAgICBhZ2VudElkOiB0eXBlZFJlc3VsdC5hZ2VudElkXG4gICAgICAgICAgICAgICAgPyB0eXBlZFJlc3VsdC5hZ2VudElkLnRvU3RyaW5nKClcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHR4SGFzaDogdHlwZWRSZXN1bHQudHhIYXNoLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBlb2FSZXN1bHQgPSBhd2FpdCBjbGllbnQuY3JlYXRlQWdlbnQoe1xuICAgICAgICBvd25lclR5cGU6ICdlb2EnLFxuICAgICAgICBleGVjdXRpb25Nb2RlOiAnc2VydmVyJyxcbiAgICAgICAgYWdlbnROYW1lOiBpbnB1dC5hZ2VudE5hbWUsXG4gICAgICAgIGFnZW50QWNjb3VudDogaW5wdXQuYWdlbnRBY2NvdW50LFxuICAgICAgICBkZXNjcmlwdGlvbjogaW5wdXQuZGVzY3JpcHRpb24sXG4gICAgICAgIGltYWdlOiBpbnB1dC5pbWFnZSxcbiAgICAgICAgYWdlbnRVcmw6IGlucHV0LmFnZW50VXJsLFxuICAgICAgICBzdXBwb3J0ZWRUcnVzdDogaW5wdXQuc3VwcG9ydGVkVHJ1c3QsXG4gICAgICAgIGVuZHBvaW50czogaW5wdXQuZW5kcG9pbnRzLFxuICAgICAgICBjaGFpbklkLFxuICAgIH0pO1xuICAgIGNvbnN0IHR5cGVkID0gZW9hUmVzdWx0O1xuICAgIHJldHVybiB7XG4gICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgIG9wZXJhdGlvbjogJ2NyZWF0ZScsXG4gICAgICAgIG1vZGU6ICdlb2EnLFxuICAgICAgICBjaGFpbklkLFxuICAgICAgICB0b2tlblVyaTogdW5kZWZpbmVkLFxuICAgICAgICBjYWxsczogW10sXG4gICAgICAgIHRyYW5zYWN0aW9uOiBudWxsLFxuICAgICAgICBhZ2VudElkOiB0eXBlZC5hZ2VudElkID8gdHlwZWQuYWdlbnRJZC50b1N0cmluZygpIDogdW5kZWZpbmVkLFxuICAgICAgICB0eEhhc2g6IHR5cGVkLnR4SGFzaCxcbiAgICB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGlyZWN0U2VydmVyLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@agentic-trust/core/dist/api/agents/directServer.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@agentic-trust/core/dist/api/agents/express.js":
/*!*************************************************************************!*\
  !*** ../../node_modules/@agentic-trust/core/dist/api/agents/express.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createAgentExpressHandler: () => (/* binding */ createAgentExpressHandler),\n/* harmony export */   getFeedbackExpressHandler: () => (/* binding */ getFeedbackExpressHandler),\n/* harmony export */   mountAgentRoutes: () => (/* binding */ mountAgentRoutes),\n/* harmony export */   prepareFeedbackExpressHandler: () => (/* binding */ prepareFeedbackExpressHandler),\n/* harmony export */   requestFeedbackAuthExpressHandler: () => (/* binding */ requestFeedbackAuthExpressHandler),\n/* harmony export */   updateAgentRegistrationExpressHandler: () => (/* binding */ updateAgentRegistrationExpressHandler)\n/* harmony export */ });\n/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/api/agents/core.js\");\n/* harmony import */ var _shared_did8004__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/did8004 */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/shared/did8004.js\");\n\n\nconst defaultContextFactory = () => ({});\nfunction sendJson(res, status, payload) {\n    res.status(status).json(payload);\n}\nfunction handleExpressError(res, error) {\n    if (error instanceof _core__WEBPACK_IMPORTED_MODULE_0__.AgentApiError) {\n        sendJson(res, error.status ?? 400, {\n            error: error.message,\n            details: error.details,\n        });\n        return;\n    }\n    console.error('[AgenticTrust][Express] Unexpected error:', error);\n    sendJson(res, 500, {\n        error: 'Internal server error',\n        message: error instanceof Error ? error.message : 'Unknown error',\n    });\n}\nfunction createHandler(handler, getContext) {\n    return async (req, res) => {\n        try {\n            const ctx = getContext(req);\n            const result = await handler(ctx, req.body);\n            sendJson(res, 200, result);\n        }\n        catch (error) {\n            handleExpressError(res, error);\n        }\n    };\n}\nfunction createAgentExpressHandler(getContext = defaultContextFactory) {\n    return createHandler(_core__WEBPACK_IMPORTED_MODULE_0__.createAgentCore, getContext);\n}\nfunction updateAgentRegistrationExpressHandler(getContext = defaultContextFactory) {\n    return async (req, res) => {\n        try {\n            const ctx = getContext(req);\n            const did8004 = req.params?.did8004 ||\n                req.params?.['did:8004'] ||\n                req.params?.['did%3A8004'];\n            if (!did8004) {\n                throw new _core__WEBPACK_IMPORTED_MODULE_0__.AgentApiError('Missing did:8004 parameter', 400);\n            }\n            const body = (req.body ?? {});\n            const input = {\n                did8004: decodeURIComponent(did8004),\n                registration: body.registration,\n                mode: body.mode,\n            };\n            const result = await (0,_core__WEBPACK_IMPORTED_MODULE_0__.updateAgentRegistrationCore)(ctx, input);\n            sendJson(res, 200, result);\n        }\n        catch (error) {\n            handleExpressError(res, error);\n        }\n    };\n}\nfunction getQueryParam(req, key) {\n    const query = req.query;\n    const value = query ? query[key] : undefined;\n    if (Array.isArray(value)) {\n        return value[0]?.toString();\n    }\n    if (typeof value === 'string') {\n        return value;\n    }\n    if (value !== undefined && value !== null) {\n        return String(value);\n    }\n    if (typeof req.url === 'string') {\n        try {\n            const url = new URL(req.url, 'http://localhost');\n            const param = url.searchParams.get(key);\n            return param ?? undefined;\n        }\n        catch {\n            return undefined;\n        }\n    }\n    return undefined;\n}\nfunction parseNumber(value) {\n    if (!value)\n        return undefined;\n    const parsed = Number(value);\n    return Number.isFinite(parsed) ? parsed : undefined;\n}\nfunction requestFeedbackAuthExpressHandler(getContext = defaultContextFactory) {\n    return async (req, res) => {\n        try {\n            const ctx = getContext(req);\n            const clientAddress = getQueryParam(req, 'clientAddress') ?? '';\n            const paramAgentId = getQueryParam(req, 'agentId') ??\n                req.params?.did8004 ??\n                req.params?.['did:8004'] ??\n                req.params?.['did%3A8004'];\n            let agentId = paramAgentId ?? '';\n            let chainId = parseNumber(getQueryParam(req, 'chainId'));\n            if (paramAgentId?.startsWith('did:8004:')) {\n                try {\n                    const parsed = (0,_shared_did8004__WEBPACK_IMPORTED_MODULE_1__.parseDid8004)(paramAgentId);\n                    agentId = parsed.agentId;\n                    chainId = parsed.chainId;\n                }\n                catch {\n                    // fallback to manual values below\n                }\n            }\n            const indexLimit = parseNumber(getQueryParam(req, 'indexLimit'));\n            const expirySeconds = parseNumber(getQueryParam(req, 'expirySec')) ??\n                parseNumber(getQueryParam(req, 'expirySeconds'));\n            const input = {\n                clientAddress,\n                agentId,\n                chainId,\n                indexLimit,\n                expirySeconds,\n            };\n            const result = await (0,_core__WEBPACK_IMPORTED_MODULE_0__.requestFeedbackAuthCore)(ctx, input);\n            sendJson(res, 200, result);\n        }\n        catch (error) {\n            handleExpressError(res, error);\n        }\n    };\n}\nfunction prepareFeedbackExpressHandler(getContext = defaultContextFactory) {\n    return async (req, res) => {\n        try {\n            const ctx = getContext(req);\n            const did8004 = req.params?.did8004 ??\n                req.params?.['did:8004'] ??\n                req.params?.['did%3A8004'];\n            if (!did8004) {\n                sendJson(res, 400, { error: 'did8004 parameter is required' });\n                return;\n            }\n            const body = (req.body ?? {});\n            const input = {\n                did8004,\n                ...body,\n            };\n            const result = await (0,_core__WEBPACK_IMPORTED_MODULE_0__.prepareFeedbackCore)(ctx, input);\n            sendJson(res, 200, result);\n        }\n        catch (error) {\n            handleExpressError(res, error);\n        }\n    };\n}\nfunction getFeedbackExpressHandler(getContext = defaultContextFactory) {\n    return async (req, res) => {\n        try {\n            const ctx = getContext(req);\n            const did8004 = req.params?.did8004 ??\n                req.params?.['did:8004'] ??\n                req.params?.['did%3A8004'];\n            if (!did8004) {\n                sendJson(res, 400, { error: 'did8004 parameter is required' });\n                return;\n            }\n            const includeRevokedParam = getQueryParam(req, 'includeRevoked');\n            const includeRevoked = includeRevokedParam === 'true' || includeRevokedParam === '1';\n            const limit = parseNumber(getQueryParam(req, 'limit')) ?? 100;\n            const offset = parseNumber(getQueryParam(req, 'offset')) ?? 0;\n            const result = await (0,_core__WEBPACK_IMPORTED_MODULE_0__.getFeedbackCore)(ctx, {\n                did8004: decodeURIComponent(did8004),\n                includeRevoked,\n                limit,\n                offset,\n            });\n            sendJson(res, 200, result);\n        }\n        catch (error) {\n            handleExpressError(res, error);\n        }\n    };\n}\nfunction mountAgentRoutes(router, options) {\n    const basePath = options?.basePath ?? '/api/agents';\n    const getContext = options?.createContext ?? defaultContextFactory;\n    router.post(`${basePath}/create`, createAgentExpressHandler(getContext));\n    router.put(`${basePath}/:did8004/registration`, updateAgentRegistrationExpressHandler(getContext));\n    router.get(`${basePath}/:did8004/feedback-auth`, requestFeedbackAuthExpressHandler(getContext));\n    router.post(`${basePath}/:did8004/feedback`, prepareFeedbackExpressHandler(getContext));\n    router.get(`${basePath}/:did8004/feedback`, getFeedbackExpressHandler(getContext));\n}\n//# sourceMappingURL=express.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BhZ2VudGljLXRydXN0L2NvcmUvZGlzdC9hcGkvYWdlbnRzL2V4cHJlc3MuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBcUo7QUFDakc7QUFDcEQsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGdEQUFhO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLHlCQUF5QixrREFBZTtBQUN4QztBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsZ0RBQWE7QUFDdkM7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxrRUFBMkI7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyw2REFBWTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLDhEQUF1QjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsd0NBQXdDO0FBQzdFO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsMERBQW1CO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyx3Q0FBd0M7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLHNEQUFlO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUIsa0JBQWtCLFNBQVM7QUFDM0Isa0JBQWtCLFNBQVM7QUFDM0IsbUJBQW1CLFNBQVM7QUFDNUIsa0JBQWtCLFNBQVM7QUFDM0I7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvYmFyYi9hYS9Bc3NvY2lhdGVkQWNjb3VudHMvbm9kZV9tb2R1bGVzL0BhZ2VudGljLXRydXN0L2NvcmUvZGlzdC9hcGkvYWdlbnRzL2V4cHJlc3MuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQWdlbnRBcGlFcnJvciwgY3JlYXRlQWdlbnRDb3JlLCB1cGRhdGVBZ2VudFJlZ2lzdHJhdGlvbkNvcmUsIHJlcXVlc3RGZWVkYmFja0F1dGhDb3JlLCBwcmVwYXJlRmVlZGJhY2tDb3JlLCBnZXRGZWVkYmFja0NvcmUsIH0gZnJvbSAnLi9jb3JlJztcbmltcG9ydCB7IHBhcnNlRGlkODAwNCB9IGZyb20gJy4uLy4uL3NoYXJlZC9kaWQ4MDA0JztcbmNvbnN0IGRlZmF1bHRDb250ZXh0RmFjdG9yeSA9ICgpID0+ICh7fSk7XG5mdW5jdGlvbiBzZW5kSnNvbihyZXMsIHN0YXR1cywgcGF5bG9hZCkge1xuICAgIHJlcy5zdGF0dXMoc3RhdHVzKS5qc29uKHBheWxvYWQpO1xufVxuZnVuY3Rpb24gaGFuZGxlRXhwcmVzc0Vycm9yKHJlcywgZXJyb3IpIHtcbiAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBBZ2VudEFwaUVycm9yKSB7XG4gICAgICAgIHNlbmRKc29uKHJlcywgZXJyb3Iuc3RhdHVzID8/IDQwMCwge1xuICAgICAgICAgICAgZXJyb3I6IGVycm9yLm1lc3NhZ2UsXG4gICAgICAgICAgICBkZXRhaWxzOiBlcnJvci5kZXRhaWxzLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zb2xlLmVycm9yKCdbQWdlbnRpY1RydXN0XVtFeHByZXNzXSBVbmV4cGVjdGVkIGVycm9yOicsIGVycm9yKTtcbiAgICBzZW5kSnNvbihyZXMsIDUwMCwge1xuICAgICAgICBlcnJvcjogJ0ludGVybmFsIHNlcnZlciBlcnJvcicsXG4gICAgICAgIG1lc3NhZ2U6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InLFxuICAgIH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlSGFuZGxlcihoYW5kbGVyLCBnZXRDb250ZXh0KSB7XG4gICAgcmV0dXJuIGFzeW5jIChyZXEsIHJlcykgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgY3R4ID0gZ2V0Q29udGV4dChyZXEpO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgaGFuZGxlcihjdHgsIHJlcS5ib2R5KTtcbiAgICAgICAgICAgIHNlbmRKc29uKHJlcywgMjAwLCByZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaGFuZGxlRXhwcmVzc0Vycm9yKHJlcywgZXJyb3IpO1xuICAgICAgICB9XG4gICAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVBZ2VudEV4cHJlc3NIYW5kbGVyKGdldENvbnRleHQgPSBkZWZhdWx0Q29udGV4dEZhY3RvcnkpIHtcbiAgICByZXR1cm4gY3JlYXRlSGFuZGxlcihjcmVhdGVBZ2VudENvcmUsIGdldENvbnRleHQpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZUFnZW50UmVnaXN0cmF0aW9uRXhwcmVzc0hhbmRsZXIoZ2V0Q29udGV4dCA9IGRlZmF1bHRDb250ZXh0RmFjdG9yeSkge1xuICAgIHJldHVybiBhc3luYyAocmVxLCByZXMpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IGdldENvbnRleHQocmVxKTtcbiAgICAgICAgICAgIGNvbnN0IGRpZDgwMDQgPSByZXEucGFyYW1zPy5kaWQ4MDA0IHx8XG4gICAgICAgICAgICAgICAgcmVxLnBhcmFtcz8uWydkaWQ6ODAwNCddIHx8XG4gICAgICAgICAgICAgICAgcmVxLnBhcmFtcz8uWydkaWQlM0E4MDA0J107XG4gICAgICAgICAgICBpZiAoIWRpZDgwMDQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQWdlbnRBcGlFcnJvcignTWlzc2luZyBkaWQ6ODAwNCBwYXJhbWV0ZXInLCA0MDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYm9keSA9IChyZXEuYm9keSA/PyB7fSk7XG4gICAgICAgICAgICBjb25zdCBpbnB1dCA9IHtcbiAgICAgICAgICAgICAgICBkaWQ4MDA0OiBkZWNvZGVVUklDb21wb25lbnQoZGlkODAwNCksXG4gICAgICAgICAgICAgICAgcmVnaXN0cmF0aW9uOiBib2R5LnJlZ2lzdHJhdGlvbixcbiAgICAgICAgICAgICAgICBtb2RlOiBib2R5Lm1vZGUsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdXBkYXRlQWdlbnRSZWdpc3RyYXRpb25Db3JlKGN0eCwgaW5wdXQpO1xuICAgICAgICAgICAgc2VuZEpzb24ocmVzLCAyMDAsIHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBoYW5kbGVFeHByZXNzRXJyb3IocmVzLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICB9O1xufVxuZnVuY3Rpb24gZ2V0UXVlcnlQYXJhbShyZXEsIGtleSkge1xuICAgIGNvbnN0IHF1ZXJ5ID0gcmVxLnF1ZXJ5O1xuICAgIGNvbnN0IHZhbHVlID0gcXVlcnkgPyBxdWVyeVtrZXldIDogdW5kZWZpbmVkO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdmFsdWVbMF0/LnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIFN0cmluZyh2YWx1ZSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgcmVxLnVybCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHVybCA9IG5ldyBVUkwocmVxLnVybCwgJ2h0dHA6Ly9sb2NhbGhvc3QnKTtcbiAgICAgICAgICAgIGNvbnN0IHBhcmFtID0gdXJsLnNlYXJjaFBhcmFtcy5nZXQoa2V5KTtcbiAgICAgICAgICAgIHJldHVybiBwYXJhbSA/PyB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2gge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gcGFyc2VOdW1iZXIodmFsdWUpIHtcbiAgICBpZiAoIXZhbHVlKVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIGNvbnN0IHBhcnNlZCA9IE51bWJlcih2YWx1ZSk7XG4gICAgcmV0dXJuIE51bWJlci5pc0Zpbml0ZShwYXJzZWQpID8gcGFyc2VkIDogdW5kZWZpbmVkO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHJlcXVlc3RGZWVkYmFja0F1dGhFeHByZXNzSGFuZGxlcihnZXRDb250ZXh0ID0gZGVmYXVsdENvbnRleHRGYWN0b3J5KSB7XG4gICAgcmV0dXJuIGFzeW5jIChyZXEsIHJlcykgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgY3R4ID0gZ2V0Q29udGV4dChyZXEpO1xuICAgICAgICAgICAgY29uc3QgY2xpZW50QWRkcmVzcyA9IGdldFF1ZXJ5UGFyYW0ocmVxLCAnY2xpZW50QWRkcmVzcycpID8/ICcnO1xuICAgICAgICAgICAgY29uc3QgcGFyYW1BZ2VudElkID0gZ2V0UXVlcnlQYXJhbShyZXEsICdhZ2VudElkJykgPz9cbiAgICAgICAgICAgICAgICByZXEucGFyYW1zPy5kaWQ4MDA0ID8/XG4gICAgICAgICAgICAgICAgcmVxLnBhcmFtcz8uWydkaWQ6ODAwNCddID8/XG4gICAgICAgICAgICAgICAgcmVxLnBhcmFtcz8uWydkaWQlM0E4MDA0J107XG4gICAgICAgICAgICBsZXQgYWdlbnRJZCA9IHBhcmFtQWdlbnRJZCA/PyAnJztcbiAgICAgICAgICAgIGxldCBjaGFpbklkID0gcGFyc2VOdW1iZXIoZ2V0UXVlcnlQYXJhbShyZXEsICdjaGFpbklkJykpO1xuICAgICAgICAgICAgaWYgKHBhcmFtQWdlbnRJZD8uc3RhcnRzV2l0aCgnZGlkOjgwMDQ6JykpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWQgPSBwYXJzZURpZDgwMDQocGFyYW1BZ2VudElkKTtcbiAgICAgICAgICAgICAgICAgICAgYWdlbnRJZCA9IHBhcnNlZC5hZ2VudElkO1xuICAgICAgICAgICAgICAgICAgICBjaGFpbklkID0gcGFyc2VkLmNoYWluSWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZmFsbGJhY2sgdG8gbWFudWFsIHZhbHVlcyBiZWxvd1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGluZGV4TGltaXQgPSBwYXJzZU51bWJlcihnZXRRdWVyeVBhcmFtKHJlcSwgJ2luZGV4TGltaXQnKSk7XG4gICAgICAgICAgICBjb25zdCBleHBpcnlTZWNvbmRzID0gcGFyc2VOdW1iZXIoZ2V0UXVlcnlQYXJhbShyZXEsICdleHBpcnlTZWMnKSkgPz9cbiAgICAgICAgICAgICAgICBwYXJzZU51bWJlcihnZXRRdWVyeVBhcmFtKHJlcSwgJ2V4cGlyeVNlY29uZHMnKSk7XG4gICAgICAgICAgICBjb25zdCBpbnB1dCA9IHtcbiAgICAgICAgICAgICAgICBjbGllbnRBZGRyZXNzLFxuICAgICAgICAgICAgICAgIGFnZW50SWQsXG4gICAgICAgICAgICAgICAgY2hhaW5JZCxcbiAgICAgICAgICAgICAgICBpbmRleExpbWl0LFxuICAgICAgICAgICAgICAgIGV4cGlyeVNlY29uZHMsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVxdWVzdEZlZWRiYWNrQXV0aENvcmUoY3R4LCBpbnB1dCk7XG4gICAgICAgICAgICBzZW5kSnNvbihyZXMsIDIwMCwgcmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGhhbmRsZUV4cHJlc3NFcnJvcihyZXMsIGVycm9yKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5leHBvcnQgZnVuY3Rpb24gcHJlcGFyZUZlZWRiYWNrRXhwcmVzc0hhbmRsZXIoZ2V0Q29udGV4dCA9IGRlZmF1bHRDb250ZXh0RmFjdG9yeSkge1xuICAgIHJldHVybiBhc3luYyAocmVxLCByZXMpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IGdldENvbnRleHQocmVxKTtcbiAgICAgICAgICAgIGNvbnN0IGRpZDgwMDQgPSByZXEucGFyYW1zPy5kaWQ4MDA0ID8/XG4gICAgICAgICAgICAgICAgcmVxLnBhcmFtcz8uWydkaWQ6ODAwNCddID8/XG4gICAgICAgICAgICAgICAgcmVxLnBhcmFtcz8uWydkaWQlM0E4MDA0J107XG4gICAgICAgICAgICBpZiAoIWRpZDgwMDQpIHtcbiAgICAgICAgICAgICAgICBzZW5kSnNvbihyZXMsIDQwMCwgeyBlcnJvcjogJ2RpZDgwMDQgcGFyYW1ldGVyIGlzIHJlcXVpcmVkJyB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gKHJlcS5ib2R5ID8/IHt9KTtcbiAgICAgICAgICAgIGNvbnN0IGlucHV0ID0ge1xuICAgICAgICAgICAgICAgIGRpZDgwMDQsXG4gICAgICAgICAgICAgICAgLi4uYm9keSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBwcmVwYXJlRmVlZGJhY2tDb3JlKGN0eCwgaW5wdXQpO1xuICAgICAgICAgICAgc2VuZEpzb24ocmVzLCAyMDAsIHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBoYW5kbGVFeHByZXNzRXJyb3IocmVzLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldEZlZWRiYWNrRXhwcmVzc0hhbmRsZXIoZ2V0Q29udGV4dCA9IGRlZmF1bHRDb250ZXh0RmFjdG9yeSkge1xuICAgIHJldHVybiBhc3luYyAocmVxLCByZXMpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IGdldENvbnRleHQocmVxKTtcbiAgICAgICAgICAgIGNvbnN0IGRpZDgwMDQgPSByZXEucGFyYW1zPy5kaWQ4MDA0ID8/XG4gICAgICAgICAgICAgICAgcmVxLnBhcmFtcz8uWydkaWQ6ODAwNCddID8/XG4gICAgICAgICAgICAgICAgcmVxLnBhcmFtcz8uWydkaWQlM0E4MDA0J107XG4gICAgICAgICAgICBpZiAoIWRpZDgwMDQpIHtcbiAgICAgICAgICAgICAgICBzZW5kSnNvbihyZXMsIDQwMCwgeyBlcnJvcjogJ2RpZDgwMDQgcGFyYW1ldGVyIGlzIHJlcXVpcmVkJyB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBpbmNsdWRlUmV2b2tlZFBhcmFtID0gZ2V0UXVlcnlQYXJhbShyZXEsICdpbmNsdWRlUmV2b2tlZCcpO1xuICAgICAgICAgICAgY29uc3QgaW5jbHVkZVJldm9rZWQgPSBpbmNsdWRlUmV2b2tlZFBhcmFtID09PSAndHJ1ZScgfHwgaW5jbHVkZVJldm9rZWRQYXJhbSA9PT0gJzEnO1xuICAgICAgICAgICAgY29uc3QgbGltaXQgPSBwYXJzZU51bWJlcihnZXRRdWVyeVBhcmFtKHJlcSwgJ2xpbWl0JykpID8/IDEwMDtcbiAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IHBhcnNlTnVtYmVyKGdldFF1ZXJ5UGFyYW0ocmVxLCAnb2Zmc2V0JykpID8/IDA7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBnZXRGZWVkYmFja0NvcmUoY3R4LCB7XG4gICAgICAgICAgICAgICAgZGlkODAwNDogZGVjb2RlVVJJQ29tcG9uZW50KGRpZDgwMDQpLFxuICAgICAgICAgICAgICAgIGluY2x1ZGVSZXZva2VkLFxuICAgICAgICAgICAgICAgIGxpbWl0LFxuICAgICAgICAgICAgICAgIG9mZnNldCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2VuZEpzb24ocmVzLCAyMDAsIHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBoYW5kbGVFeHByZXNzRXJyb3IocmVzLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIG1vdW50QWdlbnRSb3V0ZXMocm91dGVyLCBvcHRpb25zKSB7XG4gICAgY29uc3QgYmFzZVBhdGggPSBvcHRpb25zPy5iYXNlUGF0aCA/PyAnL2FwaS9hZ2VudHMnO1xuICAgIGNvbnN0IGdldENvbnRleHQgPSBvcHRpb25zPy5jcmVhdGVDb250ZXh0ID8/IGRlZmF1bHRDb250ZXh0RmFjdG9yeTtcbiAgICByb3V0ZXIucG9zdChgJHtiYXNlUGF0aH0vY3JlYXRlYCwgY3JlYXRlQWdlbnRFeHByZXNzSGFuZGxlcihnZXRDb250ZXh0KSk7XG4gICAgcm91dGVyLnB1dChgJHtiYXNlUGF0aH0vOmRpZDgwMDQvcmVnaXN0cmF0aW9uYCwgdXBkYXRlQWdlbnRSZWdpc3RyYXRpb25FeHByZXNzSGFuZGxlcihnZXRDb250ZXh0KSk7XG4gICAgcm91dGVyLmdldChgJHtiYXNlUGF0aH0vOmRpZDgwMDQvZmVlZGJhY2stYXV0aGAsIHJlcXVlc3RGZWVkYmFja0F1dGhFeHByZXNzSGFuZGxlcihnZXRDb250ZXh0KSk7XG4gICAgcm91dGVyLnBvc3QoYCR7YmFzZVBhdGh9LzpkaWQ4MDA0L2ZlZWRiYWNrYCwgcHJlcGFyZUZlZWRiYWNrRXhwcmVzc0hhbmRsZXIoZ2V0Q29udGV4dCkpO1xuICAgIHJvdXRlci5nZXQoYCR7YmFzZVBhdGh9LzpkaWQ4MDA0L2ZlZWRiYWNrYCwgZ2V0RmVlZGJhY2tFeHByZXNzSGFuZGxlcihnZXRDb250ZXh0KSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1leHByZXNzLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@agentic-trust/core/dist/api/agents/express.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@agentic-trust/core/dist/api/agents/next.js":
/*!**********************************************************************!*\
  !*** ../../node_modules/@agentic-trust/core/dist/api/agents/next.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createAgentRouteHandler: () => (/* binding */ createAgentRouteHandler),\n/* harmony export */   directFeedbackRouteHandler: () => (/* binding */ directFeedbackRouteHandler),\n/* harmony export */   getFeedbackRouteHandler: () => (/* binding */ getFeedbackRouteHandler),\n/* harmony export */   getValidationsRouteHandler: () => (/* binding */ getValidationsRouteHandler),\n/* harmony export */   prepareAssociationRequestRouteHandler: () => (/* binding */ prepareAssociationRequestRouteHandler),\n/* harmony export */   prepareFeedbackRouteHandler: () => (/* binding */ prepareFeedbackRouteHandler),\n/* harmony export */   prepareValidationRequestRouteHandler: () => (/* binding */ prepareValidationRequestRouteHandler),\n/* harmony export */   requestFeedbackAuthRouteHandler: () => (/* binding */ requestFeedbackAuthRouteHandler),\n/* harmony export */   updateAgentRegistrationRouteHandler: () => (/* binding */ updateAgentRegistrationRouteHandler)\n/* harmony export */ });\n/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/api/agents/core.js\");\n/* harmony import */ var _validations__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./validations */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/api/agents/validations.js\");\n/* harmony import */ var _shared_did8004__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../shared/did8004 */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/shared/did8004.js\");\n\n\n\nconst hasNativeResponse = typeof globalThis !== 'undefined' &&\n    typeof globalThis.Response === 'function';\nconst defaultContextFactory = () => ({});\n// Recursively convert BigInt and other non-JSON-safe values into JSON-safe forms.\nfunction toJsonSafe(value) {\n    if (typeof value === 'bigint') {\n        return value.toString();\n    }\n    if (value instanceof Date) {\n        return value.toISOString();\n    }\n    if (Array.isArray(value)) {\n        return value.map((item) => toJsonSafe(item));\n    }\n    if (value && typeof value === 'object') {\n        const result = {};\n        for (const [key, v] of Object.entries(value)) {\n            result[key] = toJsonSafe(v);\n        }\n        return result;\n    }\n    return value;\n}\nfunction jsonResponse(body, status = 200) {\n    const safeBody = toJsonSafe(body);\n    if (hasNativeResponse) {\n        const ResponseCtor = globalThis.Response;\n        return new ResponseCtor(JSON.stringify(safeBody), {\n            status,\n            headers: {\n                'content-type': 'application/json',\n            },\n        });\n    }\n    return {\n        status,\n        body: safeBody,\n        headers: { 'content-type': 'application/json' },\n    };\n}\nfunction handleNextError(error) {\n    if (error instanceof _core__WEBPACK_IMPORTED_MODULE_0__.AgentApiError) {\n        return jsonResponse({\n            error: error.message,\n            details: error.details,\n        }, error.status ?? 400);\n    }\n    console.error('[AgenticTrust][Next] Unexpected error:', error);\n    return jsonResponse({\n        error: 'Internal server error',\n        message: error instanceof Error ? error.message : 'Unknown error',\n    }, 500);\n}\nfunction createAgentRouteHandler(createContext = defaultContextFactory) {\n    return async (req) => {\n        try {\n            const input = (await req.json());\n            const ctx = createContext(req);\n            const result = await (0,_core__WEBPACK_IMPORTED_MODULE_0__.createAgentCore)(ctx, input);\n            return jsonResponse(result);\n        }\n        catch (error) {\n            return handleNextError(error);\n        }\n    };\n}\nfunction extractDidParam(params) {\n    const candidateKeys = [\n        'did:8004',\n        'did%3A8004',\n        'did8004',\n    ];\n    for (const key of candidateKeys) {\n        const value = params[key];\n        if (!value)\n            continue;\n        const asString = Array.isArray(value) ? value[0] : value;\n        if (typeof asString === 'string' && asString.length > 0) {\n            return decodeURIComponent(asString);\n        }\n    }\n    // Fallback: first value\n    const firstKey = Object.keys(params)[0];\n    if (firstKey) {\n        const value = params[firstKey];\n        if (value) {\n            const asString = Array.isArray(value) ? value[0] : value;\n            if (typeof asString === 'string' && asString.length > 0) {\n                return decodeURIComponent(asString);\n            }\n        }\n    }\n    throw new _core__WEBPACK_IMPORTED_MODULE_0__.AgentApiError('Missing did:8004 parameter', 400);\n}\nfunction updateAgentRegistrationRouteHandler(createContext = defaultContextFactory) {\n    return async (req, context) => {\n        try {\n            const did8004 = extractDidParam(context.params || {});\n            const body = (await req.json());\n            const ctx = createContext(req);\n            const input = {\n                did8004,\n                registration: body?.registration,\n                mode: typeof body?.mode === 'string' ? body.mode : undefined,\n            };\n            const result = await (0,_core__WEBPACK_IMPORTED_MODULE_0__.updateAgentRegistrationCore)(ctx, input);\n            return jsonResponse(result);\n        }\n        catch (error) {\n            return handleNextError(error);\n        }\n    };\n}\nfunction parseNumberParam(value) {\n    if (!value)\n        return undefined;\n    const parsed = Number(value);\n    return Number.isFinite(parsed) ? parsed : undefined;\n}\nfunction requestFeedbackAuthRouteHandler(createContext = defaultContextFactory) {\n    return async (req, context) => {\n        try {\n            console.log(\">>>>>>>>>>>>> feedback auth request: \", req);\n            const url = new URL(req.url);\n            const params = url.searchParams;\n            const isPost = String(req.method || 'GET').toUpperCase() === 'POST';\n            const body = isPost\n                ? (await req.json().catch(() => ({})))\n                : {};\n            let agentIdParam = (isPost && typeof body.agentId === 'string' ? body.agentId : null) ??\n                params.get('agentId') ??\n                (context?.params ? extractDidParam(context.params) : undefined);\n            const parsedDid = agentIdParam && agentIdParam.startsWith('did:8004:')\n                ? (0,_shared_did8004__WEBPACK_IMPORTED_MODULE_2__.parseDid8004)(agentIdParam)\n                : null;\n            const input = {\n                clientAddress: (isPost && typeof body.clientAddress === 'string' ? body.clientAddress : null) ??\n                    params.get('clientAddress') ??\n                    '',\n                agentId: parsedDid ? parsedDid.agentId : (agentIdParam ?? ''),\n                chainId: parsedDid\n                    ? parsedDid.chainId\n                    : (isPost && typeof body.chainId !== 'undefined'\n                        ? parseNumberParam(String(body.chainId))\n                        : parseNumberParam(params.get('chainId'))),\n                indexLimit: isPost && typeof body.indexLimit !== 'undefined'\n                    ? parseNumberParam(String(body.indexLimit))\n                    : parseNumberParam(params.get('indexLimit')),\n                expirySeconds: (isPost && typeof body.expirySeconds !== 'undefined'\n                    ? parseNumberParam(String(body.expirySeconds))\n                    : undefined) ??\n                    (isPost && typeof body.expirySec !== 'undefined'\n                        ? parseNumberParam(String(body.expirySec))\n                        : undefined) ??\n                    parseNumberParam(params.get('expirySec')) ??\n                    parseNumberParam(params.get('expirySeconds')),\n                delegationSar: isPost ? body.delegationSar : undefined,\n            };\n            const ctx = createContext(req);\n            const result = await (0,_core__WEBPACK_IMPORTED_MODULE_0__.requestFeedbackAuthCore)(ctx, input);\n            return jsonResponse(result);\n        }\n        catch (error) {\n            return handleNextError(error);\n        }\n    };\n}\nfunction prepareFeedbackRouteHandler(createContext = defaultContextFactory) {\n    return async (req, context) => {\n        try {\n            const did8004 = extractDidParam(context.params || {});\n            const body = (await req.json());\n            const ctx = createContext(req);\n            const input = {\n                did8004,\n                ...body,\n            };\n            const result = await (0,_core__WEBPACK_IMPORTED_MODULE_0__.prepareFeedbackCore)(ctx, input);\n            return jsonResponse(result);\n        }\n        catch (error) {\n            return handleNextError(error);\n        }\n    };\n}\nfunction prepareValidationRequestRouteHandler(createContext = defaultContextFactory) {\n    return async (req, context) => {\n        try {\n            const did8004 = extractDidParam(context.params || {});\n            const body = (await req.json());\n            const ctx = createContext(req);\n            const input = {\n                did8004,\n                ...body,\n            };\n            const result = await (0,_core__WEBPACK_IMPORTED_MODULE_0__.prepareValidationRequestCore)(ctx, input);\n            return jsonResponse(result);\n        }\n        catch (error) {\n            return handleNextError(error);\n        }\n    };\n}\nfunction prepareAssociationRequestRouteHandler(createContext = defaultContextFactory) {\n    return async (req, context) => {\n        try {\n            const did8004 = extractDidParam(context.params || {});\n            const body = (await req.json());\n            const ctx = createContext(req);\n            const input = {\n                did8004,\n                ...body,\n            };\n            const result = await (0,_core__WEBPACK_IMPORTED_MODULE_0__.prepareAssociationRequestCore)(ctx, input);\n            return jsonResponse(result);\n        }\n        catch (error) {\n            return handleNextError(error);\n        }\n    };\n}\nfunction getFeedbackRouteHandler(createContext = defaultContextFactory) {\n    return async (req, context) => {\n        try {\n            const did8004 = extractDidParam(context.params || {});\n            const url = new URL(req.url);\n            const searchParams = url.searchParams;\n            const includeRevokedParam = searchParams.get('includeRevoked');\n            const includeRevoked = includeRevokedParam === 'true' || includeRevokedParam === '1';\n            const limit = parseNumberParam(searchParams.get('limit')) ?? 100;\n            const offset = parseNumberParam(searchParams.get('offset')) ?? 0;\n            const ctx = createContext(req);\n            const result = await (0,_core__WEBPACK_IMPORTED_MODULE_0__.getFeedbackCore)(ctx, {\n                did8004,\n                includeRevoked,\n                limit,\n                offset,\n            });\n            return jsonResponse(result);\n        }\n        catch (error) {\n            return handleNextError(error);\n        }\n    };\n}\nfunction directFeedbackRouteHandler(createContext = defaultContextFactory) {\n    return async (req, context) => {\n        try {\n            const did8004 = extractDidParam(context.params || {});\n            const body = (await req.json());\n            const ctx = createContext(req);\n            const input = {\n                did8004,\n                ...body,\n            };\n            const result = await (0,_core__WEBPACK_IMPORTED_MODULE_0__.submitFeedbackDirectCore)(ctx, input);\n            return jsonResponse(result);\n        }\n        catch (error) {\n            return handleNextError(error);\n        }\n    };\n}\nfunction getValidationsRouteHandler(createContext = defaultContextFactory) {\n    return async (req, context) => {\n        try {\n            const did8004 = extractDidParam(context.params || {});\n            const parsed = (0,_shared_did8004__WEBPACK_IMPORTED_MODULE_2__.parseDid8004)(did8004);\n            const ctx = createContext(req);\n            const result = await (0,_validations__WEBPACK_IMPORTED_MODULE_1__.getValidationsCore)(ctx, {\n                chainId: parsed.chainId,\n                agentId: parsed.agentId,\n            });\n            console.log('[getValidationsRouteHandler] Result:', {\n                did8004,\n                chainId: parsed.chainId,\n                agentId: parsed.agentId,\n                result,\n                pendingType: typeof result.pending,\n                completedType: typeof result.completed,\n                pendingIsArray: Array.isArray(result.pending),\n                completedIsArray: Array.isArray(result.completed),\n                pendingLength: Array.isArray(result.pending) ? result.pending.length : 'N/A',\n                completedLength: Array.isArray(result.completed) ? result.completed.length : 'N/A',\n            });\n            return jsonResponse(result);\n        }\n        catch (error) {\n            return handleNextError(error);\n        }\n    };\n}\n//# sourceMappingURL=next.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BhZ2VudGljLXRydXN0L2NvcmUvZGlzdC9hcGkvYWdlbnRzL25leHQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQTRPO0FBQ3pMO0FBQ0M7QUFDcEQ7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsb0NBQW9DO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixnREFBYTtBQUN0QztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsc0RBQWU7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxnREFBYTtBQUMzQjtBQUNPO0FBQ1A7QUFDQTtBQUNBLGdFQUFnRTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxrRUFBMkI7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsNkRBQVk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsOERBQXVCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EsZ0VBQWdFO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQywwREFBbUI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSxnRUFBZ0U7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLG1FQUE0QjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLGdFQUFnRTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsb0VBQTZCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EsZ0VBQWdFO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLHNEQUFlO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EsZ0VBQWdFO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQywrREFBd0I7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSxnRUFBZ0U7QUFDaEUsMkJBQTJCLDZEQUFZO0FBQ3ZDO0FBQ0EsaUNBQWlDLGdFQUFrQjtBQUNuRDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvYmFyYi9hYS9Bc3NvY2lhdGVkQWNjb3VudHMvbm9kZV9tb2R1bGVzL0BhZ2VudGljLXRydXN0L2NvcmUvZGlzdC9hcGkvYWdlbnRzL25leHQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQWdlbnRBcGlFcnJvciwgY3JlYXRlQWdlbnRDb3JlLCB1cGRhdGVBZ2VudFJlZ2lzdHJhdGlvbkNvcmUsIHJlcXVlc3RGZWVkYmFja0F1dGhDb3JlLCBwcmVwYXJlRmVlZGJhY2tDb3JlLCBwcmVwYXJlVmFsaWRhdGlvblJlcXVlc3RDb3JlLCBwcmVwYXJlQXNzb2NpYXRpb25SZXF1ZXN0Q29yZSwgZ2V0RmVlZGJhY2tDb3JlLCBzdWJtaXRGZWVkYmFja0RpcmVjdENvcmUsIH0gZnJvbSAnLi9jb3JlJztcbmltcG9ydCB7IGdldFZhbGlkYXRpb25zQ29yZSB9IGZyb20gJy4vdmFsaWRhdGlvbnMnO1xuaW1wb3J0IHsgcGFyc2VEaWQ4MDA0IH0gZnJvbSAnLi4vLi4vc2hhcmVkL2RpZDgwMDQnO1xuY29uc3QgaGFzTmF0aXZlUmVzcG9uc2UgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICB0eXBlb2YgZ2xvYmFsVGhpcy5SZXNwb25zZSA9PT0gJ2Z1bmN0aW9uJztcbmNvbnN0IGRlZmF1bHRDb250ZXh0RmFjdG9yeSA9ICgpID0+ICh7fSk7XG4vLyBSZWN1cnNpdmVseSBjb252ZXJ0IEJpZ0ludCBhbmQgb3RoZXIgbm9uLUpTT04tc2FmZSB2YWx1ZXMgaW50byBKU09OLXNhZmUgZm9ybXMuXG5mdW5jdGlvbiB0b0pzb25TYWZlKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2JpZ2ludCcpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLnRvSVNPU3RyaW5nKCk7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdmFsdWUubWFwKChpdGVtKSA9PiB0b0pzb25TYWZlKGl0ZW0pKTtcbiAgICB9XG4gICAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdl0gb2YgT2JqZWN0LmVudHJpZXModmFsdWUpKSB7XG4gICAgICAgICAgICByZXN1bHRba2V5XSA9IHRvSnNvblNhZmUodik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24ganNvblJlc3BvbnNlKGJvZHksIHN0YXR1cyA9IDIwMCkge1xuICAgIGNvbnN0IHNhZmVCb2R5ID0gdG9Kc29uU2FmZShib2R5KTtcbiAgICBpZiAoaGFzTmF0aXZlUmVzcG9uc2UpIHtcbiAgICAgICAgY29uc3QgUmVzcG9uc2VDdG9yID0gZ2xvYmFsVGhpcy5SZXNwb25zZTtcbiAgICAgICAgcmV0dXJuIG5ldyBSZXNwb25zZUN0b3IoSlNPTi5zdHJpbmdpZnkoc2FmZUJvZHkpLCB7XG4gICAgICAgICAgICBzdGF0dXMsXG4gICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBzdGF0dXMsXG4gICAgICAgIGJvZHk6IHNhZmVCb2R5LFxuICAgICAgICBoZWFkZXJzOiB7ICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcbiAgICB9O1xufVxuZnVuY3Rpb24gaGFuZGxlTmV4dEVycm9yKGVycm9yKSB7XG4gICAgaWYgKGVycm9yIGluc3RhbmNlb2YgQWdlbnRBcGlFcnJvcikge1xuICAgICAgICByZXR1cm4ganNvblJlc3BvbnNlKHtcbiAgICAgICAgICAgIGVycm9yOiBlcnJvci5tZXNzYWdlLFxuICAgICAgICAgICAgZGV0YWlsczogZXJyb3IuZGV0YWlscyxcbiAgICAgICAgfSwgZXJyb3Iuc3RhdHVzID8/IDQwMCk7XG4gICAgfVxuICAgIGNvbnNvbGUuZXJyb3IoJ1tBZ2VudGljVHJ1c3RdW05leHRdIFVuZXhwZWN0ZWQgZXJyb3I6JywgZXJyb3IpO1xuICAgIHJldHVybiBqc29uUmVzcG9uc2Uoe1xuICAgICAgICBlcnJvcjogJ0ludGVybmFsIHNlcnZlciBlcnJvcicsXG4gICAgICAgIG1lc3NhZ2U6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InLFxuICAgIH0sIDUwMCk7XG59XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQWdlbnRSb3V0ZUhhbmRsZXIoY3JlYXRlQ29udGV4dCA9IGRlZmF1bHRDb250ZXh0RmFjdG9yeSkge1xuICAgIHJldHVybiBhc3luYyAocmVxKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBpbnB1dCA9IChhd2FpdCByZXEuanNvbigpKTtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IGNyZWF0ZUNvbnRleHQocmVxKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNyZWF0ZUFnZW50Q29yZShjdHgsIGlucHV0KTtcbiAgICAgICAgICAgIHJldHVybiBqc29uUmVzcG9uc2UocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVOZXh0RXJyb3IoZXJyb3IpO1xuICAgICAgICB9XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGV4dHJhY3REaWRQYXJhbShwYXJhbXMpIHtcbiAgICBjb25zdCBjYW5kaWRhdGVLZXlzID0gW1xuICAgICAgICAnZGlkOjgwMDQnLFxuICAgICAgICAnZGlkJTNBODAwNCcsXG4gICAgICAgICdkaWQ4MDA0JyxcbiAgICBdO1xuICAgIGZvciAoY29uc3Qga2V5IG9mIGNhbmRpZGF0ZUtleXMpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBwYXJhbXNba2V5XTtcbiAgICAgICAgaWYgKCF2YWx1ZSlcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBjb25zdCBhc1N0cmluZyA9IEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWVbMF0gOiB2YWx1ZTtcbiAgICAgICAgaWYgKHR5cGVvZiBhc1N0cmluZyA9PT0gJ3N0cmluZycgJiYgYXNTdHJpbmcubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChhc1N0cmluZyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gRmFsbGJhY2s6IGZpcnN0IHZhbHVlXG4gICAgY29uc3QgZmlyc3RLZXkgPSBPYmplY3Qua2V5cyhwYXJhbXMpWzBdO1xuICAgIGlmIChmaXJzdEtleSkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHBhcmFtc1tmaXJzdEtleV07XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgY29uc3QgYXNTdHJpbmcgPSBBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlWzBdIDogdmFsdWU7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGFzU3RyaW5nID09PSAnc3RyaW5nJyAmJiBhc1N0cmluZy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChhc1N0cmluZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgbmV3IEFnZW50QXBpRXJyb3IoJ01pc3NpbmcgZGlkOjgwMDQgcGFyYW1ldGVyJywgNDAwKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVBZ2VudFJlZ2lzdHJhdGlvblJvdXRlSGFuZGxlcihjcmVhdGVDb250ZXh0ID0gZGVmYXVsdENvbnRleHRGYWN0b3J5KSB7XG4gICAgcmV0dXJuIGFzeW5jIChyZXEsIGNvbnRleHQpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGRpZDgwMDQgPSBleHRyYWN0RGlkUGFyYW0oY29udGV4dC5wYXJhbXMgfHwge30pO1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IChhd2FpdCByZXEuanNvbigpKTtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IGNyZWF0ZUNvbnRleHQocmVxKTtcbiAgICAgICAgICAgIGNvbnN0IGlucHV0ID0ge1xuICAgICAgICAgICAgICAgIGRpZDgwMDQsXG4gICAgICAgICAgICAgICAgcmVnaXN0cmF0aW9uOiBib2R5Py5yZWdpc3RyYXRpb24sXG4gICAgICAgICAgICAgICAgbW9kZTogdHlwZW9mIGJvZHk/Lm1vZGUgPT09ICdzdHJpbmcnID8gYm9keS5tb2RlIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHVwZGF0ZUFnZW50UmVnaXN0cmF0aW9uQ29yZShjdHgsIGlucHV0KTtcbiAgICAgICAgICAgIHJldHVybiBqc29uUmVzcG9uc2UocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVOZXh0RXJyb3IoZXJyb3IpO1xuICAgICAgICB9XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHBhcnNlTnVtYmVyUGFyYW0odmFsdWUpIHtcbiAgICBpZiAoIXZhbHVlKVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIGNvbnN0IHBhcnNlZCA9IE51bWJlcih2YWx1ZSk7XG4gICAgcmV0dXJuIE51bWJlci5pc0Zpbml0ZShwYXJzZWQpID8gcGFyc2VkIDogdW5kZWZpbmVkO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHJlcXVlc3RGZWVkYmFja0F1dGhSb3V0ZUhhbmRsZXIoY3JlYXRlQ29udGV4dCA9IGRlZmF1bHRDb250ZXh0RmFjdG9yeSkge1xuICAgIHJldHVybiBhc3luYyAocmVxLCBjb250ZXh0KSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIj4+Pj4+Pj4+Pj4+Pj4gZmVlZGJhY2sgYXV0aCByZXF1ZXN0OiBcIiwgcmVxKTtcbiAgICAgICAgICAgIGNvbnN0IHVybCA9IG5ldyBVUkwocmVxLnVybCk7XG4gICAgICAgICAgICBjb25zdCBwYXJhbXMgPSB1cmwuc2VhcmNoUGFyYW1zO1xuICAgICAgICAgICAgY29uc3QgaXNQb3N0ID0gU3RyaW5nKHJlcS5tZXRob2QgfHwgJ0dFVCcpLnRvVXBwZXJDYXNlKCkgPT09ICdQT1NUJztcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBpc1Bvc3RcbiAgICAgICAgICAgICAgICA/IChhd2FpdCByZXEuanNvbigpLmNhdGNoKCgpID0+ICh7fSkpKVxuICAgICAgICAgICAgICAgIDoge307XG4gICAgICAgICAgICBsZXQgYWdlbnRJZFBhcmFtID0gKGlzUG9zdCAmJiB0eXBlb2YgYm9keS5hZ2VudElkID09PSAnc3RyaW5nJyA/IGJvZHkuYWdlbnRJZCA6IG51bGwpID8/XG4gICAgICAgICAgICAgICAgcGFyYW1zLmdldCgnYWdlbnRJZCcpID8/XG4gICAgICAgICAgICAgICAgKGNvbnRleHQ/LnBhcmFtcyA/IGV4dHJhY3REaWRQYXJhbShjb250ZXh0LnBhcmFtcykgOiB1bmRlZmluZWQpO1xuICAgICAgICAgICAgY29uc3QgcGFyc2VkRGlkID0gYWdlbnRJZFBhcmFtICYmIGFnZW50SWRQYXJhbS5zdGFydHNXaXRoKCdkaWQ6ODAwNDonKVxuICAgICAgICAgICAgICAgID8gcGFyc2VEaWQ4MDA0KGFnZW50SWRQYXJhbSlcbiAgICAgICAgICAgICAgICA6IG51bGw7XG4gICAgICAgICAgICBjb25zdCBpbnB1dCA9IHtcbiAgICAgICAgICAgICAgICBjbGllbnRBZGRyZXNzOiAoaXNQb3N0ICYmIHR5cGVvZiBib2R5LmNsaWVudEFkZHJlc3MgPT09ICdzdHJpbmcnID8gYm9keS5jbGllbnRBZGRyZXNzIDogbnVsbCkgPz9cbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zLmdldCgnY2xpZW50QWRkcmVzcycpID8/XG4gICAgICAgICAgICAgICAgICAgICcnLFxuICAgICAgICAgICAgICAgIGFnZW50SWQ6IHBhcnNlZERpZCA/IHBhcnNlZERpZC5hZ2VudElkIDogKGFnZW50SWRQYXJhbSA/PyAnJyksXG4gICAgICAgICAgICAgICAgY2hhaW5JZDogcGFyc2VkRGlkXG4gICAgICAgICAgICAgICAgICAgID8gcGFyc2VkRGlkLmNoYWluSWRcbiAgICAgICAgICAgICAgICAgICAgOiAoaXNQb3N0ICYmIHR5cGVvZiBib2R5LmNoYWluSWQgIT09ICd1bmRlZmluZWQnXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHBhcnNlTnVtYmVyUGFyYW0oU3RyaW5nKGJvZHkuY2hhaW5JZCkpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHBhcnNlTnVtYmVyUGFyYW0ocGFyYW1zLmdldCgnY2hhaW5JZCcpKSksXG4gICAgICAgICAgICAgICAgaW5kZXhMaW1pdDogaXNQb3N0ICYmIHR5cGVvZiBib2R5LmluZGV4TGltaXQgIT09ICd1bmRlZmluZWQnXG4gICAgICAgICAgICAgICAgICAgID8gcGFyc2VOdW1iZXJQYXJhbShTdHJpbmcoYm9keS5pbmRleExpbWl0KSlcbiAgICAgICAgICAgICAgICAgICAgOiBwYXJzZU51bWJlclBhcmFtKHBhcmFtcy5nZXQoJ2luZGV4TGltaXQnKSksXG4gICAgICAgICAgICAgICAgZXhwaXJ5U2Vjb25kczogKGlzUG9zdCAmJiB0eXBlb2YgYm9keS5leHBpcnlTZWNvbmRzICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICAgICAgICAgICAgICA/IHBhcnNlTnVtYmVyUGFyYW0oU3RyaW5nKGJvZHkuZXhwaXJ5U2Vjb25kcykpXG4gICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkKSA/P1xuICAgICAgICAgICAgICAgICAgICAoaXNQb3N0ICYmIHR5cGVvZiBib2R5LmV4cGlyeVNlYyAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgICAgICAgICAgICAgICAgID8gcGFyc2VOdW1iZXJQYXJhbShTdHJpbmcoYm9keS5leHBpcnlTZWMpKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQpID8/XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlTnVtYmVyUGFyYW0ocGFyYW1zLmdldCgnZXhwaXJ5U2VjJykpID8/XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlTnVtYmVyUGFyYW0ocGFyYW1zLmdldCgnZXhwaXJ5U2Vjb25kcycpKSxcbiAgICAgICAgICAgICAgICBkZWxlZ2F0aW9uU2FyOiBpc1Bvc3QgPyBib2R5LmRlbGVnYXRpb25TYXIgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgY3R4ID0gY3JlYXRlQ29udGV4dChyZXEpO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVxdWVzdEZlZWRiYWNrQXV0aENvcmUoY3R4LCBpbnB1dCk7XG4gICAgICAgICAgICByZXR1cm4ganNvblJlc3BvbnNlKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlTmV4dEVycm9yKGVycm9yKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5leHBvcnQgZnVuY3Rpb24gcHJlcGFyZUZlZWRiYWNrUm91dGVIYW5kbGVyKGNyZWF0ZUNvbnRleHQgPSBkZWZhdWx0Q29udGV4dEZhY3RvcnkpIHtcbiAgICByZXR1cm4gYXN5bmMgKHJlcSwgY29udGV4dCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgZGlkODAwNCA9IGV4dHJhY3REaWRQYXJhbShjb250ZXh0LnBhcmFtcyB8fCB7fSk7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gKGF3YWl0IHJlcS5qc29uKCkpO1xuICAgICAgICAgICAgY29uc3QgY3R4ID0gY3JlYXRlQ29udGV4dChyZXEpO1xuICAgICAgICAgICAgY29uc3QgaW5wdXQgPSB7XG4gICAgICAgICAgICAgICAgZGlkODAwNCxcbiAgICAgICAgICAgICAgICAuLi5ib2R5LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHByZXBhcmVGZWVkYmFja0NvcmUoY3R4LCBpbnB1dCk7XG4gICAgICAgICAgICByZXR1cm4ganNvblJlc3BvbnNlKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlTmV4dEVycm9yKGVycm9yKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5leHBvcnQgZnVuY3Rpb24gcHJlcGFyZVZhbGlkYXRpb25SZXF1ZXN0Um91dGVIYW5kbGVyKGNyZWF0ZUNvbnRleHQgPSBkZWZhdWx0Q29udGV4dEZhY3RvcnkpIHtcbiAgICByZXR1cm4gYXN5bmMgKHJlcSwgY29udGV4dCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgZGlkODAwNCA9IGV4dHJhY3REaWRQYXJhbShjb250ZXh0LnBhcmFtcyB8fCB7fSk7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gKGF3YWl0IHJlcS5qc29uKCkpO1xuICAgICAgICAgICAgY29uc3QgY3R4ID0gY3JlYXRlQ29udGV4dChyZXEpO1xuICAgICAgICAgICAgY29uc3QgaW5wdXQgPSB7XG4gICAgICAgICAgICAgICAgZGlkODAwNCxcbiAgICAgICAgICAgICAgICAuLi5ib2R5LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHByZXBhcmVWYWxpZGF0aW9uUmVxdWVzdENvcmUoY3R4LCBpbnB1dCk7XG4gICAgICAgICAgICByZXR1cm4ganNvblJlc3BvbnNlKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlTmV4dEVycm9yKGVycm9yKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5leHBvcnQgZnVuY3Rpb24gcHJlcGFyZUFzc29jaWF0aW9uUmVxdWVzdFJvdXRlSGFuZGxlcihjcmVhdGVDb250ZXh0ID0gZGVmYXVsdENvbnRleHRGYWN0b3J5KSB7XG4gICAgcmV0dXJuIGFzeW5jIChyZXEsIGNvbnRleHQpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGRpZDgwMDQgPSBleHRyYWN0RGlkUGFyYW0oY29udGV4dC5wYXJhbXMgfHwge30pO1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IChhd2FpdCByZXEuanNvbigpKTtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IGNyZWF0ZUNvbnRleHQocmVxKTtcbiAgICAgICAgICAgIGNvbnN0IGlucHV0ID0ge1xuICAgICAgICAgICAgICAgIGRpZDgwMDQsXG4gICAgICAgICAgICAgICAgLi4uYm9keSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBwcmVwYXJlQXNzb2NpYXRpb25SZXF1ZXN0Q29yZShjdHgsIGlucHV0KTtcbiAgICAgICAgICAgIHJldHVybiBqc29uUmVzcG9uc2UocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVOZXh0RXJyb3IoZXJyb3IpO1xuICAgICAgICB9XG4gICAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRGZWVkYmFja1JvdXRlSGFuZGxlcihjcmVhdGVDb250ZXh0ID0gZGVmYXVsdENvbnRleHRGYWN0b3J5KSB7XG4gICAgcmV0dXJuIGFzeW5jIChyZXEsIGNvbnRleHQpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGRpZDgwMDQgPSBleHRyYWN0RGlkUGFyYW0oY29udGV4dC5wYXJhbXMgfHwge30pO1xuICAgICAgICAgICAgY29uc3QgdXJsID0gbmV3IFVSTChyZXEudXJsKTtcbiAgICAgICAgICAgIGNvbnN0IHNlYXJjaFBhcmFtcyA9IHVybC5zZWFyY2hQYXJhbXM7XG4gICAgICAgICAgICBjb25zdCBpbmNsdWRlUmV2b2tlZFBhcmFtID0gc2VhcmNoUGFyYW1zLmdldCgnaW5jbHVkZVJldm9rZWQnKTtcbiAgICAgICAgICAgIGNvbnN0IGluY2x1ZGVSZXZva2VkID0gaW5jbHVkZVJldm9rZWRQYXJhbSA9PT0gJ3RydWUnIHx8IGluY2x1ZGVSZXZva2VkUGFyYW0gPT09ICcxJztcbiAgICAgICAgICAgIGNvbnN0IGxpbWl0ID0gcGFyc2VOdW1iZXJQYXJhbShzZWFyY2hQYXJhbXMuZ2V0KCdsaW1pdCcpKSA/PyAxMDA7XG4gICAgICAgICAgICBjb25zdCBvZmZzZXQgPSBwYXJzZU51bWJlclBhcmFtKHNlYXJjaFBhcmFtcy5nZXQoJ29mZnNldCcpKSA/PyAwO1xuICAgICAgICAgICAgY29uc3QgY3R4ID0gY3JlYXRlQ29udGV4dChyZXEpO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZ2V0RmVlZGJhY2tDb3JlKGN0eCwge1xuICAgICAgICAgICAgICAgIGRpZDgwMDQsXG4gICAgICAgICAgICAgICAgaW5jbHVkZVJldm9rZWQsXG4gICAgICAgICAgICAgICAgbGltaXQsXG4gICAgICAgICAgICAgICAgb2Zmc2V0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4ganNvblJlc3BvbnNlKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlTmV4dEVycm9yKGVycm9yKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5leHBvcnQgZnVuY3Rpb24gZGlyZWN0RmVlZGJhY2tSb3V0ZUhhbmRsZXIoY3JlYXRlQ29udGV4dCA9IGRlZmF1bHRDb250ZXh0RmFjdG9yeSkge1xuICAgIHJldHVybiBhc3luYyAocmVxLCBjb250ZXh0KSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBkaWQ4MDA0ID0gZXh0cmFjdERpZFBhcmFtKGNvbnRleHQucGFyYW1zIHx8IHt9KTtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSAoYXdhaXQgcmVxLmpzb24oKSk7XG4gICAgICAgICAgICBjb25zdCBjdHggPSBjcmVhdGVDb250ZXh0KHJlcSk7XG4gICAgICAgICAgICBjb25zdCBpbnB1dCA9IHtcbiAgICAgICAgICAgICAgICBkaWQ4MDA0LFxuICAgICAgICAgICAgICAgIC4uLmJvZHksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc3VibWl0RmVlZGJhY2tEaXJlY3RDb3JlKGN0eCwgaW5wdXQpO1xuICAgICAgICAgICAgcmV0dXJuIGpzb25SZXNwb25zZShyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZU5leHRFcnJvcihlcnJvcik7XG4gICAgICAgIH1cbiAgICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldFZhbGlkYXRpb25zUm91dGVIYW5kbGVyKGNyZWF0ZUNvbnRleHQgPSBkZWZhdWx0Q29udGV4dEZhY3RvcnkpIHtcbiAgICByZXR1cm4gYXN5bmMgKHJlcSwgY29udGV4dCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgZGlkODAwNCA9IGV4dHJhY3REaWRQYXJhbShjb250ZXh0LnBhcmFtcyB8fCB7fSk7XG4gICAgICAgICAgICBjb25zdCBwYXJzZWQgPSBwYXJzZURpZDgwMDQoZGlkODAwNCk7XG4gICAgICAgICAgICBjb25zdCBjdHggPSBjcmVhdGVDb250ZXh0KHJlcSk7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBnZXRWYWxpZGF0aW9uc0NvcmUoY3R4LCB7XG4gICAgICAgICAgICAgICAgY2hhaW5JZDogcGFyc2VkLmNoYWluSWQsXG4gICAgICAgICAgICAgICAgYWdlbnRJZDogcGFyc2VkLmFnZW50SWQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdbZ2V0VmFsaWRhdGlvbnNSb3V0ZUhhbmRsZXJdIFJlc3VsdDonLCB7XG4gICAgICAgICAgICAgICAgZGlkODAwNCxcbiAgICAgICAgICAgICAgICBjaGFpbklkOiBwYXJzZWQuY2hhaW5JZCxcbiAgICAgICAgICAgICAgICBhZ2VudElkOiBwYXJzZWQuYWdlbnRJZCxcbiAgICAgICAgICAgICAgICByZXN1bHQsXG4gICAgICAgICAgICAgICAgcGVuZGluZ1R5cGU6IHR5cGVvZiByZXN1bHQucGVuZGluZyxcbiAgICAgICAgICAgICAgICBjb21wbGV0ZWRUeXBlOiB0eXBlb2YgcmVzdWx0LmNvbXBsZXRlZCxcbiAgICAgICAgICAgICAgICBwZW5kaW5nSXNBcnJheTogQXJyYXkuaXNBcnJheShyZXN1bHQucGVuZGluZyksXG4gICAgICAgICAgICAgICAgY29tcGxldGVkSXNBcnJheTogQXJyYXkuaXNBcnJheShyZXN1bHQuY29tcGxldGVkKSxcbiAgICAgICAgICAgICAgICBwZW5kaW5nTGVuZ3RoOiBBcnJheS5pc0FycmF5KHJlc3VsdC5wZW5kaW5nKSA/IHJlc3VsdC5wZW5kaW5nLmxlbmd0aCA6ICdOL0EnLFxuICAgICAgICAgICAgICAgIGNvbXBsZXRlZExlbmd0aDogQXJyYXkuaXNBcnJheShyZXN1bHQuY29tcGxldGVkKSA/IHJlc3VsdC5jb21wbGV0ZWQubGVuZ3RoIDogJ04vQScsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBqc29uUmVzcG9uc2UocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVOZXh0RXJyb3IoZXJyb3IpO1xuICAgICAgICB9XG4gICAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5leHQuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@agentic-trust/core/dist/api/agents/next.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@agentic-trust/core/dist/api/agents/validations.js":
/*!*****************************************************************************!*\
  !*** ../../node_modules/@agentic-trust/core/dist/api/agents/validations.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getValidationsCore: () => (/* binding */ getValidationsCore)\n/* harmony export */ });\n/* harmony import */ var _server_lib_validations__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../server/lib/validations */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/lib/validations.js\");\n\nasync function getValidationsCore(ctx, input) {\n    const summary = await (0,_server_lib_validations__WEBPACK_IMPORTED_MODULE_0__.getAgentValidationsSummary)(input.chainId, input.agentId);\n    return {\n        success: true,\n        agentId: summary.agentId,\n        chainId: summary.chainId,\n        did8004: summary.did8004,\n        pending: summary.pending,\n        completed: summary.completed,\n    };\n}\n//# sourceMappingURL=validations.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BhZ2VudGljLXRydXN0L2NvcmUvZGlzdC9hcGkvYWdlbnRzL3ZhbGlkYXRpb25zLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQTBFO0FBQ25FO0FBQ1AsMEJBQTBCLG1GQUEwQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvYmFyYi9hYS9Bc3NvY2lhdGVkQWNjb3VudHMvbm9kZV9tb2R1bGVzL0BhZ2VudGljLXRydXN0L2NvcmUvZGlzdC9hcGkvYWdlbnRzL3ZhbGlkYXRpb25zLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGdldEFnZW50VmFsaWRhdGlvbnNTdW1tYXJ5IH0gZnJvbSAnLi4vLi4vc2VydmVyL2xpYi92YWxpZGF0aW9ucyc7XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0VmFsaWRhdGlvbnNDb3JlKGN0eCwgaW5wdXQpIHtcbiAgICBjb25zdCBzdW1tYXJ5ID0gYXdhaXQgZ2V0QWdlbnRWYWxpZGF0aW9uc1N1bW1hcnkoaW5wdXQuY2hhaW5JZCwgaW5wdXQuYWdlbnRJZCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgYWdlbnRJZDogc3VtbWFyeS5hZ2VudElkLFxuICAgICAgICBjaGFpbklkOiBzdW1tYXJ5LmNoYWluSWQsXG4gICAgICAgIGRpZDgwMDQ6IHN1bW1hcnkuZGlkODAwNCxcbiAgICAgICAgcGVuZGluZzogc3VtbWFyeS5wZW5kaW5nLFxuICAgICAgICBjb21wbGV0ZWQ6IHN1bW1hcnkuY29tcGxldGVkLFxuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD12YWxpZGF0aW9ucy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@agentic-trust/core/dist/api/agents/validations.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@agentic-trust/core/dist/api/search/next.js":
/*!**********************************************************************!*\
  !*** ../../node_modules/@agentic-trust/core/dist/api/search/next.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   searchAgentsGetRouteHandler: () => (/* binding */ searchAgentsGetRouteHandler),\n/* harmony export */   searchAgentsPostRouteHandler: () => (/* binding */ searchAgentsPostRouteHandler),\n/* harmony export */   semanticAgentSearchPostRouteHandler: () => (/* binding */ semanticAgentSearchPostRouteHandler)\n/* harmony export */ });\n/* harmony import */ var _server_lib_discover__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../server/lib/discover */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/lib/discover.js\");\n/* harmony import */ var _server_lib_agenticTrust__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../server/lib/agenticTrust */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/lib/agenticTrust.js\");\n/* harmony import */ var _server_singletons_discoveryClient__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../server/singletons/discoveryClient */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/singletons/discoveryClient.js\");\n\n\n\nconst hasNativeResponse = typeof globalThis !== 'undefined' &&\n    typeof globalThis.Response === 'function';\nfunction jsonResponse(body, status = 200) {\n    if (hasNativeResponse) {\n        const ResponseCtor = globalThis.Response;\n        return new ResponseCtor(JSON.stringify(body), {\n            status,\n            headers: {\n                'content-type': 'application/json',\n            },\n        });\n    }\n    return {\n        status,\n        body,\n        headers: { 'content-type': 'application/json' },\n    };\n}\nfunction handleError(error) {\n    // eslint-disable-next-line no-console\n    console.error('[AgenticTrust][Search][Next] Unexpected error:', error);\n    return jsonResponse({\n        error: 'Failed to search agents',\n        message: error instanceof Error ? error.message : 'Unknown error',\n        details:  true && error instanceof Error ? error.stack : undefined,\n    }, 500);\n}\nconst DEFAULT_PAGE_SIZE = 10;\nfunction toNumber(value) {\n    if (!value)\n        return undefined;\n    const parsed = Number.parseInt(value, 10);\n    return Number.isFinite(parsed) ? parsed : undefined;\n}\nfunction mapAgentsResponse(data) {\n    const { agents = [], total, page, pageSize, totalPages } = data;\n    return {\n        success: true,\n        agents,\n        total,\n        page: page ?? 1,\n        pageSize: pageSize ?? agents.length,\n        totalPages: totalPages ??\n            Math.max(1, Math.ceil((total ?? agents.length) / (pageSize ?? Math.max(agents.length, 1)))),\n    };\n}\nfunction parseParamsParam(raw) {\n    if (!raw)\n        return undefined;\n    try {\n        const parsed = JSON.parse(raw);\n        return parsed && typeof parsed === 'object' ? parsed : undefined;\n    }\n    catch {\n        return undefined;\n    }\n}\nasync function executeSearch(options) {\n    console.log('[AgenticTrust][Search] Executing search with options:', JSON.stringify(options, null, 2));\n    const result = await (0,_server_lib_discover__WEBPACK_IMPORTED_MODULE_0__.discoverAgents)(options, _server_lib_agenticTrust__WEBPACK_IMPORTED_MODULE_1__.getAgenticTrustClient);\n    // Log sample validation counts if agents found\n    if (result.agents && result.agents.length > 0) {\n        const sample = result.agents[0];\n        if (sample) {\n            console.log('[AgenticTrust][Search] First agent result validation stats:', {\n                id: sample.agentId,\n                pending: sample.validationPendingCount,\n                completed: sample.validationCompletedCount,\n                requested: sample.validationRequestedCount\n            });\n            console.log('[AgenticTrust][Search] First agent result association stats:', {\n                id: sample.agentId,\n                initiated: sample.initiatedAssociationCount,\n                approved: sample.approvedAssociationCount,\n            });\n        }\n    }\n    return result;\n}\nfunction searchAgentsGetRouteHandler() {\n    return async (req) => {\n        try {\n            const url = new URL(req.url);\n            const urlParams = url.searchParams;\n            const page = toNumber(urlParams.get('page'));\n            const pageSize = toNumber(urlParams.get('pageSize')) ?? DEFAULT_PAGE_SIZE;\n            const query = urlParams.get('query')?.trim();\n            const params = parseParamsParam(urlParams.get('params'));\n            const orderBy = urlParams.get('orderBy')?.trim() || undefined;\n            const orderDirectionRaw = urlParams.get('orderDirection')?.trim().toUpperCase();\n            const orderDirection = orderDirectionRaw === 'ASC' || orderDirectionRaw === 'DESC'\n                ? orderDirectionRaw\n                : undefined;\n            const requestedPage = page ?? 1;\n            const requestedPageSize = pageSize;\n            const minAssociations = params && typeof params.minAssociations === 'number' && Number.isFinite(params.minAssociations)\n                ? params.minAssociations\n                : undefined;\n            const needsAssocFilter = typeof minAssociations === 'number' && minAssociations > 0;\n            const response = await executeSearch({\n                page: needsAssocFilter ? 1 : requestedPage,\n                pageSize: needsAssocFilter ? Math.max(2000, requestedPageSize) : requestedPageSize,\n                query: query && query.length > 0 ? query : undefined,\n                params,\n                orderBy,\n                orderDirection,\n            });\n            if (!needsAssocFilter) {\n                return jsonResponse(mapAgentsResponse(response));\n            }\n            const agents = Array.isArray(response.agents) ? response.agents : [];\n            const filtered = agents.filter((a) => {\n                const initiated = typeof a?.initiatedAssociationCount === 'number' ? a.initiatedAssociationCount : 0;\n                const approved = typeof a?.approvedAssociationCount === 'number' ? a.approvedAssociationCount : 0;\n                return initiated + approved >= minAssociations;\n            });\n            const start = Math.max(0, (requestedPage - 1) * requestedPageSize);\n            const end = start + requestedPageSize;\n            const paged = filtered.slice(start, end);\n            return jsonResponse({\n                success: true,\n                agents: paged,\n                total: filtered.length,\n                page: requestedPage,\n                pageSize: requestedPageSize,\n                totalPages: Math.max(1, Math.ceil(filtered.length / Math.max(1, requestedPageSize))),\n            });\n        }\n        catch (error) {\n            return handleError(error);\n        }\n    };\n}\nfunction searchAgentsPostRouteHandler() {\n    return async (req) => {\n        try {\n            const body = (await req.json().catch(() => ({})));\n            const page = typeof body.page === 'number' && Number.isFinite(body.page)\n                ? body.page\n                : undefined;\n            const pageSize = typeof body.pageSize === 'number' && Number.isFinite(body.pageSize)\n                ? body.pageSize\n                : DEFAULT_PAGE_SIZE;\n            const query = typeof body.query === 'string' && body.query.trim().length > 0\n                ? body.query.trim()\n                : undefined;\n            const params = body.params && typeof body.params === 'object'\n                ? body.params\n                : undefined;\n            const orderBy = typeof body.orderBy === 'string' && body.orderBy.trim().length > 0\n                ? body.orderBy.trim()\n                : undefined;\n            const orderDirectionRaw = typeof body.orderDirection === 'string'\n                ? body.orderDirection.toUpperCase()\n                : undefined;\n            const orderDirection = orderDirectionRaw === 'ASC' || orderDirectionRaw === 'DESC'\n                ? orderDirectionRaw\n                : undefined;\n            const requestedPage = page ?? 1;\n            const requestedPageSize = pageSize;\n            const minAssociations = params && typeof params.minAssociations === 'number' && Number.isFinite(params.minAssociations)\n                ? params.minAssociations\n                : undefined;\n            const needsAssocFilter = typeof minAssociations === 'number' && minAssociations > 0;\n            const response = await executeSearch({\n                page: needsAssocFilter ? 1 : requestedPage,\n                pageSize: needsAssocFilter ? Math.max(2000, requestedPageSize) : requestedPageSize,\n                query,\n                params,\n                orderBy,\n                orderDirection,\n            });\n            if (!needsAssocFilter) {\n                return jsonResponse(mapAgentsResponse(response));\n            }\n            const agents = Array.isArray(response.agents) ? response.agents : [];\n            const filtered = agents.filter((a) => {\n                const initiated = typeof a?.initiatedAssociationCount === 'number' ? a.initiatedAssociationCount : 0;\n                const approved = typeof a?.approvedAssociationCount === 'number' ? a.approvedAssociationCount : 0;\n                return initiated + approved >= minAssociations;\n            });\n            const start = Math.max(0, (requestedPage - 1) * requestedPageSize);\n            const end = start + requestedPageSize;\n            const paged = filtered.slice(start, end);\n            return jsonResponse({\n                success: true,\n                agents: paged,\n                total: filtered.length,\n                page: requestedPage,\n                pageSize: requestedPageSize,\n                totalPages: Math.max(1, Math.ceil(filtered.length / Math.max(1, requestedPageSize))),\n            });\n        }\n        catch (error) {\n            return handleError(error);\n        }\n    };\n}\nfunction semanticAgentSearchPostRouteHandler() {\n    return async (req) => {\n        try {\n            const body = (await req.json().catch(() => ({})));\n            const rawIntentJson = typeof body.intentJson === 'string'\n                ? body.intentJson\n                : typeof body.intent === 'string'\n                    ? body.intent\n                    : '';\n            const intentJson = rawIntentJson.trim();\n            const topKRaw = body.topK;\n            const topK = typeof topKRaw === 'number' && Number.isFinite(topKRaw) && topKRaw > 0\n                ? Math.floor(topKRaw)\n                : typeof topKRaw === 'string' && topKRaw.trim()\n                    ? Math.max(1, Math.floor(Number(topKRaw)))\n                    : undefined;\n            const rawText = typeof body.text === 'string'\n                ? body.text\n                : typeof body.query === 'string'\n                    ? body.query\n                    : '';\n            const text = rawText.trim();\n            if (!text && !intentJson) {\n                return jsonResponse({\n                    success: true,\n                    total: 0,\n                    matches: [],\n                });\n            }\n            const discoveryClient = await (0,_server_singletons_discoveryClient__WEBPACK_IMPORTED_MODULE_2__.getDiscoveryClient)();\n            const result = await discoveryClient.semanticAgentSearch(intentJson ? { intentJson, topK } : { text });\n            const total = result && typeof result.total === 'number' && Number.isFinite(result.total)\n                ? result.total\n                : 0;\n            const matches = Array.isArray(result?.matches) ? result.matches : [];\n            return jsonResponse({\n                success: true,\n                total,\n                matches,\n            });\n        }\n        catch (error) {\n            return handleError(error);\n        }\n    };\n}\n//# sourceMappingURL=next.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BhZ2VudGljLXRydXN0L2NvcmUvZGlzdC9hcGkvc2VhcmNoL25leHQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQTJEO0FBQ1c7QUFDTztBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG9DQUFvQztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLEtBQXNDO0FBQ3ZELEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGlEQUFpRDtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLG9FQUFjLFVBQVUsMkVBQXFCO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsMENBQTBDLHNGQUFrQjtBQUM1RCxvRkFBb0YsbUJBQW1CLElBQUksTUFBTTtBQUNqSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9iYXJiL2FhL0Fzc29jaWF0ZWRBY2NvdW50cy9ub2RlX21vZHVsZXMvQGFnZW50aWMtdHJ1c3QvY29yZS9kaXN0L2FwaS9zZWFyY2gvbmV4dC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBkaXNjb3ZlckFnZW50cyB9IGZyb20gJy4uLy4uL3NlcnZlci9saWIvZGlzY292ZXInO1xuaW1wb3J0IHsgZ2V0QWdlbnRpY1RydXN0Q2xpZW50IH0gZnJvbSAnLi4vLi4vc2VydmVyL2xpYi9hZ2VudGljVHJ1c3QnO1xuaW1wb3J0IHsgZ2V0RGlzY292ZXJ5Q2xpZW50IH0gZnJvbSAnLi4vLi4vc2VydmVyL3NpbmdsZXRvbnMvZGlzY292ZXJ5Q2xpZW50JztcbmNvbnN0IGhhc05hdGl2ZVJlc3BvbnNlID0gdHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnICYmXG4gICAgdHlwZW9mIGdsb2JhbFRoaXMuUmVzcG9uc2UgPT09ICdmdW5jdGlvbic7XG5mdW5jdGlvbiBqc29uUmVzcG9uc2UoYm9keSwgc3RhdHVzID0gMjAwKSB7XG4gICAgaWYgKGhhc05hdGl2ZVJlc3BvbnNlKSB7XG4gICAgICAgIGNvbnN0IFJlc3BvbnNlQ3RvciA9IGdsb2JhbFRoaXMuUmVzcG9uc2U7XG4gICAgICAgIHJldHVybiBuZXcgUmVzcG9uc2VDdG9yKEpTT04uc3RyaW5naWZ5KGJvZHkpLCB7XG4gICAgICAgICAgICBzdGF0dXMsXG4gICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBzdGF0dXMsXG4gICAgICAgIGJvZHksXG4gICAgICAgIGhlYWRlcnM6IHsgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9LFxuICAgIH07XG59XG5mdW5jdGlvbiBoYW5kbGVFcnJvcihlcnJvcikge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgY29uc29sZS5lcnJvcignW0FnZW50aWNUcnVzdF1bU2VhcmNoXVtOZXh0XSBVbmV4cGVjdGVkIGVycm9yOicsIGVycm9yKTtcbiAgICByZXR1cm4ganNvblJlc3BvbnNlKHtcbiAgICAgICAgZXJyb3I6ICdGYWlsZWQgdG8gc2VhcmNoIGFnZW50cycsXG4gICAgICAgIG1lc3NhZ2U6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InLFxuICAgICAgICBkZXRhaWxzOiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyAmJiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3Iuc3RhY2sgOiB1bmRlZmluZWQsXG4gICAgfSwgNTAwKTtcbn1cbmNvbnN0IERFRkFVTFRfUEFHRV9TSVpFID0gMTA7XG5mdW5jdGlvbiB0b051bWJlcih2YWx1ZSkge1xuICAgIGlmICghdmFsdWUpXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgY29uc3QgcGFyc2VkID0gTnVtYmVyLnBhcnNlSW50KHZhbHVlLCAxMCk7XG4gICAgcmV0dXJuIE51bWJlci5pc0Zpbml0ZShwYXJzZWQpID8gcGFyc2VkIDogdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gbWFwQWdlbnRzUmVzcG9uc2UoZGF0YSkge1xuICAgIGNvbnN0IHsgYWdlbnRzID0gW10sIHRvdGFsLCBwYWdlLCBwYWdlU2l6ZSwgdG90YWxQYWdlcyB9ID0gZGF0YTtcbiAgICByZXR1cm4ge1xuICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICBhZ2VudHMsXG4gICAgICAgIHRvdGFsLFxuICAgICAgICBwYWdlOiBwYWdlID8/IDEsXG4gICAgICAgIHBhZ2VTaXplOiBwYWdlU2l6ZSA/PyBhZ2VudHMubGVuZ3RoLFxuICAgICAgICB0b3RhbFBhZ2VzOiB0b3RhbFBhZ2VzID8/XG4gICAgICAgICAgICBNYXRoLm1heCgxLCBNYXRoLmNlaWwoKHRvdGFsID8/IGFnZW50cy5sZW5ndGgpIC8gKHBhZ2VTaXplID8/IE1hdGgubWF4KGFnZW50cy5sZW5ndGgsIDEpKSkpLFxuICAgIH07XG59XG5mdW5jdGlvbiBwYXJzZVBhcmFtc1BhcmFtKHJhdykge1xuICAgIGlmICghcmF3KVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZCA9IEpTT04ucGFyc2UocmF3KTtcbiAgICAgICAgcmV0dXJuIHBhcnNlZCAmJiB0eXBlb2YgcGFyc2VkID09PSAnb2JqZWN0JyA/IHBhcnNlZCA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgY2F0Y2gge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGV4ZWN1dGVTZWFyY2gob3B0aW9ucykge1xuICAgIGNvbnNvbGUubG9nKCdbQWdlbnRpY1RydXN0XVtTZWFyY2hdIEV4ZWN1dGluZyBzZWFyY2ggd2l0aCBvcHRpb25zOicsIEpTT04uc3RyaW5naWZ5KG9wdGlvbnMsIG51bGwsIDIpKTtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBkaXNjb3ZlckFnZW50cyhvcHRpb25zLCBnZXRBZ2VudGljVHJ1c3RDbGllbnQpO1xuICAgIC8vIExvZyBzYW1wbGUgdmFsaWRhdGlvbiBjb3VudHMgaWYgYWdlbnRzIGZvdW5kXG4gICAgaWYgKHJlc3VsdC5hZ2VudHMgJiYgcmVzdWx0LmFnZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IHNhbXBsZSA9IHJlc3VsdC5hZ2VudHNbMF07XG4gICAgICAgIGlmIChzYW1wbGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdbQWdlbnRpY1RydXN0XVtTZWFyY2hdIEZpcnN0IGFnZW50IHJlc3VsdCB2YWxpZGF0aW9uIHN0YXRzOicsIHtcbiAgICAgICAgICAgICAgICBpZDogc2FtcGxlLmFnZW50SWQsXG4gICAgICAgICAgICAgICAgcGVuZGluZzogc2FtcGxlLnZhbGlkYXRpb25QZW5kaW5nQ291bnQsXG4gICAgICAgICAgICAgICAgY29tcGxldGVkOiBzYW1wbGUudmFsaWRhdGlvbkNvbXBsZXRlZENvdW50LFxuICAgICAgICAgICAgICAgIHJlcXVlc3RlZDogc2FtcGxlLnZhbGlkYXRpb25SZXF1ZXN0ZWRDb3VudFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnW0FnZW50aWNUcnVzdF1bU2VhcmNoXSBGaXJzdCBhZ2VudCByZXN1bHQgYXNzb2NpYXRpb24gc3RhdHM6Jywge1xuICAgICAgICAgICAgICAgIGlkOiBzYW1wbGUuYWdlbnRJZCxcbiAgICAgICAgICAgICAgICBpbml0aWF0ZWQ6IHNhbXBsZS5pbml0aWF0ZWRBc3NvY2lhdGlvbkNvdW50LFxuICAgICAgICAgICAgICAgIGFwcHJvdmVkOiBzYW1wbGUuYXBwcm92ZWRBc3NvY2lhdGlvbkNvdW50LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBzZWFyY2hBZ2VudHNHZXRSb3V0ZUhhbmRsZXIoKSB7XG4gICAgcmV0dXJuIGFzeW5jIChyZXEpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHVybCA9IG5ldyBVUkwocmVxLnVybCk7XG4gICAgICAgICAgICBjb25zdCB1cmxQYXJhbXMgPSB1cmwuc2VhcmNoUGFyYW1zO1xuICAgICAgICAgICAgY29uc3QgcGFnZSA9IHRvTnVtYmVyKHVybFBhcmFtcy5nZXQoJ3BhZ2UnKSk7XG4gICAgICAgICAgICBjb25zdCBwYWdlU2l6ZSA9IHRvTnVtYmVyKHVybFBhcmFtcy5nZXQoJ3BhZ2VTaXplJykpID8/IERFRkFVTFRfUEFHRV9TSVpFO1xuICAgICAgICAgICAgY29uc3QgcXVlcnkgPSB1cmxQYXJhbXMuZ2V0KCdxdWVyeScpPy50cmltKCk7XG4gICAgICAgICAgICBjb25zdCBwYXJhbXMgPSBwYXJzZVBhcmFtc1BhcmFtKHVybFBhcmFtcy5nZXQoJ3BhcmFtcycpKTtcbiAgICAgICAgICAgIGNvbnN0IG9yZGVyQnkgPSB1cmxQYXJhbXMuZ2V0KCdvcmRlckJ5Jyk/LnRyaW0oKSB8fCB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjb25zdCBvcmRlckRpcmVjdGlvblJhdyA9IHVybFBhcmFtcy5nZXQoJ29yZGVyRGlyZWN0aW9uJyk/LnRyaW0oKS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgY29uc3Qgb3JkZXJEaXJlY3Rpb24gPSBvcmRlckRpcmVjdGlvblJhdyA9PT0gJ0FTQycgfHwgb3JkZXJEaXJlY3Rpb25SYXcgPT09ICdERVNDJ1xuICAgICAgICAgICAgICAgID8gb3JkZXJEaXJlY3Rpb25SYXdcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3RlZFBhZ2UgPSBwYWdlID8/IDE7XG4gICAgICAgICAgICBjb25zdCByZXF1ZXN0ZWRQYWdlU2l6ZSA9IHBhZ2VTaXplO1xuICAgICAgICAgICAgY29uc3QgbWluQXNzb2NpYXRpb25zID0gcGFyYW1zICYmIHR5cGVvZiBwYXJhbXMubWluQXNzb2NpYXRpb25zID09PSAnbnVtYmVyJyAmJiBOdW1iZXIuaXNGaW5pdGUocGFyYW1zLm1pbkFzc29jaWF0aW9ucylcbiAgICAgICAgICAgICAgICA/IHBhcmFtcy5taW5Bc3NvY2lhdGlvbnNcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGNvbnN0IG5lZWRzQXNzb2NGaWx0ZXIgPSB0eXBlb2YgbWluQXNzb2NpYXRpb25zID09PSAnbnVtYmVyJyAmJiBtaW5Bc3NvY2lhdGlvbnMgPiAwO1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBleGVjdXRlU2VhcmNoKHtcbiAgICAgICAgICAgICAgICBwYWdlOiBuZWVkc0Fzc29jRmlsdGVyID8gMSA6IHJlcXVlc3RlZFBhZ2UsXG4gICAgICAgICAgICAgICAgcGFnZVNpemU6IG5lZWRzQXNzb2NGaWx0ZXIgPyBNYXRoLm1heCgyMDAwLCByZXF1ZXN0ZWRQYWdlU2l6ZSkgOiByZXF1ZXN0ZWRQYWdlU2l6ZSxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnkgJiYgcXVlcnkubGVuZ3RoID4gMCA/IHF1ZXJ5IDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIHBhcmFtcyxcbiAgICAgICAgICAgICAgICBvcmRlckJ5LFxuICAgICAgICAgICAgICAgIG9yZGVyRGlyZWN0aW9uLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoIW5lZWRzQXNzb2NGaWx0ZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ganNvblJlc3BvbnNlKG1hcEFnZW50c1Jlc3BvbnNlKHJlc3BvbnNlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhZ2VudHMgPSBBcnJheS5pc0FycmF5KHJlc3BvbnNlLmFnZW50cykgPyByZXNwb25zZS5hZ2VudHMgOiBbXTtcbiAgICAgICAgICAgIGNvbnN0IGZpbHRlcmVkID0gYWdlbnRzLmZpbHRlcigoYSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGluaXRpYXRlZCA9IHR5cGVvZiBhPy5pbml0aWF0ZWRBc3NvY2lhdGlvbkNvdW50ID09PSAnbnVtYmVyJyA/IGEuaW5pdGlhdGVkQXNzb2NpYXRpb25Db3VudCA6IDA7XG4gICAgICAgICAgICAgICAgY29uc3QgYXBwcm92ZWQgPSB0eXBlb2YgYT8uYXBwcm92ZWRBc3NvY2lhdGlvbkNvdW50ID09PSAnbnVtYmVyJyA/IGEuYXBwcm92ZWRBc3NvY2lhdGlvbkNvdW50IDogMDtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5pdGlhdGVkICsgYXBwcm92ZWQgPj0gbWluQXNzb2NpYXRpb25zO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBzdGFydCA9IE1hdGgubWF4KDAsIChyZXF1ZXN0ZWRQYWdlIC0gMSkgKiByZXF1ZXN0ZWRQYWdlU2l6ZSk7XG4gICAgICAgICAgICBjb25zdCBlbmQgPSBzdGFydCArIHJlcXVlc3RlZFBhZ2VTaXplO1xuICAgICAgICAgICAgY29uc3QgcGFnZWQgPSBmaWx0ZXJlZC5zbGljZShzdGFydCwgZW5kKTtcbiAgICAgICAgICAgIHJldHVybiBqc29uUmVzcG9uc2Uoe1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgICAgICAgICAgYWdlbnRzOiBwYWdlZCxcbiAgICAgICAgICAgICAgICB0b3RhbDogZmlsdGVyZWQubGVuZ3RoLFxuICAgICAgICAgICAgICAgIHBhZ2U6IHJlcXVlc3RlZFBhZ2UsXG4gICAgICAgICAgICAgICAgcGFnZVNpemU6IHJlcXVlc3RlZFBhZ2VTaXplLFxuICAgICAgICAgICAgICAgIHRvdGFsUGFnZXM6IE1hdGgubWF4KDEsIE1hdGguY2VpbChmaWx0ZXJlZC5sZW5ndGggLyBNYXRoLm1heCgxLCByZXF1ZXN0ZWRQYWdlU2l6ZSkpKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZUVycm9yKGVycm9yKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5leHBvcnQgZnVuY3Rpb24gc2VhcmNoQWdlbnRzUG9zdFJvdXRlSGFuZGxlcigpIHtcbiAgICByZXR1cm4gYXN5bmMgKHJlcSkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IChhd2FpdCByZXEuanNvbigpLmNhdGNoKCgpID0+ICh7fSkpKTtcbiAgICAgICAgICAgIGNvbnN0IHBhZ2UgPSB0eXBlb2YgYm9keS5wYWdlID09PSAnbnVtYmVyJyAmJiBOdW1iZXIuaXNGaW5pdGUoYm9keS5wYWdlKVxuICAgICAgICAgICAgICAgID8gYm9keS5wYWdlXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjb25zdCBwYWdlU2l6ZSA9IHR5cGVvZiBib2R5LnBhZ2VTaXplID09PSAnbnVtYmVyJyAmJiBOdW1iZXIuaXNGaW5pdGUoYm9keS5wYWdlU2l6ZSlcbiAgICAgICAgICAgICAgICA/IGJvZHkucGFnZVNpemVcbiAgICAgICAgICAgICAgICA6IERFRkFVTFRfUEFHRV9TSVpFO1xuICAgICAgICAgICAgY29uc3QgcXVlcnkgPSB0eXBlb2YgYm9keS5xdWVyeSA9PT0gJ3N0cmluZycgJiYgYm9keS5xdWVyeS50cmltKCkubGVuZ3RoID4gMFxuICAgICAgICAgICAgICAgID8gYm9keS5xdWVyeS50cmltKClcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGNvbnN0IHBhcmFtcyA9IGJvZHkucGFyYW1zICYmIHR5cGVvZiBib2R5LnBhcmFtcyA9PT0gJ29iamVjdCdcbiAgICAgICAgICAgICAgICA/IGJvZHkucGFyYW1zXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjb25zdCBvcmRlckJ5ID0gdHlwZW9mIGJvZHkub3JkZXJCeSA9PT0gJ3N0cmluZycgJiYgYm9keS5vcmRlckJ5LnRyaW0oKS5sZW5ndGggPiAwXG4gICAgICAgICAgICAgICAgPyBib2R5Lm9yZGVyQnkudHJpbSgpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjb25zdCBvcmRlckRpcmVjdGlvblJhdyA9IHR5cGVvZiBib2R5Lm9yZGVyRGlyZWN0aW9uID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgICAgID8gYm9keS5vcmRlckRpcmVjdGlvbi50b1VwcGVyQ2FzZSgpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjb25zdCBvcmRlckRpcmVjdGlvbiA9IG9yZGVyRGlyZWN0aW9uUmF3ID09PSAnQVNDJyB8fCBvcmRlckRpcmVjdGlvblJhdyA9PT0gJ0RFU0MnXG4gICAgICAgICAgICAgICAgPyBvcmRlckRpcmVjdGlvblJhd1xuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgY29uc3QgcmVxdWVzdGVkUGFnZSA9IHBhZ2UgPz8gMTtcbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3RlZFBhZ2VTaXplID0gcGFnZVNpemU7XG4gICAgICAgICAgICBjb25zdCBtaW5Bc3NvY2lhdGlvbnMgPSBwYXJhbXMgJiYgdHlwZW9mIHBhcmFtcy5taW5Bc3NvY2lhdGlvbnMgPT09ICdudW1iZXInICYmIE51bWJlci5pc0Zpbml0ZShwYXJhbXMubWluQXNzb2NpYXRpb25zKVxuICAgICAgICAgICAgICAgID8gcGFyYW1zLm1pbkFzc29jaWF0aW9uc1xuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgY29uc3QgbmVlZHNBc3NvY0ZpbHRlciA9IHR5cGVvZiBtaW5Bc3NvY2lhdGlvbnMgPT09ICdudW1iZXInICYmIG1pbkFzc29jaWF0aW9ucyA+IDA7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGV4ZWN1dGVTZWFyY2goe1xuICAgICAgICAgICAgICAgIHBhZ2U6IG5lZWRzQXNzb2NGaWx0ZXIgPyAxIDogcmVxdWVzdGVkUGFnZSxcbiAgICAgICAgICAgICAgICBwYWdlU2l6ZTogbmVlZHNBc3NvY0ZpbHRlciA/IE1hdGgubWF4KDIwMDAsIHJlcXVlc3RlZFBhZ2VTaXplKSA6IHJlcXVlc3RlZFBhZ2VTaXplLFxuICAgICAgICAgICAgICAgIHF1ZXJ5LFxuICAgICAgICAgICAgICAgIHBhcmFtcyxcbiAgICAgICAgICAgICAgICBvcmRlckJ5LFxuICAgICAgICAgICAgICAgIG9yZGVyRGlyZWN0aW9uLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoIW5lZWRzQXNzb2NGaWx0ZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ganNvblJlc3BvbnNlKG1hcEFnZW50c1Jlc3BvbnNlKHJlc3BvbnNlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhZ2VudHMgPSBBcnJheS5pc0FycmF5KHJlc3BvbnNlLmFnZW50cykgPyByZXNwb25zZS5hZ2VudHMgOiBbXTtcbiAgICAgICAgICAgIGNvbnN0IGZpbHRlcmVkID0gYWdlbnRzLmZpbHRlcigoYSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGluaXRpYXRlZCA9IHR5cGVvZiBhPy5pbml0aWF0ZWRBc3NvY2lhdGlvbkNvdW50ID09PSAnbnVtYmVyJyA/IGEuaW5pdGlhdGVkQXNzb2NpYXRpb25Db3VudCA6IDA7XG4gICAgICAgICAgICAgICAgY29uc3QgYXBwcm92ZWQgPSB0eXBlb2YgYT8uYXBwcm92ZWRBc3NvY2lhdGlvbkNvdW50ID09PSAnbnVtYmVyJyA/IGEuYXBwcm92ZWRBc3NvY2lhdGlvbkNvdW50IDogMDtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5pdGlhdGVkICsgYXBwcm92ZWQgPj0gbWluQXNzb2NpYXRpb25zO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBzdGFydCA9IE1hdGgubWF4KDAsIChyZXF1ZXN0ZWRQYWdlIC0gMSkgKiByZXF1ZXN0ZWRQYWdlU2l6ZSk7XG4gICAgICAgICAgICBjb25zdCBlbmQgPSBzdGFydCArIHJlcXVlc3RlZFBhZ2VTaXplO1xuICAgICAgICAgICAgY29uc3QgcGFnZWQgPSBmaWx0ZXJlZC5zbGljZShzdGFydCwgZW5kKTtcbiAgICAgICAgICAgIHJldHVybiBqc29uUmVzcG9uc2Uoe1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgICAgICAgICAgYWdlbnRzOiBwYWdlZCxcbiAgICAgICAgICAgICAgICB0b3RhbDogZmlsdGVyZWQubGVuZ3RoLFxuICAgICAgICAgICAgICAgIHBhZ2U6IHJlcXVlc3RlZFBhZ2UsXG4gICAgICAgICAgICAgICAgcGFnZVNpemU6IHJlcXVlc3RlZFBhZ2VTaXplLFxuICAgICAgICAgICAgICAgIHRvdGFsUGFnZXM6IE1hdGgubWF4KDEsIE1hdGguY2VpbChmaWx0ZXJlZC5sZW5ndGggLyBNYXRoLm1heCgxLCByZXF1ZXN0ZWRQYWdlU2l6ZSkpKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZUVycm9yKGVycm9yKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5leHBvcnQgZnVuY3Rpb24gc2VtYW50aWNBZ2VudFNlYXJjaFBvc3RSb3V0ZUhhbmRsZXIoKSB7XG4gICAgcmV0dXJuIGFzeW5jIChyZXEpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSAoYXdhaXQgcmVxLmpzb24oKS5jYXRjaCgoKSA9PiAoe30pKSk7XG4gICAgICAgICAgICBjb25zdCByYXdJbnRlbnRKc29uID0gdHlwZW9mIGJvZHkuaW50ZW50SnNvbiA9PT0gJ3N0cmluZydcbiAgICAgICAgICAgICAgICA/IGJvZHkuaW50ZW50SnNvblxuICAgICAgICAgICAgICAgIDogdHlwZW9mIGJvZHkuaW50ZW50ID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgICAgICAgICA/IGJvZHkuaW50ZW50XG4gICAgICAgICAgICAgICAgICAgIDogJyc7XG4gICAgICAgICAgICBjb25zdCBpbnRlbnRKc29uID0gcmF3SW50ZW50SnNvbi50cmltKCk7XG4gICAgICAgICAgICBjb25zdCB0b3BLUmF3ID0gYm9keS50b3BLO1xuICAgICAgICAgICAgY29uc3QgdG9wSyA9IHR5cGVvZiB0b3BLUmF3ID09PSAnbnVtYmVyJyAmJiBOdW1iZXIuaXNGaW5pdGUodG9wS1JhdykgJiYgdG9wS1JhdyA+IDBcbiAgICAgICAgICAgICAgICA/IE1hdGguZmxvb3IodG9wS1JhdylcbiAgICAgICAgICAgICAgICA6IHR5cGVvZiB0b3BLUmF3ID09PSAnc3RyaW5nJyAmJiB0b3BLUmF3LnRyaW0oKVxuICAgICAgICAgICAgICAgICAgICA/IE1hdGgubWF4KDEsIE1hdGguZmxvb3IoTnVtYmVyKHRvcEtSYXcpKSlcbiAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjb25zdCByYXdUZXh0ID0gdHlwZW9mIGJvZHkudGV4dCA9PT0gJ3N0cmluZydcbiAgICAgICAgICAgICAgICA/IGJvZHkudGV4dFxuICAgICAgICAgICAgICAgIDogdHlwZW9mIGJvZHkucXVlcnkgPT09ICdzdHJpbmcnXG4gICAgICAgICAgICAgICAgICAgID8gYm9keS5xdWVyeVxuICAgICAgICAgICAgICAgICAgICA6ICcnO1xuICAgICAgICAgICAgY29uc3QgdGV4dCA9IHJhd1RleHQudHJpbSgpO1xuICAgICAgICAgICAgaWYgKCF0ZXh0ICYmICFpbnRlbnRKc29uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGpzb25SZXNwb25zZSh7XG4gICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHRvdGFsOiAwLFxuICAgICAgICAgICAgICAgICAgICBtYXRjaGVzOiBbXSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGRpc2NvdmVyeUNsaWVudCA9IGF3YWl0IGdldERpc2NvdmVyeUNsaWVudCgpO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZGlzY292ZXJ5Q2xpZW50LnNlbWFudGljQWdlbnRTZWFyY2goaW50ZW50SnNvbiA/IHsgaW50ZW50SnNvbiwgdG9wSyB9IDogeyB0ZXh0IH0pO1xuICAgICAgICAgICAgY29uc3QgdG90YWwgPSByZXN1bHQgJiYgdHlwZW9mIHJlc3VsdC50b3RhbCA9PT0gJ251bWJlcicgJiYgTnVtYmVyLmlzRmluaXRlKHJlc3VsdC50b3RhbClcbiAgICAgICAgICAgICAgICA/IHJlc3VsdC50b3RhbFxuICAgICAgICAgICAgICAgIDogMDtcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoZXMgPSBBcnJheS5pc0FycmF5KHJlc3VsdD8ubWF0Y2hlcykgPyByZXN1bHQubWF0Y2hlcyA6IFtdO1xuICAgICAgICAgICAgcmV0dXJuIGpzb25SZXNwb25zZSh7XG4gICAgICAgICAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgICAgICAgICB0b3RhbCxcbiAgICAgICAgICAgICAgICBtYXRjaGVzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlRXJyb3IoZXJyb3IpO1xuICAgICAgICB9XG4gICAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5leHQuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@agentic-trust/core/dist/api/search/next.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@agentic-trust/core/dist/client/accountClient.js":
/*!***************************************************************************!*\
  !*** ../../node_modules/@agentic-trust/core/dist/client/accountClient.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   deploySmartAccountIfNeeded: () => (/* binding */ deploySmartAccountIfNeeded),\n/* harmony export */   getCounterfactualAAAddressByAgentName: () => (/* binding */ getCounterfactualAAAddressByAgentName),\n/* harmony export */   getCounterfactualAccountClientByAgentName: () => (/* binding */ getCounterfactualAccountClientByAgentName),\n/* harmony export */   getCounterfactualSmartAccountAddressByAgentName: () => (/* binding */ getCounterfactualSmartAccountAddressByAgentName),\n/* harmony export */   getDeployedAccountClientByAddress: () => (/* binding */ getDeployedAccountClientByAddress),\n/* harmony export */   getDeployedAccountClientByAgentName: () => (/* binding */ getDeployedAccountClientByAgentName),\n/* harmony export */   isSmartContract: () => (/* binding */ isSmartContract),\n/* harmony export */   sendSponsoredUserOperation: () => (/* binding */ sendSponsoredUserOperation),\n/* harmony export */   waitForUserOperationReceipt: () => (/* binding */ waitForUserOperationReceipt)\n/* harmony export */ });\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! viem */ \"(rsc)/../../node_modules/viem/_esm/clients/createWalletClient.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! viem */ \"(rsc)/../../node_modules/viem/_esm/clients/transports/custom.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! viem */ \"(rsc)/../../node_modules/viem/_esm/clients/createPublicClient.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! viem */ \"(rsc)/../../node_modules/viem/_esm/utils/hash/keccak256.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! viem */ \"(rsc)/../../node_modules/viem/_esm/utils/encoding/toHex.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! viem */ \"(rsc)/../../node_modules/viem/_esm/clients/transports/http.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! viem */ \"(rsc)/../../node_modules/viem/_esm/constants/address.js\");\n/* harmony import */ var viem_chains__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! viem/chains */ \"(rsc)/../../node_modules/viem/_esm/chains/definitions/sepolia.js\");\n/* harmony import */ var viem_account_abstraction__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! viem/account-abstraction */ \"(rsc)/../../node_modules/viem/_esm/account-abstraction/clients/createBundlerClient.js\");\n/* harmony import */ var _server_lib_chainConfig__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../server/lib/chainConfig */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/lib/chainConfig.js\");\n/* harmony import */ var _metamask_smart_accounts_kit__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @metamask/smart-accounts-kit */ \"(rsc)/../../node_modules/@metamask/smart-accounts-kit/dist/chunk-7MRTROLV.mjs\");\n/* harmony import */ var _metamask_smart_accounts_kit__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @metamask/smart-accounts-kit */ \"(rsc)/../../node_modules/@metamask/smart-accounts-kit/dist/index.mjs\");\n\n\n\n\n\n/**\n * Get the counterfactual AA address for an agent name (client-side computation)\n *\n * This function computes the AA address without creating a full account client.\n * It uses the wallet provider (MetaMask/Web3Auth) to compute the address.\n *\n * @param agentName - The agent name\n * @param eoaAddress - The EOA address (owner of the AA account)\n * @param options - Options for chain, ethereumProvider, etc.\n * @returns The counterfactual AA address\n */\nasync function getCounterfactualSmartAccountAddressByAgentName(agentName, eoaAddress, options) {\n    // Use the existing function to get the account client, then return just the address\n    const accountClient = await getCounterfactualAccountClientByAgentName(agentName, eoaAddress, options);\n    return accountClient.address;\n}\n/**\n * @deprecated Use getCounterfactualSmartAccountAddressByAgentName\n */\nasync function getCounterfactualAAAddressByAgentName(agentName, eoaAddress, options) {\n    return getCounterfactualSmartAccountAddressByAgentName(agentName, eoaAddress, options);\n}\nasync function getCounterfactualAccountClientByAgentName(agentName, eoaAddress, options) {\n    const chain = options?.chain || viem_chains__WEBPACK_IMPORTED_MODULE_1__.sepolia;\n    let walletClient;\n    if (options?.walletClient) {\n        walletClient = options.walletClient;\n    }\n    else if (options?.ethereumProvider) {\n        walletClient = (0,viem__WEBPACK_IMPORTED_MODULE_2__.createWalletClient)({\n            chain: chain,\n            transport: (0,viem__WEBPACK_IMPORTED_MODULE_3__.custom)(options.ethereumProvider),\n            account: eoaAddress,\n        });\n    }\n    else {\n        throw new Error('No wallet client found. Ensure MetaMask/Web3Auth is available or pass walletClient in options.');\n    }\n    let publicClient;\n    if (options?.publicClient) {\n        publicClient = options.publicClient;\n    }\n    else if (options?.ethereumProvider) {\n        publicClient = (0,viem__WEBPACK_IMPORTED_MODULE_4__.createPublicClient)({\n            chain: chain,\n            transport: (0,viem__WEBPACK_IMPORTED_MODULE_3__.custom)(options?.ethereumProvider),\n        });\n    }\n    else {\n        throw new Error('No public client found. Ensure RPC URL is available or pass publicClient in options.');\n    }\n    const salt = (0,viem__WEBPACK_IMPORTED_MODULE_5__.keccak256)((0,viem__WEBPACK_IMPORTED_MODULE_6__.stringToHex)(agentName));\n    const clientConfig = {\n        client: publicClient,\n        implementation: _metamask_smart_accounts_kit__WEBPACK_IMPORTED_MODULE_7__.Implementation.Hybrid,\n        signer: {\n            walletClient,\n        },\n        deployParams: [eoaAddress, [], [], []],\n        deploySalt: salt,\n    };\n    let counterfactualAccountClient = await (0,_metamask_smart_accounts_kit__WEBPACK_IMPORTED_MODULE_8__.toMetaMaskSmartAccount)(clientConfig);\n    return counterfactualAccountClient;\n}\n/**\n * Build a deployed MetaMask smart account client from a known smart account address.\n * Prefer this when you already know the correct agent smart account address (agentAccount),\n * since name-based derivation is case-sensitive.\n */\nasync function getDeployedAccountClientByAddress(accountAddress, eoaAddress, options) {\n    const chain = options?.chain || viem_chains__WEBPACK_IMPORTED_MODULE_1__.sepolia;\n    let walletClient;\n    if (options?.walletClient) {\n        walletClient = options.walletClient;\n    }\n    else if (options?.ethereumProvider) {\n        walletClient = (0,viem__WEBPACK_IMPORTED_MODULE_2__.createWalletClient)({\n            chain: chain,\n            transport: (0,viem__WEBPACK_IMPORTED_MODULE_3__.custom)(options.ethereumProvider),\n            account: eoaAddress,\n        });\n    }\n    else {\n        throw new Error('No wallet client found. Ensure MetaMask/Web3Auth is available or pass walletClient in options.');\n    }\n    const rpcUrl = (0,_server_lib_chainConfig__WEBPACK_IMPORTED_MODULE_0__.getChainRpcUrl)(chain.id);\n    const publicClient = options?.publicClient\n        ? options.publicClient\n        : (0,viem__WEBPACK_IMPORTED_MODULE_4__.createPublicClient)({\n            chain: chain,\n            transport: rpcUrl ? (0,viem__WEBPACK_IMPORTED_MODULE_9__.http)(rpcUrl) : (0,viem__WEBPACK_IMPORTED_MODULE_3__.custom)(options?.ethereumProvider),\n        });\n    return await (0,_metamask_smart_accounts_kit__WEBPACK_IMPORTED_MODULE_8__.toMetaMaskSmartAccount)({\n        client: publicClient,\n        implementation: _metamask_smart_accounts_kit__WEBPACK_IMPORTED_MODULE_7__.Implementation.Hybrid,\n        signer: { walletClient },\n        address: accountAddress,\n    });\n}\nasync function getDeployedAccountClientByAgentName(bundlerUrl, agentName, eoaAddress, options) {\n    // Extract only the name to the left of the first '.'\n    const normalizedAgentName = agentName.includes('.') ? agentName.split('.')[0] : agentName;\n    // Ensure we have a valid non-empty string\n    if (!normalizedAgentName || normalizedAgentName.trim().length === 0) {\n        throw new Error('Agent name is required and cannot be empty');\n    }\n    const chain = options?.chain || viem_chains__WEBPACK_IMPORTED_MODULE_1__.sepolia;\n    console.info('*********** accountClient getDeployedAccountClientByAgentName: agentName', agentName, 'normalized:', normalizedAgentName);\n    let walletClient;\n    if (options?.walletClient) {\n        walletClient = options.walletClient;\n    }\n    else if (options?.ethereumProvider) {\n        walletClient = (0,viem__WEBPACK_IMPORTED_MODULE_2__.createWalletClient)({\n            chain: chain,\n            transport: (0,viem__WEBPACK_IMPORTED_MODULE_3__.custom)(options.ethereumProvider),\n            account: eoaAddress,\n        });\n    }\n    else {\n        throw new Error('No wallet client found. Ensure MetaMask/Web3Auth is available or pass walletClient in options.');\n    }\n    let publicClient;\n    if (options?.publicClient) {\n        publicClient = options.publicClient;\n    }\n    else if (options?.ethereumProvider) {\n        publicClient = (0,viem__WEBPACK_IMPORTED_MODULE_4__.createPublicClient)({\n            chain: chain,\n            transport: (0,viem__WEBPACK_IMPORTED_MODULE_3__.custom)(options?.ethereumProvider),\n        });\n    }\n    else {\n        throw new Error('No public client found. Ensure RPC URL is available or pass publicClient in options.');\n    }\n    const salt = (0,viem__WEBPACK_IMPORTED_MODULE_5__.keccak256)((0,viem__WEBPACK_IMPORTED_MODULE_6__.stringToHex)(normalizedAgentName));\n    const clientConfig = {\n        client: publicClient,\n        implementation: _metamask_smart_accounts_kit__WEBPACK_IMPORTED_MODULE_7__.Implementation.Hybrid,\n        signer: {\n            walletClient,\n        },\n        deployParams: [eoaAddress, [], [], []],\n        deploySalt: salt,\n    };\n    let counterfactualAccountClient = await (0,_metamask_smart_accounts_kit__WEBPACK_IMPORTED_MODULE_8__.toMetaMaskSmartAccount)(clientConfig);\n    // Check deployment status with provided publicClient, then fall back to HTTP RPC if available\n    let isDeployed = false;\n    try {\n        const code = await publicClient.getBytecode({ address: counterfactualAccountClient.address });\n        isDeployed = !!code && code !== \"0x\";\n    }\n    catch { }\n    if (!isDeployed) {\n        try {\n            const rpcUrl = (0,_server_lib_chainConfig__WEBPACK_IMPORTED_MODULE_0__.getChainRpcUrl)(chain.id);\n            console.info('*********** accountClient getDeployedAccountClientByAgentName: checking on RPC', rpcUrl);\n            if (rpcUrl) {\n                const httpClient = (0,viem__WEBPACK_IMPORTED_MODULE_4__.createPublicClient)({ chain: chain, transport: (0,viem__WEBPACK_IMPORTED_MODULE_9__.http)(rpcUrl) });\n                const codeHttp = await httpClient.getBytecode({ address: counterfactualAccountClient.address });\n                isDeployed = !!codeHttp && codeHttp !== \"0x\";\n            }\n        }\n        catch { }\n    }\n    console.info('*********** accountClient getDeployedAccountClientByAgentName: isDeployed', isDeployed);\n    if (!isDeployed && bundlerUrl) {\n        console.info('*********** accountClient getDeployedAccountClientByAgentName: deploying via bundler');\n        const pimlico = await getPimlicoClient(bundlerUrl);\n        const bundlerClient = (0,viem_account_abstraction__WEBPACK_IMPORTED_MODULE_10__.createBundlerClient)({\n            transport: (0,viem__WEBPACK_IMPORTED_MODULE_9__.http)(bundlerUrl),\n            paymaster: true,\n            chain: chain,\n            paymasterContext: { mode: 'SPONSORED' },\n        });\n        const { fast: fee } = await pimlico.getUserOperationGasPrice();\n        console.info('*********** accountClient getDeployedAccountClientByAgentName: gas price', fee);\n        const userOperationHash = await bundlerClient.sendUserOperation({\n            account: counterfactualAccountClient,\n            calls: [{ to: viem__WEBPACK_IMPORTED_MODULE_11__.zeroAddress }],\n            ...fee,\n        });\n        console.info('*********** accountClient getDeployedAccountClientByAgentName: userOperationHash', userOperationHash);\n        await bundlerClient.waitForUserOperationReceipt({ hash: userOperationHash });\n        // After deployment, mark as deployed so we rebuild below\n        isDeployed = true;\n    }\n    if (isDeployed) {\n        // Rebuild a \"clean\" smart account client with address only (no factory/deploy params)\n        // using an HTTP public client to avoid provider quirks.\n        try {\n            const rpcUrl = (0,_server_lib_chainConfig__WEBPACK_IMPORTED_MODULE_0__.getChainRpcUrl)(chain.id);\n            const httpClient = (0,viem__WEBPACK_IMPORTED_MODULE_4__.createPublicClient)({ chain: chain, transport: (0,viem__WEBPACK_IMPORTED_MODULE_9__.http)(rpcUrl) });\n            console.info('*********** accountClient getDeployedAccountClientByAgentName: rebuilding deployed account client (address-only)');\n            const deployedAccountClient = await (0,_metamask_smart_accounts_kit__WEBPACK_IMPORTED_MODULE_8__.toMetaMaskSmartAccount)({\n                client: httpClient,\n                implementation: _metamask_smart_accounts_kit__WEBPACK_IMPORTED_MODULE_7__.Implementation.Hybrid,\n                signer: {\n                    walletClient: walletClient,\n                },\n                address: counterfactualAccountClient.address,\n            });\n            console.info('*********** accountClient getDeployedAccountClientByAgentName: agentAccountClient', deployedAccountClient.address);\n            return deployedAccountClient;\n        }\n        catch (rebuildErr) {\n            console.warn('*********** accountClient getDeployedAccountClientByAgentName: rebuild failed, falling back to existing client', rebuildErr);\n            return counterfactualAccountClient;\n        }\n    }\n    console.info('*********** accountClient getDeployedAccountClientByAgentName: agentAccountClient', counterfactualAccountClient.address);\n    return counterfactualAccountClient;\n}\n// ============================================================================\n// Bundler Utilities\n// ============================================================================\n// Dynamic import for permissionless (optional dependency)\nasync function getPimlicoClient(bundlerUrl) {\n    try {\n        // @ts-ignore - permissionless is an optional dependency\n        const { createPimlicoClient } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! permissionless/clients/pimlico */ \"(rsc)/../../node_modules/permissionless/_esm/clients/pimlico.js\"));\n        return createPimlicoClient({ transport: (0,viem__WEBPACK_IMPORTED_MODULE_9__.http)(bundlerUrl) });\n    }\n    catch (error) {\n        throw new Error('permissionless package not installed. Install it with: pnpm add permissionless ' +\n            `Error: ${error instanceof Error ? error.message : 'Unknown error'}`);\n    }\n}\n/**\n * Send a sponsored UserOperation via bundler\n *\n * @param params - UserOperation parameters\n * @returns UserOperation hash\n */\nasync function sendSponsoredUserOperation(params) {\n    const { bundlerUrl, chain, accountClient, calls } = params;\n    const pimlicoClient = await getPimlicoClient(bundlerUrl);\n    const bundlerClient = (0,viem_account_abstraction__WEBPACK_IMPORTED_MODULE_10__.createBundlerClient)({\n        transport: (0,viem__WEBPACK_IMPORTED_MODULE_9__.http)(bundlerUrl),\n        paymaster: true,\n        chain: chain,\n        paymasterContext: { mode: 'SPONSORED' }\n    });\n    const { fast: fee } = await pimlicoClient.getUserOperationGasPrice();\n    const userOpHash = await bundlerClient.sendUserOperation({\n        account: accountClient,\n        calls,\n        ...fee\n    });\n    return userOpHash;\n}\n/**\n * Wait for UserOperation receipt\n *\n * @param params - Receipt parameters\n * @returns UserOperation receipt\n */\nasync function waitForUserOperationReceipt(params) {\n    const { bundlerUrl, chain, hash } = params;\n    const bundlerClient = (0,viem_account_abstraction__WEBPACK_IMPORTED_MODULE_10__.createBundlerClient)({\n        transport: (0,viem__WEBPACK_IMPORTED_MODULE_9__.http)(bundlerUrl),\n        paymaster: true,\n        chain: chain,\n        paymasterContext: { mode: 'SPONSORED' }\n    });\n    return await bundlerClient.waitForUserOperationReceipt({ hash });\n}\n/**\n * Deploy smart account if needed\n *\n * @param params - Deployment parameters\n * @returns true if account was deployed, false if already deployed\n */\nasync function deploySmartAccountIfNeeded(params) {\n    const { bundlerUrl, chain, account } = params;\n    const isDeployed = await account.isDeployed();\n    if (isDeployed)\n        return false;\n    const pimlico = await getPimlicoClient(bundlerUrl);\n    const bundlerClient = (0,viem_account_abstraction__WEBPACK_IMPORTED_MODULE_10__.createBundlerClient)({\n        transport: (0,viem__WEBPACK_IMPORTED_MODULE_9__.http)(bundlerUrl),\n        paymaster: true,\n        chain: chain,\n        paymasterContext: { mode: 'SPONSORED' }\n    });\n    const { fast } = await pimlico.getUserOperationGasPrice();\n    const userOperationHash = await bundlerClient.sendUserOperation({\n        account,\n        calls: [{ to: viem__WEBPACK_IMPORTED_MODULE_11__.zeroAddress }],\n        ...fast\n    });\n    await bundlerClient.waitForUserOperationReceipt({ hash: userOperationHash });\n    return true;\n}\n/**\n * Check if an address is a smart contract (has code)\n *\n * @param publicClient - Viem public client\n * @param address - Address to check\n * @returns true if address has code (is a contract), false if EOA\n */\nasync function isSmartContract(publicClient, address) {\n    try {\n        const code = await publicClient.getBytecode({ address });\n        return code !== undefined && code !== '0x';\n    }\n    catch {\n        return false;\n    }\n}\n//# sourceMappingURL=accountClient.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BhZ2VudGljLXRydXN0L2NvcmUvZGlzdC9jbGllbnQvYWNjb3VudENsaWVudC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBaUg7QUFDM0U7QUFDeUI7QUFDSjtBQUMyQjtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1Asb0NBQW9DLGdEQUFPO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsd0RBQWtCO0FBQ3pDO0FBQ0EsdUJBQXVCLDRDQUFNO0FBQzdCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix3REFBa0I7QUFDekM7QUFDQSx1QkFBdUIsNENBQU07QUFDN0IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLCtDQUFTLENBQUMsaURBQVc7QUFDdEM7QUFDQTtBQUNBLHdCQUF3Qix3RUFBYztBQUN0QztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxvRkFBc0I7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLG9DQUFvQyxnREFBTztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHdEQUFrQjtBQUN6QztBQUNBLHVCQUF1Qiw0Q0FBTTtBQUM3QjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix1RUFBYztBQUNqQztBQUNBO0FBQ0EsVUFBVSx3REFBa0I7QUFDNUI7QUFDQSxnQ0FBZ0MsMENBQUksV0FBVyw0Q0FBTTtBQUNyRCxTQUFTO0FBQ1QsaUJBQWlCLG9GQUFzQjtBQUN2QztBQUNBLHdCQUF3Qix3RUFBYztBQUN0QyxrQkFBa0IsY0FBYztBQUNoQztBQUNBLEtBQUs7QUFDTDtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGdEQUFPO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix3REFBa0I7QUFDekM7QUFDQSx1QkFBdUIsNENBQU07QUFDN0I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHdEQUFrQjtBQUN6QztBQUNBLHVCQUF1Qiw0Q0FBTTtBQUM3QixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsK0NBQVMsQ0FBQyxpREFBVztBQUN0QztBQUNBO0FBQ0Esd0JBQXdCLHdFQUFjO0FBQ3RDO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLG9GQUFzQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsOENBQThDO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsdUVBQWM7QUFDekM7QUFDQTtBQUNBLG1DQUFtQyx3REFBa0IsR0FBRyx5QkFBeUIsMENBQUksVUFBVTtBQUMvRixnRUFBZ0UsOENBQThDO0FBQzlHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qiw4RUFBbUI7QUFDakQsdUJBQXVCLDBDQUFJO0FBQzNCO0FBQ0E7QUFDQSxnQ0FBZ0MsbUJBQW1CO0FBQ25ELFNBQVM7QUFDVCxnQkFBZ0IsWUFBWTtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsSUFBSSw4Q0FBVyxFQUFFO0FBQ3ZDO0FBQ0EsU0FBUztBQUNUO0FBQ0EsMERBQTBELHlCQUF5QjtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQix1RUFBYztBQUN6QywrQkFBK0Isd0RBQWtCLEdBQUcseUJBQXlCLDBDQUFJLFVBQVU7QUFDM0Y7QUFDQSxnREFBZ0Qsb0ZBQXNCO0FBQ3RFO0FBQ0EsZ0NBQWdDLHdFQUFjO0FBQzlDO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHNCQUFzQixRQUFRLDZMQUF3QztBQUN0RixxQ0FBcUMsV0FBVywwQ0FBSSxjQUFjO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQix5REFBeUQ7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsWUFBWSwwQ0FBMEM7QUFDdEQ7QUFDQSwwQkFBMEIsOEVBQW1CO0FBQzdDLG1CQUFtQiwwQ0FBSTtBQUN2QjtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCLEtBQUs7QUFDTCxZQUFZLFlBQVk7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsWUFBWSwwQkFBMEI7QUFDdEMsMEJBQTBCLDhFQUFtQjtBQUM3QyxtQkFBbUIsMENBQUk7QUFDdkI7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QixLQUFLO0FBQ0wsNkRBQTZELE1BQU07QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLFlBQVksNkJBQTZCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDhFQUFtQjtBQUM3QyxtQkFBbUIsMENBQUk7QUFDdkI7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QixLQUFLO0FBQ0wsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQSxrQkFBa0IsSUFBSSw4Q0FBVyxFQUFFO0FBQ25DO0FBQ0EsS0FBSztBQUNMLHNEQUFzRCx5QkFBeUI7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLHNEQUFzRCxTQUFTO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9iYXJiL2FhL0Fzc29jaWF0ZWRBY2NvdW50cy9ub2RlX21vZHVsZXMvQGFnZW50aWMtdHJ1c3QvY29yZS9kaXN0L2NsaWVudC9hY2NvdW50Q2xpZW50LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGtlY2NhazI1Niwgc3RyaW5nVG9IZXgsIGNyZWF0ZVB1YmxpY0NsaWVudCwgaHR0cCwgemVyb0FkZHJlc3MsIGNyZWF0ZVdhbGxldENsaWVudCwgY3VzdG9tIH0gZnJvbSAndmllbSc7XG5pbXBvcnQgeyBzZXBvbGlhIH0gZnJvbSAndmllbS9jaGFpbnMnO1xuaW1wb3J0IHsgY3JlYXRlQnVuZGxlckNsaWVudCB9IGZyb20gJ3ZpZW0vYWNjb3VudC1hYnN0cmFjdGlvbic7XG5pbXBvcnQgeyBnZXRDaGFpblJwY1VybCB9IGZyb20gJy4uL3NlcnZlci9saWIvY2hhaW5Db25maWcnO1xuaW1wb3J0IHsgdG9NZXRhTWFza1NtYXJ0QWNjb3VudCwgSW1wbGVtZW50YXRpb24gfSBmcm9tICdAbWV0YW1hc2svc21hcnQtYWNjb3VudHMta2l0Jztcbi8qKlxuICogR2V0IHRoZSBjb3VudGVyZmFjdHVhbCBBQSBhZGRyZXNzIGZvciBhbiBhZ2VudCBuYW1lIChjbGllbnQtc2lkZSBjb21wdXRhdGlvbilcbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGNvbXB1dGVzIHRoZSBBQSBhZGRyZXNzIHdpdGhvdXQgY3JlYXRpbmcgYSBmdWxsIGFjY291bnQgY2xpZW50LlxuICogSXQgdXNlcyB0aGUgd2FsbGV0IHByb3ZpZGVyIChNZXRhTWFzay9XZWIzQXV0aCkgdG8gY29tcHV0ZSB0aGUgYWRkcmVzcy5cbiAqXG4gKiBAcGFyYW0gYWdlbnROYW1lIC0gVGhlIGFnZW50IG5hbWVcbiAqIEBwYXJhbSBlb2FBZGRyZXNzIC0gVGhlIEVPQSBhZGRyZXNzIChvd25lciBvZiB0aGUgQUEgYWNjb3VudClcbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyBmb3IgY2hhaW4sIGV0aGVyZXVtUHJvdmlkZXIsIGV0Yy5cbiAqIEByZXR1cm5zIFRoZSBjb3VudGVyZmFjdHVhbCBBQSBhZGRyZXNzXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRDb3VudGVyZmFjdHVhbFNtYXJ0QWNjb3VudEFkZHJlc3NCeUFnZW50TmFtZShhZ2VudE5hbWUsIGVvYUFkZHJlc3MsIG9wdGlvbnMpIHtcbiAgICAvLyBVc2UgdGhlIGV4aXN0aW5nIGZ1bmN0aW9uIHRvIGdldCB0aGUgYWNjb3VudCBjbGllbnQsIHRoZW4gcmV0dXJuIGp1c3QgdGhlIGFkZHJlc3NcbiAgICBjb25zdCBhY2NvdW50Q2xpZW50ID0gYXdhaXQgZ2V0Q291bnRlcmZhY3R1YWxBY2NvdW50Q2xpZW50QnlBZ2VudE5hbWUoYWdlbnROYW1lLCBlb2FBZGRyZXNzLCBvcHRpb25zKTtcbiAgICByZXR1cm4gYWNjb3VudENsaWVudC5hZGRyZXNzO1xufVxuLyoqXG4gKiBAZGVwcmVjYXRlZCBVc2UgZ2V0Q291bnRlcmZhY3R1YWxTbWFydEFjY291bnRBZGRyZXNzQnlBZ2VudE5hbWVcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldENvdW50ZXJmYWN0dWFsQUFBZGRyZXNzQnlBZ2VudE5hbWUoYWdlbnROYW1lLCBlb2FBZGRyZXNzLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGdldENvdW50ZXJmYWN0dWFsU21hcnRBY2NvdW50QWRkcmVzc0J5QWdlbnROYW1lKGFnZW50TmFtZSwgZW9hQWRkcmVzcywgb3B0aW9ucyk7XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0Q291bnRlcmZhY3R1YWxBY2NvdW50Q2xpZW50QnlBZ2VudE5hbWUoYWdlbnROYW1lLCBlb2FBZGRyZXNzLCBvcHRpb25zKSB7XG4gICAgY29uc3QgY2hhaW4gPSBvcHRpb25zPy5jaGFpbiB8fCBzZXBvbGlhO1xuICAgIGxldCB3YWxsZXRDbGllbnQ7XG4gICAgaWYgKG9wdGlvbnM/LndhbGxldENsaWVudCkge1xuICAgICAgICB3YWxsZXRDbGllbnQgPSBvcHRpb25zLndhbGxldENsaWVudDtcbiAgICB9XG4gICAgZWxzZSBpZiAob3B0aW9ucz8uZXRoZXJldW1Qcm92aWRlcikge1xuICAgICAgICB3YWxsZXRDbGllbnQgPSBjcmVhdGVXYWxsZXRDbGllbnQoe1xuICAgICAgICAgICAgY2hhaW46IGNoYWluLFxuICAgICAgICAgICAgdHJhbnNwb3J0OiBjdXN0b20ob3B0aW9ucy5ldGhlcmV1bVByb3ZpZGVyKSxcbiAgICAgICAgICAgIGFjY291bnQ6IGVvYUFkZHJlc3MsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyB3YWxsZXQgY2xpZW50IGZvdW5kLiBFbnN1cmUgTWV0YU1hc2svV2ViM0F1dGggaXMgYXZhaWxhYmxlIG9yIHBhc3Mgd2FsbGV0Q2xpZW50IGluIG9wdGlvbnMuJyk7XG4gICAgfVxuICAgIGxldCBwdWJsaWNDbGllbnQ7XG4gICAgaWYgKG9wdGlvbnM/LnB1YmxpY0NsaWVudCkge1xuICAgICAgICBwdWJsaWNDbGllbnQgPSBvcHRpb25zLnB1YmxpY0NsaWVudDtcbiAgICB9XG4gICAgZWxzZSBpZiAob3B0aW9ucz8uZXRoZXJldW1Qcm92aWRlcikge1xuICAgICAgICBwdWJsaWNDbGllbnQgPSBjcmVhdGVQdWJsaWNDbGllbnQoe1xuICAgICAgICAgICAgY2hhaW46IGNoYWluLFxuICAgICAgICAgICAgdHJhbnNwb3J0OiBjdXN0b20ob3B0aW9ucz8uZXRoZXJldW1Qcm92aWRlciksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBwdWJsaWMgY2xpZW50IGZvdW5kLiBFbnN1cmUgUlBDIFVSTCBpcyBhdmFpbGFibGUgb3IgcGFzcyBwdWJsaWNDbGllbnQgaW4gb3B0aW9ucy4nKTtcbiAgICB9XG4gICAgY29uc3Qgc2FsdCA9IGtlY2NhazI1NihzdHJpbmdUb0hleChhZ2VudE5hbWUpKTtcbiAgICBjb25zdCBjbGllbnRDb25maWcgPSB7XG4gICAgICAgIGNsaWVudDogcHVibGljQ2xpZW50LFxuICAgICAgICBpbXBsZW1lbnRhdGlvbjogSW1wbGVtZW50YXRpb24uSHlicmlkLFxuICAgICAgICBzaWduZXI6IHtcbiAgICAgICAgICAgIHdhbGxldENsaWVudCxcbiAgICAgICAgfSxcbiAgICAgICAgZGVwbG95UGFyYW1zOiBbZW9hQWRkcmVzcywgW10sIFtdLCBbXV0sXG4gICAgICAgIGRlcGxveVNhbHQ6IHNhbHQsXG4gICAgfTtcbiAgICBsZXQgY291bnRlcmZhY3R1YWxBY2NvdW50Q2xpZW50ID0gYXdhaXQgdG9NZXRhTWFza1NtYXJ0QWNjb3VudChjbGllbnRDb25maWcpO1xuICAgIHJldHVybiBjb3VudGVyZmFjdHVhbEFjY291bnRDbGllbnQ7XG59XG4vKipcbiAqIEJ1aWxkIGEgZGVwbG95ZWQgTWV0YU1hc2sgc21hcnQgYWNjb3VudCBjbGllbnQgZnJvbSBhIGtub3duIHNtYXJ0IGFjY291bnQgYWRkcmVzcy5cbiAqIFByZWZlciB0aGlzIHdoZW4geW91IGFscmVhZHkga25vdyB0aGUgY29ycmVjdCBhZ2VudCBzbWFydCBhY2NvdW50IGFkZHJlc3MgKGFnZW50QWNjb3VudCksXG4gKiBzaW5jZSBuYW1lLWJhc2VkIGRlcml2YXRpb24gaXMgY2FzZS1zZW5zaXRpdmUuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXREZXBsb3llZEFjY291bnRDbGllbnRCeUFkZHJlc3MoYWNjb3VudEFkZHJlc3MsIGVvYUFkZHJlc3MsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBjaGFpbiA9IG9wdGlvbnM/LmNoYWluIHx8IHNlcG9saWE7XG4gICAgbGV0IHdhbGxldENsaWVudDtcbiAgICBpZiAob3B0aW9ucz8ud2FsbGV0Q2xpZW50KSB7XG4gICAgICAgIHdhbGxldENsaWVudCA9IG9wdGlvbnMud2FsbGV0Q2xpZW50O1xuICAgIH1cbiAgICBlbHNlIGlmIChvcHRpb25zPy5ldGhlcmV1bVByb3ZpZGVyKSB7XG4gICAgICAgIHdhbGxldENsaWVudCA9IGNyZWF0ZVdhbGxldENsaWVudCh7XG4gICAgICAgICAgICBjaGFpbjogY2hhaW4sXG4gICAgICAgICAgICB0cmFuc3BvcnQ6IGN1c3RvbShvcHRpb25zLmV0aGVyZXVtUHJvdmlkZXIpLFxuICAgICAgICAgICAgYWNjb3VudDogZW9hQWRkcmVzcyxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHdhbGxldCBjbGllbnQgZm91bmQuIEVuc3VyZSBNZXRhTWFzay9XZWIzQXV0aCBpcyBhdmFpbGFibGUgb3IgcGFzcyB3YWxsZXRDbGllbnQgaW4gb3B0aW9ucy4nKTtcbiAgICB9XG4gICAgY29uc3QgcnBjVXJsID0gZ2V0Q2hhaW5ScGNVcmwoY2hhaW4uaWQpO1xuICAgIGNvbnN0IHB1YmxpY0NsaWVudCA9IG9wdGlvbnM/LnB1YmxpY0NsaWVudFxuICAgICAgICA/IG9wdGlvbnMucHVibGljQ2xpZW50XG4gICAgICAgIDogY3JlYXRlUHVibGljQ2xpZW50KHtcbiAgICAgICAgICAgIGNoYWluOiBjaGFpbixcbiAgICAgICAgICAgIHRyYW5zcG9ydDogcnBjVXJsID8gaHR0cChycGNVcmwpIDogY3VzdG9tKG9wdGlvbnM/LmV0aGVyZXVtUHJvdmlkZXIpLFxuICAgICAgICB9KTtcbiAgICByZXR1cm4gYXdhaXQgdG9NZXRhTWFza1NtYXJ0QWNjb3VudCh7XG4gICAgICAgIGNsaWVudDogcHVibGljQ2xpZW50LFxuICAgICAgICBpbXBsZW1lbnRhdGlvbjogSW1wbGVtZW50YXRpb24uSHlicmlkLFxuICAgICAgICBzaWduZXI6IHsgd2FsbGV0Q2xpZW50IH0sXG4gICAgICAgIGFkZHJlc3M6IGFjY291bnRBZGRyZXNzLFxuICAgIH0pO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldERlcGxveWVkQWNjb3VudENsaWVudEJ5QWdlbnROYW1lKGJ1bmRsZXJVcmwsIGFnZW50TmFtZSwgZW9hQWRkcmVzcywgb3B0aW9ucykge1xuICAgIC8vIEV4dHJhY3Qgb25seSB0aGUgbmFtZSB0byB0aGUgbGVmdCBvZiB0aGUgZmlyc3QgJy4nXG4gICAgY29uc3Qgbm9ybWFsaXplZEFnZW50TmFtZSA9IGFnZW50TmFtZS5pbmNsdWRlcygnLicpID8gYWdlbnROYW1lLnNwbGl0KCcuJylbMF0gOiBhZ2VudE5hbWU7XG4gICAgLy8gRW5zdXJlIHdlIGhhdmUgYSB2YWxpZCBub24tZW1wdHkgc3RyaW5nXG4gICAgaWYgKCFub3JtYWxpemVkQWdlbnROYW1lIHx8IG5vcm1hbGl6ZWRBZ2VudE5hbWUudHJpbSgpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FnZW50IG5hbWUgaXMgcmVxdWlyZWQgYW5kIGNhbm5vdCBiZSBlbXB0eScpO1xuICAgIH1cbiAgICBjb25zdCBjaGFpbiA9IG9wdGlvbnM/LmNoYWluIHx8IHNlcG9saWE7XG4gICAgY29uc29sZS5pbmZvKCcqKioqKioqKioqKiBhY2NvdW50Q2xpZW50IGdldERlcGxveWVkQWNjb3VudENsaWVudEJ5QWdlbnROYW1lOiBhZ2VudE5hbWUnLCBhZ2VudE5hbWUsICdub3JtYWxpemVkOicsIG5vcm1hbGl6ZWRBZ2VudE5hbWUpO1xuICAgIGxldCB3YWxsZXRDbGllbnQ7XG4gICAgaWYgKG9wdGlvbnM/LndhbGxldENsaWVudCkge1xuICAgICAgICB3YWxsZXRDbGllbnQgPSBvcHRpb25zLndhbGxldENsaWVudDtcbiAgICB9XG4gICAgZWxzZSBpZiAob3B0aW9ucz8uZXRoZXJldW1Qcm92aWRlcikge1xuICAgICAgICB3YWxsZXRDbGllbnQgPSBjcmVhdGVXYWxsZXRDbGllbnQoe1xuICAgICAgICAgICAgY2hhaW46IGNoYWluLFxuICAgICAgICAgICAgdHJhbnNwb3J0OiBjdXN0b20ob3B0aW9ucy5ldGhlcmV1bVByb3ZpZGVyKSxcbiAgICAgICAgICAgIGFjY291bnQ6IGVvYUFkZHJlc3MsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyB3YWxsZXQgY2xpZW50IGZvdW5kLiBFbnN1cmUgTWV0YU1hc2svV2ViM0F1dGggaXMgYXZhaWxhYmxlIG9yIHBhc3Mgd2FsbGV0Q2xpZW50IGluIG9wdGlvbnMuJyk7XG4gICAgfVxuICAgIGxldCBwdWJsaWNDbGllbnQ7XG4gICAgaWYgKG9wdGlvbnM/LnB1YmxpY0NsaWVudCkge1xuICAgICAgICBwdWJsaWNDbGllbnQgPSBvcHRpb25zLnB1YmxpY0NsaWVudDtcbiAgICB9XG4gICAgZWxzZSBpZiAob3B0aW9ucz8uZXRoZXJldW1Qcm92aWRlcikge1xuICAgICAgICBwdWJsaWNDbGllbnQgPSBjcmVhdGVQdWJsaWNDbGllbnQoe1xuICAgICAgICAgICAgY2hhaW46IGNoYWluLFxuICAgICAgICAgICAgdHJhbnNwb3J0OiBjdXN0b20ob3B0aW9ucz8uZXRoZXJldW1Qcm92aWRlciksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBwdWJsaWMgY2xpZW50IGZvdW5kLiBFbnN1cmUgUlBDIFVSTCBpcyBhdmFpbGFibGUgb3IgcGFzcyBwdWJsaWNDbGllbnQgaW4gb3B0aW9ucy4nKTtcbiAgICB9XG4gICAgY29uc3Qgc2FsdCA9IGtlY2NhazI1NihzdHJpbmdUb0hleChub3JtYWxpemVkQWdlbnROYW1lKSk7XG4gICAgY29uc3QgY2xpZW50Q29uZmlnID0ge1xuICAgICAgICBjbGllbnQ6IHB1YmxpY0NsaWVudCxcbiAgICAgICAgaW1wbGVtZW50YXRpb246IEltcGxlbWVudGF0aW9uLkh5YnJpZCxcbiAgICAgICAgc2lnbmVyOiB7XG4gICAgICAgICAgICB3YWxsZXRDbGllbnQsXG4gICAgICAgIH0sXG4gICAgICAgIGRlcGxveVBhcmFtczogW2VvYUFkZHJlc3MsIFtdLCBbXSwgW11dLFxuICAgICAgICBkZXBsb3lTYWx0OiBzYWx0LFxuICAgIH07XG4gICAgbGV0IGNvdW50ZXJmYWN0dWFsQWNjb3VudENsaWVudCA9IGF3YWl0IHRvTWV0YU1hc2tTbWFydEFjY291bnQoY2xpZW50Q29uZmlnKTtcbiAgICAvLyBDaGVjayBkZXBsb3ltZW50IHN0YXR1cyB3aXRoIHByb3ZpZGVkIHB1YmxpY0NsaWVudCwgdGhlbiBmYWxsIGJhY2sgdG8gSFRUUCBSUEMgaWYgYXZhaWxhYmxlXG4gICAgbGV0IGlzRGVwbG95ZWQgPSBmYWxzZTtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBjb2RlID0gYXdhaXQgcHVibGljQ2xpZW50LmdldEJ5dGVjb2RlKHsgYWRkcmVzczogY291bnRlcmZhY3R1YWxBY2NvdW50Q2xpZW50LmFkZHJlc3MgfSk7XG4gICAgICAgIGlzRGVwbG95ZWQgPSAhIWNvZGUgJiYgY29kZSAhPT0gXCIweFwiO1xuICAgIH1cbiAgICBjYXRjaCB7IH1cbiAgICBpZiAoIWlzRGVwbG95ZWQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJwY1VybCA9IGdldENoYWluUnBjVXJsKGNoYWluLmlkKTtcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbygnKioqKioqKioqKiogYWNjb3VudENsaWVudCBnZXREZXBsb3llZEFjY291bnRDbGllbnRCeUFnZW50TmFtZTogY2hlY2tpbmcgb24gUlBDJywgcnBjVXJsKTtcbiAgICAgICAgICAgIGlmIChycGNVcmwpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBodHRwQ2xpZW50ID0gY3JlYXRlUHVibGljQ2xpZW50KHsgY2hhaW46IGNoYWluLCB0cmFuc3BvcnQ6IGh0dHAocnBjVXJsKSB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCBjb2RlSHR0cCA9IGF3YWl0IGh0dHBDbGllbnQuZ2V0Qnl0ZWNvZGUoeyBhZGRyZXNzOiBjb3VudGVyZmFjdHVhbEFjY291bnRDbGllbnQuYWRkcmVzcyB9KTtcbiAgICAgICAgICAgICAgICBpc0RlcGxveWVkID0gISFjb2RlSHR0cCAmJiBjb2RlSHR0cCAhPT0gXCIweFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIHsgfVxuICAgIH1cbiAgICBjb25zb2xlLmluZm8oJyoqKioqKioqKioqIGFjY291bnRDbGllbnQgZ2V0RGVwbG95ZWRBY2NvdW50Q2xpZW50QnlBZ2VudE5hbWU6IGlzRGVwbG95ZWQnLCBpc0RlcGxveWVkKTtcbiAgICBpZiAoIWlzRGVwbG95ZWQgJiYgYnVuZGxlclVybCkge1xuICAgICAgICBjb25zb2xlLmluZm8oJyoqKioqKioqKioqIGFjY291bnRDbGllbnQgZ2V0RGVwbG95ZWRBY2NvdW50Q2xpZW50QnlBZ2VudE5hbWU6IGRlcGxveWluZyB2aWEgYnVuZGxlcicpO1xuICAgICAgICBjb25zdCBwaW1saWNvID0gYXdhaXQgZ2V0UGltbGljb0NsaWVudChidW5kbGVyVXJsKTtcbiAgICAgICAgY29uc3QgYnVuZGxlckNsaWVudCA9IGNyZWF0ZUJ1bmRsZXJDbGllbnQoe1xuICAgICAgICAgICAgdHJhbnNwb3J0OiBodHRwKGJ1bmRsZXJVcmwpLFxuICAgICAgICAgICAgcGF5bWFzdGVyOiB0cnVlLFxuICAgICAgICAgICAgY2hhaW46IGNoYWluLFxuICAgICAgICAgICAgcGF5bWFzdGVyQ29udGV4dDogeyBtb2RlOiAnU1BPTlNPUkVEJyB9LFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgeyBmYXN0OiBmZWUgfSA9IGF3YWl0IHBpbWxpY28uZ2V0VXNlck9wZXJhdGlvbkdhc1ByaWNlKCk7XG4gICAgICAgIGNvbnNvbGUuaW5mbygnKioqKioqKioqKiogYWNjb3VudENsaWVudCBnZXREZXBsb3llZEFjY291bnRDbGllbnRCeUFnZW50TmFtZTogZ2FzIHByaWNlJywgZmVlKTtcbiAgICAgICAgY29uc3QgdXNlck9wZXJhdGlvbkhhc2ggPSBhd2FpdCBidW5kbGVyQ2xpZW50LnNlbmRVc2VyT3BlcmF0aW9uKHtcbiAgICAgICAgICAgIGFjY291bnQ6IGNvdW50ZXJmYWN0dWFsQWNjb3VudENsaWVudCxcbiAgICAgICAgICAgIGNhbGxzOiBbeyB0bzogemVyb0FkZHJlc3MgfV0sXG4gICAgICAgICAgICAuLi5mZWUsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zb2xlLmluZm8oJyoqKioqKioqKioqIGFjY291bnRDbGllbnQgZ2V0RGVwbG95ZWRBY2NvdW50Q2xpZW50QnlBZ2VudE5hbWU6IHVzZXJPcGVyYXRpb25IYXNoJywgdXNlck9wZXJhdGlvbkhhc2gpO1xuICAgICAgICBhd2FpdCBidW5kbGVyQ2xpZW50LndhaXRGb3JVc2VyT3BlcmF0aW9uUmVjZWlwdCh7IGhhc2g6IHVzZXJPcGVyYXRpb25IYXNoIH0pO1xuICAgICAgICAvLyBBZnRlciBkZXBsb3ltZW50LCBtYXJrIGFzIGRlcGxveWVkIHNvIHdlIHJlYnVpbGQgYmVsb3dcbiAgICAgICAgaXNEZXBsb3llZCA9IHRydWU7XG4gICAgfVxuICAgIGlmIChpc0RlcGxveWVkKSB7XG4gICAgICAgIC8vIFJlYnVpbGQgYSBcImNsZWFuXCIgc21hcnQgYWNjb3VudCBjbGllbnQgd2l0aCBhZGRyZXNzIG9ubHkgKG5vIGZhY3RvcnkvZGVwbG95IHBhcmFtcylcbiAgICAgICAgLy8gdXNpbmcgYW4gSFRUUCBwdWJsaWMgY2xpZW50IHRvIGF2b2lkIHByb3ZpZGVyIHF1aXJrcy5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJwY1VybCA9IGdldENoYWluUnBjVXJsKGNoYWluLmlkKTtcbiAgICAgICAgICAgIGNvbnN0IGh0dHBDbGllbnQgPSBjcmVhdGVQdWJsaWNDbGllbnQoeyBjaGFpbjogY2hhaW4sIHRyYW5zcG9ydDogaHR0cChycGNVcmwpIH0pO1xuICAgICAgICAgICAgY29uc29sZS5pbmZvKCcqKioqKioqKioqKiBhY2NvdW50Q2xpZW50IGdldERlcGxveWVkQWNjb3VudENsaWVudEJ5QWdlbnROYW1lOiByZWJ1aWxkaW5nIGRlcGxveWVkIGFjY291bnQgY2xpZW50IChhZGRyZXNzLW9ubHkpJyk7XG4gICAgICAgICAgICBjb25zdCBkZXBsb3llZEFjY291bnRDbGllbnQgPSBhd2FpdCB0b01ldGFNYXNrU21hcnRBY2NvdW50KHtcbiAgICAgICAgICAgICAgICBjbGllbnQ6IGh0dHBDbGllbnQsXG4gICAgICAgICAgICAgICAgaW1wbGVtZW50YXRpb246IEltcGxlbWVudGF0aW9uLkh5YnJpZCxcbiAgICAgICAgICAgICAgICBzaWduZXI6IHtcbiAgICAgICAgICAgICAgICAgICAgd2FsbGV0Q2xpZW50OiB3YWxsZXRDbGllbnQsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBhZGRyZXNzOiBjb3VudGVyZmFjdHVhbEFjY291bnRDbGllbnQuYWRkcmVzcyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc29sZS5pbmZvKCcqKioqKioqKioqKiBhY2NvdW50Q2xpZW50IGdldERlcGxveWVkQWNjb3VudENsaWVudEJ5QWdlbnROYW1lOiBhZ2VudEFjY291bnRDbGllbnQnLCBkZXBsb3llZEFjY291bnRDbGllbnQuYWRkcmVzcyk7XG4gICAgICAgICAgICByZXR1cm4gZGVwbG95ZWRBY2NvdW50Q2xpZW50O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChyZWJ1aWxkRXJyKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJyoqKioqKioqKioqIGFjY291bnRDbGllbnQgZ2V0RGVwbG95ZWRBY2NvdW50Q2xpZW50QnlBZ2VudE5hbWU6IHJlYnVpbGQgZmFpbGVkLCBmYWxsaW5nIGJhY2sgdG8gZXhpc3RpbmcgY2xpZW50JywgcmVidWlsZEVycik7XG4gICAgICAgICAgICByZXR1cm4gY291bnRlcmZhY3R1YWxBY2NvdW50Q2xpZW50O1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnNvbGUuaW5mbygnKioqKioqKioqKiogYWNjb3VudENsaWVudCBnZXREZXBsb3llZEFjY291bnRDbGllbnRCeUFnZW50TmFtZTogYWdlbnRBY2NvdW50Q2xpZW50JywgY291bnRlcmZhY3R1YWxBY2NvdW50Q2xpZW50LmFkZHJlc3MpO1xuICAgIHJldHVybiBjb3VudGVyZmFjdHVhbEFjY291bnRDbGllbnQ7XG59XG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBCdW5kbGVyIFV0aWxpdGllc1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gRHluYW1pYyBpbXBvcnQgZm9yIHBlcm1pc3Npb25sZXNzIChvcHRpb25hbCBkZXBlbmRlbmN5KVxuYXN5bmMgZnVuY3Rpb24gZ2V0UGltbGljb0NsaWVudChidW5kbGVyVXJsKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZSAtIHBlcm1pc3Npb25sZXNzIGlzIGFuIG9wdGlvbmFsIGRlcGVuZGVuY3lcbiAgICAgICAgY29uc3QgeyBjcmVhdGVQaW1saWNvQ2xpZW50IH0gPSBhd2FpdCBpbXBvcnQoJ3Blcm1pc3Npb25sZXNzL2NsaWVudHMvcGltbGljbycpO1xuICAgICAgICByZXR1cm4gY3JlYXRlUGltbGljb0NsaWVudCh7IHRyYW5zcG9ydDogaHR0cChidW5kbGVyVXJsKSB9KTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncGVybWlzc2lvbmxlc3MgcGFja2FnZSBub3QgaW5zdGFsbGVkLiBJbnN0YWxsIGl0IHdpdGg6IHBucG0gYWRkIHBlcm1pc3Npb25sZXNzICcgK1xuICAgICAgICAgICAgYEVycm9yOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InfWApO1xuICAgIH1cbn1cbi8qKlxuICogU2VuZCBhIHNwb25zb3JlZCBVc2VyT3BlcmF0aW9uIHZpYSBidW5kbGVyXG4gKlxuICogQHBhcmFtIHBhcmFtcyAtIFVzZXJPcGVyYXRpb24gcGFyYW1ldGVyc1xuICogQHJldHVybnMgVXNlck9wZXJhdGlvbiBoYXNoXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzZW5kU3BvbnNvcmVkVXNlck9wZXJhdGlvbihwYXJhbXMpIHtcbiAgICBjb25zdCB7IGJ1bmRsZXJVcmwsIGNoYWluLCBhY2NvdW50Q2xpZW50LCBjYWxscyB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IHBpbWxpY29DbGllbnQgPSBhd2FpdCBnZXRQaW1saWNvQ2xpZW50KGJ1bmRsZXJVcmwpO1xuICAgIGNvbnN0IGJ1bmRsZXJDbGllbnQgPSBjcmVhdGVCdW5kbGVyQ2xpZW50KHtcbiAgICAgICAgdHJhbnNwb3J0OiBodHRwKGJ1bmRsZXJVcmwpLFxuICAgICAgICBwYXltYXN0ZXI6IHRydWUsXG4gICAgICAgIGNoYWluOiBjaGFpbixcbiAgICAgICAgcGF5bWFzdGVyQ29udGV4dDogeyBtb2RlOiAnU1BPTlNPUkVEJyB9XG4gICAgfSk7XG4gICAgY29uc3QgeyBmYXN0OiBmZWUgfSA9IGF3YWl0IHBpbWxpY29DbGllbnQuZ2V0VXNlck9wZXJhdGlvbkdhc1ByaWNlKCk7XG4gICAgY29uc3QgdXNlck9wSGFzaCA9IGF3YWl0IGJ1bmRsZXJDbGllbnQuc2VuZFVzZXJPcGVyYXRpb24oe1xuICAgICAgICBhY2NvdW50OiBhY2NvdW50Q2xpZW50LFxuICAgICAgICBjYWxscyxcbiAgICAgICAgLi4uZmVlXG4gICAgfSk7XG4gICAgcmV0dXJuIHVzZXJPcEhhc2g7XG59XG4vKipcbiAqIFdhaXQgZm9yIFVzZXJPcGVyYXRpb24gcmVjZWlwdFxuICpcbiAqIEBwYXJhbSBwYXJhbXMgLSBSZWNlaXB0IHBhcmFtZXRlcnNcbiAqIEByZXR1cm5zIFVzZXJPcGVyYXRpb24gcmVjZWlwdFxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gd2FpdEZvclVzZXJPcGVyYXRpb25SZWNlaXB0KHBhcmFtcykge1xuICAgIGNvbnN0IHsgYnVuZGxlclVybCwgY2hhaW4sIGhhc2ggfSA9IHBhcmFtcztcbiAgICBjb25zdCBidW5kbGVyQ2xpZW50ID0gY3JlYXRlQnVuZGxlckNsaWVudCh7XG4gICAgICAgIHRyYW5zcG9ydDogaHR0cChidW5kbGVyVXJsKSxcbiAgICAgICAgcGF5bWFzdGVyOiB0cnVlLFxuICAgICAgICBjaGFpbjogY2hhaW4sXG4gICAgICAgIHBheW1hc3RlckNvbnRleHQ6IHsgbW9kZTogJ1NQT05TT1JFRCcgfVxuICAgIH0pO1xuICAgIHJldHVybiBhd2FpdCBidW5kbGVyQ2xpZW50LndhaXRGb3JVc2VyT3BlcmF0aW9uUmVjZWlwdCh7IGhhc2ggfSk7XG59XG4vKipcbiAqIERlcGxveSBzbWFydCBhY2NvdW50IGlmIG5lZWRlZFxuICpcbiAqIEBwYXJhbSBwYXJhbXMgLSBEZXBsb3ltZW50IHBhcmFtZXRlcnNcbiAqIEByZXR1cm5zIHRydWUgaWYgYWNjb3VudCB3YXMgZGVwbG95ZWQsIGZhbHNlIGlmIGFscmVhZHkgZGVwbG95ZWRcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGRlcGxveVNtYXJ0QWNjb3VudElmTmVlZGVkKHBhcmFtcykge1xuICAgIGNvbnN0IHsgYnVuZGxlclVybCwgY2hhaW4sIGFjY291bnQgfSA9IHBhcmFtcztcbiAgICBjb25zdCBpc0RlcGxveWVkID0gYXdhaXQgYWNjb3VudC5pc0RlcGxveWVkKCk7XG4gICAgaWYgKGlzRGVwbG95ZWQpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCBwaW1saWNvID0gYXdhaXQgZ2V0UGltbGljb0NsaWVudChidW5kbGVyVXJsKTtcbiAgICBjb25zdCBidW5kbGVyQ2xpZW50ID0gY3JlYXRlQnVuZGxlckNsaWVudCh7XG4gICAgICAgIHRyYW5zcG9ydDogaHR0cChidW5kbGVyVXJsKSxcbiAgICAgICAgcGF5bWFzdGVyOiB0cnVlLFxuICAgICAgICBjaGFpbjogY2hhaW4sXG4gICAgICAgIHBheW1hc3RlckNvbnRleHQ6IHsgbW9kZTogJ1NQT05TT1JFRCcgfVxuICAgIH0pO1xuICAgIGNvbnN0IHsgZmFzdCB9ID0gYXdhaXQgcGltbGljby5nZXRVc2VyT3BlcmF0aW9uR2FzUHJpY2UoKTtcbiAgICBjb25zdCB1c2VyT3BlcmF0aW9uSGFzaCA9IGF3YWl0IGJ1bmRsZXJDbGllbnQuc2VuZFVzZXJPcGVyYXRpb24oe1xuICAgICAgICBhY2NvdW50LFxuICAgICAgICBjYWxsczogW3sgdG86IHplcm9BZGRyZXNzIH1dLFxuICAgICAgICAuLi5mYXN0XG4gICAgfSk7XG4gICAgYXdhaXQgYnVuZGxlckNsaWVudC53YWl0Rm9yVXNlck9wZXJhdGlvblJlY2VpcHQoeyBoYXNoOiB1c2VyT3BlcmF0aW9uSGFzaCB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbi8qKlxuICogQ2hlY2sgaWYgYW4gYWRkcmVzcyBpcyBhIHNtYXJ0IGNvbnRyYWN0IChoYXMgY29kZSlcbiAqXG4gKiBAcGFyYW0gcHVibGljQ2xpZW50IC0gVmllbSBwdWJsaWMgY2xpZW50XG4gKiBAcGFyYW0gYWRkcmVzcyAtIEFkZHJlc3MgdG8gY2hlY2tcbiAqIEByZXR1cm5zIHRydWUgaWYgYWRkcmVzcyBoYXMgY29kZSAoaXMgYSBjb250cmFjdCksIGZhbHNlIGlmIEVPQVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gaXNTbWFydENvbnRyYWN0KHB1YmxpY0NsaWVudCwgYWRkcmVzcykge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGNvZGUgPSBhd2FpdCBwdWJsaWNDbGllbnQuZ2V0Qnl0ZWNvZGUoeyBhZGRyZXNzIH0pO1xuICAgICAgICByZXR1cm4gY29kZSAhPT0gdW5kZWZpbmVkICYmIGNvZGUgIT09ICcweCc7XG4gICAgfVxuICAgIGNhdGNoIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFjY291bnRDbGllbnQuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@agentic-trust/core/dist/client/accountClient.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@agentic-trust/core/dist/client/sessionPackageBuilder.js":
/*!***********************************************************************************!*\
  !*** ../../node_modules/@agentic-trust/core/dist/client/sessionPackageBuilder.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   generateSessionPackage: () => (/* binding */ generateSessionPackage)\n/* harmony export */ });\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! viem */ \"(rsc)/../../node_modules/viem/_esm/utils/hash/keccak256.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! viem */ \"(rsc)/../../node_modules/viem/_esm/utils/encoding/toHex.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! viem */ \"(rsc)/../../node_modules/viem/_esm/clients/createPublicClient.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! viem */ \"(rsc)/../../node_modules/viem/_esm/clients/transports/http.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! viem */ \"(rsc)/../../node_modules/viem/_esm/clients/createWalletClient.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! viem */ \"(rsc)/../../node_modules/viem/_esm/clients/transports/custom.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! viem */ \"(rsc)/../../node_modules/viem/_esm/constants/address.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! viem */ \"(rsc)/../../node_modules/viem/_esm/utils/abi/encodeFunctionData.js\");\n/* harmony import */ var viem_accounts__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! viem/accounts */ \"(rsc)/../../node_modules/viem/_esm/accounts/generatePrivateKey.js\");\n/* harmony import */ var viem_accounts__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! viem/accounts */ \"(rsc)/../../node_modules/viem/_esm/accounts/privateKeyToAccount.js\");\n/* harmony import */ var _metamask_smart_accounts_kit__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @metamask/smart-accounts-kit */ \"(rsc)/../../node_modules/@metamask/smart-accounts-kit/dist/index.mjs\");\n/* harmony import */ var _metamask_smart_accounts_kit__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @metamask/smart-accounts-kit */ \"(rsc)/../../node_modules/@metamask/smart-accounts-kit/dist/chunk-7MRTROLV.mjs\");\n/* harmony import */ var _metamask_smart_accounts_kit__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! @metamask/smart-accounts-kit */ \"(rsc)/../../node_modules/@metamask/smart-accounts-kit/dist/chunk-MVKT5CLQ.mjs\");\n/* harmony import */ var _metamask_smart_accounts_kit__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! @metamask/smart-accounts-kit */ \"(rsc)/../../node_modules/@metamask/smart-accounts-kit/dist/chunk-UUDQWENY.mjs\");\n/* harmony import */ var _metamask_smart_accounts_kit__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! @metamask/smart-accounts-kit */ \"(rsc)/../../node_modules/@metamask/smart-accounts-kit/dist/chunk-CPLIK3VF.mjs\");\n/* harmony import */ var _metamask_smart_accounts_kit_contracts__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! @metamask/smart-accounts-kit/contracts */ \"(rsc)/../../node_modules/@metamask/smart-accounts-kit/dist/chunk-6RN5RBOR.mjs\");\n/* harmony import */ var _agentic_trust_8004_ext_sdk_abis_IdentityRegistry_json__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @agentic-trust/8004-ext-sdk/abis/IdentityRegistry.json */ \"(rsc)/../../node_modules/@agentic-trust/8004-ext-sdk/abis/IdentityRegistry.json\");\n/* harmony import */ var _agentic_trust_8004_ext_sdk_abis_ValidationRegistry_json__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @agentic-trust/8004-ext-sdk/abis/ValidationRegistry.json */ \"(rsc)/../../node_modules/@agentic-trust/8004-ext-sdk/abis/ValidationRegistry.json\");\n/* harmony import */ var _server_lib_chainConfig__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../server/lib/chainConfig */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/lib/chainConfig.js\");\n/* harmony import */ var _accountClient__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./accountClient */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/client/accountClient.js\");\n\n\n\n\n// @ts-ignore - contracts subpath may not be in main type definitions\n\n\n\n\n\nconst VALIDATION_RESPONSE_SIGNATURE = 'validationResponse(bytes32,uint8,string,bytes32,bytes32)';\nconst DEFAULT_SELECTOR = (0,viem__WEBPACK_IMPORTED_MODULE_4__.keccak256)((0,viem__WEBPACK_IMPORTED_MODULE_5__.stringToHex)(VALIDATION_RESPONSE_SIGNATURE)).slice(0, 10);\nconst DEFAULT_ENTRY_POINT = '0x0000000071727De22E5E9d8BAf0edAc6f37da032';\nfunction normalizeHex(value) {\n    if (!value)\n        return undefined;\n    const trimmed = value.trim();\n    if (!trimmed)\n        return undefined;\n    return trimmed.startsWith('0x') ? trimmed : `0x${trimmed}`;\n}\nfunction getIdentityRegistryAddress(chainId) {\n    const cfg = (0,_server_lib_chainConfig__WEBPACK_IMPORTED_MODULE_2__.getChainConfig)(chainId);\n    if (!cfg)\n        return undefined;\n    const key = `NEXT_PUBLIC_AGENTIC_TRUST_IDENTITY_REGISTRY_${cfg.suffix}`;\n    return normalizeHex(process.env[key] ?? process.env.NEXT_PUBLIC_AGENTIC_TRUST_IDENTITY_REGISTRY ?? undefined);\n}\nfunction getReputationRegistryAddress(chainId) {\n    const cfg = (0,_server_lib_chainConfig__WEBPACK_IMPORTED_MODULE_2__.getChainConfig)(chainId);\n    if (!cfg)\n        return undefined;\n    const key = `NEXT_PUBLIC_AGENTIC_TRUST_REPUTATION_REGISTRY_${cfg.suffix}`;\n    return normalizeHex(process.env[key] ?? process.env.NEXT_PUBLIC_AGENTIC_TRUST_REPUTATION_REGISTRY ?? undefined);\n}\nfunction getValidationRegistryAddress(chainId) {\n    const cfg = (0,_server_lib_chainConfig__WEBPACK_IMPORTED_MODULE_2__.getChainConfig)(chainId);\n    if (!cfg)\n        return undefined;\n    const key = `NEXT_PUBLIC_AGENTIC_TRUST_VALIDATION_REGISTRY_${cfg.suffix}`;\n    console.info('*********** sessionPackageBuilder: validationRegistry', key);\n    console.info('*********** sessionPackageBuilder: validationRegistry', process.env[key]);\n    return normalizeHex(process.env[key] ?? process.env.NEXT_PUBLIC_AGENTIC_TRUST_VALIDATION_REGISTRY ?? undefined);\n}\nfunction getAssociationsProxyAddress(chainId) {\n    // Try chain-specific env var first, then fallback to generic env var, then default\n    const cfg = (0,_server_lib_chainConfig__WEBPACK_IMPORTED_MODULE_2__.getChainConfig)(chainId);\n    if (cfg) {\n        const chainKey = `ASSOCIATIONS_STORE_PROXY_${cfg.suffix}`;\n        const chainValue = normalizeHex(process.env[chainKey] ?? process.env[`NEXT_PUBLIC_ASSOCIATIONS_STORE_PROXY_${cfg.suffix}`]);\n        if (chainValue)\n            return chainValue;\n    }\n    const genericValue = normalizeHex(process.env.ASSOCIATIONS_STORE_PROXY ?? process.env.ASSOCIATIONS_PROXY_ADDRESS ?? process.env.NEXT_PUBLIC_ASSOCIATIONS_STORE_PROXY);\n    if (genericValue)\n        return genericValue;\n    // Default Sepolia address\n    return '0xaF7428906D31918dDA2986D1405E2Ded06561E59';\n}\nasync function switchChain(provider, chainId, rpcUrl) {\n    const chainIdHex = (0,_server_lib_chainConfig__WEBPACK_IMPORTED_MODULE_2__.getChainIdHex)(chainId);\n    try {\n        await provider.request({\n            method: 'wallet_switchEthereumChain',\n            params: [{ chainId: chainIdHex }],\n        });\n    }\n    catch (error) {\n        if (error?.code === 4902) {\n            const chainConfig = (0,_server_lib_chainConfig__WEBPACK_IMPORTED_MODULE_2__.getChainConfig)(chainId);\n            const chainName = chainConfig?.displayName ?? `Chain ${chainId}`;\n            await provider.request({\n                method: 'wallet_addEthereumChain',\n                params: [\n                    {\n                        chainId: chainIdHex,\n                        chainName,\n                        nativeCurrency: { name: 'Ether', symbol: 'ETH', decimals: 18 },\n                        rpcUrls: [rpcUrl],\n                    },\n                ],\n            });\n        }\n        else {\n            throw error;\n        }\n    }\n}\nasync function generateSessionPackage(params) {\n    const { agentId, chainId, agentAccount, provider, ownerAddress, rpcUrl: rpcUrlOverride, bundlerUrl: bundlerUrlOverride, identityRegistry: identityRegistryOverride, reputationRegistry: reputationRegistryOverride, validationRegistry: validationRegistryOverride, selector = DEFAULT_SELECTOR, } = params;\n    if (!provider) {\n        throw new Error('An EIP-1193 provider is required to generate a session package.');\n    }\n    if (!ownerAddress) {\n        throw new Error('Wallet address is required to generate a session package.');\n    }\n    if (!agentAccount) {\n        throw new Error('Agent account is required to generate a session package.');\n    }\n    const rpcUrl = rpcUrlOverride ?? (0,_server_lib_chainConfig__WEBPACK_IMPORTED_MODULE_2__.getChainRpcUrl)(chainId);\n    if (!rpcUrl) {\n        throw new Error(`Missing RPC URL for chain ${chainId}`);\n    }\n    const bundlerUrl = bundlerUrlOverride ?? (0,_server_lib_chainConfig__WEBPACK_IMPORTED_MODULE_2__.getChainBundlerUrl)(chainId);\n    if (!bundlerUrl) {\n        throw new Error(`Missing bundler URL for chain ${chainId}`);\n    }\n    const chain = (0,_server_lib_chainConfig__WEBPACK_IMPORTED_MODULE_2__.getChainById)(chainId);\n    const identityRegistry = identityRegistryOverride ?? getIdentityRegistryAddress(chainId);\n    if (!identityRegistry) {\n        throw new Error(`Missing IdentityRegistry address for chain ${chainId}. ` +\n            `Set NEXT_PUBLIC_AGENTIC_TRUST_IDENTITY_REGISTRY or ` +\n            `NEXT_PUBLIC_AGENTIC_TRUST_IDENTITY_REGISTRY_<CHAIN_SUFFIX> in your env.`);\n    }\n    const reputationRegistry = reputationRegistryOverride ?? getReputationRegistryAddress(chainId);\n    if (!reputationRegistry) {\n        throw new Error(`Missing ReputationRegistry address for chain ${chainId}. ` +\n            `Set NEXT_PUBLIC_AGENTIC_TRUST_REPUTATION_REGISTRY or ` +\n            `NEXT_PUBLIC_AGENTIC_TRUST_REPUTATION_REGISTRY_<CHAIN_SUFFIX> in your env.`);\n    }\n    const validationRegistry = validationRegistryOverride ?? getValidationRegistryAddress(chainId);\n    if (!validationRegistry) {\n        throw new Error(`Missing ValidationRegistry address for chain ${chainId}. ` +\n            `Set NEXT_PUBLIC_AGENTIC_TRUST_VALIDATION_REGISTRY or ` +\n            `NEXT_PUBLIC_AGENTIC_TRUST_VALIDATION_REGISTRY_<CHAIN_SUFFIX> in your env.`);\n    }\n    await switchChain(provider, chainId, rpcUrl);\n    await new Promise(resolve => setTimeout(resolve, 1000));\n    const publicClient = (0,viem__WEBPACK_IMPORTED_MODULE_6__.createPublicClient)({\n        chain,\n        transport: (0,viem__WEBPACK_IMPORTED_MODULE_7__.http)(rpcUrl),\n    });\n    const walletClient = (0,viem__WEBPACK_IMPORTED_MODULE_8__.createWalletClient)({\n        chain,\n        transport: (0,viem__WEBPACK_IMPORTED_MODULE_9__.custom)(provider),\n        account: ownerAddress,\n    });\n    console.info('*********** sessionPackageBuilder: walletClient', walletClient?.account?.address);\n    console.info('*********** sessionPackageBuilder: agentAccount', agentAccount);\n    const smartAccount = await (0,_metamask_smart_accounts_kit__WEBPACK_IMPORTED_MODULE_10__.toMetaMaskSmartAccount)({\n        address: agentAccount,\n        client: publicClient,\n        implementation: _metamask_smart_accounts_kit__WEBPACK_IMPORTED_MODULE_11__.Implementation.Hybrid,\n        signer: {\n            walletClient: walletClient,\n        },\n    });\n    const entryPoint = DEFAULT_ENTRY_POINT;\n    const aaCode = await publicClient.getBytecode({ address: agentAccount });\n    const aaDeployed = !!aaCode && aaCode !== '0x';\n    if (!aaDeployed) {\n        const hash = await (0,_accountClient__WEBPACK_IMPORTED_MODULE_3__.sendSponsoredUserOperation)({\n            bundlerUrl,\n            chain,\n            accountClient: smartAccount,\n            calls: [{ to: viem__WEBPACK_IMPORTED_MODULE_12__.zeroAddress }],\n        });\n        await (0,_accountClient__WEBPACK_IMPORTED_MODULE_3__.waitForUserOperationReceipt)({ bundlerUrl, chain, hash });\n    }\n    const sessionPrivateKey = (0,viem_accounts__WEBPACK_IMPORTED_MODULE_13__.generatePrivateKey)();\n    const sessionKeyAccount = (0,viem_accounts__WEBPACK_IMPORTED_MODULE_14__.privateKeyToAccount)(sessionPrivateKey);\n    const validUntil = Math.floor(Date.now() / 1000) + 60 * 30;\n    const validAfter = validUntil - 60 * 30 - 60;\n    console.info('*********** sessionPackageBuilder signer: sessionKeyAccount aaa:  ', sessionKeyAccount.address);\n    const burnerAccountClient = await (0,_metamask_smart_accounts_kit__WEBPACK_IMPORTED_MODULE_10__.toMetaMaskSmartAccount)({\n        client: publicClient,\n        implementation: _metamask_smart_accounts_kit__WEBPACK_IMPORTED_MODULE_11__.Implementation.Hybrid,\n        deployParams: [sessionKeyAccount.address, [], [], []],\n        signer: { account: sessionKeyAccount },\n        deploySalt: (0,viem__WEBPACK_IMPORTED_MODULE_5__.toHex)(10),\n    });\n    const sessionAA = (await burnerAccountClient.getAddress());\n    const sessionCode = await publicClient.getBytecode({ address: sessionAA });\n    const sessionDeployed = !!sessionCode && sessionCode !== '0x';\n    if (!sessionDeployed) {\n        const hash = await (0,_accountClient__WEBPACK_IMPORTED_MODULE_3__.sendSponsoredUserOperation)({\n            bundlerUrl,\n            chain,\n            accountClient: burnerAccountClient,\n            calls: [{ to: viem__WEBPACK_IMPORTED_MODULE_12__.zeroAddress }],\n        });\n        await (0,_accountClient__WEBPACK_IMPORTED_MODULE_3__.waitForUserOperationReceipt)({ bundlerUrl, chain, hash });\n    }\n    // Get the correct HybridDeleGator address from the smart accounts kit\n    // This MUST match the EIP-712 domain used by the contract that verifies the delegation\n    const deleGatorEnv = (0,_metamask_smart_accounts_kit__WEBPACK_IMPORTED_MODULE_15__.getSmartAccountsEnvironment)(chainId);\n    const entryPointAddress = deleGatorEnv.EntryPoint || entryPoint;\n    // The HybridDeleGator address is in the implementations object\n    // The property name is HybridDeleGatorImpl (as confirmed by the environment structure)\n    let hybridDelegatorAddress = deleGatorEnv.implementations?.HybridDeleGatorImpl;\n    console.info('*********** sessionPackageBuilder: hybridDelegatorAddress', hybridDelegatorAddress);\n    // If not found in implementations, try to get from smart account\n    // For Hybrid implementation, the implementation address might be the HybridDeleGator\n    if (!hybridDelegatorAddress) {\n        const accountImpl = smartAccount.implementationAddress ||\n            smartAccount.implementation?.address ||\n            smartAccount.getImplementationAddress?.();\n        if (accountImpl) {\n            console.warn(`[sessionPackageBuilder] HybridDeleGator not found in deleGatorEnv, using smart account implementation: ${accountImpl}`);\n            hybridDelegatorAddress = accountImpl;\n        }\n    }\n    if (!hybridDelegatorAddress) {\n        throw new Error(`HybridDeleGator address not found for chainId ${chainId}. ` +\n            `DeleGatorEnvironment: ${JSON.stringify({\n                EntryPoint: deleGatorEnv.EntryPoint,\n                implementations: deleGatorEnv.implementations\n            })}. ` +\n            `Check @metamask/smart-accounts-kit configuration.`);\n    }\n    /*\n      const environment = (smartAccount as any).environment;\n      if (!environment) {\n        throw new Error('Delegation environment is unavailable on the smart account.');\n      }\n      console.info('*********** sessionPackageBuilder: environment', environment);\n    */\n    console.info('*********** sessionPackageBuilder: createDelegation');\n    // Create delegation scope that allows validationResponse (and a read-only test method) on ValidationRegistry\n    // Also include ERC-8092 associations proxy to allow storeAssociation calls\n    // And include the agentAccount itself for ERC-1271 validation\n    const targets = [];\n    if (validationRegistry) {\n        targets.push(validationRegistry);\n    }\n    else {\n        throw new Error('validationRegistry address is required to build delegation scope');\n    }\n    // Include agentAccount in targets for delegation-aware ERC-1271 validation\n    // This allows sessionAA to call isValidSignature on agentAccount\n    targets.push(agentAccount);\n    // Add ERC-8092 associations proxy to allowed targets\n    const associationsProxy = getAssociationsProxyAddress(chainId);\n    if (associationsProxy) {\n        targets.push(associationsProxy);\n        console.info('*********** sessionPackageBuilder: Added associations proxy to delegation targets:', associationsProxy);\n    }\n    // Include getIdentityRegistry selector so the delegation test can call it successfully\n    const getIdentityRegistrySelector = (0,viem__WEBPACK_IMPORTED_MODULE_16__.encodeFunctionData)({\n        abi: _agentic_trust_8004_ext_sdk_abis_ValidationRegistry_json__WEBPACK_IMPORTED_MODULE_1__,\n        functionName: 'getIdentityRegistry',\n        args: [],\n    }).slice(0, 10);\n    // Include storeAssociation selector for ERC-8092 associations\n    // Function signature: storeAssociation((uint40,bytes2,bytes2,bytes,bytes,(bytes,bytes,uint40,uint40,bytes4,bytes)))\n    const storeAssociationSignature = 'storeAssociation((uint40,bytes2,bytes2,bytes,bytes,(bytes,bytes,uint40,uint40,bytes4,bytes)))';\n    const storeAssociationSelector = (0,viem__WEBPACK_IMPORTED_MODULE_4__.keccak256)((0,viem__WEBPACK_IMPORTED_MODULE_5__.stringToHex)(storeAssociationSignature)).slice(0, 10);\n    // Include isValidSignature selector for ERC-1271 validation\n    // This is crucial for ERC-8092 signature validation - when K1 keyType is used,\n    // the ERC-8092 contract calls agent.isValidSignature(hash, signature), which\n    // requires the delegation to allow this selector for the delegation-aware validator to work\n    const isValidSignatureSignature = 'isValidSignature(bytes32,bytes)';\n    const isValidSignatureSelector = (0,viem__WEBPACK_IMPORTED_MODULE_4__.keccak256)((0,viem__WEBPACK_IMPORTED_MODULE_5__.stringToHex)(isValidSignatureSignature)).slice(0, 10);\n    const selectors = Array.from(new Set([\n        selector,\n        getIdentityRegistrySelector,\n        storeAssociationSelector,\n        isValidSignatureSelector // Add this for ERC-1271 validation\n    ]));\n    const delegation = (0,_metamask_smart_accounts_kit__WEBPACK_IMPORTED_MODULE_17__.createDelegation)({\n        environment: deleGatorEnv,\n        scope: {\n            type: 'functionCall',\n            targets,\n            selectors,\n        },\n        from: agentAccount,\n        to: sessionAA, // Keep sessionAA as delegate\n        caveats: [],\n    });\n    let signature;\n    console.info('*********** sessionPackageBuilder yyyyy: signDelegation smartAccount');\n    signature = (await smartAccount.signDelegation({\n        delegation,\n    }));\n    const deligationWithSignature = {\n        ...delegation,\n        signature,\n    };\n    // Test the delegation by making a simple call to ValidationRegistry.getIdentityRegistry() from session account\n    // This demonstrates the full delegation redemption flow and should succeed because the selector is allowed\n    console.info('*********** sessionPackageBuilder: Testing delegation with ValidationRegistry.getIdentityRegistry() call (expected to succeed)...');\n    try {\n        // Create session account client with delegation\n        const sessionAccountClient = await (0,_metamask_smart_accounts_kit__WEBPACK_IMPORTED_MODULE_10__.toMetaMaskSmartAccount)({\n            address: sessionAA,\n            client: publicClient,\n            implementation: _metamask_smart_accounts_kit__WEBPACK_IMPORTED_MODULE_11__.Implementation.Hybrid,\n            signer: { account: sessionKeyAccount },\n            delegation: {\n                delegation: deligationWithSignature,\n                delegator: agentAccount,\n            },\n        });\n        // Prepare a simple call to ValidationRegistry.getIdentityRegistry()\n        const testCallData = (0,viem__WEBPACK_IMPORTED_MODULE_16__.encodeFunctionData)({\n            abi: _agentic_trust_8004_ext_sdk_abis_ValidationRegistry_json__WEBPACK_IMPORTED_MODULE_1__,\n            functionName: 'getIdentityRegistry',\n            args: [],\n        });\n        // Extract delegation message for redemption - use the signed delegation\n        const delegationMessage = {\n            delegate: deligationWithSignature.delegate,\n            delegator: deligationWithSignature.delegator,\n            authority: deligationWithSignature.authority,\n            caveats: deligationWithSignature.caveats,\n            salt: deligationWithSignature.salt,\n            signature: deligationWithSignature.signature, // Use the actual signature from signDelegation\n        };\n        // Encode delegation redemption\n        const SINGLE_DEFAULT_MODE = _metamask_smart_accounts_kit__WEBPACK_IMPORTED_MODULE_18__.ExecutionMode.SingleDefault;\n        if (!_metamask_smart_accounts_kit_contracts__WEBPACK_IMPORTED_MODULE_19__.DelegationManager_exports || !_metamask_smart_accounts_kit_contracts__WEBPACK_IMPORTED_MODULE_19__.DelegationManager_exports.encode || !_metamask_smart_accounts_kit_contracts__WEBPACK_IMPORTED_MODULE_19__.DelegationManager_exports.encode.redeemDelegations) {\n            throw new Error('DelegationManager.encode.redeemDelegations not found. Check @metamask/smart-accounts-kit version.');\n        }\n        const includedExecutions = [\n            {\n                target: validationRegistry,\n                value: BigInt(0),\n                callData: testCallData,\n            },\n        ];\n        const redemptionData = _metamask_smart_accounts_kit_contracts__WEBPACK_IMPORTED_MODULE_19__.DelegationManager_exports.encode.redeemDelegations({\n            delegations: [[delegationMessage]],\n            modes: [SINGLE_DEFAULT_MODE],\n            executions: [includedExecutions],\n        });\n        // Send the test call through delegation\n        const testCall = {\n            to: sessionAA,\n            data: redemptionData,\n            value: 0n,\n        };\n        console.info('*********** sessionPackageBuilder: Sending delegated call to ValidationRegistry.getIdentityRegistry()...');\n        console.info('*********** sessionPackageBuilder: This demonstrates delegation redemption flow end-to-end');\n        const testHash = await (0,_accountClient__WEBPACK_IMPORTED_MODULE_3__.sendSponsoredUserOperation)({\n            bundlerUrl,\n            chain,\n            accountClient: sessionAccountClient,\n            calls: [testCall],\n        });\n        const testReceipt = await (0,_accountClient__WEBPACK_IMPORTED_MODULE_3__.waitForUserOperationReceipt)({ bundlerUrl, chain, hash: testHash });\n        console.info('*********** sessionPackageBuilder:  Delegation test successful! Receipt:', testReceipt?.transactionHash || testHash);\n        // Verify the call returned an address (should match identityRegistry)\n        const identityRegistryFromCall = await publicClient.readContract({\n            address: validationRegistry,\n            abi: _agentic_trust_8004_ext_sdk_abis_ValidationRegistry_json__WEBPACK_IMPORTED_MODULE_1__,\n            functionName: 'getIdentityRegistry',\n            args: [],\n        });\n        console.info('*********** sessionPackageBuilder:  Delegation verified - IdentityRegistry address:', identityRegistryFromCall);\n    }\n    catch (error) {\n        const message = error instanceof Error ? error.message : String(error);\n        if (message.includes('Invalid Smart Account nonce') ||\n            message.includes('AA25 invalid account deployment')) {\n            console.warn('*********** sessionPackageBuilder: Delegation test skipped due to pending deployment/nonce conflict:', message);\n        }\n        else {\n            console.error('*********** sessionPackageBuilder: Delegation test call failed:', error);\n            throw new Error(`Delegation test failed: ${message}`);\n        }\n    }\n    // set the operator of nft to this newly created sessionAA\n    console.info(\"identityRegistry: \", identityRegistry);\n    console.info(\"zeroAddress: \", viem__WEBPACK_IMPORTED_MODULE_12__.zeroAddress);\n    if (identityRegistry && identityRegistry !== viem__WEBPACK_IMPORTED_MODULE_12__.zeroAddress) {\n        console.info('*********** sessionPackageBuilder: set the operator of nft to this newly created sessionAA');\n        const approveCalldata = (0,viem__WEBPACK_IMPORTED_MODULE_16__.encodeFunctionData)({\n            abi: _agentic_trust_8004_ext_sdk_abis_IdentityRegistry_json__WEBPACK_IMPORTED_MODULE_0__,\n            functionName: 'approve',\n            args: [sessionAA, BigInt(agentId)],\n        });\n        console.info('*********** sessionPackageBuilder: approveCalldata', approveCalldata);\n        const hash = await (0,_accountClient__WEBPACK_IMPORTED_MODULE_3__.sendSponsoredUserOperation)({\n            bundlerUrl,\n            chain,\n            accountClient: smartAccount,\n            calls: [{ to: identityRegistry, data: approveCalldata }],\n        });\n        await (0,_accountClient__WEBPACK_IMPORTED_MODULE_3__.waitForUserOperationReceipt)({ bundlerUrl, chain, hash });\n        const ownerOfAgent = await publicClient.readContract({\n            address: identityRegistry,\n            abi: _agentic_trust_8004_ext_sdk_abis_IdentityRegistry_json__WEBPACK_IMPORTED_MODULE_0__,\n            functionName: 'ownerOf',\n            args: [agentId],\n        });\n        console.info('*********** sessionPackageBuilder: ownerOfAgent', ownerOfAgent);\n    }\n    console.info('*********** sessionPackageBuilder: sessionPackage');\n    const sessionPackage = {\n        agentId,\n        chainId,\n        aa: agentAccount,\n        sessionAA,\n        selector,\n        sessionKey: {\n            privateKey: sessionPrivateKey,\n            address: sessionKeyAccount.address,\n            validAfter,\n            validUntil,\n        },\n        entryPoint,\n        bundlerUrl,\n        signedDelegation: deligationWithSignature,\n    };\n    return sessionPackage;\n}\n//# sourceMappingURL=sessionPackageBuilder.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BhZ2VudGljLXRydXN0L2NvcmUvZGlzdC9jbGllbnQvc2Vzc2lvblBhY2thZ2VCdWlsZGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFzSTtBQUM5RDtBQUMzQztBQUN3SDtBQUNySjtBQUMyRTtBQUNjO0FBQ0k7QUFDZ0M7QUFDbkM7QUFDMUY7QUFDQSx5QkFBeUIsK0NBQVMsQ0FBQyxpREFBVztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxRQUFRO0FBQzdEO0FBQ0E7QUFDQSxnQkFBZ0IsdUVBQWM7QUFDOUI7QUFDQTtBQUNBLCtEQUErRCxXQUFXO0FBQzFFO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix1RUFBYztBQUM5QjtBQUNBO0FBQ0EsaUVBQWlFLFdBQVc7QUFDNUU7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHVFQUFjO0FBQzlCO0FBQ0E7QUFDQSxpRUFBaUUsV0FBVztBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsdUVBQWM7QUFDOUI7QUFDQSxxREFBcUQsV0FBVztBQUNoRSxxSEFBcUgsV0FBVztBQUNoSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixzRUFBYTtBQUNwQztBQUNBO0FBQ0E7QUFDQSx1QkFBdUIscUJBQXFCO0FBQzVDLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsdUVBQWM7QUFDOUMsbUVBQW1FLFFBQVE7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLDRDQUE0QztBQUN0RjtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLFlBQVksMlJBQTJSO0FBQ3ZTO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyx1RUFBYztBQUNuRDtBQUNBLHFEQUFxRCxRQUFRO0FBQzdEO0FBQ0EsNkNBQTZDLDJFQUFrQjtBQUMvRDtBQUNBLHlEQUF5RCxRQUFRO0FBQ2pFO0FBQ0Esa0JBQWtCLHFFQUFZO0FBQzlCO0FBQ0E7QUFDQSxzRUFBc0UsUUFBUTtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFLFFBQVE7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSxRQUFRO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsd0RBQWtCO0FBQzNDO0FBQ0EsbUJBQW1CLDBDQUFJO0FBQ3ZCLEtBQUs7QUFDTCx5QkFBeUIsd0RBQWtCO0FBQzNDO0FBQ0EsbUJBQW1CLDRDQUFNO0FBQ3pCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSwrQkFBK0IscUZBQXNCO0FBQ3JEO0FBQ0E7QUFDQSx3QkFBd0IseUVBQWM7QUFDdEM7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQSxvREFBb0QsdUJBQXVCO0FBQzNFO0FBQ0E7QUFDQSwyQkFBMkIsMEVBQTBCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixJQUFJLDhDQUFXLEVBQUU7QUFDdkMsU0FBUztBQUNULGNBQWMsMkVBQTJCLEdBQUcseUJBQXlCO0FBQ3JFO0FBQ0EsOEJBQThCLGtFQUFrQjtBQUNoRCw4QkFBOEIsbUVBQW1CO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxxRkFBc0I7QUFDNUQ7QUFDQSx3QkFBd0IseUVBQWM7QUFDdEM7QUFDQSxrQkFBa0IsNEJBQTRCO0FBQzlDLG9CQUFvQiwyQ0FBSztBQUN6QixLQUFLO0FBQ0w7QUFDQSx5REFBeUQsb0JBQW9CO0FBQzdFO0FBQ0E7QUFDQSwyQkFBMkIsMEVBQTBCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixJQUFJLDhDQUFXLEVBQUU7QUFDdkMsU0FBUztBQUNULGNBQWMsMkVBQTJCLEdBQUcseUJBQXlCO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QiwwRkFBMkI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUlBQW1JLFlBQVk7QUFDL0k7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsUUFBUTtBQUNqRixxQ0FBcUM7QUFDckM7QUFDQTtBQUNBLGFBQWEsRUFBRTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3Qyx5REFBa0I7QUFDMUQsYUFBYSxxRkFBcUI7QUFDbEM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsK0NBQVMsQ0FBQyxpREFBVztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLCtDQUFTLENBQUMsaURBQVc7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLCtFQUFnQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMscUZBQXNCO0FBQ2pFO0FBQ0E7QUFDQSw0QkFBNEIseUVBQWM7QUFDMUMsc0JBQXNCLDRCQUE0QjtBQUNsRDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0EsNkJBQTZCLHlEQUFrQjtBQUMvQyxpQkFBaUIscUZBQXFCO0FBQ3RDO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0Msd0VBQWE7QUFDakQsYUFBYSw4RkFBaUIsS0FBSyw4RkFBaUIsWUFBWSw4RkFBaUI7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSwrQkFBK0IsOEZBQWlCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLDBFQUEwQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxrQ0FBa0MsMkVBQTJCLEdBQUcsbUNBQW1DO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHFGQUFxQjtBQUN0QztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELFFBQVE7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsOENBQVc7QUFDN0MsaURBQWlELDhDQUFXO0FBQzVEO0FBQ0EsZ0NBQWdDLHlEQUFrQjtBQUNsRCxpQkFBaUIsbUZBQW1CO0FBQ3BDO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSwyQkFBMkIsMEVBQTBCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiw2Q0FBNkM7QUFDbkUsU0FBUztBQUNULGNBQWMsMkVBQTJCLEdBQUcseUJBQXlCO0FBQ3JFO0FBQ0E7QUFDQSxpQkFBaUIsbUZBQW1CO0FBQ3BDO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvYmFyYi9hYS9Bc3NvY2lhdGVkQWNjb3VudHMvbm9kZV9tb2R1bGVzL0BhZ2VudGljLXRydXN0L2NvcmUvZGlzdC9jbGllbnQvc2Vzc2lvblBhY2thZ2VCdWlsZGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNyZWF0ZVB1YmxpY0NsaWVudCwgY3JlYXRlV2FsbGV0Q2xpZW50LCBodHRwLCBjdXN0b20sIHplcm9BZGRyZXNzLCBlbmNvZGVGdW5jdGlvbkRhdGEsIGtlY2NhazI1Niwgc3RyaW5nVG9IZXgsIH0gZnJvbSAndmllbSc7XG5pbXBvcnQgeyBnZW5lcmF0ZVByaXZhdGVLZXksIHByaXZhdGVLZXlUb0FjY291bnQgfSBmcm9tICd2aWVtL2FjY291bnRzJztcbmltcG9ydCB7IHRvSGV4IH0gZnJvbSAndmllbSc7XG5pbXBvcnQgeyB0b01ldGFNYXNrU21hcnRBY2NvdW50LCBJbXBsZW1lbnRhdGlvbiwgY3JlYXRlRGVsZWdhdGlvbiwgZ2V0U21hcnRBY2NvdW50c0Vudmlyb25tZW50LCBFeGVjdXRpb25Nb2RlLCB9IGZyb20gJ0BtZXRhbWFzay9zbWFydC1hY2NvdW50cy1raXQnO1xuLy8gQHRzLWlnbm9yZSAtIGNvbnRyYWN0cyBzdWJwYXRoIG1heSBub3QgYmUgaW4gbWFpbiB0eXBlIGRlZmluaXRpb25zXG5pbXBvcnQgeyBEZWxlZ2F0aW9uTWFuYWdlciB9IGZyb20gJ0BtZXRhbWFzay9zbWFydC1hY2NvdW50cy1raXQvY29udHJhY3RzJztcbmltcG9ydCBJZGVudGl0eVJlZ2lzdHJ5QWJpIGZyb20gJ0BhZ2VudGljLXRydXN0LzgwMDQtZXh0LXNkay9hYmlzL0lkZW50aXR5UmVnaXN0cnkuanNvbic7XG5pbXBvcnQgVmFsaWRhdGlvblJlZ2lzdHJ5QWJpIGZyb20gJ0BhZ2VudGljLXRydXN0LzgwMDQtZXh0LXNkay9hYmlzL1ZhbGlkYXRpb25SZWdpc3RyeS5qc29uJztcbmltcG9ydCB7IGdldENoYWluUnBjVXJsLCBnZXRDaGFpbkJ1bmRsZXJVcmwsIGdldENoYWluSWRIZXgsIGdldENoYWluQ29uZmlnLCBnZXRDaGFpbkJ5SWQsIH0gZnJvbSAnLi4vc2VydmVyL2xpYi9jaGFpbkNvbmZpZyc7XG5pbXBvcnQgeyBzZW5kU3BvbnNvcmVkVXNlck9wZXJhdGlvbiwgd2FpdEZvclVzZXJPcGVyYXRpb25SZWNlaXB0IH0gZnJvbSAnLi9hY2NvdW50Q2xpZW50JztcbmNvbnN0IFZBTElEQVRJT05fUkVTUE9OU0VfU0lHTkFUVVJFID0gJ3ZhbGlkYXRpb25SZXNwb25zZShieXRlczMyLHVpbnQ4LHN0cmluZyxieXRlczMyLGJ5dGVzMzIpJztcbmNvbnN0IERFRkFVTFRfU0VMRUNUT1IgPSBrZWNjYWsyNTYoc3RyaW5nVG9IZXgoVkFMSURBVElPTl9SRVNQT05TRV9TSUdOQVRVUkUpKS5zbGljZSgwLCAxMCk7XG5jb25zdCBERUZBVUxUX0VOVFJZX1BPSU5UID0gJzB4MDAwMDAwMDA3MTcyN0RlMjJFNUU5ZDhCQWYwZWRBYzZmMzdkYTAzMic7XG5mdW5jdGlvbiBub3JtYWxpemVIZXgodmFsdWUpIHtcbiAgICBpZiAoIXZhbHVlKVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIGNvbnN0IHRyaW1tZWQgPSB2YWx1ZS50cmltKCk7XG4gICAgaWYgKCF0cmltbWVkKVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIHJldHVybiB0cmltbWVkLnN0YXJ0c1dpdGgoJzB4JykgPyB0cmltbWVkIDogYDB4JHt0cmltbWVkfWA7XG59XG5mdW5jdGlvbiBnZXRJZGVudGl0eVJlZ2lzdHJ5QWRkcmVzcyhjaGFpbklkKSB7XG4gICAgY29uc3QgY2ZnID0gZ2V0Q2hhaW5Db25maWcoY2hhaW5JZCk7XG4gICAgaWYgKCFjZmcpXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgY29uc3Qga2V5ID0gYE5FWFRfUFVCTElDX0FHRU5USUNfVFJVU1RfSURFTlRJVFlfUkVHSVNUUllfJHtjZmcuc3VmZml4fWA7XG4gICAgcmV0dXJuIG5vcm1hbGl6ZUhleChwcm9jZXNzLmVudltrZXldID8/IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0FHRU5USUNfVFJVU1RfSURFTlRJVFlfUkVHSVNUUlkgPz8gdW5kZWZpbmVkKTtcbn1cbmZ1bmN0aW9uIGdldFJlcHV0YXRpb25SZWdpc3RyeUFkZHJlc3MoY2hhaW5JZCkge1xuICAgIGNvbnN0IGNmZyA9IGdldENoYWluQ29uZmlnKGNoYWluSWQpO1xuICAgIGlmICghY2ZnKVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIGNvbnN0IGtleSA9IGBORVhUX1BVQkxJQ19BR0VOVElDX1RSVVNUX1JFUFVUQVRJT05fUkVHSVNUUllfJHtjZmcuc3VmZml4fWA7XG4gICAgcmV0dXJuIG5vcm1hbGl6ZUhleChwcm9jZXNzLmVudltrZXldID8/IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0FHRU5USUNfVFJVU1RfUkVQVVRBVElPTl9SRUdJU1RSWSA/PyB1bmRlZmluZWQpO1xufVxuZnVuY3Rpb24gZ2V0VmFsaWRhdGlvblJlZ2lzdHJ5QWRkcmVzcyhjaGFpbklkKSB7XG4gICAgY29uc3QgY2ZnID0gZ2V0Q2hhaW5Db25maWcoY2hhaW5JZCk7XG4gICAgaWYgKCFjZmcpXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgY29uc3Qga2V5ID0gYE5FWFRfUFVCTElDX0FHRU5USUNfVFJVU1RfVkFMSURBVElPTl9SRUdJU1RSWV8ke2NmZy5zdWZmaXh9YDtcbiAgICBjb25zb2xlLmluZm8oJyoqKioqKioqKioqIHNlc3Npb25QYWNrYWdlQnVpbGRlcjogdmFsaWRhdGlvblJlZ2lzdHJ5Jywga2V5KTtcbiAgICBjb25zb2xlLmluZm8oJyoqKioqKioqKioqIHNlc3Npb25QYWNrYWdlQnVpbGRlcjogdmFsaWRhdGlvblJlZ2lzdHJ5JywgcHJvY2Vzcy5lbnZba2V5XSk7XG4gICAgcmV0dXJuIG5vcm1hbGl6ZUhleChwcm9jZXNzLmVudltrZXldID8/IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0FHRU5USUNfVFJVU1RfVkFMSURBVElPTl9SRUdJU1RSWSA/PyB1bmRlZmluZWQpO1xufVxuZnVuY3Rpb24gZ2V0QXNzb2NpYXRpb25zUHJveHlBZGRyZXNzKGNoYWluSWQpIHtcbiAgICAvLyBUcnkgY2hhaW4tc3BlY2lmaWMgZW52IHZhciBmaXJzdCwgdGhlbiBmYWxsYmFjayB0byBnZW5lcmljIGVudiB2YXIsIHRoZW4gZGVmYXVsdFxuICAgIGNvbnN0IGNmZyA9IGdldENoYWluQ29uZmlnKGNoYWluSWQpO1xuICAgIGlmIChjZmcpIHtcbiAgICAgICAgY29uc3QgY2hhaW5LZXkgPSBgQVNTT0NJQVRJT05TX1NUT1JFX1BST1hZXyR7Y2ZnLnN1ZmZpeH1gO1xuICAgICAgICBjb25zdCBjaGFpblZhbHVlID0gbm9ybWFsaXplSGV4KHByb2Nlc3MuZW52W2NoYWluS2V5XSA/PyBwcm9jZXNzLmVudltgTkVYVF9QVUJMSUNfQVNTT0NJQVRJT05TX1NUT1JFX1BST1hZXyR7Y2ZnLnN1ZmZpeH1gXSk7XG4gICAgICAgIGlmIChjaGFpblZhbHVlKVxuICAgICAgICAgICAgcmV0dXJuIGNoYWluVmFsdWU7XG4gICAgfVxuICAgIGNvbnN0IGdlbmVyaWNWYWx1ZSA9IG5vcm1hbGl6ZUhleChwcm9jZXNzLmVudi5BU1NPQ0lBVElPTlNfU1RPUkVfUFJPWFkgPz8gcHJvY2Vzcy5lbnYuQVNTT0NJQVRJT05TX1BST1hZX0FERFJFU1MgPz8gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfQVNTT0NJQVRJT05TX1NUT1JFX1BST1hZKTtcbiAgICBpZiAoZ2VuZXJpY1ZhbHVlKVxuICAgICAgICByZXR1cm4gZ2VuZXJpY1ZhbHVlO1xuICAgIC8vIERlZmF1bHQgU2Vwb2xpYSBhZGRyZXNzXG4gICAgcmV0dXJuICcweGFGNzQyODkwNkQzMTkxOGREQTI5ODZEMTQwNUUyRGVkMDY1NjFFNTknO1xufVxuYXN5bmMgZnVuY3Rpb24gc3dpdGNoQ2hhaW4ocHJvdmlkZXIsIGNoYWluSWQsIHJwY1VybCkge1xuICAgIGNvbnN0IGNoYWluSWRIZXggPSBnZXRDaGFpbklkSGV4KGNoYWluSWQpO1xuICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IHByb3ZpZGVyLnJlcXVlc3Qoe1xuICAgICAgICAgICAgbWV0aG9kOiAnd2FsbGV0X3N3aXRjaEV0aGVyZXVtQ2hhaW4nLFxuICAgICAgICAgICAgcGFyYW1zOiBbeyBjaGFpbklkOiBjaGFpbklkSGV4IH1dLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGlmIChlcnJvcj8uY29kZSA9PT0gNDkwMikge1xuICAgICAgICAgICAgY29uc3QgY2hhaW5Db25maWcgPSBnZXRDaGFpbkNvbmZpZyhjaGFpbklkKTtcbiAgICAgICAgICAgIGNvbnN0IGNoYWluTmFtZSA9IGNoYWluQ29uZmlnPy5kaXNwbGF5TmFtZSA/PyBgQ2hhaW4gJHtjaGFpbklkfWA7XG4gICAgICAgICAgICBhd2FpdCBwcm92aWRlci5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICd3YWxsZXRfYWRkRXRoZXJldW1DaGFpbicsXG4gICAgICAgICAgICAgICAgcGFyYW1zOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYWluSWQ6IGNoYWluSWRIZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFpbk5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYXRpdmVDdXJyZW5jeTogeyBuYW1lOiAnRXRoZXInLCBzeW1ib2w6ICdFVEgnLCBkZWNpbWFsczogMTggfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJwY1VybHM6IFtycGNVcmxdLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdlbmVyYXRlU2Vzc2lvblBhY2thZ2UocGFyYW1zKSB7XG4gICAgY29uc3QgeyBhZ2VudElkLCBjaGFpbklkLCBhZ2VudEFjY291bnQsIHByb3ZpZGVyLCBvd25lckFkZHJlc3MsIHJwY1VybDogcnBjVXJsT3ZlcnJpZGUsIGJ1bmRsZXJVcmw6IGJ1bmRsZXJVcmxPdmVycmlkZSwgaWRlbnRpdHlSZWdpc3RyeTogaWRlbnRpdHlSZWdpc3RyeU92ZXJyaWRlLCByZXB1dGF0aW9uUmVnaXN0cnk6IHJlcHV0YXRpb25SZWdpc3RyeU92ZXJyaWRlLCB2YWxpZGF0aW9uUmVnaXN0cnk6IHZhbGlkYXRpb25SZWdpc3RyeU92ZXJyaWRlLCBzZWxlY3RvciA9IERFRkFVTFRfU0VMRUNUT1IsIH0gPSBwYXJhbXM7XG4gICAgaWYgKCFwcm92aWRlcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FuIEVJUC0xMTkzIHByb3ZpZGVyIGlzIHJlcXVpcmVkIHRvIGdlbmVyYXRlIGEgc2Vzc2lvbiBwYWNrYWdlLicpO1xuICAgIH1cbiAgICBpZiAoIW93bmVyQWRkcmVzcykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dhbGxldCBhZGRyZXNzIGlzIHJlcXVpcmVkIHRvIGdlbmVyYXRlIGEgc2Vzc2lvbiBwYWNrYWdlLicpO1xuICAgIH1cbiAgICBpZiAoIWFnZW50QWNjb3VudCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FnZW50IGFjY291bnQgaXMgcmVxdWlyZWQgdG8gZ2VuZXJhdGUgYSBzZXNzaW9uIHBhY2thZ2UuJyk7XG4gICAgfVxuICAgIGNvbnN0IHJwY1VybCA9IHJwY1VybE92ZXJyaWRlID8/IGdldENoYWluUnBjVXJsKGNoYWluSWQpO1xuICAgIGlmICghcnBjVXJsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgTWlzc2luZyBSUEMgVVJMIGZvciBjaGFpbiAke2NoYWluSWR9YCk7XG4gICAgfVxuICAgIGNvbnN0IGJ1bmRsZXJVcmwgPSBidW5kbGVyVXJsT3ZlcnJpZGUgPz8gZ2V0Q2hhaW5CdW5kbGVyVXJsKGNoYWluSWQpO1xuICAgIGlmICghYnVuZGxlclVybCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE1pc3NpbmcgYnVuZGxlciBVUkwgZm9yIGNoYWluICR7Y2hhaW5JZH1gKTtcbiAgICB9XG4gICAgY29uc3QgY2hhaW4gPSBnZXRDaGFpbkJ5SWQoY2hhaW5JZCk7XG4gICAgY29uc3QgaWRlbnRpdHlSZWdpc3RyeSA9IGlkZW50aXR5UmVnaXN0cnlPdmVycmlkZSA/PyBnZXRJZGVudGl0eVJlZ2lzdHJ5QWRkcmVzcyhjaGFpbklkKTtcbiAgICBpZiAoIWlkZW50aXR5UmVnaXN0cnkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBNaXNzaW5nIElkZW50aXR5UmVnaXN0cnkgYWRkcmVzcyBmb3IgY2hhaW4gJHtjaGFpbklkfS4gYCArXG4gICAgICAgICAgICBgU2V0IE5FWFRfUFVCTElDX0FHRU5USUNfVFJVU1RfSURFTlRJVFlfUkVHSVNUUlkgb3IgYCArXG4gICAgICAgICAgICBgTkVYVF9QVUJMSUNfQUdFTlRJQ19UUlVTVF9JREVOVElUWV9SRUdJU1RSWV88Q0hBSU5fU1VGRklYPiBpbiB5b3VyIGVudi5gKTtcbiAgICB9XG4gICAgY29uc3QgcmVwdXRhdGlvblJlZ2lzdHJ5ID0gcmVwdXRhdGlvblJlZ2lzdHJ5T3ZlcnJpZGUgPz8gZ2V0UmVwdXRhdGlvblJlZ2lzdHJ5QWRkcmVzcyhjaGFpbklkKTtcbiAgICBpZiAoIXJlcHV0YXRpb25SZWdpc3RyeSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE1pc3NpbmcgUmVwdXRhdGlvblJlZ2lzdHJ5IGFkZHJlc3MgZm9yIGNoYWluICR7Y2hhaW5JZH0uIGAgK1xuICAgICAgICAgICAgYFNldCBORVhUX1BVQkxJQ19BR0VOVElDX1RSVVNUX1JFUFVUQVRJT05fUkVHSVNUUlkgb3IgYCArXG4gICAgICAgICAgICBgTkVYVF9QVUJMSUNfQUdFTlRJQ19UUlVTVF9SRVBVVEFUSU9OX1JFR0lTVFJZXzxDSEFJTl9TVUZGSVg+IGluIHlvdXIgZW52LmApO1xuICAgIH1cbiAgICBjb25zdCB2YWxpZGF0aW9uUmVnaXN0cnkgPSB2YWxpZGF0aW9uUmVnaXN0cnlPdmVycmlkZSA/PyBnZXRWYWxpZGF0aW9uUmVnaXN0cnlBZGRyZXNzKGNoYWluSWQpO1xuICAgIGlmICghdmFsaWRhdGlvblJlZ2lzdHJ5KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgTWlzc2luZyBWYWxpZGF0aW9uUmVnaXN0cnkgYWRkcmVzcyBmb3IgY2hhaW4gJHtjaGFpbklkfS4gYCArXG4gICAgICAgICAgICBgU2V0IE5FWFRfUFVCTElDX0FHRU5USUNfVFJVU1RfVkFMSURBVElPTl9SRUdJU1RSWSBvciBgICtcbiAgICAgICAgICAgIGBORVhUX1BVQkxJQ19BR0VOVElDX1RSVVNUX1ZBTElEQVRJT05fUkVHSVNUUllfPENIQUlOX1NVRkZJWD4gaW4geW91ciBlbnYuYCk7XG4gICAgfVxuICAgIGF3YWl0IHN3aXRjaENoYWluKHByb3ZpZGVyLCBjaGFpbklkLCBycGNVcmwpO1xuICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAxMDAwKSk7XG4gICAgY29uc3QgcHVibGljQ2xpZW50ID0gY3JlYXRlUHVibGljQ2xpZW50KHtcbiAgICAgICAgY2hhaW4sXG4gICAgICAgIHRyYW5zcG9ydDogaHR0cChycGNVcmwpLFxuICAgIH0pO1xuICAgIGNvbnN0IHdhbGxldENsaWVudCA9IGNyZWF0ZVdhbGxldENsaWVudCh7XG4gICAgICAgIGNoYWluLFxuICAgICAgICB0cmFuc3BvcnQ6IGN1c3RvbShwcm92aWRlciksXG4gICAgICAgIGFjY291bnQ6IG93bmVyQWRkcmVzcyxcbiAgICB9KTtcbiAgICBjb25zb2xlLmluZm8oJyoqKioqKioqKioqIHNlc3Npb25QYWNrYWdlQnVpbGRlcjogd2FsbGV0Q2xpZW50Jywgd2FsbGV0Q2xpZW50Py5hY2NvdW50Py5hZGRyZXNzKTtcbiAgICBjb25zb2xlLmluZm8oJyoqKioqKioqKioqIHNlc3Npb25QYWNrYWdlQnVpbGRlcjogYWdlbnRBY2NvdW50JywgYWdlbnRBY2NvdW50KTtcbiAgICBjb25zdCBzbWFydEFjY291bnQgPSBhd2FpdCB0b01ldGFNYXNrU21hcnRBY2NvdW50KHtcbiAgICAgICAgYWRkcmVzczogYWdlbnRBY2NvdW50LFxuICAgICAgICBjbGllbnQ6IHB1YmxpY0NsaWVudCxcbiAgICAgICAgaW1wbGVtZW50YXRpb246IEltcGxlbWVudGF0aW9uLkh5YnJpZCxcbiAgICAgICAgc2lnbmVyOiB7XG4gICAgICAgICAgICB3YWxsZXRDbGllbnQ6IHdhbGxldENsaWVudCxcbiAgICAgICAgfSxcbiAgICB9KTtcbiAgICBjb25zdCBlbnRyeVBvaW50ID0gREVGQVVMVF9FTlRSWV9QT0lOVDtcbiAgICBjb25zdCBhYUNvZGUgPSBhd2FpdCBwdWJsaWNDbGllbnQuZ2V0Qnl0ZWNvZGUoeyBhZGRyZXNzOiBhZ2VudEFjY291bnQgfSk7XG4gICAgY29uc3QgYWFEZXBsb3llZCA9ICEhYWFDb2RlICYmIGFhQ29kZSAhPT0gJzB4JztcbiAgICBpZiAoIWFhRGVwbG95ZWQpIHtcbiAgICAgICAgY29uc3QgaGFzaCA9IGF3YWl0IHNlbmRTcG9uc29yZWRVc2VyT3BlcmF0aW9uKHtcbiAgICAgICAgICAgIGJ1bmRsZXJVcmwsXG4gICAgICAgICAgICBjaGFpbixcbiAgICAgICAgICAgIGFjY291bnRDbGllbnQ6IHNtYXJ0QWNjb3VudCxcbiAgICAgICAgICAgIGNhbGxzOiBbeyB0bzogemVyb0FkZHJlc3MgfV0sXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCB3YWl0Rm9yVXNlck9wZXJhdGlvblJlY2VpcHQoeyBidW5kbGVyVXJsLCBjaGFpbiwgaGFzaCB9KTtcbiAgICB9XG4gICAgY29uc3Qgc2Vzc2lvblByaXZhdGVLZXkgPSBnZW5lcmF0ZVByaXZhdGVLZXkoKTtcbiAgICBjb25zdCBzZXNzaW9uS2V5QWNjb3VudCA9IHByaXZhdGVLZXlUb0FjY291bnQoc2Vzc2lvblByaXZhdGVLZXkpO1xuICAgIGNvbnN0IHZhbGlkVW50aWwgPSBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxMDAwKSArIDYwICogMzA7XG4gICAgY29uc3QgdmFsaWRBZnRlciA9IHZhbGlkVW50aWwgLSA2MCAqIDMwIC0gNjA7XG4gICAgY29uc29sZS5pbmZvKCcqKioqKioqKioqKiBzZXNzaW9uUGFja2FnZUJ1aWxkZXIgc2lnbmVyOiBzZXNzaW9uS2V5QWNjb3VudCBhYWE6ICAnLCBzZXNzaW9uS2V5QWNjb3VudC5hZGRyZXNzKTtcbiAgICBjb25zdCBidXJuZXJBY2NvdW50Q2xpZW50ID0gYXdhaXQgdG9NZXRhTWFza1NtYXJ0QWNjb3VudCh7XG4gICAgICAgIGNsaWVudDogcHVibGljQ2xpZW50LFxuICAgICAgICBpbXBsZW1lbnRhdGlvbjogSW1wbGVtZW50YXRpb24uSHlicmlkLFxuICAgICAgICBkZXBsb3lQYXJhbXM6IFtzZXNzaW9uS2V5QWNjb3VudC5hZGRyZXNzLCBbXSwgW10sIFtdXSxcbiAgICAgICAgc2lnbmVyOiB7IGFjY291bnQ6IHNlc3Npb25LZXlBY2NvdW50IH0sXG4gICAgICAgIGRlcGxveVNhbHQ6IHRvSGV4KDEwKSxcbiAgICB9KTtcbiAgICBjb25zdCBzZXNzaW9uQUEgPSAoYXdhaXQgYnVybmVyQWNjb3VudENsaWVudC5nZXRBZGRyZXNzKCkpO1xuICAgIGNvbnN0IHNlc3Npb25Db2RlID0gYXdhaXQgcHVibGljQ2xpZW50LmdldEJ5dGVjb2RlKHsgYWRkcmVzczogc2Vzc2lvbkFBIH0pO1xuICAgIGNvbnN0IHNlc3Npb25EZXBsb3llZCA9ICEhc2Vzc2lvbkNvZGUgJiYgc2Vzc2lvbkNvZGUgIT09ICcweCc7XG4gICAgaWYgKCFzZXNzaW9uRGVwbG95ZWQpIHtcbiAgICAgICAgY29uc3QgaGFzaCA9IGF3YWl0IHNlbmRTcG9uc29yZWRVc2VyT3BlcmF0aW9uKHtcbiAgICAgICAgICAgIGJ1bmRsZXJVcmwsXG4gICAgICAgICAgICBjaGFpbixcbiAgICAgICAgICAgIGFjY291bnRDbGllbnQ6IGJ1cm5lckFjY291bnRDbGllbnQsXG4gICAgICAgICAgICBjYWxsczogW3sgdG86IHplcm9BZGRyZXNzIH1dLFxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgd2FpdEZvclVzZXJPcGVyYXRpb25SZWNlaXB0KHsgYnVuZGxlclVybCwgY2hhaW4sIGhhc2ggfSk7XG4gICAgfVxuICAgIC8vIEdldCB0aGUgY29ycmVjdCBIeWJyaWREZWxlR2F0b3IgYWRkcmVzcyBmcm9tIHRoZSBzbWFydCBhY2NvdW50cyBraXRcbiAgICAvLyBUaGlzIE1VU1QgbWF0Y2ggdGhlIEVJUC03MTIgZG9tYWluIHVzZWQgYnkgdGhlIGNvbnRyYWN0IHRoYXQgdmVyaWZpZXMgdGhlIGRlbGVnYXRpb25cbiAgICBjb25zdCBkZWxlR2F0b3JFbnYgPSBnZXRTbWFydEFjY291bnRzRW52aXJvbm1lbnQoY2hhaW5JZCk7XG4gICAgY29uc3QgZW50cnlQb2ludEFkZHJlc3MgPSBkZWxlR2F0b3JFbnYuRW50cnlQb2ludCB8fCBlbnRyeVBvaW50O1xuICAgIC8vIFRoZSBIeWJyaWREZWxlR2F0b3IgYWRkcmVzcyBpcyBpbiB0aGUgaW1wbGVtZW50YXRpb25zIG9iamVjdFxuICAgIC8vIFRoZSBwcm9wZXJ0eSBuYW1lIGlzIEh5YnJpZERlbGVHYXRvckltcGwgKGFzIGNvbmZpcm1lZCBieSB0aGUgZW52aXJvbm1lbnQgc3RydWN0dXJlKVxuICAgIGxldCBoeWJyaWREZWxlZ2F0b3JBZGRyZXNzID0gZGVsZUdhdG9yRW52LmltcGxlbWVudGF0aW9ucz8uSHlicmlkRGVsZUdhdG9ySW1wbDtcbiAgICBjb25zb2xlLmluZm8oJyoqKioqKioqKioqIHNlc3Npb25QYWNrYWdlQnVpbGRlcjogaHlicmlkRGVsZWdhdG9yQWRkcmVzcycsIGh5YnJpZERlbGVnYXRvckFkZHJlc3MpO1xuICAgIC8vIElmIG5vdCBmb3VuZCBpbiBpbXBsZW1lbnRhdGlvbnMsIHRyeSB0byBnZXQgZnJvbSBzbWFydCBhY2NvdW50XG4gICAgLy8gRm9yIEh5YnJpZCBpbXBsZW1lbnRhdGlvbiwgdGhlIGltcGxlbWVudGF0aW9uIGFkZHJlc3MgbWlnaHQgYmUgdGhlIEh5YnJpZERlbGVHYXRvclxuICAgIGlmICghaHlicmlkRGVsZWdhdG9yQWRkcmVzcykge1xuICAgICAgICBjb25zdCBhY2NvdW50SW1wbCA9IHNtYXJ0QWNjb3VudC5pbXBsZW1lbnRhdGlvbkFkZHJlc3MgfHxcbiAgICAgICAgICAgIHNtYXJ0QWNjb3VudC5pbXBsZW1lbnRhdGlvbj8uYWRkcmVzcyB8fFxuICAgICAgICAgICAgc21hcnRBY2NvdW50LmdldEltcGxlbWVudGF0aW9uQWRkcmVzcz8uKCk7XG4gICAgICAgIGlmIChhY2NvdW50SW1wbCkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGBbc2Vzc2lvblBhY2thZ2VCdWlsZGVyXSBIeWJyaWREZWxlR2F0b3Igbm90IGZvdW5kIGluIGRlbGVHYXRvckVudiwgdXNpbmcgc21hcnQgYWNjb3VudCBpbXBsZW1lbnRhdGlvbjogJHthY2NvdW50SW1wbH1gKTtcbiAgICAgICAgICAgIGh5YnJpZERlbGVnYXRvckFkZHJlc3MgPSBhY2NvdW50SW1wbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWh5YnJpZERlbGVnYXRvckFkZHJlc3MpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBIeWJyaWREZWxlR2F0b3IgYWRkcmVzcyBub3QgZm91bmQgZm9yIGNoYWluSWQgJHtjaGFpbklkfS4gYCArXG4gICAgICAgICAgICBgRGVsZUdhdG9yRW52aXJvbm1lbnQ6ICR7SlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgIEVudHJ5UG9pbnQ6IGRlbGVHYXRvckVudi5FbnRyeVBvaW50LFxuICAgICAgICAgICAgICAgIGltcGxlbWVudGF0aW9uczogZGVsZUdhdG9yRW52LmltcGxlbWVudGF0aW9uc1xuICAgICAgICAgICAgfSl9LiBgICtcbiAgICAgICAgICAgIGBDaGVjayBAbWV0YW1hc2svc21hcnQtYWNjb3VudHMta2l0IGNvbmZpZ3VyYXRpb24uYCk7XG4gICAgfVxuICAgIC8qXG4gICAgICBjb25zdCBlbnZpcm9ubWVudCA9IChzbWFydEFjY291bnQgYXMgYW55KS5lbnZpcm9ubWVudDtcbiAgICAgIGlmICghZW52aXJvbm1lbnQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEZWxlZ2F0aW9uIGVudmlyb25tZW50IGlzIHVuYXZhaWxhYmxlIG9uIHRoZSBzbWFydCBhY2NvdW50LicpO1xuICAgICAgfVxuICAgICAgY29uc29sZS5pbmZvKCcqKioqKioqKioqKiBzZXNzaW9uUGFja2FnZUJ1aWxkZXI6IGVudmlyb25tZW50JywgZW52aXJvbm1lbnQpO1xuICAgICovXG4gICAgY29uc29sZS5pbmZvKCcqKioqKioqKioqKiBzZXNzaW9uUGFja2FnZUJ1aWxkZXI6IGNyZWF0ZURlbGVnYXRpb24nKTtcbiAgICAvLyBDcmVhdGUgZGVsZWdhdGlvbiBzY29wZSB0aGF0IGFsbG93cyB2YWxpZGF0aW9uUmVzcG9uc2UgKGFuZCBhIHJlYWQtb25seSB0ZXN0IG1ldGhvZCkgb24gVmFsaWRhdGlvblJlZ2lzdHJ5XG4gICAgLy8gQWxzbyBpbmNsdWRlIEVSQy04MDkyIGFzc29jaWF0aW9ucyBwcm94eSB0byBhbGxvdyBzdG9yZUFzc29jaWF0aW9uIGNhbGxzXG4gICAgLy8gQW5kIGluY2x1ZGUgdGhlIGFnZW50QWNjb3VudCBpdHNlbGYgZm9yIEVSQy0xMjcxIHZhbGlkYXRpb25cbiAgICBjb25zdCB0YXJnZXRzID0gW107XG4gICAgaWYgKHZhbGlkYXRpb25SZWdpc3RyeSkge1xuICAgICAgICB0YXJnZXRzLnB1c2godmFsaWRhdGlvblJlZ2lzdHJ5KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndmFsaWRhdGlvblJlZ2lzdHJ5IGFkZHJlc3MgaXMgcmVxdWlyZWQgdG8gYnVpbGQgZGVsZWdhdGlvbiBzY29wZScpO1xuICAgIH1cbiAgICAvLyBJbmNsdWRlIGFnZW50QWNjb3VudCBpbiB0YXJnZXRzIGZvciBkZWxlZ2F0aW9uLWF3YXJlIEVSQy0xMjcxIHZhbGlkYXRpb25cbiAgICAvLyBUaGlzIGFsbG93cyBzZXNzaW9uQUEgdG8gY2FsbCBpc1ZhbGlkU2lnbmF0dXJlIG9uIGFnZW50QWNjb3VudFxuICAgIHRhcmdldHMucHVzaChhZ2VudEFjY291bnQpO1xuICAgIC8vIEFkZCBFUkMtODA5MiBhc3NvY2lhdGlvbnMgcHJveHkgdG8gYWxsb3dlZCB0YXJnZXRzXG4gICAgY29uc3QgYXNzb2NpYXRpb25zUHJveHkgPSBnZXRBc3NvY2lhdGlvbnNQcm94eUFkZHJlc3MoY2hhaW5JZCk7XG4gICAgaWYgKGFzc29jaWF0aW9uc1Byb3h5KSB7XG4gICAgICAgIHRhcmdldHMucHVzaChhc3NvY2lhdGlvbnNQcm94eSk7XG4gICAgICAgIGNvbnNvbGUuaW5mbygnKioqKioqKioqKiogc2Vzc2lvblBhY2thZ2VCdWlsZGVyOiBBZGRlZCBhc3NvY2lhdGlvbnMgcHJveHkgdG8gZGVsZWdhdGlvbiB0YXJnZXRzOicsIGFzc29jaWF0aW9uc1Byb3h5KTtcbiAgICB9XG4gICAgLy8gSW5jbHVkZSBnZXRJZGVudGl0eVJlZ2lzdHJ5IHNlbGVjdG9yIHNvIHRoZSBkZWxlZ2F0aW9uIHRlc3QgY2FuIGNhbGwgaXQgc3VjY2Vzc2Z1bGx5XG4gICAgY29uc3QgZ2V0SWRlbnRpdHlSZWdpc3RyeVNlbGVjdG9yID0gZW5jb2RlRnVuY3Rpb25EYXRhKHtcbiAgICAgICAgYWJpOiBWYWxpZGF0aW9uUmVnaXN0cnlBYmksXG4gICAgICAgIGZ1bmN0aW9uTmFtZTogJ2dldElkZW50aXR5UmVnaXN0cnknLFxuICAgICAgICBhcmdzOiBbXSxcbiAgICB9KS5zbGljZSgwLCAxMCk7XG4gICAgLy8gSW5jbHVkZSBzdG9yZUFzc29jaWF0aW9uIHNlbGVjdG9yIGZvciBFUkMtODA5MiBhc3NvY2lhdGlvbnNcbiAgICAvLyBGdW5jdGlvbiBzaWduYXR1cmU6IHN0b3JlQXNzb2NpYXRpb24oKHVpbnQ0MCxieXRlczIsYnl0ZXMyLGJ5dGVzLGJ5dGVzLChieXRlcyxieXRlcyx1aW50NDAsdWludDQwLGJ5dGVzNCxieXRlcykpKVxuICAgIGNvbnN0IHN0b3JlQXNzb2NpYXRpb25TaWduYXR1cmUgPSAnc3RvcmVBc3NvY2lhdGlvbigodWludDQwLGJ5dGVzMixieXRlczIsYnl0ZXMsYnl0ZXMsKGJ5dGVzLGJ5dGVzLHVpbnQ0MCx1aW50NDAsYnl0ZXM0LGJ5dGVzKSkpJztcbiAgICBjb25zdCBzdG9yZUFzc29jaWF0aW9uU2VsZWN0b3IgPSBrZWNjYWsyNTYoc3RyaW5nVG9IZXgoc3RvcmVBc3NvY2lhdGlvblNpZ25hdHVyZSkpLnNsaWNlKDAsIDEwKTtcbiAgICAvLyBJbmNsdWRlIGlzVmFsaWRTaWduYXR1cmUgc2VsZWN0b3IgZm9yIEVSQy0xMjcxIHZhbGlkYXRpb25cbiAgICAvLyBUaGlzIGlzIGNydWNpYWwgZm9yIEVSQy04MDkyIHNpZ25hdHVyZSB2YWxpZGF0aW9uIC0gd2hlbiBLMSBrZXlUeXBlIGlzIHVzZWQsXG4gICAgLy8gdGhlIEVSQy04MDkyIGNvbnRyYWN0IGNhbGxzIGFnZW50LmlzVmFsaWRTaWduYXR1cmUoaGFzaCwgc2lnbmF0dXJlKSwgd2hpY2hcbiAgICAvLyByZXF1aXJlcyB0aGUgZGVsZWdhdGlvbiB0byBhbGxvdyB0aGlzIHNlbGVjdG9yIGZvciB0aGUgZGVsZWdhdGlvbi1hd2FyZSB2YWxpZGF0b3IgdG8gd29ya1xuICAgIGNvbnN0IGlzVmFsaWRTaWduYXR1cmVTaWduYXR1cmUgPSAnaXNWYWxpZFNpZ25hdHVyZShieXRlczMyLGJ5dGVzKSc7XG4gICAgY29uc3QgaXNWYWxpZFNpZ25hdHVyZVNlbGVjdG9yID0ga2VjY2FrMjU2KHN0cmluZ1RvSGV4KGlzVmFsaWRTaWduYXR1cmVTaWduYXR1cmUpKS5zbGljZSgwLCAxMCk7XG4gICAgY29uc3Qgc2VsZWN0b3JzID0gQXJyYXkuZnJvbShuZXcgU2V0KFtcbiAgICAgICAgc2VsZWN0b3IsXG4gICAgICAgIGdldElkZW50aXR5UmVnaXN0cnlTZWxlY3RvcixcbiAgICAgICAgc3RvcmVBc3NvY2lhdGlvblNlbGVjdG9yLFxuICAgICAgICBpc1ZhbGlkU2lnbmF0dXJlU2VsZWN0b3IgLy8gQWRkIHRoaXMgZm9yIEVSQy0xMjcxIHZhbGlkYXRpb25cbiAgICBdKSk7XG4gICAgY29uc3QgZGVsZWdhdGlvbiA9IGNyZWF0ZURlbGVnYXRpb24oe1xuICAgICAgICBlbnZpcm9ubWVudDogZGVsZUdhdG9yRW52LFxuICAgICAgICBzY29wZToge1xuICAgICAgICAgICAgdHlwZTogJ2Z1bmN0aW9uQ2FsbCcsXG4gICAgICAgICAgICB0YXJnZXRzLFxuICAgICAgICAgICAgc2VsZWN0b3JzLFxuICAgICAgICB9LFxuICAgICAgICBmcm9tOiBhZ2VudEFjY291bnQsXG4gICAgICAgIHRvOiBzZXNzaW9uQUEsIC8vIEtlZXAgc2Vzc2lvbkFBIGFzIGRlbGVnYXRlXG4gICAgICAgIGNhdmVhdHM6IFtdLFxuICAgIH0pO1xuICAgIGxldCBzaWduYXR1cmU7XG4gICAgY29uc29sZS5pbmZvKCcqKioqKioqKioqKiBzZXNzaW9uUGFja2FnZUJ1aWxkZXIgeXl5eXk6IHNpZ25EZWxlZ2F0aW9uIHNtYXJ0QWNjb3VudCcpO1xuICAgIHNpZ25hdHVyZSA9IChhd2FpdCBzbWFydEFjY291bnQuc2lnbkRlbGVnYXRpb24oe1xuICAgICAgICBkZWxlZ2F0aW9uLFxuICAgIH0pKTtcbiAgICBjb25zdCBkZWxpZ2F0aW9uV2l0aFNpZ25hdHVyZSA9IHtcbiAgICAgICAgLi4uZGVsZWdhdGlvbixcbiAgICAgICAgc2lnbmF0dXJlLFxuICAgIH07XG4gICAgLy8gVGVzdCB0aGUgZGVsZWdhdGlvbiBieSBtYWtpbmcgYSBzaW1wbGUgY2FsbCB0byBWYWxpZGF0aW9uUmVnaXN0cnkuZ2V0SWRlbnRpdHlSZWdpc3RyeSgpIGZyb20gc2Vzc2lvbiBhY2NvdW50XG4gICAgLy8gVGhpcyBkZW1vbnN0cmF0ZXMgdGhlIGZ1bGwgZGVsZWdhdGlvbiByZWRlbXB0aW9uIGZsb3cgYW5kIHNob3VsZCBzdWNjZWVkIGJlY2F1c2UgdGhlIHNlbGVjdG9yIGlzIGFsbG93ZWRcbiAgICBjb25zb2xlLmluZm8oJyoqKioqKioqKioqIHNlc3Npb25QYWNrYWdlQnVpbGRlcjogVGVzdGluZyBkZWxlZ2F0aW9uIHdpdGggVmFsaWRhdGlvblJlZ2lzdHJ5LmdldElkZW50aXR5UmVnaXN0cnkoKSBjYWxsIChleHBlY3RlZCB0byBzdWNjZWVkKS4uLicpO1xuICAgIHRyeSB7XG4gICAgICAgIC8vIENyZWF0ZSBzZXNzaW9uIGFjY291bnQgY2xpZW50IHdpdGggZGVsZWdhdGlvblxuICAgICAgICBjb25zdCBzZXNzaW9uQWNjb3VudENsaWVudCA9IGF3YWl0IHRvTWV0YU1hc2tTbWFydEFjY291bnQoe1xuICAgICAgICAgICAgYWRkcmVzczogc2Vzc2lvbkFBLFxuICAgICAgICAgICAgY2xpZW50OiBwdWJsaWNDbGllbnQsXG4gICAgICAgICAgICBpbXBsZW1lbnRhdGlvbjogSW1wbGVtZW50YXRpb24uSHlicmlkLFxuICAgICAgICAgICAgc2lnbmVyOiB7IGFjY291bnQ6IHNlc3Npb25LZXlBY2NvdW50IH0sXG4gICAgICAgICAgICBkZWxlZ2F0aW9uOiB7XG4gICAgICAgICAgICAgICAgZGVsZWdhdGlvbjogZGVsaWdhdGlvbldpdGhTaWduYXR1cmUsXG4gICAgICAgICAgICAgICAgZGVsZWdhdG9yOiBhZ2VudEFjY291bnQsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gUHJlcGFyZSBhIHNpbXBsZSBjYWxsIHRvIFZhbGlkYXRpb25SZWdpc3RyeS5nZXRJZGVudGl0eVJlZ2lzdHJ5KClcbiAgICAgICAgY29uc3QgdGVzdENhbGxEYXRhID0gZW5jb2RlRnVuY3Rpb25EYXRhKHtcbiAgICAgICAgICAgIGFiaTogVmFsaWRhdGlvblJlZ2lzdHJ5QWJpLFxuICAgICAgICAgICAgZnVuY3Rpb25OYW1lOiAnZ2V0SWRlbnRpdHlSZWdpc3RyeScsXG4gICAgICAgICAgICBhcmdzOiBbXSxcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIEV4dHJhY3QgZGVsZWdhdGlvbiBtZXNzYWdlIGZvciByZWRlbXB0aW9uIC0gdXNlIHRoZSBzaWduZWQgZGVsZWdhdGlvblxuICAgICAgICBjb25zdCBkZWxlZ2F0aW9uTWVzc2FnZSA9IHtcbiAgICAgICAgICAgIGRlbGVnYXRlOiBkZWxpZ2F0aW9uV2l0aFNpZ25hdHVyZS5kZWxlZ2F0ZSxcbiAgICAgICAgICAgIGRlbGVnYXRvcjogZGVsaWdhdGlvbldpdGhTaWduYXR1cmUuZGVsZWdhdG9yLFxuICAgICAgICAgICAgYXV0aG9yaXR5OiBkZWxpZ2F0aW9uV2l0aFNpZ25hdHVyZS5hdXRob3JpdHksXG4gICAgICAgICAgICBjYXZlYXRzOiBkZWxpZ2F0aW9uV2l0aFNpZ25hdHVyZS5jYXZlYXRzLFxuICAgICAgICAgICAgc2FsdDogZGVsaWdhdGlvbldpdGhTaWduYXR1cmUuc2FsdCxcbiAgICAgICAgICAgIHNpZ25hdHVyZTogZGVsaWdhdGlvbldpdGhTaWduYXR1cmUuc2lnbmF0dXJlLCAvLyBVc2UgdGhlIGFjdHVhbCBzaWduYXR1cmUgZnJvbSBzaWduRGVsZWdhdGlvblxuICAgICAgICB9O1xuICAgICAgICAvLyBFbmNvZGUgZGVsZWdhdGlvbiByZWRlbXB0aW9uXG4gICAgICAgIGNvbnN0IFNJTkdMRV9ERUZBVUxUX01PREUgPSBFeGVjdXRpb25Nb2RlLlNpbmdsZURlZmF1bHQ7XG4gICAgICAgIGlmICghRGVsZWdhdGlvbk1hbmFnZXIgfHwgIURlbGVnYXRpb25NYW5hZ2VyLmVuY29kZSB8fCAhRGVsZWdhdGlvbk1hbmFnZXIuZW5jb2RlLnJlZGVlbURlbGVnYXRpb25zKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RlbGVnYXRpb25NYW5hZ2VyLmVuY29kZS5yZWRlZW1EZWxlZ2F0aW9ucyBub3QgZm91bmQuIENoZWNrIEBtZXRhbWFzay9zbWFydC1hY2NvdW50cy1raXQgdmVyc2lvbi4nKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpbmNsdWRlZEV4ZWN1dGlvbnMgPSBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0OiB2YWxpZGF0aW9uUmVnaXN0cnksXG4gICAgICAgICAgICAgICAgdmFsdWU6IEJpZ0ludCgwKSxcbiAgICAgICAgICAgICAgICBjYWxsRGF0YTogdGVzdENhbGxEYXRhLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXTtcbiAgICAgICAgY29uc3QgcmVkZW1wdGlvbkRhdGEgPSBEZWxlZ2F0aW9uTWFuYWdlci5lbmNvZGUucmVkZWVtRGVsZWdhdGlvbnMoe1xuICAgICAgICAgICAgZGVsZWdhdGlvbnM6IFtbZGVsZWdhdGlvbk1lc3NhZ2VdXSxcbiAgICAgICAgICAgIG1vZGVzOiBbU0lOR0xFX0RFRkFVTFRfTU9ERV0sXG4gICAgICAgICAgICBleGVjdXRpb25zOiBbaW5jbHVkZWRFeGVjdXRpb25zXSxcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFNlbmQgdGhlIHRlc3QgY2FsbCB0aHJvdWdoIGRlbGVnYXRpb25cbiAgICAgICAgY29uc3QgdGVzdENhbGwgPSB7XG4gICAgICAgICAgICB0bzogc2Vzc2lvbkFBLFxuICAgICAgICAgICAgZGF0YTogcmVkZW1wdGlvbkRhdGEsXG4gICAgICAgICAgICB2YWx1ZTogMG4sXG4gICAgICAgIH07XG4gICAgICAgIGNvbnNvbGUuaW5mbygnKioqKioqKioqKiogc2Vzc2lvblBhY2thZ2VCdWlsZGVyOiBTZW5kaW5nIGRlbGVnYXRlZCBjYWxsIHRvIFZhbGlkYXRpb25SZWdpc3RyeS5nZXRJZGVudGl0eVJlZ2lzdHJ5KCkuLi4nKTtcbiAgICAgICAgY29uc29sZS5pbmZvKCcqKioqKioqKioqKiBzZXNzaW9uUGFja2FnZUJ1aWxkZXI6IFRoaXMgZGVtb25zdHJhdGVzIGRlbGVnYXRpb24gcmVkZW1wdGlvbiBmbG93IGVuZC10by1lbmQnKTtcbiAgICAgICAgY29uc3QgdGVzdEhhc2ggPSBhd2FpdCBzZW5kU3BvbnNvcmVkVXNlck9wZXJhdGlvbih7XG4gICAgICAgICAgICBidW5kbGVyVXJsLFxuICAgICAgICAgICAgY2hhaW4sXG4gICAgICAgICAgICBhY2NvdW50Q2xpZW50OiBzZXNzaW9uQWNjb3VudENsaWVudCxcbiAgICAgICAgICAgIGNhbGxzOiBbdGVzdENhbGxdLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgdGVzdFJlY2VpcHQgPSBhd2FpdCB3YWl0Rm9yVXNlck9wZXJhdGlvblJlY2VpcHQoeyBidW5kbGVyVXJsLCBjaGFpbiwgaGFzaDogdGVzdEhhc2ggfSk7XG4gICAgICAgIGNvbnNvbGUuaW5mbygnKioqKioqKioqKiogc2Vzc2lvblBhY2thZ2VCdWlsZGVyOiDinJMgRGVsZWdhdGlvbiB0ZXN0IHN1Y2Nlc3NmdWwhIFJlY2VpcHQ6JywgdGVzdFJlY2VpcHQ/LnRyYW5zYWN0aW9uSGFzaCB8fCB0ZXN0SGFzaCk7XG4gICAgICAgIC8vIFZlcmlmeSB0aGUgY2FsbCByZXR1cm5lZCBhbiBhZGRyZXNzIChzaG91bGQgbWF0Y2ggaWRlbnRpdHlSZWdpc3RyeSlcbiAgICAgICAgY29uc3QgaWRlbnRpdHlSZWdpc3RyeUZyb21DYWxsID0gYXdhaXQgcHVibGljQ2xpZW50LnJlYWRDb250cmFjdCh7XG4gICAgICAgICAgICBhZGRyZXNzOiB2YWxpZGF0aW9uUmVnaXN0cnksXG4gICAgICAgICAgICBhYmk6IFZhbGlkYXRpb25SZWdpc3RyeUFiaSxcbiAgICAgICAgICAgIGZ1bmN0aW9uTmFtZTogJ2dldElkZW50aXR5UmVnaXN0cnknLFxuICAgICAgICAgICAgYXJnczogW10sXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zb2xlLmluZm8oJyoqKioqKioqKioqIHNlc3Npb25QYWNrYWdlQnVpbGRlcjog4pyTIERlbGVnYXRpb24gdmVyaWZpZWQgLSBJZGVudGl0eVJlZ2lzdHJ5IGFkZHJlc3M6JywgaWRlbnRpdHlSZWdpc3RyeUZyb21DYWxsKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvcik7XG4gICAgICAgIGlmIChtZXNzYWdlLmluY2x1ZGVzKCdJbnZhbGlkIFNtYXJ0IEFjY291bnQgbm9uY2UnKSB8fFxuICAgICAgICAgICAgbWVzc2FnZS5pbmNsdWRlcygnQUEyNSBpbnZhbGlkIGFjY291bnQgZGVwbG95bWVudCcpKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJyoqKioqKioqKioqIHNlc3Npb25QYWNrYWdlQnVpbGRlcjogRGVsZWdhdGlvbiB0ZXN0IHNraXBwZWQgZHVlIHRvIHBlbmRpbmcgZGVwbG95bWVudC9ub25jZSBjb25mbGljdDonLCBtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJyoqKioqKioqKioqIHNlc3Npb25QYWNrYWdlQnVpbGRlcjogRGVsZWdhdGlvbiB0ZXN0IGNhbGwgZmFpbGVkOicsIGVycm9yKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRGVsZWdhdGlvbiB0ZXN0IGZhaWxlZDogJHttZXNzYWdlfWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIHNldCB0aGUgb3BlcmF0b3Igb2YgbmZ0IHRvIHRoaXMgbmV3bHkgY3JlYXRlZCBzZXNzaW9uQUFcbiAgICBjb25zb2xlLmluZm8oXCJpZGVudGl0eVJlZ2lzdHJ5OiBcIiwgaWRlbnRpdHlSZWdpc3RyeSk7XG4gICAgY29uc29sZS5pbmZvKFwiemVyb0FkZHJlc3M6IFwiLCB6ZXJvQWRkcmVzcyk7XG4gICAgaWYgKGlkZW50aXR5UmVnaXN0cnkgJiYgaWRlbnRpdHlSZWdpc3RyeSAhPT0gemVyb0FkZHJlc3MpIHtcbiAgICAgICAgY29uc29sZS5pbmZvKCcqKioqKioqKioqKiBzZXNzaW9uUGFja2FnZUJ1aWxkZXI6IHNldCB0aGUgb3BlcmF0b3Igb2YgbmZ0IHRvIHRoaXMgbmV3bHkgY3JlYXRlZCBzZXNzaW9uQUEnKTtcbiAgICAgICAgY29uc3QgYXBwcm92ZUNhbGxkYXRhID0gZW5jb2RlRnVuY3Rpb25EYXRhKHtcbiAgICAgICAgICAgIGFiaTogSWRlbnRpdHlSZWdpc3RyeUFiaSxcbiAgICAgICAgICAgIGZ1bmN0aW9uTmFtZTogJ2FwcHJvdmUnLFxuICAgICAgICAgICAgYXJnczogW3Nlc3Npb25BQSwgQmlnSW50KGFnZW50SWQpXSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnNvbGUuaW5mbygnKioqKioqKioqKiogc2Vzc2lvblBhY2thZ2VCdWlsZGVyOiBhcHByb3ZlQ2FsbGRhdGEnLCBhcHByb3ZlQ2FsbGRhdGEpO1xuICAgICAgICBjb25zdCBoYXNoID0gYXdhaXQgc2VuZFNwb25zb3JlZFVzZXJPcGVyYXRpb24oe1xuICAgICAgICAgICAgYnVuZGxlclVybCxcbiAgICAgICAgICAgIGNoYWluLFxuICAgICAgICAgICAgYWNjb3VudENsaWVudDogc21hcnRBY2NvdW50LFxuICAgICAgICAgICAgY2FsbHM6IFt7IHRvOiBpZGVudGl0eVJlZ2lzdHJ5LCBkYXRhOiBhcHByb3ZlQ2FsbGRhdGEgfV0sXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCB3YWl0Rm9yVXNlck9wZXJhdGlvblJlY2VpcHQoeyBidW5kbGVyVXJsLCBjaGFpbiwgaGFzaCB9KTtcbiAgICAgICAgY29uc3Qgb3duZXJPZkFnZW50ID0gYXdhaXQgcHVibGljQ2xpZW50LnJlYWRDb250cmFjdCh7XG4gICAgICAgICAgICBhZGRyZXNzOiBpZGVudGl0eVJlZ2lzdHJ5LFxuICAgICAgICAgICAgYWJpOiBJZGVudGl0eVJlZ2lzdHJ5QWJpLFxuICAgICAgICAgICAgZnVuY3Rpb25OYW1lOiAnb3duZXJPZicsXG4gICAgICAgICAgICBhcmdzOiBbYWdlbnRJZF0sXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zb2xlLmluZm8oJyoqKioqKioqKioqIHNlc3Npb25QYWNrYWdlQnVpbGRlcjogb3duZXJPZkFnZW50Jywgb3duZXJPZkFnZW50KTtcbiAgICB9XG4gICAgY29uc29sZS5pbmZvKCcqKioqKioqKioqKiBzZXNzaW9uUGFja2FnZUJ1aWxkZXI6IHNlc3Npb25QYWNrYWdlJyk7XG4gICAgY29uc3Qgc2Vzc2lvblBhY2thZ2UgPSB7XG4gICAgICAgIGFnZW50SWQsXG4gICAgICAgIGNoYWluSWQsXG4gICAgICAgIGFhOiBhZ2VudEFjY291bnQsXG4gICAgICAgIHNlc3Npb25BQSxcbiAgICAgICAgc2VsZWN0b3IsXG4gICAgICAgIHNlc3Npb25LZXk6IHtcbiAgICAgICAgICAgIHByaXZhdGVLZXk6IHNlc3Npb25Qcml2YXRlS2V5LFxuICAgICAgICAgICAgYWRkcmVzczogc2Vzc2lvbktleUFjY291bnQuYWRkcmVzcyxcbiAgICAgICAgICAgIHZhbGlkQWZ0ZXIsXG4gICAgICAgICAgICB2YWxpZFVudGlsLFxuICAgICAgICB9LFxuICAgICAgICBlbnRyeVBvaW50LFxuICAgICAgICBidW5kbGVyVXJsLFxuICAgICAgICBzaWduZWREZWxlZ2F0aW9uOiBkZWxpZ2F0aW9uV2l0aFNpZ25hdHVyZSxcbiAgICB9O1xuICAgIHJldHVybiBzZXNzaW9uUGFja2FnZTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNlc3Npb25QYWNrYWdlQnVpbGRlci5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@agentic-trust/core/dist/client/sessionPackageBuilder.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@agentic-trust/core/dist/client/walletSigning.js":
/*!***************************************************************************!*\
  !*** ../../node_modules/@agentic-trust/core/dist/client/walletSigning.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createAgentWithWallet: () => (/* binding */ createAgentWithWallet),\n/* harmony export */   extractAgentIdFromReceipt: () => (/* binding */ extractAgentIdFromReceipt),\n/* harmony export */   finalizeAssociationWithWallet: () => (/* binding */ finalizeAssociationWithWallet),\n/* harmony export */   getCounterfactualAAAddressByAgentName: () => (/* reexport safe */ _accountClient__WEBPACK_IMPORTED_MODULE_2__.getCounterfactualAAAddressByAgentName),\n/* harmony export */   getCounterfactualAccountClientByAgentName: () => (/* reexport safe */ _accountClient__WEBPACK_IMPORTED_MODULE_2__.getCounterfactualAccountClientByAgentName),\n/* harmony export */   getCounterfactualSmartAccountAddressByAgentName: () => (/* reexport safe */ _accountClient__WEBPACK_IMPORTED_MODULE_2__.getCounterfactualSmartAccountAddressByAgentName),\n/* harmony export */   getDeployedAccountClientByAddress: () => (/* reexport safe */ _accountClient__WEBPACK_IMPORTED_MODULE_2__.getDeployedAccountClientByAddress),\n/* harmony export */   getDeployedAccountClientByAgentName: () => (/* reexport safe */ _accountClient__WEBPACK_IMPORTED_MODULE_2__.getDeployedAccountClientByAgentName),\n/* harmony export */   getWalletAddress: () => (/* binding */ getWalletAddress),\n/* harmony export */   giveFeedbackWithWallet: () => (/* binding */ giveFeedbackWithWallet),\n/* harmony export */   isWalletProviderAvailable: () => (/* binding */ isWalletProviderAvailable),\n/* harmony export */   refreshAgentInIndexer: () => (/* binding */ refreshAgentInIndexer),\n/* harmony export */   requestAIDValidationWithWallet: () => (/* binding */ requestAIDValidationWithWallet),\n/* harmony export */   requestAccountValidationWithWallet: () => (/* binding */ requestAccountValidationWithWallet),\n/* harmony export */   requestAppValidationWithWallet: () => (/* binding */ requestAppValidationWithWallet),\n/* harmony export */   requestNameValidationWithWallet: () => (/* binding */ requestNameValidationWithWallet),\n/* harmony export */   signAndSendTransaction: () => (/* binding */ signAndSendTransaction),\n/* harmony export */   updateAgentRegistrationWithWallet: () => (/* binding */ updateAgentRegistrationWithWallet)\n/* harmony export */ });\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! viem */ \"(rsc)/../../node_modules/viem/_esm/clients/createWalletClient.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! viem */ \"(rsc)/../../node_modules/viem/_esm/clients/transports/custom.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! viem */ \"(rsc)/../../node_modules/viem/_esm/clients/createPublicClient.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! viem */ \"(rsc)/../../node_modules/viem/_esm/utils/address/getAddress.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! viem */ \"(rsc)/../../node_modules/viem/_esm/clients/transports/http.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! viem */ \"(rsc)/../../node_modules/viem/_esm/utils/address/isAddressEqual.js\");\n/* harmony import */ var _agentic_trust_8004_ext_sdk__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @agentic-trust/8004-ext-sdk */ \"(rsc)/../../node_modules/@agentic-trust/8004-ext-sdk/dist/index.js\");\n/* harmony import */ var _server_lib_chainConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../server/lib/chainConfig */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/lib/chainConfig.js\");\n/* harmony import */ var _accountClient__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./accountClient */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/client/accountClient.js\");\n/* harmony import */ var _api_agents_client__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../api/agents/client */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/api/agents/client.js\");\n/* harmony import */ var _shared_did8004__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../shared/did8004 */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/shared/did8004.js\");\n/**\n * Client-side wallet signing utilities\n *\n * Handles MetaMask/EIP-1193 wallet integration for signing and sending transactions\n * All Ethereum logic is handled server-side, client only needs to sign and send\n */\n\n\n\n\n\n\n\n\nfunction resolveEthereumProvider(providedProvider) {\n    if (providedProvider)\n        return providedProvider;\n    if (typeof window !== 'undefined') {\n        const web3authProvider = window?.web3auth?.provider;\n        if (web3authProvider)\n            return web3authProvider;\n        const injected = window.ethereum;\n        if (injected)\n            return injected;\n    }\n    return null;\n}\nasync function resolveChainId(ethereumProvider) {\n    try {\n        const chainHex = await ethereumProvider.request?.({\n            method: 'eth_chainId',\n        });\n        if (typeof chainHex === 'string') {\n            return parseInt(chainHex, 16);\n        }\n    }\n    catch {\n        // ignore; fallback below\n    }\n    // Fallback to default chain id\n    return _server_lib_chainConfig__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_CHAIN_ID;\n}\n/**\n * Ensure the provider has an authorized account and return it.\n * Tries eth_accounts first; if empty, requests eth_requestAccounts.\n */\nasync function ensureAuthorizedAccount(ethereumProvider) {\n    try {\n        const existing = await ethereumProvider.request({ method: 'eth_accounts' });\n        if (Array.isArray(existing) && existing.length > 0) {\n            return existing[0];\n        }\n    }\n    catch {\n        // ignore and fall through to request\n    }\n    try {\n        const granted = await ethereumProvider.request({\n            method: 'eth_requestAccounts',\n        });\n        if (Array.isArray(granted) && granted.length > 0) {\n            return granted[0];\n        }\n    }\n    catch {\n        // fallthrough to permissions flow\n    }\n    try {\n        await ethereumProvider.request?.({\n            method: 'wallet_requestPermissions',\n            params: [{ eth_accounts: {} }],\n        });\n        const afterPerm = await ethereumProvider.request({\n            method: 'eth_accounts',\n        });\n        if (Array.isArray(afterPerm) && afterPerm.length > 0) {\n            return afterPerm[0];\n        }\n    }\n    catch {\n        // ignore\n    }\n    throw new Error('Wallet not authorized. Please connect your wallet.');\n}\nasync function ensureChainSelected(ethereumProvider, chain) {\n    try {\n        const currentHex = await ethereumProvider.request?.({\n            method: 'eth_chainId',\n        });\n        const current = typeof currentHex === 'string' ? parseInt(currentHex, 16) : undefined;\n        if (current === chain.id)\n            return;\n    }\n    catch {\n        // continue to switch\n    }\n    const hexId = `0x${chain.id.toString(16)}`;\n    try {\n        await ethereumProvider.request?.({\n            method: 'wallet_switchEthereumChain',\n            params: [{ chainId: hexId }],\n        });\n        return;\n    }\n    catch (switchErr) {\n        // 4902 = unknown chain, try add then switch\n        if (switchErr?.code !== 4902) {\n            throw switchErr;\n        }\n    }\n    // Try to add chain using centralized configuration\n    const chainConfig = (0,_server_lib_chainConfig__WEBPACK_IMPORTED_MODULE_1__.getChainById)(chain.id);\n    const addParams = {\n        chainId: hexId,\n        chainName: chainConfig.name,\n        nativeCurrency: {\n            name: 'ETH',\n            symbol: 'ETH',\n            decimals: 18,\n        },\n        rpcUrls: [(0,_server_lib_chainConfig__WEBPACK_IMPORTED_MODULE_1__.getChainRpcUrl)(chain.id)],\n        blockExplorerUrls: chainConfig.blockExplorers?.default\n            ? [chainConfig.blockExplorers.default.url]\n            : [],\n    };\n    await ethereumProvider.request?.({\n        method: 'wallet_addEthereumChain',\n        params: [addParams],\n    });\n    await ethereumProvider.request?.({\n        method: 'wallet_switchEthereumChain',\n        params: [{ chainId: hexId }],\n    });\n}\n/**\n * Sign and send a transaction using MetaMask/EIP-1193 wallet\n *\n * @param options - Signing options including transaction, account, chain, and provider\n * @returns Transaction hash, receipt, and optionally extracted agentId\n */\nasync function signAndSendTransaction(options) {\n    const { transaction, account, chain, ethereumProvider, rpcUrl, onStatusUpdate, extractAgentId = false, } = options;\n    // Get wallet provider\n    const provider = resolveEthereumProvider(ethereumProvider);\n    if (!provider) {\n        throw new Error('No wallet provider found. Please connect MetaMask or use an EIP-1193 compatible wallet.');\n    }\n    // Update status\n    onStatusUpdate?.('Connecting to wallet...');\n    // Create wallet client\n    try {\n        // Ensure correct chain & account permission before sending\n        await ensureChainSelected(provider, chain);\n        await ensureAuthorizedAccount(provider);\n    }\n    catch {\n        // Non-fatal; some providers may not require this here\n    }\n    const walletClient = (0,viem__WEBPACK_IMPORTED_MODULE_5__.createWalletClient)({\n        account,\n        chain,\n        transport: (0,viem__WEBPACK_IMPORTED_MODULE_6__.custom)(provider),\n    });\n    // Prefer a real RPC for reads (Web3Auth/OpenLogin providers often return opaque \"internal JSON-RPC error\"\n    // for eth_getCode / eth_estimateGas / waitForReceipt).\n    const rpcForReads = rpcUrl ||\n        chain?.rpcUrls?.default?.http?.[0] ||\n        chain?.rpcUrls?.public?.http?.[0];\n    const readClient = (0,viem__WEBPACK_IMPORTED_MODULE_7__.createPublicClient)({\n        chain,\n        transport: rpcForReads ? (0,viem__WEBPACK_IMPORTED_MODULE_8__.http)(rpcForReads) : (0,viem__WEBPACK_IMPORTED_MODULE_6__.custom)(provider),\n    });\n    // Web3Auth/OpenLogin providers can be on a different chain than our UI selection.\n    // If we don't enforce chain alignment, sendTransaction can fail with opaque internal errors.\n    try {\n        const currentChainIdHex = (await provider.request?.({ method: 'eth_chainId', params: [] }));\n        if (currentChainIdHex && typeof currentChainIdHex === 'string' && currentChainIdHex.startsWith('0x')) {\n            const current = Number.parseInt(currentChainIdHex, 16);\n            if (Number.isFinite(current) && current !== chain.id) {\n                throw new Error(`Wallet is on chainId ${current} but this transaction targets chainId ${chain.id}. Please switch networks in Web3Auth and retry.`);\n            }\n        }\n    }\n    catch (e) {\n        // If eth_chainId itself fails, continue; other checks will still surface errors.\n    }\n    // Preflight: ensure target has code + estimate gas (so we can surface reverts early and\n    // avoid wallet-side estimation failures).\n    let estimatedGas = null;\n    if (transaction?.to) {\n        const code = await readClient.getBytecode({ address: transaction.to });\n        if (!code || code === '0x') {\n            throw new Error(`Target contract is not deployed at ${String(transaction.to)} on chainId ${chain.id}. Check addresses/config.`);\n        }\n        try {\n            estimatedGas = await readClient.estimateGas({\n                account,\n                to: transaction.to,\n                data: transaction.data,\n                value: BigInt(transaction.value ?? 0),\n            });\n        }\n        catch (estimateErr) {\n            // Try to extract revert reason from eth_call simulation\n            let revertReason = 'unknown reason';\n            try {\n                await readClient.call({\n                    account,\n                    to: transaction.to,\n                    data: transaction.data,\n                    value: BigInt(transaction.value ?? 0),\n                });\n            }\n            catch (callErr) {\n                // Try multiple ways to extract revert reason\n                const data = callErr?.data || callErr?.cause?.data || callErr?.details || callErr?.body?.error?.data || '';\n                const shortMsg = callErr?.shortMessage || callErr?.message || '';\n                // Standard Solidity revert: Error(string) selector 0x08c379a0\n                if (typeof data === 'string' && data.startsWith('0x08c379a0')) {\n                    try {\n                        const { decodeAbiParameters } = await Promise.all(/*! import() */[__webpack_require__.e(\"vendor-chunks/viem\"), __webpack_require__.e(\"vendor-chunks/abitype\")]).then(__webpack_require__.bind(__webpack_require__, /*! viem */ \"(rsc)/../../node_modules/viem/_esm/index.js\"));\n                        const decoded = decodeAbiParameters([{ type: 'string', name: 'reason' }], `0x${data.slice(10)}`);\n                        revertReason = decoded[0];\n                    }\n                    catch {\n                        revertReason = 'reverted with Error(string) (decode failed)';\n                    }\n                }\n                else if (typeof data === 'string' && data.length > 2 && data.startsWith('0x')) {\n                    // If we have hex data but it's not Error(string), show first bytes\n                    revertReason = `reverted with data: ${data.slice(0, 130)}`;\n                }\n                else if (shortMsg && !shortMsg.includes('unknown')) {\n                    revertReason = shortMsg;\n                }\n                // Log full error for debugging\n                const errorMessage = callErr?.message || '';\n                console.warn('[signAndSendTransaction] Full eth_call error details:', {\n                    data,\n                    shortMessage: shortMsg,\n                    message: errorMessage,\n                    cause: callErr?.cause,\n                    body: callErr?.body,\n                    stack: callErr?.stack?.split('\\n').slice(0, 5),\n                });\n                // Try to decode Error(string) from the data if available\n                if (data && typeof data === 'string' && data.startsWith('0x') && data.length >= 10) {\n                    try {\n                        // Check if it's an Error(string) - selector is 0x08c379a0\n                        if (data.startsWith('0x08c379a0')) {\n                            const { decodeAbiParameters } = await Promise.all(/*! import() */[__webpack_require__.e(\"vendor-chunks/viem\"), __webpack_require__.e(\"vendor-chunks/abitype\")]).then(__webpack_require__.bind(__webpack_require__, /*! viem */ \"(rsc)/../../node_modules/viem/_esm/index.js\"));\n                            const decoded = decodeAbiParameters([{ type: 'string', name: 'reason' }], `0x${data.slice(10)}`);\n                            console.warn('[signAndSendTransaction] Decoded Error(string) revert reason:', decoded[0]);\n                            revertReason = decoded[0];\n                        }\n                        else {\n                            // Try to decode as raw string data\n                            const { decodeAbiParameters } = await Promise.all(/*! import() */[__webpack_require__.e(\"vendor-chunks/viem\"), __webpack_require__.e(\"vendor-chunks/abitype\")]).then(__webpack_require__.bind(__webpack_require__, /*! viem */ \"(rsc)/../../node_modules/viem/_esm/index.js\"));\n                            try {\n                                const decoded = decodeAbiParameters([{ type: 'string', name: 'reason' }], data);\n                                if (decoded[0]) {\n                                    console.warn('[signAndSendTransaction] Decoded raw revert reason:', decoded[0]);\n                                    revertReason = decoded[0];\n                                }\n                            }\n                            catch {\n                                // If that fails, show first part of hex data\n                                console.warn('[signAndSendTransaction] Raw revert data (first 100 chars):', data.slice(0, 100));\n                            }\n                        }\n                    }\n                    catch (decodeErr) {\n                        console.warn('[signAndSendTransaction] Failed to decode revert data:', decodeErr);\n                    }\n                }\n                // Try additional error message extraction\n                if (errorMessage && errorMessage.includes('revert')) {\n                    revertReason = errorMessage;\n                }\n            }\n            const msg = estimateErr?.shortMessage || estimateErr?.message || String(estimateErr);\n            throw new Error(`Transaction would fail (estimateGas): Execution reverted: ${revertReason}. ${msg}`);\n        }\n    }\n    // Update status\n    onStatusUpdate?.('Transaction prepared. Please confirm in your wallet...');\n    // Convert hex strings to bigint for Viem (Viem accepts both, but TypeScript is strict)\n    const txParams = {\n        ...transaction,\n        value: BigInt(transaction.value),\n    };\n    if (transaction.gas) {\n        txParams.gas = BigInt(transaction.gas);\n    }\n    else if (estimatedGas) {\n        // Pad estimate to avoid underestimation; some wallets struggle to estimate internally.\n        // IMPORTANT: keep this integer-safe; BigInt() cannot take fractional numbers.\n        // Use pure BigInt math to apply a 20% buffer.\n        const eg = typeof estimatedGas === 'bigint' ? estimatedGas : BigInt(estimatedGas);\n        txParams.gas = (eg * 120n) / 100n;\n    }\n    if (transaction.gasPrice) {\n        txParams.gasPrice = BigInt(transaction.gasPrice);\n    }\n    if (transaction.maxFeePerGas) {\n        txParams.maxFeePerGas = BigInt(transaction.maxFeePerGas);\n    }\n    if (transaction.maxPriorityFeePerGas) {\n        txParams.maxPriorityFeePerGas = BigInt(transaction.maxPriorityFeePerGas);\n    }\n    // If fees are not provided, estimate them via RPC. This avoids Web3Auth internal errors\n    // during wallet-side fee estimation.\n    if (!txParams.gasPrice && !txParams.maxFeePerGas && !txParams.maxPriorityFeePerGas) {\n        try {\n            const fees = await readClient.estimateFeesPerGas();\n            if (fees?.maxFeePerGas && fees?.maxPriorityFeePerGas) {\n                txParams.maxFeePerGas = fees.maxFeePerGas;\n                txParams.maxPriorityFeePerGas = fees.maxPriorityFeePerGas;\n            }\n            else {\n                const gp = await readClient.getGasPrice();\n                txParams.gasPrice = gp;\n            }\n        }\n        catch {\n            // Ignore; wallet may still handle fee estimation.\n        }\n    }\n    // Sign and send transaction\n    // NOTE: Web3Auth (OpenLogin) sometimes fails to surface the approval modal when using walletClient.sendTransaction.\n    // We keep the viem path first, but add a fallback to eth_sendTransaction which tends to reliably trigger the UI.\n    let hash;\n    try {\n        hash = await walletClient.sendTransaction(txParams);\n    }\n    catch (sendErr) {\n        console.warn('[signAndSendTransaction] walletClient.sendTransaction failed; attempting eth_sendTransaction fallback', sendErr);\n        try {\n            const from = account || txParams.account;\n            const txForProvider = {\n                from,\n                to: txParams.to,\n                data: txParams.data,\n                value: `0x${BigInt(txParams.value ?? 0n).toString(16)}`,\n            };\n            if (txParams.gas)\n                txForProvider.gas = `0x${BigInt(txParams.gas).toString(16)}`;\n            if (txParams.gasPrice)\n                txForProvider.gasPrice = `0x${BigInt(txParams.gasPrice).toString(16)}`;\n            if (txParams.maxFeePerGas)\n                txForProvider.maxFeePerGas = `0x${BigInt(txParams.maxFeePerGas).toString(16)}`;\n            if (txParams.maxPriorityFeePerGas)\n                txForProvider.maxPriorityFeePerGas = `0x${BigInt(txParams.maxPriorityFeePerGas).toString(16)}`;\n            hash = await provider.request?.({ method: 'eth_sendTransaction', params: [txForProvider] });\n        }\n        catch (fallbackErr) {\n            console.warn('[signAndSendTransaction] eth_sendTransaction fallback failed', fallbackErr);\n            throw sendErr;\n        }\n    }\n    // Update status\n    onStatusUpdate?.(`Transaction submitted! Hash: ${hash}. Waiting for confirmation...`);\n    // Wait for transaction receipt (use RPC, not wallet provider)\n    const receipt = await readClient.waitForTransactionReceipt({ hash });\n    // Extract agentId if requested (for agent creation transactions)\n    let agentId;\n    if (receipt && Array.isArray(receipt.logs)) {\n        const zeroTopic = '0x0000000000000000000000000000000000000000000000000000000000000000';\n        const transferTopic = '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef';\n        const mintLog = receipt.logs.find((log) => log?.topics?.[0] === transferTopic &&\n            (log?.topics?.[1] === zeroTopic || log?.topics?.[1] === undefined));\n        if (mintLog) {\n            const tokenTopic = mintLog.topics?.[3];\n            const tokenData = mintLog.data;\n            const tokenHex = tokenTopic ?? tokenData;\n            if (tokenHex) {\n                try {\n                    agentId = BigInt(tokenHex).toString();\n                }\n                catch (error) {\n                    console.warn('Unable to parse agentId from mint log:', error);\n                }\n            }\n        }\n    }\n    if (extractAgentId) {\n        try {\n            agentId = extractAgentIdFromReceipt(receipt);\n        }\n        catch (error) {\n            console.warn('Could not extract agentId from receipt:', error);\n        }\n    }\n    return {\n        hash,\n        receipt,\n        agentId,\n    };\n}\n/**\n * Extract agentId from a transaction receipt (for agent creation)\n * Looks for ERC-721 Transfer event from zero address\n *\n * @param receipt - Transaction receipt\n * @returns Extracted agentId as string, or undefined if not found\n */\nfunction extractAgentIdFromReceipt(receipt) {\n    try {\n        // ERC-721 Transfer event signature\n        const transferTopic = '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef';\n        // Zero address topic (from address)\n        const zeroAddress = '0x0000000000000000000000000000000000000000000000000000000000000000';\n        if (!receipt.logs || !Array.isArray(receipt.logs)) {\n            return undefined;\n        }\n        for (const log of receipt.logs) {\n            if (log.topics &&\n                log.topics[0] === transferTopic &&\n                log.topics[1] === zeroAddress) {\n                // Extract tokenId (agentId) from topics[3]\n                if (log.topics[3]) {\n                    return BigInt(log.topics[3]).toString();\n                }\n            }\n        }\n        return undefined;\n    }\n    catch (error) {\n        console.warn('Error extracting agentId from receipt:', error);\n        return undefined;\n    }\n}\n/**\n * Refresh agent in GraphQL indexer\n *\n * @param agentId - Agent ID to refresh\n * @param chainId - Chain ID for the agent\n * @param refreshEndpoint - Optional custom refresh endpoint (defaults to `/api/agents/<did>/refresh`)\n * @returns Promise that resolves when refresh is complete\n */\nasync function refreshAgentInIndexer(agentId, chainId, refreshEndpoint) {\n    const chainIdStr = typeof chainId === 'number' ? chainId.toString(10) : chainId?.toString() ?? '';\n    if (!chainIdStr.trim()) {\n        throw new Error('Chain ID is required to refresh agent in indexer');\n    }\n    const did = encodeURIComponent(`did:8004:${chainIdStr.trim()}:${agentId}`);\n    const endpoint = refreshEndpoint || `/api/agents/${did}/refresh`;\n    try {\n        const response = await fetch(endpoint, {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json',\n            },\n            body: JSON.stringify({}), // Send empty body to avoid JSON parsing errors\n        });\n        if (!response.ok) {\n            const errorText = await response.text();\n            console.warn(`Failed to refresh agent ${agentId} in GraphQL indexer: ${response.status} ${response.statusText}`, errorText);\n            return;\n        }\n        // Try to parse response, but don't fail if it's empty\n        try {\n            const data = await response.json();\n            console.log(` Refreshed agent ${agentId} in GraphQL indexer`, data);\n        }\n        catch (parseError) {\n            // Response might be empty, that's okay\n            console.log(` Refreshed agent ${agentId} in GraphQL indexer`);\n        }\n    }\n    catch (error) {\n        console.warn(`Error refreshing agent ${agentId} in GraphQL indexer:`, error);\n    }\n}\n/**\n * Check if wallet provider is available\n *\n * @param ethereumProvider - Optional provider (defaults to window.ethereum)\n * @returns true if provider is available\n */\nfunction isWalletProviderAvailable(ethereumProvider) {\n    if (ethereumProvider) {\n        return true;\n    }\n    if (typeof window === 'undefined') {\n        return false;\n    }\n    return !!window.ethereum;\n}\n/**\n * Get the connected wallet address from provider\n *\n * @param ethereumProvider - Optional provider (defaults to window.ethereum)\n * @returns Connected wallet address, or null if not connected\n */\nasync function getWalletAddress(ethereumProvider) {\n    const provider = ethereumProvider ||\n        (typeof window !== 'undefined' ? window.ethereum : null);\n    if (!provider) {\n        return null;\n    }\n    try {\n        const accounts = await provider.request({ method: 'eth_accounts' });\n        if (accounts && accounts.length > 0) {\n            return accounts[0];\n        }\n        return null;\n    }\n    catch (error) {\n        console.warn('Error getting wallet address:', error);\n        return null;\n    }\n}\n/**\n * Create an agent with automatic wallet signing if needed\n *\n * This method handles the entire flow:\n * 1. Calls the API to create agent (endpoint: /api/agents/create)\n * 2. If client-side signing is required, signs and sends transaction\n * 3. Waits for receipt and extracts agentId\n * 4. Refreshes GraphQL indexer\n *\n * Only agentData is required - account, chain, and provider are auto-detected\n *\n * @param options - Creation options (only agentData required)\n * @returns Agent creation result\n */\nasync function createAgentWithWalletEOA(options) {\n    const { agentData, account: providedAccount, ethereumProvider: providedProvider, rpcUrl: providedRpcUrl, onStatusUpdate, chainId: requestedChainId, } = options;\n    // Get wallet provider (default to window.ethereum)\n    const ethereumProvider = providedProvider ||\n        (typeof window !== 'undefined' ? window.ethereum : null);\n    if (!ethereumProvider) {\n        throw new Error('No wallet provider found. Please connect MetaMask or use an EIP-1193 compatible wallet.');\n    }\n    // Get account from provider if not provided\n    let account;\n    if (providedAccount) {\n        account = providedAccount;\n    }\n    else {\n        account = await ensureAuthorizedAccount(ethereumProvider);\n    }\n    // Step 1: Call API to create agent\n    onStatusUpdate?.('Creating agent...');\n    const plan = await (0,_api_agents_client__WEBPACK_IMPORTED_MODULE_3__.createAgent)({\n        mode: 'eoa',\n        agentName: agentData.agentName,\n        agentAccount: agentData.agentAccount,\n        agentCategory: agentData.agentCategory,\n        supportedTrust: agentData.supportedTrust,\n        description: agentData.description,\n        image: agentData.image,\n        agentUrl: agentData.agentUrl,\n        endpoints: agentData.endpoints,\n        chainId: requestedChainId,\n    });\n    if (plan.mode !== 'eoa' || !plan.transaction) {\n        throw new Error('Server response missing EOA transaction details');\n    }\n    const chain = (0,_server_lib_chainConfig__WEBPACK_IMPORTED_MODULE_1__.getChainById)(plan.chainId);\n    const preparedTx = {\n        to: plan.transaction.to,\n        data: plan.transaction.data,\n        value: (plan.transaction.value ?? '0'),\n        gas: plan.transaction.gas,\n        gasPrice: plan.transaction.gasPrice,\n        maxFeePerGas: plan.transaction.maxFeePerGas,\n        maxPriorityFeePerGas: plan.transaction.maxPriorityFeePerGas,\n        nonce: plan.transaction.nonce,\n        chainId: plan.transaction.chainId,\n    };\n    // Sign and send transaction\n    const result = await signAndSendTransaction({\n        transaction: preparedTx,\n        account,\n        chain,\n        ethereumProvider,\n        onStatusUpdate,\n        extractAgentId: true,\n    });\n    if (result.agentId) {\n        // After registration, set agentWallet on-chain BEFORE notifying the indexer.\n        try {\n            const identityRegistry = plan.identityRegistry;\n            if (!identityRegistry) {\n                throw new Error('Missing identityRegistry in create-agent plan');\n            }\n            const viemWalletClient = (0,viem__WEBPACK_IMPORTED_MODULE_5__.createWalletClient)({\n                account,\n                chain,\n                transport: (0,viem__WEBPACK_IMPORTED_MODULE_6__.custom)(ethereumProvider),\n            });\n            const viemPublicClient = (0,viem__WEBPACK_IMPORTED_MODULE_7__.createPublicClient)({\n                chain,\n                transport: (0,viem__WEBPACK_IMPORTED_MODULE_6__.custom)(ethereumProvider),\n            });\n            const identityClient = new _agentic_trust_8004_ext_sdk__WEBPACK_IMPORTED_MODULE_0__.AIAgentIdentityClient({\n                publicClient: viemPublicClient,\n                walletClient: viemWalletClient,\n                identityRegistryAddress: identityRegistry,\n            });\n            const EIP712_DOMAIN_ABI = [\n                {\n                    type: 'function',\n                    name: 'eip712Domain',\n                    stateMutability: 'view',\n                    inputs: [],\n                    outputs: [\n                        { name: 'name', type: 'string' },\n                        { name: 'version', type: 'string' },\n                        { name: 'chainId', type: 'uint256' },\n                        { name: 'verifyingContract', type: 'address' },\n                        { name: 'salt', type: 'bytes32' },\n                        { name: 'extensions', type: 'uint256[]' },\n                    ],\n                },\n            ];\n            const domainRaw = (await viemPublicClient.readContract({\n                address: identityRegistry,\n                abi: EIP712_DOMAIN_ABI,\n                functionName: 'eip712Domain',\n                args: [],\n            }));\n            const domain = {\n                name: String(domainRaw?.name ?? domainRaw?.[0] ?? ''),\n                version: String(domainRaw?.version ?? domainRaw?.[1] ?? ''),\n                chainId: Number(domainRaw?.chainId ?? domainRaw?.[2] ?? chain.id),\n                verifyingContract: (domainRaw?.verifyingContract ?? domainRaw?.[3]),\n                salt: (domainRaw?.salt ?? domainRaw?.[4]),\n            };\n            const agentIdBigInt = BigInt(result.agentId);\n            const deadline = BigInt(Math.floor(Date.now() / 1000) + 60 * 60); // +1h\n            const newWallet = (0,viem__WEBPACK_IMPORTED_MODULE_9__.getAddress)(account);\n            onStatusUpdate?.('MetaMask signature: set agent wallet (IdentityRegistry)');\n            const signature = (await viemWalletClient.signTypedData({\n                account,\n                domain,\n                primaryType: 'SetAgentWallet',\n                types: {\n                    SetAgentWallet: [\n                        { name: 'agentId', type: 'uint256' },\n                        { name: 'newWallet', type: 'address' },\n                        { name: 'deadline', type: 'uint256' },\n                    ],\n                },\n                message: { agentId: agentIdBigInt, newWallet, deadline },\n            }));\n            const { calls } = await identityClient.prepareSetAgentWalletCalls(agentIdBigInt, newWallet, deadline, signature);\n            const call = calls[0];\n            if (!call)\n                throw new Error('prepareSetAgentWalletCalls returned no calls');\n            await signAndSendTransaction({\n                transaction: {\n                    to: call.to,\n                    data: call.data,\n                    value: '0x0',\n                    chainId: chain.id,\n                },\n                account,\n                chain,\n                ethereumProvider,\n                onStatusUpdate,\n                extractAgentId: false,\n            });\n        }\n        catch (e) {\n            console.warn('[createAgentWithWalletEOA] setAgentWallet failed (non-fatal):', e);\n        }\n        await refreshAgentInIndexer(result.agentId, plan.chainId);\n    }\n    return {\n        agentId: result.agentId,\n        txHash: result.hash,\n        requiresClientSigning: true,\n    };\n}\n/**\n * Create an agent with Account Abstraction (AA) using a wallet\n *\n * This client-side function handles the complete AA agent creation flow:\n * 1. Detects wallet provider and account\n * 2. Creates/retrieves AA account client for the agent\n * 3. Calls the server API route `/api/agents/create` to prepare registration\n * 4. Sends UserOperation via bundler using the AA account\n * 5. Extracts agentId and refreshes the indexer\n *\n * **Setup Required:**\n * Your Next.js app must mount the API route handler:\n *\n * ```typescript\n * // In app/api/agents/create/route.ts\n * import { createAgentRouteHandler } from '@agentic-trust/core/server';\n * export const POST = createAgentRouteHandler();\n * ```\n *\n * **Usage:**\n * ```typescript\n * import { createAgentWithWallet } from '@agentic-trust/core/client';\n *\n * const result = await createAgentWithWallet({\n *   agentData: {\n *     agentName: 'my-agent',\n *     agentAccount: '0x...', // AA account address\n *     description: 'My agent',\n *   },\n *   onStatusUpdate: (msg) => console.log(msg),\n * });\n * ```\n *\n * @param options - Agent creation options\n * @returns Agent creation result with agentId and txHash\n */\nasync function createAgentWithWalletAA(options) {\n    const { agentData, account: providedAccount, ethereumProvider: providedProvider, rpcUrl: providedRpcUrl, onStatusUpdate, chainId: providedChainId, } = options;\n    // Get wallet provider (default to window.ethereum)\n    const ethereumProvider = resolveEthereumProvider(providedProvider);\n    if (!ethereumProvider) {\n        throw new Error('No wallet provider found. Please connect MetaMask or use an EIP-1193 compatible wallet.');\n    }\n    // Get account from provider if not provided\n    let account;\n    if (providedAccount) {\n        account = providedAccount;\n    }\n    else {\n        account = await ensureAuthorizedAccount(ethereumProvider);\n    }\n    const chainId = typeof providedChainId === 'number'\n        ? providedChainId\n        : await resolveChainId(ethereumProvider);\n    // Step 1: Call API to create agent\n    onStatusUpdate?.('Creating agent...');\n    // 0.  Get on the correct chain get adapter for the chain\n    let chain;\n    switch (chainId) {\n        case 11155111: // ETH Sepolia\n            chain = _server_lib_chainConfig__WEBPACK_IMPORTED_MODULE_1__.sepolia;\n            break;\n        case 84532: // Base Sepolia\n            chain = _server_lib_chainConfig__WEBPACK_IMPORTED_MODULE_1__.baseSepolia;\n            break;\n        case 11155420: // Optimism Sepolia\n            chain = _server_lib_chainConfig__WEBPACK_IMPORTED_MODULE_1__.optimismSepolia;\n            break;\n        default:\n            chain = _server_lib_chainConfig__WEBPACK_IMPORTED_MODULE_1__.sepolia;\n            console.warn(`Unknown chainId ${chainId}, defaulting to Sepolia`);\n    }\n    // Ensure provider is on the required chain before building clients\n    try {\n        await ensureChainSelected(ethereumProvider, chain);\n    }\n    catch (switchErr) {\n        console.warn('Unable to switch chain on provider for AA flow:', switchErr);\n    }\n    // Build viem clients bound to the user's Web3Auth provider\n    const viemWalletClient = (0,viem__WEBPACK_IMPORTED_MODULE_5__.createWalletClient)({\n        account,\n        chain,\n        transport: (0,viem__WEBPACK_IMPORTED_MODULE_6__.custom)(ethereumProvider),\n    });\n    const viemPublicClient = (0,viem__WEBPACK_IMPORTED_MODULE_7__.createPublicClient)({\n        chain,\n        transport: (0,viem__WEBPACK_IMPORTED_MODULE_6__.custom)(ethereumProvider),\n    });\n    // 1.  Need to create the Agent Account Abstraction (Account)\n    // Build AA account client using client's EOA (MetaMask/Web3Auth)\n    // Get agent name from request\n    //let agentFullName = options.agentData.agentName;\n    //if (options.ensOptions?.orgName) {\n    //  agentFullName = options.agentData.agentName + '.' + options.ensOptions?.orgName + \".eth\";\n    //}\n    // Get Account Client by Agent Name, find if exists and if not then create it\n    let bundlerUrl = (0,_server_lib_chainConfig__WEBPACK_IMPORTED_MODULE_1__.getChainBundlerUrl)(chainId);\n    let agentAccountClient = await (0,_accountClient__WEBPACK_IMPORTED_MODULE_2__.getDeployedAccountClientByAgentName)(bundlerUrl, options.agentData.agentName, account, {\n        chain: chain,\n        walletClient: viemWalletClient,\n        publicClient: viemPublicClient,\n    });\n    if (!agentAccountClient) {\n        throw new Error('Failed to build AA account client');\n    }\n    // Verify the address matches\n    const computedAddress = await agentAccountClient.getAddress();\n    if (computedAddress.toLowerCase() !==\n        options.agentData.agentAccount.toLowerCase()) {\n        throw new Error(`AA address mismatch: computed ${computedAddress}, expected ${options.agentData.agentAccount}`);\n    }\n    // 2.  Add ENS record associated with new agent\n    console.log('*********** createAgentWithWallet: options.ensOptions', options.ensOptions);\n    if (options.ensOptions?.enabled &&\n        options.ensOptions.orgName &&\n        (0,_server_lib_chainConfig__WEBPACK_IMPORTED_MODULE_1__.isL1)(chainId)) {\n        try {\n            const ensAgentAccount = typeof computedAddress === 'string' && computedAddress.startsWith('0x')\n                ? computedAddress\n                : options.agentData.agentAccount;\n            onStatusUpdate?.('Creating ENS subdomain for agent: ' + options.agentData.agentName);\n            const pkModeDetected = (0,_server_lib_chainConfig__WEBPACK_IMPORTED_MODULE_1__.isPrivateKeyMode)();\n            console.log(\"createAgentWithWallet: pkModeDetected\", pkModeDetected);\n            const addEndpoint = pkModeDetected\n                ? '/api/names/add-to-l1-org-pk'\n                : '/api/names/add-to-l1-org';\n            console.info(`[ENS][L1] ${pkModeDetected ? 'PK mode detected 11111' : 'Client mode'} - calling ${addEndpoint}`);\n            const ensResponse = await fetch(addEndpoint, {\n                method: 'POST',\n                headers: { 'Content-Type': 'application/json' },\n                body: JSON.stringify({\n                    agentAccount: ensAgentAccount,\n                    orgName: options.ensOptions.orgName,\n                    agentName: options.agentData.agentName,\n                    agentUrl: options.agentData.agentUrl,\n                    chainId,\n                }),\n            });\n            if (!ensResponse.ok) {\n                const err = await ensResponse.json().catch(() => ({}));\n                console.warn('[ENS][L1] add-to-l1-org call failed', err);\n            }\n            else {\n                console.info('[ENS][L1] add-to-l1-org call succeeded');\n            }\n            onStatusUpdate?.('Preparing ENS metadata update...');\n            const infoEndpoint = pkModeDetected\n                ? '/api/names/set-l1-name-info-pk'\n                : '/api/names/set-l1-name-info';\n            console.info(`[ENS][L1] ${pkModeDetected ? 'PK mode detected 22222' : 'Client mode'} - calling ${infoEndpoint}`);\n            const infoResponse = await fetch(infoEndpoint, {\n                method: 'POST',\n                headers: { 'Content-Type': 'application/json' },\n                body: JSON.stringify({\n                    agentAddress: ensAgentAccount,\n                    orgName: options.ensOptions.orgName,\n                    agentName: options.agentData.agentName,\n                    agentUrl: options.agentData.agentUrl,\n                    agentDescription: options.agentData.description,\n                    chainId,\n                }),\n            });\n            if (infoResponse.ok) {\n                console.log('*********** createAgentWithWallet: ENS metadata response received');\n                const infoData = await infoResponse.json();\n                const serverInfoUserOpHash = infoData?.userOpHash;\n                if (serverInfoUserOpHash) {\n                    console.log('*********** createAgentWithWallet: ENS info userOpHash (server-submitted)', serverInfoUserOpHash);\n                }\n                else {\n                    const infoCalls = [];\n                    if (Array.isArray(infoData?.calls)) {\n                        for (const rawCall of infoData.calls) {\n                            const to = rawCall?.to;\n                            const data = rawCall?.data;\n                            if (!to || !data) {\n                                continue;\n                            }\n                            let value;\n                            if (rawCall?.value !== null && rawCall?.value !== undefined) {\n                                try {\n                                    value = BigInt(rawCall.value);\n                                }\n                                catch (error) {\n                                    console.warn('Unable to parse ENS info call value', rawCall.value, error);\n                                }\n                            }\n                            infoCalls.push({\n                                to,\n                                data,\n                                value,\n                            });\n                        }\n                    }\n                    if (infoCalls.length > 0) {\n                        onStatusUpdate?.('MetaMask signature: update ENS metadata (URL/description/image)');\n                        // Ensure we are using a deployed-only AA client (no factory/factoryData)\n                        //const fullAgentName = agentName + '.' + options.ensOptions.orgName + \".eth\";\n                        console.log('!!!!!!!!!!!! handleCreateAgent: getDeployedAccountClientByAgentName 2: agentName', options.agentData.agentName);\n                        agentAccountClient = await (0,_accountClient__WEBPACK_IMPORTED_MODULE_2__.getDeployedAccountClientByAgentName)(bundlerUrl, options.agentData.agentName, account, {\n                            chain: chain,\n                            walletClient: viemWalletClient,\n                            publicClient: viemPublicClient,\n                        });\n                        const infoUserOpHash = await (0,_accountClient__WEBPACK_IMPORTED_MODULE_2__.sendSponsoredUserOperation)({\n                            bundlerUrl,\n                            chain: chain,\n                            accountClient: agentAccountClient,\n                            calls: infoCalls,\n                        });\n                        await (0,_accountClient__WEBPACK_IMPORTED_MODULE_2__.waitForUserOperationReceipt)({\n                            bundlerUrl,\n                            chain: chain,\n                            hash: infoUserOpHash,\n                        });\n                    }\n                }\n            }\n            else {\n                const errorPayload = await infoResponse.json().catch(() => ({}));\n                console.warn('Failed to prepare ENS metadata calls:', errorPayload);\n            }\n            console.log('Requested ENS record creation and metadata update for agent', options.agentData.agentName);\n        }\n        catch (ensError) {\n            console.warn('Failed to create ENS record for agent:', ensError);\n        }\n    }\n    else if (options.ensOptions?.enabled &&\n        options.ensOptions.orgName &&\n        (0,_server_lib_chainConfig__WEBPACK_IMPORTED_MODULE_1__.isL2)(chainId)) {\n        const rawOrg = options.ensOptions.orgName || '';\n        const rawAgent = options.agentData.agentName || '';\n        const cleanOrgName = rawOrg.replace(/\\.eth$/i, '').toLowerCase();\n        const orgPattern = cleanOrgName.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n        const cleanAgentName = rawAgent\n            .replace(new RegExp(`^${orgPattern}\\\\.`, 'i'), '')\n            .replace(/\\.eth$/i, '')\n            .trim()\n            .toLowerCase()\n            .replace(/\\s+/g, '-');\n        const agentUrl = options.agentData.agentUrl;\n        const agentDescription = options.agentData.description;\n        const agentImage = options.agentData.image;\n        // Prepare all necessary L2 ENS calls server-side, then send them as one user operation\n        const prepareResp = await fetch('/api/names/add-to-l2-org', {\n            method: 'POST',\n            headers: { 'Content-Type': 'application/json' },\n            body: JSON.stringify({\n                agentAddress: agentAccountClient.address,\n                orgName: cleanOrgName,\n                agentName: cleanAgentName,\n                agentUrl,\n                agentDescription,\n                agentImage,\n                chainId,\n            }),\n        });\n        if (!prepareResp.ok) {\n            const errorPayload = await prepareResp.json().catch(() => ({}));\n            console.warn('Failed to prepare L2 ENS calls:', errorPayload);\n        }\n        else {\n            const { calls: rawCalls } = await prepareResp.json();\n            const l2EnsCalls = (rawCalls || []).map((call) => ({\n                to: call.to,\n                data: call.data,\n                value: BigInt(call.value || '0'),\n            }));\n            if (l2EnsCalls.length > 0) {\n                for (const call of l2EnsCalls) {\n                    onStatusUpdate?.('MetaMask signature: create ENS subdomain / set ENS records');\n                    console.log('********************* send sponsored user operation for L2 ENS call');\n                    const userOpHash = await (0,_accountClient__WEBPACK_IMPORTED_MODULE_2__.sendSponsoredUserOperation)({\n                        bundlerUrl,\n                        chain,\n                        accountClient: agentAccountClient,\n                        calls: [call],\n                    });\n                    await (0,_accountClient__WEBPACK_IMPORTED_MODULE_2__.waitForUserOperationReceipt)({\n                        bundlerUrl,\n                        chain,\n                        hash: userOpHash,\n                    });\n                }\n            }\n        }\n        /*  TODO:  Need to resolve this to set ens url and description\n          onStatusUpdate?.('Set ENS metadata update...');\n          const infoResponse = await fetch('/api/names/set-l2-name-info', {\n            method: 'POST',\n            headers: { 'Content-Type': 'application/json' },\n            body: JSON.stringify({\n              agentAddress: agentAccountClient.address,\n              orgName: options.ensOptions.orgName,\n              agentName: options.agentData.agentName,\n              agentUrl: options.agentData.agentUrl,\n              agentDescription: options.agentData.description,\n              chainId,\n            }),\n          });\n    \n          if (!infoResponse.ok) {\n            const errorPayload = await infoResponse.json().catch(() => ({}));\n            console.warn('Failed to prepare L2 ENS calls:', errorPayload);\n          } else {\n            const { calls: rawCalls } = await infoResponse.json();\n            const l2EnsCalls = (rawCalls || []).map((call: any) => ({\n              to: call.to as `0x${string}`,\n              data: call.data as `0x${string}`,\n              value: BigInt(call.value || '0'),\n            }));\n            if (l2EnsCalls.length > 0) {\n              for (const call of l2EnsCalls) {\n                console.log('********************* send sponsored user operation for L2 ENS call');\n                const userOpHash = await sendSponsoredUserOperation({\n                  bundlerUrl,\n                  chain,\n                  accountClient: agentAccountClient,\n                  calls: [call],\n                });\n                await waitForUserOperationReceipt({\n                  bundlerUrl,\n                  chain,\n                  hash: userOpHash,\n                });\n              }\n            }\n          }\n            */\n    }\n    // 2.  Need to create the Agent Identity (NFT)\n    console.log('*********** createAgentWithWallet: creating agent identity...');\n    const finalAgentName = options.ensOptions?.enabled && options.ensOptions?.orgName\n        ? `${options.agentData.agentName}.${options.ensOptions?.orgName}.eth`\n        : options.agentData.agentName;\n    agentData.agentName = finalAgentName;\n    let data;\n    try {\n        data = await (0,_api_agents_client__WEBPACK_IMPORTED_MODULE_3__.createAgent)({\n            mode: 'smartAccount',\n            account: computedAddress,\n            agentName: agentData.agentName,\n            agentAccount: agentData.agentAccount,\n            agentCategory: agentData.agentCategory,\n            supportedTrust: agentData.supportedTrust,\n            description: agentData.description,\n            image: agentData.image,\n            agentUrl: agentData.agentUrl,\n            endpoints: agentData.endpoints,\n            chainId,\n        });\n    }\n    catch (error) {\n        throw new Error(error instanceof Error ? error.message : 'Failed to create agent');\n    }\n    if (data.mode !== 'smartAccount') {\n        throw new Error('Server returned an unexpected plan mode for SmartAccount creation');\n    }\n    if (data.bundlerUrl) {\n        bundlerUrl = data.bundlerUrl;\n    }\n    if (!Array.isArray(data.calls) || data.calls.length === 0) {\n        throw new Error('Agent creation response missing register calls');\n    }\n    // Construct Agent Identity with agentAccount Client\n    const createAgentIdentityCalls = data.calls.map((call) => ({\n        to: call.to,\n        data: call.data,\n        value: BigInt(call.value || '0'),\n    }));\n    // Send UserOperation via bundler\n    onStatusUpdate?.('MetaMask signature: register agent identity (ERC-8004)');\n    const userOpHash = await (0,_accountClient__WEBPACK_IMPORTED_MODULE_2__.sendSponsoredUserOperation)({\n        bundlerUrl,\n        chain: chain,\n        accountClient: agentAccountClient,\n        calls: createAgentIdentityCalls,\n    });\n    onStatusUpdate?.(`UserOperation sent! Hash: ${userOpHash}. Waiting for confirmation...`);\n    // Wait for receipt\n    const receipt = await (0,_accountClient__WEBPACK_IMPORTED_MODULE_2__.waitForUserOperationReceipt)({\n        bundlerUrl,\n        chain: chain,\n        hash: userOpHash,\n    });\n    // Extract agentId from receipt logs\n    let agentId;\n    try {\n        const extractResponse = await fetch('/api/agents/extract-agent-id', {\n            method: 'POST',\n            headers: { 'Content-Type': 'application/json' },\n            body: JSON.stringify({\n                receipt: JSON.parse(JSON.stringify(receipt, (_, value) => typeof value === 'bigint' ? value.toString() : value)),\n                chainId: chain.id,\n            }),\n        });\n        if (extractResponse.ok) {\n            const extractData = await extractResponse.json();\n            if (extractData?.agentId) {\n                agentId = extractData.agentId;\n            }\n        }\n        else {\n            const errorPayload = await extractResponse.json().catch(() => ({}));\n            console.warn('Failed to extract agentId via API:', errorPayload);\n        }\n    }\n    catch (error) {\n        console.warn('Unable to extract agentId via API:', error);\n    }\n    // Refresh GraphQL indexer\n    if (agentId) {\n        // After registration, set agentWallet on-chain BEFORE notifying the indexer.\n        try {\n            const identityRegistry = data.identityRegistry;\n            if (!identityRegistry) {\n                throw new Error('Missing identityRegistry in create-agent response');\n            }\n            const identityClient = new _agentic_trust_8004_ext_sdk__WEBPACK_IMPORTED_MODULE_0__.AIAgentIdentityClient({\n                publicClient: viemPublicClient,\n                walletClient: viemWalletClient,\n                identityRegistryAddress: identityRegistry,\n            });\n            const EIP712_DOMAIN_ABI = [\n                {\n                    type: 'function',\n                    name: 'eip712Domain',\n                    stateMutability: 'view',\n                    inputs: [],\n                    outputs: [\n                        { name: 'name', type: 'string' },\n                        { name: 'version', type: 'string' },\n                        { name: 'chainId', type: 'uint256' },\n                        { name: 'verifyingContract', type: 'address' },\n                        { name: 'salt', type: 'bytes32' },\n                        { name: 'extensions', type: 'uint256[]' },\n                    ],\n                },\n            ];\n            const domainRaw = (await viemPublicClient.readContract({\n                address: identityRegistry,\n                abi: EIP712_DOMAIN_ABI,\n                functionName: 'eip712Domain',\n                args: [],\n            }));\n            const domain = {\n                name: String(domainRaw?.name ?? domainRaw?.[0] ?? ''),\n                version: String(domainRaw?.version ?? domainRaw?.[1] ?? ''),\n                chainId: Number(domainRaw?.chainId ?? domainRaw?.[2] ?? chain.id),\n                verifyingContract: (domainRaw?.verifyingContract ?? domainRaw?.[3]),\n                salt: (domainRaw?.salt ?? domainRaw?.[4]),\n            };\n            const agentIdBigInt = BigInt(agentId);\n            const deadline = BigInt(Math.floor(Date.now() / 1000) + 60 * 60); // +1h\n            const newWallet = (0,viem__WEBPACK_IMPORTED_MODULE_9__.getAddress)(account);\n            onStatusUpdate?.('MetaMask signature: set agent wallet (IdentityRegistry)');\n            const signature = (await viemWalletClient.signTypedData({\n                account,\n                domain,\n                primaryType: 'SetAgentWallet',\n                types: {\n                    SetAgentWallet: [\n                        { name: 'agentId', type: 'uint256' },\n                        { name: 'newWallet', type: 'address' },\n                        { name: 'deadline', type: 'uint256' },\n                    ],\n                },\n                message: { agentId: agentIdBigInt, newWallet, deadline },\n            }));\n            const { calls } = await identityClient.prepareSetAgentWalletCalls(agentIdBigInt, newWallet, deadline, signature);\n            const call = calls[0];\n            if (!call)\n                throw new Error('prepareSetAgentWalletCalls returned no calls');\n            const setWalletUserOpHash = await (0,_accountClient__WEBPACK_IMPORTED_MODULE_2__.sendSponsoredUserOperation)({\n                bundlerUrl,\n                chain: chain,\n                accountClient: agentAccountClient,\n                calls: [{ to: call.to, data: call.data, value: 0n }],\n            });\n            await (0,_accountClient__WEBPACK_IMPORTED_MODULE_2__.waitForUserOperationReceipt)({\n                bundlerUrl,\n                chain: chain,\n                hash: setWalletUserOpHash,\n            });\n        }\n        catch (e) {\n            console.warn('[createAgentWithWalletAA] setAgentWallet failed (non-fatal):', e);\n        }\n        await refreshAgentInIndexer(agentId, chain.id);\n        // Finalize UAID now that we have a real on-chain agentId, and write it back by updating tokenUri.\n        try {\n            onStatusUpdate?.('Finalizing UAID and updating registration tokenUri...');\n            const uaidResp = await fetch('/api/agents/generate-uaid', {\n                method: 'POST',\n                headers: { 'Content-Type': 'application/json' },\n                body: JSON.stringify({\n                    agentAccount: agentData.agentAccount,\n                    chainId: chain.id,\n                    // Use did:ethr for uid (not ENS)\n                    uid: `did:ethr:${chain.id}:${agentData.agentAccount}`,\n                    proto: 'a2a',\n                    registry: 'erc-8004',\n                    domain: typeof agentData.agentUrl === 'string' && agentData.agentUrl.trim()\n                        ? (() => {\n                            try {\n                                return new URL(agentData.agentUrl).hostname;\n                            }\n                            catch {\n                                return undefined;\n                            }\n                        })()\n                        : undefined,\n                }),\n            });\n            if (uaidResp.ok) {\n                const uaidData = await uaidResp.json().catch(() => ({}));\n                const uaid = typeof uaidData?.uaid === 'string' && uaidData.uaid.trim() ? uaidData.uaid.trim() : null;\n                if (uaid) {\n                    const did8004 = `did:8004:${chain.id}:${agentId}`;\n                    const registrationUpdate = {\n                        type: 'https://eips.ethereum.org/EIPS/eip-8004#registration-v1',\n                        name: agentData.agentName,\n                        description: agentData.description,\n                        image: agentData.image,\n                        agentUrl: agentData.agentUrl,\n                        // Never include MCP endpoint in registration JSON updates.\n                        endpoints: Array.isArray(agentData.endpoints)\n                            ? agentData.endpoints.filter(e => e?.name !== 'MCP')\n                            : undefined,\n                        supportedTrust: agentData.supportedTrust,\n                        active: true,\n                        registeredBy: 'agentic-trust',\n                        registryNamespace: 'erc-8004',\n                        uaid,\n                        // Ensure agentId is written into the tokenUri JSON\n                        registrations: [\n                            {\n                                agentId: String(agentId),\n                                // agentRegistry is best-effort; server will also backfill if omitted\n                                agentRegistry: `eip155:${chain.id}:unknown`,\n                                registeredAt: new Date().toISOString(),\n                            },\n                        ],\n                    };\n                    await updateAgentRegistrationWithWallet({\n                        did8004,\n                        chain,\n                        accountClient: agentAccountClient,\n                        registration: registrationUpdate,\n                        onStatusUpdate,\n                    });\n                }\n                else {\n                    console.warn('[createAgentWithWalletAA] UAID endpoint returned no uaid value');\n                }\n            }\n            else {\n                const err = await uaidResp.json().catch(() => ({}));\n                console.warn('[createAgentWithWalletAA] UAID endpoint failed:', err);\n            }\n        }\n        catch (uaidErr) {\n            console.warn('[createAgentWithWalletAA] Failed to finalize UAID + registration update:', uaidErr);\n        }\n    }\n    else {\n        onStatusUpdate?.('Refreshing GraphQL indexer...');\n        console.log('UserOperation confirmed. Please refresh the agent list to see the new agent.');\n    }\n    return {\n        agentId,\n        txHash: userOpHash,\n        requiresClientSigning: true,\n    };\n}\nasync function createAgentWithWallet(options) {\n    const useAA = options.useAA ?? false;\n    if (useAA) {\n        return createAgentWithWalletAA(options);\n    }\n    return createAgentWithWalletEOA(options);\n}\nasync function updateAgentRegistrationWithWallet(options) {\n    const { did8004, chain, accountClient, registration, onStatusUpdate } = options;\n    const serialized = typeof registration === 'string' ? registration : JSON.stringify(registration, null, 2);\n    onStatusUpdate?.('Preparing agent registration update on server...');\n    console.info('........... registration: ', registration);\n    let prepared;\n    try {\n        prepared = await (0,_api_agents_client__WEBPACK_IMPORTED_MODULE_3__.updateAgentRegistration)({\n            did8004,\n            registration: serialized,\n            mode: 'smartAccount',\n        });\n    }\n    catch (error) {\n        throw new Error(error instanceof Error\n            ? error.message\n            : 'Failed to prepare registration update');\n    }\n    const bundlerUrl = prepared.bundlerUrl;\n    const rawCalls = Array.isArray(prepared.calls) ? prepared.calls : [];\n    if (!bundlerUrl || rawCalls.length === 0) {\n        throw new Error('Registration update response missing bundlerUrl or calls');\n    }\n    // Preflight authorization check to avoid opaque bundler simulation reverts (\"Not authorized\").\n    // The IdentityRegistry setAgentUri requires msg.sender to be owner or approved operator for the agentId.\n    try {\n        const identityRegistry = prepared.identityRegistry;\n        const rpcUrl = (0,_server_lib_chainConfig__WEBPACK_IMPORTED_MODULE_1__.getChainRpcUrl)(chain.id) || chain.rpcUrls?.default?.http?.[0];\n        if (identityRegistry && rpcUrl) {\n            const publicClient = (0,viem__WEBPACK_IMPORTED_MODULE_7__.createPublicClient)({\n                chain: chain,\n                transport: (0,viem__WEBPACK_IMPORTED_MODULE_8__.http)(rpcUrl),\n            });\n            const { agentId } = (0,_shared_did8004__WEBPACK_IMPORTED_MODULE_4__.parseDid8004)(did8004);\n            const tokenId = BigInt(agentId);\n            const sender = (0,viem__WEBPACK_IMPORTED_MODULE_9__.getAddress)(accountClient.address);\n            const ERC721_ABI = [\n                {\n                    type: 'function',\n                    name: 'ownerOf',\n                    stateMutability: 'view',\n                    inputs: [{ name: 'tokenId', type: 'uint256' }],\n                    outputs: [{ name: 'owner', type: 'address' }],\n                },\n                {\n                    type: 'function',\n                    name: 'getApproved',\n                    stateMutability: 'view',\n                    inputs: [{ name: 'tokenId', type: 'uint256' }],\n                    outputs: [{ name: 'operator', type: 'address' }],\n                },\n                {\n                    type: 'function',\n                    name: 'isApprovedForAll',\n                    stateMutability: 'view',\n                    inputs: [\n                        { name: 'owner', type: 'address' },\n                        { name: 'operator', type: 'address' },\n                    ],\n                    outputs: [{ name: 'approved', type: 'bool' }],\n                },\n            ];\n            const owner = (await publicClient.readContract({\n                address: identityRegistry,\n                abi: ERC721_ABI,\n                functionName: 'ownerOf',\n                args: [tokenId],\n            }));\n            // If owner is sender, OK.\n            const ownerNorm = (0,viem__WEBPACK_IMPORTED_MODULE_9__.getAddress)(owner);\n            if (ownerNorm !== sender) {\n                const approved = (await publicClient.readContract({\n                    address: identityRegistry,\n                    abi: ERC721_ABI,\n                    functionName: 'getApproved',\n                    args: [tokenId],\n                }));\n                const approvedNorm = approved ? (0,viem__WEBPACK_IMPORTED_MODULE_9__.getAddress)(approved) : '0x0000000000000000000000000000000000000000';\n                const approvedForAll = (await publicClient.readContract({\n                    address: identityRegistry,\n                    abi: ERC721_ABI,\n                    functionName: 'isApprovedForAll',\n                    args: [ownerNorm, sender],\n                }));\n                const isAuthorized = approvedNorm === sender || approvedForAll === true;\n                if (!isAuthorized) {\n                    throw new Error(`Not authorized to update agent registration. ` +\n                        `Agent NFT owner=${ownerNorm}, sender=${sender}. ` +\n                        `Grant approval (approve or setApprovalForAll) or use the owning account.`);\n                }\n            }\n        }\n    }\n    catch (preflightErr) {\n        // If we can definitively detect authorization mismatch, surface it.\n        const msg = preflightErr?.message || String(preflightErr);\n        if (msg.includes('Not authorized to update agent registration')) {\n            throw preflightErr;\n        }\n    }\n    const updateCalls = rawCalls.map((call) => ({\n        to: call.to,\n        data: call.data,\n        value: BigInt(call.value ?? '0'),\n    }));\n    console.info('updateCalls', updateCalls);\n    console.info('accountClient:', accountClient.address);\n    onStatusUpdate?.('Sending registration update via bundler...');\n    const userOpHash = await (0,_accountClient__WEBPACK_IMPORTED_MODULE_2__.sendSponsoredUserOperation)({\n        bundlerUrl,\n        chain: chain,\n        accountClient,\n        calls: updateCalls,\n    });\n    onStatusUpdate?.(`Registration update sent! UserOperation hash: ${userOpHash}. Waiting for confirmation...`);\n    const receipt = await (0,_accountClient__WEBPACK_IMPORTED_MODULE_2__.waitForUserOperationReceipt)({\n        bundlerUrl,\n        chain: chain,\n        hash: userOpHash,\n    });\n    console.info('........... receipt: ', receipt);\n    return {\n        txHash: userOpHash,\n        requiresClientSigning: true,\n    };\n}\nasync function giveFeedbackWithWallet(options) {\n    const { did8004, chain, score, feedback, feedbackAuth, clientAddress, tag1, tag2, feedbackUri, feedbackHash, skill, context, capability, ethereumProvider, onStatusUpdate, } = options;\n    onStatusUpdate?.('Preparing feedback submission on server...');\n    let prepared;\n    try {\n        const response = await fetch(`/api/agents/${encodeURIComponent(did8004)}/feedback`, {\n            method: 'POST',\n            headers: { 'Content-Type': 'application/json' },\n            body: JSON.stringify({\n                score,\n                feedback,\n                feedbackAuth,\n                clientAddress,\n                tag1,\n                tag2,\n                feedbackUri,\n                feedbackHash,\n                skill,\n                context,\n                capability,\n                mode: 'eoa',\n            }),\n        });\n        if (!response.ok) {\n            const errorData = await response.json().catch(() => ({}));\n            throw new Error(errorData.error || errorData.message || 'Failed to prepare feedback submission');\n        }\n        prepared = (await response.json());\n    }\n    catch (error) {\n        throw new Error(error instanceof Error\n            ? error.message\n            : 'Failed to prepare feedback submission');\n    }\n    if (!prepared.transaction) {\n        throw new Error('Feedback submission response missing transaction payload');\n    }\n    const txResult = await signAndSendTransaction({\n        transaction: prepared.transaction, // AgentPreparedTransactionPayload is compatible with PreparedTransaction\n        account: (clientAddress || '0x'),\n        chain,\n        ethereumProvider,\n        onStatusUpdate,\n    });\n    return {\n        txHash: txResult.hash,\n        requiresClientSigning: true,\n    };\n}\nasync function finalizeAssociationWithWallet(options) {\n    const { chain, submitterAccountClient, mode = 'smartAccount', ethereumProvider, account, requesterDid, initiatorAddress: initiatorAddressOverride, approverAddress, assocType, description, validAt, data, initiatorSignature, approverSignature, onStatusUpdate, } = options;\n    // Preflight: best-effort ERC-1271 signature validation to avoid opaque bundler \"reason: 0x\".\n    // This checks whether the initiator/approver smart accounts would accept the provided signatures\n    // for the association digest we are about to submit.\n    if (mode === 'smartAccount') {\n        if (!submitterAccountClient) {\n            throw new Error('smartAccount mode requires submitterAccountClient');\n        }\n        try {\n            const rpcUrl = (0,_server_lib_chainConfig__WEBPACK_IMPORTED_MODULE_1__.getChainRpcUrl)(chain.id) || chain.rpcUrls?.default?.http?.[0];\n            if (rpcUrl) {\n                const publicClient = (0,viem__WEBPACK_IMPORTED_MODULE_7__.createPublicClient)({\n                    chain: chain,\n                    transport: (0,viem__WEBPACK_IMPORTED_MODULE_8__.http)(rpcUrl),\n                });\n                // Resolve initiator address for digest computation.\n                // If caller supplied an override (from inbox payload), prefer it to avoid mismatches.\n                const initiatorFinal = initiatorAddressOverride\n                    ? (0,viem__WEBPACK_IMPORTED_MODULE_9__.getAddress)(initiatorAddressOverride)\n                    : null;\n                let initiatorResolved = initiatorFinal;\n                if (!initiatorResolved) {\n                    const initiatorResp = await fetch(`/api/agents/${encodeURIComponent(requesterDid)}`);\n                    const initiatorJson = initiatorResp.ok ? await initiatorResp.json().catch(() => ({})) : {};\n                    const initiatorAddrRaw = initiatorJson?.agentAccount || initiatorJson?.account;\n                    if (initiatorAddrRaw) {\n                        initiatorResolved = (0,viem__WEBPACK_IMPORTED_MODULE_9__.getAddress)(initiatorAddrRaw);\n                    }\n                }\n                if (!initiatorResolved) {\n                    throw new Error('Missing initiatorAddress for association preflight');\n                }\n                const approver = (0,viem__WEBPACK_IMPORTED_MODULE_9__.getAddress)(approverAddress);\n                // Recompute digest using the erc8092 scheme (same as packages/erc8092-sdk eip712Hash)\n                const { ethers } = await __webpack_require__.e(/*! import() */ \"vendor-chunks/ethers\").then(__webpack_require__.bind(__webpack_require__, /*! ethers */ \"(rsc)/../../node_modules/ethers/lib.esm/index.js\"));\n                const toMinimalBigEndianBytes = (n) => {\n                    if (n === 0n)\n                        return new Uint8Array([0]);\n                    let hex = n.toString(16);\n                    if (hex.length % 2)\n                        hex = `0${hex}`;\n                    return ethers.getBytes(`0x${hex}`);\n                };\n                const formatEvmV1 = (chainId, address) => {\n                    const addr = ethers.getAddress(address);\n                    const chainRef = toMinimalBigEndianBytes(BigInt(chainId));\n                    const head = ethers.getBytes('0x00010000');\n                    const out = ethers.concat([\n                        head,\n                        new Uint8Array([chainRef.length]),\n                        chainRef,\n                        new Uint8Array([20]),\n                        ethers.getBytes(addr),\n                    ]);\n                    return ethers.hexlify(out);\n                };\n                const initiatorInterop = formatEvmV1(chain.id, initiatorResolved);\n                const approverInterop = formatEvmV1(chain.id, approver);\n                const abiCoder = ethers.AbiCoder.defaultAbiCoder();\n                const DOMAIN_TYPEHASH = ethers.id('EIP712Domain(string name,string version)');\n                const NAME_HASH = ethers.id('AssociatedAccounts');\n                const VERSION_HASH = ethers.id('1');\n                const MESSAGE_TYPEHASH = ethers.id('AssociatedAccountRecord(bytes initiator,bytes approver,uint40 validAt,uint40 validUntil,bytes4 interfaceId,bytes data)');\n                const domainSeparator = ethers.keccak256(abiCoder.encode(['bytes32', 'bytes32', 'bytes32'], [DOMAIN_TYPEHASH, NAME_HASH, VERSION_HASH]));\n                const interfaceId = '0x00000000';\n                const validUntil = 0;\n                const hashStruct = ethers.keccak256(abiCoder.encode(['bytes32', 'bytes32', 'bytes32', 'uint40', 'uint40', 'bytes4', 'bytes32'], [\n                    MESSAGE_TYPEHASH,\n                    ethers.keccak256(initiatorInterop),\n                    ethers.keccak256(approverInterop),\n                    validAt,\n                    validUntil,\n                    interfaceId,\n                    ethers.keccak256(data),\n                ]));\n                const digest = ethers.keccak256(ethers.solidityPacked(['bytes2', 'bytes32', 'bytes32'], ['0x1901', domainSeparator, hashStruct]));\n                const ERC1271_MAGIC = '0x1626ba7e';\n                const ERC1271_ABI = [\n                    {\n                        type: 'function',\n                        name: 'isValidSignature',\n                        stateMutability: 'view',\n                        inputs: [\n                            { name: 'hash', type: 'bytes32' },\n                            { name: 'signature', type: 'bytes' },\n                        ],\n                        outputs: [{ name: 'magicValue', type: 'bytes4' }],\n                    },\n                ];\n                const checkSignature = async (account, sig) => {\n                    const code = await publicClient.getBytecode({ address: account });\n                    // EOA: verify with ecrecover.\n                    if (!code || code === '0x') {\n                        try {\n                            const recovered = ethers.recoverAddress(digest, sig);\n                            return {\n                                ok: recovered.toLowerCase() === account.toLowerCase(),\n                                method: 'ecrecover',\n                                recovered,\n                            };\n                        }\n                        catch (e) {\n                            return { ok: false, method: 'ecrecover', error: e?.message || String(e) };\n                        }\n                    }\n                    // Contract: verify with ERC-1271.\n                    try {\n                        const magic = (await publicClient.readContract({\n                            address: account,\n                            abi: ERC1271_ABI,\n                            functionName: 'isValidSignature',\n                            args: [digest, sig],\n                        }));\n                        return { ok: magic.toLowerCase() === ERC1271_MAGIC, method: 'erc1271', magic };\n                    }\n                    catch (e) {\n                        return { ok: false, method: 'erc1271', error: e?.message || String(e) };\n                    }\n                };\n                const initiatorCheck = await checkSignature(initiatorResolved, initiatorSignature);\n                if (!initiatorCheck.ok) {\n                    throw new Error(`Initiator signature check failed. initiator=${initiatorResolved} digest=${digest} method=${initiatorCheck.method}`);\n                }\n                const approverCheck = await checkSignature(approver, approverSignature);\n                if (!approverCheck.ok) {\n                    throw new Error(`Approver signature check failed. approver=${approver} digest=${digest} method=${approverCheck.method}`);\n                }\n                // Extra sanity: ensure we're submitting from the approver account we think we are.\n                const submitter = (0,viem__WEBPACK_IMPORTED_MODULE_9__.getAddress)(submitterAccountClient.address);\n                if (!(0,viem__WEBPACK_IMPORTED_MODULE_10__.isAddressEqual)(submitter, approver)) {\n                    console.warn('[finalizeAssociationWithWallet] submitterAccountClient.address does not match approverAddress', { submitter, approver });\n                }\n            }\n        }\n        catch (preflightErr) {\n            // If we can detect invalid signatures, surface it; otherwise continue to let bundler give more info.\n            // (This block is best-effort and should not block in environments without RPC.)\n            const msg = preflightErr?.message || String(preflightErr);\n            if (msg.includes('rejected signature') || msg.includes('ERC-1271')) {\n                throw preflightErr;\n            }\n        }\n    }\n    onStatusUpdate?.('Preparing association store transaction on server...');\n    let prepared;\n    const response = await fetch('/api/associate', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({\n            did8004: requesterDid,\n            initiatorAddress: initiatorAddressOverride,\n            approverAddress: (0,viem__WEBPACK_IMPORTED_MODULE_9__.getAddress)(approverAddress),\n            assocType,\n            description,\n            validAt,\n            data,\n            initiatorSignature,\n            approverSignature,\n            mode,\n        }),\n    });\n    if (!response.ok) {\n        const errorData = await response.json().catch(() => ({}));\n        throw new Error(errorData.error || errorData.message || 'Failed to prepare association store');\n    }\n    prepared = (await response.json());\n    if (mode === 'eoa') {\n        if (!prepared.transaction) {\n            throw new Error('Association store response missing transaction payload');\n        }\n        if (!account) {\n            throw new Error('EOA mode requires account (EOA sender address)');\n        }\n        const txResult = await signAndSendTransaction({\n            transaction: prepared.transaction,\n            account,\n            chain,\n            ethereumProvider,\n            onStatusUpdate,\n        });\n        return { txHash: txResult.hash, requiresClientSigning: true };\n    }\n    const bundlerUrl = prepared.bundlerUrl;\n    const rawCalls = Array.isArray(prepared.calls) ? prepared.calls : [];\n    if (!bundlerUrl || rawCalls.length === 0) {\n        throw new Error('Association store response missing bundlerUrl or calls');\n    }\n    if (!submitterAccountClient) {\n        throw new Error('smartAccount mode requires submitterAccountClient');\n    }\n    const calls = rawCalls.map((call) => ({\n        to: (0,viem__WEBPACK_IMPORTED_MODULE_9__.getAddress)(call.to),\n        data: call.data,\n        value: BigInt(call.value ?? '0'),\n    }));\n    onStatusUpdate?.('Submitting association via bundler...');\n    const userOpHash = await (0,_accountClient__WEBPACK_IMPORTED_MODULE_2__.sendSponsoredUserOperation)({\n        bundlerUrl,\n        chain: chain,\n        accountClient: submitterAccountClient,\n        calls,\n    });\n    await (0,_accountClient__WEBPACK_IMPORTED_MODULE_2__.waitForUserOperationReceipt)({\n        bundlerUrl,\n        chain: chain,\n        hash: userOpHash,\n    });\n    return { txHash: userOpHash, requiresClientSigning: true };\n}\nasync function requestNameValidationWithWallet(options) {\n    const { requesterDid, chain, requesterAccountClient, mode = 'smartAccount', ethereumProvider, account, requestUri, requestHash, onStatusUpdate, } = options;\n    onStatusUpdate?.('Preparing validation request on server...');\n    const validatorName = 'name-validator';\n    const chainIdFromDid = (() => {\n        const m = requesterDid.match(/^did:8004:(\\d+):/);\n        if (!m)\n            return undefined;\n        const parsed = Number(m[1]);\n        return Number.isFinite(parsed) ? parsed : undefined;\n    })();\n    async function resolveValidatorAddressByName(params) {\n        const urlParams = new URLSearchParams({\n            query: params.validatorName,\n            page: '1',\n            pageSize: '10',\n        });\n        const response = await fetch(`/api/agents/search?${urlParams.toString()}`);\n        if (!response.ok) {\n            throw new Error(`Failed to resolve validator \"${params.validatorName}\" via discovery (status ${response.status})`);\n        }\n        const data = (await response.json().catch(() => ({})));\n        const agents = Array.isArray(data?.agents) ? data.agents : [];\n        const normalizedName = params.validatorName.trim().toLowerCase();\n        const byExactName = agents.find((a) => {\n            const name = typeof a?.agentName === 'string' ? a.agentName.trim().toLowerCase() : '';\n            const chainIdOk = typeof params.chainId === 'number' ? Number(a?.chainId) === params.chainId : true;\n            const acctOk = typeof a?.agentAccount === 'string' && a.agentAccount.startsWith('0x');\n            return chainIdOk && acctOk && name === normalizedName;\n        });\n        const fallback = agents.find((a) => {\n            const chainIdOk = typeof params.chainId === 'number' ? Number(a?.chainId) === params.chainId : true;\n            const acctOk = typeof a?.agentAccount === 'string' && a.agentAccount.startsWith('0x');\n            return chainIdOk && acctOk;\n        });\n        const agentAccount = (byExactName?.agentAccount ?? fallback?.agentAccount);\n        if (!agentAccount) {\n            throw new Error(`Validator \"${params.validatorName}\" not found in discovery (chainId=${params.chainId ?? 'any'})`);\n        }\n        return (0,viem__WEBPACK_IMPORTED_MODULE_9__.getAddress)(agentAccount);\n    }\n    async function resolveValidatorAddress(params) {\n        try {\n            return await resolveValidatorAddressByName(params);\n        }\n        catch (_discoveryErr) {\n            const chainId = typeof params.chainId === 'number'\n                ? params.chainId\n                : typeof chain?.id === 'number'\n                    ? chain.id\n                    : undefined;\n            if (!chainId) {\n                throw _discoveryErr;\n            }\n            const resp = await fetch(`/api/validator-address?validatorName=${encodeURIComponent(params.validatorName)}&chainId=${encodeURIComponent(String(chainId))}`);\n            if (!resp.ok) {\n                const errData = await resp.json().catch(() => ({}));\n                const msg = errData?.error ||\n                    errData?.message ||\n                    `Failed to resolve validator \"${params.validatorName}\" via /api/validator-address (status ${resp.status})`;\n                throw new Error(msg);\n            }\n            const data = (await resp.json().catch(() => ({})));\n            const addr = typeof data?.validatorAddress === 'string' ? data.validatorAddress : '';\n            if (!addr || !addr.startsWith('0x')) {\n                throw new Error(`Validator \"${params.validatorName}\" address not returned by /api/validator-address`);\n            }\n            return (0,viem__WEBPACK_IMPORTED_MODULE_9__.getAddress)(addr);\n        }\n    }\n    let prepared;\n    try {\n        const requestBody = {\n            requestUri,\n            requestHash,\n            mode,\n        };\n        // Server requires validatorAddress; resolve validatorName -> address client-side if needed.\n        requestBody.validatorAddress =\n            (options.validatorAddress\n                ? (0,viem__WEBPACK_IMPORTED_MODULE_9__.getAddress)(options.validatorAddress)\n                : await resolveValidatorAddress({\n                    validatorName,\n                    chainId: chainIdFromDid,\n                }));\n        const response = await fetch(`/api/agents/${encodeURIComponent(requesterDid)}/validation-request`, {\n            method: 'POST',\n            headers: { 'Content-Type': 'application/json' },\n            body: JSON.stringify(requestBody),\n        });\n        if (!response.ok) {\n            const errorData = await response.json().catch(() => ({}));\n            throw new Error(errorData.error || errorData.message || 'Failed to prepare validation request');\n        }\n        prepared = (await response.json());\n    }\n    catch (error) {\n        throw new Error(error instanceof Error\n            ? error.message\n            : 'Failed to prepare validation request');\n    }\n    const bundlerUrl = prepared.bundlerUrl;\n    const rawCalls = Array.isArray(prepared.calls) ? prepared.calls : [];\n    // EOA mode: server returns a transaction payload.\n    if (mode === 'eoa') {\n        if (!prepared.transaction) {\n            throw new Error('Validation request response missing transaction payload');\n        }\n        if (!account) {\n            throw new Error('EOA mode requires account (EOA sender address)');\n        }\n        const txResult = await signAndSendTransaction({\n            transaction: prepared.transaction,\n            account,\n            chain,\n            ethereumProvider,\n            onStatusUpdate,\n        });\n        const validatorAddress = prepared.metadata?.validatorAddress ||\n            (options.validatorAddress ? (0,viem__WEBPACK_IMPORTED_MODULE_9__.getAddress)(options.validatorAddress) : '') ||\n            '';\n        const finalRequestHash = prepared.metadata?.requestHash || '';\n        return {\n            txHash: txResult.hash,\n            requiresClientSigning: true,\n            validatorAddress,\n            requestHash: finalRequestHash,\n        };\n    }\n    if (!bundlerUrl || rawCalls.length === 0) {\n        throw new Error('Validation request response missing bundlerUrl or calls');\n    }\n    const validationCalls = rawCalls.map((call) => ({\n        to: call.to,\n        data: call.data,\n        value: BigInt(call.value ?? '0'),\n    }));\n    onStatusUpdate?.('Sending validation request via bundler...');\n    const userOpHash = await (0,_accountClient__WEBPACK_IMPORTED_MODULE_2__.sendSponsoredUserOperation)({\n        bundlerUrl,\n        chain: chain,\n        accountClient: requesterAccountClient,\n        calls: validationCalls,\n    });\n    onStatusUpdate?.(`Validation request sent! UserOperation hash: ${userOpHash}. Waiting for confirmation...`);\n    const receipt = await (0,_accountClient__WEBPACK_IMPORTED_MODULE_2__.waitForUserOperationReceipt)({\n        bundlerUrl,\n        chain: chain,\n        hash: userOpHash,\n    });\n    const validatorAddress = prepared.metadata?.validatorAddress ||\n        (options.validatorAddress ? (0,viem__WEBPACK_IMPORTED_MODULE_9__.getAddress)(options.validatorAddress) : '') ||\n        '';\n    const finalRequestHash = prepared.metadata?.requestHash || '';\n    return {\n        txHash: userOpHash,\n        requiresClientSigning: true,\n        validatorAddress,\n        requestHash: finalRequestHash,\n    };\n}\nasync function requestAccountValidationWithWallet(options) {\n    const { requesterDid, chain, requesterAccountClient, mode = 'smartAccount', ethereumProvider, account, requestUri, requestHash, onStatusUpdate, } = options;\n    onStatusUpdate?.('Preparing validation request on server...');\n    const validatorName = 'account-validator';\n    const chainIdFromDid = (() => {\n        const m = requesterDid.match(/^did:8004:(\\d+):/);\n        if (!m)\n            return undefined;\n        const parsed = Number(m[1]);\n        return Number.isFinite(parsed) ? parsed : undefined;\n    })();\n    async function resolveValidatorAddressByName(params) {\n        const urlParams = new URLSearchParams({\n            query: params.validatorName,\n            page: '1',\n            pageSize: '10',\n        });\n        const response = await fetch(`/api/agents/search?${urlParams.toString()}`);\n        if (!response.ok) {\n            throw new Error(`Failed to resolve validator \"${params.validatorName}\" via discovery (status ${response.status})`);\n        }\n        const data = (await response.json().catch(() => ({})));\n        const agents = Array.isArray(data?.agents) ? data.agents : [];\n        const normalizedName = params.validatorName.trim().toLowerCase();\n        const byExactName = agents.find((a) => {\n            const name = typeof a?.agentName === 'string' ? a.agentName.trim().toLowerCase() : '';\n            const chainIdOk = typeof params.chainId === 'number' ? Number(a?.chainId) === params.chainId : true;\n            const acctOk = typeof a?.agentAccount === 'string' && a.agentAccount.startsWith('0x');\n            return chainIdOk && acctOk && name === normalizedName;\n        });\n        const fallback = agents.find((a) => {\n            const chainIdOk = typeof params.chainId === 'number' ? Number(a?.chainId) === params.chainId : true;\n            const acctOk = typeof a?.agentAccount === 'string' && a.agentAccount.startsWith('0x');\n            return chainIdOk && acctOk;\n        });\n        const agentAccount = (byExactName?.agentAccount ?? fallback?.agentAccount);\n        if (!agentAccount) {\n            throw new Error(`Validator \"${params.validatorName}\" not found in discovery (chainId=${params.chainId ?? 'any'})`);\n        }\n        return (0,viem__WEBPACK_IMPORTED_MODULE_9__.getAddress)(agentAccount);\n    }\n    async function resolveValidatorAddress(params) {\n        try {\n            return await resolveValidatorAddressByName(params);\n        }\n        catch (_discoveryErr) {\n            const chainId = typeof params.chainId === 'number'\n                ? params.chainId\n                : typeof chain?.id === 'number'\n                    ? chain.id\n                    : undefined;\n            if (!chainId) {\n                throw _discoveryErr;\n            }\n            const resp = await fetch(`/api/validator-address?validatorName=${encodeURIComponent(params.validatorName)}&chainId=${encodeURIComponent(String(chainId))}`);\n            if (!resp.ok) {\n                const errData = await resp.json().catch(() => ({}));\n                const msg = errData?.error ||\n                    errData?.message ||\n                    `Failed to resolve validator \"${params.validatorName}\" via /api/validator-address (status ${resp.status})`;\n                throw new Error(msg);\n            }\n            const data = (await resp.json().catch(() => ({})));\n            const addr = typeof data?.validatorAddress === 'string' ? data.validatorAddress : '';\n            if (!addr || !addr.startsWith('0x')) {\n                throw new Error(`Validator \"${params.validatorName}\" address not returned by /api/validator-address`);\n            }\n            return (0,viem__WEBPACK_IMPORTED_MODULE_9__.getAddress)(addr);\n        }\n    }\n    let prepared;\n    try {\n        const requestBody = {\n            requestUri,\n            requestHash,\n            mode: 'smartAccount',\n        };\n        // Server requires validatorAddress; resolve validatorName -> address client-side if needed.\n        requestBody.validatorAddress =\n            (options.validatorAddress\n                ? (0,viem__WEBPACK_IMPORTED_MODULE_9__.getAddress)(options.validatorAddress)\n                : await resolveValidatorAddress({\n                    validatorName,\n                    chainId: chainIdFromDid,\n                }));\n        const response = await fetch(`/api/agents/${encodeURIComponent(requesterDid)}/validation-request`, {\n            method: 'POST',\n            headers: { 'Content-Type': 'application/json' },\n            body: JSON.stringify(requestBody),\n        });\n        if (!response.ok) {\n            const errorData = await response.json().catch(() => ({}));\n            throw new Error(errorData.error || errorData.message || 'Failed to prepare validation request');\n        }\n        prepared = (await response.json());\n    }\n    catch (error) {\n        throw new Error(error instanceof Error\n            ? error.message\n            : 'Failed to prepare validation request');\n    }\n    const bundlerUrl = prepared.bundlerUrl;\n    const rawCalls = Array.isArray(prepared.calls) ? prepared.calls : [];\n    if (mode === 'eoa') {\n        if (!prepared.transaction) {\n            throw new Error('Validation request response missing transaction payload');\n        }\n        if (!account) {\n            throw new Error('EOA mode requires account (EOA sender address)');\n        }\n        const txResult = await signAndSendTransaction({\n            transaction: prepared.transaction,\n            account,\n            chain,\n            ethereumProvider,\n            onStatusUpdate,\n        });\n        const validatorAddress = prepared.metadata?.validatorAddress ||\n            (options.validatorAddress ? (0,viem__WEBPACK_IMPORTED_MODULE_9__.getAddress)(options.validatorAddress) : '') ||\n            '';\n        const finalRequestHash = prepared.metadata?.requestHash || '';\n        return {\n            txHash: txResult.hash,\n            requiresClientSigning: true,\n            validatorAddress,\n            requestHash: finalRequestHash,\n        };\n    }\n    if (!bundlerUrl || rawCalls.length === 0) {\n        throw new Error('Validation request response missing bundlerUrl or calls');\n    }\n    const validationCalls = rawCalls.map((call) => ({\n        to: call.to,\n        data: call.data,\n        value: BigInt(call.value ?? '0'),\n    }));\n    onStatusUpdate?.('Sending validation request via bundler...');\n    const userOpHash = await (0,_accountClient__WEBPACK_IMPORTED_MODULE_2__.sendSponsoredUserOperation)({\n        bundlerUrl,\n        chain: chain,\n        accountClient: requesterAccountClient,\n        calls: validationCalls,\n    });\n    onStatusUpdate?.(`Validation request sent! UserOperation hash: ${userOpHash}. Waiting for confirmation...`);\n    const receipt = await (0,_accountClient__WEBPACK_IMPORTED_MODULE_2__.waitForUserOperationReceipt)({\n        bundlerUrl,\n        chain: chain,\n        hash: userOpHash,\n    });\n    const validatorAddress = prepared.metadata?.validatorAddress ||\n        (options.validatorAddress ? (0,viem__WEBPACK_IMPORTED_MODULE_9__.getAddress)(options.validatorAddress) : '') ||\n        '';\n    const finalRequestHash = prepared.metadata?.requestHash || '';\n    return {\n        txHash: userOpHash,\n        requiresClientSigning: true,\n        validatorAddress,\n        requestHash: finalRequestHash,\n    };\n}\nasync function requestAppValidationWithWallet(options) {\n    const { requesterDid, chain, requesterAccountClient, mode = 'smartAccount', ethereumProvider, account, requestUri, requestHash, onStatusUpdate, } = options;\n    onStatusUpdate?.('Preparing validation request on server...');\n    const validatorName = 'app-validator';\n    const chainIdFromDid = (() => {\n        const m = requesterDid.match(/^did:8004:(\\d+):/);\n        if (!m)\n            return undefined;\n        const parsed = Number(m[1]);\n        return Number.isFinite(parsed) ? parsed : undefined;\n    })();\n    async function resolveValidatorAddressByName(params) {\n        const urlParams = new URLSearchParams({\n            query: params.validatorName,\n            page: '1',\n            pageSize: '10',\n        });\n        const response = await fetch(`/api/agents/search?${urlParams.toString()}`);\n        if (!response.ok) {\n            throw new Error(`Failed to resolve validator \"${params.validatorName}\" via discovery (status ${response.status})`);\n        }\n        const data = (await response.json().catch(() => ({})));\n        const agents = Array.isArray(data?.agents) ? data.agents : [];\n        const normalizedName = params.validatorName.trim().toLowerCase();\n        const byExactName = agents.find((a) => {\n            const name = typeof a?.agentName === 'string' ? a.agentName.trim().toLowerCase() : '';\n            const chainIdOk = typeof params.chainId === 'number' ? Number(a?.chainId) === params.chainId : true;\n            const acctOk = typeof a?.agentAccount === 'string' && a.agentAccount.startsWith('0x');\n            return chainIdOk && acctOk && name === normalizedName;\n        });\n        const fallback = agents.find((a) => {\n            const chainIdOk = typeof params.chainId === 'number' ? Number(a?.chainId) === params.chainId : true;\n            const acctOk = typeof a?.agentAccount === 'string' && a.agentAccount.startsWith('0x');\n            return chainIdOk && acctOk;\n        });\n        const agentAccount = (byExactName?.agentAccount ?? fallback?.agentAccount);\n        if (!agentAccount) {\n            throw new Error(`Validator \"${params.validatorName}\" not found in discovery (chainId=${params.chainId ?? 'any'})`);\n        }\n        return (0,viem__WEBPACK_IMPORTED_MODULE_9__.getAddress)(agentAccount);\n    }\n    async function resolveValidatorAddress(params) {\n        try {\n            return await resolveValidatorAddressByName(params);\n        }\n        catch (_discoveryErr) {\n            const chainId = typeof params.chainId === 'number'\n                ? params.chainId\n                : typeof chain?.id === 'number'\n                    ? chain.id\n                    : undefined;\n            if (!chainId) {\n                throw _discoveryErr;\n            }\n            const resp = await fetch(`/api/validator-address?validatorName=${encodeURIComponent(params.validatorName)}&chainId=${encodeURIComponent(String(chainId))}`);\n            if (!resp.ok) {\n                const errData = await resp.json().catch(() => ({}));\n                const msg = errData?.error ||\n                    errData?.message ||\n                    `Failed to resolve validator \"${params.validatorName}\" via /api/validator-address (status ${resp.status})`;\n                throw new Error(msg);\n            }\n            const data = (await resp.json().catch(() => ({})));\n            const addr = typeof data?.validatorAddress === 'string' ? data.validatorAddress : '';\n            if (!addr || !addr.startsWith('0x')) {\n                throw new Error(`Validator \"${params.validatorName}\" address not returned by /api/validator-address`);\n            }\n            return (0,viem__WEBPACK_IMPORTED_MODULE_9__.getAddress)(addr);\n        }\n    }\n    let prepared;\n    try {\n        const requestBody = {\n            requestUri,\n            requestHash,\n            mode,\n        };\n        requestBody.validatorAddress =\n            (options.validatorAddress\n                ? (0,viem__WEBPACK_IMPORTED_MODULE_9__.getAddress)(options.validatorAddress)\n                : await resolveValidatorAddress({\n                    validatorName,\n                    chainId: chainIdFromDid,\n                }));\n        const response = await fetch(`/api/agents/${encodeURIComponent(requesterDid)}/validation-request`, {\n            method: 'POST',\n            headers: { 'Content-Type': 'application/json' },\n            body: JSON.stringify(requestBody),\n        });\n        if (!response.ok) {\n            const errorData = await response.json().catch(() => ({}));\n            throw new Error(errorData.error || errorData.message || 'Failed to prepare validation request');\n        }\n        prepared = (await response.json());\n    }\n    catch (error) {\n        throw new Error(error instanceof Error\n            ? error.message\n            : 'Failed to prepare validation request');\n    }\n    const bundlerUrl = prepared.bundlerUrl;\n    const rawCalls = Array.isArray(prepared.calls) ? prepared.calls : [];\n    if (mode === 'eoa') {\n        if (!prepared.transaction) {\n            throw new Error('Validation request response missing transaction payload');\n        }\n        if (!account) {\n            throw new Error('EOA mode requires account (EOA sender address)');\n        }\n        const txResult = await signAndSendTransaction({\n            transaction: prepared.transaction,\n            account,\n            chain,\n            ethereumProvider,\n            onStatusUpdate,\n        });\n        const validatorAddress = prepared.metadata?.validatorAddress ||\n            (options.validatorAddress ? (0,viem__WEBPACK_IMPORTED_MODULE_9__.getAddress)(options.validatorAddress) : '') ||\n            '';\n        const finalRequestHash = prepared.metadata?.requestHash || '';\n        return {\n            txHash: txResult.hash,\n            requiresClientSigning: true,\n            validatorAddress,\n            requestHash: finalRequestHash,\n        };\n    }\n    if (!bundlerUrl || rawCalls.length === 0) {\n        throw new Error('Validation request response missing bundlerUrl or calls');\n    }\n    const validationCalls = rawCalls.map((call) => ({\n        to: call.to,\n        data: call.data,\n        value: BigInt(call.value ?? '0'),\n    }));\n    onStatusUpdate?.('Sending validation request via bundler...');\n    const userOpHash = await (0,_accountClient__WEBPACK_IMPORTED_MODULE_2__.sendSponsoredUserOperation)({\n        bundlerUrl,\n        chain: chain,\n        accountClient: requesterAccountClient,\n        calls: validationCalls,\n    });\n    onStatusUpdate?.(`Validation request sent! UserOperation hash: ${userOpHash}. Waiting for confirmation...`);\n    const receipt = await (0,_accountClient__WEBPACK_IMPORTED_MODULE_2__.waitForUserOperationReceipt)({\n        bundlerUrl,\n        chain: chain,\n        hash: userOpHash,\n    });\n    const validatorAddress = prepared.metadata?.validatorAddress ||\n        (options.validatorAddress ? (0,viem__WEBPACK_IMPORTED_MODULE_9__.getAddress)(options.validatorAddress) : '') ||\n        '';\n    const finalRequestHash = prepared.metadata?.requestHash || '';\n    return {\n        txHash: userOpHash,\n        requiresClientSigning: true,\n        validatorAddress,\n        requestHash: finalRequestHash,\n    };\n}\nasync function requestAIDValidationWithWallet(options) {\n    const { requesterDid, chain, requesterAccountClient, mode = 'smartAccount', ethereumProvider, account, requestUri, requestHash, onStatusUpdate, } = options;\n    onStatusUpdate?.('Preparing validation request on server...');\n    const validatorName = 'aid-validator';\n    const chainIdFromDid = (() => {\n        const m = requesterDid.match(/^did:8004:(\\d+):/);\n        if (!m)\n            return undefined;\n        const parsed = Number(m[1]);\n        return Number.isFinite(parsed) ? parsed : undefined;\n    })();\n    async function resolveValidatorAddressByName(params) {\n        const urlParams = new URLSearchParams({\n            query: params.validatorName,\n            page: '1',\n            pageSize: '10',\n        });\n        const response = await fetch(`/api/agents/search?${urlParams.toString()}`);\n        if (!response.ok) {\n            throw new Error(`Failed to resolve validator \"${params.validatorName}\" via discovery (status ${response.status})`);\n        }\n        const data = (await response.json().catch(() => ({})));\n        const agents = Array.isArray(data?.agents) ? data.agents : [];\n        const normalizedName = params.validatorName.trim().toLowerCase();\n        const byExactName = agents.find((a) => {\n            const name = typeof a?.agentName === 'string' ? a.agentName.trim().toLowerCase() : '';\n            const chainIdOk = typeof params.chainId === 'number' ? Number(a?.chainId) === params.chainId : true;\n            const acctOk = typeof a?.agentAccount === 'string' && a.agentAccount.startsWith('0x');\n            return chainIdOk && acctOk && name === normalizedName;\n        });\n        const fallback = agents.find((a) => {\n            const chainIdOk = typeof params.chainId === 'number' ? Number(a?.chainId) === params.chainId : true;\n            const acctOk = typeof a?.agentAccount === 'string' && a.agentAccount.startsWith('0x');\n            return chainIdOk && acctOk;\n        });\n        const agentAccount = (byExactName?.agentAccount ?? fallback?.agentAccount);\n        if (!agentAccount) {\n            throw new Error(`Validator \"${params.validatorName}\" not found in discovery (chainId=${params.chainId ?? 'any'})`);\n        }\n        return (0,viem__WEBPACK_IMPORTED_MODULE_9__.getAddress)(agentAccount);\n    }\n    async function resolveValidatorAddress(params) {\n        try {\n            return await resolveValidatorAddressByName(params);\n        }\n        catch (_discoveryErr) {\n            const chainId = typeof params.chainId === 'number'\n                ? params.chainId\n                : typeof chain?.id === 'number'\n                    ? chain.id\n                    : undefined;\n            if (!chainId) {\n                throw _discoveryErr;\n            }\n            const resp = await fetch(`/api/validator-address?validatorName=${encodeURIComponent(params.validatorName)}&chainId=${encodeURIComponent(String(chainId))}`);\n            if (!resp.ok) {\n                const errData = await resp.json().catch(() => ({}));\n                const msg = errData?.error ||\n                    errData?.message ||\n                    `Failed to resolve validator \"${params.validatorName}\" via /api/validator-address (status ${resp.status})`;\n                throw new Error(msg);\n            }\n            const data = (await resp.json().catch(() => ({})));\n            const addr = typeof data?.validatorAddress === 'string' ? data.validatorAddress : '';\n            if (!addr || !addr.startsWith('0x')) {\n                throw new Error(`Validator \"${params.validatorName}\" address not returned by /api/validator-address`);\n            }\n            return (0,viem__WEBPACK_IMPORTED_MODULE_9__.getAddress)(addr);\n        }\n    }\n    let prepared;\n    try {\n        const requestBody = {\n            requestUri,\n            requestHash,\n            mode,\n        };\n        requestBody.validatorAddress =\n            (options.validatorAddress\n                ? (0,viem__WEBPACK_IMPORTED_MODULE_9__.getAddress)(options.validatorAddress)\n                : await resolveValidatorAddress({\n                    validatorName,\n                    chainId: chainIdFromDid,\n                }));\n        const response = await fetch(`/api/agents/${encodeURIComponent(requesterDid)}/validation-request`, {\n            method: 'POST',\n            headers: { 'Content-Type': 'application/json' },\n            body: JSON.stringify(requestBody),\n        });\n        if (!response.ok) {\n            const errorData = await response.json().catch(() => ({}));\n            throw new Error(errorData.error || errorData.message || 'Failed to prepare validation request');\n        }\n        prepared = (await response.json());\n    }\n    catch (error) {\n        throw new Error(error instanceof Error\n            ? error.message\n            : 'Failed to prepare validation request');\n    }\n    const bundlerUrl = prepared.bundlerUrl;\n    const rawCalls = Array.isArray(prepared.calls) ? prepared.calls : [];\n    if (mode === 'eoa') {\n        if (!prepared.transaction) {\n            throw new Error('Validation request response missing transaction payload');\n        }\n        if (!account) {\n            throw new Error('EOA mode requires account (EOA sender address)');\n        }\n        const txResult = await signAndSendTransaction({\n            transaction: prepared.transaction,\n            account,\n            chain,\n            ethereumProvider,\n            onStatusUpdate,\n        });\n        const validatorAddress = prepared.metadata?.validatorAddress ||\n            (options.validatorAddress ? (0,viem__WEBPACK_IMPORTED_MODULE_9__.getAddress)(options.validatorAddress) : '') ||\n            '';\n        const finalRequestHash = prepared.metadata?.requestHash || '';\n        return {\n            txHash: txResult.hash,\n            requiresClientSigning: true,\n            validatorAddress,\n            requestHash: finalRequestHash,\n        };\n    }\n    if (!bundlerUrl || rawCalls.length === 0) {\n        throw new Error('Validation request response missing bundlerUrl or calls');\n    }\n    const validationCalls = rawCalls.map((call) => ({\n        to: call.to,\n        data: call.data,\n        value: BigInt(call.value ?? '0'),\n    }));\n    onStatusUpdate?.('Sending validation request via bundler...');\n    const userOpHash = await (0,_accountClient__WEBPACK_IMPORTED_MODULE_2__.sendSponsoredUserOperation)({\n        bundlerUrl,\n        chain: chain,\n        accountClient: requesterAccountClient,\n        calls: validationCalls,\n    });\n    onStatusUpdate?.(`Validation request sent! UserOperation hash: ${userOpHash}. Waiting for confirmation...`);\n    const receipt = await (0,_accountClient__WEBPACK_IMPORTED_MODULE_2__.waitForUserOperationReceipt)({\n        bundlerUrl,\n        chain: chain,\n        hash: userOpHash,\n    });\n    const validatorAddress = prepared.metadata?.validatorAddress ||\n        (options.validatorAddress ? (0,viem__WEBPACK_IMPORTED_MODULE_9__.getAddress)(options.validatorAddress) : '') ||\n        '';\n    const finalRequestHash = prepared.metadata?.requestHash || '';\n    return {\n        txHash: userOpHash,\n        requiresClientSigning: true,\n        validatorAddress,\n        requestHash: finalRequestHash,\n    };\n}\n//# sourceMappingURL=walletSigning.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BhZ2VudGljLXRydXN0L2NvcmUvZGlzdC9jbGllbnQvd2FsbGV0U2lnbmluZy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNtRjtBQUN2QztBQUN3QjtBQUNpSDtBQUNyRDtBQUNlO0FBQzlGO0FBQzRMO0FBQzdPO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0EsV0FBVyxxRUFBZ0I7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCx3QkFBd0I7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsa0JBQWtCO0FBQ3pDLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsZ0JBQWdCO0FBQ3ZDLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IscUVBQVk7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Qsa0JBQWtCLHVFQUFjO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxtQkFBbUIsZ0JBQWdCO0FBQ25DLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsWUFBWSxpR0FBaUc7QUFDN0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBLHlCQUF5Qix3REFBa0I7QUFDM0M7QUFDQTtBQUNBLG1CQUFtQiw0Q0FBTTtBQUN6QixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix3REFBa0I7QUFDekM7QUFDQSxpQ0FBaUMsMENBQUksZ0JBQWdCLDRDQUFNO0FBQzNELEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsbUNBQW1DO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxTQUFTLHVDQUF1QyxTQUFTO0FBQ2pIO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QseUJBQXlCO0FBQzdFO0FBQ0Esa0VBQWtFLHdCQUF3QixhQUFhLFNBQVM7QUFDaEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxzQkFBc0IsUUFBUSx3T0FBYztBQUM1RSwrREFBK0QsZ0NBQWdDLFFBQVEsZUFBZTtBQUN0SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELG1CQUFtQjtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLHNCQUFzQixRQUFRLHdPQUFjO0FBQ2hGLG1FQUFtRSxnQ0FBZ0MsUUFBUSxlQUFlO0FBQzFIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0Msc0JBQXNCLFFBQVEsd09BQWM7QUFDaEY7QUFDQSx1RUFBdUUsZ0NBQWdDO0FBQ3ZHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlGQUF5RixhQUFhLElBQUksSUFBSTtBQUM5RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRCw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRkFBb0Y7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDBDQUEwQztBQUN0RTtBQUNBO0FBQ0EseUNBQXlDLGtDQUFrQztBQUMzRTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQSxrREFBa0QsMkNBQTJDO0FBQzdGO0FBQ0EsMERBQTBELG1EQUFtRDtBQUM3Ryw4Q0FBOEMsd0RBQXdEO0FBQ3RHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELEtBQUs7QUFDMUQ7QUFDQSxpRUFBaUUsTUFBTTtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0Msa0JBQWtCLEdBQUcsUUFBUTtBQUM1RSx1REFBdUQsSUFBSTtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLG1DQUFtQztBQUNuQyxTQUFTO0FBQ1Q7QUFDQTtBQUNBLG9EQUFvRCxTQUFTLHNCQUFzQixpQkFBaUIsRUFBRSxvQkFBb0I7QUFDMUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxTQUFTO0FBQ3REO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxTQUFTO0FBQ3REO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxTQUFTO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCx3QkFBd0I7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDhJQUE4STtBQUMxSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QiwrREFBdUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHFFQUFZO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLHdEQUFrQjtBQUN2RDtBQUNBO0FBQ0EsMkJBQTJCLDRDQUFNO0FBQ2pDLGFBQWE7QUFDYixxQ0FBcUMsd0RBQWtCO0FBQ3ZEO0FBQ0EsMkJBQTJCLDRDQUFNO0FBQ2pDLGFBQWE7QUFDYix1Q0FBdUMsOEVBQXFCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiw4QkFBOEI7QUFDeEQsMEJBQTBCLGlDQUFpQztBQUMzRCwwQkFBMEIsa0NBQWtDO0FBQzVELDBCQUEwQiw0Q0FBNEM7QUFDdEUsMEJBQTBCLCtCQUErQjtBQUN6RCwwQkFBMEIsdUNBQXVDO0FBQ2pFO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFO0FBQzlFLDhCQUE4QixnREFBVTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixrQ0FBa0M7QUFDNUQsMEJBQTBCLG9DQUFvQztBQUM5RCwwQkFBMEIsbUNBQW1DO0FBQzdEO0FBQ0EsaUJBQWlCO0FBQ2pCLDJCQUEyQiw2Q0FBNkM7QUFDeEUsYUFBYTtBQUNiLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksMEJBQTBCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHdCQUF3QjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSw2SUFBNkk7QUFDeko7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsNERBQU87QUFDM0I7QUFDQTtBQUNBLG9CQUFvQixnRUFBVztBQUMvQjtBQUNBO0FBQ0Esb0JBQW9CLG9FQUFlO0FBQ25DO0FBQ0E7QUFDQSxvQkFBb0IsNERBQU87QUFDM0IsNENBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHdEQUFrQjtBQUMvQztBQUNBO0FBQ0EsbUJBQW1CLDRDQUFNO0FBQ3pCLEtBQUs7QUFDTCw2QkFBNkIsd0RBQWtCO0FBQy9DO0FBQ0EsbUJBQW1CLDRDQUFNO0FBQ3pCLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDJFQUFrQjtBQUN2QyxtQ0FBbUMsbUZBQW1DO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxnQkFBZ0IsYUFBYSwrQkFBK0I7QUFDckg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsNkRBQUk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLHlFQUFnQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQywyREFBMkQsWUFBWSxZQUFZO0FBQ3pIO0FBQ0E7QUFDQSwyQkFBMkIsb0NBQW9DO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQSxvRUFBb0U7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLDJEQUEyRCxZQUFZLGFBQWE7QUFDMUg7QUFDQTtBQUNBLDJCQUEyQixvQ0FBb0M7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsbUZBQW1DO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixxREFBcUQsMEVBQTBCO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLDhCQUE4QiwyRUFBMkI7QUFDekQ7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSw2REFBSTtBQUNaO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRDtBQUNBLG9DQUFvQyxXQUFXO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLG9DQUFvQztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBLHlFQUF5RTtBQUN6RTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLDBFQUEwQjtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQiwwQkFBMEIsMkVBQTJCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixvQ0FBb0M7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYO0FBQ0E7QUFDQSwwRUFBMEU7QUFDMUU7QUFDQSxZQUFZO0FBQ1osb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBLGtDQUFrQyxPQUFPO0FBQ3pDLHNDQUFzQyxPQUFPO0FBQzdDO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsNEJBQTRCLEdBQUcsNEJBQTRCO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLCtEQUF1QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsNkJBQTZCLDBFQUEwQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxrREFBa0QsV0FBVztBQUM3RDtBQUNBLDBCQUEwQiwyRUFBMkI7QUFDckQ7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsb0NBQW9DO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkU7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qyw4RUFBcUI7QUFDNUQ7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDhCQUE4QjtBQUN4RCwwQkFBMEIsaUNBQWlDO0FBQzNELDBCQUEwQixrQ0FBa0M7QUFDNUQsMEJBQTBCLDRDQUE0QztBQUN0RSwwQkFBMEIsK0JBQStCO0FBQ3pELDBCQUEwQix1Q0FBdUM7QUFDakU7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEU7QUFDOUUsOEJBQThCLGdEQUFVO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGtDQUFrQztBQUM1RCwwQkFBMEIsb0NBQW9DO0FBQzlELDBCQUEwQixtQ0FBbUM7QUFDN0Q7QUFDQSxpQkFBaUI7QUFDakIsMkJBQTJCLDZDQUE2QztBQUN4RSxhQUFhO0FBQ2Isb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsOENBQThDLDBFQUEwQjtBQUN4RTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIseUNBQXlDO0FBQ25FLGFBQWE7QUFDYixrQkFBa0IsMkVBQTJCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixvQ0FBb0M7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsU0FBUyxHQUFHLHVCQUF1QjtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQSxzRUFBc0U7QUFDdEU7QUFDQTtBQUNBLGdEQUFnRCxTQUFTLEdBQUcsUUFBUTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRTtBQUNqRSx5REFBeUQsU0FBUztBQUNsRTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLFlBQVksOERBQThEO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsMkVBQW1DO0FBQzVEO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsdUVBQWM7QUFDckM7QUFDQSxpQ0FBaUMsd0RBQWtCO0FBQ25EO0FBQ0EsMkJBQTJCLDBDQUFJO0FBQy9CLGFBQWE7QUFDYixvQkFBb0IsVUFBVSxFQUFFLDZEQUFZO0FBQzVDO0FBQ0EsMkJBQTJCLGdEQUFVO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0Isa0NBQWtDO0FBQ2pFLGdDQUFnQyxnQ0FBZ0M7QUFDaEUsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGtDQUFrQztBQUNqRSxnQ0FBZ0MsbUNBQW1DO0FBQ25FLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGdDQUFnQztBQUMxRCwwQkFBMEIsbUNBQW1DO0FBQzdEO0FBQ0EsZ0NBQWdDLGdDQUFnQztBQUNoRSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsOEJBQThCLGdEQUFVO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixnREFBZ0QsZ0RBQVU7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsVUFBVSxXQUFXLE9BQU87QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDBFQUEwQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxzRUFBc0UsV0FBVztBQUNqRiwwQkFBMEIsMkVBQTJCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLFlBQVkscUtBQXFLO0FBQ2pMO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCw0QkFBNEI7QUFDaEY7QUFDQSx1QkFBdUIsb0NBQW9DO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBLG1FQUFtRTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsWUFBWSw0UEFBNFA7QUFDeFE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQix1RUFBYztBQUN6QztBQUNBLHFDQUFxQyx3REFBa0I7QUFDdkQ7QUFDQSwrQkFBK0IsMENBQUk7QUFDbkMsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixnREFBVTtBQUNoQztBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsaUNBQWlDO0FBQ3RHLHVHQUF1RztBQUN2RztBQUNBO0FBQ0EsNENBQTRDLGdEQUFVO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsZ0RBQVU7QUFDM0M7QUFDQSx3QkFBd0IsU0FBUyxRQUFRLG1MQUFnQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLElBQUk7QUFDdEMsZ0RBQWdELElBQUk7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QiwrQkFBK0I7QUFDN0QsOEJBQThCLGtDQUFrQztBQUNoRTtBQUNBLG9DQUFvQyxvQ0FBb0M7QUFDeEUscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxrRUFBa0Usa0JBQWtCO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLGlDQUFpQztBQUNqQztBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUZBQW1GLG1CQUFtQixTQUFTLFFBQVEsU0FBUyxzQkFBc0I7QUFDdEo7QUFDQTtBQUNBO0FBQ0EsaUZBQWlGLFVBQVUsU0FBUyxRQUFRLFNBQVMscUJBQXFCO0FBQzFJO0FBQ0E7QUFDQSxrQ0FBa0MsZ0RBQVU7QUFDNUMscUJBQXFCLHFEQUFjO0FBQ25DLG9JQUFvSSxxQkFBcUI7QUFDeko7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0U7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixvQ0FBb0M7QUFDdkQ7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGdEQUFVO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBLCtEQUErRDtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdEQUFVO0FBQ3RCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSw2QkFBNkIsMEVBQTBCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLFVBQVUsMkVBQTJCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxhQUFhO0FBQ2I7QUFDTztBQUNQLFlBQVksMElBQTBJO0FBQ3RKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCwyREFBMkQscUJBQXFCO0FBQ2hGO0FBQ0EsNERBQTRELHFCQUFxQiwwQkFBMEIsZ0JBQWdCO0FBQzNIO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSwwQ0FBMEMscUJBQXFCLG9DQUFvQyx3QkFBd0I7QUFDM0g7QUFDQSxlQUFlLGdEQUFVO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkUseUNBQXlDLFdBQVcsb0NBQW9DO0FBQ3JLO0FBQ0EsaUVBQWlFO0FBQ2pFO0FBQ0E7QUFDQSxvREFBb0QscUJBQXFCLHVDQUF1QyxZQUFZO0FBQzVIO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBLDhDQUE4QyxxQkFBcUI7QUFDbkU7QUFDQSxtQkFBbUIsZ0RBQVU7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQSxrQkFBa0IsZ0RBQVU7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLG9EQUFvRCxpQ0FBaUM7QUFDckY7QUFDQSx1QkFBdUIsb0NBQW9DO0FBQzNEO0FBQ0EsU0FBUztBQUNUO0FBQ0EsbUVBQW1FO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esd0NBQXdDLGdEQUFVO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsNkJBQTZCLDBFQUEwQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxxRUFBcUUsV0FBVztBQUNoRiwwQkFBMEIsMkVBQTJCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLG9DQUFvQyxnREFBVTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLFlBQVksMElBQTBJO0FBQ3RKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCwyREFBMkQscUJBQXFCO0FBQ2hGO0FBQ0EsNERBQTRELHFCQUFxQiwwQkFBMEIsZ0JBQWdCO0FBQzNIO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSwwQ0FBMEMscUJBQXFCLG9DQUFvQyx3QkFBd0I7QUFDM0g7QUFDQSxlQUFlLGdEQUFVO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkUseUNBQXlDLFdBQVcsb0NBQW9DO0FBQ3JLO0FBQ0EsaUVBQWlFO0FBQ2pFO0FBQ0E7QUFDQSxvREFBb0QscUJBQXFCLHVDQUF1QyxZQUFZO0FBQzVIO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBLDhDQUE4QyxxQkFBcUI7QUFDbkU7QUFDQSxtQkFBbUIsZ0RBQVU7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQSxrQkFBa0IsZ0RBQVU7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLG9EQUFvRCxpQ0FBaUM7QUFDckY7QUFDQSx1QkFBdUIsb0NBQW9DO0FBQzNEO0FBQ0EsU0FBUztBQUNUO0FBQ0EsbUVBQW1FO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLHdDQUF3QyxnREFBVTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLDZCQUE2QiwwRUFBMEI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wscUVBQXFFLFdBQVc7QUFDaEYsMEJBQTBCLDJFQUEyQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxvQ0FBb0MsZ0RBQVU7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxZQUFZLDBJQUEwSTtBQUN0SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsMkRBQTJELHFCQUFxQjtBQUNoRjtBQUNBLDREQUE0RCxxQkFBcUIsMEJBQTBCLGdCQUFnQjtBQUMzSDtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsMENBQTBDLHFCQUFxQixvQ0FBb0Msd0JBQXdCO0FBQzNIO0FBQ0EsZUFBZSxnREFBVTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFLHlDQUF5QyxXQUFXLG9DQUFvQztBQUNySztBQUNBLGlFQUFpRTtBQUNqRTtBQUNBO0FBQ0Esb0RBQW9ELHFCQUFxQix1Q0FBdUMsWUFBWTtBQUM1SDtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQSw4Q0FBOEMscUJBQXFCO0FBQ25FO0FBQ0EsbUJBQW1CLGdEQUFVO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZ0RBQVU7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLG9EQUFvRCxpQ0FBaUM7QUFDckY7QUFDQSx1QkFBdUIsb0NBQW9DO0FBQzNEO0FBQ0EsU0FBUztBQUNUO0FBQ0EsbUVBQW1FO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLHdDQUF3QyxnREFBVTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLDZCQUE2QiwwRUFBMEI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wscUVBQXFFLFdBQVc7QUFDaEYsMEJBQTBCLDJFQUEyQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxvQ0FBb0MsZ0RBQVU7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxZQUFZLDBJQUEwSTtBQUN0SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsMkRBQTJELHFCQUFxQjtBQUNoRjtBQUNBLDREQUE0RCxxQkFBcUIsMEJBQTBCLGdCQUFnQjtBQUMzSDtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsMENBQTBDLHFCQUFxQixvQ0FBb0Msd0JBQXdCO0FBQzNIO0FBQ0EsZUFBZSxnREFBVTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFLHlDQUF5QyxXQUFXLG9DQUFvQztBQUNySztBQUNBLGlFQUFpRTtBQUNqRTtBQUNBO0FBQ0Esb0RBQW9ELHFCQUFxQix1Q0FBdUMsWUFBWTtBQUM1SDtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQSw4Q0FBOEMscUJBQXFCO0FBQ25FO0FBQ0EsbUJBQW1CLGdEQUFVO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZ0RBQVU7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLG9EQUFvRCxpQ0FBaUM7QUFDckY7QUFDQSx1QkFBdUIsb0NBQW9DO0FBQzNEO0FBQ0EsU0FBUztBQUNUO0FBQ0EsbUVBQW1FO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLHdDQUF3QyxnREFBVTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLDZCQUE2QiwwRUFBMEI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wscUVBQXFFLFdBQVc7QUFDaEYsMEJBQTBCLDJFQUEyQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxvQ0FBb0MsZ0RBQVU7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL2JhcmIvYWEvQXNzb2NpYXRlZEFjY291bnRzL25vZGVfbW9kdWxlcy9AYWdlbnRpYy10cnVzdC9jb3JlL2Rpc3QvY2xpZW50L3dhbGxldFNpZ25pbmcuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDbGllbnQtc2lkZSB3YWxsZXQgc2lnbmluZyB1dGlsaXRpZXNcbiAqXG4gKiBIYW5kbGVzIE1ldGFNYXNrL0VJUC0xMTkzIHdhbGxldCBpbnRlZ3JhdGlvbiBmb3Igc2lnbmluZyBhbmQgc2VuZGluZyB0cmFuc2FjdGlvbnNcbiAqIEFsbCBFdGhlcmV1bSBsb2dpYyBpcyBoYW5kbGVkIHNlcnZlci1zaWRlLCBjbGllbnQgb25seSBuZWVkcyB0byBzaWduIGFuZCBzZW5kXG4gKi9cbmltcG9ydCB7IGNyZWF0ZVdhbGxldENsaWVudCwgY3VzdG9tLCBjcmVhdGVQdWJsaWNDbGllbnQsIGdldEFkZHJlc3MsIH0gZnJvbSAndmllbSc7XG5pbXBvcnQgeyBodHRwLCBpc0FkZHJlc3NFcXVhbCB9IGZyb20gJ3ZpZW0nO1xuaW1wb3J0IHsgQUlBZ2VudElkZW50aXR5Q2xpZW50IH0gZnJvbSAnQGFnZW50aWMtdHJ1c3QvODAwNC1leHQtc2RrJztcbmltcG9ydCB7IGdldENoYWluQnlJZCwgREVGQVVMVF9DSEFJTl9JRCwgZ2V0Q2hhaW5ScGNVcmwsIGdldENoYWluQnVuZGxlclVybCwgc2Vwb2xpYSwgYmFzZVNlcG9saWEsIG9wdGltaXNtU2Vwb2xpYSwgaXNMMSwgaXNMMiwgaXNQcml2YXRlS2V5TW9kZSwgfSBmcm9tICcuLi9zZXJ2ZXIvbGliL2NoYWluQ29uZmlnJztcbmltcG9ydCB7IGdldERlcGxveWVkQWNjb3VudENsaWVudEJ5QWdlbnROYW1lLCBzZW5kU3BvbnNvcmVkVXNlck9wZXJhdGlvbiwgd2FpdEZvclVzZXJPcGVyYXRpb25SZWNlaXB0LCB9IGZyb20gJy4vYWNjb3VudENsaWVudCc7XG5pbXBvcnQgeyBjcmVhdGVBZ2VudCBhcyBjYWxsQ3JlYXRlQWdlbnRFbmRwb2ludCwgdXBkYXRlQWdlbnRSZWdpc3RyYXRpb24gYXMgY2FsbFVwZGF0ZUFnZW50UmVnaXN0cmF0aW9uRW5kcG9pbnQsIH0gZnJvbSAnLi4vYXBpL2FnZW50cy9jbGllbnQnO1xuaW1wb3J0IHsgcGFyc2VEaWQ4MDA0IH0gZnJvbSAnLi4vc2hhcmVkL2RpZDgwMDQnO1xuZXhwb3J0IHsgZ2V0RGVwbG95ZWRBY2NvdW50Q2xpZW50QnlBZ2VudE5hbWUsIGdldERlcGxveWVkQWNjb3VudENsaWVudEJ5QWRkcmVzcywgZ2V0Q291bnRlcmZhY3R1YWxBY2NvdW50Q2xpZW50QnlBZ2VudE5hbWUsIGdldENvdW50ZXJmYWN0dWFsU21hcnRBY2NvdW50QWRkcmVzc0J5QWdlbnROYW1lLCBnZXRDb3VudGVyZmFjdHVhbEFBQWRkcmVzc0J5QWdlbnROYW1lLCB9IGZyb20gJy4vYWNjb3VudENsaWVudCc7XG5mdW5jdGlvbiByZXNvbHZlRXRoZXJldW1Qcm92aWRlcihwcm92aWRlZFByb3ZpZGVyKSB7XG4gICAgaWYgKHByb3ZpZGVkUHJvdmlkZXIpXG4gICAgICAgIHJldHVybiBwcm92aWRlZFByb3ZpZGVyO1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjb25zdCB3ZWIzYXV0aFByb3ZpZGVyID0gd2luZG93Py53ZWIzYXV0aD8ucHJvdmlkZXI7XG4gICAgICAgIGlmICh3ZWIzYXV0aFByb3ZpZGVyKVxuICAgICAgICAgICAgcmV0dXJuIHdlYjNhdXRoUHJvdmlkZXI7XG4gICAgICAgIGNvbnN0IGluamVjdGVkID0gd2luZG93LmV0aGVyZXVtO1xuICAgICAgICBpZiAoaW5qZWN0ZWQpXG4gICAgICAgICAgICByZXR1cm4gaW5qZWN0ZWQ7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuYXN5bmMgZnVuY3Rpb24gcmVzb2x2ZUNoYWluSWQoZXRoZXJldW1Qcm92aWRlcikge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGNoYWluSGV4ID0gYXdhaXQgZXRoZXJldW1Qcm92aWRlci5yZXF1ZXN0Py4oe1xuICAgICAgICAgICAgbWV0aG9kOiAnZXRoX2NoYWluSWQnLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHR5cGVvZiBjaGFpbkhleCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUludChjaGFpbkhleCwgMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIHtcbiAgICAgICAgLy8gaWdub3JlOyBmYWxsYmFjayBiZWxvd1xuICAgIH1cbiAgICAvLyBGYWxsYmFjayB0byBkZWZhdWx0IGNoYWluIGlkXG4gICAgcmV0dXJuIERFRkFVTFRfQ0hBSU5fSUQ7XG59XG4vKipcbiAqIEVuc3VyZSB0aGUgcHJvdmlkZXIgaGFzIGFuIGF1dGhvcml6ZWQgYWNjb3VudCBhbmQgcmV0dXJuIGl0LlxuICogVHJpZXMgZXRoX2FjY291bnRzIGZpcnN0OyBpZiBlbXB0eSwgcmVxdWVzdHMgZXRoX3JlcXVlc3RBY2NvdW50cy5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gZW5zdXJlQXV0aG9yaXplZEFjY291bnQoZXRoZXJldW1Qcm92aWRlcikge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nID0gYXdhaXQgZXRoZXJldW1Qcm92aWRlci5yZXF1ZXN0KHsgbWV0aG9kOiAnZXRoX2FjY291bnRzJyB9KTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZXhpc3RpbmcpICYmIGV4aXN0aW5nLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiBleGlzdGluZ1swXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCB7XG4gICAgICAgIC8vIGlnbm9yZSBhbmQgZmFsbCB0aHJvdWdoIHRvIHJlcXVlc3RcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgZ3JhbnRlZCA9IGF3YWl0IGV0aGVyZXVtUHJvdmlkZXIucmVxdWVzdCh7XG4gICAgICAgICAgICBtZXRob2Q6ICdldGhfcmVxdWVzdEFjY291bnRzJyxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGdyYW50ZWQpICYmIGdyYW50ZWQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGdyYW50ZWRbMF07XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2gge1xuICAgICAgICAvLyBmYWxsdGhyb3VnaCB0byBwZXJtaXNzaW9ucyBmbG93XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IGV0aGVyZXVtUHJvdmlkZXIucmVxdWVzdD8uKHtcbiAgICAgICAgICAgIG1ldGhvZDogJ3dhbGxldF9yZXF1ZXN0UGVybWlzc2lvbnMnLFxuICAgICAgICAgICAgcGFyYW1zOiBbeyBldGhfYWNjb3VudHM6IHt9IH1dLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgYWZ0ZXJQZXJtID0gYXdhaXQgZXRoZXJldW1Qcm92aWRlci5yZXF1ZXN0KHtcbiAgICAgICAgICAgIG1ldGhvZDogJ2V0aF9hY2NvdW50cycsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhZnRlclBlcm0pICYmIGFmdGVyUGVybS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4gYWZ0ZXJQZXJtWzBdO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIHtcbiAgICAgICAgLy8gaWdub3JlXG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignV2FsbGV0IG5vdCBhdXRob3JpemVkLiBQbGVhc2UgY29ubmVjdCB5b3VyIHdhbGxldC4nKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGVuc3VyZUNoYWluU2VsZWN0ZWQoZXRoZXJldW1Qcm92aWRlciwgY2hhaW4pIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBjdXJyZW50SGV4ID0gYXdhaXQgZXRoZXJldW1Qcm92aWRlci5yZXF1ZXN0Py4oe1xuICAgICAgICAgICAgbWV0aG9kOiAnZXRoX2NoYWluSWQnLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgY3VycmVudCA9IHR5cGVvZiBjdXJyZW50SGV4ID09PSAnc3RyaW5nJyA/IHBhcnNlSW50KGN1cnJlbnRIZXgsIDE2KSA6IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKGN1cnJlbnQgPT09IGNoYWluLmlkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjYXRjaCB7XG4gICAgICAgIC8vIGNvbnRpbnVlIHRvIHN3aXRjaFxuICAgIH1cbiAgICBjb25zdCBoZXhJZCA9IGAweCR7Y2hhaW4uaWQudG9TdHJpbmcoMTYpfWA7XG4gICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgZXRoZXJldW1Qcm92aWRlci5yZXF1ZXN0Py4oe1xuICAgICAgICAgICAgbWV0aG9kOiAnd2FsbGV0X3N3aXRjaEV0aGVyZXVtQ2hhaW4nLFxuICAgICAgICAgICAgcGFyYW1zOiBbeyBjaGFpbklkOiBoZXhJZCB9XSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2F0Y2ggKHN3aXRjaEVycikge1xuICAgICAgICAvLyA0OTAyID0gdW5rbm93biBjaGFpbiwgdHJ5IGFkZCB0aGVuIHN3aXRjaFxuICAgICAgICBpZiAoc3dpdGNoRXJyPy5jb2RlICE9PSA0OTAyKSB7XG4gICAgICAgICAgICB0aHJvdyBzd2l0Y2hFcnI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gVHJ5IHRvIGFkZCBjaGFpbiB1c2luZyBjZW50cmFsaXplZCBjb25maWd1cmF0aW9uXG4gICAgY29uc3QgY2hhaW5Db25maWcgPSBnZXRDaGFpbkJ5SWQoY2hhaW4uaWQpO1xuICAgIGNvbnN0IGFkZFBhcmFtcyA9IHtcbiAgICAgICAgY2hhaW5JZDogaGV4SWQsXG4gICAgICAgIGNoYWluTmFtZTogY2hhaW5Db25maWcubmFtZSxcbiAgICAgICAgbmF0aXZlQ3VycmVuY3k6IHtcbiAgICAgICAgICAgIG5hbWU6ICdFVEgnLFxuICAgICAgICAgICAgc3ltYm9sOiAnRVRIJyxcbiAgICAgICAgICAgIGRlY2ltYWxzOiAxOCxcbiAgICAgICAgfSxcbiAgICAgICAgcnBjVXJsczogW2dldENoYWluUnBjVXJsKGNoYWluLmlkKV0sXG4gICAgICAgIGJsb2NrRXhwbG9yZXJVcmxzOiBjaGFpbkNvbmZpZy5ibG9ja0V4cGxvcmVycz8uZGVmYXVsdFxuICAgICAgICAgICAgPyBbY2hhaW5Db25maWcuYmxvY2tFeHBsb3JlcnMuZGVmYXVsdC51cmxdXG4gICAgICAgICAgICA6IFtdLFxuICAgIH07XG4gICAgYXdhaXQgZXRoZXJldW1Qcm92aWRlci5yZXF1ZXN0Py4oe1xuICAgICAgICBtZXRob2Q6ICd3YWxsZXRfYWRkRXRoZXJldW1DaGFpbicsXG4gICAgICAgIHBhcmFtczogW2FkZFBhcmFtc10sXG4gICAgfSk7XG4gICAgYXdhaXQgZXRoZXJldW1Qcm92aWRlci5yZXF1ZXN0Py4oe1xuICAgICAgICBtZXRob2Q6ICd3YWxsZXRfc3dpdGNoRXRoZXJldW1DaGFpbicsXG4gICAgICAgIHBhcmFtczogW3sgY2hhaW5JZDogaGV4SWQgfV0sXG4gICAgfSk7XG59XG4vKipcbiAqIFNpZ24gYW5kIHNlbmQgYSB0cmFuc2FjdGlvbiB1c2luZyBNZXRhTWFzay9FSVAtMTE5MyB3YWxsZXRcbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyAtIFNpZ25pbmcgb3B0aW9ucyBpbmNsdWRpbmcgdHJhbnNhY3Rpb24sIGFjY291bnQsIGNoYWluLCBhbmQgcHJvdmlkZXJcbiAqIEByZXR1cm5zIFRyYW5zYWN0aW9uIGhhc2gsIHJlY2VpcHQsIGFuZCBvcHRpb25hbGx5IGV4dHJhY3RlZCBhZ2VudElkXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzaWduQW5kU2VuZFRyYW5zYWN0aW9uKG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IHRyYW5zYWN0aW9uLCBhY2NvdW50LCBjaGFpbiwgZXRoZXJldW1Qcm92aWRlciwgcnBjVXJsLCBvblN0YXR1c1VwZGF0ZSwgZXh0cmFjdEFnZW50SWQgPSBmYWxzZSwgfSA9IG9wdGlvbnM7XG4gICAgLy8gR2V0IHdhbGxldCBwcm92aWRlclxuICAgIGNvbnN0IHByb3ZpZGVyID0gcmVzb2x2ZUV0aGVyZXVtUHJvdmlkZXIoZXRoZXJldW1Qcm92aWRlcik7XG4gICAgaWYgKCFwcm92aWRlcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHdhbGxldCBwcm92aWRlciBmb3VuZC4gUGxlYXNlIGNvbm5lY3QgTWV0YU1hc2sgb3IgdXNlIGFuIEVJUC0xMTkzIGNvbXBhdGlibGUgd2FsbGV0LicpO1xuICAgIH1cbiAgICAvLyBVcGRhdGUgc3RhdHVzXG4gICAgb25TdGF0dXNVcGRhdGU/LignQ29ubmVjdGluZyB0byB3YWxsZXQuLi4nKTtcbiAgICAvLyBDcmVhdGUgd2FsbGV0IGNsaWVudFxuICAgIHRyeSB7XG4gICAgICAgIC8vIEVuc3VyZSBjb3JyZWN0IGNoYWluICYgYWNjb3VudCBwZXJtaXNzaW9uIGJlZm9yZSBzZW5kaW5nXG4gICAgICAgIGF3YWl0IGVuc3VyZUNoYWluU2VsZWN0ZWQocHJvdmlkZXIsIGNoYWluKTtcbiAgICAgICAgYXdhaXQgZW5zdXJlQXV0aG9yaXplZEFjY291bnQocHJvdmlkZXIpO1xuICAgIH1cbiAgICBjYXRjaCB7XG4gICAgICAgIC8vIE5vbi1mYXRhbDsgc29tZSBwcm92aWRlcnMgbWF5IG5vdCByZXF1aXJlIHRoaXMgaGVyZVxuICAgIH1cbiAgICBjb25zdCB3YWxsZXRDbGllbnQgPSBjcmVhdGVXYWxsZXRDbGllbnQoe1xuICAgICAgICBhY2NvdW50LFxuICAgICAgICBjaGFpbixcbiAgICAgICAgdHJhbnNwb3J0OiBjdXN0b20ocHJvdmlkZXIpLFxuICAgIH0pO1xuICAgIC8vIFByZWZlciBhIHJlYWwgUlBDIGZvciByZWFkcyAoV2ViM0F1dGgvT3BlbkxvZ2luIHByb3ZpZGVycyBvZnRlbiByZXR1cm4gb3BhcXVlIFwiaW50ZXJuYWwgSlNPTi1SUEMgZXJyb3JcIlxuICAgIC8vIGZvciBldGhfZ2V0Q29kZSAvIGV0aF9lc3RpbWF0ZUdhcyAvIHdhaXRGb3JSZWNlaXB0KS5cbiAgICBjb25zdCBycGNGb3JSZWFkcyA9IHJwY1VybCB8fFxuICAgICAgICBjaGFpbj8ucnBjVXJscz8uZGVmYXVsdD8uaHR0cD8uWzBdIHx8XG4gICAgICAgIGNoYWluPy5ycGNVcmxzPy5wdWJsaWM/Lmh0dHA/LlswXTtcbiAgICBjb25zdCByZWFkQ2xpZW50ID0gY3JlYXRlUHVibGljQ2xpZW50KHtcbiAgICAgICAgY2hhaW4sXG4gICAgICAgIHRyYW5zcG9ydDogcnBjRm9yUmVhZHMgPyBodHRwKHJwY0ZvclJlYWRzKSA6IGN1c3RvbShwcm92aWRlciksXG4gICAgfSk7XG4gICAgLy8gV2ViM0F1dGgvT3BlbkxvZ2luIHByb3ZpZGVycyBjYW4gYmUgb24gYSBkaWZmZXJlbnQgY2hhaW4gdGhhbiBvdXIgVUkgc2VsZWN0aW9uLlxuICAgIC8vIElmIHdlIGRvbid0IGVuZm9yY2UgY2hhaW4gYWxpZ25tZW50LCBzZW5kVHJhbnNhY3Rpb24gY2FuIGZhaWwgd2l0aCBvcGFxdWUgaW50ZXJuYWwgZXJyb3JzLlxuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRDaGFpbklkSGV4ID0gKGF3YWl0IHByb3ZpZGVyLnJlcXVlc3Q/Lih7IG1ldGhvZDogJ2V0aF9jaGFpbklkJywgcGFyYW1zOiBbXSB9KSk7XG4gICAgICAgIGlmIChjdXJyZW50Q2hhaW5JZEhleCAmJiB0eXBlb2YgY3VycmVudENoYWluSWRIZXggPT09ICdzdHJpbmcnICYmIGN1cnJlbnRDaGFpbklkSGV4LnN0YXJ0c1dpdGgoJzB4JykpIHtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnQgPSBOdW1iZXIucGFyc2VJbnQoY3VycmVudENoYWluSWRIZXgsIDE2KTtcbiAgICAgICAgICAgIGlmIChOdW1iZXIuaXNGaW5pdGUoY3VycmVudCkgJiYgY3VycmVudCAhPT0gY2hhaW4uaWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFdhbGxldCBpcyBvbiBjaGFpbklkICR7Y3VycmVudH0gYnV0IHRoaXMgdHJhbnNhY3Rpb24gdGFyZ2V0cyBjaGFpbklkICR7Y2hhaW4uaWR9LiBQbGVhc2Ugc3dpdGNoIG5ldHdvcmtzIGluIFdlYjNBdXRoIGFuZCByZXRyeS5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICAvLyBJZiBldGhfY2hhaW5JZCBpdHNlbGYgZmFpbHMsIGNvbnRpbnVlOyBvdGhlciBjaGVja3Mgd2lsbCBzdGlsbCBzdXJmYWNlIGVycm9ycy5cbiAgICB9XG4gICAgLy8gUHJlZmxpZ2h0OiBlbnN1cmUgdGFyZ2V0IGhhcyBjb2RlICsgZXN0aW1hdGUgZ2FzIChzbyB3ZSBjYW4gc3VyZmFjZSByZXZlcnRzIGVhcmx5IGFuZFxuICAgIC8vIGF2b2lkIHdhbGxldC1zaWRlIGVzdGltYXRpb24gZmFpbHVyZXMpLlxuICAgIGxldCBlc3RpbWF0ZWRHYXMgPSBudWxsO1xuICAgIGlmICh0cmFuc2FjdGlvbj8udG8pIHtcbiAgICAgICAgY29uc3QgY29kZSA9IGF3YWl0IHJlYWRDbGllbnQuZ2V0Qnl0ZWNvZGUoeyBhZGRyZXNzOiB0cmFuc2FjdGlvbi50byB9KTtcbiAgICAgICAgaWYgKCFjb2RlIHx8IGNvZGUgPT09ICcweCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVGFyZ2V0IGNvbnRyYWN0IGlzIG5vdCBkZXBsb3llZCBhdCAke1N0cmluZyh0cmFuc2FjdGlvbi50byl9IG9uIGNoYWluSWQgJHtjaGFpbi5pZH0uIENoZWNrIGFkZHJlc3Nlcy9jb25maWcuYCk7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGVzdGltYXRlZEdhcyA9IGF3YWl0IHJlYWRDbGllbnQuZXN0aW1hdGVHYXMoe1xuICAgICAgICAgICAgICAgIGFjY291bnQsXG4gICAgICAgICAgICAgICAgdG86IHRyYW5zYWN0aW9uLnRvLFxuICAgICAgICAgICAgICAgIGRhdGE6IHRyYW5zYWN0aW9uLmRhdGEsXG4gICAgICAgICAgICAgICAgdmFsdWU6IEJpZ0ludCh0cmFuc2FjdGlvbi52YWx1ZSA/PyAwKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlc3RpbWF0ZUVycikge1xuICAgICAgICAgICAgLy8gVHJ5IHRvIGV4dHJhY3QgcmV2ZXJ0IHJlYXNvbiBmcm9tIGV0aF9jYWxsIHNpbXVsYXRpb25cbiAgICAgICAgICAgIGxldCByZXZlcnRSZWFzb24gPSAndW5rbm93biByZWFzb24nO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBhd2FpdCByZWFkQ2xpZW50LmNhbGwoe1xuICAgICAgICAgICAgICAgICAgICBhY2NvdW50LFxuICAgICAgICAgICAgICAgICAgICB0bzogdHJhbnNhY3Rpb24udG8sXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHRyYW5zYWN0aW9uLmRhdGEsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBCaWdJbnQodHJhbnNhY3Rpb24udmFsdWUgPz8gMCksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoY2FsbEVycikge1xuICAgICAgICAgICAgICAgIC8vIFRyeSBtdWx0aXBsZSB3YXlzIHRvIGV4dHJhY3QgcmV2ZXJ0IHJlYXNvblxuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBjYWxsRXJyPy5kYXRhIHx8IGNhbGxFcnI/LmNhdXNlPy5kYXRhIHx8IGNhbGxFcnI/LmRldGFpbHMgfHwgY2FsbEVycj8uYm9keT8uZXJyb3I/LmRhdGEgfHwgJyc7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2hvcnRNc2cgPSBjYWxsRXJyPy5zaG9ydE1lc3NhZ2UgfHwgY2FsbEVycj8ubWVzc2FnZSB8fCAnJztcbiAgICAgICAgICAgICAgICAvLyBTdGFuZGFyZCBTb2xpZGl0eSByZXZlcnQ6IEVycm9yKHN0cmluZykgc2VsZWN0b3IgMHgwOGMzNzlhMFxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycgJiYgZGF0YS5zdGFydHNXaXRoKCcweDA4YzM3OWEwJykpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgZGVjb2RlQWJpUGFyYW1ldGVycyB9ID0gYXdhaXQgaW1wb3J0KCd2aWVtJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkZWNvZGVkID0gZGVjb2RlQWJpUGFyYW1ldGVycyhbeyB0eXBlOiAnc3RyaW5nJywgbmFtZTogJ3JlYXNvbicgfV0sIGAweCR7ZGF0YS5zbGljZSgxMCl9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXZlcnRSZWFzb24gPSBkZWNvZGVkWzBdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldmVydFJlYXNvbiA9ICdyZXZlcnRlZCB3aXRoIEVycm9yKHN0cmluZykgKGRlY29kZSBmYWlsZWQpJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycgJiYgZGF0YS5sZW5ndGggPiAyICYmIGRhdGEuc3RhcnRzV2l0aCgnMHgnKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSBoYXZlIGhleCBkYXRhIGJ1dCBpdCdzIG5vdCBFcnJvcihzdHJpbmcpLCBzaG93IGZpcnN0IGJ5dGVzXG4gICAgICAgICAgICAgICAgICAgIHJldmVydFJlYXNvbiA9IGByZXZlcnRlZCB3aXRoIGRhdGE6ICR7ZGF0YS5zbGljZSgwLCAxMzApfWA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNob3J0TXNnICYmICFzaG9ydE1zZy5pbmNsdWRlcygndW5rbm93bicpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldmVydFJlYXNvbiA9IHNob3J0TXNnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBMb2cgZnVsbCBlcnJvciBmb3IgZGVidWdnaW5nXG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gY2FsbEVycj8ubWVzc2FnZSB8fCAnJztcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1tzaWduQW5kU2VuZFRyYW5zYWN0aW9uXSBGdWxsIGV0aF9jYWxsIGVycm9yIGRldGFpbHM6Jywge1xuICAgICAgICAgICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgICAgICAgICBzaG9ydE1lc3NhZ2U6IHNob3J0TXNnLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBlcnJvck1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIGNhdXNlOiBjYWxsRXJyPy5jYXVzZSxcbiAgICAgICAgICAgICAgICAgICAgYm9keTogY2FsbEVycj8uYm9keSxcbiAgICAgICAgICAgICAgICAgICAgc3RhY2s6IGNhbGxFcnI/LnN0YWNrPy5zcGxpdCgnXFxuJykuc2xpY2UoMCwgNSksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgLy8gVHJ5IHRvIGRlY29kZSBFcnJvcihzdHJpbmcpIGZyb20gdGhlIGRhdGEgaWYgYXZhaWxhYmxlXG4gICAgICAgICAgICAgICAgaWYgKGRhdGEgJiYgdHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnICYmIGRhdGEuc3RhcnRzV2l0aCgnMHgnKSAmJiBkYXRhLmxlbmd0aCA+PSAxMCkge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgaXQncyBhbiBFcnJvcihzdHJpbmcpIC0gc2VsZWN0b3IgaXMgMHgwOGMzNzlhMFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEuc3RhcnRzV2l0aCgnMHgwOGMzNzlhMCcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBkZWNvZGVBYmlQYXJhbWV0ZXJzIH0gPSBhd2FpdCBpbXBvcnQoJ3ZpZW0nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkZWNvZGVkID0gZGVjb2RlQWJpUGFyYW1ldGVycyhbeyB0eXBlOiAnc3RyaW5nJywgbmFtZTogJ3JlYXNvbicgfV0sIGAweCR7ZGF0YS5zbGljZSgxMCl9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdbc2lnbkFuZFNlbmRUcmFuc2FjdGlvbl0gRGVjb2RlZCBFcnJvcihzdHJpbmcpIHJldmVydCByZWFzb246JywgZGVjb2RlZFswXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV2ZXJ0UmVhc29uID0gZGVjb2RlZFswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRyeSB0byBkZWNvZGUgYXMgcmF3IHN0cmluZyBkYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBkZWNvZGVBYmlQYXJhbWV0ZXJzIH0gPSBhd2FpdCBpbXBvcnQoJ3ZpZW0nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkZWNvZGVkID0gZGVjb2RlQWJpUGFyYW1ldGVycyhbeyB0eXBlOiAnc3RyaW5nJywgbmFtZTogJ3JlYXNvbicgfV0sIGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVjb2RlZFswXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdbc2lnbkFuZFNlbmRUcmFuc2FjdGlvbl0gRGVjb2RlZCByYXcgcmV2ZXJ0IHJlYXNvbjonLCBkZWNvZGVkWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldmVydFJlYXNvbiA9IGRlY29kZWRbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2gge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGF0IGZhaWxzLCBzaG93IGZpcnN0IHBhcnQgb2YgaGV4IGRhdGFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdbc2lnbkFuZFNlbmRUcmFuc2FjdGlvbl0gUmF3IHJldmVydCBkYXRhIChmaXJzdCAxMDAgY2hhcnMpOicsIGRhdGEuc2xpY2UoMCwgMTAwKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChkZWNvZGVFcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignW3NpZ25BbmRTZW5kVHJhbnNhY3Rpb25dIEZhaWxlZCB0byBkZWNvZGUgcmV2ZXJ0IGRhdGE6JywgZGVjb2RlRXJyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBUcnkgYWRkaXRpb25hbCBlcnJvciBtZXNzYWdlIGV4dHJhY3Rpb25cbiAgICAgICAgICAgICAgICBpZiAoZXJyb3JNZXNzYWdlICYmIGVycm9yTWVzc2FnZS5pbmNsdWRlcygncmV2ZXJ0JykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV2ZXJ0UmVhc29uID0gZXJyb3JNZXNzYWdlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG1zZyA9IGVzdGltYXRlRXJyPy5zaG9ydE1lc3NhZ2UgfHwgZXN0aW1hdGVFcnI/Lm1lc3NhZ2UgfHwgU3RyaW5nKGVzdGltYXRlRXJyKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVHJhbnNhY3Rpb24gd291bGQgZmFpbCAoZXN0aW1hdGVHYXMpOiBFeGVjdXRpb24gcmV2ZXJ0ZWQ6ICR7cmV2ZXJ0UmVhc29ufS4gJHttc2d9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gVXBkYXRlIHN0YXR1c1xuICAgIG9uU3RhdHVzVXBkYXRlPy4oJ1RyYW5zYWN0aW9uIHByZXBhcmVkLiBQbGVhc2UgY29uZmlybSBpbiB5b3VyIHdhbGxldC4uLicpO1xuICAgIC8vIENvbnZlcnQgaGV4IHN0cmluZ3MgdG8gYmlnaW50IGZvciBWaWVtIChWaWVtIGFjY2VwdHMgYm90aCwgYnV0IFR5cGVTY3JpcHQgaXMgc3RyaWN0KVxuICAgIGNvbnN0IHR4UGFyYW1zID0ge1xuICAgICAgICAuLi50cmFuc2FjdGlvbixcbiAgICAgICAgdmFsdWU6IEJpZ0ludCh0cmFuc2FjdGlvbi52YWx1ZSksXG4gICAgfTtcbiAgICBpZiAodHJhbnNhY3Rpb24uZ2FzKSB7XG4gICAgICAgIHR4UGFyYW1zLmdhcyA9IEJpZ0ludCh0cmFuc2FjdGlvbi5nYXMpO1xuICAgIH1cbiAgICBlbHNlIGlmIChlc3RpbWF0ZWRHYXMpIHtcbiAgICAgICAgLy8gUGFkIGVzdGltYXRlIHRvIGF2b2lkIHVuZGVyZXN0aW1hdGlvbjsgc29tZSB3YWxsZXRzIHN0cnVnZ2xlIHRvIGVzdGltYXRlIGludGVybmFsbHkuXG4gICAgICAgIC8vIElNUE9SVEFOVDoga2VlcCB0aGlzIGludGVnZXItc2FmZTsgQmlnSW50KCkgY2Fubm90IHRha2UgZnJhY3Rpb25hbCBudW1iZXJzLlxuICAgICAgICAvLyBVc2UgcHVyZSBCaWdJbnQgbWF0aCB0byBhcHBseSBhIDIwJSBidWZmZXIuXG4gICAgICAgIGNvbnN0IGVnID0gdHlwZW9mIGVzdGltYXRlZEdhcyA9PT0gJ2JpZ2ludCcgPyBlc3RpbWF0ZWRHYXMgOiBCaWdJbnQoZXN0aW1hdGVkR2FzKTtcbiAgICAgICAgdHhQYXJhbXMuZ2FzID0gKGVnICogMTIwbikgLyAxMDBuO1xuICAgIH1cbiAgICBpZiAodHJhbnNhY3Rpb24uZ2FzUHJpY2UpIHtcbiAgICAgICAgdHhQYXJhbXMuZ2FzUHJpY2UgPSBCaWdJbnQodHJhbnNhY3Rpb24uZ2FzUHJpY2UpO1xuICAgIH1cbiAgICBpZiAodHJhbnNhY3Rpb24ubWF4RmVlUGVyR2FzKSB7XG4gICAgICAgIHR4UGFyYW1zLm1heEZlZVBlckdhcyA9IEJpZ0ludCh0cmFuc2FjdGlvbi5tYXhGZWVQZXJHYXMpO1xuICAgIH1cbiAgICBpZiAodHJhbnNhY3Rpb24ubWF4UHJpb3JpdHlGZWVQZXJHYXMpIHtcbiAgICAgICAgdHhQYXJhbXMubWF4UHJpb3JpdHlGZWVQZXJHYXMgPSBCaWdJbnQodHJhbnNhY3Rpb24ubWF4UHJpb3JpdHlGZWVQZXJHYXMpO1xuICAgIH1cbiAgICAvLyBJZiBmZWVzIGFyZSBub3QgcHJvdmlkZWQsIGVzdGltYXRlIHRoZW0gdmlhIFJQQy4gVGhpcyBhdm9pZHMgV2ViM0F1dGggaW50ZXJuYWwgZXJyb3JzXG4gICAgLy8gZHVyaW5nIHdhbGxldC1zaWRlIGZlZSBlc3RpbWF0aW9uLlxuICAgIGlmICghdHhQYXJhbXMuZ2FzUHJpY2UgJiYgIXR4UGFyYW1zLm1heEZlZVBlckdhcyAmJiAhdHhQYXJhbXMubWF4UHJpb3JpdHlGZWVQZXJHYXMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGZlZXMgPSBhd2FpdCByZWFkQ2xpZW50LmVzdGltYXRlRmVlc1BlckdhcygpO1xuICAgICAgICAgICAgaWYgKGZlZXM/Lm1heEZlZVBlckdhcyAmJiBmZWVzPy5tYXhQcmlvcml0eUZlZVBlckdhcykge1xuICAgICAgICAgICAgICAgIHR4UGFyYW1zLm1heEZlZVBlckdhcyA9IGZlZXMubWF4RmVlUGVyR2FzO1xuICAgICAgICAgICAgICAgIHR4UGFyYW1zLm1heFByaW9yaXR5RmVlUGVyR2FzID0gZmVlcy5tYXhQcmlvcml0eUZlZVBlckdhcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGdwID0gYXdhaXQgcmVhZENsaWVudC5nZXRHYXNQcmljZSgpO1xuICAgICAgICAgICAgICAgIHR4UGFyYW1zLmdhc1ByaWNlID0gZ3A7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2gge1xuICAgICAgICAgICAgLy8gSWdub3JlOyB3YWxsZXQgbWF5IHN0aWxsIGhhbmRsZSBmZWUgZXN0aW1hdGlvbi5cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBTaWduIGFuZCBzZW5kIHRyYW5zYWN0aW9uXG4gICAgLy8gTk9URTogV2ViM0F1dGggKE9wZW5Mb2dpbikgc29tZXRpbWVzIGZhaWxzIHRvIHN1cmZhY2UgdGhlIGFwcHJvdmFsIG1vZGFsIHdoZW4gdXNpbmcgd2FsbGV0Q2xpZW50LnNlbmRUcmFuc2FjdGlvbi5cbiAgICAvLyBXZSBrZWVwIHRoZSB2aWVtIHBhdGggZmlyc3QsIGJ1dCBhZGQgYSBmYWxsYmFjayB0byBldGhfc2VuZFRyYW5zYWN0aW9uIHdoaWNoIHRlbmRzIHRvIHJlbGlhYmx5IHRyaWdnZXIgdGhlIFVJLlxuICAgIGxldCBoYXNoO1xuICAgIHRyeSB7XG4gICAgICAgIGhhc2ggPSBhd2FpdCB3YWxsZXRDbGllbnQuc2VuZFRyYW5zYWN0aW9uKHR4UGFyYW1zKTtcbiAgICB9XG4gICAgY2F0Y2ggKHNlbmRFcnIpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdbc2lnbkFuZFNlbmRUcmFuc2FjdGlvbl0gd2FsbGV0Q2xpZW50LnNlbmRUcmFuc2FjdGlvbiBmYWlsZWQ7IGF0dGVtcHRpbmcgZXRoX3NlbmRUcmFuc2FjdGlvbiBmYWxsYmFjaycsIHNlbmRFcnIpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgZnJvbSA9IGFjY291bnQgfHwgdHhQYXJhbXMuYWNjb3VudDtcbiAgICAgICAgICAgIGNvbnN0IHR4Rm9yUHJvdmlkZXIgPSB7XG4gICAgICAgICAgICAgICAgZnJvbSxcbiAgICAgICAgICAgICAgICB0bzogdHhQYXJhbXMudG8sXG4gICAgICAgICAgICAgICAgZGF0YTogdHhQYXJhbXMuZGF0YSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogYDB4JHtCaWdJbnQodHhQYXJhbXMudmFsdWUgPz8gMG4pLnRvU3RyaW5nKDE2KX1gLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICh0eFBhcmFtcy5nYXMpXG4gICAgICAgICAgICAgICAgdHhGb3JQcm92aWRlci5nYXMgPSBgMHgke0JpZ0ludCh0eFBhcmFtcy5nYXMpLnRvU3RyaW5nKDE2KX1gO1xuICAgICAgICAgICAgaWYgKHR4UGFyYW1zLmdhc1ByaWNlKVxuICAgICAgICAgICAgICAgIHR4Rm9yUHJvdmlkZXIuZ2FzUHJpY2UgPSBgMHgke0JpZ0ludCh0eFBhcmFtcy5nYXNQcmljZSkudG9TdHJpbmcoMTYpfWA7XG4gICAgICAgICAgICBpZiAodHhQYXJhbXMubWF4RmVlUGVyR2FzKVxuICAgICAgICAgICAgICAgIHR4Rm9yUHJvdmlkZXIubWF4RmVlUGVyR2FzID0gYDB4JHtCaWdJbnQodHhQYXJhbXMubWF4RmVlUGVyR2FzKS50b1N0cmluZygxNil9YDtcbiAgICAgICAgICAgIGlmICh0eFBhcmFtcy5tYXhQcmlvcml0eUZlZVBlckdhcylcbiAgICAgICAgICAgICAgICB0eEZvclByb3ZpZGVyLm1heFByaW9yaXR5RmVlUGVyR2FzID0gYDB4JHtCaWdJbnQodHhQYXJhbXMubWF4UHJpb3JpdHlGZWVQZXJHYXMpLnRvU3RyaW5nKDE2KX1gO1xuICAgICAgICAgICAgaGFzaCA9IGF3YWl0IHByb3ZpZGVyLnJlcXVlc3Q/Lih7IG1ldGhvZDogJ2V0aF9zZW5kVHJhbnNhY3Rpb24nLCBwYXJhbXM6IFt0eEZvclByb3ZpZGVyXSB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZmFsbGJhY2tFcnIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignW3NpZ25BbmRTZW5kVHJhbnNhY3Rpb25dIGV0aF9zZW5kVHJhbnNhY3Rpb24gZmFsbGJhY2sgZmFpbGVkJywgZmFsbGJhY2tFcnIpO1xuICAgICAgICAgICAgdGhyb3cgc2VuZEVycjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBVcGRhdGUgc3RhdHVzXG4gICAgb25TdGF0dXNVcGRhdGU/LihgVHJhbnNhY3Rpb24gc3VibWl0dGVkISBIYXNoOiAke2hhc2h9LiBXYWl0aW5nIGZvciBjb25maXJtYXRpb24uLi5gKTtcbiAgICAvLyBXYWl0IGZvciB0cmFuc2FjdGlvbiByZWNlaXB0ICh1c2UgUlBDLCBub3Qgd2FsbGV0IHByb3ZpZGVyKVxuICAgIGNvbnN0IHJlY2VpcHQgPSBhd2FpdCByZWFkQ2xpZW50LndhaXRGb3JUcmFuc2FjdGlvblJlY2VpcHQoeyBoYXNoIH0pO1xuICAgIC8vIEV4dHJhY3QgYWdlbnRJZCBpZiByZXF1ZXN0ZWQgKGZvciBhZ2VudCBjcmVhdGlvbiB0cmFuc2FjdGlvbnMpXG4gICAgbGV0IGFnZW50SWQ7XG4gICAgaWYgKHJlY2VpcHQgJiYgQXJyYXkuaXNBcnJheShyZWNlaXB0LmxvZ3MpKSB7XG4gICAgICAgIGNvbnN0IHplcm9Ub3BpYyA9ICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnO1xuICAgICAgICBjb25zdCB0cmFuc2ZlclRvcGljID0gJzB4ZGRmMjUyYWQxYmUyYzg5YjY5YzJiMDY4ZmMzNzhkYWE5NTJiYTdmMTYzYzRhMTE2MjhmNTVhNGRmNTIzYjNlZic7XG4gICAgICAgIGNvbnN0IG1pbnRMb2cgPSByZWNlaXB0LmxvZ3MuZmluZCgobG9nKSA9PiBsb2c/LnRvcGljcz8uWzBdID09PSB0cmFuc2ZlclRvcGljICYmXG4gICAgICAgICAgICAobG9nPy50b3BpY3M/LlsxXSA9PT0gemVyb1RvcGljIHx8IGxvZz8udG9waWNzPy5bMV0gPT09IHVuZGVmaW5lZCkpO1xuICAgICAgICBpZiAobWludExvZykge1xuICAgICAgICAgICAgY29uc3QgdG9rZW5Ub3BpYyA9IG1pbnRMb2cudG9waWNzPy5bM107XG4gICAgICAgICAgICBjb25zdCB0b2tlbkRhdGEgPSBtaW50TG9nLmRhdGE7XG4gICAgICAgICAgICBjb25zdCB0b2tlbkhleCA9IHRva2VuVG9waWMgPz8gdG9rZW5EYXRhO1xuICAgICAgICAgICAgaWYgKHRva2VuSGV4KSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgYWdlbnRJZCA9IEJpZ0ludCh0b2tlbkhleCkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignVW5hYmxlIHRvIHBhcnNlIGFnZW50SWQgZnJvbSBtaW50IGxvZzonLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChleHRyYWN0QWdlbnRJZCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYWdlbnRJZCA9IGV4dHJhY3RBZ2VudElkRnJvbVJlY2VpcHQocmVjZWlwdCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ0NvdWxkIG5vdCBleHRyYWN0IGFnZW50SWQgZnJvbSByZWNlaXB0OicsIGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBoYXNoLFxuICAgICAgICByZWNlaXB0LFxuICAgICAgICBhZ2VudElkLFxuICAgIH07XG59XG4vKipcbiAqIEV4dHJhY3QgYWdlbnRJZCBmcm9tIGEgdHJhbnNhY3Rpb24gcmVjZWlwdCAoZm9yIGFnZW50IGNyZWF0aW9uKVxuICogTG9va3MgZm9yIEVSQy03MjEgVHJhbnNmZXIgZXZlbnQgZnJvbSB6ZXJvIGFkZHJlc3NcbiAqXG4gKiBAcGFyYW0gcmVjZWlwdCAtIFRyYW5zYWN0aW9uIHJlY2VpcHRcbiAqIEByZXR1cm5zIEV4dHJhY3RlZCBhZ2VudElkIGFzIHN0cmluZywgb3IgdW5kZWZpbmVkIGlmIG5vdCBmb3VuZFxuICovXG5leHBvcnQgZnVuY3Rpb24gZXh0cmFjdEFnZW50SWRGcm9tUmVjZWlwdChyZWNlaXB0KSB7XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gRVJDLTcyMSBUcmFuc2ZlciBldmVudCBzaWduYXR1cmVcbiAgICAgICAgY29uc3QgdHJhbnNmZXJUb3BpYyA9ICcweGRkZjI1MmFkMWJlMmM4OWI2OWMyYjA2OGZjMzc4ZGFhOTUyYmE3ZjE2M2M0YTExNjI4ZjU1YTRkZjUyM2IzZWYnO1xuICAgICAgICAvLyBaZXJvIGFkZHJlc3MgdG9waWMgKGZyb20gYWRkcmVzcylcbiAgICAgICAgY29uc3QgemVyb0FkZHJlc3MgPSAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJztcbiAgICAgICAgaWYgKCFyZWNlaXB0LmxvZ3MgfHwgIUFycmF5LmlzQXJyYXkocmVjZWlwdC5sb2dzKSkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGxvZyBvZiByZWNlaXB0LmxvZ3MpIHtcbiAgICAgICAgICAgIGlmIChsb2cudG9waWNzICYmXG4gICAgICAgICAgICAgICAgbG9nLnRvcGljc1swXSA9PT0gdHJhbnNmZXJUb3BpYyAmJlxuICAgICAgICAgICAgICAgIGxvZy50b3BpY3NbMV0gPT09IHplcm9BZGRyZXNzKSB7XG4gICAgICAgICAgICAgICAgLy8gRXh0cmFjdCB0b2tlbklkIChhZ2VudElkKSBmcm9tIHRvcGljc1szXVxuICAgICAgICAgICAgICAgIGlmIChsb2cudG9waWNzWzNdKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBCaWdJbnQobG9nLnRvcGljc1szXSkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignRXJyb3IgZXh0cmFjdGluZyBhZ2VudElkIGZyb20gcmVjZWlwdDonLCBlcnJvcik7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxufVxuLyoqXG4gKiBSZWZyZXNoIGFnZW50IGluIEdyYXBoUUwgaW5kZXhlclxuICpcbiAqIEBwYXJhbSBhZ2VudElkIC0gQWdlbnQgSUQgdG8gcmVmcmVzaFxuICogQHBhcmFtIGNoYWluSWQgLSBDaGFpbiBJRCBmb3IgdGhlIGFnZW50XG4gKiBAcGFyYW0gcmVmcmVzaEVuZHBvaW50IC0gT3B0aW9uYWwgY3VzdG9tIHJlZnJlc2ggZW5kcG9pbnQgKGRlZmF1bHRzIHRvIGAvYXBpL2FnZW50cy88ZGlkPi9yZWZyZXNoYClcbiAqIEByZXR1cm5zIFByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIHJlZnJlc2ggaXMgY29tcGxldGVcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJlZnJlc2hBZ2VudEluSW5kZXhlcihhZ2VudElkLCBjaGFpbklkLCByZWZyZXNoRW5kcG9pbnQpIHtcbiAgICBjb25zdCBjaGFpbklkU3RyID0gdHlwZW9mIGNoYWluSWQgPT09ICdudW1iZXInID8gY2hhaW5JZC50b1N0cmluZygxMCkgOiBjaGFpbklkPy50b1N0cmluZygpID8/ICcnO1xuICAgIGlmICghY2hhaW5JZFN0ci50cmltKCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDaGFpbiBJRCBpcyByZXF1aXJlZCB0byByZWZyZXNoIGFnZW50IGluIGluZGV4ZXInKTtcbiAgICB9XG4gICAgY29uc3QgZGlkID0gZW5jb2RlVVJJQ29tcG9uZW50KGBkaWQ6ODAwNDoke2NoYWluSWRTdHIudHJpbSgpfToke2FnZW50SWR9YCk7XG4gICAgY29uc3QgZW5kcG9pbnQgPSByZWZyZXNoRW5kcG9pbnQgfHwgYC9hcGkvYWdlbnRzLyR7ZGlkfS9yZWZyZXNoYDtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGVuZHBvaW50LCB7XG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHt9KSwgLy8gU2VuZCBlbXB0eSBib2R5IHRvIGF2b2lkIEpTT04gcGFyc2luZyBlcnJvcnNcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yVGV4dCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgRmFpbGVkIHRvIHJlZnJlc2ggYWdlbnQgJHthZ2VudElkfSBpbiBHcmFwaFFMIGluZGV4ZXI6ICR7cmVzcG9uc2Uuc3RhdHVzfSAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YCwgZXJyb3JUZXh0KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBUcnkgdG8gcGFyc2UgcmVzcG9uc2UsIGJ1dCBkb24ndCBmYWlsIGlmIGl0J3MgZW1wdHlcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhg4pyFIFJlZnJlc2hlZCBhZ2VudCAke2FnZW50SWR9IGluIEdyYXBoUUwgaW5kZXhlcmAsIGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChwYXJzZUVycm9yKSB7XG4gICAgICAgICAgICAvLyBSZXNwb25zZSBtaWdodCBiZSBlbXB0eSwgdGhhdCdzIG9rYXlcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGDinIUgUmVmcmVzaGVkIGFnZW50ICR7YWdlbnRJZH0gaW4gR3JhcGhRTCBpbmRleGVyYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihgRXJyb3IgcmVmcmVzaGluZyBhZ2VudCAke2FnZW50SWR9IGluIEdyYXBoUUwgaW5kZXhlcjpgLCBlcnJvcik7XG4gICAgfVxufVxuLyoqXG4gKiBDaGVjayBpZiB3YWxsZXQgcHJvdmlkZXIgaXMgYXZhaWxhYmxlXG4gKlxuICogQHBhcmFtIGV0aGVyZXVtUHJvdmlkZXIgLSBPcHRpb25hbCBwcm92aWRlciAoZGVmYXVsdHMgdG8gd2luZG93LmV0aGVyZXVtKVxuICogQHJldHVybnMgdHJ1ZSBpZiBwcm92aWRlciBpcyBhdmFpbGFibGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzV2FsbGV0UHJvdmlkZXJBdmFpbGFibGUoZXRoZXJldW1Qcm92aWRlcikge1xuICAgIGlmIChldGhlcmV1bVByb3ZpZGVyKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gISF3aW5kb3cuZXRoZXJldW07XG59XG4vKipcbiAqIEdldCB0aGUgY29ubmVjdGVkIHdhbGxldCBhZGRyZXNzIGZyb20gcHJvdmlkZXJcbiAqXG4gKiBAcGFyYW0gZXRoZXJldW1Qcm92aWRlciAtIE9wdGlvbmFsIHByb3ZpZGVyIChkZWZhdWx0cyB0byB3aW5kb3cuZXRoZXJldW0pXG4gKiBAcmV0dXJucyBDb25uZWN0ZWQgd2FsbGV0IGFkZHJlc3MsIG9yIG51bGwgaWYgbm90IGNvbm5lY3RlZFxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0V2FsbGV0QWRkcmVzcyhldGhlcmV1bVByb3ZpZGVyKSB7XG4gICAgY29uc3QgcHJvdmlkZXIgPSBldGhlcmV1bVByb3ZpZGVyIHx8XG4gICAgICAgICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdy5ldGhlcmV1bSA6IG51bGwpO1xuICAgIGlmICghcHJvdmlkZXIpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGFjY291bnRzID0gYXdhaXQgcHJvdmlkZXIucmVxdWVzdCh7IG1ldGhvZDogJ2V0aF9hY2NvdW50cycgfSk7XG4gICAgICAgIGlmIChhY2NvdW50cyAmJiBhY2NvdW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4gYWNjb3VudHNbMF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLndhcm4oJ0Vycm9yIGdldHRpbmcgd2FsbGV0IGFkZHJlc3M6JywgZXJyb3IpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG4vKipcbiAqIENyZWF0ZSBhbiBhZ2VudCB3aXRoIGF1dG9tYXRpYyB3YWxsZXQgc2lnbmluZyBpZiBuZWVkZWRcbiAqXG4gKiBUaGlzIG1ldGhvZCBoYW5kbGVzIHRoZSBlbnRpcmUgZmxvdzpcbiAqIDEuIENhbGxzIHRoZSBBUEkgdG8gY3JlYXRlIGFnZW50IChlbmRwb2ludDogL2FwaS9hZ2VudHMvY3JlYXRlKVxuICogMi4gSWYgY2xpZW50LXNpZGUgc2lnbmluZyBpcyByZXF1aXJlZCwgc2lnbnMgYW5kIHNlbmRzIHRyYW5zYWN0aW9uXG4gKiAzLiBXYWl0cyBmb3IgcmVjZWlwdCBhbmQgZXh0cmFjdHMgYWdlbnRJZFxuICogNC4gUmVmcmVzaGVzIEdyYXBoUUwgaW5kZXhlclxuICpcbiAqIE9ubHkgYWdlbnREYXRhIGlzIHJlcXVpcmVkIC0gYWNjb3VudCwgY2hhaW4sIGFuZCBwcm92aWRlciBhcmUgYXV0by1kZXRlY3RlZFxuICpcbiAqIEBwYXJhbSBvcHRpb25zIC0gQ3JlYXRpb24gb3B0aW9ucyAob25seSBhZ2VudERhdGEgcmVxdWlyZWQpXG4gKiBAcmV0dXJucyBBZ2VudCBjcmVhdGlvbiByZXN1bHRcbiAqL1xuYXN5bmMgZnVuY3Rpb24gY3JlYXRlQWdlbnRXaXRoV2FsbGV0RU9BKG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IGFnZW50RGF0YSwgYWNjb3VudDogcHJvdmlkZWRBY2NvdW50LCBldGhlcmV1bVByb3ZpZGVyOiBwcm92aWRlZFByb3ZpZGVyLCBycGNVcmw6IHByb3ZpZGVkUnBjVXJsLCBvblN0YXR1c1VwZGF0ZSwgY2hhaW5JZDogcmVxdWVzdGVkQ2hhaW5JZCwgfSA9IG9wdGlvbnM7XG4gICAgLy8gR2V0IHdhbGxldCBwcm92aWRlciAoZGVmYXVsdCB0byB3aW5kb3cuZXRoZXJldW0pXG4gICAgY29uc3QgZXRoZXJldW1Qcm92aWRlciA9IHByb3ZpZGVkUHJvdmlkZXIgfHxcbiAgICAgICAgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93LmV0aGVyZXVtIDogbnVsbCk7XG4gICAgaWYgKCFldGhlcmV1bVByb3ZpZGVyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gd2FsbGV0IHByb3ZpZGVyIGZvdW5kLiBQbGVhc2UgY29ubmVjdCBNZXRhTWFzayBvciB1c2UgYW4gRUlQLTExOTMgY29tcGF0aWJsZSB3YWxsZXQuJyk7XG4gICAgfVxuICAgIC8vIEdldCBhY2NvdW50IGZyb20gcHJvdmlkZXIgaWYgbm90IHByb3ZpZGVkXG4gICAgbGV0IGFjY291bnQ7XG4gICAgaWYgKHByb3ZpZGVkQWNjb3VudCkge1xuICAgICAgICBhY2NvdW50ID0gcHJvdmlkZWRBY2NvdW50O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgYWNjb3VudCA9IGF3YWl0IGVuc3VyZUF1dGhvcml6ZWRBY2NvdW50KGV0aGVyZXVtUHJvdmlkZXIpO1xuICAgIH1cbiAgICAvLyBTdGVwIDE6IENhbGwgQVBJIHRvIGNyZWF0ZSBhZ2VudFxuICAgIG9uU3RhdHVzVXBkYXRlPy4oJ0NyZWF0aW5nIGFnZW50Li4uJyk7XG4gICAgY29uc3QgcGxhbiA9IGF3YWl0IGNhbGxDcmVhdGVBZ2VudEVuZHBvaW50KHtcbiAgICAgICAgbW9kZTogJ2VvYScsXG4gICAgICAgIGFnZW50TmFtZTogYWdlbnREYXRhLmFnZW50TmFtZSxcbiAgICAgICAgYWdlbnRBY2NvdW50OiBhZ2VudERhdGEuYWdlbnRBY2NvdW50LFxuICAgICAgICBhZ2VudENhdGVnb3J5OiBhZ2VudERhdGEuYWdlbnRDYXRlZ29yeSxcbiAgICAgICAgc3VwcG9ydGVkVHJ1c3Q6IGFnZW50RGF0YS5zdXBwb3J0ZWRUcnVzdCxcbiAgICAgICAgZGVzY3JpcHRpb246IGFnZW50RGF0YS5kZXNjcmlwdGlvbixcbiAgICAgICAgaW1hZ2U6IGFnZW50RGF0YS5pbWFnZSxcbiAgICAgICAgYWdlbnRVcmw6IGFnZW50RGF0YS5hZ2VudFVybCxcbiAgICAgICAgZW5kcG9pbnRzOiBhZ2VudERhdGEuZW5kcG9pbnRzLFxuICAgICAgICBjaGFpbklkOiByZXF1ZXN0ZWRDaGFpbklkLFxuICAgIH0pO1xuICAgIGlmIChwbGFuLm1vZGUgIT09ICdlb2EnIHx8ICFwbGFuLnRyYW5zYWN0aW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignU2VydmVyIHJlc3BvbnNlIG1pc3NpbmcgRU9BIHRyYW5zYWN0aW9uIGRldGFpbHMnKTtcbiAgICB9XG4gICAgY29uc3QgY2hhaW4gPSBnZXRDaGFpbkJ5SWQocGxhbi5jaGFpbklkKTtcbiAgICBjb25zdCBwcmVwYXJlZFR4ID0ge1xuICAgICAgICB0bzogcGxhbi50cmFuc2FjdGlvbi50byxcbiAgICAgICAgZGF0YTogcGxhbi50cmFuc2FjdGlvbi5kYXRhLFxuICAgICAgICB2YWx1ZTogKHBsYW4udHJhbnNhY3Rpb24udmFsdWUgPz8gJzAnKSxcbiAgICAgICAgZ2FzOiBwbGFuLnRyYW5zYWN0aW9uLmdhcyxcbiAgICAgICAgZ2FzUHJpY2U6IHBsYW4udHJhbnNhY3Rpb24uZ2FzUHJpY2UsXG4gICAgICAgIG1heEZlZVBlckdhczogcGxhbi50cmFuc2FjdGlvbi5tYXhGZWVQZXJHYXMsXG4gICAgICAgIG1heFByaW9yaXR5RmVlUGVyR2FzOiBwbGFuLnRyYW5zYWN0aW9uLm1heFByaW9yaXR5RmVlUGVyR2FzLFxuICAgICAgICBub25jZTogcGxhbi50cmFuc2FjdGlvbi5ub25jZSxcbiAgICAgICAgY2hhaW5JZDogcGxhbi50cmFuc2FjdGlvbi5jaGFpbklkLFxuICAgIH07XG4gICAgLy8gU2lnbiBhbmQgc2VuZCB0cmFuc2FjdGlvblxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHNpZ25BbmRTZW5kVHJhbnNhY3Rpb24oe1xuICAgICAgICB0cmFuc2FjdGlvbjogcHJlcGFyZWRUeCxcbiAgICAgICAgYWNjb3VudCxcbiAgICAgICAgY2hhaW4sXG4gICAgICAgIGV0aGVyZXVtUHJvdmlkZXIsXG4gICAgICAgIG9uU3RhdHVzVXBkYXRlLFxuICAgICAgICBleHRyYWN0QWdlbnRJZDogdHJ1ZSxcbiAgICB9KTtcbiAgICBpZiAocmVzdWx0LmFnZW50SWQpIHtcbiAgICAgICAgLy8gQWZ0ZXIgcmVnaXN0cmF0aW9uLCBzZXQgYWdlbnRXYWxsZXQgb24tY2hhaW4gQkVGT1JFIG5vdGlmeWluZyB0aGUgaW5kZXhlci5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGlkZW50aXR5UmVnaXN0cnkgPSBwbGFuLmlkZW50aXR5UmVnaXN0cnk7XG4gICAgICAgICAgICBpZiAoIWlkZW50aXR5UmVnaXN0cnkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgaWRlbnRpdHlSZWdpc3RyeSBpbiBjcmVhdGUtYWdlbnQgcGxhbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdmllbVdhbGxldENsaWVudCA9IGNyZWF0ZVdhbGxldENsaWVudCh7XG4gICAgICAgICAgICAgICAgYWNjb3VudCxcbiAgICAgICAgICAgICAgICBjaGFpbixcbiAgICAgICAgICAgICAgICB0cmFuc3BvcnQ6IGN1c3RvbShldGhlcmV1bVByb3ZpZGVyKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgdmllbVB1YmxpY0NsaWVudCA9IGNyZWF0ZVB1YmxpY0NsaWVudCh7XG4gICAgICAgICAgICAgICAgY2hhaW4sXG4gICAgICAgICAgICAgICAgdHJhbnNwb3J0OiBjdXN0b20oZXRoZXJldW1Qcm92aWRlciksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGlkZW50aXR5Q2xpZW50ID0gbmV3IEFJQWdlbnRJZGVudGl0eUNsaWVudCh7XG4gICAgICAgICAgICAgICAgcHVibGljQ2xpZW50OiB2aWVtUHVibGljQ2xpZW50LFxuICAgICAgICAgICAgICAgIHdhbGxldENsaWVudDogdmllbVdhbGxldENsaWVudCxcbiAgICAgICAgICAgICAgICBpZGVudGl0eVJlZ2lzdHJ5QWRkcmVzczogaWRlbnRpdHlSZWdpc3RyeSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgRUlQNzEyX0RPTUFJTl9BQkkgPSBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnZnVuY3Rpb24nLFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnZWlwNzEyRG9tYWluJyxcbiAgICAgICAgICAgICAgICAgICAgc3RhdGVNdXRhYmlsaXR5OiAndmlldycsXG4gICAgICAgICAgICAgICAgICAgIGlucHV0czogW10sXG4gICAgICAgICAgICAgICAgICAgIG91dHB1dHM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ25hbWUnLCB0eXBlOiAnc3RyaW5nJyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAndmVyc2lvbicsIHR5cGU6ICdzdHJpbmcnIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWU6ICdjaGFpbklkJywgdHlwZTogJ3VpbnQyNTYnIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWU6ICd2ZXJpZnlpbmdDb250cmFjdCcsIHR5cGU6ICdhZGRyZXNzJyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAnc2FsdCcsIHR5cGU6ICdieXRlczMyJyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAnZXh0ZW5zaW9ucycsIHR5cGU6ICd1aW50MjU2W10nIH0sXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICBjb25zdCBkb21haW5SYXcgPSAoYXdhaXQgdmllbVB1YmxpY0NsaWVudC5yZWFkQ29udHJhY3Qoe1xuICAgICAgICAgICAgICAgIGFkZHJlc3M6IGlkZW50aXR5UmVnaXN0cnksXG4gICAgICAgICAgICAgICAgYWJpOiBFSVA3MTJfRE9NQUlOX0FCSSxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbk5hbWU6ICdlaXA3MTJEb21haW4nLFxuICAgICAgICAgICAgICAgIGFyZ3M6IFtdLFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgY29uc3QgZG9tYWluID0ge1xuICAgICAgICAgICAgICAgIG5hbWU6IFN0cmluZyhkb21haW5SYXc/Lm5hbWUgPz8gZG9tYWluUmF3Py5bMF0gPz8gJycpLFxuICAgICAgICAgICAgICAgIHZlcnNpb246IFN0cmluZyhkb21haW5SYXc/LnZlcnNpb24gPz8gZG9tYWluUmF3Py5bMV0gPz8gJycpLFxuICAgICAgICAgICAgICAgIGNoYWluSWQ6IE51bWJlcihkb21haW5SYXc/LmNoYWluSWQgPz8gZG9tYWluUmF3Py5bMl0gPz8gY2hhaW4uaWQpLFxuICAgICAgICAgICAgICAgIHZlcmlmeWluZ0NvbnRyYWN0OiAoZG9tYWluUmF3Py52ZXJpZnlpbmdDb250cmFjdCA/PyBkb21haW5SYXc/LlszXSksXG4gICAgICAgICAgICAgICAgc2FsdDogKGRvbWFpblJhdz8uc2FsdCA/PyBkb21haW5SYXc/Lls0XSksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgYWdlbnRJZEJpZ0ludCA9IEJpZ0ludChyZXN1bHQuYWdlbnRJZCk7XG4gICAgICAgICAgICBjb25zdCBkZWFkbGluZSA9IEJpZ0ludChNYXRoLmZsb29yKERhdGUubm93KCkgLyAxMDAwKSArIDYwICogNjApOyAvLyArMWhcbiAgICAgICAgICAgIGNvbnN0IG5ld1dhbGxldCA9IGdldEFkZHJlc3MoYWNjb3VudCk7XG4gICAgICAgICAgICBvblN0YXR1c1VwZGF0ZT8uKCdNZXRhTWFzayBzaWduYXR1cmU6IHNldCBhZ2VudCB3YWxsZXQgKElkZW50aXR5UmVnaXN0cnkpJyk7XG4gICAgICAgICAgICBjb25zdCBzaWduYXR1cmUgPSAoYXdhaXQgdmllbVdhbGxldENsaWVudC5zaWduVHlwZWREYXRhKHtcbiAgICAgICAgICAgICAgICBhY2NvdW50LFxuICAgICAgICAgICAgICAgIGRvbWFpbixcbiAgICAgICAgICAgICAgICBwcmltYXJ5VHlwZTogJ1NldEFnZW50V2FsbGV0JyxcbiAgICAgICAgICAgICAgICB0eXBlczoge1xuICAgICAgICAgICAgICAgICAgICBTZXRBZ2VudFdhbGxldDogW1xuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAnYWdlbnRJZCcsIHR5cGU6ICd1aW50MjU2JyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAnbmV3V2FsbGV0JywgdHlwZTogJ2FkZHJlc3MnIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWU6ICdkZWFkbGluZScsIHR5cGU6ICd1aW50MjU2JyB9LFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogeyBhZ2VudElkOiBhZ2VudElkQmlnSW50LCBuZXdXYWxsZXQsIGRlYWRsaW5lIH0sXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICBjb25zdCB7IGNhbGxzIH0gPSBhd2FpdCBpZGVudGl0eUNsaWVudC5wcmVwYXJlU2V0QWdlbnRXYWxsZXRDYWxscyhhZ2VudElkQmlnSW50LCBuZXdXYWxsZXQsIGRlYWRsaW5lLCBzaWduYXR1cmUpO1xuICAgICAgICAgICAgY29uc3QgY2FsbCA9IGNhbGxzWzBdO1xuICAgICAgICAgICAgaWYgKCFjYWxsKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncHJlcGFyZVNldEFnZW50V2FsbGV0Q2FsbHMgcmV0dXJuZWQgbm8gY2FsbHMnKTtcbiAgICAgICAgICAgIGF3YWl0IHNpZ25BbmRTZW5kVHJhbnNhY3Rpb24oe1xuICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uOiB7XG4gICAgICAgICAgICAgICAgICAgIHRvOiBjYWxsLnRvLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBjYWxsLmRhdGEsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiAnMHgwJyxcbiAgICAgICAgICAgICAgICAgICAgY2hhaW5JZDogY2hhaW4uaWQsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBhY2NvdW50LFxuICAgICAgICAgICAgICAgIGNoYWluLFxuICAgICAgICAgICAgICAgIGV0aGVyZXVtUHJvdmlkZXIsXG4gICAgICAgICAgICAgICAgb25TdGF0dXNVcGRhdGUsXG4gICAgICAgICAgICAgICAgZXh0cmFjdEFnZW50SWQ6IGZhbHNlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignW2NyZWF0ZUFnZW50V2l0aFdhbGxldEVPQV0gc2V0QWdlbnRXYWxsZXQgZmFpbGVkIChub24tZmF0YWwpOicsIGUpO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHJlZnJlc2hBZ2VudEluSW5kZXhlcihyZXN1bHQuYWdlbnRJZCwgcGxhbi5jaGFpbklkKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYWdlbnRJZDogcmVzdWx0LmFnZW50SWQsXG4gICAgICAgIHR4SGFzaDogcmVzdWx0Lmhhc2gsXG4gICAgICAgIHJlcXVpcmVzQ2xpZW50U2lnbmluZzogdHJ1ZSxcbiAgICB9O1xufVxuLyoqXG4gKiBDcmVhdGUgYW4gYWdlbnQgd2l0aCBBY2NvdW50IEFic3RyYWN0aW9uIChBQSkgdXNpbmcgYSB3YWxsZXRcbiAqXG4gKiBUaGlzIGNsaWVudC1zaWRlIGZ1bmN0aW9uIGhhbmRsZXMgdGhlIGNvbXBsZXRlIEFBIGFnZW50IGNyZWF0aW9uIGZsb3c6XG4gKiAxLiBEZXRlY3RzIHdhbGxldCBwcm92aWRlciBhbmQgYWNjb3VudFxuICogMi4gQ3JlYXRlcy9yZXRyaWV2ZXMgQUEgYWNjb3VudCBjbGllbnQgZm9yIHRoZSBhZ2VudFxuICogMy4gQ2FsbHMgdGhlIHNlcnZlciBBUEkgcm91dGUgYC9hcGkvYWdlbnRzL2NyZWF0ZWAgdG8gcHJlcGFyZSByZWdpc3RyYXRpb25cbiAqIDQuIFNlbmRzIFVzZXJPcGVyYXRpb24gdmlhIGJ1bmRsZXIgdXNpbmcgdGhlIEFBIGFjY291bnRcbiAqIDUuIEV4dHJhY3RzIGFnZW50SWQgYW5kIHJlZnJlc2hlcyB0aGUgaW5kZXhlclxuICpcbiAqICoqU2V0dXAgUmVxdWlyZWQ6KipcbiAqIFlvdXIgTmV4dC5qcyBhcHAgbXVzdCBtb3VudCB0aGUgQVBJIHJvdXRlIGhhbmRsZXI6XG4gKlxuICogYGBgdHlwZXNjcmlwdFxuICogLy8gSW4gYXBwL2FwaS9hZ2VudHMvY3JlYXRlL3JvdXRlLnRzXG4gKiBpbXBvcnQgeyBjcmVhdGVBZ2VudFJvdXRlSGFuZGxlciB9IGZyb20gJ0BhZ2VudGljLXRydXN0L2NvcmUvc2VydmVyJztcbiAqIGV4cG9ydCBjb25zdCBQT1NUID0gY3JlYXRlQWdlbnRSb3V0ZUhhbmRsZXIoKTtcbiAqIGBgYFxuICpcbiAqICoqVXNhZ2U6KipcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGltcG9ydCB7IGNyZWF0ZUFnZW50V2l0aFdhbGxldCB9IGZyb20gJ0BhZ2VudGljLXRydXN0L2NvcmUvY2xpZW50JztcbiAqXG4gKiBjb25zdCByZXN1bHQgPSBhd2FpdCBjcmVhdGVBZ2VudFdpdGhXYWxsZXQoe1xuICogICBhZ2VudERhdGE6IHtcbiAqICAgICBhZ2VudE5hbWU6ICdteS1hZ2VudCcsXG4gKiAgICAgYWdlbnRBY2NvdW50OiAnMHguLi4nLCAvLyBBQSBhY2NvdW50IGFkZHJlc3NcbiAqICAgICBkZXNjcmlwdGlvbjogJ015IGFnZW50JyxcbiAqICAgfSxcbiAqICAgb25TdGF0dXNVcGRhdGU6IChtc2cpID0+IGNvbnNvbGUubG9nKG1zZyksXG4gKiB9KTtcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBvcHRpb25zIC0gQWdlbnQgY3JlYXRpb24gb3B0aW9uc1xuICogQHJldHVybnMgQWdlbnQgY3JlYXRpb24gcmVzdWx0IHdpdGggYWdlbnRJZCBhbmQgdHhIYXNoXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGNyZWF0ZUFnZW50V2l0aFdhbGxldEFBKG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IGFnZW50RGF0YSwgYWNjb3VudDogcHJvdmlkZWRBY2NvdW50LCBldGhlcmV1bVByb3ZpZGVyOiBwcm92aWRlZFByb3ZpZGVyLCBycGNVcmw6IHByb3ZpZGVkUnBjVXJsLCBvblN0YXR1c1VwZGF0ZSwgY2hhaW5JZDogcHJvdmlkZWRDaGFpbklkLCB9ID0gb3B0aW9ucztcbiAgICAvLyBHZXQgd2FsbGV0IHByb3ZpZGVyIChkZWZhdWx0IHRvIHdpbmRvdy5ldGhlcmV1bSlcbiAgICBjb25zdCBldGhlcmV1bVByb3ZpZGVyID0gcmVzb2x2ZUV0aGVyZXVtUHJvdmlkZXIocHJvdmlkZWRQcm92aWRlcik7XG4gICAgaWYgKCFldGhlcmV1bVByb3ZpZGVyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gd2FsbGV0IHByb3ZpZGVyIGZvdW5kLiBQbGVhc2UgY29ubmVjdCBNZXRhTWFzayBvciB1c2UgYW4gRUlQLTExOTMgY29tcGF0aWJsZSB3YWxsZXQuJyk7XG4gICAgfVxuICAgIC8vIEdldCBhY2NvdW50IGZyb20gcHJvdmlkZXIgaWYgbm90IHByb3ZpZGVkXG4gICAgbGV0IGFjY291bnQ7XG4gICAgaWYgKHByb3ZpZGVkQWNjb3VudCkge1xuICAgICAgICBhY2NvdW50ID0gcHJvdmlkZWRBY2NvdW50O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgYWNjb3VudCA9IGF3YWl0IGVuc3VyZUF1dGhvcml6ZWRBY2NvdW50KGV0aGVyZXVtUHJvdmlkZXIpO1xuICAgIH1cbiAgICBjb25zdCBjaGFpbklkID0gdHlwZW9mIHByb3ZpZGVkQ2hhaW5JZCA9PT0gJ251bWJlcidcbiAgICAgICAgPyBwcm92aWRlZENoYWluSWRcbiAgICAgICAgOiBhd2FpdCByZXNvbHZlQ2hhaW5JZChldGhlcmV1bVByb3ZpZGVyKTtcbiAgICAvLyBTdGVwIDE6IENhbGwgQVBJIHRvIGNyZWF0ZSBhZ2VudFxuICAgIG9uU3RhdHVzVXBkYXRlPy4oJ0NyZWF0aW5nIGFnZW50Li4uJyk7XG4gICAgLy8gMC4gIEdldCBvbiB0aGUgY29ycmVjdCBjaGFpbiBnZXQgYWRhcHRlciBmb3IgdGhlIGNoYWluXG4gICAgbGV0IGNoYWluO1xuICAgIHN3aXRjaCAoY2hhaW5JZCkge1xuICAgICAgICBjYXNlIDExMTU1MTExOiAvLyBFVEggU2Vwb2xpYVxuICAgICAgICAgICAgY2hhaW4gPSBzZXBvbGlhO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgODQ1MzI6IC8vIEJhc2UgU2Vwb2xpYVxuICAgICAgICAgICAgY2hhaW4gPSBiYXNlU2Vwb2xpYTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDExMTU1NDIwOiAvLyBPcHRpbWlzbSBTZXBvbGlhXG4gICAgICAgICAgICBjaGFpbiA9IG9wdGltaXNtU2Vwb2xpYTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgY2hhaW4gPSBzZXBvbGlhO1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGBVbmtub3duIGNoYWluSWQgJHtjaGFpbklkfSwgZGVmYXVsdGluZyB0byBTZXBvbGlhYCk7XG4gICAgfVxuICAgIC8vIEVuc3VyZSBwcm92aWRlciBpcyBvbiB0aGUgcmVxdWlyZWQgY2hhaW4gYmVmb3JlIGJ1aWxkaW5nIGNsaWVudHNcbiAgICB0cnkge1xuICAgICAgICBhd2FpdCBlbnN1cmVDaGFpblNlbGVjdGVkKGV0aGVyZXVtUHJvdmlkZXIsIGNoYWluKTtcbiAgICB9XG4gICAgY2F0Y2ggKHN3aXRjaEVycikge1xuICAgICAgICBjb25zb2xlLndhcm4oJ1VuYWJsZSB0byBzd2l0Y2ggY2hhaW4gb24gcHJvdmlkZXIgZm9yIEFBIGZsb3c6Jywgc3dpdGNoRXJyKTtcbiAgICB9XG4gICAgLy8gQnVpbGQgdmllbSBjbGllbnRzIGJvdW5kIHRvIHRoZSB1c2VyJ3MgV2ViM0F1dGggcHJvdmlkZXJcbiAgICBjb25zdCB2aWVtV2FsbGV0Q2xpZW50ID0gY3JlYXRlV2FsbGV0Q2xpZW50KHtcbiAgICAgICAgYWNjb3VudCxcbiAgICAgICAgY2hhaW4sXG4gICAgICAgIHRyYW5zcG9ydDogY3VzdG9tKGV0aGVyZXVtUHJvdmlkZXIpLFxuICAgIH0pO1xuICAgIGNvbnN0IHZpZW1QdWJsaWNDbGllbnQgPSBjcmVhdGVQdWJsaWNDbGllbnQoe1xuICAgICAgICBjaGFpbixcbiAgICAgICAgdHJhbnNwb3J0OiBjdXN0b20oZXRoZXJldW1Qcm92aWRlciksXG4gICAgfSk7XG4gICAgLy8gMS4gIE5lZWQgdG8gY3JlYXRlIHRoZSBBZ2VudCBBY2NvdW50IEFic3RyYWN0aW9uIChBY2NvdW50KVxuICAgIC8vIEJ1aWxkIEFBIGFjY291bnQgY2xpZW50IHVzaW5nIGNsaWVudCdzIEVPQSAoTWV0YU1hc2svV2ViM0F1dGgpXG4gICAgLy8gR2V0IGFnZW50IG5hbWUgZnJvbSByZXF1ZXN0XG4gICAgLy9sZXQgYWdlbnRGdWxsTmFtZSA9IG9wdGlvbnMuYWdlbnREYXRhLmFnZW50TmFtZTtcbiAgICAvL2lmIChvcHRpb25zLmVuc09wdGlvbnM/Lm9yZ05hbWUpIHtcbiAgICAvLyAgYWdlbnRGdWxsTmFtZSA9IG9wdGlvbnMuYWdlbnREYXRhLmFnZW50TmFtZSArICcuJyArIG9wdGlvbnMuZW5zT3B0aW9ucz8ub3JnTmFtZSArIFwiLmV0aFwiO1xuICAgIC8vfVxuICAgIC8vIEdldCBBY2NvdW50IENsaWVudCBieSBBZ2VudCBOYW1lLCBmaW5kIGlmIGV4aXN0cyBhbmQgaWYgbm90IHRoZW4gY3JlYXRlIGl0XG4gICAgbGV0IGJ1bmRsZXJVcmwgPSBnZXRDaGFpbkJ1bmRsZXJVcmwoY2hhaW5JZCk7XG4gICAgbGV0IGFnZW50QWNjb3VudENsaWVudCA9IGF3YWl0IGdldERlcGxveWVkQWNjb3VudENsaWVudEJ5QWdlbnROYW1lKGJ1bmRsZXJVcmwsIG9wdGlvbnMuYWdlbnREYXRhLmFnZW50TmFtZSwgYWNjb3VudCwge1xuICAgICAgICBjaGFpbjogY2hhaW4sXG4gICAgICAgIHdhbGxldENsaWVudDogdmllbVdhbGxldENsaWVudCxcbiAgICAgICAgcHVibGljQ2xpZW50OiB2aWVtUHVibGljQ2xpZW50LFxuICAgIH0pO1xuICAgIGlmICghYWdlbnRBY2NvdW50Q2xpZW50KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGJ1aWxkIEFBIGFjY291bnQgY2xpZW50Jyk7XG4gICAgfVxuICAgIC8vIFZlcmlmeSB0aGUgYWRkcmVzcyBtYXRjaGVzXG4gICAgY29uc3QgY29tcHV0ZWRBZGRyZXNzID0gYXdhaXQgYWdlbnRBY2NvdW50Q2xpZW50LmdldEFkZHJlc3MoKTtcbiAgICBpZiAoY29tcHV0ZWRBZGRyZXNzLnRvTG93ZXJDYXNlKCkgIT09XG4gICAgICAgIG9wdGlvbnMuYWdlbnREYXRhLmFnZW50QWNjb3VudC50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQUEgYWRkcmVzcyBtaXNtYXRjaDogY29tcHV0ZWQgJHtjb21wdXRlZEFkZHJlc3N9LCBleHBlY3RlZCAke29wdGlvbnMuYWdlbnREYXRhLmFnZW50QWNjb3VudH1gKTtcbiAgICB9XG4gICAgLy8gMi4gIEFkZCBFTlMgcmVjb3JkIGFzc29jaWF0ZWQgd2l0aCBuZXcgYWdlbnRcbiAgICBjb25zb2xlLmxvZygnKioqKioqKioqKiogY3JlYXRlQWdlbnRXaXRoV2FsbGV0OiBvcHRpb25zLmVuc09wdGlvbnMnLCBvcHRpb25zLmVuc09wdGlvbnMpO1xuICAgIGlmIChvcHRpb25zLmVuc09wdGlvbnM/LmVuYWJsZWQgJiZcbiAgICAgICAgb3B0aW9ucy5lbnNPcHRpb25zLm9yZ05hbWUgJiZcbiAgICAgICAgaXNMMShjaGFpbklkKSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgZW5zQWdlbnRBY2NvdW50ID0gdHlwZW9mIGNvbXB1dGVkQWRkcmVzcyA9PT0gJ3N0cmluZycgJiYgY29tcHV0ZWRBZGRyZXNzLnN0YXJ0c1dpdGgoJzB4JylcbiAgICAgICAgICAgICAgICA/IGNvbXB1dGVkQWRkcmVzc1xuICAgICAgICAgICAgICAgIDogb3B0aW9ucy5hZ2VudERhdGEuYWdlbnRBY2NvdW50O1xuICAgICAgICAgICAgb25TdGF0dXNVcGRhdGU/LignQ3JlYXRpbmcgRU5TIHN1YmRvbWFpbiBmb3IgYWdlbnQ6ICcgKyBvcHRpb25zLmFnZW50RGF0YS5hZ2VudE5hbWUpO1xuICAgICAgICAgICAgY29uc3QgcGtNb2RlRGV0ZWN0ZWQgPSBpc1ByaXZhdGVLZXlNb2RlKCk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcImNyZWF0ZUFnZW50V2l0aFdhbGxldDogcGtNb2RlRGV0ZWN0ZWRcIiwgcGtNb2RlRGV0ZWN0ZWQpO1xuICAgICAgICAgICAgY29uc3QgYWRkRW5kcG9pbnQgPSBwa01vZGVEZXRlY3RlZFxuICAgICAgICAgICAgICAgID8gJy9hcGkvbmFtZXMvYWRkLXRvLWwxLW9yZy1waydcbiAgICAgICAgICAgICAgICA6ICcvYXBpL25hbWVzL2FkZC10by1sMS1vcmcnO1xuICAgICAgICAgICAgY29uc29sZS5pbmZvKGBbRU5TXVtMMV0gJHtwa01vZGVEZXRlY3RlZCA/ICdQSyBtb2RlIGRldGVjdGVkIDExMTExJyA6ICdDbGllbnQgbW9kZSd9IC0gY2FsbGluZyAke2FkZEVuZHBvaW50fWApO1xuICAgICAgICAgICAgY29uc3QgZW5zUmVzcG9uc2UgPSBhd2FpdCBmZXRjaChhZGRFbmRwb2ludCwge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9LFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICAgICAgYWdlbnRBY2NvdW50OiBlbnNBZ2VudEFjY291bnQsXG4gICAgICAgICAgICAgICAgICAgIG9yZ05hbWU6IG9wdGlvbnMuZW5zT3B0aW9ucy5vcmdOYW1lLFxuICAgICAgICAgICAgICAgICAgICBhZ2VudE5hbWU6IG9wdGlvbnMuYWdlbnREYXRhLmFnZW50TmFtZSxcbiAgICAgICAgICAgICAgICAgICAgYWdlbnRVcmw6IG9wdGlvbnMuYWdlbnREYXRhLmFnZW50VXJsLFxuICAgICAgICAgICAgICAgICAgICBjaGFpbklkLFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoIWVuc1Jlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyID0gYXdhaXQgZW5zUmVzcG9uc2UuanNvbigpLmNhdGNoKCgpID0+ICh7fSkpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignW0VOU11bTDFdIGFkZC10by1sMS1vcmcgY2FsbCBmYWlsZWQnLCBlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5pbmZvKCdbRU5TXVtMMV0gYWRkLXRvLWwxLW9yZyBjYWxsIHN1Y2NlZWRlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb25TdGF0dXNVcGRhdGU/LignUHJlcGFyaW5nIEVOUyBtZXRhZGF0YSB1cGRhdGUuLi4nKTtcbiAgICAgICAgICAgIGNvbnN0IGluZm9FbmRwb2ludCA9IHBrTW9kZURldGVjdGVkXG4gICAgICAgICAgICAgICAgPyAnL2FwaS9uYW1lcy9zZXQtbDEtbmFtZS1pbmZvLXBrJ1xuICAgICAgICAgICAgICAgIDogJy9hcGkvbmFtZXMvc2V0LWwxLW5hbWUtaW5mbyc7XG4gICAgICAgICAgICBjb25zb2xlLmluZm8oYFtFTlNdW0wxXSAke3BrTW9kZURldGVjdGVkID8gJ1BLIG1vZGUgZGV0ZWN0ZWQgMjIyMjInIDogJ0NsaWVudCBtb2RlJ30gLSBjYWxsaW5nICR7aW5mb0VuZHBvaW50fWApO1xuICAgICAgICAgICAgY29uc3QgaW5mb1Jlc3BvbnNlID0gYXdhaXQgZmV0Y2goaW5mb0VuZHBvaW50LCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH0sXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgICAgICBhZ2VudEFkZHJlc3M6IGVuc0FnZW50QWNjb3VudCxcbiAgICAgICAgICAgICAgICAgICAgb3JnTmFtZTogb3B0aW9ucy5lbnNPcHRpb25zLm9yZ05hbWUsXG4gICAgICAgICAgICAgICAgICAgIGFnZW50TmFtZTogb3B0aW9ucy5hZ2VudERhdGEuYWdlbnROYW1lLFxuICAgICAgICAgICAgICAgICAgICBhZ2VudFVybDogb3B0aW9ucy5hZ2VudERhdGEuYWdlbnRVcmwsXG4gICAgICAgICAgICAgICAgICAgIGFnZW50RGVzY3JpcHRpb246IG9wdGlvbnMuYWdlbnREYXRhLmRlc2NyaXB0aW9uLFxuICAgICAgICAgICAgICAgICAgICBjaGFpbklkLFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoaW5mb1Jlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJyoqKioqKioqKioqIGNyZWF0ZUFnZW50V2l0aFdhbGxldDogRU5TIG1ldGFkYXRhIHJlc3BvbnNlIHJlY2VpdmVkJyk7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5mb0RhdGEgPSBhd2FpdCBpbmZvUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNlcnZlckluZm9Vc2VyT3BIYXNoID0gaW5mb0RhdGE/LnVzZXJPcEhhc2g7XG4gICAgICAgICAgICAgICAgaWYgKHNlcnZlckluZm9Vc2VyT3BIYXNoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCcqKioqKioqKioqKiBjcmVhdGVBZ2VudFdpdGhXYWxsZXQ6IEVOUyBpbmZvIHVzZXJPcEhhc2ggKHNlcnZlci1zdWJtaXR0ZWQpJywgc2VydmVySW5mb1VzZXJPcEhhc2gpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5mb0NhbGxzID0gW107XG4gICAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGluZm9EYXRhPy5jYWxscykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcmF3Q2FsbCBvZiBpbmZvRGF0YS5jYWxscykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRvID0gcmF3Q2FsbD8udG87XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IHJhd0NhbGw/LmRhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0byB8fCAhZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyYXdDYWxsPy52YWx1ZSAhPT0gbnVsbCAmJiByYXdDYWxsPy52YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IEJpZ0ludChyYXdDYWxsLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignVW5hYmxlIHRvIHBhcnNlIEVOUyBpbmZvIGNhbGwgdmFsdWUnLCByYXdDYWxsLnZhbHVlLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5mb0NhbGxzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0byxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGluZm9DYWxscy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvblN0YXR1c1VwZGF0ZT8uKCdNZXRhTWFzayBzaWduYXR1cmU6IHVwZGF0ZSBFTlMgbWV0YWRhdGEgKFVSTC9kZXNjcmlwdGlvbi9pbWFnZSknKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVuc3VyZSB3ZSBhcmUgdXNpbmcgYSBkZXBsb3llZC1vbmx5IEFBIGNsaWVudCAobm8gZmFjdG9yeS9mYWN0b3J5RGF0YSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc3QgZnVsbEFnZW50TmFtZSA9IGFnZW50TmFtZSArICcuJyArIG9wdGlvbnMuZW5zT3B0aW9ucy5vcmdOYW1lICsgXCIuZXRoXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnISEhISEhISEhISEhIGhhbmRsZUNyZWF0ZUFnZW50OiBnZXREZXBsb3llZEFjY291bnRDbGllbnRCeUFnZW50TmFtZSAyOiBhZ2VudE5hbWUnLCBvcHRpb25zLmFnZW50RGF0YS5hZ2VudE5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYWdlbnRBY2NvdW50Q2xpZW50ID0gYXdhaXQgZ2V0RGVwbG95ZWRBY2NvdW50Q2xpZW50QnlBZ2VudE5hbWUoYnVuZGxlclVybCwgb3B0aW9ucy5hZ2VudERhdGEuYWdlbnROYW1lLCBhY2NvdW50LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhaW46IGNoYWluLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdhbGxldENsaWVudDogdmllbVdhbGxldENsaWVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwdWJsaWNDbGllbnQ6IHZpZW1QdWJsaWNDbGllbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGluZm9Vc2VyT3BIYXNoID0gYXdhaXQgc2VuZFNwb25zb3JlZFVzZXJPcGVyYXRpb24oe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1bmRsZXJVcmwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhaW46IGNoYWluLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjY291bnRDbGllbnQ6IGFnZW50QWNjb3VudENsaWVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsczogaW5mb0NhbGxzLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB3YWl0Rm9yVXNlck9wZXJhdGlvblJlY2VpcHQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1bmRsZXJVcmwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhaW46IGNoYWluLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhc2g6IGluZm9Vc2VyT3BIYXNoLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJvclBheWxvYWQgPSBhd2FpdCBpbmZvUmVzcG9uc2UuanNvbigpLmNhdGNoKCgpID0+ICh7fSkpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignRmFpbGVkIHRvIHByZXBhcmUgRU5TIG1ldGFkYXRhIGNhbGxzOicsIGVycm9yUGF5bG9hZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnUmVxdWVzdGVkIEVOUyByZWNvcmQgY3JlYXRpb24gYW5kIG1ldGFkYXRhIHVwZGF0ZSBmb3IgYWdlbnQnLCBvcHRpb25zLmFnZW50RGF0YS5hZ2VudE5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlbnNFcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdGYWlsZWQgdG8gY3JlYXRlIEVOUyByZWNvcmQgZm9yIGFnZW50OicsIGVuc0Vycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChvcHRpb25zLmVuc09wdGlvbnM/LmVuYWJsZWQgJiZcbiAgICAgICAgb3B0aW9ucy5lbnNPcHRpb25zLm9yZ05hbWUgJiZcbiAgICAgICAgaXNMMihjaGFpbklkKSkge1xuICAgICAgICBjb25zdCByYXdPcmcgPSBvcHRpb25zLmVuc09wdGlvbnMub3JnTmFtZSB8fCAnJztcbiAgICAgICAgY29uc3QgcmF3QWdlbnQgPSBvcHRpb25zLmFnZW50RGF0YS5hZ2VudE5hbWUgfHwgJyc7XG4gICAgICAgIGNvbnN0IGNsZWFuT3JnTmFtZSA9IHJhd09yZy5yZXBsYWNlKC9cXC5ldGgkL2ksICcnKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBjb25zdCBvcmdQYXR0ZXJuID0gY2xlYW5PcmdOYW1lLnJlcGxhY2UoL1suKis/XiR7fSgpfFtcXF1cXFxcXS9nLCAnXFxcXCQmJyk7XG4gICAgICAgIGNvbnN0IGNsZWFuQWdlbnROYW1lID0gcmF3QWdlbnRcbiAgICAgICAgICAgIC5yZXBsYWNlKG5ldyBSZWdFeHAoYF4ke29yZ1BhdHRlcm59XFxcXC5gLCAnaScpLCAnJylcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXC5ldGgkL2ksICcnKVxuICAgICAgICAgICAgLnRyaW0oKVxuICAgICAgICAgICAgLnRvTG93ZXJDYXNlKClcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXHMrL2csICctJyk7XG4gICAgICAgIGNvbnN0IGFnZW50VXJsID0gb3B0aW9ucy5hZ2VudERhdGEuYWdlbnRVcmw7XG4gICAgICAgIGNvbnN0IGFnZW50RGVzY3JpcHRpb24gPSBvcHRpb25zLmFnZW50RGF0YS5kZXNjcmlwdGlvbjtcbiAgICAgICAgY29uc3QgYWdlbnRJbWFnZSA9IG9wdGlvbnMuYWdlbnREYXRhLmltYWdlO1xuICAgICAgICAvLyBQcmVwYXJlIGFsbCBuZWNlc3NhcnkgTDIgRU5TIGNhbGxzIHNlcnZlci1zaWRlLCB0aGVuIHNlbmQgdGhlbSBhcyBvbmUgdXNlciBvcGVyYXRpb25cbiAgICAgICAgY29uc3QgcHJlcGFyZVJlc3AgPSBhd2FpdCBmZXRjaCgnL2FwaS9uYW1lcy9hZGQtdG8tbDItb3JnJywge1xuICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICBhZ2VudEFkZHJlc3M6IGFnZW50QWNjb3VudENsaWVudC5hZGRyZXNzLFxuICAgICAgICAgICAgICAgIG9yZ05hbWU6IGNsZWFuT3JnTmFtZSxcbiAgICAgICAgICAgICAgICBhZ2VudE5hbWU6IGNsZWFuQWdlbnROYW1lLFxuICAgICAgICAgICAgICAgIGFnZW50VXJsLFxuICAgICAgICAgICAgICAgIGFnZW50RGVzY3JpcHRpb24sXG4gICAgICAgICAgICAgICAgYWdlbnRJbWFnZSxcbiAgICAgICAgICAgICAgICBjaGFpbklkLFxuICAgICAgICAgICAgfSksXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIXByZXBhcmVSZXNwLm9rKSB7XG4gICAgICAgICAgICBjb25zdCBlcnJvclBheWxvYWQgPSBhd2FpdCBwcmVwYXJlUmVzcC5qc29uKCkuY2F0Y2goKCkgPT4gKHt9KSk7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ0ZhaWxlZCB0byBwcmVwYXJlIEwyIEVOUyBjYWxsczonLCBlcnJvclBheWxvYWQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgeyBjYWxsczogcmF3Q2FsbHMgfSA9IGF3YWl0IHByZXBhcmVSZXNwLmpzb24oKTtcbiAgICAgICAgICAgIGNvbnN0IGwyRW5zQ2FsbHMgPSAocmF3Q2FsbHMgfHwgW10pLm1hcCgoY2FsbCkgPT4gKHtcbiAgICAgICAgICAgICAgICB0bzogY2FsbC50byxcbiAgICAgICAgICAgICAgICBkYXRhOiBjYWxsLmRhdGEsXG4gICAgICAgICAgICAgICAgdmFsdWU6IEJpZ0ludChjYWxsLnZhbHVlIHx8ICcwJyksXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICBpZiAobDJFbnNDYWxscy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBjYWxsIG9mIGwyRW5zQ2FsbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgb25TdGF0dXNVcGRhdGU/LignTWV0YU1hc2sgc2lnbmF0dXJlOiBjcmVhdGUgRU5TIHN1YmRvbWFpbiAvIHNldCBFTlMgcmVjb3JkcycpO1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnKioqKioqKioqKioqKioqKioqKioqIHNlbmQgc3BvbnNvcmVkIHVzZXIgb3BlcmF0aW9uIGZvciBMMiBFTlMgY2FsbCcpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB1c2VyT3BIYXNoID0gYXdhaXQgc2VuZFNwb25zb3JlZFVzZXJPcGVyYXRpb24oe1xuICAgICAgICAgICAgICAgICAgICAgICAgYnVuZGxlclVybCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYWluLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWNjb3VudENsaWVudDogYWdlbnRBY2NvdW50Q2xpZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbHM6IFtjYWxsXSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHdhaXRGb3JVc2VyT3BlcmF0aW9uUmVjZWlwdCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBidW5kbGVyVXJsLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2hhaW4sXG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNoOiB1c2VyT3BIYXNoLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLyogIFRPRE86ICBOZWVkIHRvIHJlc29sdmUgdGhpcyB0byBzZXQgZW5zIHVybCBhbmQgZGVzY3JpcHRpb25cbiAgICAgICAgICBvblN0YXR1c1VwZGF0ZT8uKCdTZXQgRU5TIG1ldGFkYXRhIHVwZGF0ZS4uLicpO1xuICAgICAgICAgIGNvbnN0IGluZm9SZXNwb25zZSA9IGF3YWl0IGZldGNoKCcvYXBpL25hbWVzL3NldC1sMi1uYW1lLWluZm8nLCB7XG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9LFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICBhZ2VudEFkZHJlc3M6IGFnZW50QWNjb3VudENsaWVudC5hZGRyZXNzLFxuICAgICAgICAgICAgICBvcmdOYW1lOiBvcHRpb25zLmVuc09wdGlvbnMub3JnTmFtZSxcbiAgICAgICAgICAgICAgYWdlbnROYW1lOiBvcHRpb25zLmFnZW50RGF0YS5hZ2VudE5hbWUsXG4gICAgICAgICAgICAgIGFnZW50VXJsOiBvcHRpb25zLmFnZW50RGF0YS5hZ2VudFVybCxcbiAgICAgICAgICAgICAgYWdlbnREZXNjcmlwdGlvbjogb3B0aW9ucy5hZ2VudERhdGEuZGVzY3JpcHRpb24sXG4gICAgICAgICAgICAgIGNoYWluSWQsXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICB9KTtcbiAgICBcbiAgICAgICAgICBpZiAoIWluZm9SZXNwb25zZS5vaykge1xuICAgICAgICAgICAgY29uc3QgZXJyb3JQYXlsb2FkID0gYXdhaXQgaW5mb1Jlc3BvbnNlLmpzb24oKS5jYXRjaCgoKSA9PiAoe30pKTtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignRmFpbGVkIHRvIHByZXBhcmUgTDIgRU5TIGNhbGxzOicsIGVycm9yUGF5bG9hZCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHsgY2FsbHM6IHJhd0NhbGxzIH0gPSBhd2FpdCBpbmZvUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgY29uc3QgbDJFbnNDYWxscyA9IChyYXdDYWxscyB8fCBbXSkubWFwKChjYWxsOiBhbnkpID0+ICh7XG4gICAgICAgICAgICAgIHRvOiBjYWxsLnRvIGFzIGAweCR7c3RyaW5nfWAsXG4gICAgICAgICAgICAgIGRhdGE6IGNhbGwuZGF0YSBhcyBgMHgke3N0cmluZ31gLFxuICAgICAgICAgICAgICB2YWx1ZTogQmlnSW50KGNhbGwudmFsdWUgfHwgJzAnKSxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIGlmIChsMkVuc0NhbGxzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgZm9yIChjb25zdCBjYWxsIG9mIGwyRW5zQ2FsbHMpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnKioqKioqKioqKioqKioqKioqKioqIHNlbmQgc3BvbnNvcmVkIHVzZXIgb3BlcmF0aW9uIGZvciBMMiBFTlMgY2FsbCcpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHVzZXJPcEhhc2ggPSBhd2FpdCBzZW5kU3BvbnNvcmVkVXNlck9wZXJhdGlvbih7XG4gICAgICAgICAgICAgICAgICBidW5kbGVyVXJsLFxuICAgICAgICAgICAgICAgICAgY2hhaW4sXG4gICAgICAgICAgICAgICAgICBhY2NvdW50Q2xpZW50OiBhZ2VudEFjY291bnRDbGllbnQsXG4gICAgICAgICAgICAgICAgICBjYWxsczogW2NhbGxdLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGF3YWl0IHdhaXRGb3JVc2VyT3BlcmF0aW9uUmVjZWlwdCh7XG4gICAgICAgICAgICAgICAgICBidW5kbGVyVXJsLFxuICAgICAgICAgICAgICAgICAgY2hhaW4sXG4gICAgICAgICAgICAgICAgICBoYXNoOiB1c2VyT3BIYXNoLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgICAgKi9cbiAgICB9XG4gICAgLy8gMi4gIE5lZWQgdG8gY3JlYXRlIHRoZSBBZ2VudCBJZGVudGl0eSAoTkZUKVxuICAgIGNvbnNvbGUubG9nKCcqKioqKioqKioqKiBjcmVhdGVBZ2VudFdpdGhXYWxsZXQ6IGNyZWF0aW5nIGFnZW50IGlkZW50aXR5Li4uJyk7XG4gICAgY29uc3QgZmluYWxBZ2VudE5hbWUgPSBvcHRpb25zLmVuc09wdGlvbnM/LmVuYWJsZWQgJiYgb3B0aW9ucy5lbnNPcHRpb25zPy5vcmdOYW1lXG4gICAgICAgID8gYCR7b3B0aW9ucy5hZ2VudERhdGEuYWdlbnROYW1lfS4ke29wdGlvbnMuZW5zT3B0aW9ucz8ub3JnTmFtZX0uZXRoYFxuICAgICAgICA6IG9wdGlvbnMuYWdlbnREYXRhLmFnZW50TmFtZTtcbiAgICBhZ2VudERhdGEuYWdlbnROYW1lID0gZmluYWxBZ2VudE5hbWU7XG4gICAgbGV0IGRhdGE7XG4gICAgdHJ5IHtcbiAgICAgICAgZGF0YSA9IGF3YWl0IGNhbGxDcmVhdGVBZ2VudEVuZHBvaW50KHtcbiAgICAgICAgICAgIG1vZGU6ICdzbWFydEFjY291bnQnLFxuICAgICAgICAgICAgYWNjb3VudDogY29tcHV0ZWRBZGRyZXNzLFxuICAgICAgICAgICAgYWdlbnROYW1lOiBhZ2VudERhdGEuYWdlbnROYW1lLFxuICAgICAgICAgICAgYWdlbnRBY2NvdW50OiBhZ2VudERhdGEuYWdlbnRBY2NvdW50LFxuICAgICAgICAgICAgYWdlbnRDYXRlZ29yeTogYWdlbnREYXRhLmFnZW50Q2F0ZWdvcnksXG4gICAgICAgICAgICBzdXBwb3J0ZWRUcnVzdDogYWdlbnREYXRhLnN1cHBvcnRlZFRydXN0LFxuICAgICAgICAgICAgZGVzY3JpcHRpb246IGFnZW50RGF0YS5kZXNjcmlwdGlvbixcbiAgICAgICAgICAgIGltYWdlOiBhZ2VudERhdGEuaW1hZ2UsXG4gICAgICAgICAgICBhZ2VudFVybDogYWdlbnREYXRhLmFnZW50VXJsLFxuICAgICAgICAgICAgZW5kcG9pbnRzOiBhZ2VudERhdGEuZW5kcG9pbnRzLFxuICAgICAgICAgICAgY2hhaW5JZCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnRmFpbGVkIHRvIGNyZWF0ZSBhZ2VudCcpO1xuICAgIH1cbiAgICBpZiAoZGF0YS5tb2RlICE9PSAnc21hcnRBY2NvdW50Jykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NlcnZlciByZXR1cm5lZCBhbiB1bmV4cGVjdGVkIHBsYW4gbW9kZSBmb3IgU21hcnRBY2NvdW50IGNyZWF0aW9uJyk7XG4gICAgfVxuICAgIGlmIChkYXRhLmJ1bmRsZXJVcmwpIHtcbiAgICAgICAgYnVuZGxlclVybCA9IGRhdGEuYnVuZGxlclVybDtcbiAgICB9XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGRhdGEuY2FsbHMpIHx8IGRhdGEuY2FsbHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQWdlbnQgY3JlYXRpb24gcmVzcG9uc2UgbWlzc2luZyByZWdpc3RlciBjYWxscycpO1xuICAgIH1cbiAgICAvLyBDb25zdHJ1Y3QgQWdlbnQgSWRlbnRpdHkgd2l0aCBhZ2VudEFjY291bnQgQ2xpZW50XG4gICAgY29uc3QgY3JlYXRlQWdlbnRJZGVudGl0eUNhbGxzID0gZGF0YS5jYWxscy5tYXAoKGNhbGwpID0+ICh7XG4gICAgICAgIHRvOiBjYWxsLnRvLFxuICAgICAgICBkYXRhOiBjYWxsLmRhdGEsXG4gICAgICAgIHZhbHVlOiBCaWdJbnQoY2FsbC52YWx1ZSB8fCAnMCcpLFxuICAgIH0pKTtcbiAgICAvLyBTZW5kIFVzZXJPcGVyYXRpb24gdmlhIGJ1bmRsZXJcbiAgICBvblN0YXR1c1VwZGF0ZT8uKCdNZXRhTWFzayBzaWduYXR1cmU6IHJlZ2lzdGVyIGFnZW50IGlkZW50aXR5IChFUkMtODAwNCknKTtcbiAgICBjb25zdCB1c2VyT3BIYXNoID0gYXdhaXQgc2VuZFNwb25zb3JlZFVzZXJPcGVyYXRpb24oe1xuICAgICAgICBidW5kbGVyVXJsLFxuICAgICAgICBjaGFpbjogY2hhaW4sXG4gICAgICAgIGFjY291bnRDbGllbnQ6IGFnZW50QWNjb3VudENsaWVudCxcbiAgICAgICAgY2FsbHM6IGNyZWF0ZUFnZW50SWRlbnRpdHlDYWxscyxcbiAgICB9KTtcbiAgICBvblN0YXR1c1VwZGF0ZT8uKGBVc2VyT3BlcmF0aW9uIHNlbnQhIEhhc2g6ICR7dXNlck9wSGFzaH0uIFdhaXRpbmcgZm9yIGNvbmZpcm1hdGlvbi4uLmApO1xuICAgIC8vIFdhaXQgZm9yIHJlY2VpcHRcbiAgICBjb25zdCByZWNlaXB0ID0gYXdhaXQgd2FpdEZvclVzZXJPcGVyYXRpb25SZWNlaXB0KHtcbiAgICAgICAgYnVuZGxlclVybCxcbiAgICAgICAgY2hhaW46IGNoYWluLFxuICAgICAgICBoYXNoOiB1c2VyT3BIYXNoLFxuICAgIH0pO1xuICAgIC8vIEV4dHJhY3QgYWdlbnRJZCBmcm9tIHJlY2VpcHQgbG9nc1xuICAgIGxldCBhZ2VudElkO1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGV4dHJhY3RSZXNwb25zZSA9IGF3YWl0IGZldGNoKCcvYXBpL2FnZW50cy9leHRyYWN0LWFnZW50LWlkJywge1xuICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICByZWNlaXB0OiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHJlY2VpcHQsIChfLCB2YWx1ZSkgPT4gdHlwZW9mIHZhbHVlID09PSAnYmlnaW50JyA/IHZhbHVlLnRvU3RyaW5nKCkgOiB2YWx1ZSkpLFxuICAgICAgICAgICAgICAgIGNoYWluSWQ6IGNoYWluLmlkLFxuICAgICAgICAgICAgfSksXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoZXh0cmFjdFJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICBjb25zdCBleHRyYWN0RGF0YSA9IGF3YWl0IGV4dHJhY3RSZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICBpZiAoZXh0cmFjdERhdGE/LmFnZW50SWQpIHtcbiAgICAgICAgICAgICAgICBhZ2VudElkID0gZXh0cmFjdERhdGEuYWdlbnRJZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yUGF5bG9hZCA9IGF3YWl0IGV4dHJhY3RSZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gKHt9KSk7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ0ZhaWxlZCB0byBleHRyYWN0IGFnZW50SWQgdmlhIEFQSTonLCBlcnJvclBheWxvYWQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLndhcm4oJ1VuYWJsZSB0byBleHRyYWN0IGFnZW50SWQgdmlhIEFQSTonLCBlcnJvcik7XG4gICAgfVxuICAgIC8vIFJlZnJlc2ggR3JhcGhRTCBpbmRleGVyXG4gICAgaWYgKGFnZW50SWQpIHtcbiAgICAgICAgLy8gQWZ0ZXIgcmVnaXN0cmF0aW9uLCBzZXQgYWdlbnRXYWxsZXQgb24tY2hhaW4gQkVGT1JFIG5vdGlmeWluZyB0aGUgaW5kZXhlci5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGlkZW50aXR5UmVnaXN0cnkgPSBkYXRhLmlkZW50aXR5UmVnaXN0cnk7XG4gICAgICAgICAgICBpZiAoIWlkZW50aXR5UmVnaXN0cnkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgaWRlbnRpdHlSZWdpc3RyeSBpbiBjcmVhdGUtYWdlbnQgcmVzcG9uc2UnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGlkZW50aXR5Q2xpZW50ID0gbmV3IEFJQWdlbnRJZGVudGl0eUNsaWVudCh7XG4gICAgICAgICAgICAgICAgcHVibGljQ2xpZW50OiB2aWVtUHVibGljQ2xpZW50LFxuICAgICAgICAgICAgICAgIHdhbGxldENsaWVudDogdmllbVdhbGxldENsaWVudCxcbiAgICAgICAgICAgICAgICBpZGVudGl0eVJlZ2lzdHJ5QWRkcmVzczogaWRlbnRpdHlSZWdpc3RyeSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgRUlQNzEyX0RPTUFJTl9BQkkgPSBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnZnVuY3Rpb24nLFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnZWlwNzEyRG9tYWluJyxcbiAgICAgICAgICAgICAgICAgICAgc3RhdGVNdXRhYmlsaXR5OiAndmlldycsXG4gICAgICAgICAgICAgICAgICAgIGlucHV0czogW10sXG4gICAgICAgICAgICAgICAgICAgIG91dHB1dHM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ25hbWUnLCB0eXBlOiAnc3RyaW5nJyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAndmVyc2lvbicsIHR5cGU6ICdzdHJpbmcnIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWU6ICdjaGFpbklkJywgdHlwZTogJ3VpbnQyNTYnIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWU6ICd2ZXJpZnlpbmdDb250cmFjdCcsIHR5cGU6ICdhZGRyZXNzJyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAnc2FsdCcsIHR5cGU6ICdieXRlczMyJyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAnZXh0ZW5zaW9ucycsIHR5cGU6ICd1aW50MjU2W10nIH0sXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICBjb25zdCBkb21haW5SYXcgPSAoYXdhaXQgdmllbVB1YmxpY0NsaWVudC5yZWFkQ29udHJhY3Qoe1xuICAgICAgICAgICAgICAgIGFkZHJlc3M6IGlkZW50aXR5UmVnaXN0cnksXG4gICAgICAgICAgICAgICAgYWJpOiBFSVA3MTJfRE9NQUlOX0FCSSxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbk5hbWU6ICdlaXA3MTJEb21haW4nLFxuICAgICAgICAgICAgICAgIGFyZ3M6IFtdLFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgY29uc3QgZG9tYWluID0ge1xuICAgICAgICAgICAgICAgIG5hbWU6IFN0cmluZyhkb21haW5SYXc/Lm5hbWUgPz8gZG9tYWluUmF3Py5bMF0gPz8gJycpLFxuICAgICAgICAgICAgICAgIHZlcnNpb246IFN0cmluZyhkb21haW5SYXc/LnZlcnNpb24gPz8gZG9tYWluUmF3Py5bMV0gPz8gJycpLFxuICAgICAgICAgICAgICAgIGNoYWluSWQ6IE51bWJlcihkb21haW5SYXc/LmNoYWluSWQgPz8gZG9tYWluUmF3Py5bMl0gPz8gY2hhaW4uaWQpLFxuICAgICAgICAgICAgICAgIHZlcmlmeWluZ0NvbnRyYWN0OiAoZG9tYWluUmF3Py52ZXJpZnlpbmdDb250cmFjdCA/PyBkb21haW5SYXc/LlszXSksXG4gICAgICAgICAgICAgICAgc2FsdDogKGRvbWFpblJhdz8uc2FsdCA/PyBkb21haW5SYXc/Lls0XSksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgYWdlbnRJZEJpZ0ludCA9IEJpZ0ludChhZ2VudElkKTtcbiAgICAgICAgICAgIGNvbnN0IGRlYWRsaW5lID0gQmlnSW50KE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDEwMDApICsgNjAgKiA2MCk7IC8vICsxaFxuICAgICAgICAgICAgY29uc3QgbmV3V2FsbGV0ID0gZ2V0QWRkcmVzcyhhY2NvdW50KTtcbiAgICAgICAgICAgIG9uU3RhdHVzVXBkYXRlPy4oJ01ldGFNYXNrIHNpZ25hdHVyZTogc2V0IGFnZW50IHdhbGxldCAoSWRlbnRpdHlSZWdpc3RyeSknKTtcbiAgICAgICAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IChhd2FpdCB2aWVtV2FsbGV0Q2xpZW50LnNpZ25UeXBlZERhdGEoe1xuICAgICAgICAgICAgICAgIGFjY291bnQsXG4gICAgICAgICAgICAgICAgZG9tYWluLFxuICAgICAgICAgICAgICAgIHByaW1hcnlUeXBlOiAnU2V0QWdlbnRXYWxsZXQnLFxuICAgICAgICAgICAgICAgIHR5cGVzOiB7XG4gICAgICAgICAgICAgICAgICAgIFNldEFnZW50V2FsbGV0OiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWU6ICdhZ2VudElkJywgdHlwZTogJ3VpbnQyNTYnIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWU6ICduZXdXYWxsZXQnLCB0eXBlOiAnYWRkcmVzcycgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ2RlYWRsaW5lJywgdHlwZTogJ3VpbnQyNTYnIH0sXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiB7IGFnZW50SWQ6IGFnZW50SWRCaWdJbnQsIG5ld1dhbGxldCwgZGVhZGxpbmUgfSxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIGNvbnN0IHsgY2FsbHMgfSA9IGF3YWl0IGlkZW50aXR5Q2xpZW50LnByZXBhcmVTZXRBZ2VudFdhbGxldENhbGxzKGFnZW50SWRCaWdJbnQsIG5ld1dhbGxldCwgZGVhZGxpbmUsIHNpZ25hdHVyZSk7XG4gICAgICAgICAgICBjb25zdCBjYWxsID0gY2FsbHNbMF07XG4gICAgICAgICAgICBpZiAoIWNhbGwpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwcmVwYXJlU2V0QWdlbnRXYWxsZXRDYWxscyByZXR1cm5lZCBubyBjYWxscycpO1xuICAgICAgICAgICAgY29uc3Qgc2V0V2FsbGV0VXNlck9wSGFzaCA9IGF3YWl0IHNlbmRTcG9uc29yZWRVc2VyT3BlcmF0aW9uKHtcbiAgICAgICAgICAgICAgICBidW5kbGVyVXJsLFxuICAgICAgICAgICAgICAgIGNoYWluOiBjaGFpbixcbiAgICAgICAgICAgICAgICBhY2NvdW50Q2xpZW50OiBhZ2VudEFjY291bnRDbGllbnQsXG4gICAgICAgICAgICAgICAgY2FsbHM6IFt7IHRvOiBjYWxsLnRvLCBkYXRhOiBjYWxsLmRhdGEsIHZhbHVlOiAwbiB9XSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYXdhaXQgd2FpdEZvclVzZXJPcGVyYXRpb25SZWNlaXB0KHtcbiAgICAgICAgICAgICAgICBidW5kbGVyVXJsLFxuICAgICAgICAgICAgICAgIGNoYWluOiBjaGFpbixcbiAgICAgICAgICAgICAgICBoYXNoOiBzZXRXYWxsZXRVc2VyT3BIYXNoLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignW2NyZWF0ZUFnZW50V2l0aFdhbGxldEFBXSBzZXRBZ2VudFdhbGxldCBmYWlsZWQgKG5vbi1mYXRhbCk6JywgZSk7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgcmVmcmVzaEFnZW50SW5JbmRleGVyKGFnZW50SWQsIGNoYWluLmlkKTtcbiAgICAgICAgLy8gRmluYWxpemUgVUFJRCBub3cgdGhhdCB3ZSBoYXZlIGEgcmVhbCBvbi1jaGFpbiBhZ2VudElkLCBhbmQgd3JpdGUgaXQgYmFjayBieSB1cGRhdGluZyB0b2tlblVyaS5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG9uU3RhdHVzVXBkYXRlPy4oJ0ZpbmFsaXppbmcgVUFJRCBhbmQgdXBkYXRpbmcgcmVnaXN0cmF0aW9uIHRva2VuVXJpLi4uJyk7XG4gICAgICAgICAgICBjb25zdCB1YWlkUmVzcCA9IGF3YWl0IGZldGNoKCcvYXBpL2FnZW50cy9nZW5lcmF0ZS11YWlkJywge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9LFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICAgICAgYWdlbnRBY2NvdW50OiBhZ2VudERhdGEuYWdlbnRBY2NvdW50LFxuICAgICAgICAgICAgICAgICAgICBjaGFpbklkOiBjaGFpbi5pZCxcbiAgICAgICAgICAgICAgICAgICAgLy8gVXNlIGRpZDpldGhyIGZvciB1aWQgKG5vdCBFTlMpXG4gICAgICAgICAgICAgICAgICAgIHVpZDogYGRpZDpldGhyOiR7Y2hhaW4uaWR9OiR7YWdlbnREYXRhLmFnZW50QWNjb3VudH1gLFxuICAgICAgICAgICAgICAgICAgICBwcm90bzogJ2EyYScsXG4gICAgICAgICAgICAgICAgICAgIHJlZ2lzdHJ5OiAnZXJjLTgwMDQnLFxuICAgICAgICAgICAgICAgICAgICBkb21haW46IHR5cGVvZiBhZ2VudERhdGEuYWdlbnRVcmwgPT09ICdzdHJpbmcnICYmIGFnZW50RGF0YS5hZ2VudFVybC50cmltKClcbiAgICAgICAgICAgICAgICAgICAgICAgID8gKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFVSTChhZ2VudERhdGEuYWdlbnRVcmwpLmhvc3RuYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSkoKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICh1YWlkUmVzcC5vaykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHVhaWREYXRhID0gYXdhaXQgdWFpZFJlc3AuanNvbigpLmNhdGNoKCgpID0+ICh7fSkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHVhaWQgPSB0eXBlb2YgdWFpZERhdGE/LnVhaWQgPT09ICdzdHJpbmcnICYmIHVhaWREYXRhLnVhaWQudHJpbSgpID8gdWFpZERhdGEudWFpZC50cmltKCkgOiBudWxsO1xuICAgICAgICAgICAgICAgIGlmICh1YWlkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRpZDgwMDQgPSBgZGlkOjgwMDQ6JHtjaGFpbi5pZH06JHthZ2VudElkfWA7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlZ2lzdHJhdGlvblVwZGF0ZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdodHRwczovL2VpcHMuZXRoZXJldW0ub3JnL0VJUFMvZWlwLTgwMDQjcmVnaXN0cmF0aW9uLXYxJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGFnZW50RGF0YS5hZ2VudE5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogYWdlbnREYXRhLmRlc2NyaXB0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2U6IGFnZW50RGF0YS5pbWFnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFnZW50VXJsOiBhZ2VudERhdGEuYWdlbnRVcmwsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBOZXZlciBpbmNsdWRlIE1DUCBlbmRwb2ludCBpbiByZWdpc3RyYXRpb24gSlNPTiB1cGRhdGVzLlxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kcG9pbnRzOiBBcnJheS5pc0FycmF5KGFnZW50RGF0YS5lbmRwb2ludHMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBhZ2VudERhdGEuZW5kcG9pbnRzLmZpbHRlcihlID0+IGU/Lm5hbWUgIT09ICdNQ1AnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3VwcG9ydGVkVHJ1c3Q6IGFnZW50RGF0YS5zdXBwb3J0ZWRUcnVzdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGl2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZ2lzdGVyZWRCeTogJ2FnZW50aWMtdHJ1c3QnLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVnaXN0cnlOYW1lc3BhY2U6ICdlcmMtODAwNCcsXG4gICAgICAgICAgICAgICAgICAgICAgICB1YWlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRW5zdXJlIGFnZW50SWQgaXMgd3JpdHRlbiBpbnRvIHRoZSB0b2tlblVyaSBKU09OXG4gICAgICAgICAgICAgICAgICAgICAgICByZWdpc3RyYXRpb25zOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZ2VudElkOiBTdHJpbmcoYWdlbnRJZCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFnZW50UmVnaXN0cnkgaXMgYmVzdC1lZmZvcnQ7IHNlcnZlciB3aWxsIGFsc28gYmFja2ZpbGwgaWYgb21pdHRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZ2VudFJlZ2lzdHJ5OiBgZWlwMTU1OiR7Y2hhaW4uaWR9OnVua25vd25gLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWdpc3RlcmVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdXBkYXRlQWdlbnRSZWdpc3RyYXRpb25XaXRoV2FsbGV0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpZDgwMDQsXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFpbixcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjY291bnRDbGllbnQ6IGFnZW50QWNjb3VudENsaWVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZ2lzdHJhdGlvbjogcmVnaXN0cmF0aW9uVXBkYXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgb25TdGF0dXNVcGRhdGUsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdbY3JlYXRlQWdlbnRXaXRoV2FsbGV0QUFdIFVBSUQgZW5kcG9pbnQgcmV0dXJuZWQgbm8gdWFpZCB2YWx1ZScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVyciA9IGF3YWl0IHVhaWRSZXNwLmpzb24oKS5jYXRjaCgoKSA9PiAoe30pKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1tjcmVhdGVBZ2VudFdpdGhXYWxsZXRBQV0gVUFJRCBlbmRwb2ludCBmYWlsZWQ6JywgZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAodWFpZEVycikge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdbY3JlYXRlQWdlbnRXaXRoV2FsbGV0QUFdIEZhaWxlZCB0byBmaW5hbGl6ZSBVQUlEICsgcmVnaXN0cmF0aW9uIHVwZGF0ZTonLCB1YWlkRXJyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgb25TdGF0dXNVcGRhdGU/LignUmVmcmVzaGluZyBHcmFwaFFMIGluZGV4ZXIuLi4nKTtcbiAgICAgICAgY29uc29sZS5sb2coJ1VzZXJPcGVyYXRpb24gY29uZmlybWVkLiBQbGVhc2UgcmVmcmVzaCB0aGUgYWdlbnQgbGlzdCB0byBzZWUgdGhlIG5ldyBhZ2VudC4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYWdlbnRJZCxcbiAgICAgICAgdHhIYXNoOiB1c2VyT3BIYXNoLFxuICAgICAgICByZXF1aXJlc0NsaWVudFNpZ25pbmc6IHRydWUsXG4gICAgfTtcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjcmVhdGVBZ2VudFdpdGhXYWxsZXQob3B0aW9ucykge1xuICAgIGNvbnN0IHVzZUFBID0gb3B0aW9ucy51c2VBQSA/PyBmYWxzZTtcbiAgICBpZiAodXNlQUEpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUFnZW50V2l0aFdhbGxldEFBKG9wdGlvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQWdlbnRXaXRoV2FsbGV0RU9BKG9wdGlvbnMpO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHVwZGF0ZUFnZW50UmVnaXN0cmF0aW9uV2l0aFdhbGxldChvcHRpb25zKSB7XG4gICAgY29uc3QgeyBkaWQ4MDA0LCBjaGFpbiwgYWNjb3VudENsaWVudCwgcmVnaXN0cmF0aW9uLCBvblN0YXR1c1VwZGF0ZSB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBzZXJpYWxpemVkID0gdHlwZW9mIHJlZ2lzdHJhdGlvbiA9PT0gJ3N0cmluZycgPyByZWdpc3RyYXRpb24gOiBKU09OLnN0cmluZ2lmeShyZWdpc3RyYXRpb24sIG51bGwsIDIpO1xuICAgIG9uU3RhdHVzVXBkYXRlPy4oJ1ByZXBhcmluZyBhZ2VudCByZWdpc3RyYXRpb24gdXBkYXRlIG9uIHNlcnZlci4uLicpO1xuICAgIGNvbnNvbGUuaW5mbygnLi4uLi4uLi4uLi4gcmVnaXN0cmF0aW9uOiAnLCByZWdpc3RyYXRpb24pO1xuICAgIGxldCBwcmVwYXJlZDtcbiAgICB0cnkge1xuICAgICAgICBwcmVwYXJlZCA9IGF3YWl0IGNhbGxVcGRhdGVBZ2VudFJlZ2lzdHJhdGlvbkVuZHBvaW50KHtcbiAgICAgICAgICAgIGRpZDgwMDQsXG4gICAgICAgICAgICByZWdpc3RyYXRpb246IHNlcmlhbGl6ZWQsXG4gICAgICAgICAgICBtb2RlOiAnc21hcnRBY2NvdW50JyxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3IgaW5zdGFuY2VvZiBFcnJvclxuICAgICAgICAgICAgPyBlcnJvci5tZXNzYWdlXG4gICAgICAgICAgICA6ICdGYWlsZWQgdG8gcHJlcGFyZSByZWdpc3RyYXRpb24gdXBkYXRlJyk7XG4gICAgfVxuICAgIGNvbnN0IGJ1bmRsZXJVcmwgPSBwcmVwYXJlZC5idW5kbGVyVXJsO1xuICAgIGNvbnN0IHJhd0NhbGxzID0gQXJyYXkuaXNBcnJheShwcmVwYXJlZC5jYWxscykgPyBwcmVwYXJlZC5jYWxscyA6IFtdO1xuICAgIGlmICghYnVuZGxlclVybCB8fCByYXdDYWxscy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZWdpc3RyYXRpb24gdXBkYXRlIHJlc3BvbnNlIG1pc3NpbmcgYnVuZGxlclVybCBvciBjYWxscycpO1xuICAgIH1cbiAgICAvLyBQcmVmbGlnaHQgYXV0aG9yaXphdGlvbiBjaGVjayB0byBhdm9pZCBvcGFxdWUgYnVuZGxlciBzaW11bGF0aW9uIHJldmVydHMgKFwiTm90IGF1dGhvcml6ZWRcIikuXG4gICAgLy8gVGhlIElkZW50aXR5UmVnaXN0cnkgc2V0QWdlbnRVcmkgcmVxdWlyZXMgbXNnLnNlbmRlciB0byBiZSBvd25lciBvciBhcHByb3ZlZCBvcGVyYXRvciBmb3IgdGhlIGFnZW50SWQuXG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgaWRlbnRpdHlSZWdpc3RyeSA9IHByZXBhcmVkLmlkZW50aXR5UmVnaXN0cnk7XG4gICAgICAgIGNvbnN0IHJwY1VybCA9IGdldENoYWluUnBjVXJsKGNoYWluLmlkKSB8fCBjaGFpbi5ycGNVcmxzPy5kZWZhdWx0Py5odHRwPy5bMF07XG4gICAgICAgIGlmIChpZGVudGl0eVJlZ2lzdHJ5ICYmIHJwY1VybCkge1xuICAgICAgICAgICAgY29uc3QgcHVibGljQ2xpZW50ID0gY3JlYXRlUHVibGljQ2xpZW50KHtcbiAgICAgICAgICAgICAgICBjaGFpbjogY2hhaW4sXG4gICAgICAgICAgICAgICAgdHJhbnNwb3J0OiBodHRwKHJwY1VybCksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHsgYWdlbnRJZCB9ID0gcGFyc2VEaWQ4MDA0KGRpZDgwMDQpO1xuICAgICAgICAgICAgY29uc3QgdG9rZW5JZCA9IEJpZ0ludChhZ2VudElkKTtcbiAgICAgICAgICAgIGNvbnN0IHNlbmRlciA9IGdldEFkZHJlc3MoYWNjb3VudENsaWVudC5hZGRyZXNzKTtcbiAgICAgICAgICAgIGNvbnN0IEVSQzcyMV9BQkkgPSBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnZnVuY3Rpb24nLFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnb3duZXJPZicsXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlTXV0YWJpbGl0eTogJ3ZpZXcnLFxuICAgICAgICAgICAgICAgICAgICBpbnB1dHM6IFt7IG5hbWU6ICd0b2tlbklkJywgdHlwZTogJ3VpbnQyNTYnIH1dLFxuICAgICAgICAgICAgICAgICAgICBvdXRwdXRzOiBbeyBuYW1lOiAnb3duZXInLCB0eXBlOiAnYWRkcmVzcycgfV0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdmdW5jdGlvbicsXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdnZXRBcHByb3ZlZCcsXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlTXV0YWJpbGl0eTogJ3ZpZXcnLFxuICAgICAgICAgICAgICAgICAgICBpbnB1dHM6IFt7IG5hbWU6ICd0b2tlbklkJywgdHlwZTogJ3VpbnQyNTYnIH1dLFxuICAgICAgICAgICAgICAgICAgICBvdXRwdXRzOiBbeyBuYW1lOiAnb3BlcmF0b3InLCB0eXBlOiAnYWRkcmVzcycgfV0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdmdW5jdGlvbicsXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdpc0FwcHJvdmVkRm9yQWxsJyxcbiAgICAgICAgICAgICAgICAgICAgc3RhdGVNdXRhYmlsaXR5OiAndmlldycsXG4gICAgICAgICAgICAgICAgICAgIGlucHV0czogW1xuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAnb3duZXInLCB0eXBlOiAnYWRkcmVzcycgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ29wZXJhdG9yJywgdHlwZTogJ2FkZHJlc3MnIH0sXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgIG91dHB1dHM6IFt7IG5hbWU6ICdhcHByb3ZlZCcsIHR5cGU6ICdib29sJyB9XSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIGNvbnN0IG93bmVyID0gKGF3YWl0IHB1YmxpY0NsaWVudC5yZWFkQ29udHJhY3Qoe1xuICAgICAgICAgICAgICAgIGFkZHJlc3M6IGlkZW50aXR5UmVnaXN0cnksXG4gICAgICAgICAgICAgICAgYWJpOiBFUkM3MjFfQUJJLFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uTmFtZTogJ293bmVyT2YnLFxuICAgICAgICAgICAgICAgIGFyZ3M6IFt0b2tlbklkXSxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIC8vIElmIG93bmVyIGlzIHNlbmRlciwgT0suXG4gICAgICAgICAgICBjb25zdCBvd25lck5vcm0gPSBnZXRBZGRyZXNzKG93bmVyKTtcbiAgICAgICAgICAgIGlmIChvd25lck5vcm0gIT09IHNlbmRlcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFwcHJvdmVkID0gKGF3YWl0IHB1YmxpY0NsaWVudC5yZWFkQ29udHJhY3Qoe1xuICAgICAgICAgICAgICAgICAgICBhZGRyZXNzOiBpZGVudGl0eVJlZ2lzdHJ5LFxuICAgICAgICAgICAgICAgICAgICBhYmk6IEVSQzcyMV9BQkksXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uTmFtZTogJ2dldEFwcHJvdmVkJyxcbiAgICAgICAgICAgICAgICAgICAgYXJnczogW3Rva2VuSWRdLFxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICBjb25zdCBhcHByb3ZlZE5vcm0gPSBhcHByb3ZlZCA/IGdldEFkZHJlc3MoYXBwcm92ZWQpIDogJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCc7XG4gICAgICAgICAgICAgICAgY29uc3QgYXBwcm92ZWRGb3JBbGwgPSAoYXdhaXQgcHVibGljQ2xpZW50LnJlYWRDb250cmFjdCh7XG4gICAgICAgICAgICAgICAgICAgIGFkZHJlc3M6IGlkZW50aXR5UmVnaXN0cnksXG4gICAgICAgICAgICAgICAgICAgIGFiaTogRVJDNzIxX0FCSSxcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25OYW1lOiAnaXNBcHByb3ZlZEZvckFsbCcsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtvd25lck5vcm0sIHNlbmRlcl0sXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzQXV0aG9yaXplZCA9IGFwcHJvdmVkTm9ybSA9PT0gc2VuZGVyIHx8IGFwcHJvdmVkRm9yQWxsID09PSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmICghaXNBdXRob3JpemVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTm90IGF1dGhvcml6ZWQgdG8gdXBkYXRlIGFnZW50IHJlZ2lzdHJhdGlvbi4gYCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgQWdlbnQgTkZUIG93bmVyPSR7b3duZXJOb3JtfSwgc2VuZGVyPSR7c2VuZGVyfS4gYCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgR3JhbnQgYXBwcm92YWwgKGFwcHJvdmUgb3Igc2V0QXBwcm92YWxGb3JBbGwpIG9yIHVzZSB0aGUgb3duaW5nIGFjY291bnQuYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChwcmVmbGlnaHRFcnIpIHtcbiAgICAgICAgLy8gSWYgd2UgY2FuIGRlZmluaXRpdmVseSBkZXRlY3QgYXV0aG9yaXphdGlvbiBtaXNtYXRjaCwgc3VyZmFjZSBpdC5cbiAgICAgICAgY29uc3QgbXNnID0gcHJlZmxpZ2h0RXJyPy5tZXNzYWdlIHx8IFN0cmluZyhwcmVmbGlnaHRFcnIpO1xuICAgICAgICBpZiAobXNnLmluY2x1ZGVzKCdOb3QgYXV0aG9yaXplZCB0byB1cGRhdGUgYWdlbnQgcmVnaXN0cmF0aW9uJykpIHtcbiAgICAgICAgICAgIHRocm93IHByZWZsaWdodEVycjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB1cGRhdGVDYWxscyA9IHJhd0NhbGxzLm1hcCgoY2FsbCkgPT4gKHtcbiAgICAgICAgdG86IGNhbGwudG8sXG4gICAgICAgIGRhdGE6IGNhbGwuZGF0YSxcbiAgICAgICAgdmFsdWU6IEJpZ0ludChjYWxsLnZhbHVlID8/ICcwJyksXG4gICAgfSkpO1xuICAgIGNvbnNvbGUuaW5mbygndXBkYXRlQ2FsbHMnLCB1cGRhdGVDYWxscyk7XG4gICAgY29uc29sZS5pbmZvKCdhY2NvdW50Q2xpZW50OicsIGFjY291bnRDbGllbnQuYWRkcmVzcyk7XG4gICAgb25TdGF0dXNVcGRhdGU/LignU2VuZGluZyByZWdpc3RyYXRpb24gdXBkYXRlIHZpYSBidW5kbGVyLi4uJyk7XG4gICAgY29uc3QgdXNlck9wSGFzaCA9IGF3YWl0IHNlbmRTcG9uc29yZWRVc2VyT3BlcmF0aW9uKHtcbiAgICAgICAgYnVuZGxlclVybCxcbiAgICAgICAgY2hhaW46IGNoYWluLFxuICAgICAgICBhY2NvdW50Q2xpZW50LFxuICAgICAgICBjYWxsczogdXBkYXRlQ2FsbHMsXG4gICAgfSk7XG4gICAgb25TdGF0dXNVcGRhdGU/LihgUmVnaXN0cmF0aW9uIHVwZGF0ZSBzZW50ISBVc2VyT3BlcmF0aW9uIGhhc2g6ICR7dXNlck9wSGFzaH0uIFdhaXRpbmcgZm9yIGNvbmZpcm1hdGlvbi4uLmApO1xuICAgIGNvbnN0IHJlY2VpcHQgPSBhd2FpdCB3YWl0Rm9yVXNlck9wZXJhdGlvblJlY2VpcHQoe1xuICAgICAgICBidW5kbGVyVXJsLFxuICAgICAgICBjaGFpbjogY2hhaW4sXG4gICAgICAgIGhhc2g6IHVzZXJPcEhhc2gsXG4gICAgfSk7XG4gICAgY29uc29sZS5pbmZvKCcuLi4uLi4uLi4uLiByZWNlaXB0OiAnLCByZWNlaXB0KTtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eEhhc2g6IHVzZXJPcEhhc2gsXG4gICAgICAgIHJlcXVpcmVzQ2xpZW50U2lnbmluZzogdHJ1ZSxcbiAgICB9O1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdpdmVGZWVkYmFja1dpdGhXYWxsZXQob3B0aW9ucykge1xuICAgIGNvbnN0IHsgZGlkODAwNCwgY2hhaW4sIHNjb3JlLCBmZWVkYmFjaywgZmVlZGJhY2tBdXRoLCBjbGllbnRBZGRyZXNzLCB0YWcxLCB0YWcyLCBmZWVkYmFja1VyaSwgZmVlZGJhY2tIYXNoLCBza2lsbCwgY29udGV4dCwgY2FwYWJpbGl0eSwgZXRoZXJldW1Qcm92aWRlciwgb25TdGF0dXNVcGRhdGUsIH0gPSBvcHRpb25zO1xuICAgIG9uU3RhdHVzVXBkYXRlPy4oJ1ByZXBhcmluZyBmZWVkYmFjayBzdWJtaXNzaW9uIG9uIHNlcnZlci4uLicpO1xuICAgIGxldCBwcmVwYXJlZDtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAvYXBpL2FnZW50cy8ke2VuY29kZVVSSUNvbXBvbmVudChkaWQ4MDA0KX0vZmVlZGJhY2tgLCB7XG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9LFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgIHNjb3JlLFxuICAgICAgICAgICAgICAgIGZlZWRiYWNrLFxuICAgICAgICAgICAgICAgIGZlZWRiYWNrQXV0aCxcbiAgICAgICAgICAgICAgICBjbGllbnRBZGRyZXNzLFxuICAgICAgICAgICAgICAgIHRhZzEsXG4gICAgICAgICAgICAgICAgdGFnMixcbiAgICAgICAgICAgICAgICBmZWVkYmFja1VyaSxcbiAgICAgICAgICAgICAgICBmZWVkYmFja0hhc2gsXG4gICAgICAgICAgICAgICAgc2tpbGwsXG4gICAgICAgICAgICAgICAgY29udGV4dCxcbiAgICAgICAgICAgICAgICBjYXBhYmlsaXR5LFxuICAgICAgICAgICAgICAgIG1vZGU6ICdlb2EnLFxuICAgICAgICAgICAgfSksXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gKHt9KSk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JEYXRhLmVycm9yIHx8IGVycm9yRGF0YS5tZXNzYWdlIHx8ICdGYWlsZWQgdG8gcHJlcGFyZSBmZWVkYmFjayBzdWJtaXNzaW9uJyk7XG4gICAgICAgIH1cbiAgICAgICAgcHJlcGFyZWQgPSAoYXdhaXQgcmVzcG9uc2UuanNvbigpKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvciBpbnN0YW5jZW9mIEVycm9yXG4gICAgICAgICAgICA/IGVycm9yLm1lc3NhZ2VcbiAgICAgICAgICAgIDogJ0ZhaWxlZCB0byBwcmVwYXJlIGZlZWRiYWNrIHN1Ym1pc3Npb24nKTtcbiAgICB9XG4gICAgaWYgKCFwcmVwYXJlZC50cmFuc2FjdGlvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZlZWRiYWNrIHN1Ym1pc3Npb24gcmVzcG9uc2UgbWlzc2luZyB0cmFuc2FjdGlvbiBwYXlsb2FkJyk7XG4gICAgfVxuICAgIGNvbnN0IHR4UmVzdWx0ID0gYXdhaXQgc2lnbkFuZFNlbmRUcmFuc2FjdGlvbih7XG4gICAgICAgIHRyYW5zYWN0aW9uOiBwcmVwYXJlZC50cmFuc2FjdGlvbiwgLy8gQWdlbnRQcmVwYXJlZFRyYW5zYWN0aW9uUGF5bG9hZCBpcyBjb21wYXRpYmxlIHdpdGggUHJlcGFyZWRUcmFuc2FjdGlvblxuICAgICAgICBhY2NvdW50OiAoY2xpZW50QWRkcmVzcyB8fCAnMHgnKSxcbiAgICAgICAgY2hhaW4sXG4gICAgICAgIGV0aGVyZXVtUHJvdmlkZXIsXG4gICAgICAgIG9uU3RhdHVzVXBkYXRlLFxuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIHR4SGFzaDogdHhSZXN1bHQuaGFzaCxcbiAgICAgICAgcmVxdWlyZXNDbGllbnRTaWduaW5nOiB0cnVlLFxuICAgIH07XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZmluYWxpemVBc3NvY2lhdGlvbldpdGhXYWxsZXQob3B0aW9ucykge1xuICAgIGNvbnN0IHsgY2hhaW4sIHN1Ym1pdHRlckFjY291bnRDbGllbnQsIG1vZGUgPSAnc21hcnRBY2NvdW50JywgZXRoZXJldW1Qcm92aWRlciwgYWNjb3VudCwgcmVxdWVzdGVyRGlkLCBpbml0aWF0b3JBZGRyZXNzOiBpbml0aWF0b3JBZGRyZXNzT3ZlcnJpZGUsIGFwcHJvdmVyQWRkcmVzcywgYXNzb2NUeXBlLCBkZXNjcmlwdGlvbiwgdmFsaWRBdCwgZGF0YSwgaW5pdGlhdG9yU2lnbmF0dXJlLCBhcHByb3ZlclNpZ25hdHVyZSwgb25TdGF0dXNVcGRhdGUsIH0gPSBvcHRpb25zO1xuICAgIC8vIFByZWZsaWdodDogYmVzdC1lZmZvcnQgRVJDLTEyNzEgc2lnbmF0dXJlIHZhbGlkYXRpb24gdG8gYXZvaWQgb3BhcXVlIGJ1bmRsZXIgXCJyZWFzb246IDB4XCIuXG4gICAgLy8gVGhpcyBjaGVja3Mgd2hldGhlciB0aGUgaW5pdGlhdG9yL2FwcHJvdmVyIHNtYXJ0IGFjY291bnRzIHdvdWxkIGFjY2VwdCB0aGUgcHJvdmlkZWQgc2lnbmF0dXJlc1xuICAgIC8vIGZvciB0aGUgYXNzb2NpYXRpb24gZGlnZXN0IHdlIGFyZSBhYm91dCB0byBzdWJtaXQuXG4gICAgaWYgKG1vZGUgPT09ICdzbWFydEFjY291bnQnKSB7XG4gICAgICAgIGlmICghc3VibWl0dGVyQWNjb3VudENsaWVudCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzbWFydEFjY291bnQgbW9kZSByZXF1aXJlcyBzdWJtaXR0ZXJBY2NvdW50Q2xpZW50Jyk7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJwY1VybCA9IGdldENoYWluUnBjVXJsKGNoYWluLmlkKSB8fCBjaGFpbi5ycGNVcmxzPy5kZWZhdWx0Py5odHRwPy5bMF07XG4gICAgICAgICAgICBpZiAocnBjVXJsKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHVibGljQ2xpZW50ID0gY3JlYXRlUHVibGljQ2xpZW50KHtcbiAgICAgICAgICAgICAgICAgICAgY2hhaW46IGNoYWluLFxuICAgICAgICAgICAgICAgICAgICB0cmFuc3BvcnQ6IGh0dHAocnBjVXJsKSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAvLyBSZXNvbHZlIGluaXRpYXRvciBhZGRyZXNzIGZvciBkaWdlc3QgY29tcHV0YXRpb24uXG4gICAgICAgICAgICAgICAgLy8gSWYgY2FsbGVyIHN1cHBsaWVkIGFuIG92ZXJyaWRlIChmcm9tIGluYm94IHBheWxvYWQpLCBwcmVmZXIgaXQgdG8gYXZvaWQgbWlzbWF0Y2hlcy5cbiAgICAgICAgICAgICAgICBjb25zdCBpbml0aWF0b3JGaW5hbCA9IGluaXRpYXRvckFkZHJlc3NPdmVycmlkZVxuICAgICAgICAgICAgICAgICAgICA/IGdldEFkZHJlc3MoaW5pdGlhdG9yQWRkcmVzc092ZXJyaWRlKVxuICAgICAgICAgICAgICAgICAgICA6IG51bGw7XG4gICAgICAgICAgICAgICAgbGV0IGluaXRpYXRvclJlc29sdmVkID0gaW5pdGlhdG9yRmluYWw7XG4gICAgICAgICAgICAgICAgaWYgKCFpbml0aWF0b3JSZXNvbHZlZCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbml0aWF0b3JSZXNwID0gYXdhaXQgZmV0Y2goYC9hcGkvYWdlbnRzLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHJlcXVlc3RlckRpZCl9YCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGluaXRpYXRvckpzb24gPSBpbml0aWF0b3JSZXNwLm9rID8gYXdhaXQgaW5pdGlhdG9yUmVzcC5qc29uKCkuY2F0Y2goKCkgPT4gKHt9KSkgOiB7fTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5pdGlhdG9yQWRkclJhdyA9IGluaXRpYXRvckpzb24/LmFnZW50QWNjb3VudCB8fCBpbml0aWF0b3JKc29uPy5hY2NvdW50O1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5pdGlhdG9yQWRkclJhdykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5pdGlhdG9yUmVzb2x2ZWQgPSBnZXRBZGRyZXNzKGluaXRpYXRvckFkZHJSYXcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghaW5pdGlhdG9yUmVzb2x2ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIGluaXRpYXRvckFkZHJlc3MgZm9yIGFzc29jaWF0aW9uIHByZWZsaWdodCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBhcHByb3ZlciA9IGdldEFkZHJlc3MoYXBwcm92ZXJBZGRyZXNzKTtcbiAgICAgICAgICAgICAgICAvLyBSZWNvbXB1dGUgZGlnZXN0IHVzaW5nIHRoZSBlcmM4MDkyIHNjaGVtZSAoc2FtZSBhcyBwYWNrYWdlcy9lcmM4MDkyLXNkayBlaXA3MTJIYXNoKVxuICAgICAgICAgICAgICAgIGNvbnN0IHsgZXRoZXJzIH0gPSBhd2FpdCBpbXBvcnQoJ2V0aGVycycpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRvTWluaW1hbEJpZ0VuZGlhbkJ5dGVzID0gKG4pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG4gPT09IDBuKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFswXSk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBoZXggPSBuLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhleC5sZW5ndGggJSAyKVxuICAgICAgICAgICAgICAgICAgICAgICAgaGV4ID0gYDAke2hleH1gO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXRoZXJzLmdldEJ5dGVzKGAweCR7aGV4fWApO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgY29uc3QgZm9ybWF0RXZtVjEgPSAoY2hhaW5JZCwgYWRkcmVzcykgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhZGRyID0gZXRoZXJzLmdldEFkZHJlc3MoYWRkcmVzcyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoYWluUmVmID0gdG9NaW5pbWFsQmlnRW5kaWFuQnl0ZXMoQmlnSW50KGNoYWluSWQpKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaGVhZCA9IGV0aGVycy5nZXRCeXRlcygnMHgwMDAxMDAwMCcpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvdXQgPSBldGhlcnMuY29uY2F0KFtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXcgVWludDhBcnJheShbY2hhaW5SZWYubGVuZ3RoXSksXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFpblJlZixcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBVaW50OEFycmF5KFsyMF0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXRoZXJzLmdldEJ5dGVzKGFkZHIpLFxuICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGV0aGVycy5oZXhsaWZ5KG91dCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBjb25zdCBpbml0aWF0b3JJbnRlcm9wID0gZm9ybWF0RXZtVjEoY2hhaW4uaWQsIGluaXRpYXRvclJlc29sdmVkKTtcbiAgICAgICAgICAgICAgICBjb25zdCBhcHByb3ZlckludGVyb3AgPSBmb3JtYXRFdm1WMShjaGFpbi5pZCwgYXBwcm92ZXIpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGFiaUNvZGVyID0gZXRoZXJzLkFiaUNvZGVyLmRlZmF1bHRBYmlDb2RlcigpO1xuICAgICAgICAgICAgICAgIGNvbnN0IERPTUFJTl9UWVBFSEFTSCA9IGV0aGVycy5pZCgnRUlQNzEyRG9tYWluKHN0cmluZyBuYW1lLHN0cmluZyB2ZXJzaW9uKScpO1xuICAgICAgICAgICAgICAgIGNvbnN0IE5BTUVfSEFTSCA9IGV0aGVycy5pZCgnQXNzb2NpYXRlZEFjY291bnRzJyk7XG4gICAgICAgICAgICAgICAgY29uc3QgVkVSU0lPTl9IQVNIID0gZXRoZXJzLmlkKCcxJyk7XG4gICAgICAgICAgICAgICAgY29uc3QgTUVTU0FHRV9UWVBFSEFTSCA9IGV0aGVycy5pZCgnQXNzb2NpYXRlZEFjY291bnRSZWNvcmQoYnl0ZXMgaW5pdGlhdG9yLGJ5dGVzIGFwcHJvdmVyLHVpbnQ0MCB2YWxpZEF0LHVpbnQ0MCB2YWxpZFVudGlsLGJ5dGVzNCBpbnRlcmZhY2VJZCxieXRlcyBkYXRhKScpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGRvbWFpblNlcGFyYXRvciA9IGV0aGVycy5rZWNjYWsyNTYoYWJpQ29kZXIuZW5jb2RlKFsnYnl0ZXMzMicsICdieXRlczMyJywgJ2J5dGVzMzInXSwgW0RPTUFJTl9UWVBFSEFTSCwgTkFNRV9IQVNILCBWRVJTSU9OX0hBU0hdKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgaW50ZXJmYWNlSWQgPSAnMHgwMDAwMDAwMCc7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsaWRVbnRpbCA9IDA7XG4gICAgICAgICAgICAgICAgY29uc3QgaGFzaFN0cnVjdCA9IGV0aGVycy5rZWNjYWsyNTYoYWJpQ29kZXIuZW5jb2RlKFsnYnl0ZXMzMicsICdieXRlczMyJywgJ2J5dGVzMzInLCAndWludDQwJywgJ3VpbnQ0MCcsICdieXRlczQnLCAnYnl0ZXMzMiddLCBbXG4gICAgICAgICAgICAgICAgICAgIE1FU1NBR0VfVFlQRUhBU0gsXG4gICAgICAgICAgICAgICAgICAgIGV0aGVycy5rZWNjYWsyNTYoaW5pdGlhdG9ySW50ZXJvcCksXG4gICAgICAgICAgICAgICAgICAgIGV0aGVycy5rZWNjYWsyNTYoYXBwcm92ZXJJbnRlcm9wKSxcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRBdCxcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRVbnRpbCxcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJmYWNlSWQsXG4gICAgICAgICAgICAgICAgICAgIGV0aGVycy5rZWNjYWsyNTYoZGF0YSksXG4gICAgICAgICAgICAgICAgXSkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGRpZ2VzdCA9IGV0aGVycy5rZWNjYWsyNTYoZXRoZXJzLnNvbGlkaXR5UGFja2VkKFsnYnl0ZXMyJywgJ2J5dGVzMzInLCAnYnl0ZXMzMiddLCBbJzB4MTkwMScsIGRvbWFpblNlcGFyYXRvciwgaGFzaFN0cnVjdF0pKTtcbiAgICAgICAgICAgICAgICBjb25zdCBFUkMxMjcxX01BR0lDID0gJzB4MTYyNmJhN2UnO1xuICAgICAgICAgICAgICAgIGNvbnN0IEVSQzEyNzFfQUJJID0gW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnZnVuY3Rpb24nLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ2lzVmFsaWRTaWduYXR1cmUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVNdXRhYmlsaXR5OiAndmlldycsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnB1dHM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWU6ICdoYXNoJywgdHlwZTogJ2J5dGVzMzInIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAnc2lnbmF0dXJlJywgdHlwZTogJ2J5dGVzJyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dHM6IFt7IG5hbWU6ICdtYWdpY1ZhbHVlJywgdHlwZTogJ2J5dGVzNCcgfV0sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGVja1NpZ25hdHVyZSA9IGFzeW5jIChhY2NvdW50LCBzaWcpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29kZSA9IGF3YWl0IHB1YmxpY0NsaWVudC5nZXRCeXRlY29kZSh7IGFkZHJlc3M6IGFjY291bnQgfSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIEVPQTogdmVyaWZ5IHdpdGggZWNyZWNvdmVyLlxuICAgICAgICAgICAgICAgICAgICBpZiAoIWNvZGUgfHwgY29kZSA9PT0gJzB4Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZWNvdmVyZWQgPSBldGhlcnMucmVjb3ZlckFkZHJlc3MoZGlnZXN0LCBzaWcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9rOiByZWNvdmVyZWQudG9Mb3dlckNhc2UoKSA9PT0gYWNjb3VudC50b0xvd2VyQ2FzZSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRob2Q6ICdlY3JlY292ZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWNvdmVyZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgb2s6IGZhbHNlLCBtZXRob2Q6ICdlY3JlY292ZXInLCBlcnJvcjogZT8ubWVzc2FnZSB8fCBTdHJpbmcoZSkgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBDb250cmFjdDogdmVyaWZ5IHdpdGggRVJDLTEyNzEuXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtYWdpYyA9IChhd2FpdCBwdWJsaWNDbGllbnQucmVhZENvbnRyYWN0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzOiBhY2NvdW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFiaTogRVJDMTI3MV9BQkksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25OYW1lOiAnaXNWYWxpZFNpZ25hdHVyZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJnczogW2RpZ2VzdCwgc2lnXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IG9rOiBtYWdpYy50b0xvd2VyQ2FzZSgpID09PSBFUkMxMjcxX01BR0lDLCBtZXRob2Q6ICdlcmMxMjcxJywgbWFnaWMgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgb2s6IGZhbHNlLCBtZXRob2Q6ICdlcmMxMjcxJywgZXJyb3I6IGU/Lm1lc3NhZ2UgfHwgU3RyaW5nKGUpIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGNvbnN0IGluaXRpYXRvckNoZWNrID0gYXdhaXQgY2hlY2tTaWduYXR1cmUoaW5pdGlhdG9yUmVzb2x2ZWQsIGluaXRpYXRvclNpZ25hdHVyZSk7XG4gICAgICAgICAgICAgICAgaWYgKCFpbml0aWF0b3JDaGVjay5vaykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEluaXRpYXRvciBzaWduYXR1cmUgY2hlY2sgZmFpbGVkLiBpbml0aWF0b3I9JHtpbml0aWF0b3JSZXNvbHZlZH0gZGlnZXN0PSR7ZGlnZXN0fSBtZXRob2Q9JHtpbml0aWF0b3JDaGVjay5tZXRob2R9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGFwcHJvdmVyQ2hlY2sgPSBhd2FpdCBjaGVja1NpZ25hdHVyZShhcHByb3ZlciwgYXBwcm92ZXJTaWduYXR1cmUpO1xuICAgICAgICAgICAgICAgIGlmICghYXBwcm92ZXJDaGVjay5vaykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEFwcHJvdmVyIHNpZ25hdHVyZSBjaGVjayBmYWlsZWQuIGFwcHJvdmVyPSR7YXBwcm92ZXJ9IGRpZ2VzdD0ke2RpZ2VzdH0gbWV0aG9kPSR7YXBwcm92ZXJDaGVjay5tZXRob2R9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEV4dHJhIHNhbml0eTogZW5zdXJlIHdlJ3JlIHN1Ym1pdHRpbmcgZnJvbSB0aGUgYXBwcm92ZXIgYWNjb3VudCB3ZSB0aGluayB3ZSBhcmUuXG4gICAgICAgICAgICAgICAgY29uc3Qgc3VibWl0dGVyID0gZ2V0QWRkcmVzcyhzdWJtaXR0ZXJBY2NvdW50Q2xpZW50LmFkZHJlc3MpO1xuICAgICAgICAgICAgICAgIGlmICghaXNBZGRyZXNzRXF1YWwoc3VibWl0dGVyLCBhcHByb3ZlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdbZmluYWxpemVBc3NvY2lhdGlvbldpdGhXYWxsZXRdIHN1Ym1pdHRlckFjY291bnRDbGllbnQuYWRkcmVzcyBkb2VzIG5vdCBtYXRjaCBhcHByb3ZlckFkZHJlc3MnLCB7IHN1Ym1pdHRlciwgYXBwcm92ZXIgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChwcmVmbGlnaHRFcnIpIHtcbiAgICAgICAgICAgIC8vIElmIHdlIGNhbiBkZXRlY3QgaW52YWxpZCBzaWduYXR1cmVzLCBzdXJmYWNlIGl0OyBvdGhlcndpc2UgY29udGludWUgdG8gbGV0IGJ1bmRsZXIgZ2l2ZSBtb3JlIGluZm8uXG4gICAgICAgICAgICAvLyAoVGhpcyBibG9jayBpcyBiZXN0LWVmZm9ydCBhbmQgc2hvdWxkIG5vdCBibG9jayBpbiBlbnZpcm9ubWVudHMgd2l0aG91dCBSUEMuKVxuICAgICAgICAgICAgY29uc3QgbXNnID0gcHJlZmxpZ2h0RXJyPy5tZXNzYWdlIHx8IFN0cmluZyhwcmVmbGlnaHRFcnIpO1xuICAgICAgICAgICAgaWYgKG1zZy5pbmNsdWRlcygncmVqZWN0ZWQgc2lnbmF0dXJlJykgfHwgbXNnLmluY2x1ZGVzKCdFUkMtMTI3MScpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgcHJlZmxpZ2h0RXJyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIG9uU3RhdHVzVXBkYXRlPy4oJ1ByZXBhcmluZyBhc3NvY2lhdGlvbiBzdG9yZSB0cmFuc2FjdGlvbiBvbiBzZXJ2ZXIuLi4nKTtcbiAgICBsZXQgcHJlcGFyZWQ7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCgnL2FwaS9hc3NvY2lhdGUnLCB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgZGlkODAwNDogcmVxdWVzdGVyRGlkLFxuICAgICAgICAgICAgaW5pdGlhdG9yQWRkcmVzczogaW5pdGlhdG9yQWRkcmVzc092ZXJyaWRlLFxuICAgICAgICAgICAgYXBwcm92ZXJBZGRyZXNzOiBnZXRBZGRyZXNzKGFwcHJvdmVyQWRkcmVzcyksXG4gICAgICAgICAgICBhc3NvY1R5cGUsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbixcbiAgICAgICAgICAgIHZhbGlkQXQsXG4gICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgaW5pdGlhdG9yU2lnbmF0dXJlLFxuICAgICAgICAgICAgYXBwcm92ZXJTaWduYXR1cmUsXG4gICAgICAgICAgICBtb2RlLFxuICAgICAgICB9KSxcbiAgICB9KTtcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKS5jYXRjaCgoKSA9PiAoe30pKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yRGF0YS5lcnJvciB8fCBlcnJvckRhdGEubWVzc2FnZSB8fCAnRmFpbGVkIHRvIHByZXBhcmUgYXNzb2NpYXRpb24gc3RvcmUnKTtcbiAgICB9XG4gICAgcHJlcGFyZWQgPSAoYXdhaXQgcmVzcG9uc2UuanNvbigpKTtcbiAgICBpZiAobW9kZSA9PT0gJ2VvYScpIHtcbiAgICAgICAgaWYgKCFwcmVwYXJlZC50cmFuc2FjdGlvbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBc3NvY2lhdGlvbiBzdG9yZSByZXNwb25zZSBtaXNzaW5nIHRyYW5zYWN0aW9uIHBheWxvYWQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWFjY291bnQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRU9BIG1vZGUgcmVxdWlyZXMgYWNjb3VudCAoRU9BIHNlbmRlciBhZGRyZXNzKScpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHR4UmVzdWx0ID0gYXdhaXQgc2lnbkFuZFNlbmRUcmFuc2FjdGlvbih7XG4gICAgICAgICAgICB0cmFuc2FjdGlvbjogcHJlcGFyZWQudHJhbnNhY3Rpb24sXG4gICAgICAgICAgICBhY2NvdW50LFxuICAgICAgICAgICAgY2hhaW4sXG4gICAgICAgICAgICBldGhlcmV1bVByb3ZpZGVyLFxuICAgICAgICAgICAgb25TdGF0dXNVcGRhdGUsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4geyB0eEhhc2g6IHR4UmVzdWx0Lmhhc2gsIHJlcXVpcmVzQ2xpZW50U2lnbmluZzogdHJ1ZSB9O1xuICAgIH1cbiAgICBjb25zdCBidW5kbGVyVXJsID0gcHJlcGFyZWQuYnVuZGxlclVybDtcbiAgICBjb25zdCByYXdDYWxscyA9IEFycmF5LmlzQXJyYXkocHJlcGFyZWQuY2FsbHMpID8gcHJlcGFyZWQuY2FsbHMgOiBbXTtcbiAgICBpZiAoIWJ1bmRsZXJVcmwgfHwgcmF3Q2FsbHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQXNzb2NpYXRpb24gc3RvcmUgcmVzcG9uc2UgbWlzc2luZyBidW5kbGVyVXJsIG9yIGNhbGxzJyk7XG4gICAgfVxuICAgIGlmICghc3VibWl0dGVyQWNjb3VudENsaWVudCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NtYXJ0QWNjb3VudCBtb2RlIHJlcXVpcmVzIHN1Ym1pdHRlckFjY291bnRDbGllbnQnKTtcbiAgICB9XG4gICAgY29uc3QgY2FsbHMgPSByYXdDYWxscy5tYXAoKGNhbGwpID0+ICh7XG4gICAgICAgIHRvOiBnZXRBZGRyZXNzKGNhbGwudG8pLFxuICAgICAgICBkYXRhOiBjYWxsLmRhdGEsXG4gICAgICAgIHZhbHVlOiBCaWdJbnQoY2FsbC52YWx1ZSA/PyAnMCcpLFxuICAgIH0pKTtcbiAgICBvblN0YXR1c1VwZGF0ZT8uKCdTdWJtaXR0aW5nIGFzc29jaWF0aW9uIHZpYSBidW5kbGVyLi4uJyk7XG4gICAgY29uc3QgdXNlck9wSGFzaCA9IGF3YWl0IHNlbmRTcG9uc29yZWRVc2VyT3BlcmF0aW9uKHtcbiAgICAgICAgYnVuZGxlclVybCxcbiAgICAgICAgY2hhaW46IGNoYWluLFxuICAgICAgICBhY2NvdW50Q2xpZW50OiBzdWJtaXR0ZXJBY2NvdW50Q2xpZW50LFxuICAgICAgICBjYWxscyxcbiAgICB9KTtcbiAgICBhd2FpdCB3YWl0Rm9yVXNlck9wZXJhdGlvblJlY2VpcHQoe1xuICAgICAgICBidW5kbGVyVXJsLFxuICAgICAgICBjaGFpbjogY2hhaW4sXG4gICAgICAgIGhhc2g6IHVzZXJPcEhhc2gsXG4gICAgfSk7XG4gICAgcmV0dXJuIHsgdHhIYXNoOiB1c2VyT3BIYXNoLCByZXF1aXJlc0NsaWVudFNpZ25pbmc6IHRydWUgfTtcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZXF1ZXN0TmFtZVZhbGlkYXRpb25XaXRoV2FsbGV0KG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IHJlcXVlc3RlckRpZCwgY2hhaW4sIHJlcXVlc3RlckFjY291bnRDbGllbnQsIG1vZGUgPSAnc21hcnRBY2NvdW50JywgZXRoZXJldW1Qcm92aWRlciwgYWNjb3VudCwgcmVxdWVzdFVyaSwgcmVxdWVzdEhhc2gsIG9uU3RhdHVzVXBkYXRlLCB9ID0gb3B0aW9ucztcbiAgICBvblN0YXR1c1VwZGF0ZT8uKCdQcmVwYXJpbmcgdmFsaWRhdGlvbiByZXF1ZXN0IG9uIHNlcnZlci4uLicpO1xuICAgIGNvbnN0IHZhbGlkYXRvck5hbWUgPSAnbmFtZS12YWxpZGF0b3InO1xuICAgIGNvbnN0IGNoYWluSWRGcm9tRGlkID0gKCgpID0+IHtcbiAgICAgICAgY29uc3QgbSA9IHJlcXVlc3RlckRpZC5tYXRjaCgvXmRpZDo4MDA0OihcXGQrKTovKTtcbiAgICAgICAgaWYgKCFtKVxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3QgcGFyc2VkID0gTnVtYmVyKG1bMV0pO1xuICAgICAgICByZXR1cm4gTnVtYmVyLmlzRmluaXRlKHBhcnNlZCkgPyBwYXJzZWQgOiB1bmRlZmluZWQ7XG4gICAgfSkoKTtcbiAgICBhc3luYyBmdW5jdGlvbiByZXNvbHZlVmFsaWRhdG9yQWRkcmVzc0J5TmFtZShwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgdXJsUGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyh7XG4gICAgICAgICAgICBxdWVyeTogcGFyYW1zLnZhbGlkYXRvck5hbWUsXG4gICAgICAgICAgICBwYWdlOiAnMScsXG4gICAgICAgICAgICBwYWdlU2l6ZTogJzEwJyxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYC9hcGkvYWdlbnRzL3NlYXJjaD8ke3VybFBhcmFtcy50b1N0cmluZygpfWApO1xuICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byByZXNvbHZlIHZhbGlkYXRvciBcIiR7cGFyYW1zLnZhbGlkYXRvck5hbWV9XCIgdmlhIGRpc2NvdmVyeSAoc3RhdHVzICR7cmVzcG9uc2Uuc3RhdHVzfSlgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkYXRhID0gKGF3YWl0IHJlc3BvbnNlLmpzb24oKS5jYXRjaCgoKSA9PiAoe30pKSk7XG4gICAgICAgIGNvbnN0IGFnZW50cyA9IEFycmF5LmlzQXJyYXkoZGF0YT8uYWdlbnRzKSA/IGRhdGEuYWdlbnRzIDogW107XG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWROYW1lID0gcGFyYW1zLnZhbGlkYXRvck5hbWUudHJpbSgpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGNvbnN0IGJ5RXhhY3ROYW1lID0gYWdlbnRzLmZpbmQoKGEpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSB0eXBlb2YgYT8uYWdlbnROYW1lID09PSAnc3RyaW5nJyA/IGEuYWdlbnROYW1lLnRyaW0oKS50b0xvd2VyQ2FzZSgpIDogJyc7XG4gICAgICAgICAgICBjb25zdCBjaGFpbklkT2sgPSB0eXBlb2YgcGFyYW1zLmNoYWluSWQgPT09ICdudW1iZXInID8gTnVtYmVyKGE/LmNoYWluSWQpID09PSBwYXJhbXMuY2hhaW5JZCA6IHRydWU7XG4gICAgICAgICAgICBjb25zdCBhY2N0T2sgPSB0eXBlb2YgYT8uYWdlbnRBY2NvdW50ID09PSAnc3RyaW5nJyAmJiBhLmFnZW50QWNjb3VudC5zdGFydHNXaXRoKCcweCcpO1xuICAgICAgICAgICAgcmV0dXJuIGNoYWluSWRPayAmJiBhY2N0T2sgJiYgbmFtZSA9PT0gbm9ybWFsaXplZE5hbWU7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBmYWxsYmFjayA9IGFnZW50cy5maW5kKChhKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjaGFpbklkT2sgPSB0eXBlb2YgcGFyYW1zLmNoYWluSWQgPT09ICdudW1iZXInID8gTnVtYmVyKGE/LmNoYWluSWQpID09PSBwYXJhbXMuY2hhaW5JZCA6IHRydWU7XG4gICAgICAgICAgICBjb25zdCBhY2N0T2sgPSB0eXBlb2YgYT8uYWdlbnRBY2NvdW50ID09PSAnc3RyaW5nJyAmJiBhLmFnZW50QWNjb3VudC5zdGFydHNXaXRoKCcweCcpO1xuICAgICAgICAgICAgcmV0dXJuIGNoYWluSWRPayAmJiBhY2N0T2s7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBhZ2VudEFjY291bnQgPSAoYnlFeGFjdE5hbWU/LmFnZW50QWNjb3VudCA/PyBmYWxsYmFjaz8uYWdlbnRBY2NvdW50KTtcbiAgICAgICAgaWYgKCFhZ2VudEFjY291bnQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVmFsaWRhdG9yIFwiJHtwYXJhbXMudmFsaWRhdG9yTmFtZX1cIiBub3QgZm91bmQgaW4gZGlzY292ZXJ5IChjaGFpbklkPSR7cGFyYW1zLmNoYWluSWQgPz8gJ2FueSd9KWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnZXRBZGRyZXNzKGFnZW50QWNjb3VudCk7XG4gICAgfVxuICAgIGFzeW5jIGZ1bmN0aW9uIHJlc29sdmVWYWxpZGF0b3JBZGRyZXNzKHBhcmFtcykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHJlc29sdmVWYWxpZGF0b3JBZGRyZXNzQnlOYW1lKHBhcmFtcyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKF9kaXNjb3ZlcnlFcnIpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoYWluSWQgPSB0eXBlb2YgcGFyYW1zLmNoYWluSWQgPT09ICdudW1iZXInXG4gICAgICAgICAgICAgICAgPyBwYXJhbXMuY2hhaW5JZFxuICAgICAgICAgICAgICAgIDogdHlwZW9mIGNoYWluPy5pZCA9PT0gJ251bWJlcidcbiAgICAgICAgICAgICAgICAgICAgPyBjaGFpbi5pZFxuICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmICghY2hhaW5JZCkge1xuICAgICAgICAgICAgICAgIHRocm93IF9kaXNjb3ZlcnlFcnI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwID0gYXdhaXQgZmV0Y2goYC9hcGkvdmFsaWRhdG9yLWFkZHJlc3M/dmFsaWRhdG9yTmFtZT0ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMudmFsaWRhdG9yTmFtZSl9JmNoYWluSWQ9JHtlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKGNoYWluSWQpKX1gKTtcbiAgICAgICAgICAgIGlmICghcmVzcC5vaykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVyckRhdGEgPSBhd2FpdCByZXNwLmpzb24oKS5jYXRjaCgoKSA9PiAoe30pKTtcbiAgICAgICAgICAgICAgICBjb25zdCBtc2cgPSBlcnJEYXRhPy5lcnJvciB8fFxuICAgICAgICAgICAgICAgICAgICBlcnJEYXRhPy5tZXNzYWdlIHx8XG4gICAgICAgICAgICAgICAgICAgIGBGYWlsZWQgdG8gcmVzb2x2ZSB2YWxpZGF0b3IgXCIke3BhcmFtcy52YWxpZGF0b3JOYW1lfVwiIHZpYSAvYXBpL3ZhbGlkYXRvci1hZGRyZXNzIChzdGF0dXMgJHtyZXNwLnN0YXR1c30pYDtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSAoYXdhaXQgcmVzcC5qc29uKCkuY2F0Y2goKCkgPT4gKHt9KSkpO1xuICAgICAgICAgICAgY29uc3QgYWRkciA9IHR5cGVvZiBkYXRhPy52YWxpZGF0b3JBZGRyZXNzID09PSAnc3RyaW5nJyA/IGRhdGEudmFsaWRhdG9yQWRkcmVzcyA6ICcnO1xuICAgICAgICAgICAgaWYgKCFhZGRyIHx8ICFhZGRyLnN0YXJ0c1dpdGgoJzB4JykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFZhbGlkYXRvciBcIiR7cGFyYW1zLnZhbGlkYXRvck5hbWV9XCIgYWRkcmVzcyBub3QgcmV0dXJuZWQgYnkgL2FwaS92YWxpZGF0b3ItYWRkcmVzc2ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGdldEFkZHJlc3MoYWRkcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IHByZXBhcmVkO1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3RCb2R5ID0ge1xuICAgICAgICAgICAgcmVxdWVzdFVyaSxcbiAgICAgICAgICAgIHJlcXVlc3RIYXNoLFxuICAgICAgICAgICAgbW9kZSxcbiAgICAgICAgfTtcbiAgICAgICAgLy8gU2VydmVyIHJlcXVpcmVzIHZhbGlkYXRvckFkZHJlc3M7IHJlc29sdmUgdmFsaWRhdG9yTmFtZSAtPiBhZGRyZXNzIGNsaWVudC1zaWRlIGlmIG5lZWRlZC5cbiAgICAgICAgcmVxdWVzdEJvZHkudmFsaWRhdG9yQWRkcmVzcyA9XG4gICAgICAgICAgICAob3B0aW9ucy52YWxpZGF0b3JBZGRyZXNzXG4gICAgICAgICAgICAgICAgPyBnZXRBZGRyZXNzKG9wdGlvbnMudmFsaWRhdG9yQWRkcmVzcylcbiAgICAgICAgICAgICAgICA6IGF3YWl0IHJlc29sdmVWYWxpZGF0b3JBZGRyZXNzKHtcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRhdG9yTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgY2hhaW5JZDogY2hhaW5JZEZyb21EaWQsXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAvYXBpL2FnZW50cy8ke2VuY29kZVVSSUNvbXBvbmVudChyZXF1ZXN0ZXJEaWQpfS92YWxpZGF0aW9uLXJlcXVlc3RgLCB7XG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9LFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkocmVxdWVzdEJvZHkpLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpLmNhdGNoKCgpID0+ICh7fSkpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yRGF0YS5lcnJvciB8fCBlcnJvckRhdGEubWVzc2FnZSB8fCAnRmFpbGVkIHRvIHByZXBhcmUgdmFsaWRhdGlvbiByZXF1ZXN0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcHJlcGFyZWQgPSAoYXdhaXQgcmVzcG9uc2UuanNvbigpKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvciBpbnN0YW5jZW9mIEVycm9yXG4gICAgICAgICAgICA/IGVycm9yLm1lc3NhZ2VcbiAgICAgICAgICAgIDogJ0ZhaWxlZCB0byBwcmVwYXJlIHZhbGlkYXRpb24gcmVxdWVzdCcpO1xuICAgIH1cbiAgICBjb25zdCBidW5kbGVyVXJsID0gcHJlcGFyZWQuYnVuZGxlclVybDtcbiAgICBjb25zdCByYXdDYWxscyA9IEFycmF5LmlzQXJyYXkocHJlcGFyZWQuY2FsbHMpID8gcHJlcGFyZWQuY2FsbHMgOiBbXTtcbiAgICAvLyBFT0EgbW9kZTogc2VydmVyIHJldHVybnMgYSB0cmFuc2FjdGlvbiBwYXlsb2FkLlxuICAgIGlmIChtb2RlID09PSAnZW9hJykge1xuICAgICAgICBpZiAoIXByZXBhcmVkLnRyYW5zYWN0aW9uKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1ZhbGlkYXRpb24gcmVxdWVzdCByZXNwb25zZSBtaXNzaW5nIHRyYW5zYWN0aW9uIHBheWxvYWQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWFjY291bnQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRU9BIG1vZGUgcmVxdWlyZXMgYWNjb3VudCAoRU9BIHNlbmRlciBhZGRyZXNzKScpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHR4UmVzdWx0ID0gYXdhaXQgc2lnbkFuZFNlbmRUcmFuc2FjdGlvbih7XG4gICAgICAgICAgICB0cmFuc2FjdGlvbjogcHJlcGFyZWQudHJhbnNhY3Rpb24sXG4gICAgICAgICAgICBhY2NvdW50LFxuICAgICAgICAgICAgY2hhaW4sXG4gICAgICAgICAgICBldGhlcmV1bVByb3ZpZGVyLFxuICAgICAgICAgICAgb25TdGF0dXNVcGRhdGUsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB2YWxpZGF0b3JBZGRyZXNzID0gcHJlcGFyZWQubWV0YWRhdGE/LnZhbGlkYXRvckFkZHJlc3MgfHxcbiAgICAgICAgICAgIChvcHRpb25zLnZhbGlkYXRvckFkZHJlc3MgPyBnZXRBZGRyZXNzKG9wdGlvbnMudmFsaWRhdG9yQWRkcmVzcykgOiAnJykgfHxcbiAgICAgICAgICAgICcnO1xuICAgICAgICBjb25zdCBmaW5hbFJlcXVlc3RIYXNoID0gcHJlcGFyZWQubWV0YWRhdGE/LnJlcXVlc3RIYXNoIHx8ICcnO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHhIYXNoOiB0eFJlc3VsdC5oYXNoLFxuICAgICAgICAgICAgcmVxdWlyZXNDbGllbnRTaWduaW5nOiB0cnVlLFxuICAgICAgICAgICAgdmFsaWRhdG9yQWRkcmVzcyxcbiAgICAgICAgICAgIHJlcXVlc3RIYXNoOiBmaW5hbFJlcXVlc3RIYXNoLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAoIWJ1bmRsZXJVcmwgfHwgcmF3Q2FsbHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVmFsaWRhdGlvbiByZXF1ZXN0IHJlc3BvbnNlIG1pc3NpbmcgYnVuZGxlclVybCBvciBjYWxscycpO1xuICAgIH1cbiAgICBjb25zdCB2YWxpZGF0aW9uQ2FsbHMgPSByYXdDYWxscy5tYXAoKGNhbGwpID0+ICh7XG4gICAgICAgIHRvOiBjYWxsLnRvLFxuICAgICAgICBkYXRhOiBjYWxsLmRhdGEsXG4gICAgICAgIHZhbHVlOiBCaWdJbnQoY2FsbC52YWx1ZSA/PyAnMCcpLFxuICAgIH0pKTtcbiAgICBvblN0YXR1c1VwZGF0ZT8uKCdTZW5kaW5nIHZhbGlkYXRpb24gcmVxdWVzdCB2aWEgYnVuZGxlci4uLicpO1xuICAgIGNvbnN0IHVzZXJPcEhhc2ggPSBhd2FpdCBzZW5kU3BvbnNvcmVkVXNlck9wZXJhdGlvbih7XG4gICAgICAgIGJ1bmRsZXJVcmwsXG4gICAgICAgIGNoYWluOiBjaGFpbixcbiAgICAgICAgYWNjb3VudENsaWVudDogcmVxdWVzdGVyQWNjb3VudENsaWVudCxcbiAgICAgICAgY2FsbHM6IHZhbGlkYXRpb25DYWxscyxcbiAgICB9KTtcbiAgICBvblN0YXR1c1VwZGF0ZT8uKGBWYWxpZGF0aW9uIHJlcXVlc3Qgc2VudCEgVXNlck9wZXJhdGlvbiBoYXNoOiAke3VzZXJPcEhhc2h9LiBXYWl0aW5nIGZvciBjb25maXJtYXRpb24uLi5gKTtcbiAgICBjb25zdCByZWNlaXB0ID0gYXdhaXQgd2FpdEZvclVzZXJPcGVyYXRpb25SZWNlaXB0KHtcbiAgICAgICAgYnVuZGxlclVybCxcbiAgICAgICAgY2hhaW46IGNoYWluLFxuICAgICAgICBoYXNoOiB1c2VyT3BIYXNoLFxuICAgIH0pO1xuICAgIGNvbnN0IHZhbGlkYXRvckFkZHJlc3MgPSBwcmVwYXJlZC5tZXRhZGF0YT8udmFsaWRhdG9yQWRkcmVzcyB8fFxuICAgICAgICAob3B0aW9ucy52YWxpZGF0b3JBZGRyZXNzID8gZ2V0QWRkcmVzcyhvcHRpb25zLnZhbGlkYXRvckFkZHJlc3MpIDogJycpIHx8XG4gICAgICAgICcnO1xuICAgIGNvbnN0IGZpbmFsUmVxdWVzdEhhc2ggPSBwcmVwYXJlZC5tZXRhZGF0YT8ucmVxdWVzdEhhc2ggfHwgJyc7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHhIYXNoOiB1c2VyT3BIYXNoLFxuICAgICAgICByZXF1aXJlc0NsaWVudFNpZ25pbmc6IHRydWUsXG4gICAgICAgIHZhbGlkYXRvckFkZHJlc3MsXG4gICAgICAgIHJlcXVlc3RIYXNoOiBmaW5hbFJlcXVlc3RIYXNoLFxuICAgIH07XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVxdWVzdEFjY291bnRWYWxpZGF0aW9uV2l0aFdhbGxldChvcHRpb25zKSB7XG4gICAgY29uc3QgeyByZXF1ZXN0ZXJEaWQsIGNoYWluLCByZXF1ZXN0ZXJBY2NvdW50Q2xpZW50LCBtb2RlID0gJ3NtYXJ0QWNjb3VudCcsIGV0aGVyZXVtUHJvdmlkZXIsIGFjY291bnQsIHJlcXVlc3RVcmksIHJlcXVlc3RIYXNoLCBvblN0YXR1c1VwZGF0ZSwgfSA9IG9wdGlvbnM7XG4gICAgb25TdGF0dXNVcGRhdGU/LignUHJlcGFyaW5nIHZhbGlkYXRpb24gcmVxdWVzdCBvbiBzZXJ2ZXIuLi4nKTtcbiAgICBjb25zdCB2YWxpZGF0b3JOYW1lID0gJ2FjY291bnQtdmFsaWRhdG9yJztcbiAgICBjb25zdCBjaGFpbklkRnJvbURpZCA9ICgoKSA9PiB7XG4gICAgICAgIGNvbnN0IG0gPSByZXF1ZXN0ZXJEaWQubWF0Y2goL15kaWQ6ODAwNDooXFxkKyk6Lyk7XG4gICAgICAgIGlmICghbSlcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IHBhcnNlZCA9IE51bWJlcihtWzFdKTtcbiAgICAgICAgcmV0dXJuIE51bWJlci5pc0Zpbml0ZShwYXJzZWQpID8gcGFyc2VkIDogdW5kZWZpbmVkO1xuICAgIH0pKCk7XG4gICAgYXN5bmMgZnVuY3Rpb24gcmVzb2x2ZVZhbGlkYXRvckFkZHJlc3NCeU5hbWUocGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IHVybFBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoe1xuICAgICAgICAgICAgcXVlcnk6IHBhcmFtcy52YWxpZGF0b3JOYW1lLFxuICAgICAgICAgICAgcGFnZTogJzEnLFxuICAgICAgICAgICAgcGFnZVNpemU6ICcxMCcsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAvYXBpL2FnZW50cy9zZWFyY2g/JHt1cmxQYXJhbXMudG9TdHJpbmcoKX1gKTtcbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gcmVzb2x2ZSB2YWxpZGF0b3IgXCIke3BhcmFtcy52YWxpZGF0b3JOYW1lfVwiIHZpYSBkaXNjb3ZlcnkgKHN0YXR1cyAke3Jlc3BvbnNlLnN0YXR1c30pYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGF0YSA9IChhd2FpdCByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gKHt9KSkpO1xuICAgICAgICBjb25zdCBhZ2VudHMgPSBBcnJheS5pc0FycmF5KGRhdGE/LmFnZW50cykgPyBkYXRhLmFnZW50cyA6IFtdO1xuICAgICAgICBjb25zdCBub3JtYWxpemVkTmFtZSA9IHBhcmFtcy52YWxpZGF0b3JOYW1lLnRyaW0oKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBjb25zdCBieUV4YWN0TmFtZSA9IGFnZW50cy5maW5kKChhKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gdHlwZW9mIGE/LmFnZW50TmFtZSA9PT0gJ3N0cmluZycgPyBhLmFnZW50TmFtZS50cmltKCkudG9Mb3dlckNhc2UoKSA6ICcnO1xuICAgICAgICAgICAgY29uc3QgY2hhaW5JZE9rID0gdHlwZW9mIHBhcmFtcy5jaGFpbklkID09PSAnbnVtYmVyJyA/IE51bWJlcihhPy5jaGFpbklkKSA9PT0gcGFyYW1zLmNoYWluSWQgOiB0cnVlO1xuICAgICAgICAgICAgY29uc3QgYWNjdE9rID0gdHlwZW9mIGE/LmFnZW50QWNjb3VudCA9PT0gJ3N0cmluZycgJiYgYS5hZ2VudEFjY291bnQuc3RhcnRzV2l0aCgnMHgnKTtcbiAgICAgICAgICAgIHJldHVybiBjaGFpbklkT2sgJiYgYWNjdE9rICYmIG5hbWUgPT09IG5vcm1hbGl6ZWROYW1lO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgZmFsbGJhY2sgPSBhZ2VudHMuZmluZCgoYSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY2hhaW5JZE9rID0gdHlwZW9mIHBhcmFtcy5jaGFpbklkID09PSAnbnVtYmVyJyA/IE51bWJlcihhPy5jaGFpbklkKSA9PT0gcGFyYW1zLmNoYWluSWQgOiB0cnVlO1xuICAgICAgICAgICAgY29uc3QgYWNjdE9rID0gdHlwZW9mIGE/LmFnZW50QWNjb3VudCA9PT0gJ3N0cmluZycgJiYgYS5hZ2VudEFjY291bnQuc3RhcnRzV2l0aCgnMHgnKTtcbiAgICAgICAgICAgIHJldHVybiBjaGFpbklkT2sgJiYgYWNjdE9rO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgYWdlbnRBY2NvdW50ID0gKGJ5RXhhY3ROYW1lPy5hZ2VudEFjY291bnQgPz8gZmFsbGJhY2s/LmFnZW50QWNjb3VudCk7XG4gICAgICAgIGlmICghYWdlbnRBY2NvdW50KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFZhbGlkYXRvciBcIiR7cGFyYW1zLnZhbGlkYXRvck5hbWV9XCIgbm90IGZvdW5kIGluIGRpc2NvdmVyeSAoY2hhaW5JZD0ke3BhcmFtcy5jaGFpbklkID8/ICdhbnknfSlgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ2V0QWRkcmVzcyhhZ2VudEFjY291bnQpO1xuICAgIH1cbiAgICBhc3luYyBmdW5jdGlvbiByZXNvbHZlVmFsaWRhdG9yQWRkcmVzcyhwYXJhbXMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCByZXNvbHZlVmFsaWRhdG9yQWRkcmVzc0J5TmFtZShwYXJhbXMpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChfZGlzY292ZXJ5RXJyKSB7XG4gICAgICAgICAgICBjb25zdCBjaGFpbklkID0gdHlwZW9mIHBhcmFtcy5jaGFpbklkID09PSAnbnVtYmVyJ1xuICAgICAgICAgICAgICAgID8gcGFyYW1zLmNoYWluSWRcbiAgICAgICAgICAgICAgICA6IHR5cGVvZiBjaGFpbj8uaWQgPT09ICdudW1iZXInXG4gICAgICAgICAgICAgICAgICAgID8gY2hhaW4uaWRcbiAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAoIWNoYWluSWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBfZGlzY292ZXJ5RXJyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcCA9IGF3YWl0IGZldGNoKGAvYXBpL3ZhbGlkYXRvci1hZGRyZXNzP3ZhbGlkYXRvck5hbWU9JHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLnZhbGlkYXRvck5hbWUpfSZjaGFpbklkPSR7ZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhjaGFpbklkKSl9YCk7XG4gICAgICAgICAgICBpZiAoIXJlc3Aub2spIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJEYXRhID0gYXdhaXQgcmVzcC5qc29uKCkuY2F0Y2goKCkgPT4gKHt9KSk7XG4gICAgICAgICAgICAgICAgY29uc3QgbXNnID0gZXJyRGF0YT8uZXJyb3IgfHxcbiAgICAgICAgICAgICAgICAgICAgZXJyRGF0YT8ubWVzc2FnZSB8fFxuICAgICAgICAgICAgICAgICAgICBgRmFpbGVkIHRvIHJlc29sdmUgdmFsaWRhdG9yIFwiJHtwYXJhbXMudmFsaWRhdG9yTmFtZX1cIiB2aWEgL2FwaS92YWxpZGF0b3ItYWRkcmVzcyAoc3RhdHVzICR7cmVzcC5zdGF0dXN9KWA7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBkYXRhID0gKGF3YWl0IHJlc3AuanNvbigpLmNhdGNoKCgpID0+ICh7fSkpKTtcbiAgICAgICAgICAgIGNvbnN0IGFkZHIgPSB0eXBlb2YgZGF0YT8udmFsaWRhdG9yQWRkcmVzcyA9PT0gJ3N0cmluZycgPyBkYXRhLnZhbGlkYXRvckFkZHJlc3MgOiAnJztcbiAgICAgICAgICAgIGlmICghYWRkciB8fCAhYWRkci5zdGFydHNXaXRoKCcweCcpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBWYWxpZGF0b3IgXCIke3BhcmFtcy52YWxpZGF0b3JOYW1lfVwiIGFkZHJlc3Mgbm90IHJldHVybmVkIGJ5IC9hcGkvdmFsaWRhdG9yLWFkZHJlc3NgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBnZXRBZGRyZXNzKGFkZHIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxldCBwcmVwYXJlZDtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCByZXF1ZXN0Qm9keSA9IHtcbiAgICAgICAgICAgIHJlcXVlc3RVcmksXG4gICAgICAgICAgICByZXF1ZXN0SGFzaCxcbiAgICAgICAgICAgIG1vZGU6ICdzbWFydEFjY291bnQnLFxuICAgICAgICB9O1xuICAgICAgICAvLyBTZXJ2ZXIgcmVxdWlyZXMgdmFsaWRhdG9yQWRkcmVzczsgcmVzb2x2ZSB2YWxpZGF0b3JOYW1lIC0+IGFkZHJlc3MgY2xpZW50LXNpZGUgaWYgbmVlZGVkLlxuICAgICAgICByZXF1ZXN0Qm9keS52YWxpZGF0b3JBZGRyZXNzID1cbiAgICAgICAgICAgIChvcHRpb25zLnZhbGlkYXRvckFkZHJlc3NcbiAgICAgICAgICAgICAgICA/IGdldEFkZHJlc3Mob3B0aW9ucy52YWxpZGF0b3JBZGRyZXNzKVxuICAgICAgICAgICAgICAgIDogYXdhaXQgcmVzb2x2ZVZhbGlkYXRvckFkZHJlc3Moe1xuICAgICAgICAgICAgICAgICAgICB2YWxpZGF0b3JOYW1lLFxuICAgICAgICAgICAgICAgICAgICBjaGFpbklkOiBjaGFpbklkRnJvbURpZCxcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYC9hcGkvYWdlbnRzLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHJlcXVlc3RlckRpZCl9L3ZhbGlkYXRpb24tcmVxdWVzdGAsIHtcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH0sXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShyZXF1ZXN0Qm9keSksXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gKHt9KSk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JEYXRhLmVycm9yIHx8IGVycm9yRGF0YS5tZXNzYWdlIHx8ICdGYWlsZWQgdG8gcHJlcGFyZSB2YWxpZGF0aW9uIHJlcXVlc3QnKTtcbiAgICAgICAgfVxuICAgICAgICBwcmVwYXJlZCA9IChhd2FpdCByZXNwb25zZS5qc29uKCkpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yIGluc3RhbmNlb2YgRXJyb3JcbiAgICAgICAgICAgID8gZXJyb3IubWVzc2FnZVxuICAgICAgICAgICAgOiAnRmFpbGVkIHRvIHByZXBhcmUgdmFsaWRhdGlvbiByZXF1ZXN0Jyk7XG4gICAgfVxuICAgIGNvbnN0IGJ1bmRsZXJVcmwgPSBwcmVwYXJlZC5idW5kbGVyVXJsO1xuICAgIGNvbnN0IHJhd0NhbGxzID0gQXJyYXkuaXNBcnJheShwcmVwYXJlZC5jYWxscykgPyBwcmVwYXJlZC5jYWxscyA6IFtdO1xuICAgIGlmIChtb2RlID09PSAnZW9hJykge1xuICAgICAgICBpZiAoIXByZXBhcmVkLnRyYW5zYWN0aW9uKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1ZhbGlkYXRpb24gcmVxdWVzdCByZXNwb25zZSBtaXNzaW5nIHRyYW5zYWN0aW9uIHBheWxvYWQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWFjY291bnQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRU9BIG1vZGUgcmVxdWlyZXMgYWNjb3VudCAoRU9BIHNlbmRlciBhZGRyZXNzKScpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHR4UmVzdWx0ID0gYXdhaXQgc2lnbkFuZFNlbmRUcmFuc2FjdGlvbih7XG4gICAgICAgICAgICB0cmFuc2FjdGlvbjogcHJlcGFyZWQudHJhbnNhY3Rpb24sXG4gICAgICAgICAgICBhY2NvdW50LFxuICAgICAgICAgICAgY2hhaW4sXG4gICAgICAgICAgICBldGhlcmV1bVByb3ZpZGVyLFxuICAgICAgICAgICAgb25TdGF0dXNVcGRhdGUsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB2YWxpZGF0b3JBZGRyZXNzID0gcHJlcGFyZWQubWV0YWRhdGE/LnZhbGlkYXRvckFkZHJlc3MgfHxcbiAgICAgICAgICAgIChvcHRpb25zLnZhbGlkYXRvckFkZHJlc3MgPyBnZXRBZGRyZXNzKG9wdGlvbnMudmFsaWRhdG9yQWRkcmVzcykgOiAnJykgfHxcbiAgICAgICAgICAgICcnO1xuICAgICAgICBjb25zdCBmaW5hbFJlcXVlc3RIYXNoID0gcHJlcGFyZWQubWV0YWRhdGE/LnJlcXVlc3RIYXNoIHx8ICcnO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHhIYXNoOiB0eFJlc3VsdC5oYXNoLFxuICAgICAgICAgICAgcmVxdWlyZXNDbGllbnRTaWduaW5nOiB0cnVlLFxuICAgICAgICAgICAgdmFsaWRhdG9yQWRkcmVzcyxcbiAgICAgICAgICAgIHJlcXVlc3RIYXNoOiBmaW5hbFJlcXVlc3RIYXNoLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAoIWJ1bmRsZXJVcmwgfHwgcmF3Q2FsbHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVmFsaWRhdGlvbiByZXF1ZXN0IHJlc3BvbnNlIG1pc3NpbmcgYnVuZGxlclVybCBvciBjYWxscycpO1xuICAgIH1cbiAgICBjb25zdCB2YWxpZGF0aW9uQ2FsbHMgPSByYXdDYWxscy5tYXAoKGNhbGwpID0+ICh7XG4gICAgICAgIHRvOiBjYWxsLnRvLFxuICAgICAgICBkYXRhOiBjYWxsLmRhdGEsXG4gICAgICAgIHZhbHVlOiBCaWdJbnQoY2FsbC52YWx1ZSA/PyAnMCcpLFxuICAgIH0pKTtcbiAgICBvblN0YXR1c1VwZGF0ZT8uKCdTZW5kaW5nIHZhbGlkYXRpb24gcmVxdWVzdCB2aWEgYnVuZGxlci4uLicpO1xuICAgIGNvbnN0IHVzZXJPcEhhc2ggPSBhd2FpdCBzZW5kU3BvbnNvcmVkVXNlck9wZXJhdGlvbih7XG4gICAgICAgIGJ1bmRsZXJVcmwsXG4gICAgICAgIGNoYWluOiBjaGFpbixcbiAgICAgICAgYWNjb3VudENsaWVudDogcmVxdWVzdGVyQWNjb3VudENsaWVudCxcbiAgICAgICAgY2FsbHM6IHZhbGlkYXRpb25DYWxscyxcbiAgICB9KTtcbiAgICBvblN0YXR1c1VwZGF0ZT8uKGBWYWxpZGF0aW9uIHJlcXVlc3Qgc2VudCEgVXNlck9wZXJhdGlvbiBoYXNoOiAke3VzZXJPcEhhc2h9LiBXYWl0aW5nIGZvciBjb25maXJtYXRpb24uLi5gKTtcbiAgICBjb25zdCByZWNlaXB0ID0gYXdhaXQgd2FpdEZvclVzZXJPcGVyYXRpb25SZWNlaXB0KHtcbiAgICAgICAgYnVuZGxlclVybCxcbiAgICAgICAgY2hhaW46IGNoYWluLFxuICAgICAgICBoYXNoOiB1c2VyT3BIYXNoLFxuICAgIH0pO1xuICAgIGNvbnN0IHZhbGlkYXRvckFkZHJlc3MgPSBwcmVwYXJlZC5tZXRhZGF0YT8udmFsaWRhdG9yQWRkcmVzcyB8fFxuICAgICAgICAob3B0aW9ucy52YWxpZGF0b3JBZGRyZXNzID8gZ2V0QWRkcmVzcyhvcHRpb25zLnZhbGlkYXRvckFkZHJlc3MpIDogJycpIHx8XG4gICAgICAgICcnO1xuICAgIGNvbnN0IGZpbmFsUmVxdWVzdEhhc2ggPSBwcmVwYXJlZC5tZXRhZGF0YT8ucmVxdWVzdEhhc2ggfHwgJyc7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHhIYXNoOiB1c2VyT3BIYXNoLFxuICAgICAgICByZXF1aXJlc0NsaWVudFNpZ25pbmc6IHRydWUsXG4gICAgICAgIHZhbGlkYXRvckFkZHJlc3MsXG4gICAgICAgIHJlcXVlc3RIYXNoOiBmaW5hbFJlcXVlc3RIYXNoLFxuICAgIH07XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVxdWVzdEFwcFZhbGlkYXRpb25XaXRoV2FsbGV0KG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IHJlcXVlc3RlckRpZCwgY2hhaW4sIHJlcXVlc3RlckFjY291bnRDbGllbnQsIG1vZGUgPSAnc21hcnRBY2NvdW50JywgZXRoZXJldW1Qcm92aWRlciwgYWNjb3VudCwgcmVxdWVzdFVyaSwgcmVxdWVzdEhhc2gsIG9uU3RhdHVzVXBkYXRlLCB9ID0gb3B0aW9ucztcbiAgICBvblN0YXR1c1VwZGF0ZT8uKCdQcmVwYXJpbmcgdmFsaWRhdGlvbiByZXF1ZXN0IG9uIHNlcnZlci4uLicpO1xuICAgIGNvbnN0IHZhbGlkYXRvck5hbWUgPSAnYXBwLXZhbGlkYXRvcic7XG4gICAgY29uc3QgY2hhaW5JZEZyb21EaWQgPSAoKCkgPT4ge1xuICAgICAgICBjb25zdCBtID0gcmVxdWVzdGVyRGlkLm1hdGNoKC9eZGlkOjgwMDQ6KFxcZCspOi8pO1xuICAgICAgICBpZiAoIW0pXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBwYXJzZWQgPSBOdW1iZXIobVsxXSk7XG4gICAgICAgIHJldHVybiBOdW1iZXIuaXNGaW5pdGUocGFyc2VkKSA/IHBhcnNlZCA6IHVuZGVmaW5lZDtcbiAgICB9KSgpO1xuICAgIGFzeW5jIGZ1bmN0aW9uIHJlc29sdmVWYWxpZGF0b3JBZGRyZXNzQnlOYW1lKHBhcmFtcykge1xuICAgICAgICBjb25zdCB1cmxQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHtcbiAgICAgICAgICAgIHF1ZXJ5OiBwYXJhbXMudmFsaWRhdG9yTmFtZSxcbiAgICAgICAgICAgIHBhZ2U6ICcxJyxcbiAgICAgICAgICAgIHBhZ2VTaXplOiAnMTAnLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgL2FwaS9hZ2VudHMvc2VhcmNoPyR7dXJsUGFyYW1zLnRvU3RyaW5nKCl9YCk7XG4gICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHJlc29sdmUgdmFsaWRhdG9yIFwiJHtwYXJhbXMudmFsaWRhdG9yTmFtZX1cIiB2aWEgZGlzY292ZXJ5IChzdGF0dXMgJHtyZXNwb25zZS5zdGF0dXN9KWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRhdGEgPSAoYXdhaXQgcmVzcG9uc2UuanNvbigpLmNhdGNoKCgpID0+ICh7fSkpKTtcbiAgICAgICAgY29uc3QgYWdlbnRzID0gQXJyYXkuaXNBcnJheShkYXRhPy5hZ2VudHMpID8gZGF0YS5hZ2VudHMgOiBbXTtcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZE5hbWUgPSBwYXJhbXMudmFsaWRhdG9yTmFtZS50cmltKCkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgY29uc3QgYnlFeGFjdE5hbWUgPSBhZ2VudHMuZmluZCgoYSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbmFtZSA9IHR5cGVvZiBhPy5hZ2VudE5hbWUgPT09ICdzdHJpbmcnID8gYS5hZ2VudE5hbWUudHJpbSgpLnRvTG93ZXJDYXNlKCkgOiAnJztcbiAgICAgICAgICAgIGNvbnN0IGNoYWluSWRPayA9IHR5cGVvZiBwYXJhbXMuY2hhaW5JZCA9PT0gJ251bWJlcicgPyBOdW1iZXIoYT8uY2hhaW5JZCkgPT09IHBhcmFtcy5jaGFpbklkIDogdHJ1ZTtcbiAgICAgICAgICAgIGNvbnN0IGFjY3RPayA9IHR5cGVvZiBhPy5hZ2VudEFjY291bnQgPT09ICdzdHJpbmcnICYmIGEuYWdlbnRBY2NvdW50LnN0YXJ0c1dpdGgoJzB4Jyk7XG4gICAgICAgICAgICByZXR1cm4gY2hhaW5JZE9rICYmIGFjY3RPayAmJiBuYW1lID09PSBub3JtYWxpemVkTmFtZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGZhbGxiYWNrID0gYWdlbnRzLmZpbmQoKGEpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNoYWluSWRPayA9IHR5cGVvZiBwYXJhbXMuY2hhaW5JZCA9PT0gJ251bWJlcicgPyBOdW1iZXIoYT8uY2hhaW5JZCkgPT09IHBhcmFtcy5jaGFpbklkIDogdHJ1ZTtcbiAgICAgICAgICAgIGNvbnN0IGFjY3RPayA9IHR5cGVvZiBhPy5hZ2VudEFjY291bnQgPT09ICdzdHJpbmcnICYmIGEuYWdlbnRBY2NvdW50LnN0YXJ0c1dpdGgoJzB4Jyk7XG4gICAgICAgICAgICByZXR1cm4gY2hhaW5JZE9rICYmIGFjY3RPaztcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGFnZW50QWNjb3VudCA9IChieUV4YWN0TmFtZT8uYWdlbnRBY2NvdW50ID8/IGZhbGxiYWNrPy5hZ2VudEFjY291bnQpO1xuICAgICAgICBpZiAoIWFnZW50QWNjb3VudCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBWYWxpZGF0b3IgXCIke3BhcmFtcy52YWxpZGF0b3JOYW1lfVwiIG5vdCBmb3VuZCBpbiBkaXNjb3ZlcnkgKGNoYWluSWQ9JHtwYXJhbXMuY2hhaW5JZCA/PyAnYW55J30pYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdldEFkZHJlc3MoYWdlbnRBY2NvdW50KTtcbiAgICB9XG4gICAgYXN5bmMgZnVuY3Rpb24gcmVzb2x2ZVZhbGlkYXRvckFkZHJlc3MocGFyYW1zKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgcmVzb2x2ZVZhbGlkYXRvckFkZHJlc3NCeU5hbWUocGFyYW1zKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoX2Rpc2NvdmVyeUVycikge1xuICAgICAgICAgICAgY29uc3QgY2hhaW5JZCA9IHR5cGVvZiBwYXJhbXMuY2hhaW5JZCA9PT0gJ251bWJlcidcbiAgICAgICAgICAgICAgICA/IHBhcmFtcy5jaGFpbklkXG4gICAgICAgICAgICAgICAgOiB0eXBlb2YgY2hhaW4/LmlkID09PSAnbnVtYmVyJ1xuICAgICAgICAgICAgICAgICAgICA/IGNoYWluLmlkXG4gICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKCFjaGFpbklkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgX2Rpc2NvdmVyeUVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBhd2FpdCBmZXRjaChgL2FwaS92YWxpZGF0b3ItYWRkcmVzcz92YWxpZGF0b3JOYW1lPSR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy52YWxpZGF0b3JOYW1lKX0mY2hhaW5JZD0ke2VuY29kZVVSSUNvbXBvbmVudChTdHJpbmcoY2hhaW5JZCkpfWApO1xuICAgICAgICAgICAgaWYgKCFyZXNwLm9rKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyRGF0YSA9IGF3YWl0IHJlc3AuanNvbigpLmNhdGNoKCgpID0+ICh7fSkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG1zZyA9IGVyckRhdGE/LmVycm9yIHx8XG4gICAgICAgICAgICAgICAgICAgIGVyckRhdGE/Lm1lc3NhZ2UgfHxcbiAgICAgICAgICAgICAgICAgICAgYEZhaWxlZCB0byByZXNvbHZlIHZhbGlkYXRvciBcIiR7cGFyYW1zLnZhbGlkYXRvck5hbWV9XCIgdmlhIC9hcGkvdmFsaWRhdG9yLWFkZHJlc3MgKHN0YXR1cyAke3Jlc3Auc3RhdHVzfSlgO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZGF0YSA9IChhd2FpdCByZXNwLmpzb24oKS5jYXRjaCgoKSA9PiAoe30pKSk7XG4gICAgICAgICAgICBjb25zdCBhZGRyID0gdHlwZW9mIGRhdGE/LnZhbGlkYXRvckFkZHJlc3MgPT09ICdzdHJpbmcnID8gZGF0YS52YWxpZGF0b3JBZGRyZXNzIDogJyc7XG4gICAgICAgICAgICBpZiAoIWFkZHIgfHwgIWFkZHIuc3RhcnRzV2l0aCgnMHgnKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVmFsaWRhdG9yIFwiJHtwYXJhbXMudmFsaWRhdG9yTmFtZX1cIiBhZGRyZXNzIG5vdCByZXR1cm5lZCBieSAvYXBpL3ZhbGlkYXRvci1hZGRyZXNzYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZ2V0QWRkcmVzcyhhZGRyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgcHJlcGFyZWQ7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVxdWVzdEJvZHkgPSB7XG4gICAgICAgICAgICByZXF1ZXN0VXJpLFxuICAgICAgICAgICAgcmVxdWVzdEhhc2gsXG4gICAgICAgICAgICBtb2RlLFxuICAgICAgICB9O1xuICAgICAgICByZXF1ZXN0Qm9keS52YWxpZGF0b3JBZGRyZXNzID1cbiAgICAgICAgICAgIChvcHRpb25zLnZhbGlkYXRvckFkZHJlc3NcbiAgICAgICAgICAgICAgICA/IGdldEFkZHJlc3Mob3B0aW9ucy52YWxpZGF0b3JBZGRyZXNzKVxuICAgICAgICAgICAgICAgIDogYXdhaXQgcmVzb2x2ZVZhbGlkYXRvckFkZHJlc3Moe1xuICAgICAgICAgICAgICAgICAgICB2YWxpZGF0b3JOYW1lLFxuICAgICAgICAgICAgICAgICAgICBjaGFpbklkOiBjaGFpbklkRnJvbURpZCxcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYC9hcGkvYWdlbnRzLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHJlcXVlc3RlckRpZCl9L3ZhbGlkYXRpb24tcmVxdWVzdGAsIHtcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH0sXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShyZXF1ZXN0Qm9keSksXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gKHt9KSk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JEYXRhLmVycm9yIHx8IGVycm9yRGF0YS5tZXNzYWdlIHx8ICdGYWlsZWQgdG8gcHJlcGFyZSB2YWxpZGF0aW9uIHJlcXVlc3QnKTtcbiAgICAgICAgfVxuICAgICAgICBwcmVwYXJlZCA9IChhd2FpdCByZXNwb25zZS5qc29uKCkpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yIGluc3RhbmNlb2YgRXJyb3JcbiAgICAgICAgICAgID8gZXJyb3IubWVzc2FnZVxuICAgICAgICAgICAgOiAnRmFpbGVkIHRvIHByZXBhcmUgdmFsaWRhdGlvbiByZXF1ZXN0Jyk7XG4gICAgfVxuICAgIGNvbnN0IGJ1bmRsZXJVcmwgPSBwcmVwYXJlZC5idW5kbGVyVXJsO1xuICAgIGNvbnN0IHJhd0NhbGxzID0gQXJyYXkuaXNBcnJheShwcmVwYXJlZC5jYWxscykgPyBwcmVwYXJlZC5jYWxscyA6IFtdO1xuICAgIGlmIChtb2RlID09PSAnZW9hJykge1xuICAgICAgICBpZiAoIXByZXBhcmVkLnRyYW5zYWN0aW9uKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1ZhbGlkYXRpb24gcmVxdWVzdCByZXNwb25zZSBtaXNzaW5nIHRyYW5zYWN0aW9uIHBheWxvYWQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWFjY291bnQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRU9BIG1vZGUgcmVxdWlyZXMgYWNjb3VudCAoRU9BIHNlbmRlciBhZGRyZXNzKScpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHR4UmVzdWx0ID0gYXdhaXQgc2lnbkFuZFNlbmRUcmFuc2FjdGlvbih7XG4gICAgICAgICAgICB0cmFuc2FjdGlvbjogcHJlcGFyZWQudHJhbnNhY3Rpb24sXG4gICAgICAgICAgICBhY2NvdW50LFxuICAgICAgICAgICAgY2hhaW4sXG4gICAgICAgICAgICBldGhlcmV1bVByb3ZpZGVyLFxuICAgICAgICAgICAgb25TdGF0dXNVcGRhdGUsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB2YWxpZGF0b3JBZGRyZXNzID0gcHJlcGFyZWQubWV0YWRhdGE/LnZhbGlkYXRvckFkZHJlc3MgfHxcbiAgICAgICAgICAgIChvcHRpb25zLnZhbGlkYXRvckFkZHJlc3MgPyBnZXRBZGRyZXNzKG9wdGlvbnMudmFsaWRhdG9yQWRkcmVzcykgOiAnJykgfHxcbiAgICAgICAgICAgICcnO1xuICAgICAgICBjb25zdCBmaW5hbFJlcXVlc3RIYXNoID0gcHJlcGFyZWQubWV0YWRhdGE/LnJlcXVlc3RIYXNoIHx8ICcnO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHhIYXNoOiB0eFJlc3VsdC5oYXNoLFxuICAgICAgICAgICAgcmVxdWlyZXNDbGllbnRTaWduaW5nOiB0cnVlLFxuICAgICAgICAgICAgdmFsaWRhdG9yQWRkcmVzcyxcbiAgICAgICAgICAgIHJlcXVlc3RIYXNoOiBmaW5hbFJlcXVlc3RIYXNoLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAoIWJ1bmRsZXJVcmwgfHwgcmF3Q2FsbHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVmFsaWRhdGlvbiByZXF1ZXN0IHJlc3BvbnNlIG1pc3NpbmcgYnVuZGxlclVybCBvciBjYWxscycpO1xuICAgIH1cbiAgICBjb25zdCB2YWxpZGF0aW9uQ2FsbHMgPSByYXdDYWxscy5tYXAoKGNhbGwpID0+ICh7XG4gICAgICAgIHRvOiBjYWxsLnRvLFxuICAgICAgICBkYXRhOiBjYWxsLmRhdGEsXG4gICAgICAgIHZhbHVlOiBCaWdJbnQoY2FsbC52YWx1ZSA/PyAnMCcpLFxuICAgIH0pKTtcbiAgICBvblN0YXR1c1VwZGF0ZT8uKCdTZW5kaW5nIHZhbGlkYXRpb24gcmVxdWVzdCB2aWEgYnVuZGxlci4uLicpO1xuICAgIGNvbnN0IHVzZXJPcEhhc2ggPSBhd2FpdCBzZW5kU3BvbnNvcmVkVXNlck9wZXJhdGlvbih7XG4gICAgICAgIGJ1bmRsZXJVcmwsXG4gICAgICAgIGNoYWluOiBjaGFpbixcbiAgICAgICAgYWNjb3VudENsaWVudDogcmVxdWVzdGVyQWNjb3VudENsaWVudCxcbiAgICAgICAgY2FsbHM6IHZhbGlkYXRpb25DYWxscyxcbiAgICB9KTtcbiAgICBvblN0YXR1c1VwZGF0ZT8uKGBWYWxpZGF0aW9uIHJlcXVlc3Qgc2VudCEgVXNlck9wZXJhdGlvbiBoYXNoOiAke3VzZXJPcEhhc2h9LiBXYWl0aW5nIGZvciBjb25maXJtYXRpb24uLi5gKTtcbiAgICBjb25zdCByZWNlaXB0ID0gYXdhaXQgd2FpdEZvclVzZXJPcGVyYXRpb25SZWNlaXB0KHtcbiAgICAgICAgYnVuZGxlclVybCxcbiAgICAgICAgY2hhaW46IGNoYWluLFxuICAgICAgICBoYXNoOiB1c2VyT3BIYXNoLFxuICAgIH0pO1xuICAgIGNvbnN0IHZhbGlkYXRvckFkZHJlc3MgPSBwcmVwYXJlZC5tZXRhZGF0YT8udmFsaWRhdG9yQWRkcmVzcyB8fFxuICAgICAgICAob3B0aW9ucy52YWxpZGF0b3JBZGRyZXNzID8gZ2V0QWRkcmVzcyhvcHRpb25zLnZhbGlkYXRvckFkZHJlc3MpIDogJycpIHx8XG4gICAgICAgICcnO1xuICAgIGNvbnN0IGZpbmFsUmVxdWVzdEhhc2ggPSBwcmVwYXJlZC5tZXRhZGF0YT8ucmVxdWVzdEhhc2ggfHwgJyc7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHhIYXNoOiB1c2VyT3BIYXNoLFxuICAgICAgICByZXF1aXJlc0NsaWVudFNpZ25pbmc6IHRydWUsXG4gICAgICAgIHZhbGlkYXRvckFkZHJlc3MsXG4gICAgICAgIHJlcXVlc3RIYXNoOiBmaW5hbFJlcXVlc3RIYXNoLFxuICAgIH07XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVxdWVzdEFJRFZhbGlkYXRpb25XaXRoV2FsbGV0KG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IHJlcXVlc3RlckRpZCwgY2hhaW4sIHJlcXVlc3RlckFjY291bnRDbGllbnQsIG1vZGUgPSAnc21hcnRBY2NvdW50JywgZXRoZXJldW1Qcm92aWRlciwgYWNjb3VudCwgcmVxdWVzdFVyaSwgcmVxdWVzdEhhc2gsIG9uU3RhdHVzVXBkYXRlLCB9ID0gb3B0aW9ucztcbiAgICBvblN0YXR1c1VwZGF0ZT8uKCdQcmVwYXJpbmcgdmFsaWRhdGlvbiByZXF1ZXN0IG9uIHNlcnZlci4uLicpO1xuICAgIGNvbnN0IHZhbGlkYXRvck5hbWUgPSAnYWlkLXZhbGlkYXRvcic7XG4gICAgY29uc3QgY2hhaW5JZEZyb21EaWQgPSAoKCkgPT4ge1xuICAgICAgICBjb25zdCBtID0gcmVxdWVzdGVyRGlkLm1hdGNoKC9eZGlkOjgwMDQ6KFxcZCspOi8pO1xuICAgICAgICBpZiAoIW0pXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBwYXJzZWQgPSBOdW1iZXIobVsxXSk7XG4gICAgICAgIHJldHVybiBOdW1iZXIuaXNGaW5pdGUocGFyc2VkKSA/IHBhcnNlZCA6IHVuZGVmaW5lZDtcbiAgICB9KSgpO1xuICAgIGFzeW5jIGZ1bmN0aW9uIHJlc29sdmVWYWxpZGF0b3JBZGRyZXNzQnlOYW1lKHBhcmFtcykge1xuICAgICAgICBjb25zdCB1cmxQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHtcbiAgICAgICAgICAgIHF1ZXJ5OiBwYXJhbXMudmFsaWRhdG9yTmFtZSxcbiAgICAgICAgICAgIHBhZ2U6ICcxJyxcbiAgICAgICAgICAgIHBhZ2VTaXplOiAnMTAnLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgL2FwaS9hZ2VudHMvc2VhcmNoPyR7dXJsUGFyYW1zLnRvU3RyaW5nKCl9YCk7XG4gICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHJlc29sdmUgdmFsaWRhdG9yIFwiJHtwYXJhbXMudmFsaWRhdG9yTmFtZX1cIiB2aWEgZGlzY292ZXJ5IChzdGF0dXMgJHtyZXNwb25zZS5zdGF0dXN9KWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRhdGEgPSAoYXdhaXQgcmVzcG9uc2UuanNvbigpLmNhdGNoKCgpID0+ICh7fSkpKTtcbiAgICAgICAgY29uc3QgYWdlbnRzID0gQXJyYXkuaXNBcnJheShkYXRhPy5hZ2VudHMpID8gZGF0YS5hZ2VudHMgOiBbXTtcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZE5hbWUgPSBwYXJhbXMudmFsaWRhdG9yTmFtZS50cmltKCkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgY29uc3QgYnlFeGFjdE5hbWUgPSBhZ2VudHMuZmluZCgoYSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbmFtZSA9IHR5cGVvZiBhPy5hZ2VudE5hbWUgPT09ICdzdHJpbmcnID8gYS5hZ2VudE5hbWUudHJpbSgpLnRvTG93ZXJDYXNlKCkgOiAnJztcbiAgICAgICAgICAgIGNvbnN0IGNoYWluSWRPayA9IHR5cGVvZiBwYXJhbXMuY2hhaW5JZCA9PT0gJ251bWJlcicgPyBOdW1iZXIoYT8uY2hhaW5JZCkgPT09IHBhcmFtcy5jaGFpbklkIDogdHJ1ZTtcbiAgICAgICAgICAgIGNvbnN0IGFjY3RPayA9IHR5cGVvZiBhPy5hZ2VudEFjY291bnQgPT09ICdzdHJpbmcnICYmIGEuYWdlbnRBY2NvdW50LnN0YXJ0c1dpdGgoJzB4Jyk7XG4gICAgICAgICAgICByZXR1cm4gY2hhaW5JZE9rICYmIGFjY3RPayAmJiBuYW1lID09PSBub3JtYWxpemVkTmFtZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGZhbGxiYWNrID0gYWdlbnRzLmZpbmQoKGEpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNoYWluSWRPayA9IHR5cGVvZiBwYXJhbXMuY2hhaW5JZCA9PT0gJ251bWJlcicgPyBOdW1iZXIoYT8uY2hhaW5JZCkgPT09IHBhcmFtcy5jaGFpbklkIDogdHJ1ZTtcbiAgICAgICAgICAgIGNvbnN0IGFjY3RPayA9IHR5cGVvZiBhPy5hZ2VudEFjY291bnQgPT09ICdzdHJpbmcnICYmIGEuYWdlbnRBY2NvdW50LnN0YXJ0c1dpdGgoJzB4Jyk7XG4gICAgICAgICAgICByZXR1cm4gY2hhaW5JZE9rICYmIGFjY3RPaztcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGFnZW50QWNjb3VudCA9IChieUV4YWN0TmFtZT8uYWdlbnRBY2NvdW50ID8/IGZhbGxiYWNrPy5hZ2VudEFjY291bnQpO1xuICAgICAgICBpZiAoIWFnZW50QWNjb3VudCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBWYWxpZGF0b3IgXCIke3BhcmFtcy52YWxpZGF0b3JOYW1lfVwiIG5vdCBmb3VuZCBpbiBkaXNjb3ZlcnkgKGNoYWluSWQ9JHtwYXJhbXMuY2hhaW5JZCA/PyAnYW55J30pYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdldEFkZHJlc3MoYWdlbnRBY2NvdW50KTtcbiAgICB9XG4gICAgYXN5bmMgZnVuY3Rpb24gcmVzb2x2ZVZhbGlkYXRvckFkZHJlc3MocGFyYW1zKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgcmVzb2x2ZVZhbGlkYXRvckFkZHJlc3NCeU5hbWUocGFyYW1zKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoX2Rpc2NvdmVyeUVycikge1xuICAgICAgICAgICAgY29uc3QgY2hhaW5JZCA9IHR5cGVvZiBwYXJhbXMuY2hhaW5JZCA9PT0gJ251bWJlcidcbiAgICAgICAgICAgICAgICA/IHBhcmFtcy5jaGFpbklkXG4gICAgICAgICAgICAgICAgOiB0eXBlb2YgY2hhaW4/LmlkID09PSAnbnVtYmVyJ1xuICAgICAgICAgICAgICAgICAgICA/IGNoYWluLmlkXG4gICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKCFjaGFpbklkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgX2Rpc2NvdmVyeUVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBhd2FpdCBmZXRjaChgL2FwaS92YWxpZGF0b3ItYWRkcmVzcz92YWxpZGF0b3JOYW1lPSR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy52YWxpZGF0b3JOYW1lKX0mY2hhaW5JZD0ke2VuY29kZVVSSUNvbXBvbmVudChTdHJpbmcoY2hhaW5JZCkpfWApO1xuICAgICAgICAgICAgaWYgKCFyZXNwLm9rKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyRGF0YSA9IGF3YWl0IHJlc3AuanNvbigpLmNhdGNoKCgpID0+ICh7fSkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG1zZyA9IGVyckRhdGE/LmVycm9yIHx8XG4gICAgICAgICAgICAgICAgICAgIGVyckRhdGE/Lm1lc3NhZ2UgfHxcbiAgICAgICAgICAgICAgICAgICAgYEZhaWxlZCB0byByZXNvbHZlIHZhbGlkYXRvciBcIiR7cGFyYW1zLnZhbGlkYXRvck5hbWV9XCIgdmlhIC9hcGkvdmFsaWRhdG9yLWFkZHJlc3MgKHN0YXR1cyAke3Jlc3Auc3RhdHVzfSlgO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZGF0YSA9IChhd2FpdCByZXNwLmpzb24oKS5jYXRjaCgoKSA9PiAoe30pKSk7XG4gICAgICAgICAgICBjb25zdCBhZGRyID0gdHlwZW9mIGRhdGE/LnZhbGlkYXRvckFkZHJlc3MgPT09ICdzdHJpbmcnID8gZGF0YS52YWxpZGF0b3JBZGRyZXNzIDogJyc7XG4gICAgICAgICAgICBpZiAoIWFkZHIgfHwgIWFkZHIuc3RhcnRzV2l0aCgnMHgnKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVmFsaWRhdG9yIFwiJHtwYXJhbXMudmFsaWRhdG9yTmFtZX1cIiBhZGRyZXNzIG5vdCByZXR1cm5lZCBieSAvYXBpL3ZhbGlkYXRvci1hZGRyZXNzYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZ2V0QWRkcmVzcyhhZGRyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgcHJlcGFyZWQ7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVxdWVzdEJvZHkgPSB7XG4gICAgICAgICAgICByZXF1ZXN0VXJpLFxuICAgICAgICAgICAgcmVxdWVzdEhhc2gsXG4gICAgICAgICAgICBtb2RlLFxuICAgICAgICB9O1xuICAgICAgICByZXF1ZXN0Qm9keS52YWxpZGF0b3JBZGRyZXNzID1cbiAgICAgICAgICAgIChvcHRpb25zLnZhbGlkYXRvckFkZHJlc3NcbiAgICAgICAgICAgICAgICA/IGdldEFkZHJlc3Mob3B0aW9ucy52YWxpZGF0b3JBZGRyZXNzKVxuICAgICAgICAgICAgICAgIDogYXdhaXQgcmVzb2x2ZVZhbGlkYXRvckFkZHJlc3Moe1xuICAgICAgICAgICAgICAgICAgICB2YWxpZGF0b3JOYW1lLFxuICAgICAgICAgICAgICAgICAgICBjaGFpbklkOiBjaGFpbklkRnJvbURpZCxcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYC9hcGkvYWdlbnRzLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHJlcXVlc3RlckRpZCl9L3ZhbGlkYXRpb24tcmVxdWVzdGAsIHtcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH0sXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShyZXF1ZXN0Qm9keSksXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gKHt9KSk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JEYXRhLmVycm9yIHx8IGVycm9yRGF0YS5tZXNzYWdlIHx8ICdGYWlsZWQgdG8gcHJlcGFyZSB2YWxpZGF0aW9uIHJlcXVlc3QnKTtcbiAgICAgICAgfVxuICAgICAgICBwcmVwYXJlZCA9IChhd2FpdCByZXNwb25zZS5qc29uKCkpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yIGluc3RhbmNlb2YgRXJyb3JcbiAgICAgICAgICAgID8gZXJyb3IubWVzc2FnZVxuICAgICAgICAgICAgOiAnRmFpbGVkIHRvIHByZXBhcmUgdmFsaWRhdGlvbiByZXF1ZXN0Jyk7XG4gICAgfVxuICAgIGNvbnN0IGJ1bmRsZXJVcmwgPSBwcmVwYXJlZC5idW5kbGVyVXJsO1xuICAgIGNvbnN0IHJhd0NhbGxzID0gQXJyYXkuaXNBcnJheShwcmVwYXJlZC5jYWxscykgPyBwcmVwYXJlZC5jYWxscyA6IFtdO1xuICAgIGlmIChtb2RlID09PSAnZW9hJykge1xuICAgICAgICBpZiAoIXByZXBhcmVkLnRyYW5zYWN0aW9uKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1ZhbGlkYXRpb24gcmVxdWVzdCByZXNwb25zZSBtaXNzaW5nIHRyYW5zYWN0aW9uIHBheWxvYWQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWFjY291bnQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRU9BIG1vZGUgcmVxdWlyZXMgYWNjb3VudCAoRU9BIHNlbmRlciBhZGRyZXNzKScpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHR4UmVzdWx0ID0gYXdhaXQgc2lnbkFuZFNlbmRUcmFuc2FjdGlvbih7XG4gICAgICAgICAgICB0cmFuc2FjdGlvbjogcHJlcGFyZWQudHJhbnNhY3Rpb24sXG4gICAgICAgICAgICBhY2NvdW50LFxuICAgICAgICAgICAgY2hhaW4sXG4gICAgICAgICAgICBldGhlcmV1bVByb3ZpZGVyLFxuICAgICAgICAgICAgb25TdGF0dXNVcGRhdGUsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB2YWxpZGF0b3JBZGRyZXNzID0gcHJlcGFyZWQubWV0YWRhdGE/LnZhbGlkYXRvckFkZHJlc3MgfHxcbiAgICAgICAgICAgIChvcHRpb25zLnZhbGlkYXRvckFkZHJlc3MgPyBnZXRBZGRyZXNzKG9wdGlvbnMudmFsaWRhdG9yQWRkcmVzcykgOiAnJykgfHxcbiAgICAgICAgICAgICcnO1xuICAgICAgICBjb25zdCBmaW5hbFJlcXVlc3RIYXNoID0gcHJlcGFyZWQubWV0YWRhdGE/LnJlcXVlc3RIYXNoIHx8ICcnO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHhIYXNoOiB0eFJlc3VsdC5oYXNoLFxuICAgICAgICAgICAgcmVxdWlyZXNDbGllbnRTaWduaW5nOiB0cnVlLFxuICAgICAgICAgICAgdmFsaWRhdG9yQWRkcmVzcyxcbiAgICAgICAgICAgIHJlcXVlc3RIYXNoOiBmaW5hbFJlcXVlc3RIYXNoLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAoIWJ1bmRsZXJVcmwgfHwgcmF3Q2FsbHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVmFsaWRhdGlvbiByZXF1ZXN0IHJlc3BvbnNlIG1pc3NpbmcgYnVuZGxlclVybCBvciBjYWxscycpO1xuICAgIH1cbiAgICBjb25zdCB2YWxpZGF0aW9uQ2FsbHMgPSByYXdDYWxscy5tYXAoKGNhbGwpID0+ICh7XG4gICAgICAgIHRvOiBjYWxsLnRvLFxuICAgICAgICBkYXRhOiBjYWxsLmRhdGEsXG4gICAgICAgIHZhbHVlOiBCaWdJbnQoY2FsbC52YWx1ZSA/PyAnMCcpLFxuICAgIH0pKTtcbiAgICBvblN0YXR1c1VwZGF0ZT8uKCdTZW5kaW5nIHZhbGlkYXRpb24gcmVxdWVzdCB2aWEgYnVuZGxlci4uLicpO1xuICAgIGNvbnN0IHVzZXJPcEhhc2ggPSBhd2FpdCBzZW5kU3BvbnNvcmVkVXNlck9wZXJhdGlvbih7XG4gICAgICAgIGJ1bmRsZXJVcmwsXG4gICAgICAgIGNoYWluOiBjaGFpbixcbiAgICAgICAgYWNjb3VudENsaWVudDogcmVxdWVzdGVyQWNjb3VudENsaWVudCxcbiAgICAgICAgY2FsbHM6IHZhbGlkYXRpb25DYWxscyxcbiAgICB9KTtcbiAgICBvblN0YXR1c1VwZGF0ZT8uKGBWYWxpZGF0aW9uIHJlcXVlc3Qgc2VudCEgVXNlck9wZXJhdGlvbiBoYXNoOiAke3VzZXJPcEhhc2h9LiBXYWl0aW5nIGZvciBjb25maXJtYXRpb24uLi5gKTtcbiAgICBjb25zdCByZWNlaXB0ID0gYXdhaXQgd2FpdEZvclVzZXJPcGVyYXRpb25SZWNlaXB0KHtcbiAgICAgICAgYnVuZGxlclVybCxcbiAgICAgICAgY2hhaW46IGNoYWluLFxuICAgICAgICBoYXNoOiB1c2VyT3BIYXNoLFxuICAgIH0pO1xuICAgIGNvbnN0IHZhbGlkYXRvckFkZHJlc3MgPSBwcmVwYXJlZC5tZXRhZGF0YT8udmFsaWRhdG9yQWRkcmVzcyB8fFxuICAgICAgICAob3B0aW9ucy52YWxpZGF0b3JBZGRyZXNzID8gZ2V0QWRkcmVzcyhvcHRpb25zLnZhbGlkYXRvckFkZHJlc3MpIDogJycpIHx8XG4gICAgICAgICcnO1xuICAgIGNvbnN0IGZpbmFsUmVxdWVzdEhhc2ggPSBwcmVwYXJlZC5tZXRhZGF0YT8ucmVxdWVzdEhhc2ggfHwgJyc7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHhIYXNoOiB1c2VyT3BIYXNoLFxuICAgICAgICByZXF1aXJlc0NsaWVudFNpZ25pbmc6IHRydWUsXG4gICAgICAgIHZhbGlkYXRvckFkZHJlc3MsXG4gICAgICAgIHJlcXVlc3RIYXNoOiBmaW5hbFJlcXVlc3RIYXNoLFxuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD13YWxsZXRTaWduaW5nLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@agentic-trust/core/dist/client/walletSigning.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@agentic-trust/core/dist/index.js":
/*!************************************************************!*\
  !*** ../../node_modules/@agentic-trust/core/dist/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AIAgentENSClient: () => (/* reexport safe */ _agentic_trust_8004_ext_sdk__WEBPACK_IMPORTED_MODULE_0__.AIAgentENSClient),\n/* harmony export */   AIAgentIdentityClient: () => (/* reexport safe */ _agentic_trust_8004_ext_sdk__WEBPACK_IMPORTED_MODULE_0__.AIAgentIdentityClient),\n/* harmony export */   AIAgentL2ENSDurenClient: () => (/* reexport safe */ _agentic_trust_8004_ext_sdk__WEBPACK_IMPORTED_MODULE_0__.AIAgentL2ENSDurenClient),\n/* harmony export */   AIAgentL2ENSNamespaceClient: () => (/* reexport safe */ _agentic_trust_8004_ext_sdk__WEBPACK_IMPORTED_MODULE_0__.AIAgentL2ENSNamespaceClient),\n/* harmony export */   AIAgentReputationClient: () => (/* reexport safe */ _agentic_trust_8004_ext_sdk__WEBPACK_IMPORTED_MODULE_0__.AIAgentReputationClient),\n/* harmony export */   DEFAULT_CHAIN_ID: () => (/* reexport safe */ _server_lib_chainConfig__WEBPACK_IMPORTED_MODULE_5__.DEFAULT_CHAIN_ID),\n/* harmony export */   OrgIdentityClient: () => (/* reexport safe */ _agentic_trust_8004_ext_sdk__WEBPACK_IMPORTED_MODULE_0__.OrgIdentityClient),\n/* harmony export */   ViemAccountProvider: () => (/* reexport safe */ _agentic_trust_8004_sdk__WEBPACK_IMPORTED_MODULE_1__.ViemAccountProvider),\n/* harmony export */   ViemAdapter: () => (/* reexport safe */ _agentic_trust_8004_sdk__WEBPACK_IMPORTED_MODULE_1__.ViemAdapter),\n/* harmony export */   buildDid8004: () => (/* reexport safe */ _shared_did8004__WEBPACK_IMPORTED_MODULE_2__.buildDid8004),\n/* harmony export */   buildDidEns: () => (/* reexport safe */ _shared_didEns__WEBPACK_IMPORTED_MODULE_3__.buildDidEns),\n/* harmony export */   buildDidEnsFromAgentAndOrg: () => (/* reexport safe */ _shared_didEns__WEBPACK_IMPORTED_MODULE_3__.buildDidEnsFromAgentAndOrg),\n/* harmony export */   buildDidEthr: () => (/* reexport safe */ _shared_didEthr__WEBPACK_IMPORTED_MODULE_4__.buildDidEthr),\n/* harmony export */   createAgent: () => (/* reexport safe */ _api_agents_client__WEBPACK_IMPORTED_MODULE_9__.createAgent),\n/* harmony export */   createAgentDirect: () => (/* reexport safe */ _api_agents_directClient__WEBPACK_IMPORTED_MODULE_10__.createAgentDirect),\n/* harmony export */   createAgentWithWallet: () => (/* reexport safe */ _client_walletSigning__WEBPACK_IMPORTED_MODULE_8__.createAgentWithWallet),\n/* harmony export */   createValidatorAccountAbstraction: () => (/* reexport safe */ _server_lib_validations__WEBPACK_IMPORTED_MODULE_11__.createValidatorAccountAbstraction),\n/* harmony export */   deploySmartAccountIfNeeded: () => (/* reexport safe */ _client_accountClient__WEBPACK_IMPORTED_MODULE_6__.deploySmartAccountIfNeeded),\n/* harmony export */   extractAgentIdFromReceipt: () => (/* reexport safe */ _client_walletSigning__WEBPACK_IMPORTED_MODULE_8__.extractAgentIdFromReceipt),\n/* harmony export */   generateSessionPackage: () => (/* reexport safe */ _client_sessionPackageBuilder__WEBPACK_IMPORTED_MODULE_7__.generateSessionPackage),\n/* harmony export */   getChainBundlerUrl: () => (/* reexport safe */ _server_lib_chainConfig__WEBPACK_IMPORTED_MODULE_5__.getChainBundlerUrl),\n/* harmony export */   getChainDisplayMetadata: () => (/* reexport safe */ _server_lib_chainConfig__WEBPACK_IMPORTED_MODULE_5__.getChainDisplayMetadata),\n/* harmony export */   getChainIdHex: () => (/* reexport safe */ _server_lib_chainConfig__WEBPACK_IMPORTED_MODULE_5__.getChainIdHex),\n/* harmony export */   getChainRpcUrl: () => (/* reexport safe */ _server_lib_chainConfig__WEBPACK_IMPORTED_MODULE_5__.getChainRpcUrl),\n/* harmony export */   getCounterfactualAAAddressByAgentName: () => (/* reexport safe */ _client_walletSigning__WEBPACK_IMPORTED_MODULE_8__.getCounterfactualAAAddressByAgentName),\n/* harmony export */   getCounterfactualAccountClientByAgentName: () => (/* reexport safe */ _client_walletSigning__WEBPACK_IMPORTED_MODULE_8__.getCounterfactualAccountClientByAgentName),\n/* harmony export */   getCounterfactualSmartAccountAddressByAgentName: () => (/* reexport safe */ _client_walletSigning__WEBPACK_IMPORTED_MODULE_8__.getCounterfactualSmartAccountAddressByAgentName),\n/* harmony export */   getDeployedAccountClientByAddress: () => (/* reexport safe */ _client_walletSigning__WEBPACK_IMPORTED_MODULE_8__.getDeployedAccountClientByAddress),\n/* harmony export */   getDeployedAccountClientByAgentName: () => (/* reexport safe */ _client_walletSigning__WEBPACK_IMPORTED_MODULE_8__.getDeployedAccountClientByAgentName),\n/* harmony export */   getEnsOrgName: () => (/* reexport safe */ _server_lib_chainConfig__WEBPACK_IMPORTED_MODULE_5__.getEnsOrgName),\n/* harmony export */   getSupportedChainIds: () => (/* reexport safe */ _server_lib_chainConfig__WEBPACK_IMPORTED_MODULE_5__.getSupportedChainIds),\n/* harmony export */   getWalletAddress: () => (/* reexport safe */ _client_walletSigning__WEBPACK_IMPORTED_MODULE_8__.getWalletAddress),\n/* harmony export */   getWeb3AuthChainSettings: () => (/* reexport safe */ _server_lib_chainConfig__WEBPACK_IMPORTED_MODULE_5__.getWeb3AuthChainSettings),\n/* harmony export */   getWeb3AuthClientId: () => (/* reexport safe */ _server_lib_chainConfig__WEBPACK_IMPORTED_MODULE_5__.getWeb3AuthClientId),\n/* harmony export */   getWeb3AuthNetwork: () => (/* reexport safe */ _server_lib_chainConfig__WEBPACK_IMPORTED_MODULE_5__.getWeb3AuthNetwork),\n/* harmony export */   giveFeedbackWithWallet: () => (/* reexport safe */ _client_walletSigning__WEBPACK_IMPORTED_MODULE_8__.giveFeedbackWithWallet),\n/* harmony export */   isPrivateKeyMode: () => (/* reexport safe */ _server_lib_chainConfig__WEBPACK_IMPORTED_MODULE_5__.isPrivateKeyMode),\n/* harmony export */   isSmartContract: () => (/* reexport safe */ _client_accountClient__WEBPACK_IMPORTED_MODULE_6__.isSmartContract),\n/* harmony export */   isWalletProviderAvailable: () => (/* reexport safe */ _client_walletSigning__WEBPACK_IMPORTED_MODULE_8__.isWalletProviderAvailable),\n/* harmony export */   parseDid8004: () => (/* reexport safe */ _shared_did8004__WEBPACK_IMPORTED_MODULE_2__.parseDid8004),\n/* harmony export */   parseDidEns: () => (/* reexport safe */ _shared_didEns__WEBPACK_IMPORTED_MODULE_3__.parseDidEns),\n/* harmony export */   parseDidEthr: () => (/* reexport safe */ _shared_didEthr__WEBPACK_IMPORTED_MODULE_4__.parseDidEthr),\n/* harmony export */   refreshAgentInIndexer: () => (/* reexport safe */ _client_walletSigning__WEBPACK_IMPORTED_MODULE_8__.refreshAgentInIndexer),\n/* harmony export */   requestAIDValidationWithWallet: () => (/* reexport safe */ _client_walletSigning__WEBPACK_IMPORTED_MODULE_8__.requestAIDValidationWithWallet),\n/* harmony export */   requestAccountValidationWithWallet: () => (/* reexport safe */ _client_walletSigning__WEBPACK_IMPORTED_MODULE_8__.requestAccountValidationWithWallet),\n/* harmony export */   requestAppValidationWithWallet: () => (/* reexport safe */ _client_walletSigning__WEBPACK_IMPORTED_MODULE_8__.requestAppValidationWithWallet),\n/* harmony export */   requestNameValidationWithWallet: () => (/* reexport safe */ _client_walletSigning__WEBPACK_IMPORTED_MODULE_8__.requestNameValidationWithWallet),\n/* harmony export */   resolveDid8004: () => (/* reexport safe */ _shared_did8004__WEBPACK_IMPORTED_MODULE_2__.resolveDid8004),\n/* harmony export */   sendSponsoredUserOperation: () => (/* reexport safe */ _client_accountClient__WEBPACK_IMPORTED_MODULE_6__.sendSponsoredUserOperation),\n/* harmony export */   signAndSendTransaction: () => (/* reexport safe */ _client_walletSigning__WEBPACK_IMPORTED_MODULE_8__.signAndSendTransaction),\n/* harmony export */   updateAgentRegistration: () => (/* reexport safe */ _api_agents_client__WEBPACK_IMPORTED_MODULE_9__.updateAgentRegistration),\n/* harmony export */   updateAgentRegistrationWithWallet: () => (/* reexport safe */ _client_walletSigning__WEBPACK_IMPORTED_MODULE_8__.updateAgentRegistrationWithWallet),\n/* harmony export */   waitForUserOperationReceipt: () => (/* reexport safe */ _client_accountClient__WEBPACK_IMPORTED_MODULE_6__.waitForUserOperationReceipt)\n/* harmony export */ });\n/* harmony import */ var _agentic_trust_8004_ext_sdk__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @agentic-trust/8004-ext-sdk */ \"(rsc)/../../node_modules/@agentic-trust/8004-ext-sdk/dist/index.js\");\n/* harmony import */ var _agentic_trust_8004_sdk__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @agentic-trust/8004-sdk */ \"(rsc)/../../node_modules/@agentic-trust/8004-sdk/dist/index.js\");\n/* harmony import */ var _shared_did8004__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./shared/did8004 */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/shared/did8004.js\");\n/* harmony import */ var _shared_didEns__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./shared/didEns */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/shared/didEns.js\");\n/* harmony import */ var _shared_didEthr__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./shared/didEthr */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/shared/didEthr.js\");\n/* harmony import */ var _server_lib_chainConfig__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./server/lib/chainConfig */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/lib/chainConfig.js\");\n/* harmony import */ var _client_accountClient__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./client/accountClient */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/client/accountClient.js\");\n/* harmony import */ var _client_sessionPackageBuilder__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./client/sessionPackageBuilder */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/client/sessionPackageBuilder.js\");\n/* harmony import */ var _client_walletSigning__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./client/walletSigning */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/client/walletSigning.js\");\n/* harmony import */ var _api_agents_client__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./api/agents/client */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/api/agents/client.js\");\n/* harmony import */ var _api_agents_directClient__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./api/agents/directClient */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/api/agents/directClient.js\");\n/* harmony import */ var _server_lib_validations__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./server/lib/validations */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/lib/validations.js\");\n/**\n * @agentic-trust/core\n *\n * Core SDK for agentic trust systems\n */\n// ERC-8004 Agentic Trust SDK exports\n// Re-export all ERC-8004 functionality for convenience\n\n// Export AccountProvider types from erc8004-sdk for convenience\n\n\n\n\n// Chain / Web3Auth config helpers (safe for both client and server)\n\n// Legacy export for backward compatibility (deprecated - use ViemAccountProvider instead)\n\n// Session package utilities are server-only and should be imported from '@agentic-trust/core/server'\n// They are NOT exported here to prevent browser bundling issues (uses Node.js 'fs' module)\n// Export bundler utilities\n\n\n// Note: Server-only functionality is exported from '@agentic-trust/core/server'\n// Export client-side wallet signing utilities\n\n// Client-side agent API helpers (HTTP-based)\n\n\n// Validation request utilities (server-side)\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BhZ2VudGljLXRydXN0L2NvcmUvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ3lMO0FBQ3pMO0FBQytEO0FBR087QUFDa0I7QUFDekI7QUFDL0Q7QUFDbVE7QUFDblE7QUFDc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQytJO0FBQ3ZFO0FBQ3hFO0FBQ0E7QUFDa2tCO0FBQ2xrQjtBQUM0RTtBQUNiO0FBQy9EO0FBQzhFO0FBQzlFIiwic291cmNlcyI6WyIvaG9tZS9iYXJiL2FhL0Fzc29jaWF0ZWRBY2NvdW50cy9ub2RlX21vZHVsZXMvQGFnZW50aWMtdHJ1c3QvY29yZS9kaXN0L2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGFnZW50aWMtdHJ1c3QvY29yZVxuICpcbiAqIENvcmUgU0RLIGZvciBhZ2VudGljIHRydXN0IHN5c3RlbXNcbiAqL1xuLy8gRVJDLTgwMDQgQWdlbnRpYyBUcnVzdCBTREsgZXhwb3J0c1xuLy8gUmUtZXhwb3J0IGFsbCBFUkMtODAwNCBmdW5jdGlvbmFsaXR5IGZvciBjb252ZW5pZW5jZVxuZXhwb3J0IHsgQUlBZ2VudEVOU0NsaWVudCwgQUlBZ2VudEwyRU5TRHVyZW5DbGllbnQsIEFJQWdlbnRMMkVOU05hbWVzcGFjZUNsaWVudCwgQUlBZ2VudElkZW50aXR5Q2xpZW50LCBBSUFnZW50UmVwdXRhdGlvbkNsaWVudCwgT3JnSWRlbnRpdHlDbGllbnQsIH0gZnJvbSAnQGFnZW50aWMtdHJ1c3QvODAwNC1leHQtc2RrJztcbi8vIEV4cG9ydCBBY2NvdW50UHJvdmlkZXIgdHlwZXMgZnJvbSBlcmM4MDA0LXNkayBmb3IgY29udmVuaWVuY2VcbmV4cG9ydCB7IFZpZW1BY2NvdW50UHJvdmlkZXIsIH0gZnJvbSAnQGFnZW50aWMtdHJ1c3QvODAwNC1zZGsnO1xuZXhwb3J0IHsgXG4vLyBQcmVmZXJyZWQgRGlkLXRoZW4tbWV0aG9kIG5hbWVzIG9ubHlcbmJ1aWxkRGlkODAwNCwgcGFyc2VEaWQ4MDA0LCByZXNvbHZlRGlkODAwNCwgfSBmcm9tICcuL3NoYXJlZC9kaWQ4MDA0JztcbmV4cG9ydCB7IGJ1aWxkRGlkRW5zLCBidWlsZERpZEVuc0Zyb21BZ2VudEFuZE9yZywgcGFyc2VEaWRFbnMsIH0gZnJvbSAnLi9zaGFyZWQvZGlkRW5zJztcbmV4cG9ydCB7IGJ1aWxkRGlkRXRociwgcGFyc2VEaWRFdGhyLCB9IGZyb20gJy4vc2hhcmVkL2RpZEV0aHInO1xuLy8gQ2hhaW4gLyBXZWIzQXV0aCBjb25maWcgaGVscGVycyAoc2FmZSBmb3IgYm90aCBjbGllbnQgYW5kIHNlcnZlcilcbmV4cG9ydCB7IERFRkFVTFRfQ0hBSU5fSUQsIGdldENoYWluUnBjVXJsLCBnZXRDaGFpbkJ1bmRsZXJVcmwsIGlzUHJpdmF0ZUtleU1vZGUsIGdldEVuc09yZ05hbWUsIGdldFdlYjNBdXRoQ2xpZW50SWQsIGdldFdlYjNBdXRoTmV0d29yaywgZ2V0Q2hhaW5EaXNwbGF5TWV0YWRhdGEsIGdldFN1cHBvcnRlZENoYWluSWRzLCBnZXRXZWIzQXV0aENoYWluU2V0dGluZ3MsIGdldENoYWluSWRIZXgsIH0gZnJvbSAnLi9zZXJ2ZXIvbGliL2NoYWluQ29uZmlnJztcbi8vIExlZ2FjeSBleHBvcnQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkgKGRlcHJlY2F0ZWQgLSB1c2UgVmllbUFjY291bnRQcm92aWRlciBpbnN0ZWFkKVxuZXhwb3J0IHsgVmllbUFkYXB0ZXIgfSBmcm9tICdAYWdlbnRpYy10cnVzdC84MDA0LXNkayc7XG4vLyBTZXNzaW9uIHBhY2thZ2UgdXRpbGl0aWVzIGFyZSBzZXJ2ZXItb25seSBhbmQgc2hvdWxkIGJlIGltcG9ydGVkIGZyb20gJ0BhZ2VudGljLXRydXN0L2NvcmUvc2VydmVyJ1xuLy8gVGhleSBhcmUgTk9UIGV4cG9ydGVkIGhlcmUgdG8gcHJldmVudCBicm93c2VyIGJ1bmRsaW5nIGlzc3VlcyAodXNlcyBOb2RlLmpzICdmcycgbW9kdWxlKVxuLy8gRXhwb3J0IGJ1bmRsZXIgdXRpbGl0aWVzXG5leHBvcnQgeyBzZW5kU3BvbnNvcmVkVXNlck9wZXJhdGlvbiwgd2FpdEZvclVzZXJPcGVyYXRpb25SZWNlaXB0LCBkZXBsb3lTbWFydEFjY291bnRJZk5lZWRlZCwgaXNTbWFydENvbnRyYWN0LCB9IGZyb20gJy4vY2xpZW50L2FjY291bnRDbGllbnQnO1xuZXhwb3J0IHsgZ2VuZXJhdGVTZXNzaW9uUGFja2FnZSB9IGZyb20gJy4vY2xpZW50L3Nlc3Npb25QYWNrYWdlQnVpbGRlcic7XG4vLyBOb3RlOiBTZXJ2ZXItb25seSBmdW5jdGlvbmFsaXR5IGlzIGV4cG9ydGVkIGZyb20gJ0BhZ2VudGljLXRydXN0L2NvcmUvc2VydmVyJ1xuLy8gRXhwb3J0IGNsaWVudC1zaWRlIHdhbGxldCBzaWduaW5nIHV0aWxpdGllc1xuZXhwb3J0IHsgc2lnbkFuZFNlbmRUcmFuc2FjdGlvbiwgZXh0cmFjdEFnZW50SWRGcm9tUmVjZWlwdCwgcmVmcmVzaEFnZW50SW5JbmRleGVyLCBpc1dhbGxldFByb3ZpZGVyQXZhaWxhYmxlLCBnZXRXYWxsZXRBZGRyZXNzLCBnZXREZXBsb3llZEFjY291bnRDbGllbnRCeUFnZW50TmFtZSwgZ2V0RGVwbG95ZWRBY2NvdW50Q2xpZW50QnlBZGRyZXNzLCBnZXRDb3VudGVyZmFjdHVhbEFjY291bnRDbGllbnRCeUFnZW50TmFtZSwgZ2V0Q291bnRlcmZhY3R1YWxTbWFydEFjY291bnRBZGRyZXNzQnlBZ2VudE5hbWUsIGdldENvdW50ZXJmYWN0dWFsQUFBZGRyZXNzQnlBZ2VudE5hbWUsIGNyZWF0ZUFnZW50V2l0aFdhbGxldCwgdXBkYXRlQWdlbnRSZWdpc3RyYXRpb25XaXRoV2FsbGV0LCBnaXZlRmVlZGJhY2tXaXRoV2FsbGV0LCByZXF1ZXN0TmFtZVZhbGlkYXRpb25XaXRoV2FsbGV0LCByZXF1ZXN0QWNjb3VudFZhbGlkYXRpb25XaXRoV2FsbGV0LCByZXF1ZXN0QXBwVmFsaWRhdGlvbldpdGhXYWxsZXQsIHJlcXVlc3RBSURWYWxpZGF0aW9uV2l0aFdhbGxldCwgfSBmcm9tICcuL2NsaWVudC93YWxsZXRTaWduaW5nJztcbi8vIENsaWVudC1zaWRlIGFnZW50IEFQSSBoZWxwZXJzIChIVFRQLWJhc2VkKVxuZXhwb3J0IHsgY3JlYXRlQWdlbnQsIHVwZGF0ZUFnZW50UmVnaXN0cmF0aW9uLCB9IGZyb20gJy4vYXBpL2FnZW50cy9jbGllbnQnO1xuZXhwb3J0IHsgY3JlYXRlQWdlbnREaXJlY3QsIH0gZnJvbSAnLi9hcGkvYWdlbnRzL2RpcmVjdENsaWVudCc7XG4vLyBWYWxpZGF0aW9uIHJlcXVlc3QgdXRpbGl0aWVzIChzZXJ2ZXItc2lkZSlcbmV4cG9ydCB7IGNyZWF0ZVZhbGlkYXRvckFjY291bnRBYnN0cmFjdGlvbiwgfSBmcm9tICcuL3NlcnZlci9saWIvdmFsaWRhdGlvbnMnO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@agentic-trust/core/dist/index.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@agentic-trust/core/dist/server/index.js":
/*!*******************************************************************!*\
  !*** ../../node_modules/@agentic-trust/core/dist/server/index.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Agent: () => (/* reexport safe */ _lib_agent__WEBPACK_IMPORTED_MODULE_10__.Agent),\n/* harmony export */   AgenticTrustClient: () => (/* reexport safe */ _singletons_agenticTrustClient__WEBPACK_IMPORTED_MODULE_7__.AgenticTrustClient),\n/* harmony export */   AgentsAPI: () => (/* reexport safe */ _lib_agents__WEBPACK_IMPORTED_MODULE_11__.AgentsAPI),\n/* harmony export */   DEFAULT_CHAIN_ID: () => (/* reexport safe */ _lib_chainConfig__WEBPACK_IMPORTED_MODULE_28__.DEFAULT_CHAIN_ID),\n/* harmony export */   addToL1OrgPK: () => (/* reexport safe */ _lib_names__WEBPACK_IMPORTED_MODULE_30__.addToL1OrgPK),\n/* harmony export */   baseSepolia: () => (/* reexport safe */ _lib_chainConfig__WEBPACK_IMPORTED_MODULE_28__.baseSepolia),\n/* harmony export */   buildAgentAccountFromSession: () => (/* reexport safe */ _lib_sessionPackage__WEBPACK_IMPORTED_MODULE_31__.buildAgentAccountFromSession),\n/* harmony export */   buildDelegatedAssociationContext: () => (/* reexport safe */ _services_delegatedAssociation__WEBPACK_IMPORTED_MODULE_24__.buildDelegatedAssociationContext),\n/* harmony export */   buildDelegatedValidationContext: () => (/* reexport safe */ _services_delegatedValidation__WEBPACK_IMPORTED_MODULE_33__.buildDelegatedValidationContext),\n/* harmony export */   buildDelegationSetup: () => (/* reexport safe */ _lib_sessionPackage__WEBPACK_IMPORTED_MODULE_31__.buildDelegationSetup),\n/* harmony export */   buildSessionPackage: () => (/* reexport safe */ _lib_sessionPackage__WEBPACK_IMPORTED_MODULE_31__.buildSessionPackage),\n/* harmony export */   createAgent: () => (/* reexport safe */ _api_agents_core__WEBPACK_IMPORTED_MODULE_5__.createAgentCore),\n/* harmony export */   createAgentDirect: () => (/* reexport safe */ _api_agents_directServer__WEBPACK_IMPORTED_MODULE_6__.createAgentDirectCore),\n/* harmony export */   createAgentDirectExpressHandler: () => (/* reexport safe */ _api_agents_directExpress__WEBPACK_IMPORTED_MODULE_4__.createAgentDirectExpressHandler),\n/* harmony export */   createAgentDirectRouteHandler: () => (/* reexport safe */ _api_agents_directNext__WEBPACK_IMPORTED_MODULE_2__.createAgentDirectRouteHandler),\n/* harmony export */   createAgentExpressHandler: () => (/* reexport safe */ _api_agents_express__WEBPACK_IMPORTED_MODULE_3__.createAgentExpressHandler),\n/* harmony export */   createAgentRouteHandler: () => (/* reexport safe */ _api_agents_next__WEBPACK_IMPORTED_MODULE_1__.createAgentRouteHandler),\n/* harmony export */   createDelegationAssociationWithIpfs: () => (/* reexport safe */ _lib_delegationAssociation__WEBPACK_IMPORTED_MODULE_13__.createDelegationAssociationWithIpfs),\n/* harmony export */   createFeedbackAuth: () => (/* reexport safe */ _lib_agentFeedback__WEBPACK_IMPORTED_MODULE_12__.createFeedbackAuth),\n/* harmony export */   createIPFSStorage: () => (/* reexport safe */ _lib_ipfs__WEBPACK_IMPORTED_MODULE_29__.createIPFSStorage),\n/* harmony export */   createRegistrationJSON: () => (/* reexport safe */ _lib_agentRegistration__WEBPACK_IMPORTED_MODULE_15__.createRegistrationJSON),\n/* harmony export */   createValidatorAccountAbstraction: () => (/* reexport safe */ _lib_validations__WEBPACK_IMPORTED_MODULE_34__.createValidatorAccountAbstraction),\n/* harmony export */   decodeAssociationData: () => (/* reexport safe */ _lib_association__WEBPACK_IMPORTED_MODULE_14__.decodeAssociationData),\n/* harmony export */   directFeedbackRouteHandler: () => (/* reexport safe */ _api_agents_next__WEBPACK_IMPORTED_MODULE_1__.directFeedbackRouteHandler),\n/* harmony export */   discoverAgents: () => (/* reexport safe */ _lib_discover__WEBPACK_IMPORTED_MODULE_26__.discoverAgents),\n/* harmony export */   encodeAssociationData: () => (/* reexport safe */ _lib_association__WEBPACK_IMPORTED_MODULE_14__.encodeAssociationData),\n/* harmony export */   extractAgentAccountFromDiscovery: () => (/* reexport safe */ _lib_accounts__WEBPACK_IMPORTED_MODULE_16__.extractAgentAccountFromDiscovery),\n/* harmony export */   fetchA2AAgentCard: () => (/* reexport safe */ _lib_a2aAgentCard__WEBPACK_IMPORTED_MODULE_9__.fetchA2AAgentCard),\n/* harmony export */   generateHcs14UaidDidTarget: () => (/* reexport safe */ _lib_uaid__WEBPACK_IMPORTED_MODULE_22__.generateHcs14UaidDidTarget),\n/* harmony export */   getAccountOwner: () => (/* reexport safe */ _lib_accounts__WEBPACK_IMPORTED_MODULE_16__.getAccountOwner),\n/* harmony export */   getAccountOwnerByDidEthr: () => (/* reexport safe */ _lib_accounts__WEBPACK_IMPORTED_MODULE_16__.getAccountOwnerByDidEthr),\n/* harmony export */   getAdminAddress: () => (/* reexport safe */ _userApps_adminApp__WEBPACK_IMPORTED_MODULE_17__.getAdminAddress),\n/* harmony export */   getAdminApp: () => (/* reexport safe */ _userApps_adminApp__WEBPACK_IMPORTED_MODULE_17__.getAdminApp),\n/* harmony export */   getAgentAccountByAgentName: () => (/* reexport safe */ _lib_accounts__WEBPACK_IMPORTED_MODULE_16__.getAgentAccountByAgentName),\n/* harmony export */   getAgentValidationsSummary: () => (/* reexport safe */ _lib_validations__WEBPACK_IMPORTED_MODULE_34__.getAgentValidationsSummary),\n/* harmony export */   getAgenticTrustClient: () => (/* reexport safe */ _lib_agenticTrust__WEBPACK_IMPORTED_MODULE_8__.getAgenticTrustClient),\n/* harmony export */   getAssociationsClient: () => (/* reexport safe */ _singletons_associationClient__WEBPACK_IMPORTED_MODULE_23__.getAssociationsClient),\n/* harmony export */   getChainBundlerUrl: () => (/* reexport safe */ _lib_chainConfig__WEBPACK_IMPORTED_MODULE_28__.getChainBundlerUrl),\n/* harmony export */   getChainById: () => (/* reexport safe */ _lib_chainConfig__WEBPACK_IMPORTED_MODULE_28__.getChainById),\n/* harmony export */   getChainConfig: () => (/* reexport safe */ _lib_chainConfig__WEBPACK_IMPORTED_MODULE_28__.getChainConfig),\n/* harmony export */   getChainDisplayMetadata: () => (/* reexport safe */ _lib_chainConfig__WEBPACK_IMPORTED_MODULE_28__.getChainDisplayMetadata),\n/* harmony export */   getChainEnvVar: () => (/* reexport safe */ _lib_chainConfig__WEBPACK_IMPORTED_MODULE_28__.getChainEnvVar),\n/* harmony export */   getChainEnvVarDetails: () => (/* reexport safe */ _lib_chainConfig__WEBPACK_IMPORTED_MODULE_28__.getChainEnvVarDetails),\n/* harmony export */   getChainEnvVarNames: () => (/* reexport safe */ _lib_chainConfig__WEBPACK_IMPORTED_MODULE_28__.getChainEnvVarNames),\n/* harmony export */   getChainIdHex: () => (/* reexport safe */ _lib_chainConfig__WEBPACK_IMPORTED_MODULE_28__.getChainIdHex),\n/* harmony export */   getChainRpcUrl: () => (/* reexport safe */ _lib_chainConfig__WEBPACK_IMPORTED_MODULE_28__.getChainRpcUrl),\n/* harmony export */   getClientAddress: () => (/* reexport safe */ _userApps_clientApp__WEBPACK_IMPORTED_MODULE_18__.getClientAddress),\n/* harmony export */   getClientApp: () => (/* reexport safe */ _userApps_clientApp__WEBPACK_IMPORTED_MODULE_18__.getClientApp),\n/* harmony export */   getClientAppAccount: () => (/* reexport safe */ _userApps_clientApp__WEBPACK_IMPORTED_MODULE_18__.getClientAppAccount),\n/* harmony export */   getCounterfactualAAAddressByAgentName: () => (/* reexport safe */ _lib_accounts__WEBPACK_IMPORTED_MODULE_16__.getCounterfactualAAAddressByAgentName),\n/* harmony export */   getCounterfactualSmartAccountAddressByAgentName: () => (/* reexport safe */ _lib_accounts__WEBPACK_IMPORTED_MODULE_16__.getCounterfactualSmartAccountAddressByAgentName),\n/* harmony export */   getDiscoveryClient: () => (/* reexport safe */ _singletons_discoveryClient__WEBPACK_IMPORTED_MODULE_21__.getDiscoveryClient),\n/* harmony export */   getENSClient: () => (/* reexport safe */ _singletons_ensClient__WEBPACK_IMPORTED_MODULE_25__.getENSClient),\n/* harmony export */   getEnsOrgAddress: () => (/* reexport safe */ _lib_chainConfig__WEBPACK_IMPORTED_MODULE_28__.getEnsOrgAddress),\n/* harmony export */   getEnsOrgName: () => (/* reexport safe */ _lib_chainConfig__WEBPACK_IMPORTED_MODULE_28__.getEnsOrgName),\n/* harmony export */   getEnsPrivateKey: () => (/* reexport safe */ _lib_chainConfig__WEBPACK_IMPORTED_MODULE_28__.getEnsPrivateKey),\n/* harmony export */   getFeedbackExpressHandler: () => (/* reexport safe */ _api_agents_express__WEBPACK_IMPORTED_MODULE_3__.getFeedbackExpressHandler),\n/* harmony export */   getFeedbackRouteHandler: () => (/* reexport safe */ _api_agents_next__WEBPACK_IMPORTED_MODULE_1__.getFeedbackRouteHandler),\n/* harmony export */   getIPFSStorage: () => (/* reexport safe */ _lib_ipfs__WEBPACK_IMPORTED_MODULE_29__.getIPFSStorage),\n/* harmony export */   getProviderAgentId: () => (/* reexport safe */ _userApps_providerApp__WEBPACK_IMPORTED_MODULE_19__.getProviderAgentId),\n/* harmony export */   getProviderApp: () => (/* reexport safe */ _userApps_providerApp__WEBPACK_IMPORTED_MODULE_19__.getProviderApp),\n/* harmony export */   getRegistration: () => (/* reexport safe */ _lib_agentRegistration__WEBPACK_IMPORTED_MODULE_15__.getRegistration),\n/* harmony export */   getSupportedChainIds: () => (/* reexport safe */ _lib_chainConfig__WEBPACK_IMPORTED_MODULE_28__.getSupportedChainIds),\n/* harmony export */   getValidationRegistryClient: () => (/* reexport safe */ _singletons_validationClient__WEBPACK_IMPORTED_MODULE_32__.getValidationRegistryClient),\n/* harmony export */   getValidationsRouteHandler: () => (/* reexport safe */ _api_agents_next__WEBPACK_IMPORTED_MODULE_1__.getValidationsRouteHandler),\n/* harmony export */   getValidatorAddress: () => (/* reexport safe */ _userApps_validatorApp__WEBPACK_IMPORTED_MODULE_20__.getValidatorAddress),\n/* harmony export */   getValidatorAddressValidations: () => (/* reexport safe */ _lib_validations__WEBPACK_IMPORTED_MODULE_34__.getValidatorAddressValidations),\n/* harmony export */   getValidatorApp: () => (/* reexport safe */ _userApps_validatorApp__WEBPACK_IMPORTED_MODULE_20__.getValidatorApp),\n/* harmony export */   getWeb3AuthChainSettings: () => (/* reexport safe */ _lib_chainConfig__WEBPACK_IMPORTED_MODULE_28__.getWeb3AuthChainSettings),\n/* harmony export */   getWeb3AuthClientId: () => (/* reexport safe */ _lib_chainConfig__WEBPACK_IMPORTED_MODULE_28__.getWeb3AuthClientId),\n/* harmony export */   getWeb3AuthNetwork: () => (/* reexport safe */ _lib_chainConfig__WEBPACK_IMPORTED_MODULE_28__.getWeb3AuthNetwork),\n/* harmony export */   handleResolveAccount: () => (/* reexport safe */ _lib_resolveAccount__WEBPACK_IMPORTED_MODULE_0__.handleResolveAccount),\n/* harmony export */   hasAdminPrivateKey: () => (/* reexport safe */ _userApps_adminApp__WEBPACK_IMPORTED_MODULE_17__.hasAdminPrivateKey),\n/* harmony export */   hasValidatorPrivateKey: () => (/* reexport safe */ _userApps_validatorApp__WEBPACK_IMPORTED_MODULE_20__.hasValidatorPrivateKey),\n/* harmony export */   isAdminAppInitialized: () => (/* reexport safe */ _userApps_adminApp__WEBPACK_IMPORTED_MODULE_17__.isAdminAppInitialized),\n/* harmony export */   isAssociationsClientInitialized: () => (/* reexport safe */ _singletons_associationClient__WEBPACK_IMPORTED_MODULE_23__.isAssociationsClientInitialized),\n/* harmony export */   isChainSupported: () => (/* reexport safe */ _lib_chainConfig__WEBPACK_IMPORTED_MODULE_28__.isChainSupported),\n/* harmony export */   isClientAppInitialized: () => (/* reexport safe */ _userApps_clientApp__WEBPACK_IMPORTED_MODULE_18__.isClientAppInitialized),\n/* harmony export */   isDiscoveryClientInitialized: () => (/* reexport safe */ _singletons_discoveryClient__WEBPACK_IMPORTED_MODULE_21__.isDiscoveryClientInitialized),\n/* harmony export */   isENSAvailable: () => (/* reexport safe */ _singletons_ensClient__WEBPACK_IMPORTED_MODULE_25__.isENSAvailable),\n/* harmony export */   isENSClientInitialized: () => (/* reexport safe */ _singletons_ensClient__WEBPACK_IMPORTED_MODULE_25__.isENSClientInitialized),\n/* harmony export */   isENSNameAvailable: () => (/* reexport safe */ _singletons_ensClient__WEBPACK_IMPORTED_MODULE_25__.isENSNameAvailable),\n/* harmony export */   isIPFSStorageInitialized: () => (/* reexport safe */ _lib_ipfs__WEBPACK_IMPORTED_MODULE_29__.isIPFSStorageInitialized),\n/* harmony export */   isPrivateKeyMode: () => (/* reexport safe */ _lib_chainConfig__WEBPACK_IMPORTED_MODULE_28__.isPrivateKeyMode),\n/* harmony export */   isProviderAppInitialized: () => (/* reexport safe */ _userApps_providerApp__WEBPACK_IMPORTED_MODULE_19__.isProviderAppInitialized),\n/* harmony export */   isValidationClientInitialized: () => (/* reexport safe */ _singletons_validationClient__WEBPACK_IMPORTED_MODULE_32__.isValidationClientInitialized),\n/* harmony export */   isValidatorAppInitialized: () => (/* reexport safe */ _userApps_validatorApp__WEBPACK_IMPORTED_MODULE_20__.isValidatorAppInitialized),\n/* harmony export */   loadSessionPackage: () => (/* reexport safe */ _lib_sessionPackage__WEBPACK_IMPORTED_MODULE_31__.loadSessionPackage),\n/* harmony export */   mountAgentApiRoutes: () => (/* reexport safe */ _api_agents_express__WEBPACK_IMPORTED_MODULE_3__.mountAgentRoutes),\n/* harmony export */   optimismSepolia: () => (/* reexport safe */ _lib_chainConfig__WEBPACK_IMPORTED_MODULE_28__.optimismSepolia),\n/* harmony export */   parseEthrDid: () => (/* reexport safe */ _lib_accounts__WEBPACK_IMPORTED_MODULE_16__.parseEthrDid),\n/* harmony export */   prepareAssociationRequest: () => (/* reexport safe */ _api_agents_core__WEBPACK_IMPORTED_MODULE_5__.prepareAssociationRequestCore),\n/* harmony export */   prepareAssociationRequestRouteHandler: () => (/* reexport safe */ _api_agents_next__WEBPACK_IMPORTED_MODULE_1__.prepareAssociationRequestRouteHandler),\n/* harmony export */   prepareFeedback: () => (/* reexport safe */ _api_agents_core__WEBPACK_IMPORTED_MODULE_5__.prepareFeedbackCore),\n/* harmony export */   prepareFeedbackExpressHandler: () => (/* reexport safe */ _api_agents_express__WEBPACK_IMPORTED_MODULE_3__.prepareFeedbackExpressHandler),\n/* harmony export */   prepareFeedbackRouteHandler: () => (/* reexport safe */ _api_agents_next__WEBPACK_IMPORTED_MODULE_1__.prepareFeedbackRouteHandler),\n/* harmony export */   prepareValidationRequest: () => (/* reexport safe */ _api_agents_core__WEBPACK_IMPORTED_MODULE_5__.prepareValidationRequestCore),\n/* harmony export */   prepareValidationRequestRouteHandler: () => (/* reexport safe */ _api_agents_next__WEBPACK_IMPORTED_MODULE_1__.prepareValidationRequestRouteHandler),\n/* harmony export */   processValidationRequestsWithSessionPackage: () => (/* reexport safe */ _services_delegatedValidation__WEBPACK_IMPORTED_MODULE_33__.processValidationRequestsWithSessionPackage),\n/* harmony export */   requestFeedbackAuth: () => (/* reexport safe */ _api_agents_core__WEBPACK_IMPORTED_MODULE_5__.requestFeedbackAuthCore),\n/* harmony export */   requestFeedbackAuthExpressHandler: () => (/* reexport safe */ _api_agents_express__WEBPACK_IMPORTED_MODULE_3__.requestFeedbackAuthExpressHandler),\n/* harmony export */   requestFeedbackAuthRouteHandler: () => (/* reexport safe */ _api_agents_next__WEBPACK_IMPORTED_MODULE_1__.requestFeedbackAuthRouteHandler),\n/* harmony export */   requireChainEnvVar: () => (/* reexport safe */ _lib_chainConfig__WEBPACK_IMPORTED_MODULE_28__.requireChainEnvVar),\n/* harmony export */   resetAdminApp: () => (/* reexport safe */ _userApps_adminApp__WEBPACK_IMPORTED_MODULE_17__.resetAdminApp),\n/* harmony export */   resetAssociationsClient: () => (/* reexport safe */ _singletons_associationClient__WEBPACK_IMPORTED_MODULE_23__.resetAssociationsClient),\n/* harmony export */   resetClientApp: () => (/* reexport safe */ _userApps_clientApp__WEBPACK_IMPORTED_MODULE_18__.resetClientApp),\n/* harmony export */   resetDiscoveryClient: () => (/* reexport safe */ _singletons_discoveryClient__WEBPACK_IMPORTED_MODULE_21__.resetDiscoveryClient),\n/* harmony export */   resetENSClient: () => (/* reexport safe */ _singletons_ensClient__WEBPACK_IMPORTED_MODULE_25__.resetENSClient),\n/* harmony export */   resetIPFSStorage: () => (/* reexport safe */ _lib_ipfs__WEBPACK_IMPORTED_MODULE_29__.resetIPFSStorage),\n/* harmony export */   resetProviderApp: () => (/* reexport safe */ _userApps_providerApp__WEBPACK_IMPORTED_MODULE_19__.resetProviderApp),\n/* harmony export */   resetValidationClient: () => (/* reexport safe */ _singletons_validationClient__WEBPACK_IMPORTED_MODULE_32__.resetValidationClient),\n/* harmony export */   resetValidatorApp: () => (/* reexport safe */ _userApps_validatorApp__WEBPACK_IMPORTED_MODULE_20__.resetValidatorApp),\n/* harmony export */   searchAgentsGetRouteHandler: () => (/* reexport safe */ _api_search_next__WEBPACK_IMPORTED_MODULE_27__.searchAgentsGetRouteHandler),\n/* harmony export */   searchAgentsPostRouteHandler: () => (/* reexport safe */ _api_search_next__WEBPACK_IMPORTED_MODULE_27__.searchAgentsPostRouteHandler),\n/* harmony export */   semanticAgentSearchPostRouteHandler: () => (/* reexport safe */ _api_search_next__WEBPACK_IMPORTED_MODULE_27__.semanticAgentSearchPostRouteHandler),\n/* harmony export */   sepolia: () => (/* reexport safe */ _lib_chainConfig__WEBPACK_IMPORTED_MODULE_28__.sepolia),\n/* harmony export */   setL1NameInfoPK: () => (/* reexport safe */ _lib_names__WEBPACK_IMPORTED_MODULE_30__.setL1NameInfoPK),\n/* harmony export */   storeErc8092AssociationWithSessionDelegation: () => (/* reexport safe */ _services_delegatedAssociation__WEBPACK_IMPORTED_MODULE_24__.storeErc8092AssociationWithSessionDelegation),\n/* harmony export */   updateAgentRegistration: () => (/* reexport safe */ _api_agents_core__WEBPACK_IMPORTED_MODULE_5__.updateAgentRegistrationCore),\n/* harmony export */   updateAgentRegistrationExpressHandler: () => (/* reexport safe */ _api_agents_express__WEBPACK_IMPORTED_MODULE_3__.updateAgentRegistrationExpressHandler),\n/* harmony export */   updateAgentRegistrationRouteHandler: () => (/* reexport safe */ _api_agents_next__WEBPACK_IMPORTED_MODULE_1__.updateAgentRegistrationRouteHandler),\n/* harmony export */   uploadRegistration: () => (/* reexport safe */ _lib_agentRegistration__WEBPACK_IMPORTED_MODULE_15__.uploadRegistration),\n/* harmony export */   validateSessionPackage: () => (/* reexport safe */ _lib_sessionPackage__WEBPACK_IMPORTED_MODULE_31__.validateSessionPackage)\n/* harmony export */ });\n/* harmony import */ var _lib_resolveAccount__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/resolveAccount */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/lib/resolveAccount.js\");\n/* harmony import */ var _api_agents_next__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../api/agents/next */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/api/agents/next.js\");\n/* harmony import */ var _api_agents_directNext__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../api/agents/directNext */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/api/agents/directNext.js\");\n/* harmony import */ var _api_agents_express__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../api/agents/express */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/api/agents/express.js\");\n/* harmony import */ var _api_agents_directExpress__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../api/agents/directExpress */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/api/agents/directExpress.js\");\n/* harmony import */ var _api_agents_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../api/agents/core */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/api/agents/core.js\");\n/* harmony import */ var _api_agents_directServer__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../api/agents/directServer */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/api/agents/directServer.js\");\n/* harmony import */ var _singletons_agenticTrustClient__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./singletons/agenticTrustClient */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/singletons/agenticTrustClient.js\");\n/* harmony import */ var _lib_agenticTrust__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./lib/agenticTrust */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/lib/agenticTrust.js\");\n/* harmony import */ var _lib_a2aAgentCard__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./lib/a2aAgentCard */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/lib/a2aAgentCard.js\");\n/* harmony import */ var _lib_agent__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./lib/agent */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/lib/agent.js\");\n/* harmony import */ var _lib_agents__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./lib/agents */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/lib/agents.js\");\n/* harmony import */ var _lib_agentFeedback__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./lib/agentFeedback */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/lib/agentFeedback.js\");\n/* harmony import */ var _lib_delegationAssociation__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./lib/delegationAssociation */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/lib/delegationAssociation.js\");\n/* harmony import */ var _lib_association__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./lib/association */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/lib/association.js\");\n/* harmony import */ var _lib_agentRegistration__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./lib/agentRegistration */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/lib/agentRegistration.js\");\n/* harmony import */ var _lib_accounts__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./lib/accounts */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/lib/accounts.js\");\n/* harmony import */ var _userApps_adminApp__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./userApps/adminApp */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/userApps/adminApp.js\");\n/* harmony import */ var _userApps_clientApp__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./userApps/clientApp */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/userApps/clientApp.js\");\n/* harmony import */ var _userApps_providerApp__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./userApps/providerApp */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/userApps/providerApp.js\");\n/* harmony import */ var _userApps_validatorApp__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./userApps/validatorApp */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/userApps/validatorApp.js\");\n/* harmony import */ var _singletons_discoveryClient__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./singletons/discoveryClient */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/singletons/discoveryClient.js\");\n/* harmony import */ var _lib_uaid__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./lib/uaid */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/lib/uaid.js\");\n/* harmony import */ var _singletons_associationClient__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./singletons/associationClient */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/singletons/associationClient.js\");\n/* harmony import */ var _services_delegatedAssociation__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./services/delegatedAssociation */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/services/delegatedAssociation.js\");\n/* harmony import */ var _singletons_ensClient__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./singletons/ensClient */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/singletons/ensClient.js\");\n/* harmony import */ var _lib_discover__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./lib/discover */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/lib/discover.js\");\n/* harmony import */ var _api_search_next__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ../api/search/next */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/api/search/next.js\");\n/* harmony import */ var _lib_chainConfig__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./lib/chainConfig */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/lib/chainConfig.js\");\n/* harmony import */ var _lib_ipfs__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./lib/ipfs */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/lib/ipfs.js\");\n/* harmony import */ var _lib_names__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./lib/names */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/lib/names.js\");\n/* harmony import */ var _lib_sessionPackage__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./lib/sessionPackage */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/lib/sessionPackage.js\");\n/* harmony import */ var _singletons_validationClient__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ./singletons/validationClient */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/singletons/validationClient.js\");\n/* harmony import */ var _services_delegatedValidation__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ./services/delegatedValidation */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/services/delegatedValidation.js\");\n/* harmony import */ var _lib_validations__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! ./lib/validations */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/lib/validations.js\");\n/**\n * Server-only exports for @agentic-trust/core\n *\n * This entry point aggregates utilities that are safe to use in Node.js / server contexts only.\n * Import from `@agentic-trust/core/server` instead of the base package when you need these helpers.\n */\n// API route handlers (server-side only)\n\n// Next.js API route handlers for agents (function-based)\n\n\n// Express-compatible API route handlers and router helpers\n\n\n// Core agent API for direct server usage\n\n\n// Server singletons & utilities\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// API helpers for server routes (discovery/search)\n\n\n\n\n// Export IPFS storage (server-backed implementation)\n\n\n\n// AA utilities that rely on server-side contexts\n\n// Validation client and utilities\n\n\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BhZ2VudGljLXRydXN0L2NvcmUvZGlzdC9zZXJ2ZXIvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUM0RDtBQUM1RDtBQUMrVDtBQUNyUDtBQUMxRTtBQUNnUDtBQUNqSztBQUMvRTtBQUMyVTtBQUNuUDtBQUN4RjtBQUNzRTtBQUNWO0FBQ0o7QUFDbkI7QUFDSztBQUNnQjtBQUN5QjtBQUNEO0FBQ3FCO0FBQ2dGO0FBQ3pEO0FBQ007QUFDWDtBQUM2QjtBQUMvQjtBQUMvRDtBQUMwRTtBQUNBO0FBQ0M7QUFDbkk7QUFDaUQ7QUFDb0Y7QUFDM0M7QUFDNlc7QUFDdmM7QUFDNEc7QUFDL0M7QUFDaUU7QUFDOUg7QUFDb0U7QUFDcEU7QUFDbUk7QUFDSjtBQUNJO0FBQ25JIiwic291cmNlcyI6WyIvaG9tZS9iYXJiL2FhL0Fzc29jaWF0ZWRBY2NvdW50cy9ub2RlX21vZHVsZXMvQGFnZW50aWMtdHJ1c3QvY29yZS9kaXN0L3NlcnZlci9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFNlcnZlci1vbmx5IGV4cG9ydHMgZm9yIEBhZ2VudGljLXRydXN0L2NvcmVcbiAqXG4gKiBUaGlzIGVudHJ5IHBvaW50IGFnZ3JlZ2F0ZXMgdXRpbGl0aWVzIHRoYXQgYXJlIHNhZmUgdG8gdXNlIGluIE5vZGUuanMgLyBzZXJ2ZXIgY29udGV4dHMgb25seS5cbiAqIEltcG9ydCBmcm9tIGBAYWdlbnRpYy10cnVzdC9jb3JlL3NlcnZlcmAgaW5zdGVhZCBvZiB0aGUgYmFzZSBwYWNrYWdlIHdoZW4geW91IG5lZWQgdGhlc2UgaGVscGVycy5cbiAqL1xuLy8gQVBJIHJvdXRlIGhhbmRsZXJzIChzZXJ2ZXItc2lkZSBvbmx5KVxuZXhwb3J0IHsgaGFuZGxlUmVzb2x2ZUFjY291bnQgfSBmcm9tICcuL2xpYi9yZXNvbHZlQWNjb3VudCc7XG4vLyBOZXh0LmpzIEFQSSByb3V0ZSBoYW5kbGVycyBmb3IgYWdlbnRzIChmdW5jdGlvbi1iYXNlZClcbmV4cG9ydCB7IGNyZWF0ZUFnZW50Um91dGVIYW5kbGVyLCB1cGRhdGVBZ2VudFJlZ2lzdHJhdGlvblJvdXRlSGFuZGxlciwgcmVxdWVzdEZlZWRiYWNrQXV0aFJvdXRlSGFuZGxlciwgcHJlcGFyZUZlZWRiYWNrUm91dGVIYW5kbGVyLCBwcmVwYXJlVmFsaWRhdGlvblJlcXVlc3RSb3V0ZUhhbmRsZXIsIHByZXBhcmVBc3NvY2lhdGlvblJlcXVlc3RSb3V0ZUhhbmRsZXIsIGdldEZlZWRiYWNrUm91dGVIYW5kbGVyLCBkaXJlY3RGZWVkYmFja1JvdXRlSGFuZGxlciwgZ2V0VmFsaWRhdGlvbnNSb3V0ZUhhbmRsZXIsIH0gZnJvbSAnLi4vYXBpL2FnZW50cy9uZXh0JztcbmV4cG9ydCB7IGNyZWF0ZUFnZW50RGlyZWN0Um91dGVIYW5kbGVyLCB9IGZyb20gJy4uL2FwaS9hZ2VudHMvZGlyZWN0TmV4dCc7XG4vLyBFeHByZXNzLWNvbXBhdGlibGUgQVBJIHJvdXRlIGhhbmRsZXJzIGFuZCByb3V0ZXIgaGVscGVyc1xuZXhwb3J0IHsgY3JlYXRlQWdlbnRFeHByZXNzSGFuZGxlciwgdXBkYXRlQWdlbnRSZWdpc3RyYXRpb25FeHByZXNzSGFuZGxlciwgcmVxdWVzdEZlZWRiYWNrQXV0aEV4cHJlc3NIYW5kbGVyLCBwcmVwYXJlRmVlZGJhY2tFeHByZXNzSGFuZGxlciwgZ2V0RmVlZGJhY2tFeHByZXNzSGFuZGxlciwgbW91bnRBZ2VudFJvdXRlcyBhcyBtb3VudEFnZW50QXBpUm91dGVzLCB9IGZyb20gJy4uL2FwaS9hZ2VudHMvZXhwcmVzcyc7XG5leHBvcnQgeyBjcmVhdGVBZ2VudERpcmVjdEV4cHJlc3NIYW5kbGVyLCB9IGZyb20gJy4uL2FwaS9hZ2VudHMvZGlyZWN0RXhwcmVzcyc7XG4vLyBDb3JlIGFnZW50IEFQSSBmb3IgZGlyZWN0IHNlcnZlciB1c2FnZVxuZXhwb3J0IHsgY3JlYXRlQWdlbnRDb3JlIGFzIGNyZWF0ZUFnZW50LCB1cGRhdGVBZ2VudFJlZ2lzdHJhdGlvbkNvcmUgYXMgdXBkYXRlQWdlbnRSZWdpc3RyYXRpb24sIHJlcXVlc3RGZWVkYmFja0F1dGhDb3JlIGFzIHJlcXVlc3RGZWVkYmFja0F1dGgsIHByZXBhcmVGZWVkYmFja0NvcmUgYXMgcHJlcGFyZUZlZWRiYWNrLCBwcmVwYXJlVmFsaWRhdGlvblJlcXVlc3RDb3JlIGFzIHByZXBhcmVWYWxpZGF0aW9uUmVxdWVzdCwgcHJlcGFyZUFzc29jaWF0aW9uUmVxdWVzdENvcmUgYXMgcHJlcGFyZUFzc29jaWF0aW9uUmVxdWVzdCwgfSBmcm9tICcuLi9hcGkvYWdlbnRzL2NvcmUnO1xuZXhwb3J0IHsgY3JlYXRlQWdlbnREaXJlY3RDb3JlIGFzIGNyZWF0ZUFnZW50RGlyZWN0IH0gZnJvbSAnLi4vYXBpL2FnZW50cy9kaXJlY3RTZXJ2ZXInO1xuLy8gU2VydmVyIHNpbmdsZXRvbnMgJiB1dGlsaXRpZXNcbmV4cG9ydCB7IEFnZW50aWNUcnVzdENsaWVudCwgfSBmcm9tICcuL3NpbmdsZXRvbnMvYWdlbnRpY1RydXN0Q2xpZW50JztcbmV4cG9ydCB7IGdldEFnZW50aWNUcnVzdENsaWVudCwgfSBmcm9tICcuL2xpYi9hZ2VudGljVHJ1c3QnO1xuZXhwb3J0IHsgZmV0Y2hBMkFBZ2VudENhcmQsIH0gZnJvbSAnLi9saWIvYTJhQWdlbnRDYXJkJztcbmV4cG9ydCB7IEFnZW50LCB9IGZyb20gJy4vbGliL2FnZW50JztcbmV4cG9ydCB7IEFnZW50c0FQSSwgfSBmcm9tICcuL2xpYi9hZ2VudHMnO1xuZXhwb3J0IHsgY3JlYXRlRmVlZGJhY2tBdXRoLCB9IGZyb20gJy4vbGliL2FnZW50RmVlZGJhY2snO1xuZXhwb3J0IHsgY3JlYXRlRGVsZWdhdGlvbkFzc29jaWF0aW9uV2l0aElwZnMsIH0gZnJvbSAnLi9saWIvZGVsZWdhdGlvbkFzc29jaWF0aW9uJztcbmV4cG9ydCB7IGVuY29kZUFzc29jaWF0aW9uRGF0YSwgZGVjb2RlQXNzb2NpYXRpb25EYXRhLCB9IGZyb20gJy4vbGliL2Fzc29jaWF0aW9uJztcbmV4cG9ydCB7IHVwbG9hZFJlZ2lzdHJhdGlvbiwgZ2V0UmVnaXN0cmF0aW9uLCBjcmVhdGVSZWdpc3RyYXRpb25KU09OLCB9IGZyb20gJy4vbGliL2FnZW50UmVnaXN0cmF0aW9uJztcbmV4cG9ydCB7IGdldEFnZW50QWNjb3VudEJ5QWdlbnROYW1lLCBleHRyYWN0QWdlbnRBY2NvdW50RnJvbURpc2NvdmVyeSwgZ2V0Q291bnRlcmZhY3R1YWxTbWFydEFjY291bnRBZGRyZXNzQnlBZ2VudE5hbWUsIGdldENvdW50ZXJmYWN0dWFsQUFBZGRyZXNzQnlBZ2VudE5hbWUsIH0gZnJvbSAnLi9saWIvYWNjb3VudHMnO1xuZXhwb3J0IHsgZ2V0QWRtaW5BcHAsIGdldEFkbWluQWRkcmVzcywgaXNBZG1pbkFwcEluaXRpYWxpemVkLCByZXNldEFkbWluQXBwLCBoYXNBZG1pblByaXZhdGVLZXksIH0gZnJvbSAnLi91c2VyQXBwcy9hZG1pbkFwcCc7XG5leHBvcnQgeyBnZXRDbGllbnRBcHAsIGdldENsaWVudEFwcEFjY291bnQsIGdldENsaWVudEFkZHJlc3MsIGlzQ2xpZW50QXBwSW5pdGlhbGl6ZWQsIHJlc2V0Q2xpZW50QXBwLCB9IGZyb20gJy4vdXNlckFwcHMvY2xpZW50QXBwJztcbmV4cG9ydCB7IGdldFByb3ZpZGVyQXBwLCBnZXRQcm92aWRlckFnZW50SWQsIGlzUHJvdmlkZXJBcHBJbml0aWFsaXplZCwgcmVzZXRQcm92aWRlckFwcCwgfSBmcm9tICcuL3VzZXJBcHBzL3Byb3ZpZGVyQXBwJztcbmV4cG9ydCB7IGdldFZhbGlkYXRvckFwcCwgZ2V0VmFsaWRhdG9yQWRkcmVzcywgaGFzVmFsaWRhdG9yUHJpdmF0ZUtleSwgaXNWYWxpZGF0b3JBcHBJbml0aWFsaXplZCwgcmVzZXRWYWxpZGF0b3JBcHAsIH0gZnJvbSAnLi91c2VyQXBwcy92YWxpZGF0b3JBcHAnO1xuZXhwb3J0IHsgZ2V0RGlzY292ZXJ5Q2xpZW50LCBpc0Rpc2NvdmVyeUNsaWVudEluaXRpYWxpemVkLCByZXNldERpc2NvdmVyeUNsaWVudCwgfSBmcm9tICcuL3NpbmdsZXRvbnMvZGlzY292ZXJ5Q2xpZW50JztcbmV4cG9ydCB7IGdlbmVyYXRlSGNzMTRVYWlkRGlkVGFyZ2V0IH0gZnJvbSAnLi9saWIvdWFpZCc7XG5leHBvcnQgeyBnZXRBc3NvY2lhdGlvbnNDbGllbnQsIGlzQXNzb2NpYXRpb25zQ2xpZW50SW5pdGlhbGl6ZWQsIHJlc2V0QXNzb2NpYXRpb25zQ2xpZW50LCB9IGZyb20gJy4vc2luZ2xldG9ucy9hc3NvY2lhdGlvbkNsaWVudCc7XG5leHBvcnQgeyBidWlsZERlbGVnYXRlZEFzc29jaWF0aW9uQ29udGV4dCwgc3RvcmVFcmM4MDkyQXNzb2NpYXRpb25XaXRoU2Vzc2lvbkRlbGVnYXRpb24sIH0gZnJvbSAnLi9zZXJ2aWNlcy9kZWxlZ2F0ZWRBc3NvY2lhdGlvbic7XG5leHBvcnQgeyBnZXRFTlNDbGllbnQsIGlzRU5TQ2xpZW50SW5pdGlhbGl6ZWQsIHJlc2V0RU5TQ2xpZW50LCBpc0VOU05hbWVBdmFpbGFibGUsIGlzRU5TQXZhaWxhYmxlLCB9IGZyb20gJy4vc2luZ2xldG9ucy9lbnNDbGllbnQnO1xuLy8gQVBJIGhlbHBlcnMgZm9yIHNlcnZlciByb3V0ZXMgKGRpc2NvdmVyeS9zZWFyY2gpXG5leHBvcnQgeyBkaXNjb3ZlckFnZW50cywgfSBmcm9tICcuL2xpYi9kaXNjb3Zlcic7XG5leHBvcnQgeyBzZWFyY2hBZ2VudHNHZXRSb3V0ZUhhbmRsZXIsIHNlYXJjaEFnZW50c1Bvc3RSb3V0ZUhhbmRsZXIsIHNlbWFudGljQWdlbnRTZWFyY2hQb3N0Um91dGVIYW5kbGVyLCB9IGZyb20gJy4uL2FwaS9zZWFyY2gvbmV4dCc7XG5leHBvcnQgeyBnZXRBY2NvdW50T3duZXIsIGdldEFjY291bnRPd25lckJ5RGlkRXRociwgcGFyc2VFdGhyRGlkLCB9IGZyb20gJy4vbGliL2FjY291bnRzJztcbmV4cG9ydCB7IGdldENoYWluRW52VmFyLCBnZXRDaGFpbkVudlZhckRldGFpbHMsIGdldENoYWluRW52VmFyTmFtZXMsIHJlcXVpcmVDaGFpbkVudlZhciwgZ2V0Q2hhaW5CeUlkLCBnZXRTdXBwb3J0ZWRDaGFpbklkcywgaXNDaGFpblN1cHBvcnRlZCwgZ2V0Q2hhaW5Db25maWcsIGdldENoYWluUnBjVXJsLCBnZXRDaGFpbkJ1bmRsZXJVcmwsIGlzUHJpdmF0ZUtleU1vZGUsIGdldEVuc09yZ05hbWUsIGdldEVuc09yZ0FkZHJlc3MsIGdldEVuc1ByaXZhdGVLZXksIGdldFdlYjNBdXRoQ2xpZW50SWQsIGdldFdlYjNBdXRoTmV0d29yaywgZ2V0Q2hhaW5EaXNwbGF5TWV0YWRhdGEsIGdldFdlYjNBdXRoQ2hhaW5TZXR0aW5ncywgZ2V0Q2hhaW5JZEhleCwgREVGQVVMVF9DSEFJTl9JRCwgc2Vwb2xpYSwgYmFzZVNlcG9saWEsIG9wdGltaXNtU2Vwb2xpYSwgfSBmcm9tICcuL2xpYi9jaGFpbkNvbmZpZyc7XG4vLyBFeHBvcnQgSVBGUyBzdG9yYWdlIChzZXJ2ZXItYmFja2VkIGltcGxlbWVudGF0aW9uKVxuZXhwb3J0IHsgY3JlYXRlSVBGU1N0b3JhZ2UsIGdldElQRlNTdG9yYWdlLCBpc0lQRlNTdG9yYWdlSW5pdGlhbGl6ZWQsIHJlc2V0SVBGU1N0b3JhZ2UsIH0gZnJvbSAnLi9saWIvaXBmcyc7XG5leHBvcnQgeyBhZGRUb0wxT3JnUEssIHNldEwxTmFtZUluZm9QSywgfSBmcm9tICcuL2xpYi9uYW1lcyc7XG5leHBvcnQgeyBsb2FkU2Vzc2lvblBhY2thZ2UsIHZhbGlkYXRlU2Vzc2lvblBhY2thZ2UsIGJ1aWxkRGVsZWdhdGlvblNldHVwLCBidWlsZFNlc3Npb25QYWNrYWdlLCB9IGZyb20gJy4vbGliL3Nlc3Npb25QYWNrYWdlJztcbi8vIEFBIHV0aWxpdGllcyB0aGF0IHJlbHkgb24gc2VydmVyLXNpZGUgY29udGV4dHNcbmV4cG9ydCB7IGJ1aWxkQWdlbnRBY2NvdW50RnJvbVNlc3Npb24gfSBmcm9tICcuL2xpYi9zZXNzaW9uUGFja2FnZSc7XG4vLyBWYWxpZGF0aW9uIGNsaWVudCBhbmQgdXRpbGl0aWVzXG5leHBvcnQgeyBnZXRWYWxpZGF0aW9uUmVnaXN0cnlDbGllbnQsIGlzVmFsaWRhdGlvbkNsaWVudEluaXRpYWxpemVkLCByZXNldFZhbGlkYXRpb25DbGllbnQsIH0gZnJvbSAnLi9zaW5nbGV0b25zL3ZhbGlkYXRpb25DbGllbnQnO1xuZXhwb3J0IHsgcHJvY2Vzc1ZhbGlkYXRpb25SZXF1ZXN0c1dpdGhTZXNzaW9uUGFja2FnZSwgYnVpbGREZWxlZ2F0ZWRWYWxpZGF0aW9uQ29udGV4dCwgfSBmcm9tICcuL3NlcnZpY2VzL2RlbGVnYXRlZFZhbGlkYXRpb24nO1xuZXhwb3J0IHsgY3JlYXRlVmFsaWRhdG9yQWNjb3VudEFic3RyYWN0aW9uLCBnZXRBZ2VudFZhbGlkYXRpb25zU3VtbWFyeSwgZ2V0VmFsaWRhdG9yQWRkcmVzc1ZhbGlkYXRpb25zLCB9IGZyb20gJy4vbGliL3ZhbGlkYXRpb25zJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@agentic-trust/core/dist/server/index.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@agentic-trust/core/dist/server/lib/a2aAgentCard.js":
/*!******************************************************************************!*\
  !*** ../../node_modules/@agentic-trust/core/dist/server/lib/a2aAgentCard.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fetchA2AAgentCard: () => (/* binding */ fetchA2AAgentCard)\n/* harmony export */ });\n/* harmony import */ var http__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! http */ \"http\");\n/* harmony import */ var https__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! https */ \"https\");\n\n\n/**\n * Fetch an A2A agent card from a URL\n * Supports both direct URLs and base URLs (will append /.well-known/agent-card.json)\n */\nasync function fetchA2AAgentCard(cardUrl) {\n    try {\n        // Normalize the URL - handle both full URLs and base URLs\n        let url = cardUrl?.trim() ?? '';\n        if (!url) {\n            throw new Error('Agent card URL is empty');\n        }\n        // Support scheme-less inputs like \"agent.example.com\" or \"//agent.example.com\"\n        if (url.startsWith('//')) {\n            url = `https:${url}`;\n        }\n        else if (!url.startsWith('http://') && !url.startsWith('https://')) {\n            url = `https://${url.replace(/^\\/+/, '')}`;\n        }\n        // Parse the URL to handle it properly\n        let urlObj;\n        try {\n            urlObj = new URL(url);\n        }\n        catch (urlError) {\n            throw new Error(`Invalid URL format: ${url}. ${urlError instanceof Error ? urlError.message : 'Unknown error'}`);\n        }\n        // Normalize localhost to 127.0.0.1 for better Node.js compatibility\n        if (urlObj.hostname === 'localhost') {\n            urlObj.hostname = '127.0.0.1';\n        }\n        // Agent card is always at the base domain's /.well-known/agent-card.json (v1.0)\n        // Extract the origin (protocol + hostname + port) and use that as the base\n        // This ensures that even if the input is an A2A endpoint like /api/a2a,\n        // we construct the agent card from the base domain\n        const isWellKnownAgentJson = /\\/agent\\.json\\/?$/i.test(urlObj.pathname);\n        const isWellKnownAgentCardJson = /\\/agent-card\\.json\\/?$/i.test(urlObj.pathname);\n        if (!isWellKnownAgentJson && !isWellKnownAgentCardJson) {\n            // Use the origin (base domain) and set path to /.well-known/agent-card.json\n            // This works for both base URLs and protocol endpoint URLs (e.g., /api/a2a)\n            urlObj.pathname = '/.well-known/agent-card.json';\n        }\n        const finalUrl = urlObj.toString();\n        console.log('[fetchA2AAgentCard] Fetching from:', finalUrl);\n        // Try fetch first, fallback to native http/https if it fails\n        let response;\n        try {\n            response = await fetch(finalUrl, {\n                method: 'GET',\n                headers: {\n                    Accept: 'application/json',\n                },\n                // Disable any HTTP caching so we always hit the live provider\n                cache: 'no-store',\n            });\n        }\n        catch (fetchError) {\n            // If fetch fails (e.g., \"bad port\" error with localhost), try native http/https\n            console.warn('[fetchA2AAgentCard] Fetch failed, trying native http/https:', fetchError);\n            const card = await fetchWithNativeHttp(urlObj);\n            return card;\n        }\n        if (!response.ok) {\n            throw new Error(`Failed to fetch agent card: ${response.status} ${response.statusText}`);\n        }\n        const card = await response.json();\n        return card;\n    }\n    catch (error) {\n        console.error('[fetchA2AAgentCard] Error fetching agent card:', error);\n        if (error instanceof Error) {\n            console.error('[fetchA2AAgentCard] Error details:', {\n                message: error.message,\n                stack: error.stack,\n                cardUrl,\n            });\n        }\n        return null;\n    }\n}\n/**\n * Fallback: Use native Node.js http/https modules when fetch fails\n */\nasync function fetchWithNativeHttp(urlObj) {\n    return new Promise((resolve, reject) => {\n        const isHttps = urlObj.protocol === 'https:';\n        const httpModule = isHttps ? https__WEBPACK_IMPORTED_MODULE_1__.request : http__WEBPACK_IMPORTED_MODULE_0__.request;\n        const options = {\n            hostname: urlObj.hostname,\n            port: urlObj.port || (isHttps ? 443 : 80),\n            path: urlObj.pathname + urlObj.search,\n            method: 'GET',\n            headers: {\n                Accept: 'application/json',\n            },\n        };\n        const req = httpModule(options, (res) => {\n            let data = '';\n            res.on('data', (chunk) => {\n                data += chunk;\n            });\n            res.on('end', () => {\n                if (res.statusCode && res.statusCode >= 200 && res.statusCode < 300) {\n                    try {\n                        const card = JSON.parse(data);\n                        resolve(card);\n                    }\n                    catch (parseError) {\n                        reject(new Error(`Failed to parse agent card JSON: ${parseError instanceof Error ? parseError.message : 'Unknown error'}`));\n                    }\n                }\n                else {\n                    reject(new Error(`Failed to fetch agent card: ${res.statusCode} ${res.statusMessage || 'Unknown error'}`));\n                }\n            });\n        });\n        req.on('error', (error) => {\n            reject(new Error(`HTTP request failed: ${error.message}`));\n        });\n        req.end();\n    });\n}\n//# sourceMappingURL=a2aAgentCard.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BhZ2VudGljLXRydXN0L2NvcmUvZGlzdC9zZXJ2ZXIvbGliL2EyYUFnZW50Q2FyZC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBK0I7QUFDaUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsSUFBSTtBQUMvQjtBQUNBO0FBQ0EsNkJBQTZCLHdCQUF3QjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxJQUFJLElBQUksK0RBQStEO0FBQzFIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxpQkFBaUIsRUFBRSxvQkFBb0I7QUFDbEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQywwQ0FBWSxHQUFHLHlDQUFPO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkUsbUVBQW1FO0FBQ2hKO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSxnQkFBZ0IsRUFBRSxxQ0FBcUM7QUFDM0g7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0EscURBQXFELGNBQWM7QUFDbkUsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL2JhcmIvYWEvQXNzb2NpYXRlZEFjY291bnRzL25vZGVfbW9kdWxlcy9AYWdlbnRpYy10cnVzdC9jb3JlL2Rpc3Qvc2VydmVyL2xpYi9hMmFBZ2VudENhcmQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcmVxdWVzdCB9IGZyb20gJ2h0dHAnO1xuaW1wb3J0IHsgcmVxdWVzdCBhcyBodHRwc1JlcXVlc3QgfSBmcm9tICdodHRwcyc7XG4vKipcbiAqIEZldGNoIGFuIEEyQSBhZ2VudCBjYXJkIGZyb20gYSBVUkxcbiAqIFN1cHBvcnRzIGJvdGggZGlyZWN0IFVSTHMgYW5kIGJhc2UgVVJMcyAod2lsbCBhcHBlbmQgLy53ZWxsLWtub3duL2FnZW50LWNhcmQuanNvbilcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGZldGNoQTJBQWdlbnRDYXJkKGNhcmRVcmwpIHtcbiAgICB0cnkge1xuICAgICAgICAvLyBOb3JtYWxpemUgdGhlIFVSTCAtIGhhbmRsZSBib3RoIGZ1bGwgVVJMcyBhbmQgYmFzZSBVUkxzXG4gICAgICAgIGxldCB1cmwgPSBjYXJkVXJsPy50cmltKCkgPz8gJyc7XG4gICAgICAgIGlmICghdXJsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FnZW50IGNhcmQgVVJMIGlzIGVtcHR5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU3VwcG9ydCBzY2hlbWUtbGVzcyBpbnB1dHMgbGlrZSBcImFnZW50LmV4YW1wbGUuY29tXCIgb3IgXCIvL2FnZW50LmV4YW1wbGUuY29tXCJcbiAgICAgICAgaWYgKHVybC5zdGFydHNXaXRoKCcvLycpKSB7XG4gICAgICAgICAgICB1cmwgPSBgaHR0cHM6JHt1cmx9YDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghdXJsLnN0YXJ0c1dpdGgoJ2h0dHA6Ly8nKSAmJiAhdXJsLnN0YXJ0c1dpdGgoJ2h0dHBzOi8vJykpIHtcbiAgICAgICAgICAgIHVybCA9IGBodHRwczovLyR7dXJsLnJlcGxhY2UoL15cXC8rLywgJycpfWA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUGFyc2UgdGhlIFVSTCB0byBoYW5kbGUgaXQgcHJvcGVybHlcbiAgICAgICAgbGV0IHVybE9iajtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHVybE9iaiA9IG5ldyBVUkwodXJsKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAodXJsRXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBVUkwgZm9ybWF0OiAke3VybH0uICR7dXJsRXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IHVybEVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvcid9YCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm9ybWFsaXplIGxvY2FsaG9zdCB0byAxMjcuMC4wLjEgZm9yIGJldHRlciBOb2RlLmpzIGNvbXBhdGliaWxpdHlcbiAgICAgICAgaWYgKHVybE9iai5ob3N0bmFtZSA9PT0gJ2xvY2FsaG9zdCcpIHtcbiAgICAgICAgICAgIHVybE9iai5ob3N0bmFtZSA9ICcxMjcuMC4wLjEnO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFnZW50IGNhcmQgaXMgYWx3YXlzIGF0IHRoZSBiYXNlIGRvbWFpbidzIC8ud2VsbC1rbm93bi9hZ2VudC1jYXJkLmpzb24gKHYxLjApXG4gICAgICAgIC8vIEV4dHJhY3QgdGhlIG9yaWdpbiAocHJvdG9jb2wgKyBob3N0bmFtZSArIHBvcnQpIGFuZCB1c2UgdGhhdCBhcyB0aGUgYmFzZVxuICAgICAgICAvLyBUaGlzIGVuc3VyZXMgdGhhdCBldmVuIGlmIHRoZSBpbnB1dCBpcyBhbiBBMkEgZW5kcG9pbnQgbGlrZSAvYXBpL2EyYSxcbiAgICAgICAgLy8gd2UgY29uc3RydWN0IHRoZSBhZ2VudCBjYXJkIGZyb20gdGhlIGJhc2UgZG9tYWluXG4gICAgICAgIGNvbnN0IGlzV2VsbEtub3duQWdlbnRKc29uID0gL1xcL2FnZW50XFwuanNvblxcLz8kL2kudGVzdCh1cmxPYmoucGF0aG5hbWUpO1xuICAgICAgICBjb25zdCBpc1dlbGxLbm93bkFnZW50Q2FyZEpzb24gPSAvXFwvYWdlbnQtY2FyZFxcLmpzb25cXC8/JC9pLnRlc3QodXJsT2JqLnBhdGhuYW1lKTtcbiAgICAgICAgaWYgKCFpc1dlbGxLbm93bkFnZW50SnNvbiAmJiAhaXNXZWxsS25vd25BZ2VudENhcmRKc29uKSB7XG4gICAgICAgICAgICAvLyBVc2UgdGhlIG9yaWdpbiAoYmFzZSBkb21haW4pIGFuZCBzZXQgcGF0aCB0byAvLndlbGwta25vd24vYWdlbnQtY2FyZC5qc29uXG4gICAgICAgICAgICAvLyBUaGlzIHdvcmtzIGZvciBib3RoIGJhc2UgVVJMcyBhbmQgcHJvdG9jb2wgZW5kcG9pbnQgVVJMcyAoZS5nLiwgL2FwaS9hMmEpXG4gICAgICAgICAgICB1cmxPYmoucGF0aG5hbWUgPSAnLy53ZWxsLWtub3duL2FnZW50LWNhcmQuanNvbic7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZmluYWxVcmwgPSB1cmxPYmoudG9TdHJpbmcoKTtcbiAgICAgICAgY29uc29sZS5sb2coJ1tmZXRjaEEyQUFnZW50Q2FyZF0gRmV0Y2hpbmcgZnJvbTonLCBmaW5hbFVybCk7XG4gICAgICAgIC8vIFRyeSBmZXRjaCBmaXJzdCwgZmFsbGJhY2sgdG8gbmF0aXZlIGh0dHAvaHR0cHMgaWYgaXQgZmFpbHNcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChmaW5hbFVybCwge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICAgICBBY2NlcHQ6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIC8vIERpc2FibGUgYW55IEhUVFAgY2FjaGluZyBzbyB3ZSBhbHdheXMgaGl0IHRoZSBsaXZlIHByb3ZpZGVyXG4gICAgICAgICAgICAgICAgY2FjaGU6ICduby1zdG9yZScsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZmV0Y2hFcnJvcikge1xuICAgICAgICAgICAgLy8gSWYgZmV0Y2ggZmFpbHMgKGUuZy4sIFwiYmFkIHBvcnRcIiBlcnJvciB3aXRoIGxvY2FsaG9zdCksIHRyeSBuYXRpdmUgaHR0cC9odHRwc1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdbZmV0Y2hBMkFBZ2VudENhcmRdIEZldGNoIGZhaWxlZCwgdHJ5aW5nIG5hdGl2ZSBodHRwL2h0dHBzOicsIGZldGNoRXJyb3IpO1xuICAgICAgICAgICAgY29uc3QgY2FyZCA9IGF3YWl0IGZldGNoV2l0aE5hdGl2ZUh0dHAodXJsT2JqKTtcbiAgICAgICAgICAgIHJldHVybiBjYXJkO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGZldGNoIGFnZW50IGNhcmQ6ICR7cmVzcG9uc2Uuc3RhdHVzfSAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2FyZCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgcmV0dXJuIGNhcmQ7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdbZmV0Y2hBMkFBZ2VudENhcmRdIEVycm9yIGZldGNoaW5nIGFnZW50IGNhcmQ6JywgZXJyb3IpO1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignW2ZldGNoQTJBQWdlbnRDYXJkXSBFcnJvciBkZXRhaWxzOicsIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBlcnJvci5tZXNzYWdlLFxuICAgICAgICAgICAgICAgIHN0YWNrOiBlcnJvci5zdGFjayxcbiAgICAgICAgICAgICAgICBjYXJkVXJsLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuLyoqXG4gKiBGYWxsYmFjazogVXNlIG5hdGl2ZSBOb2RlLmpzIGh0dHAvaHR0cHMgbW9kdWxlcyB3aGVuIGZldGNoIGZhaWxzXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGZldGNoV2l0aE5hdGl2ZUh0dHAodXJsT2JqKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgY29uc3QgaXNIdHRwcyA9IHVybE9iai5wcm90b2NvbCA9PT0gJ2h0dHBzOic7XG4gICAgICAgIGNvbnN0IGh0dHBNb2R1bGUgPSBpc0h0dHBzID8gaHR0cHNSZXF1ZXN0IDogcmVxdWVzdDtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGhvc3RuYW1lOiB1cmxPYmouaG9zdG5hbWUsXG4gICAgICAgICAgICBwb3J0OiB1cmxPYmoucG9ydCB8fCAoaXNIdHRwcyA/IDQ0MyA6IDgwKSxcbiAgICAgICAgICAgIHBhdGg6IHVybE9iai5wYXRobmFtZSArIHVybE9iai5zZWFyY2gsXG4gICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgIEFjY2VwdDogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcmVxID0gaHR0cE1vZHVsZShvcHRpb25zLCAocmVzKSA9PiB7XG4gICAgICAgICAgICBsZXQgZGF0YSA9ICcnO1xuICAgICAgICAgICAgcmVzLm9uKCdkYXRhJywgKGNodW5rKSA9PiB7XG4gICAgICAgICAgICAgICAgZGF0YSArPSBjaHVuaztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmVzLm9uKCdlbmQnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHJlcy5zdGF0dXNDb2RlICYmIHJlcy5zdGF0dXNDb2RlID49IDIwMCAmJiByZXMuc3RhdHVzQ29kZSA8IDMwMCkge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2FyZCA9IEpTT04ucGFyc2UoZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGNhcmQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChwYXJzZUVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKGBGYWlsZWQgdG8gcGFyc2UgYWdlbnQgY2FyZCBKU09OOiAke3BhcnNlRXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IHBhcnNlRXJyb3IubWVzc2FnZSA6ICdVbmtub3duIGVycm9yJ31gKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoYEZhaWxlZCB0byBmZXRjaCBhZ2VudCBjYXJkOiAke3Jlcy5zdGF0dXNDb2RlfSAke3Jlcy5zdGF0dXNNZXNzYWdlIHx8ICdVbmtub3duIGVycm9yJ31gKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXEub24oJ2Vycm9yJywgKGVycm9yKSA9PiB7XG4gICAgICAgICAgICByZWplY3QobmV3IEVycm9yKGBIVFRQIHJlcXVlc3QgZmFpbGVkOiAke2Vycm9yLm1lc3NhZ2V9YCkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmVxLmVuZCgpO1xuICAgIH0pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YTJhQWdlbnRDYXJkLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@agentic-trust/core/dist/server/lib/a2aAgentCard.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@agentic-trust/core/dist/server/lib/a2aProtocolProvider.js":
/*!*************************************************************************************!*\
  !*** ../../node_modules/@agentic-trust/core/dist/server/lib/a2aProtocolProvider.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A2AProtocolProvider: () => (/* binding */ A2AProtocolProvider),\n/* harmony export */   A2AProtocolProviderAPI: () => (/* binding */ A2AProtocolProviderAPI)\n/* harmony export */ });\n/* harmony import */ var _a2aAgentCard__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./a2aAgentCard */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/lib/a2aAgentCard.js\");\n/**\n * A2A Protocol Provider API for AgenticTrust Client\n * Handles Agent-to-Agent (A2A) interactions\n */\n\n/**\n * A2A Protocol Provider API for GraphQL operations\n * Used by AgenticTrustClient for backend queries\n */\nclass A2AProtocolProviderAPI {\n    graphQLClient;\n    constructor(graphQLClient) {\n        this.graphQLClient = graphQLClient;\n    }\n    /**\n     * Get agent provider endpoint for A2A communication via GraphQL\n     */\n    async getAgentProvider(agentId) {\n        const query = `\r\n      query GetAgentProvider($agentId: String!) {\r\n        agentProvider(agentId: $agentId) {\r\n          providerId\r\n          endpoint\r\n          agentName\r\n        }\r\n      }\r\n    `;\n        try {\n            const data = await this.graphQLClient.request(query, { agentId });\n            return data.agentProvider;\n        }\n        catch (error) {\n            // If the query fails, return null\n            console.warn('Failed to get agent provider from GraphQL:', error);\n            return null;\n        }\n    }\n    /**\n     * Send an Agent-to-Agent (A2A) message via GraphQL\n     */\n    async sendA2AMessage(request) {\n        const mutation = `\r\n      mutation SendA2AMessage(\r\n        $fromAgentId: String!\r\n        $toAgentId: String!\r\n        $message: String\r\n        $payload: String\r\n        $metadata: String\r\n      ) {\r\n        sendA2AMessage(\r\n          fromAgentId: $fromAgentId\r\n          toAgentId: $toAgentId\r\n          message: $message\r\n          payload: $payload\r\n          metadata: $metadata\r\n        ) {\r\n          success\r\n          messageId\r\n          response\r\n          error\r\n        }\r\n      }\r\n    `;\n        try {\n            const data = await this.graphQLClient.request(mutation, {\n                fromAgentId: request.fromAgentId,\n                toAgentId: request.toAgentId,\n                message: request.message,\n                payload: request.payload ? JSON.stringify(request.payload) : undefined,\n                metadata: request.metadata ? JSON.stringify(request.metadata) : undefined,\n            });\n            return data.sendA2AMessage;\n        }\n        catch (error) {\n            // If mutation fails, return error response\n            return {\n                success: false,\n                error: error instanceof Error ? error.message : 'Failed to send A2A message',\n            };\n        }\n    }\n    /**\n     * List available agent providers via GraphQL\n     */\n    async listProviders() {\n        const query = `\r\n      query ListProviders {\r\n        providers {\r\n          id\r\n          providerId\r\n          agentName\r\n          endpoint\r\n        }\r\n      }\r\n    `;\n        const data = await this.graphQLClient.request(query);\n        return data.providers || [];\n    }\n}\n/**\n * A2A Protocol Provider for a specific agent\n * Handles direct A2A communication with an agent provider\n */\nclass A2AProtocolProvider {\n    // The URL provided by the caller. Interpreted as an agent-card URL (agent.json)\n    // or any URL on the same origin (we will bootstrap to /.well-known/agent.json).\n    providerUrl;\n    agentCard = null;\n    a2aEndpoint = null;\n    veramoAgent = null;\n    authenticated = false;\n    clientDid = null;\n    clientKid = null;\n    /**\n     * Check if an endpoint URL is a placeholder/example URL\n     * Note: localhost URLs are allowed for development, only actual placeholder/example domains are flagged\n     */\n    static isPlaceholderUrl(url) {\n        const placeholderPatterns = [\n            // Match example.com and its subdomains (actual placeholder domain)\n            /^https?:\\/\\/(www\\.)?example\\.com/i,\n            // Match other example domains (example.org, example.net, etc.)\n            /^https?:\\/\\/example\\.(com|org|net|edu|gov)/i,\n            // Match URLs containing \"placeholder\" (but not localhost)\n            /placeholder/i,\n            // Match URLs containing \"example\" but NOT localhost (to avoid false positives)\n            // This will catch things like \"example.com\" but not \"localhost:3001\"\n            /example/i,\n        ];\n        // Don't flag localhost URLs - they're valid for development\n        if (/^https?:\\/\\/localhost/i.test(url) || /^https?:\\/\\/127\\.0\\.0\\.1/i.test(url)) {\n            return false;\n        }\n        return placeholderPatterns.some(pattern => pattern.test(url));\n    }\n    /**\n     * Construct an A2A Protocol Provider for a specific agent.\n     *\n     * @param a2aEndpoint - The agent's A2A discovery URL (agent.json), or any URL on the agent's origin.\n     * @param veramoAgent - Veramo agent for authentication\n     */\n    constructor(a2aEndpoint, veramoAgent) {\n        // Verify a2aEndpoint is an absolute URL\n        if (!a2aEndpoint.startsWith('http://') && !a2aEndpoint.startsWith('https://')) {\n            //console.log(`Warning: a2aEndpoint should be an absolute URL (starting with http:// or https://), got: ${a2aEndpoint}`);\n        }\n        // Check if endpoint is a placeholder/example URL\n        if (A2AProtocolProvider.isPlaceholderUrl(a2aEndpoint)) {\n            //console.warn(`Warning: A2A endpoint appears to be a placeholder URL: ${a2aEndpoint}. This endpoint will not work for actual A2A communication.`);\n        }\n        this.providerUrl = a2aEndpoint.replace(/\\/$/, ''); // Remove trailing slash\n        this.veramoAgent = veramoAgent;\n    }\n    /**\n     * Fetch and cache the agent descriptor from /.well-known/agent.json\n     */\n    async fetchAgentCard() {\n        try {\n            console.log('[A2AProtocolProvider.fetchAgentCard] Fetching agent card using providerUrl:', this.providerUrl);\n            console.log('[A2AProtocolProvider.fetchAgentCard] Base providerUrl:', this.providerUrl);\n            const card = await (0,_a2aAgentCard__WEBPACK_IMPORTED_MODULE_0__.fetchA2AAgentCard)(this.providerUrl);\n            console.log('[A2AProtocolProvider.fetchAgentCard] Agent card received:', JSON.stringify(card, null, 2));\n            if (card) {\n                this.agentCard = card;\n                // Prefer explicit message endpoint from agent card.\n                // This must be explicitly declared by the agent card; we do not guess.\n                const baseOrigin = (() => {\n                    try {\n                        return new URL(this.providerUrl).origin.replace(/\\/$/, '');\n                    }\n                    catch {\n                        return this.providerUrl.replace(/\\/$/, '');\n                    }\n                })();\n                const endpointFromSupportedInterfaces = (() => {\n                    const supportedInterfaces = Array.isArray(card?.supportedInterfaces)\n                        ? card.supportedInterfaces\n                        : [];\n                    const pick = (binding) => supportedInterfaces.find((x) => String(x?.protocolBinding || '') === binding)?.url;\n                    // Prefer JSON-RPC if advertised; fall back to HTTP+JSON.\n                    return pick('JSONRPC') ?? pick('HTTP+JSON') ?? undefined;\n                })();\n                const endpointFromProviderUrl = typeof card?.provider?.url === 'string' ? card.provider.url : undefined;\n                const endpointFromEndpointsArray = Array.isArray(card.endpoints)\n                    ? card.endpoints.find((e) => String(e?.name || '').toLowerCase() === 'a2a')?.url ??\n                        card.endpoints.find((e) => String(e?.name || '').toLowerCase() === 'a2a')?.endpoint\n                    : undefined;\n                const endpointFromEndpointsObject = card?.endpoints && typeof card.endpoints === 'object' && !Array.isArray(card.endpoints)\n                    ? card.endpoints.a2a\n                    : undefined;\n                const normalizeEndpoint = (raw) => {\n                    const s = String(raw || '').trim();\n                    if (!s)\n                        return null;\n                    if (s.startsWith('http://') || s.startsWith('https://')) {\n                        try {\n                            const u = new URL(s);\n                            // If provider.url is just a bare origin (\"/\"), treat it as not an explicit message endpoint.\n                            // Agents should publish an explicit message endpoint (e.g. /api/a2a) in agent.json.\n                            if (!u.pathname || u.pathname === '/' || u.pathname === '')\n                                return null;\n                        }\n                        catch {\n                            // Fall through and still return the string trimmed.\n                        }\n                        return s.replace(/\\/$/, '');\n                    }\n                    if (s.startsWith('/'))\n                        return `${baseOrigin}${s}`;\n                    return `${baseOrigin}/${s.replace(/^\\/+/, '')}`;\n                };\n                const picked = normalizeEndpoint(endpointFromSupportedInterfaces) ??\n                    normalizeEndpoint(endpointFromProviderUrl) ??\n                    normalizeEndpoint(endpointFromEndpointsArray) ??\n                    normalizeEndpoint(endpointFromEndpointsObject);\n                if (picked) {\n                    console.log('[A2AProtocolProvider.fetchAgentCard] Using A2A endpoint from agent card:', picked);\n                    this.a2aEndpoint = picked;\n                }\n                else {\n                    console.warn('[A2AProtocolProvider.fetchAgentCard] Agent card did not declare an A2A message endpoint.');\n                    this.a2aEndpoint = null;\n                }\n                // Verify the constructed a2aEndpoint is absolute\n                if (this.a2aEndpoint && !this.a2aEndpoint.startsWith('http://') && !this.a2aEndpoint.startsWith('https://')) {\n                    console.warn('[A2AProtocolProvider.fetchAgentCard] Warning: A2A endpoint should be an absolute URL (starting with http:// or https://), got:', this.a2aEndpoint);\n                }\n            }\n            else {\n                console.warn('[A2AProtocolProvider.fetchAgentCard] No agent card received');\n                this.a2aEndpoint = null;\n            }\n            return card;\n        }\n        catch (error) {\n            console.error('[A2AProtocolProvider.fetchAgentCard] Failed to fetch agent card:', error);\n            console.error('[A2AProtocolProvider.fetchAgentCard] Error details:', {\n                message: error instanceof Error ? error.message : String(error),\n                stack: error instanceof Error ? error.stack : undefined,\n                providerUrl: this.providerUrl,\n            });\n            return null;\n        }\n    }\n    /**\n     * Get the cached agent card (call fetchAgentCard first)\n     */\n    getAgentCard() {\n        return this.agentCard;\n    }\n    /**\n     * Get the A2A endpoint URL\n     * This will fetch the agent card if not already cached\n     */\n    async getA2AEndpoint() {\n        // If we already have an a2aEndpoint constructed (with subdomain), use it directly\n        if (this.a2aEndpoint) {\n            console.log('[A2AProtocolProvider.getA2AEndpoint] Using cached endpoint:', this.a2aEndpoint);\n            return {\n                providerId: this.agentCard?.name || 'unknown',\n                url: this.a2aEndpoint,\n                endpoint: this.a2aEndpoint,\n                method: 'POST',\n            };\n        }\n        // Lazy load agent card if not already fetched\n        if (!this.agentCard) {\n            await this.fetchAgentCard();\n        }\n        if (!this.a2aEndpoint) {\n            console.error('[A2AProtocolProvider.getA2AEndpoint] No endpoint available');\n            return null;\n        }\n        // Verify endpoint is absolute before returning\n        if (!this.a2aEndpoint ||\n            (!this.a2aEndpoint.startsWith('http://') && !this.a2aEndpoint.startsWith('https://'))) {\n            console.log(`Warning: A2A endpoint should be an absolute URL (starting with http:// or https://), got: ${this.a2aEndpoint}`);\n        }\n        return {\n            providerId: this.agentCard?.name || 'unknown',\n            url: this.a2aEndpoint,\n            endpoint: this.a2aEndpoint,\n            method: 'POST',\n        };\n    }\n    /**\n     * Check if the agent supports A2A protocol\n     */\n    async supportsA2A() {\n        const card = await this.fetchAgentCard();\n        return card !== null &&\n            card.skills !== undefined &&\n            card.skills.length > 0 &&\n            card.provider?.url !== undefined;\n    }\n    /**\n     * Get available skills from the agent card\n     */\n    async getSkills() {\n        const card = await this.fetchAgentCard();\n        return card?.skills || [];\n    }\n    /**\n     * Get agent capabilities\n     */\n    async getCapabilities() {\n        const card = await this.fetchAgentCard();\n        return card?.capabilities || null;\n    }\n    /**\n     * Create and sign an authentication challenge\n     */\n    async createSignedChallenge(audience) {\n        const agent = this.veramoAgent;\n        if (!agent) {\n            console.warn('No Veramo agent available for authentication');\n            return null;\n        }\n        try {\n            // Get the client's DID\n            const identifiers = await agent.didManagerFind();\n            if (!identifiers || identifiers.length === 0) {\n                // Create a default DID if none exists\n                // Use ethr provider for client DIDs (simpler than agent DIDs)\n                const identifier = await agent.didManagerCreate({\n                    alias: 'default',\n                    provider: 'did:ethr',\n                });\n                this.clientDid = identifier.did;\n            }\n            else {\n                const firstIdentifier = identifiers[0];\n                this.clientDid = firstIdentifier?.did || null;\n            }\n            if (!this.clientDid) {\n                throw new Error('Could not get or create client DID');\n            }\n            // Get the identifier to access its keys\n            const identifier = await agent.didManagerGet({ did: this.clientDid });\n            if (!identifier || !identifier.keys || identifier.keys.length === 0) {\n                throw new Error('No keys available for signing in identifier');\n            }\n            // Use the first available key from the identifier\n            const key = identifier.keys[0];\n            if (!key) {\n                throw new Error('No key available');\n            }\n            this.clientKid = key.kid;\n            // Generate nonce\n            const nonce = crypto.randomUUID();\n            // Create canonical challenge\n            const iat = Date.now();\n            const challenge = [\n                'orgtrust-challenge',\n                `iss=${this.clientDid}`,\n                `aud=${audience}`,\n                `nonce=${nonce}`,\n                `iat=${iat}`,\n            ].join('\\n');\n            // For ethr DIDs, use eth_signMessage algorithm\n            // Extract Ethereum address from the key for direct verification (no DID resolution needed)\n            const isEthrDid = this.clientDid.startsWith('did:ethr:');\n            let algorithm = 'ES256K'; // Default\n            let ethereumAddress = undefined;\n            if (isEthrDid) {\n                // Use eth_signMessage for ethr DIDs - this is what the provider expects\n                algorithm = 'eth_signMessage';\n                // Extract Ethereum address from the key's metadata or derive from public key\n                // For ethr DIDs, the address is in the key's meta.ethereumAddress or can be derived\n                if (key.meta?.ethereumAddress) {\n                    ethereumAddress = key.meta.ethereumAddress;\n                }\n                else if (key.publicKeyHex) {\n                    // Derive address from public key if not in metadata\n                    // This is a simplified approach - in production, use proper key derivation\n                    try {\n                        const { computeAddress } = await __webpack_require__.e(/*! import() */ \"vendor-chunks/ethers\").then(__webpack_require__.bind(__webpack_require__, /*! ethers */ \"(rsc)/../../node_modules/ethers/lib.esm/index.js\"));\n                        const publicKeyBytes = Buffer.from(key.publicKeyHex.replace(/^0x/, ''), 'hex');\n                        // For uncompressed public key (65 bytes), skip first byte\n                        const pubKey = publicKeyBytes.length === 65 ? publicKeyBytes.slice(1) : publicKeyBytes;\n                        ethereumAddress = computeAddress(`0x${pubKey.toString('hex')}`);\n                    }\n                    catch (error) {\n                        console.warn('Could not derive Ethereum address from public key:', error);\n                    }\n                }\n            }\n            else if (key.type === 'Ed25519') {\n                algorithm = 'EdDSA';\n            }\n            else if (key.type === 'Secp256k1') {\n                algorithm = 'ES256K';\n            }\n            const signature = await agent.keyManagerSign({\n                keyRef: key.kid,\n                algorithm: algorithm,\n                data: challenge,\n                encoding: 'utf-8',\n            });\n            // For ethr DIDs, use the DID itself as the kid (or a standard fragment)\n            // Include Ethereum address for direct verification without DID resolution\n            const kid = isEthrDid ? `${this.clientDid}#controllerKey` : key.kid;\n            return {\n                did: this.clientDid,\n                kid,\n                algorithm,\n                challenge,\n                signature,\n                ...(ethereumAddress && { ethereumAddress }), // Include address for direct verification\n            };\n        }\n        catch (error) {\n            console.error('Failed to create signed challenge:', error);\n            return null;\n        }\n    }\n    /**\n     * Send an A2A message to the agent\n     */\n    async sendMessage(request) {\n        console.log('[A2AProtocolProvider.sendMessage] Starting sendMessage');\n        console.log('[A2AProtocolProvider.sendMessage] providerUrl:', this.providerUrl);\n        console.log('[A2AProtocolProvider.sendMessage] request:', JSON.stringify(request, null, 2));\n        // Ensure we have the endpoint\n        const endpointInfo = await this.getA2AEndpoint();\n        console.log('[A2AProtocolProvider.sendMessage] endpointInfo:', JSON.stringify(endpointInfo, null, 2));\n        if (!endpointInfo) {\n            console.error('[A2AProtocolProvider.sendMessage] No endpoint info available');\n            throw new Error('A2A endpoint not available. Fetch agent card first.');\n        }\n        console.log('[A2AProtocolProvider.sendMessage] Constructed url:', endpointInfo.url);\n        console.log('[A2AProtocolProvider.sendMessage] Endpoint method:', endpointInfo.method || 'POST');\n        // Validate endpoint is not a placeholder\n        if (A2AProtocolProvider.isPlaceholderUrl(endpointInfo.url)) {\n            console.error('[A2AProtocolProvider.sendMessage] Endpoint is a placeholder URL');\n            throw new Error(`Invalid A2A url: The agent's A2A url appears to be a placeholder URL (${endpointInfo.url}). ` +\n                `Please update the agent's endpoint to a valid, accessible URL. ` +\n                `The endpoint should point to a real agent provider that can handle A2A protocol messages.`);\n        }\n        // Commented out authentication - allow A2A endpoint to respond without authentication\n        // Authenticate on first message if Veramo agent is available\n        let authChallenge = null;\n        // if (this.veramoAgent && !this.authenticated) {\n        //   console.log('[A2AProtocolProvider.sendMessage] Creating authentication challenge');\n        //   // Use the A2A endpoint as the audience (the exact URL we're sending the request to)\n        //   // This should match what the agent expects for authentication\n        //   const endpointInfo = await this.getA2AEndpoint();\n        //   if (!endpointInfo?.endpoint) {\n        //     throw new Error('A2A endpoint is required for authentication');\n        //   }\n        //   const aud = endpointInfo.endpoint;\n        //   console.log('[A2AProtocolProvider.sendMessage] Using audience for authentication:', aud);\n        //   authChallenge = await this.createSignedChallenge(aud);\n        //   if (authChallenge) {\n        //     this.authenticated = true;\n        //     console.log('[A2AProtocolProvider.sendMessage] Authentication challenge created successfully');\n        //   } else {\n        //     console.warn('[A2AProtocolProvider.sendMessage] Failed to create authentication challenge');\n        //   }\n        // } else {\n        //   console.log('[A2AProtocolProvider.sendMessage] Skipping authentication:', {\n        //     hasVeramoAgent: !!this.veramoAgent,\n        //     authenticated: this.authenticated,\n        //   });\n        // }\n        console.log('[A2AProtocolProvider.sendMessage] Authentication disabled - sending request without auth challenge');\n        // Build request with authentication\n        const authenticatedRequest = {\n            ...request,\n            ...(authChallenge && { auth: authChallenge }),\n        };\n        console.log('[A2AProtocolProvider.sendMessage] Sending request to:', endpointInfo.url);\n        console.log('[A2AProtocolProvider.sendMessage] Request payload:', JSON.stringify(authenticatedRequest, null, 2));\n        try {\n            const response = await fetch(endpointInfo.url, {\n                method: endpointInfo.method || 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                },\n                body: JSON.stringify(authenticatedRequest),\n            });\n            console.log('[A2AProtocolProvider.sendMessage] Response status:', response.status, response.statusText);\n            // Log headers (Headers.entries() may not be available in all environments)\n            const headersObj = {};\n            if (response.headers && typeof response.headers.forEach === 'function') {\n                response.headers.forEach((value, key) => {\n                    headersObj[key] = value;\n                });\n            }\n            console.log('[A2AProtocolProvider.sendMessage] Response headers:', headersObj);\n            if (!response.ok) {\n                let errorText = await response.text();\n                let errorMessage = `A2A request failed: ${response.status} ${response.statusText}`;\n                // Try to parse JSON error response for better error messages\n                try {\n                    const errorJson = JSON.parse(errorText);\n                    if (errorJson.response?.error) {\n                        errorMessage = errorJson.response.error;\n                    }\n                    else if (errorJson.error) {\n                        errorMessage = errorJson.error;\n                    }\n                    else {\n                        errorMessage = `${errorMessage} - ${errorText}`;\n                    }\n                }\n                catch {\n                    // If not JSON, use the raw error text\n                    errorMessage = `${errorMessage} - ${errorText}`;\n                }\n                // Log error but don't throw - return a graceful error response\n                console.warn('[A2AProtocolProvider.sendMessage] Request failed (returning error response):', {\n                    status: response.status,\n                    statusText: response.statusText,\n                    url: endpointInfo.url,\n                    errorMessage,\n                });\n                // Return an error response instead of throwing\n                return {\n                    success: false,\n                    error: errorMessage,\n                };\n            }\n            const data = await response.json();\n            console.log('[A2AProtocolProvider.sendMessage] Response data:', JSON.stringify(data, null, 2));\n            // If authentication failed, reset and throw\n            if (data.success === false && data.error?.includes('authentication')) {\n                this.authenticated = false;\n                console.error('[A2AProtocolProvider.sendMessage] Authentication failed, resetting authenticated flag');\n                throw new Error(data.error || 'Authentication failed');\n            }\n            return data;\n        }\n        catch (error) {\n            console.error('[A2AProtocolProvider.sendMessage] Exception caught:', error);\n            console.error('[A2AProtocolProvider.sendMessage] Error details:', {\n                message: error instanceof Error ? error.message : String(error),\n                stack: error instanceof Error ? error.stack : undefined,\n                url: endpointInfo.url,\n                providerUrl: this.providerUrl,\n            });\n            throw error;\n        }\n    }\n}\n//# sourceMappingURL=a2aProtocolProvider.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BhZ2VudGljLXRydXN0L2NvcmUvZGlzdC9zZXJ2ZXIvbGliL2EyYVByb3RvY29sUHJvdmlkZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSxTQUFTO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzSEFBc0gsWUFBWTtBQUNsSTtBQUNBO0FBQ0E7QUFDQSxxRkFBcUYsWUFBWTtBQUNqRztBQUNBLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsZ0VBQWlCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxXQUFXLEVBQUUsRUFBRTtBQUNqRCw4QkFBOEIsV0FBVyxHQUFHLHNCQUFzQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFIQUFxSCxpQkFBaUI7QUFDdEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxxQkFBcUI7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGVBQWU7QUFDdEMsdUJBQXVCLFNBQVM7QUFDaEMseUJBQXlCLE1BQU07QUFDL0IsdUJBQXVCLElBQUk7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsaUJBQWlCLFFBQVEsbUxBQWdCO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCx1QkFBdUI7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsdUNBQXVDLGVBQWU7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLGlCQUFpQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUdBQXFHLGlCQUFpQjtBQUN0SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMscUJBQXFCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELGlCQUFpQixFQUFFLG9CQUFvQjtBQUNqRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxjQUFjLElBQUksVUFBVTtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxjQUFjLElBQUksVUFBVTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL2JhcmIvYWEvQXNzb2NpYXRlZEFjY291bnRzL25vZGVfbW9kdWxlcy9AYWdlbnRpYy10cnVzdC9jb3JlL2Rpc3Qvc2VydmVyL2xpYi9hMmFQcm90b2NvbFByb3ZpZGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQTJBIFByb3RvY29sIFByb3ZpZGVyIEFQSSBmb3IgQWdlbnRpY1RydXN0IENsaWVudFxuICogSGFuZGxlcyBBZ2VudC10by1BZ2VudCAoQTJBKSBpbnRlcmFjdGlvbnNcbiAqL1xuaW1wb3J0IHsgZmV0Y2hBMkFBZ2VudENhcmQgfSBmcm9tICcuL2EyYUFnZW50Q2FyZCc7XG4vKipcbiAqIEEyQSBQcm90b2NvbCBQcm92aWRlciBBUEkgZm9yIEdyYXBoUUwgb3BlcmF0aW9uc1xuICogVXNlZCBieSBBZ2VudGljVHJ1c3RDbGllbnQgZm9yIGJhY2tlbmQgcXVlcmllc1xuICovXG5leHBvcnQgY2xhc3MgQTJBUHJvdG9jb2xQcm92aWRlckFQSSB7XG4gICAgZ3JhcGhRTENsaWVudDtcbiAgICBjb25zdHJ1Y3RvcihncmFwaFFMQ2xpZW50KSB7XG4gICAgICAgIHRoaXMuZ3JhcGhRTENsaWVudCA9IGdyYXBoUUxDbGllbnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhZ2VudCBwcm92aWRlciBlbmRwb2ludCBmb3IgQTJBIGNvbW11bmljYXRpb24gdmlhIEdyYXBoUUxcbiAgICAgKi9cbiAgICBhc3luYyBnZXRBZ2VudFByb3ZpZGVyKGFnZW50SWQpIHtcbiAgICAgICAgY29uc3QgcXVlcnkgPSBgXHJcbiAgICAgIHF1ZXJ5IEdldEFnZW50UHJvdmlkZXIoJGFnZW50SWQ6IFN0cmluZyEpIHtcclxuICAgICAgICBhZ2VudFByb3ZpZGVyKGFnZW50SWQ6ICRhZ2VudElkKSB7XHJcbiAgICAgICAgICBwcm92aWRlcklkXHJcbiAgICAgICAgICBlbmRwb2ludFxyXG4gICAgICAgICAgYWdlbnROYW1lXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICBgO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHRoaXMuZ3JhcGhRTENsaWVudC5yZXF1ZXN0KHF1ZXJ5LCB7IGFnZW50SWQgfSk7XG4gICAgICAgICAgICByZXR1cm4gZGF0YS5hZ2VudFByb3ZpZGVyO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgLy8gSWYgdGhlIHF1ZXJ5IGZhaWxzLCByZXR1cm4gbnVsbFxuICAgICAgICAgICAgY29uc29sZS53YXJuKCdGYWlsZWQgdG8gZ2V0IGFnZW50IHByb3ZpZGVyIGZyb20gR3JhcGhRTDonLCBlcnJvcik7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kIGFuIEFnZW50LXRvLUFnZW50IChBMkEpIG1lc3NhZ2UgdmlhIEdyYXBoUUxcbiAgICAgKi9cbiAgICBhc3luYyBzZW5kQTJBTWVzc2FnZShyZXF1ZXN0KSB7XG4gICAgICAgIGNvbnN0IG11dGF0aW9uID0gYFxyXG4gICAgICBtdXRhdGlvbiBTZW5kQTJBTWVzc2FnZShcclxuICAgICAgICAkZnJvbUFnZW50SWQ6IFN0cmluZyFcclxuICAgICAgICAkdG9BZ2VudElkOiBTdHJpbmchXHJcbiAgICAgICAgJG1lc3NhZ2U6IFN0cmluZ1xyXG4gICAgICAgICRwYXlsb2FkOiBTdHJpbmdcclxuICAgICAgICAkbWV0YWRhdGE6IFN0cmluZ1xyXG4gICAgICApIHtcclxuICAgICAgICBzZW5kQTJBTWVzc2FnZShcclxuICAgICAgICAgIGZyb21BZ2VudElkOiAkZnJvbUFnZW50SWRcclxuICAgICAgICAgIHRvQWdlbnRJZDogJHRvQWdlbnRJZFxyXG4gICAgICAgICAgbWVzc2FnZTogJG1lc3NhZ2VcclxuICAgICAgICAgIHBheWxvYWQ6ICRwYXlsb2FkXHJcbiAgICAgICAgICBtZXRhZGF0YTogJG1ldGFkYXRhXHJcbiAgICAgICAgKSB7XHJcbiAgICAgICAgICBzdWNjZXNzXHJcbiAgICAgICAgICBtZXNzYWdlSWRcclxuICAgICAgICAgIHJlc3BvbnNlXHJcbiAgICAgICAgICBlcnJvclxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgYDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLmdyYXBoUUxDbGllbnQucmVxdWVzdChtdXRhdGlvbiwge1xuICAgICAgICAgICAgICAgIGZyb21BZ2VudElkOiByZXF1ZXN0LmZyb21BZ2VudElkLFxuICAgICAgICAgICAgICAgIHRvQWdlbnRJZDogcmVxdWVzdC50b0FnZW50SWQsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogcmVxdWVzdC5tZXNzYWdlLFxuICAgICAgICAgICAgICAgIHBheWxvYWQ6IHJlcXVlc3QucGF5bG9hZCA/IEpTT04uc3RyaW5naWZ5KHJlcXVlc3QucGF5bG9hZCkgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgbWV0YWRhdGE6IHJlcXVlc3QubWV0YWRhdGEgPyBKU09OLnN0cmluZ2lmeShyZXF1ZXN0Lm1ldGFkYXRhKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGRhdGEuc2VuZEEyQU1lc3NhZ2U7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAvLyBJZiBtdXRhdGlvbiBmYWlscywgcmV0dXJuIGVycm9yIHJlc3BvbnNlXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdGYWlsZWQgdG8gc2VuZCBBMkEgbWVzc2FnZScsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExpc3QgYXZhaWxhYmxlIGFnZW50IHByb3ZpZGVycyB2aWEgR3JhcGhRTFxuICAgICAqL1xuICAgIGFzeW5jIGxpc3RQcm92aWRlcnMoKSB7XG4gICAgICAgIGNvbnN0IHF1ZXJ5ID0gYFxyXG4gICAgICBxdWVyeSBMaXN0UHJvdmlkZXJzIHtcclxuICAgICAgICBwcm92aWRlcnMge1xyXG4gICAgICAgICAgaWRcclxuICAgICAgICAgIHByb3ZpZGVySWRcclxuICAgICAgICAgIGFnZW50TmFtZVxyXG4gICAgICAgICAgZW5kcG9pbnRcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIGA7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLmdyYXBoUUxDbGllbnQucmVxdWVzdChxdWVyeSk7XG4gICAgICAgIHJldHVybiBkYXRhLnByb3ZpZGVycyB8fCBbXTtcbiAgICB9XG59XG4vKipcbiAqIEEyQSBQcm90b2NvbCBQcm92aWRlciBmb3IgYSBzcGVjaWZpYyBhZ2VudFxuICogSGFuZGxlcyBkaXJlY3QgQTJBIGNvbW11bmljYXRpb24gd2l0aCBhbiBhZ2VudCBwcm92aWRlclxuICovXG5leHBvcnQgY2xhc3MgQTJBUHJvdG9jb2xQcm92aWRlciB7XG4gICAgLy8gVGhlIFVSTCBwcm92aWRlZCBieSB0aGUgY2FsbGVyLiBJbnRlcnByZXRlZCBhcyBhbiBhZ2VudC1jYXJkIFVSTCAoYWdlbnQuanNvbilcbiAgICAvLyBvciBhbnkgVVJMIG9uIHRoZSBzYW1lIG9yaWdpbiAod2Ugd2lsbCBib290c3RyYXAgdG8gLy53ZWxsLWtub3duL2FnZW50Lmpzb24pLlxuICAgIHByb3ZpZGVyVXJsO1xuICAgIGFnZW50Q2FyZCA9IG51bGw7XG4gICAgYTJhRW5kcG9pbnQgPSBudWxsO1xuICAgIHZlcmFtb0FnZW50ID0gbnVsbDtcbiAgICBhdXRoZW50aWNhdGVkID0gZmFsc2U7XG4gICAgY2xpZW50RGlkID0gbnVsbDtcbiAgICBjbGllbnRLaWQgPSBudWxsO1xuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIGFuIGVuZHBvaW50IFVSTCBpcyBhIHBsYWNlaG9sZGVyL2V4YW1wbGUgVVJMXG4gICAgICogTm90ZTogbG9jYWxob3N0IFVSTHMgYXJlIGFsbG93ZWQgZm9yIGRldmVsb3BtZW50LCBvbmx5IGFjdHVhbCBwbGFjZWhvbGRlci9leGFtcGxlIGRvbWFpbnMgYXJlIGZsYWdnZWRcbiAgICAgKi9cbiAgICBzdGF0aWMgaXNQbGFjZWhvbGRlclVybCh1cmwpIHtcbiAgICAgICAgY29uc3QgcGxhY2Vob2xkZXJQYXR0ZXJucyA9IFtcbiAgICAgICAgICAgIC8vIE1hdGNoIGV4YW1wbGUuY29tIGFuZCBpdHMgc3ViZG9tYWlucyAoYWN0dWFsIHBsYWNlaG9sZGVyIGRvbWFpbilcbiAgICAgICAgICAgIC9eaHR0cHM/OlxcL1xcLyh3d3dcXC4pP2V4YW1wbGVcXC5jb20vaSxcbiAgICAgICAgICAgIC8vIE1hdGNoIG90aGVyIGV4YW1wbGUgZG9tYWlucyAoZXhhbXBsZS5vcmcsIGV4YW1wbGUubmV0LCBldGMuKVxuICAgICAgICAgICAgL15odHRwcz86XFwvXFwvZXhhbXBsZVxcLihjb218b3JnfG5ldHxlZHV8Z292KS9pLFxuICAgICAgICAgICAgLy8gTWF0Y2ggVVJMcyBjb250YWluaW5nIFwicGxhY2Vob2xkZXJcIiAoYnV0IG5vdCBsb2NhbGhvc3QpXG4gICAgICAgICAgICAvcGxhY2Vob2xkZXIvaSxcbiAgICAgICAgICAgIC8vIE1hdGNoIFVSTHMgY29udGFpbmluZyBcImV4YW1wbGVcIiBidXQgTk9UIGxvY2FsaG9zdCAodG8gYXZvaWQgZmFsc2UgcG9zaXRpdmVzKVxuICAgICAgICAgICAgLy8gVGhpcyB3aWxsIGNhdGNoIHRoaW5ncyBsaWtlIFwiZXhhbXBsZS5jb21cIiBidXQgbm90IFwibG9jYWxob3N0OjMwMDFcIlxuICAgICAgICAgICAgL2V4YW1wbGUvaSxcbiAgICAgICAgXTtcbiAgICAgICAgLy8gRG9uJ3QgZmxhZyBsb2NhbGhvc3QgVVJMcyAtIHRoZXkncmUgdmFsaWQgZm9yIGRldmVsb3BtZW50XG4gICAgICAgIGlmICgvXmh0dHBzPzpcXC9cXC9sb2NhbGhvc3QvaS50ZXN0KHVybCkgfHwgL15odHRwcz86XFwvXFwvMTI3XFwuMFxcLjBcXC4xL2kudGVzdCh1cmwpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBsYWNlaG9sZGVyUGF0dGVybnMuc29tZShwYXR0ZXJuID0+IHBhdHRlcm4udGVzdCh1cmwpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IGFuIEEyQSBQcm90b2NvbCBQcm92aWRlciBmb3IgYSBzcGVjaWZpYyBhZ2VudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhMmFFbmRwb2ludCAtIFRoZSBhZ2VudCdzIEEyQSBkaXNjb3ZlcnkgVVJMIChhZ2VudC5qc29uKSwgb3IgYW55IFVSTCBvbiB0aGUgYWdlbnQncyBvcmlnaW4uXG4gICAgICogQHBhcmFtIHZlcmFtb0FnZW50IC0gVmVyYW1vIGFnZW50IGZvciBhdXRoZW50aWNhdGlvblxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGEyYUVuZHBvaW50LCB2ZXJhbW9BZ2VudCkge1xuICAgICAgICAvLyBWZXJpZnkgYTJhRW5kcG9pbnQgaXMgYW4gYWJzb2x1dGUgVVJMXG4gICAgICAgIGlmICghYTJhRW5kcG9pbnQuc3RhcnRzV2l0aCgnaHR0cDovLycpICYmICFhMmFFbmRwb2ludC5zdGFydHNXaXRoKCdodHRwczovLycpKSB7XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKGBXYXJuaW5nOiBhMmFFbmRwb2ludCBzaG91bGQgYmUgYW4gYWJzb2x1dGUgVVJMIChzdGFydGluZyB3aXRoIGh0dHA6Ly8gb3IgaHR0cHM6Ly8pLCBnb3Q6ICR7YTJhRW5kcG9pbnR9YCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2hlY2sgaWYgZW5kcG9pbnQgaXMgYSBwbGFjZWhvbGRlci9leGFtcGxlIFVSTFxuICAgICAgICBpZiAoQTJBUHJvdG9jb2xQcm92aWRlci5pc1BsYWNlaG9sZGVyVXJsKGEyYUVuZHBvaW50KSkge1xuICAgICAgICAgICAgLy9jb25zb2xlLndhcm4oYFdhcm5pbmc6IEEyQSBlbmRwb2ludCBhcHBlYXJzIHRvIGJlIGEgcGxhY2Vob2xkZXIgVVJMOiAke2EyYUVuZHBvaW50fS4gVGhpcyBlbmRwb2ludCB3aWxsIG5vdCB3b3JrIGZvciBhY3R1YWwgQTJBIGNvbW11bmljYXRpb24uYCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wcm92aWRlclVybCA9IGEyYUVuZHBvaW50LnJlcGxhY2UoL1xcLyQvLCAnJyk7IC8vIFJlbW92ZSB0cmFpbGluZyBzbGFzaFxuICAgICAgICB0aGlzLnZlcmFtb0FnZW50ID0gdmVyYW1vQWdlbnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZldGNoIGFuZCBjYWNoZSB0aGUgYWdlbnQgZGVzY3JpcHRvciBmcm9tIC8ud2VsbC1rbm93bi9hZ2VudC5qc29uXG4gICAgICovXG4gICAgYXN5bmMgZmV0Y2hBZ2VudENhcmQoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnW0EyQVByb3RvY29sUHJvdmlkZXIuZmV0Y2hBZ2VudENhcmRdIEZldGNoaW5nIGFnZW50IGNhcmQgdXNpbmcgcHJvdmlkZXJVcmw6JywgdGhpcy5wcm92aWRlclVybCk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnW0EyQVByb3RvY29sUHJvdmlkZXIuZmV0Y2hBZ2VudENhcmRdIEJhc2UgcHJvdmlkZXJVcmw6JywgdGhpcy5wcm92aWRlclVybCk7XG4gICAgICAgICAgICBjb25zdCBjYXJkID0gYXdhaXQgZmV0Y2hBMkFBZ2VudENhcmQodGhpcy5wcm92aWRlclVybCk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnW0EyQVByb3RvY29sUHJvdmlkZXIuZmV0Y2hBZ2VudENhcmRdIEFnZW50IGNhcmQgcmVjZWl2ZWQ6JywgSlNPTi5zdHJpbmdpZnkoY2FyZCwgbnVsbCwgMikpO1xuICAgICAgICAgICAgaWYgKGNhcmQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFnZW50Q2FyZCA9IGNhcmQ7XG4gICAgICAgICAgICAgICAgLy8gUHJlZmVyIGV4cGxpY2l0IG1lc3NhZ2UgZW5kcG9pbnQgZnJvbSBhZ2VudCBjYXJkLlxuICAgICAgICAgICAgICAgIC8vIFRoaXMgbXVzdCBiZSBleHBsaWNpdGx5IGRlY2xhcmVkIGJ5IHRoZSBhZ2VudCBjYXJkOyB3ZSBkbyBub3QgZ3Vlc3MuXG4gICAgICAgICAgICAgICAgY29uc3QgYmFzZU9yaWdpbiA9ICgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFVSTCh0aGlzLnByb3ZpZGVyVXJsKS5vcmlnaW4ucmVwbGFjZSgvXFwvJC8sICcnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wcm92aWRlclVybC5yZXBsYWNlKC9cXC8kLywgJycpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBlbmRwb2ludEZyb21TdXBwb3J0ZWRJbnRlcmZhY2VzID0gKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3VwcG9ydGVkSW50ZXJmYWNlcyA9IEFycmF5LmlzQXJyYXkoY2FyZD8uc3VwcG9ydGVkSW50ZXJmYWNlcylcbiAgICAgICAgICAgICAgICAgICAgICAgID8gY2FyZC5zdXBwb3J0ZWRJbnRlcmZhY2VzXG4gICAgICAgICAgICAgICAgICAgICAgICA6IFtdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwaWNrID0gKGJpbmRpbmcpID0+IHN1cHBvcnRlZEludGVyZmFjZXMuZmluZCgoeCkgPT4gU3RyaW5nKHg/LnByb3RvY29sQmluZGluZyB8fCAnJykgPT09IGJpbmRpbmcpPy51cmw7XG4gICAgICAgICAgICAgICAgICAgIC8vIFByZWZlciBKU09OLVJQQyBpZiBhZHZlcnRpc2VkOyBmYWxsIGJhY2sgdG8gSFRUUCtKU09OLlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGljaygnSlNPTlJQQycpID8/IHBpY2soJ0hUVFArSlNPTicpID8/IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9KSgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGVuZHBvaW50RnJvbVByb3ZpZGVyVXJsID0gdHlwZW9mIGNhcmQ/LnByb3ZpZGVyPy51cmwgPT09ICdzdHJpbmcnID8gY2FyZC5wcm92aWRlci51cmwgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgY29uc3QgZW5kcG9pbnRGcm9tRW5kcG9pbnRzQXJyYXkgPSBBcnJheS5pc0FycmF5KGNhcmQuZW5kcG9pbnRzKVxuICAgICAgICAgICAgICAgICAgICA/IGNhcmQuZW5kcG9pbnRzLmZpbmQoKGUpID0+IFN0cmluZyhlPy5uYW1lIHx8ICcnKS50b0xvd2VyQ2FzZSgpID09PSAnYTJhJyk/LnVybCA/P1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FyZC5lbmRwb2ludHMuZmluZCgoZSkgPT4gU3RyaW5nKGU/Lm5hbWUgfHwgJycpLnRvTG93ZXJDYXNlKCkgPT09ICdhMmEnKT8uZW5kcG9pbnRcbiAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgY29uc3QgZW5kcG9pbnRGcm9tRW5kcG9pbnRzT2JqZWN0ID0gY2FyZD8uZW5kcG9pbnRzICYmIHR5cGVvZiBjYXJkLmVuZHBvaW50cyA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkoY2FyZC5lbmRwb2ludHMpXG4gICAgICAgICAgICAgICAgICAgID8gY2FyZC5lbmRwb2ludHMuYTJhXG4gICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGNvbnN0IG5vcm1hbGl6ZUVuZHBvaW50ID0gKHJhdykgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzID0gU3RyaW5nKHJhdyB8fCAnJykudHJpbSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXMpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHMuc3RhcnRzV2l0aCgnaHR0cDovLycpIHx8IHMuc3RhcnRzV2l0aCgnaHR0cHM6Ly8nKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB1ID0gbmV3IFVSTChzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBwcm92aWRlci51cmwgaXMganVzdCBhIGJhcmUgb3JpZ2luIChcIi9cIiksIHRyZWF0IGl0IGFzIG5vdCBhbiBleHBsaWNpdCBtZXNzYWdlIGVuZHBvaW50LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFnZW50cyBzaG91bGQgcHVibGlzaCBhbiBleHBsaWNpdCBtZXNzYWdlIGVuZHBvaW50IChlLmcuIC9hcGkvYTJhKSBpbiBhZ2VudC5qc29uLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdS5wYXRobmFtZSB8fCB1LnBhdGhuYW1lID09PSAnLycgfHwgdS5wYXRobmFtZSA9PT0gJycpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2gge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZhbGwgdGhyb3VnaCBhbmQgc3RpbGwgcmV0dXJuIHRoZSBzdHJpbmcgdHJpbW1lZC5cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzLnJlcGxhY2UoL1xcLyQvLCAnJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHMuc3RhcnRzV2l0aCgnLycpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGAke2Jhc2VPcmlnaW59JHtzfWA7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBgJHtiYXNlT3JpZ2lufS8ke3MucmVwbGFjZSgvXlxcLysvLCAnJyl9YDtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGNvbnN0IHBpY2tlZCA9IG5vcm1hbGl6ZUVuZHBvaW50KGVuZHBvaW50RnJvbVN1cHBvcnRlZEludGVyZmFjZXMpID8/XG4gICAgICAgICAgICAgICAgICAgIG5vcm1hbGl6ZUVuZHBvaW50KGVuZHBvaW50RnJvbVByb3ZpZGVyVXJsKSA/P1xuICAgICAgICAgICAgICAgICAgICBub3JtYWxpemVFbmRwb2ludChlbmRwb2ludEZyb21FbmRwb2ludHNBcnJheSkgPz9cbiAgICAgICAgICAgICAgICAgICAgbm9ybWFsaXplRW5kcG9pbnQoZW5kcG9pbnRGcm9tRW5kcG9pbnRzT2JqZWN0KTtcbiAgICAgICAgICAgICAgICBpZiAocGlja2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdbQTJBUHJvdG9jb2xQcm92aWRlci5mZXRjaEFnZW50Q2FyZF0gVXNpbmcgQTJBIGVuZHBvaW50IGZyb20gYWdlbnQgY2FyZDonLCBwaWNrZWQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmEyYUVuZHBvaW50ID0gcGlja2VkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdbQTJBUHJvdG9jb2xQcm92aWRlci5mZXRjaEFnZW50Q2FyZF0gQWdlbnQgY2FyZCBkaWQgbm90IGRlY2xhcmUgYW4gQTJBIG1lc3NhZ2UgZW5kcG9pbnQuJyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYTJhRW5kcG9pbnQgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBWZXJpZnkgdGhlIGNvbnN0cnVjdGVkIGEyYUVuZHBvaW50IGlzIGFic29sdXRlXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYTJhRW5kcG9pbnQgJiYgIXRoaXMuYTJhRW5kcG9pbnQuc3RhcnRzV2l0aCgnaHR0cDovLycpICYmICF0aGlzLmEyYUVuZHBvaW50LnN0YXJ0c1dpdGgoJ2h0dHBzOi8vJykpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdbQTJBUHJvdG9jb2xQcm92aWRlci5mZXRjaEFnZW50Q2FyZF0gV2FybmluZzogQTJBIGVuZHBvaW50IHNob3VsZCBiZSBhbiBhYnNvbHV0ZSBVUkwgKHN0YXJ0aW5nIHdpdGggaHR0cDovLyBvciBodHRwczovLyksIGdvdDonLCB0aGlzLmEyYUVuZHBvaW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1tBMkFQcm90b2NvbFByb3ZpZGVyLmZldGNoQWdlbnRDYXJkXSBObyBhZ2VudCBjYXJkIHJlY2VpdmVkJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5hMmFFbmRwb2ludCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY2FyZDtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1tBMkFQcm90b2NvbFByb3ZpZGVyLmZldGNoQWdlbnRDYXJkXSBGYWlsZWQgdG8gZmV0Y2ggYWdlbnQgY2FyZDonLCBlcnJvcik7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdbQTJBUHJvdG9jb2xQcm92aWRlci5mZXRjaEFnZW50Q2FyZF0gRXJyb3IgZGV0YWlsczonLCB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZTogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpLFxuICAgICAgICAgICAgICAgIHN0YWNrOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3Iuc3RhY2sgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgcHJvdmlkZXJVcmw6IHRoaXMucHJvdmlkZXJVcmwsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY2FjaGVkIGFnZW50IGNhcmQgKGNhbGwgZmV0Y2hBZ2VudENhcmQgZmlyc3QpXG4gICAgICovXG4gICAgZ2V0QWdlbnRDYXJkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hZ2VudENhcmQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgQTJBIGVuZHBvaW50IFVSTFxuICAgICAqIFRoaXMgd2lsbCBmZXRjaCB0aGUgYWdlbnQgY2FyZCBpZiBub3QgYWxyZWFkeSBjYWNoZWRcbiAgICAgKi9cbiAgICBhc3luYyBnZXRBMkFFbmRwb2ludCgpIHtcbiAgICAgICAgLy8gSWYgd2UgYWxyZWFkeSBoYXZlIGFuIGEyYUVuZHBvaW50IGNvbnN0cnVjdGVkICh3aXRoIHN1YmRvbWFpbiksIHVzZSBpdCBkaXJlY3RseVxuICAgICAgICBpZiAodGhpcy5hMmFFbmRwb2ludCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ1tBMkFQcm90b2NvbFByb3ZpZGVyLmdldEEyQUVuZHBvaW50XSBVc2luZyBjYWNoZWQgZW5kcG9pbnQ6JywgdGhpcy5hMmFFbmRwb2ludCk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHByb3ZpZGVySWQ6IHRoaXMuYWdlbnRDYXJkPy5uYW1lIHx8ICd1bmtub3duJyxcbiAgICAgICAgICAgICAgICB1cmw6IHRoaXMuYTJhRW5kcG9pbnQsXG4gICAgICAgICAgICAgICAgZW5kcG9pbnQ6IHRoaXMuYTJhRW5kcG9pbnQsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIC8vIExhenkgbG9hZCBhZ2VudCBjYXJkIGlmIG5vdCBhbHJlYWR5IGZldGNoZWRcbiAgICAgICAgaWYgKCF0aGlzLmFnZW50Q2FyZCkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5mZXRjaEFnZW50Q2FyZCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5hMmFFbmRwb2ludCkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignW0EyQVByb3RvY29sUHJvdmlkZXIuZ2V0QTJBRW5kcG9pbnRdIE5vIGVuZHBvaW50IGF2YWlsYWJsZScpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVmVyaWZ5IGVuZHBvaW50IGlzIGFic29sdXRlIGJlZm9yZSByZXR1cm5pbmdcbiAgICAgICAgaWYgKCF0aGlzLmEyYUVuZHBvaW50IHx8XG4gICAgICAgICAgICAoIXRoaXMuYTJhRW5kcG9pbnQuc3RhcnRzV2l0aCgnaHR0cDovLycpICYmICF0aGlzLmEyYUVuZHBvaW50LnN0YXJ0c1dpdGgoJ2h0dHBzOi8vJykpKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgV2FybmluZzogQTJBIGVuZHBvaW50IHNob3VsZCBiZSBhbiBhYnNvbHV0ZSBVUkwgKHN0YXJ0aW5nIHdpdGggaHR0cDovLyBvciBodHRwczovLyksIGdvdDogJHt0aGlzLmEyYUVuZHBvaW50fWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwcm92aWRlcklkOiB0aGlzLmFnZW50Q2FyZD8ubmFtZSB8fCAndW5rbm93bicsXG4gICAgICAgICAgICB1cmw6IHRoaXMuYTJhRW5kcG9pbnQsXG4gICAgICAgICAgICBlbmRwb2ludDogdGhpcy5hMmFFbmRwb2ludCxcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0aGUgYWdlbnQgc3VwcG9ydHMgQTJBIHByb3RvY29sXG4gICAgICovXG4gICAgYXN5bmMgc3VwcG9ydHNBMkEoKSB7XG4gICAgICAgIGNvbnN0IGNhcmQgPSBhd2FpdCB0aGlzLmZldGNoQWdlbnRDYXJkKCk7XG4gICAgICAgIHJldHVybiBjYXJkICE9PSBudWxsICYmXG4gICAgICAgICAgICBjYXJkLnNraWxscyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICBjYXJkLnNraWxscy5sZW5ndGggPiAwICYmXG4gICAgICAgICAgICBjYXJkLnByb3ZpZGVyPy51cmwgIT09IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGF2YWlsYWJsZSBza2lsbHMgZnJvbSB0aGUgYWdlbnQgY2FyZFxuICAgICAqL1xuICAgIGFzeW5jIGdldFNraWxscygpIHtcbiAgICAgICAgY29uc3QgY2FyZCA9IGF3YWl0IHRoaXMuZmV0Y2hBZ2VudENhcmQoKTtcbiAgICAgICAgcmV0dXJuIGNhcmQ/LnNraWxscyB8fCBbXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGFnZW50IGNhcGFiaWxpdGllc1xuICAgICAqL1xuICAgIGFzeW5jIGdldENhcGFiaWxpdGllcygpIHtcbiAgICAgICAgY29uc3QgY2FyZCA9IGF3YWl0IHRoaXMuZmV0Y2hBZ2VudENhcmQoKTtcbiAgICAgICAgcmV0dXJuIGNhcmQ/LmNhcGFiaWxpdGllcyB8fCBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYW5kIHNpZ24gYW4gYXV0aGVudGljYXRpb24gY2hhbGxlbmdlXG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlU2lnbmVkQ2hhbGxlbmdlKGF1ZGllbmNlKSB7XG4gICAgICAgIGNvbnN0IGFnZW50ID0gdGhpcy52ZXJhbW9BZ2VudDtcbiAgICAgICAgaWYgKCFhZ2VudCkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdObyBWZXJhbW8gYWdlbnQgYXZhaWxhYmxlIGZvciBhdXRoZW50aWNhdGlvbicpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIEdldCB0aGUgY2xpZW50J3MgRElEXG4gICAgICAgICAgICBjb25zdCBpZGVudGlmaWVycyA9IGF3YWl0IGFnZW50LmRpZE1hbmFnZXJGaW5kKCk7XG4gICAgICAgICAgICBpZiAoIWlkZW50aWZpZXJzIHx8IGlkZW50aWZpZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBhIGRlZmF1bHQgRElEIGlmIG5vbmUgZXhpc3RzXG4gICAgICAgICAgICAgICAgLy8gVXNlIGV0aHIgcHJvdmlkZXIgZm9yIGNsaWVudCBESURzIChzaW1wbGVyIHRoYW4gYWdlbnQgRElEcylcbiAgICAgICAgICAgICAgICBjb25zdCBpZGVudGlmaWVyID0gYXdhaXQgYWdlbnQuZGlkTWFuYWdlckNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIGFsaWFzOiAnZGVmYXVsdCcsXG4gICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyOiAnZGlkOmV0aHInLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuY2xpZW50RGlkID0gaWRlbnRpZmllci5kaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmaXJzdElkZW50aWZpZXIgPSBpZGVudGlmaWVyc1swXTtcbiAgICAgICAgICAgICAgICB0aGlzLmNsaWVudERpZCA9IGZpcnN0SWRlbnRpZmllcj8uZGlkIHx8IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMuY2xpZW50RGlkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgZ2V0IG9yIGNyZWF0ZSBjbGllbnQgRElEJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBHZXQgdGhlIGlkZW50aWZpZXIgdG8gYWNjZXNzIGl0cyBrZXlzXG4gICAgICAgICAgICBjb25zdCBpZGVudGlmaWVyID0gYXdhaXQgYWdlbnQuZGlkTWFuYWdlckdldCh7IGRpZDogdGhpcy5jbGllbnREaWQgfSk7XG4gICAgICAgICAgICBpZiAoIWlkZW50aWZpZXIgfHwgIWlkZW50aWZpZXIua2V5cyB8fCBpZGVudGlmaWVyLmtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBrZXlzIGF2YWlsYWJsZSBmb3Igc2lnbmluZyBpbiBpZGVudGlmaWVyJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBVc2UgdGhlIGZpcnN0IGF2YWlsYWJsZSBrZXkgZnJvbSB0aGUgaWRlbnRpZmllclxuICAgICAgICAgICAgY29uc3Qga2V5ID0gaWRlbnRpZmllci5rZXlzWzBdO1xuICAgICAgICAgICAgaWYgKCFrZXkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGtleSBhdmFpbGFibGUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY2xpZW50S2lkID0ga2V5LmtpZDtcbiAgICAgICAgICAgIC8vIEdlbmVyYXRlIG5vbmNlXG4gICAgICAgICAgICBjb25zdCBub25jZSA9IGNyeXB0by5yYW5kb21VVUlEKCk7XG4gICAgICAgICAgICAvLyBDcmVhdGUgY2Fub25pY2FsIGNoYWxsZW5nZVxuICAgICAgICAgICAgY29uc3QgaWF0ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgIGNvbnN0IGNoYWxsZW5nZSA9IFtcbiAgICAgICAgICAgICAgICAnb3JndHJ1c3QtY2hhbGxlbmdlJyxcbiAgICAgICAgICAgICAgICBgaXNzPSR7dGhpcy5jbGllbnREaWR9YCxcbiAgICAgICAgICAgICAgICBgYXVkPSR7YXVkaWVuY2V9YCxcbiAgICAgICAgICAgICAgICBgbm9uY2U9JHtub25jZX1gLFxuICAgICAgICAgICAgICAgIGBpYXQ9JHtpYXR9YCxcbiAgICAgICAgICAgIF0uam9pbignXFxuJyk7XG4gICAgICAgICAgICAvLyBGb3IgZXRociBESURzLCB1c2UgZXRoX3NpZ25NZXNzYWdlIGFsZ29yaXRobVxuICAgICAgICAgICAgLy8gRXh0cmFjdCBFdGhlcmV1bSBhZGRyZXNzIGZyb20gdGhlIGtleSBmb3IgZGlyZWN0IHZlcmlmaWNhdGlvbiAobm8gRElEIHJlc29sdXRpb24gbmVlZGVkKVxuICAgICAgICAgICAgY29uc3QgaXNFdGhyRGlkID0gdGhpcy5jbGllbnREaWQuc3RhcnRzV2l0aCgnZGlkOmV0aHI6Jyk7XG4gICAgICAgICAgICBsZXQgYWxnb3JpdGhtID0gJ0VTMjU2Syc7IC8vIERlZmF1bHRcbiAgICAgICAgICAgIGxldCBldGhlcmV1bUFkZHJlc3MgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAoaXNFdGhyRGlkKSB7XG4gICAgICAgICAgICAgICAgLy8gVXNlIGV0aF9zaWduTWVzc2FnZSBmb3IgZXRociBESURzIC0gdGhpcyBpcyB3aGF0IHRoZSBwcm92aWRlciBleHBlY3RzXG4gICAgICAgICAgICAgICAgYWxnb3JpdGhtID0gJ2V0aF9zaWduTWVzc2FnZSc7XG4gICAgICAgICAgICAgICAgLy8gRXh0cmFjdCBFdGhlcmV1bSBhZGRyZXNzIGZyb20gdGhlIGtleSdzIG1ldGFkYXRhIG9yIGRlcml2ZSBmcm9tIHB1YmxpYyBrZXlcbiAgICAgICAgICAgICAgICAvLyBGb3IgZXRociBESURzLCB0aGUgYWRkcmVzcyBpcyBpbiB0aGUga2V5J3MgbWV0YS5ldGhlcmV1bUFkZHJlc3Mgb3IgY2FuIGJlIGRlcml2ZWRcbiAgICAgICAgICAgICAgICBpZiAoa2V5Lm1ldGE/LmV0aGVyZXVtQWRkcmVzcykge1xuICAgICAgICAgICAgICAgICAgICBldGhlcmV1bUFkZHJlc3MgPSBrZXkubWV0YS5ldGhlcmV1bUFkZHJlc3M7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGtleS5wdWJsaWNLZXlIZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRGVyaXZlIGFkZHJlc3MgZnJvbSBwdWJsaWMga2V5IGlmIG5vdCBpbiBtZXRhZGF0YVxuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIGEgc2ltcGxpZmllZCBhcHByb2FjaCAtIGluIHByb2R1Y3Rpb24sIHVzZSBwcm9wZXIga2V5IGRlcml2YXRpb25cbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgY29tcHV0ZUFkZHJlc3MgfSA9IGF3YWl0IGltcG9ydCgnZXRoZXJzJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwdWJsaWNLZXlCeXRlcyA9IEJ1ZmZlci5mcm9tKGtleS5wdWJsaWNLZXlIZXgucmVwbGFjZSgvXjB4LywgJycpLCAnaGV4Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGb3IgdW5jb21wcmVzc2VkIHB1YmxpYyBrZXkgKDY1IGJ5dGVzKSwgc2tpcCBmaXJzdCBieXRlXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwdWJLZXkgPSBwdWJsaWNLZXlCeXRlcy5sZW5ndGggPT09IDY1ID8gcHVibGljS2V5Qnl0ZXMuc2xpY2UoMSkgOiBwdWJsaWNLZXlCeXRlcztcbiAgICAgICAgICAgICAgICAgICAgICAgIGV0aGVyZXVtQWRkcmVzcyA9IGNvbXB1dGVBZGRyZXNzKGAweCR7cHViS2V5LnRvU3RyaW5nKCdoZXgnKX1gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignQ291bGQgbm90IGRlcml2ZSBFdGhlcmV1bSBhZGRyZXNzIGZyb20gcHVibGljIGtleTonLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkudHlwZSA9PT0gJ0VkMjU1MTknKSB7XG4gICAgICAgICAgICAgICAgYWxnb3JpdGhtID0gJ0VkRFNBJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleS50eXBlID09PSAnU2VjcDI1NmsxJykge1xuICAgICAgICAgICAgICAgIGFsZ29yaXRobSA9ICdFUzI1NksnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc2lnbmF0dXJlID0gYXdhaXQgYWdlbnQua2V5TWFuYWdlclNpZ24oe1xuICAgICAgICAgICAgICAgIGtleVJlZjoga2V5LmtpZCxcbiAgICAgICAgICAgICAgICBhbGdvcml0aG06IGFsZ29yaXRobSxcbiAgICAgICAgICAgICAgICBkYXRhOiBjaGFsbGVuZ2UsXG4gICAgICAgICAgICAgICAgZW5jb2Rpbmc6ICd1dGYtOCcsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIEZvciBldGhyIERJRHMsIHVzZSB0aGUgRElEIGl0c2VsZiBhcyB0aGUga2lkIChvciBhIHN0YW5kYXJkIGZyYWdtZW50KVxuICAgICAgICAgICAgLy8gSW5jbHVkZSBFdGhlcmV1bSBhZGRyZXNzIGZvciBkaXJlY3QgdmVyaWZpY2F0aW9uIHdpdGhvdXQgRElEIHJlc29sdXRpb25cbiAgICAgICAgICAgIGNvbnN0IGtpZCA9IGlzRXRockRpZCA/IGAke3RoaXMuY2xpZW50RGlkfSNjb250cm9sbGVyS2V5YCA6IGtleS5raWQ7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGRpZDogdGhpcy5jbGllbnREaWQsXG4gICAgICAgICAgICAgICAga2lkLFxuICAgICAgICAgICAgICAgIGFsZ29yaXRobSxcbiAgICAgICAgICAgICAgICBjaGFsbGVuZ2UsXG4gICAgICAgICAgICAgICAgc2lnbmF0dXJlLFxuICAgICAgICAgICAgICAgIC4uLihldGhlcmV1bUFkZHJlc3MgJiYgeyBldGhlcmV1bUFkZHJlc3MgfSksIC8vIEluY2x1ZGUgYWRkcmVzcyBmb3IgZGlyZWN0IHZlcmlmaWNhdGlvblxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBjcmVhdGUgc2lnbmVkIGNoYWxsZW5nZTonLCBlcnJvcik7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kIGFuIEEyQSBtZXNzYWdlIHRvIHRoZSBhZ2VudFxuICAgICAqL1xuICAgIGFzeW5jIHNlbmRNZXNzYWdlKHJlcXVlc3QpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ1tBMkFQcm90b2NvbFByb3ZpZGVyLnNlbmRNZXNzYWdlXSBTdGFydGluZyBzZW5kTWVzc2FnZScpO1xuICAgICAgICBjb25zb2xlLmxvZygnW0EyQVByb3RvY29sUHJvdmlkZXIuc2VuZE1lc3NhZ2VdIHByb3ZpZGVyVXJsOicsIHRoaXMucHJvdmlkZXJVcmwpO1xuICAgICAgICBjb25zb2xlLmxvZygnW0EyQVByb3RvY29sUHJvdmlkZXIuc2VuZE1lc3NhZ2VdIHJlcXVlc3Q6JywgSlNPTi5zdHJpbmdpZnkocmVxdWVzdCwgbnVsbCwgMikpO1xuICAgICAgICAvLyBFbnN1cmUgd2UgaGF2ZSB0aGUgZW5kcG9pbnRcbiAgICAgICAgY29uc3QgZW5kcG9pbnRJbmZvID0gYXdhaXQgdGhpcy5nZXRBMkFFbmRwb2ludCgpO1xuICAgICAgICBjb25zb2xlLmxvZygnW0EyQVByb3RvY29sUHJvdmlkZXIuc2VuZE1lc3NhZ2VdIGVuZHBvaW50SW5mbzonLCBKU09OLnN0cmluZ2lmeShlbmRwb2ludEluZm8sIG51bGwsIDIpKTtcbiAgICAgICAgaWYgKCFlbmRwb2ludEluZm8pIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1tBMkFQcm90b2NvbFByb3ZpZGVyLnNlbmRNZXNzYWdlXSBObyBlbmRwb2ludCBpbmZvIGF2YWlsYWJsZScpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBMkEgZW5kcG9pbnQgbm90IGF2YWlsYWJsZS4gRmV0Y2ggYWdlbnQgY2FyZCBmaXJzdC4nKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zb2xlLmxvZygnW0EyQVByb3RvY29sUHJvdmlkZXIuc2VuZE1lc3NhZ2VdIENvbnN0cnVjdGVkIHVybDonLCBlbmRwb2ludEluZm8udXJsKTtcbiAgICAgICAgY29uc29sZS5sb2coJ1tBMkFQcm90b2NvbFByb3ZpZGVyLnNlbmRNZXNzYWdlXSBFbmRwb2ludCBtZXRob2Q6JywgZW5kcG9pbnRJbmZvLm1ldGhvZCB8fCAnUE9TVCcpO1xuICAgICAgICAvLyBWYWxpZGF0ZSBlbmRwb2ludCBpcyBub3QgYSBwbGFjZWhvbGRlclxuICAgICAgICBpZiAoQTJBUHJvdG9jb2xQcm92aWRlci5pc1BsYWNlaG9sZGVyVXJsKGVuZHBvaW50SW5mby51cmwpKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdbQTJBUHJvdG9jb2xQcm92aWRlci5zZW5kTWVzc2FnZV0gRW5kcG9pbnQgaXMgYSBwbGFjZWhvbGRlciBVUkwnKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBBMkEgdXJsOiBUaGUgYWdlbnQncyBBMkEgdXJsIGFwcGVhcnMgdG8gYmUgYSBwbGFjZWhvbGRlciBVUkwgKCR7ZW5kcG9pbnRJbmZvLnVybH0pLiBgICtcbiAgICAgICAgICAgICAgICBgUGxlYXNlIHVwZGF0ZSB0aGUgYWdlbnQncyBlbmRwb2ludCB0byBhIHZhbGlkLCBhY2Nlc3NpYmxlIFVSTC4gYCArXG4gICAgICAgICAgICAgICAgYFRoZSBlbmRwb2ludCBzaG91bGQgcG9pbnQgdG8gYSByZWFsIGFnZW50IHByb3ZpZGVyIHRoYXQgY2FuIGhhbmRsZSBBMkEgcHJvdG9jb2wgbWVzc2FnZXMuYCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ29tbWVudGVkIG91dCBhdXRoZW50aWNhdGlvbiAtIGFsbG93IEEyQSBlbmRwb2ludCB0byByZXNwb25kIHdpdGhvdXQgYXV0aGVudGljYXRpb25cbiAgICAgICAgLy8gQXV0aGVudGljYXRlIG9uIGZpcnN0IG1lc3NhZ2UgaWYgVmVyYW1vIGFnZW50IGlzIGF2YWlsYWJsZVxuICAgICAgICBsZXQgYXV0aENoYWxsZW5nZSA9IG51bGw7XG4gICAgICAgIC8vIGlmICh0aGlzLnZlcmFtb0FnZW50ICYmICF0aGlzLmF1dGhlbnRpY2F0ZWQpIHtcbiAgICAgICAgLy8gICBjb25zb2xlLmxvZygnW0EyQVByb3RvY29sUHJvdmlkZXIuc2VuZE1lc3NhZ2VdIENyZWF0aW5nIGF1dGhlbnRpY2F0aW9uIGNoYWxsZW5nZScpO1xuICAgICAgICAvLyAgIC8vIFVzZSB0aGUgQTJBIGVuZHBvaW50IGFzIHRoZSBhdWRpZW5jZSAodGhlIGV4YWN0IFVSTCB3ZSdyZSBzZW5kaW5nIHRoZSByZXF1ZXN0IHRvKVxuICAgICAgICAvLyAgIC8vIFRoaXMgc2hvdWxkIG1hdGNoIHdoYXQgdGhlIGFnZW50IGV4cGVjdHMgZm9yIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgIC8vICAgY29uc3QgZW5kcG9pbnRJbmZvID0gYXdhaXQgdGhpcy5nZXRBMkFFbmRwb2ludCgpO1xuICAgICAgICAvLyAgIGlmICghZW5kcG9pbnRJbmZvPy5lbmRwb2ludCkge1xuICAgICAgICAvLyAgICAgdGhyb3cgbmV3IEVycm9yKCdBMkEgZW5kcG9pbnQgaXMgcmVxdWlyZWQgZm9yIGF1dGhlbnRpY2F0aW9uJyk7XG4gICAgICAgIC8vICAgfVxuICAgICAgICAvLyAgIGNvbnN0IGF1ZCA9IGVuZHBvaW50SW5mby5lbmRwb2ludDtcbiAgICAgICAgLy8gICBjb25zb2xlLmxvZygnW0EyQVByb3RvY29sUHJvdmlkZXIuc2VuZE1lc3NhZ2VdIFVzaW5nIGF1ZGllbmNlIGZvciBhdXRoZW50aWNhdGlvbjonLCBhdWQpO1xuICAgICAgICAvLyAgIGF1dGhDaGFsbGVuZ2UgPSBhd2FpdCB0aGlzLmNyZWF0ZVNpZ25lZENoYWxsZW5nZShhdWQpO1xuICAgICAgICAvLyAgIGlmIChhdXRoQ2hhbGxlbmdlKSB7XG4gICAgICAgIC8vICAgICB0aGlzLmF1dGhlbnRpY2F0ZWQgPSB0cnVlO1xuICAgICAgICAvLyAgICAgY29uc29sZS5sb2coJ1tBMkFQcm90b2NvbFByb3ZpZGVyLnNlbmRNZXNzYWdlXSBBdXRoZW50aWNhdGlvbiBjaGFsbGVuZ2UgY3JlYXRlZCBzdWNjZXNzZnVsbHknKTtcbiAgICAgICAgLy8gICB9IGVsc2Uge1xuICAgICAgICAvLyAgICAgY29uc29sZS53YXJuKCdbQTJBUHJvdG9jb2xQcm92aWRlci5zZW5kTWVzc2FnZV0gRmFpbGVkIHRvIGNyZWF0ZSBhdXRoZW50aWNhdGlvbiBjaGFsbGVuZ2UnKTtcbiAgICAgICAgLy8gICB9XG4gICAgICAgIC8vIH0gZWxzZSB7XG4gICAgICAgIC8vICAgY29uc29sZS5sb2coJ1tBMkFQcm90b2NvbFByb3ZpZGVyLnNlbmRNZXNzYWdlXSBTa2lwcGluZyBhdXRoZW50aWNhdGlvbjonLCB7XG4gICAgICAgIC8vICAgICBoYXNWZXJhbW9BZ2VudDogISF0aGlzLnZlcmFtb0FnZW50LFxuICAgICAgICAvLyAgICAgYXV0aGVudGljYXRlZDogdGhpcy5hdXRoZW50aWNhdGVkLFxuICAgICAgICAvLyAgIH0pO1xuICAgICAgICAvLyB9XG4gICAgICAgIGNvbnNvbGUubG9nKCdbQTJBUHJvdG9jb2xQcm92aWRlci5zZW5kTWVzc2FnZV0gQXV0aGVudGljYXRpb24gZGlzYWJsZWQgLSBzZW5kaW5nIHJlcXVlc3Qgd2l0aG91dCBhdXRoIGNoYWxsZW5nZScpO1xuICAgICAgICAvLyBCdWlsZCByZXF1ZXN0IHdpdGggYXV0aGVudGljYXRpb25cbiAgICAgICAgY29uc3QgYXV0aGVudGljYXRlZFJlcXVlc3QgPSB7XG4gICAgICAgICAgICAuLi5yZXF1ZXN0LFxuICAgICAgICAgICAgLi4uKGF1dGhDaGFsbGVuZ2UgJiYgeyBhdXRoOiBhdXRoQ2hhbGxlbmdlIH0pLFxuICAgICAgICB9O1xuICAgICAgICBjb25zb2xlLmxvZygnW0EyQVByb3RvY29sUHJvdmlkZXIuc2VuZE1lc3NhZ2VdIFNlbmRpbmcgcmVxdWVzdCB0bzonLCBlbmRwb2ludEluZm8udXJsKTtcbiAgICAgICAgY29uc29sZS5sb2coJ1tBMkFQcm90b2NvbFByb3ZpZGVyLnNlbmRNZXNzYWdlXSBSZXF1ZXN0IHBheWxvYWQ6JywgSlNPTi5zdHJpbmdpZnkoYXV0aGVudGljYXRlZFJlcXVlc3QsIG51bGwsIDIpKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goZW5kcG9pbnRJbmZvLnVybCwge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogZW5kcG9pbnRJbmZvLm1ldGhvZCB8fCAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYXV0aGVudGljYXRlZFJlcXVlc3QpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnW0EyQVByb3RvY29sUHJvdmlkZXIuc2VuZE1lc3NhZ2VdIFJlc3BvbnNlIHN0YXR1czonLCByZXNwb25zZS5zdGF0dXMsIHJlc3BvbnNlLnN0YXR1c1RleHQpO1xuICAgICAgICAgICAgLy8gTG9nIGhlYWRlcnMgKEhlYWRlcnMuZW50cmllcygpIG1heSBub3QgYmUgYXZhaWxhYmxlIGluIGFsbCBlbnZpcm9ubWVudHMpXG4gICAgICAgICAgICBjb25zdCBoZWFkZXJzT2JqID0ge307XG4gICAgICAgICAgICBpZiAocmVzcG9uc2UuaGVhZGVycyAmJiB0eXBlb2YgcmVzcG9uc2UuaGVhZGVycy5mb3JFYWNoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2UuaGVhZGVycy5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnNPYmpba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc29sZS5sb2coJ1tBMkFQcm90b2NvbFByb3ZpZGVyLnNlbmRNZXNzYWdlXSBSZXNwb25zZSBoZWFkZXJzOicsIGhlYWRlcnNPYmopO1xuICAgICAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgICAgIGxldCBlcnJvclRleHQgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gICAgICAgICAgICAgICAgbGV0IGVycm9yTWVzc2FnZSA9IGBBMkEgcmVxdWVzdCBmYWlsZWQ6ICR7cmVzcG9uc2Uuc3RhdHVzfSAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YDtcbiAgICAgICAgICAgICAgICAvLyBUcnkgdG8gcGFyc2UgSlNPTiBlcnJvciByZXNwb25zZSBmb3IgYmV0dGVyIGVycm9yIG1lc3NhZ2VzXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3JKc29uID0gSlNPTi5wYXJzZShlcnJvclRleHQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3JKc29uLnJlc3BvbnNlPy5lcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JNZXNzYWdlID0gZXJyb3JKc29uLnJlc3BvbnNlLmVycm9yO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGVycm9ySnNvbi5lcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JNZXNzYWdlID0gZXJyb3JKc29uLmVycm9yO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JNZXNzYWdlID0gYCR7ZXJyb3JNZXNzYWdlfSAtICR7ZXJyb3JUZXh0fWA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2gge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiBub3QgSlNPTiwgdXNlIHRoZSByYXcgZXJyb3IgdGV4dFxuICAgICAgICAgICAgICAgICAgICBlcnJvck1lc3NhZ2UgPSBgJHtlcnJvck1lc3NhZ2V9IC0gJHtlcnJvclRleHR9YDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gTG9nIGVycm9yIGJ1dCBkb24ndCB0aHJvdyAtIHJldHVybiBhIGdyYWNlZnVsIGVycm9yIHJlc3BvbnNlXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdbQTJBUHJvdG9jb2xQcm92aWRlci5zZW5kTWVzc2FnZV0gUmVxdWVzdCBmYWlsZWQgKHJldHVybmluZyBlcnJvciByZXNwb25zZSk6Jywge1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzVGV4dDogcmVzcG9uc2Uuc3RhdHVzVGV4dCxcbiAgICAgICAgICAgICAgICAgICAgdXJsOiBlbmRwb2ludEluZm8udXJsLFxuICAgICAgICAgICAgICAgICAgICBlcnJvck1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgLy8gUmV0dXJuIGFuIGVycm9yIHJlc3BvbnNlIGluc3RlYWQgb2YgdGhyb3dpbmdcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yTWVzc2FnZSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdbQTJBUHJvdG9jb2xQcm92aWRlci5zZW5kTWVzc2FnZV0gUmVzcG9uc2UgZGF0YTonLCBKU09OLnN0cmluZ2lmeShkYXRhLCBudWxsLCAyKSk7XG4gICAgICAgICAgICAvLyBJZiBhdXRoZW50aWNhdGlvbiBmYWlsZWQsIHJlc2V0IGFuZCB0aHJvd1xuICAgICAgICAgICAgaWYgKGRhdGEuc3VjY2VzcyA9PT0gZmFsc2UgJiYgZGF0YS5lcnJvcj8uaW5jbHVkZXMoJ2F1dGhlbnRpY2F0aW9uJykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmF1dGhlbnRpY2F0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdbQTJBUHJvdG9jb2xQcm92aWRlci5zZW5kTWVzc2FnZV0gQXV0aGVudGljYXRpb24gZmFpbGVkLCByZXNldHRpbmcgYXV0aGVudGljYXRlZCBmbGFnJyk7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGRhdGEuZXJyb3IgfHwgJ0F1dGhlbnRpY2F0aW9uIGZhaWxlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdbQTJBUHJvdG9jb2xQcm92aWRlci5zZW5kTWVzc2FnZV0gRXhjZXB0aW9uIGNhdWdodDonLCBlcnJvcik7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdbQTJBUHJvdG9jb2xQcm92aWRlci5zZW5kTWVzc2FnZV0gRXJyb3IgZGV0YWlsczonLCB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZTogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpLFxuICAgICAgICAgICAgICAgIHN0YWNrOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3Iuc3RhY2sgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgdXJsOiBlbmRwb2ludEluZm8udXJsLFxuICAgICAgICAgICAgICAgIHByb3ZpZGVyVXJsOiB0aGlzLnByb3ZpZGVyVXJsLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWEyYVByb3RvY29sUHJvdmlkZXIuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@agentic-trust/core/dist/server/lib/a2aProtocolProvider.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@agentic-trust/core/dist/server/lib/accounts.js":
/*!**************************************************************************!*\
  !*** ../../node_modules/@agentic-trust/core/dist/server/lib/accounts.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   extractAgentAccountFromDiscovery: () => (/* binding */ extractAgentAccountFromDiscovery),\n/* harmony export */   getAccountOwner: () => (/* binding */ getAccountOwner),\n/* harmony export */   getAccountOwnerByDidEthr: () => (/* binding */ getAccountOwnerByDidEthr),\n/* harmony export */   getAgentAccountByAgentName: () => (/* binding */ getAgentAccountByAgentName),\n/* harmony export */   getCounterfactualAAAddressByAgentName: () => (/* binding */ getCounterfactualAAAddressByAgentName),\n/* harmony export */   getCounterfactualSmartAccountAddressByAgentName: () => (/* binding */ getCounterfactualSmartAccountAddressByAgentName),\n/* harmony export */   parseEthrDid: () => (/* binding */ parseEthrDid)\n/* harmony export */ });\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! viem */ \"(rsc)/../../node_modules/viem/_esm/clients/createPublicClient.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! viem */ \"(rsc)/../../node_modules/viem/_esm/clients/transports/http.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! viem */ \"(rsc)/../../node_modules/viem/_esm/utils/hash/keccak256.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! viem */ \"(rsc)/../../node_modules/viem/_esm/utils/encoding/toHex.js\");\n/* harmony import */ var _metamask_smart_accounts_kit__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @metamask/smart-accounts-kit */ \"(rsc)/../../node_modules/@metamask/smart-accounts-kit/dist/chunk-7MRTROLV.mjs\");\n/* harmony import */ var _metamask_smart_accounts_kit__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @metamask/smart-accounts-kit */ \"(rsc)/../../node_modules/@metamask/smart-accounts-kit/dist/index.mjs\");\n/* harmony import */ var _singletons_identityClient__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../singletons/identityClient */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/singletons/identityClient.js\");\n/* harmony import */ var _singletons_ensClient__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../singletons/ensClient */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/singletons/ensClient.js\");\n/* harmony import */ var _singletons_discoveryClient__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../singletons/discoveryClient */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/singletons/discoveryClient.js\");\n/* harmony import */ var _userApps_adminApp__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../userApps/adminApp */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/userApps/adminApp.js\");\n/* harmony import */ var _chainConfig__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./chainConfig */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/lib/chainConfig.js\");\n/**\n * Server-side utilities for account operations\n *\n * This module provides utilities for:\n * - Getting account owners (EOA) from account addresses\n * - Resolving agent account addresses by name\n * - Computing counterfactual AA addresses (private key mode only)\n * - Parsing PKH DIDs\n */\n\n\n\n\n\n\n\n// ============================================================================\n// PKH DID Parsing\n// ============================================================================\nconst ETHR_DID_PREFIX = 'did:ethr:';\n/**\n * Parse a did:ethr DID to extract chainId and account address\n *\n * @param didEthr - The did:ethr string (e.g., \"did:ethr:11155111:0x1234...\" or \"did:ethr:0x1234...\")\n * @returns Parsed DID with chainId and account address\n */\nfunction parseEthrDid(didEthr) {\n    const decoded = decodeURIComponent((didEthr || '').trim());\n    if (!decoded) {\n        throw new Error('Missing ETHR DID parameter');\n    }\n    if (!decoded.startsWith(ETHR_DID_PREFIX)) {\n        throw new Error(`Invalid ETHR DID format: ${decoded}. Expected format: did:ethr:chainId:account or did:ethr:account`);\n    }\n    const segments = decoded.split(':');\n    const accountCandidate = segments[segments.length - 1];\n    if (!accountCandidate || !accountCandidate.startsWith('0x')) {\n        throw new Error('ETHR DID is missing account component');\n    }\n    // Try to find chainId in the remaining segments\n    const remaining = segments.slice(2, -1);\n    let chainId = _chainConfig__WEBPACK_IMPORTED_MODULE_4__.DEFAULT_CHAIN_ID;\n    for (let i = remaining.length - 1; i >= 0; i -= 1) {\n        const value = remaining[i];\n        if (value && /^\\d+$/.test(value)) {\n            const parsed = Number.parseInt(value, 10);\n            if (Number.isFinite(parsed) && parsed > 0) {\n                chainId = parsed;\n                break;\n            }\n        }\n    }\n    // Validate chain ID is supported (or use default) - but allow any numeric chainId\n    if (!(0,_chainConfig__WEBPACK_IMPORTED_MODULE_4__.isChainSupported)(chainId)) {\n        console.warn(`Chain ID ${chainId} is not in supported list, but will attempt to use it`);\n        // Note: We still allow unsupported chainIds since getIdentityRegistryClient may support them\n    }\n    // Validate account address\n    if (accountCandidate.length !== 42 || !/^0x[a-fA-F0-9]{40}$/.test(accountCandidate)) {\n        throw new Error('Invalid account address in ETHR DID');\n    }\n    return {\n        chainId,\n        account: accountCandidate,\n    };\n}\n// ============================================================================\n// Account Owner Resolution\n// ============================================================================\n/**\n * Get the owner (EOA) of an account address using did:ethr format\n *\n * @param didEthr - The did:ethr string (e.g., \"did:ethr:11155111:0x1234...\")\n * @returns The owner address (EOA) or null if not found or error\n */\nasync function getAccountOwnerByDidEthr(didEthr) {\n    try {\n        const { chainId, account } = parseEthrDid(didEthr);\n        const identityClient = await (0,_singletons_identityClient__WEBPACK_IMPORTED_MODULE_0__.getIdentityRegistryClient)(chainId);\n        return await identityClient.getAccountOwner(account);\n    }\n    catch (error) {\n        console.error('Error getting account owner by DID ETHR:', error);\n        return null;\n    }\n}\n/**\n * Get the owner (EOA) of an account address\n *\n * @param accountAddress - The account address (smart account or contract)\n * @param chainId - Chain ID where the account is deployed (defaults to DEFAULT_CHAIN_ID)\n * @returns The owner address (EOA) or null if not found or error\n */\nasync function getAccountOwner(accountAddress, chainId) {\n    try {\n        const targetChainId = chainId || _chainConfig__WEBPACK_IMPORTED_MODULE_4__.DEFAULT_CHAIN_ID;\n        const identityClient = await (0,_singletons_identityClient__WEBPACK_IMPORTED_MODULE_0__.getIdentityRegistryClient)(targetChainId);\n        return await identityClient.getAccountOwner(accountAddress);\n    }\n    catch (error) {\n        console.error('Error getting account owner:', error);\n        return null;\n    }\n}\nconst ZERO_ADDRESS = '0x0000000000000000000000000000000000000000';\nfunction isValidAddress(value) {\n    return (typeof value === 'string' &&\n        value.startsWith('0x') &&\n        value.length === 42 &&\n        value.toLowerCase() !== ZERO_ADDRESS);\n}\nfunction extractAgentAccountFromDiscovery(agent) {\n    if (!agent || typeof agent !== 'object') {\n        return null;\n    }\n    const record = agent;\n    // New discovery schema prefers explicit EOA for the agent account.\n    const eoaAccount = record.eoaAgentAccount;\n    if (isValidAddress(eoaAccount)) {\n        return eoaAccount;\n    }\n    const directAccount = record.agentAccount;\n    if (isValidAddress(directAccount)) {\n        return directAccount;\n    }\n    // `agentAccount` is stored as \"{chainId}:{0x...}\" in the discovery schema.\n    if (typeof directAccount === 'string' && directAccount.includes(':')) {\n        const maybeAccount = directAccount.split(':').pop();\n        if (isValidAddress(maybeAccount)) {\n            return maybeAccount;\n        }\n    }\n    const rawJson = record.rawJson;\n    if (typeof rawJson === 'string' && rawJson.trim().length > 0) {\n        try {\n            const parsed = JSON.parse(rawJson);\n            const rawAccount = parsed.agentAccount ||\n                (parsed.agent && typeof parsed.agent === 'object'\n                    ? parsed.agent.account\n                    : undefined) ||\n                parsed.account;\n            if (isValidAddress(rawAccount)) {\n                return rawAccount;\n            }\n        }\n        catch (error) {\n            console.warn('Failed to parse discovery agent rawJson:', error);\n        }\n    }\n    return null;\n}\n/**\n * Resolve the agent account address using ENS. Falls back to deterministic indication when not found.\n */\nasync function getAgentAccountByAgentName(agentName) {\n    const trimmed = agentName?.trim();\n    if (!trimmed) {\n        return {\n            account: null,\n            method: null,\n        };\n    }\n    try {\n        const ensClient = await (0,_singletons_ensClient__WEBPACK_IMPORTED_MODULE_1__.getENSClient)();\n        if (!ensClient) {\n            return {\n                account: null,\n                method: null,\n            };\n        }\n        const ensRegistryAddress = ensClient?.ensRegistryAddress;\n        if (!isValidAddress(ensRegistryAddress)) {\n            return {\n                account: null,\n                method: null,\n            };\n        }\n        try {\n            const { account } = await ensClient.getAgentIdentityByName(trimmed);\n            if (isValidAddress(account)) {\n                return {\n                    account,\n                    method: 'ens-identity',\n                };\n            }\n        }\n        catch (ensError) {\n            console.warn('ENS identity resolution failed:', ensError);\n        }\n        try {\n            const directAccount = await ensClient.getAgentAccountByName(trimmed);\n            if (isValidAddress(directAccount)) {\n                return {\n                    account: directAccount,\n                    method: 'ens-direct',\n                };\n            }\n        }\n        catch (ensError) {\n            console.warn('ENS direct resolution failed:', ensError);\n        }\n        try {\n            const discoveryClient = await (0,_singletons_discoveryClient__WEBPACK_IMPORTED_MODULE_2__.getDiscoveryClient)();\n            if (discoveryClient) {\n                try {\n                    const agent = await discoveryClient.getAgentByName(trimmed);\n                    const account = extractAgentAccountFromDiscovery(agent);\n                    if (isValidAddress(account)) {\n                        return {\n                            account,\n                            method: 'discovery',\n                        };\n                    }\n                }\n                catch (discoveryError) {\n                    console.warn('Discovery client lookup failed:', discoveryError);\n                }\n            }\n        }\n        catch (discoveryInitError) {\n            console.warn('Failed to initialize discovery client for account lookup:', discoveryInitError);\n        }\n        return {\n            account: null,\n            method: 'deterministic',\n        };\n    }\n    catch (error) {\n        console.error('Error resolving agent account by name:', error);\n        return {\n            account: null,\n            method: null,\n        };\n    }\n}\n// ============================================================================\n// Counterfactual AA Address Computation (Private Key Mode)\n// ============================================================================\n/**\n * Get the counterfactual AA address for an agent name (server-side computation with private key)\n *\n * This function computes the AA address using the AdminApp's private key.\n * It should only be used when the server has a private key configured (private key mode).\n *\n * @param agentName - The agent name\n * @param chainId - Chain ID (defaults to DEFAULT_CHAIN_ID)\n * @returns The counterfactual AA address\n */\nasync function getCounterfactualSmartAccountAddressByAgentName(agentName, chainId) {\n    if (!agentName || agentName.trim().length === 0) {\n        throw new Error('agentName is required');\n    }\n    const targetChainId = chainId || _chainConfig__WEBPACK_IMPORTED_MODULE_4__.DEFAULT_CHAIN_ID;\n    const adminApp = await (0,_userApps_adminApp__WEBPACK_IMPORTED_MODULE_3__.getAdminApp)(undefined, targetChainId);\n    if (!adminApp) {\n        throw new Error('AdminApp not initialized. Private key mode is required for server-side counterfactual address computation.');\n    }\n    // Check hasPrivateKey first - this is the primary check\n    if (!adminApp.hasPrivateKey) {\n        throw new Error('AdminApp does not have a private key. Private key mode is required for server-side counterfactual address computation. ' +\n            'Set AGENTIC_TRUST_ADMIN_PRIVATE_KEY environment variable.');\n    }\n    if (!adminApp.address) {\n        throw new Error('AdminApp address is not available');\n    }\n    // Verify that we have either walletClient or account (required for signing)\n    // Even if hasPrivateKey is true, we need to ensure the signer is available\n    if (!adminApp.walletClient && !adminApp.account) {\n        throw new Error('AdminApp does not have a signer (walletClient or account). ' +\n            'Private key mode is required, but AdminApp was initialized without a signer. ' +\n            'This may indicate that AGENTIC_TRUST_ADMIN_PRIVATE_KEY was not properly loaded from the environment.');\n    }\n    const chain = (0,_chainConfig__WEBPACK_IMPORTED_MODULE_4__.getChainById)(targetChainId);\n    const rpcUrl = (0,_chainConfig__WEBPACK_IMPORTED_MODULE_4__.getChainRpcUrl)(targetChainId);\n    if (!rpcUrl) {\n        throw new Error(`Missing RPC URL for chain ${targetChainId}. Configure AGENTIC_TRUST_RPC_URL_{CHAIN} environment variable.`);\n    }\n    // Use existing publicClient if available, else create an HTTP client\n    const publicClient = adminApp.publicClient ||\n        (0,viem__WEBPACK_IMPORTED_MODULE_5__.createPublicClient)({ chain: chain, transport: (0,viem__WEBPACK_IMPORTED_MODULE_6__.http)(rpcUrl) });\n    const salt = (0,viem__WEBPACK_IMPORTED_MODULE_7__.keccak256)((0,viem__WEBPACK_IMPORTED_MODULE_8__.stringToHex)(agentName));\n    // Create signer object - must have either walletClient or account\n    // toMetaMaskSmartAccount expects signer to have either walletClient or account, not both\n    // Prefer walletClient over account if both are available\n    // Important: Both walletClient and account can be truthy but we only want one in the signer\n    const signer = adminApp.walletClient\n        ? { walletClient: adminApp.walletClient }\n        : { account: adminApp.account }; // Non-null assertion is safe because we check above\n    const clientConfig = {\n        client: publicClient,\n        implementation: _metamask_smart_accounts_kit__WEBPACK_IMPORTED_MODULE_9__.Implementation.Hybrid,\n        // Use signer (server-side) instead of signer (client-side)\n        signer,\n        deployParams: [adminApp.address, [], [], []],\n        deploySalt: salt,\n    };\n    const accountClient = await (0,_metamask_smart_accounts_kit__WEBPACK_IMPORTED_MODULE_10__.toMetaMaskSmartAccount)(clientConfig);\n    return accountClient.address;\n}\n/**\n * @deprecated Use getCounterfactualSmartAccountAddressByAgentName\n */\nasync function getCounterfactualAAAddressByAgentName(agentName, chainId) {\n    return getCounterfactualSmartAccountAddressByAgentName(agentName, chainId);\n}\n//# sourceMappingURL=accounts.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BhZ2VudGljLXRydXN0L2NvcmUvZGlzdC9zZXJ2ZXIvbGliL2FjY291bnRzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUN3RTtBQUNjO0FBQ2I7QUFDbEI7QUFDWTtBQUNoQjtBQUM4QztBQUNqRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxRQUFRO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsMERBQWdCO0FBQ2xDLHVDQUF1QyxRQUFRO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyw4REFBZ0I7QUFDekIsaUNBQWlDLFNBQVM7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELEdBQUc7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsZ0JBQWdCLG1CQUFtQjtBQUNuQyxxQ0FBcUMscUZBQXlCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EseUNBQXlDLDBEQUFnQjtBQUN6RCxxQ0FBcUMscUZBQXlCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLFFBQVEsRUFBRSxNQUFNO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLG1FQUFZO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsVUFBVTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLCtFQUFrQjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQywwREFBZ0I7QUFDckQsMkJBQTJCLCtEQUFXO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiwwREFBWTtBQUM5QixtQkFBbUIsNERBQWM7QUFDakM7QUFDQSxxREFBcUQsY0FBYyxtQ0FBbUMsT0FBTztBQUM3RztBQUNBO0FBQ0E7QUFDQSxRQUFRLHdEQUFrQixHQUFHLHlCQUF5QiwwQ0FBSSxVQUFVO0FBQ3BFLGlCQUFpQiwrQ0FBUyxDQUFDLGlEQUFXO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1osWUFBWSw2QkFBNkI7QUFDekM7QUFDQTtBQUNBLHdCQUF3Qix3RUFBYztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHFGQUFzQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL2JhcmIvYWEvQXNzb2NpYXRlZEFjY291bnRzL25vZGVfbW9kdWxlcy9AYWdlbnRpYy10cnVzdC9jb3JlL2Rpc3Qvc2VydmVyL2xpYi9hY2NvdW50cy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFNlcnZlci1zaWRlIHV0aWxpdGllcyBmb3IgYWNjb3VudCBvcGVyYXRpb25zXG4gKlxuICogVGhpcyBtb2R1bGUgcHJvdmlkZXMgdXRpbGl0aWVzIGZvcjpcbiAqIC0gR2V0dGluZyBhY2NvdW50IG93bmVycyAoRU9BKSBmcm9tIGFjY291bnQgYWRkcmVzc2VzXG4gKiAtIFJlc29sdmluZyBhZ2VudCBhY2NvdW50IGFkZHJlc3NlcyBieSBuYW1lXG4gKiAtIENvbXB1dGluZyBjb3VudGVyZmFjdHVhbCBBQSBhZGRyZXNzZXMgKHByaXZhdGUga2V5IG1vZGUgb25seSlcbiAqIC0gUGFyc2luZyBQS0ggRElEc1xuICovXG5pbXBvcnQgeyBrZWNjYWsyNTYsIHN0cmluZ1RvSGV4LCBjcmVhdGVQdWJsaWNDbGllbnQsIGh0dHAgfSBmcm9tICd2aWVtJztcbmltcG9ydCB7IEltcGxlbWVudGF0aW9uLCB0b01ldGFNYXNrU21hcnRBY2NvdW50IH0gZnJvbSAnQG1ldGFtYXNrL3NtYXJ0LWFjY291bnRzLWtpdCc7XG5pbXBvcnQgeyBnZXRJZGVudGl0eVJlZ2lzdHJ5Q2xpZW50IH0gZnJvbSAnLi4vc2luZ2xldG9ucy9pZGVudGl0eUNsaWVudCc7XG5pbXBvcnQgeyBnZXRFTlNDbGllbnQgfSBmcm9tICcuLi9zaW5nbGV0b25zL2Vuc0NsaWVudCc7XG5pbXBvcnQgeyBnZXREaXNjb3ZlcnlDbGllbnQgfSBmcm9tICcuLi9zaW5nbGV0b25zL2Rpc2NvdmVyeUNsaWVudCc7XG5pbXBvcnQgeyBnZXRBZG1pbkFwcCB9IGZyb20gJy4uL3VzZXJBcHBzL2FkbWluQXBwJztcbmltcG9ydCB7IERFRkFVTFRfQ0hBSU5fSUQsIGlzQ2hhaW5TdXBwb3J0ZWQsIGdldENoYWluQnlJZCwgZ2V0Q2hhaW5ScGNVcmwgfSBmcm9tICcuL2NoYWluQ29uZmlnJztcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIFBLSCBESUQgUGFyc2luZ1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuY29uc3QgRVRIUl9ESURfUFJFRklYID0gJ2RpZDpldGhyOic7XG4vKipcbiAqIFBhcnNlIGEgZGlkOmV0aHIgRElEIHRvIGV4dHJhY3QgY2hhaW5JZCBhbmQgYWNjb3VudCBhZGRyZXNzXG4gKlxuICogQHBhcmFtIGRpZEV0aHIgLSBUaGUgZGlkOmV0aHIgc3RyaW5nIChlLmcuLCBcImRpZDpldGhyOjExMTU1MTExOjB4MTIzNC4uLlwiIG9yIFwiZGlkOmV0aHI6MHgxMjM0Li4uXCIpXG4gKiBAcmV0dXJucyBQYXJzZWQgRElEIHdpdGggY2hhaW5JZCBhbmQgYWNjb3VudCBhZGRyZXNzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUV0aHJEaWQoZGlkRXRocikge1xuICAgIGNvbnN0IGRlY29kZWQgPSBkZWNvZGVVUklDb21wb25lbnQoKGRpZEV0aHIgfHwgJycpLnRyaW0oKSk7XG4gICAgaWYgKCFkZWNvZGVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBFVEhSIERJRCBwYXJhbWV0ZXInKTtcbiAgICB9XG4gICAgaWYgKCFkZWNvZGVkLnN0YXJ0c1dpdGgoRVRIUl9ESURfUFJFRklYKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgRVRIUiBESUQgZm9ybWF0OiAke2RlY29kZWR9LiBFeHBlY3RlZCBmb3JtYXQ6IGRpZDpldGhyOmNoYWluSWQ6YWNjb3VudCBvciBkaWQ6ZXRocjphY2NvdW50YCk7XG4gICAgfVxuICAgIGNvbnN0IHNlZ21lbnRzID0gZGVjb2RlZC5zcGxpdCgnOicpO1xuICAgIGNvbnN0IGFjY291bnRDYW5kaWRhdGUgPSBzZWdtZW50c1tzZWdtZW50cy5sZW5ndGggLSAxXTtcbiAgICBpZiAoIWFjY291bnRDYW5kaWRhdGUgfHwgIWFjY291bnRDYW5kaWRhdGUuc3RhcnRzV2l0aCgnMHgnKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VUSFIgRElEIGlzIG1pc3NpbmcgYWNjb3VudCBjb21wb25lbnQnKTtcbiAgICB9XG4gICAgLy8gVHJ5IHRvIGZpbmQgY2hhaW5JZCBpbiB0aGUgcmVtYWluaW5nIHNlZ21lbnRzXG4gICAgY29uc3QgcmVtYWluaW5nID0gc2VnbWVudHMuc2xpY2UoMiwgLTEpO1xuICAgIGxldCBjaGFpbklkID0gREVGQVVMVF9DSEFJTl9JRDtcbiAgICBmb3IgKGxldCBpID0gcmVtYWluaW5nLmxlbmd0aCAtIDE7IGkgPj0gMDsgaSAtPSAxKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gcmVtYWluaW5nW2ldO1xuICAgICAgICBpZiAodmFsdWUgJiYgL15cXGQrJC8udGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZCA9IE51bWJlci5wYXJzZUludCh2YWx1ZSwgMTApO1xuICAgICAgICAgICAgaWYgKE51bWJlci5pc0Zpbml0ZShwYXJzZWQpICYmIHBhcnNlZCA+IDApIHtcbiAgICAgICAgICAgICAgICBjaGFpbklkID0gcGFyc2VkO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFZhbGlkYXRlIGNoYWluIElEIGlzIHN1cHBvcnRlZCAob3IgdXNlIGRlZmF1bHQpIC0gYnV0IGFsbG93IGFueSBudW1lcmljIGNoYWluSWRcbiAgICBpZiAoIWlzQ2hhaW5TdXBwb3J0ZWQoY2hhaW5JZCkpIHtcbiAgICAgICAgY29uc29sZS53YXJuKGBDaGFpbiBJRCAke2NoYWluSWR9IGlzIG5vdCBpbiBzdXBwb3J0ZWQgbGlzdCwgYnV0IHdpbGwgYXR0ZW1wdCB0byB1c2UgaXRgKTtcbiAgICAgICAgLy8gTm90ZTogV2Ugc3RpbGwgYWxsb3cgdW5zdXBwb3J0ZWQgY2hhaW5JZHMgc2luY2UgZ2V0SWRlbnRpdHlSZWdpc3RyeUNsaWVudCBtYXkgc3VwcG9ydCB0aGVtXG4gICAgfVxuICAgIC8vIFZhbGlkYXRlIGFjY291bnQgYWRkcmVzc1xuICAgIGlmIChhY2NvdW50Q2FuZGlkYXRlLmxlbmd0aCAhPT0gNDIgfHwgIS9eMHhbYS1mQS1GMC05XXs0MH0kLy50ZXN0KGFjY291bnRDYW5kaWRhdGUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhY2NvdW50IGFkZHJlc3MgaW4gRVRIUiBESUQnKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY2hhaW5JZCxcbiAgICAgICAgYWNjb3VudDogYWNjb3VudENhbmRpZGF0ZSxcbiAgICB9O1xufVxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gQWNjb3VudCBPd25lciBSZXNvbHV0aW9uXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vKipcbiAqIEdldCB0aGUgb3duZXIgKEVPQSkgb2YgYW4gYWNjb3VudCBhZGRyZXNzIHVzaW5nIGRpZDpldGhyIGZvcm1hdFxuICpcbiAqIEBwYXJhbSBkaWRFdGhyIC0gVGhlIGRpZDpldGhyIHN0cmluZyAoZS5nLiwgXCJkaWQ6ZXRocjoxMTE1NTExMToweDEyMzQuLi5cIilcbiAqIEByZXR1cm5zIFRoZSBvd25lciBhZGRyZXNzIChFT0EpIG9yIG51bGwgaWYgbm90IGZvdW5kIG9yIGVycm9yXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRBY2NvdW50T3duZXJCeURpZEV0aHIoZGlkRXRocikge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHsgY2hhaW5JZCwgYWNjb3VudCB9ID0gcGFyc2VFdGhyRGlkKGRpZEV0aHIpO1xuICAgICAgICBjb25zdCBpZGVudGl0eUNsaWVudCA9IGF3YWl0IGdldElkZW50aXR5UmVnaXN0cnlDbGllbnQoY2hhaW5JZCk7XG4gICAgICAgIHJldHVybiBhd2FpdCBpZGVudGl0eUNsaWVudC5nZXRBY2NvdW50T3duZXIoYWNjb3VudCk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBnZXR0aW5nIGFjY291bnQgb3duZXIgYnkgRElEIEVUSFI6JywgZXJyb3IpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG4vKipcbiAqIEdldCB0aGUgb3duZXIgKEVPQSkgb2YgYW4gYWNjb3VudCBhZGRyZXNzXG4gKlxuICogQHBhcmFtIGFjY291bnRBZGRyZXNzIC0gVGhlIGFjY291bnQgYWRkcmVzcyAoc21hcnQgYWNjb3VudCBvciBjb250cmFjdClcbiAqIEBwYXJhbSBjaGFpbklkIC0gQ2hhaW4gSUQgd2hlcmUgdGhlIGFjY291bnQgaXMgZGVwbG95ZWQgKGRlZmF1bHRzIHRvIERFRkFVTFRfQ0hBSU5fSUQpXG4gKiBAcmV0dXJucyBUaGUgb3duZXIgYWRkcmVzcyAoRU9BKSBvciBudWxsIGlmIG5vdCBmb3VuZCBvciBlcnJvclxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0QWNjb3VudE93bmVyKGFjY291bnRBZGRyZXNzLCBjaGFpbklkKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgdGFyZ2V0Q2hhaW5JZCA9IGNoYWluSWQgfHwgREVGQVVMVF9DSEFJTl9JRDtcbiAgICAgICAgY29uc3QgaWRlbnRpdHlDbGllbnQgPSBhd2FpdCBnZXRJZGVudGl0eVJlZ2lzdHJ5Q2xpZW50KHRhcmdldENoYWluSWQpO1xuICAgICAgICByZXR1cm4gYXdhaXQgaWRlbnRpdHlDbGllbnQuZ2V0QWNjb3VudE93bmVyKGFjY291bnRBZGRyZXNzKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGdldHRpbmcgYWNjb3VudCBvd25lcjonLCBlcnJvcik7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cbmNvbnN0IFpFUk9fQUREUkVTUyA9ICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnO1xuZnVuY3Rpb24gaXNWYWxpZEFkZHJlc3ModmFsdWUpIHtcbiAgICByZXR1cm4gKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgdmFsdWUuc3RhcnRzV2l0aCgnMHgnKSAmJlxuICAgICAgICB2YWx1ZS5sZW5ndGggPT09IDQyICYmXG4gICAgICAgIHZhbHVlLnRvTG93ZXJDYXNlKCkgIT09IFpFUk9fQUREUkVTUyk7XG59XG5leHBvcnQgZnVuY3Rpb24gZXh0cmFjdEFnZW50QWNjb3VudEZyb21EaXNjb3ZlcnkoYWdlbnQpIHtcbiAgICBpZiAoIWFnZW50IHx8IHR5cGVvZiBhZ2VudCAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHJlY29yZCA9IGFnZW50O1xuICAgIC8vIE5ldyBkaXNjb3Zlcnkgc2NoZW1hIHByZWZlcnMgZXhwbGljaXQgRU9BIGZvciB0aGUgYWdlbnQgYWNjb3VudC5cbiAgICBjb25zdCBlb2FBY2NvdW50ID0gcmVjb3JkLmVvYUFnZW50QWNjb3VudDtcbiAgICBpZiAoaXNWYWxpZEFkZHJlc3MoZW9hQWNjb3VudCkpIHtcbiAgICAgICAgcmV0dXJuIGVvYUFjY291bnQ7XG4gICAgfVxuICAgIGNvbnN0IGRpcmVjdEFjY291bnQgPSByZWNvcmQuYWdlbnRBY2NvdW50O1xuICAgIGlmIChpc1ZhbGlkQWRkcmVzcyhkaXJlY3RBY2NvdW50KSkge1xuICAgICAgICByZXR1cm4gZGlyZWN0QWNjb3VudDtcbiAgICB9XG4gICAgLy8gYGFnZW50QWNjb3VudGAgaXMgc3RvcmVkIGFzIFwie2NoYWluSWR9OnsweC4uLn1cIiBpbiB0aGUgZGlzY292ZXJ5IHNjaGVtYS5cbiAgICBpZiAodHlwZW9mIGRpcmVjdEFjY291bnQgPT09ICdzdHJpbmcnICYmIGRpcmVjdEFjY291bnQuaW5jbHVkZXMoJzonKSkge1xuICAgICAgICBjb25zdCBtYXliZUFjY291bnQgPSBkaXJlY3RBY2NvdW50LnNwbGl0KCc6JykucG9wKCk7XG4gICAgICAgIGlmIChpc1ZhbGlkQWRkcmVzcyhtYXliZUFjY291bnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gbWF5YmVBY2NvdW50O1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHJhd0pzb24gPSByZWNvcmQucmF3SnNvbjtcbiAgICBpZiAodHlwZW9mIHJhd0pzb24gPT09ICdzdHJpbmcnICYmIHJhd0pzb24udHJpbSgpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZCA9IEpTT04ucGFyc2UocmF3SnNvbik7XG4gICAgICAgICAgICBjb25zdCByYXdBY2NvdW50ID0gcGFyc2VkLmFnZW50QWNjb3VudCB8fFxuICAgICAgICAgICAgICAgIChwYXJzZWQuYWdlbnQgJiYgdHlwZW9mIHBhcnNlZC5hZ2VudCA9PT0gJ29iamVjdCdcbiAgICAgICAgICAgICAgICAgICAgPyBwYXJzZWQuYWdlbnQuYWNjb3VudFxuICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCkgfHxcbiAgICAgICAgICAgICAgICBwYXJzZWQuYWNjb3VudDtcbiAgICAgICAgICAgIGlmIChpc1ZhbGlkQWRkcmVzcyhyYXdBY2NvdW50KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiByYXdBY2NvdW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdGYWlsZWQgdG8gcGFyc2UgZGlzY292ZXJ5IGFnZW50IHJhd0pzb246JywgZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuLyoqXG4gKiBSZXNvbHZlIHRoZSBhZ2VudCBhY2NvdW50IGFkZHJlc3MgdXNpbmcgRU5TLiBGYWxscyBiYWNrIHRvIGRldGVybWluaXN0aWMgaW5kaWNhdGlvbiB3aGVuIG5vdCBmb3VuZC5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEFnZW50QWNjb3VudEJ5QWdlbnROYW1lKGFnZW50TmFtZSkge1xuICAgIGNvbnN0IHRyaW1tZWQgPSBhZ2VudE5hbWU/LnRyaW0oKTtcbiAgICBpZiAoIXRyaW1tZWQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFjY291bnQ6IG51bGwsXG4gICAgICAgICAgICBtZXRob2Q6IG51bGwsXG4gICAgICAgIH07XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGVuc0NsaWVudCA9IGF3YWl0IGdldEVOU0NsaWVudCgpO1xuICAgICAgICBpZiAoIWVuc0NsaWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBhY2NvdW50OiBudWxsLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogbnVsbCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZW5zUmVnaXN0cnlBZGRyZXNzID0gZW5zQ2xpZW50Py5lbnNSZWdpc3RyeUFkZHJlc3M7XG4gICAgICAgIGlmICghaXNWYWxpZEFkZHJlc3MoZW5zUmVnaXN0cnlBZGRyZXNzKSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBhY2NvdW50OiBudWxsLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogbnVsbCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHsgYWNjb3VudCB9ID0gYXdhaXQgZW5zQ2xpZW50LmdldEFnZW50SWRlbnRpdHlCeU5hbWUodHJpbW1lZCk7XG4gICAgICAgICAgICBpZiAoaXNWYWxpZEFkZHJlc3MoYWNjb3VudCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBhY2NvdW50LFxuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6ICdlbnMtaWRlbnRpdHknLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVuc0Vycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ0VOUyBpZGVudGl0eSByZXNvbHV0aW9uIGZhaWxlZDonLCBlbnNFcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGRpcmVjdEFjY291bnQgPSBhd2FpdCBlbnNDbGllbnQuZ2V0QWdlbnRBY2NvdW50QnlOYW1lKHRyaW1tZWQpO1xuICAgICAgICAgICAgaWYgKGlzVmFsaWRBZGRyZXNzKGRpcmVjdEFjY291bnQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgYWNjb3VudDogZGlyZWN0QWNjb3VudCxcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAnZW5zLWRpcmVjdCcsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZW5zRXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignRU5TIGRpcmVjdCByZXNvbHV0aW9uIGZhaWxlZDonLCBlbnNFcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGRpc2NvdmVyeUNsaWVudCA9IGF3YWl0IGdldERpc2NvdmVyeUNsaWVudCgpO1xuICAgICAgICAgICAgaWYgKGRpc2NvdmVyeUNsaWVudCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFnZW50ID0gYXdhaXQgZGlzY292ZXJ5Q2xpZW50LmdldEFnZW50QnlOYW1lKHRyaW1tZWQpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhY2NvdW50ID0gZXh0cmFjdEFnZW50QWNjb3VudEZyb21EaXNjb3ZlcnkoYWdlbnQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNWYWxpZEFkZHJlc3MoYWNjb3VudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWNjb3VudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRob2Q6ICdkaXNjb3ZlcnknLFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZGlzY292ZXJ5RXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdEaXNjb3ZlcnkgY2xpZW50IGxvb2t1cCBmYWlsZWQ6JywgZGlzY292ZXJ5RXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZGlzY292ZXJ5SW5pdEVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ0ZhaWxlZCB0byBpbml0aWFsaXplIGRpc2NvdmVyeSBjbGllbnQgZm9yIGFjY291bnQgbG9va3VwOicsIGRpc2NvdmVyeUluaXRFcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFjY291bnQ6IG51bGwsXG4gICAgICAgICAgICBtZXRob2Q6ICdkZXRlcm1pbmlzdGljJyxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHJlc29sdmluZyBhZ2VudCBhY2NvdW50IGJ5IG5hbWU6JywgZXJyb3IpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYWNjb3VudDogbnVsbCxcbiAgICAgICAgICAgIG1ldGhvZDogbnVsbCxcbiAgICAgICAgfTtcbiAgICB9XG59XG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBDb3VudGVyZmFjdHVhbCBBQSBBZGRyZXNzIENvbXB1dGF0aW9uIChQcml2YXRlIEtleSBNb2RlKVxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLyoqXG4gKiBHZXQgdGhlIGNvdW50ZXJmYWN0dWFsIEFBIGFkZHJlc3MgZm9yIGFuIGFnZW50IG5hbWUgKHNlcnZlci1zaWRlIGNvbXB1dGF0aW9uIHdpdGggcHJpdmF0ZSBrZXkpXG4gKlxuICogVGhpcyBmdW5jdGlvbiBjb21wdXRlcyB0aGUgQUEgYWRkcmVzcyB1c2luZyB0aGUgQWRtaW5BcHAncyBwcml2YXRlIGtleS5cbiAqIEl0IHNob3VsZCBvbmx5IGJlIHVzZWQgd2hlbiB0aGUgc2VydmVyIGhhcyBhIHByaXZhdGUga2V5IGNvbmZpZ3VyZWQgKHByaXZhdGUga2V5IG1vZGUpLlxuICpcbiAqIEBwYXJhbSBhZ2VudE5hbWUgLSBUaGUgYWdlbnQgbmFtZVxuICogQHBhcmFtIGNoYWluSWQgLSBDaGFpbiBJRCAoZGVmYXVsdHMgdG8gREVGQVVMVF9DSEFJTl9JRClcbiAqIEByZXR1cm5zIFRoZSBjb3VudGVyZmFjdHVhbCBBQSBhZGRyZXNzXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRDb3VudGVyZmFjdHVhbFNtYXJ0QWNjb3VudEFkZHJlc3NCeUFnZW50TmFtZShhZ2VudE5hbWUsIGNoYWluSWQpIHtcbiAgICBpZiAoIWFnZW50TmFtZSB8fCBhZ2VudE5hbWUudHJpbSgpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FnZW50TmFtZSBpcyByZXF1aXJlZCcpO1xuICAgIH1cbiAgICBjb25zdCB0YXJnZXRDaGFpbklkID0gY2hhaW5JZCB8fCBERUZBVUxUX0NIQUlOX0lEO1xuICAgIGNvbnN0IGFkbWluQXBwID0gYXdhaXQgZ2V0QWRtaW5BcHAodW5kZWZpbmVkLCB0YXJnZXRDaGFpbklkKTtcbiAgICBpZiAoIWFkbWluQXBwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQWRtaW5BcHAgbm90IGluaXRpYWxpemVkLiBQcml2YXRlIGtleSBtb2RlIGlzIHJlcXVpcmVkIGZvciBzZXJ2ZXItc2lkZSBjb3VudGVyZmFjdHVhbCBhZGRyZXNzIGNvbXB1dGF0aW9uLicpO1xuICAgIH1cbiAgICAvLyBDaGVjayBoYXNQcml2YXRlS2V5IGZpcnN0IC0gdGhpcyBpcyB0aGUgcHJpbWFyeSBjaGVja1xuICAgIGlmICghYWRtaW5BcHAuaGFzUHJpdmF0ZUtleSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FkbWluQXBwIGRvZXMgbm90IGhhdmUgYSBwcml2YXRlIGtleS4gUHJpdmF0ZSBrZXkgbW9kZSBpcyByZXF1aXJlZCBmb3Igc2VydmVyLXNpZGUgY291bnRlcmZhY3R1YWwgYWRkcmVzcyBjb21wdXRhdGlvbi4gJyArXG4gICAgICAgICAgICAnU2V0IEFHRU5USUNfVFJVU1RfQURNSU5fUFJJVkFURV9LRVkgZW52aXJvbm1lbnQgdmFyaWFibGUuJyk7XG4gICAgfVxuICAgIGlmICghYWRtaW5BcHAuYWRkcmVzcykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FkbWluQXBwIGFkZHJlc3MgaXMgbm90IGF2YWlsYWJsZScpO1xuICAgIH1cbiAgICAvLyBWZXJpZnkgdGhhdCB3ZSBoYXZlIGVpdGhlciB3YWxsZXRDbGllbnQgb3IgYWNjb3VudCAocmVxdWlyZWQgZm9yIHNpZ25pbmcpXG4gICAgLy8gRXZlbiBpZiBoYXNQcml2YXRlS2V5IGlzIHRydWUsIHdlIG5lZWQgdG8gZW5zdXJlIHRoZSBzaWduZXIgaXMgYXZhaWxhYmxlXG4gICAgaWYgKCFhZG1pbkFwcC53YWxsZXRDbGllbnQgJiYgIWFkbWluQXBwLmFjY291bnQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBZG1pbkFwcCBkb2VzIG5vdCBoYXZlIGEgc2lnbmVyICh3YWxsZXRDbGllbnQgb3IgYWNjb3VudCkuICcgK1xuICAgICAgICAgICAgJ1ByaXZhdGUga2V5IG1vZGUgaXMgcmVxdWlyZWQsIGJ1dCBBZG1pbkFwcCB3YXMgaW5pdGlhbGl6ZWQgd2l0aG91dCBhIHNpZ25lci4gJyArXG4gICAgICAgICAgICAnVGhpcyBtYXkgaW5kaWNhdGUgdGhhdCBBR0VOVElDX1RSVVNUX0FETUlOX1BSSVZBVEVfS0VZIHdhcyBub3QgcHJvcGVybHkgbG9hZGVkIGZyb20gdGhlIGVudmlyb25tZW50LicpO1xuICAgIH1cbiAgICBjb25zdCBjaGFpbiA9IGdldENoYWluQnlJZCh0YXJnZXRDaGFpbklkKTtcbiAgICBjb25zdCBycGNVcmwgPSBnZXRDaGFpblJwY1VybCh0YXJnZXRDaGFpbklkKTtcbiAgICBpZiAoIXJwY1VybCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE1pc3NpbmcgUlBDIFVSTCBmb3IgY2hhaW4gJHt0YXJnZXRDaGFpbklkfS4gQ29uZmlndXJlIEFHRU5USUNfVFJVU1RfUlBDX1VSTF97Q0hBSU59IGVudmlyb25tZW50IHZhcmlhYmxlLmApO1xuICAgIH1cbiAgICAvLyBVc2UgZXhpc3RpbmcgcHVibGljQ2xpZW50IGlmIGF2YWlsYWJsZSwgZWxzZSBjcmVhdGUgYW4gSFRUUCBjbGllbnRcbiAgICBjb25zdCBwdWJsaWNDbGllbnQgPSBhZG1pbkFwcC5wdWJsaWNDbGllbnQgfHxcbiAgICAgICAgY3JlYXRlUHVibGljQ2xpZW50KHsgY2hhaW46IGNoYWluLCB0cmFuc3BvcnQ6IGh0dHAocnBjVXJsKSB9KTtcbiAgICBjb25zdCBzYWx0ID0ga2VjY2FrMjU2KHN0cmluZ1RvSGV4KGFnZW50TmFtZSkpO1xuICAgIC8vIENyZWF0ZSBzaWduZXIgb2JqZWN0IC0gbXVzdCBoYXZlIGVpdGhlciB3YWxsZXRDbGllbnQgb3IgYWNjb3VudFxuICAgIC8vIHRvTWV0YU1hc2tTbWFydEFjY291bnQgZXhwZWN0cyBzaWduZXIgdG8gaGF2ZSBlaXRoZXIgd2FsbGV0Q2xpZW50IG9yIGFjY291bnQsIG5vdCBib3RoXG4gICAgLy8gUHJlZmVyIHdhbGxldENsaWVudCBvdmVyIGFjY291bnQgaWYgYm90aCBhcmUgYXZhaWxhYmxlXG4gICAgLy8gSW1wb3J0YW50OiBCb3RoIHdhbGxldENsaWVudCBhbmQgYWNjb3VudCBjYW4gYmUgdHJ1dGh5IGJ1dCB3ZSBvbmx5IHdhbnQgb25lIGluIHRoZSBzaWduZXJcbiAgICBjb25zdCBzaWduZXIgPSBhZG1pbkFwcC53YWxsZXRDbGllbnRcbiAgICAgICAgPyB7IHdhbGxldENsaWVudDogYWRtaW5BcHAud2FsbGV0Q2xpZW50IH1cbiAgICAgICAgOiB7IGFjY291bnQ6IGFkbWluQXBwLmFjY291bnQgfTsgLy8gTm9uLW51bGwgYXNzZXJ0aW9uIGlzIHNhZmUgYmVjYXVzZSB3ZSBjaGVjayBhYm92ZVxuICAgIGNvbnN0IGNsaWVudENvbmZpZyA9IHtcbiAgICAgICAgY2xpZW50OiBwdWJsaWNDbGllbnQsXG4gICAgICAgIGltcGxlbWVudGF0aW9uOiBJbXBsZW1lbnRhdGlvbi5IeWJyaWQsXG4gICAgICAgIC8vIFVzZSBzaWduZXIgKHNlcnZlci1zaWRlKSBpbnN0ZWFkIG9mIHNpZ25lciAoY2xpZW50LXNpZGUpXG4gICAgICAgIHNpZ25lcixcbiAgICAgICAgZGVwbG95UGFyYW1zOiBbYWRtaW5BcHAuYWRkcmVzcywgW10sIFtdLCBbXV0sXG4gICAgICAgIGRlcGxveVNhbHQ6IHNhbHQsXG4gICAgfTtcbiAgICBjb25zdCBhY2NvdW50Q2xpZW50ID0gYXdhaXQgdG9NZXRhTWFza1NtYXJ0QWNjb3VudChjbGllbnRDb25maWcpO1xuICAgIHJldHVybiBhY2NvdW50Q2xpZW50LmFkZHJlc3M7XG59XG4vKipcbiAqIEBkZXByZWNhdGVkIFVzZSBnZXRDb3VudGVyZmFjdHVhbFNtYXJ0QWNjb3VudEFkZHJlc3NCeUFnZW50TmFtZVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0Q291bnRlcmZhY3R1YWxBQUFkZHJlc3NCeUFnZW50TmFtZShhZ2VudE5hbWUsIGNoYWluSWQpIHtcbiAgICByZXR1cm4gZ2V0Q291bnRlcmZhY3R1YWxTbWFydEFjY291bnRBZGRyZXNzQnlBZ2VudE5hbWUoYWdlbnROYW1lLCBjaGFpbklkKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFjY291bnRzLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@agentic-trust/core/dist/server/lib/accounts.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@agentic-trust/core/dist/server/lib/agent.js":
/*!***********************************************************************!*\
  !*** ../../node_modules/@agentic-trust/core/dist/server/lib/agent.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Agent: () => (/* binding */ Agent),\n/* harmony export */   buildAgentDetail: () => (/* binding */ buildAgentDetail),\n/* harmony export */   loadAgentDetail: () => (/* binding */ loadAgentDetail)\n/* harmony export */ });\n/* harmony import */ var _a2aProtocolProvider__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./a2aProtocolProvider */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/lib/a2aProtocolProvider.js\");\n/* harmony import */ var _agentic_trust_8004_ext_sdk__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @agentic-trust/8004-ext-sdk */ \"(rsc)/../../node_modules/@agentic-trust/8004-ext-sdk/dist/index.js\");\n/* harmony import */ var _userApps_providerApp__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../userApps/providerApp */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/userApps/providerApp.js\");\n/* harmony import */ var _singletons_reputationClient__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../singletons/reputationClient */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/singletons/reputationClient.js\");\n/* harmony import */ var _ipfs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ipfs */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/lib/ipfs.js\");\n/* harmony import */ var _singletons_identityClient__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../singletons/identityClient */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/singletons/identityClient.js\");\n/* harmony import */ var _singletons_discoveryClient__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../singletons/discoveryClient */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/singletons/discoveryClient.js\");\n/* harmony import */ var _chainConfig__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./chainConfig */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/lib/chainConfig.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ethers */ \"(rsc)/../../node_modules/ethers/lib.esm/crypto/keccak.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ethers */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/utf8.js\");\n/**\n * Agent class\n *\n * Represents a discovered agent with protocol support (A2A, MCP, etc.)\n * Abstracts protocol details so clients can interact with agents without\n * knowing the underlying protocol implementation.\n */\n\n\n\n\n\n\n\n\n\n/**\n * Agent class - represents a discovered agent with protocol support\n */\nclass Agent {\n    data;\n    client;\n    a2aProvider = null;\n    agentCard = null;\n    endpoint = null;\n    initialized = false;\n    sessionPackage = null;\n    constructor(data, client) {\n        this.data = data;\n        this.client = client;\n        // Auto-initialize if agent has an a2aEndpoint\n        if (this.data.a2aEndpoint) {\n            this.initialize();\n        }\n    }\n    /**\n     * Get agent ID\n     */\n    get agentId() {\n        const { agentId } = this.data;\n        if (typeof agentId === 'number') {\n            return agentId;\n        }\n        if (typeof agentId === 'string') {\n            const parsed = Number(agentId);\n            return Number.isFinite(parsed) ? parsed : undefined;\n        }\n        return undefined;\n    }\n    /**\n     * Get agent name\n     */\n    get agentName() {\n        return this.data.agentName;\n    }\n    /**\n     * Get agent account address\n     */\n    get agentAccount() {\n        const account = this.data.agentAccount;\n        if (typeof account === 'string' && account.trim().length > 0) {\n            return account;\n        }\n        const legacyAddress = this.data.agentAddress;\n        if (typeof legacyAddress === 'string' && legacyAddress.trim().length > 0) {\n            return legacyAddress;\n        }\n        return undefined;\n    }\n    /**\n     * Backwards-compatible alias for agentAccount\n     */\n    get agentAddress() {\n        return this.agentAccount;\n    }\n    /**\n     * Get agent identity owner account (stored as \"{chainId}:{0x...}\")\n     */\n    get agentIdentityOwnerAccount() {\n        const owner = this.data.agentIdentityOwnerAccount;\n        if (typeof owner === 'string' && owner.trim().length > 0) {\n            return owner;\n        }\n        return undefined;\n    }\n    /**\n     * Get identity DID (e.g. did:8004)\n     */\n    get didIdentity() {\n        const value = this.data.didIdentity;\n        if (value === null) {\n            return null;\n        }\n        if (typeof value === 'string' && value.trim().length > 0) {\n            return value.trim();\n        }\n        return undefined;\n    }\n    /**\n     * Get account DID (e.g. did:ethr)\n     */\n    get didAccount() {\n        const value = this.data.didAccount;\n        if (value === null) {\n            return null;\n        }\n        if (typeof value === 'string' && value.trim().length > 0) {\n            return value.trim();\n        }\n        return undefined;\n    }\n    /**\n     * Get name DID (e.g. did:ens)\n     */\n    get didName() {\n        const value = this.data.didName;\n        if (value === null) {\n            return null;\n        }\n        if (typeof value === 'string' && value.trim().length > 0) {\n            return value.trim();\n        }\n        return undefined;\n    }\n    /**\n     * Get validation pending count\n     */\n    get validationPendingCount() {\n        const value = this.data.validationPendingCount;\n        if (typeof value === 'number') {\n            return value;\n        }\n        return undefined;\n    }\n    /**\n     * Get validation completed count\n     */\n    get validationCompletedCount() {\n        const value = this.data.validationCompletedCount;\n        if (typeof value === 'number') {\n            return value;\n        }\n        return undefined;\n    }\n    /**\n     * Get validation requested count\n     */\n    get validationRequestedCount() {\n        const value = this.data.validationRequestedCount;\n        if (typeof value === 'number') {\n            return value;\n        }\n        return undefined;\n    }\n    /**\n     * Get feedback count\n     */\n    get feedbackCount() {\n        const value = this.data.feedbackCount;\n        if (typeof value === 'number') {\n            return value;\n        }\n        return undefined;\n    }\n    /**\n     * Get feedback average score\n     */\n    get feedbackAverageScore() {\n        const value = this.data.feedbackAverageScore;\n        if (typeof value === 'number') {\n            return value;\n        }\n        return undefined;\n    }\n    /**\n     * Get A2A endpoint URL\n     */\n    get a2aEndpoint() {\n        return typeof this.data.a2aEndpoint === 'string'\n            ? this.data.a2aEndpoint\n            : undefined;\n    }\n    initialize() {\n        if (this.initialized) {\n            return;\n        }\n        if (!this.data.a2aEndpoint) {\n            return; // No endpoint, agent cannot be initialized\n        }\n        // Get Veramo agent from the client\n        const veramoAgent = this.client.veramo.getAgent();\n        // Use the explicitly-defined A2A endpoint (no hostname/path rewriting).\n        const a2aEndpointUrl = this.data.a2aEndpoint;\n        // Create A2A Protocol Provider for this agent\n        // This does NOT fetch the agent card - card is fetched lazily when needed\n        this.a2aProvider = new _a2aProtocolProvider__WEBPACK_IMPORTED_MODULE_0__.A2AProtocolProvider(a2aEndpointUrl, veramoAgent);\n        this.initialized = true;\n    }\n    isInitialized() {\n        return this.initialized;\n    }\n    async fetchCard() {\n        if (!this.a2aProvider) {\n            throw new Error('Agent not initialized. Call initialize(client) first.');\n        }\n        // Lazy load: only fetch if not already cached\n        if (!this.agentCard) {\n            this.agentCard = await this.a2aProvider.fetchAgentCard();\n        }\n        return this.agentCard;\n    }\n    getCard() {\n        return this.agentCard;\n    }\n    async getSkills() {\n        const card = await this.fetchCard(); // Lazy load\n        return card?.skills || [];\n    }\n    async getCapabilities() {\n        const card = await this.fetchCard(); // Lazy load\n        return card?.capabilities || null;\n    }\n    async supportsProtocol() {\n        if (!this.a2aProvider) {\n            return false;\n        }\n        const card = await this.fetchCard();\n        return card !== null &&\n            card.skills !== undefined &&\n            card.skills.length > 0 &&\n            card.url !== undefined;\n    }\n    async getEndpoint() {\n        if (!this.a2aProvider) {\n            throw new Error('Agent not initialized. Call initialize(client) first.');\n        }\n        if (!this.endpoint) {\n            const endpointInfo = await this.a2aProvider.getA2AEndpoint();\n            if (endpointInfo) {\n                this.endpoint = {\n                    providerId: endpointInfo.providerId,\n                    url: endpointInfo.url,\n                    method: endpointInfo.method,\n                };\n            }\n        }\n        return this.endpoint;\n    }\n    /**\n     * Send a message to the agent\n     */\n    async sendMessage(request) {\n        console.log('[Agent.sendMessage] Starting sendMessage');\n        console.log('[Agent.sendMessage] Agent data:', {\n            agentId: this.data.agentId,\n            chainId: this.data.chainId,\n            agentName: this.data.agentName,\n            a2aEndpoint: this.data.a2aEndpoint,\n            initialized: this.initialized,\n            hasA2aProvider: !!this.a2aProvider,\n        });\n        if (!this.a2aProvider) {\n            console.error('[Agent.sendMessage] A2A provider not initialized');\n            throw new Error('Agent not initialized. Call initialize(client) first.');\n        }\n        // Check if agent has a valid A2A endpoint\n        console.log('[Agent.sendMessage] Agent a2aEndpoint:', this.data.a2aEndpoint);\n        if (!this.data.a2aEndpoint) {\n            console.error('[Agent.sendMessage] Agent does not have an A2A endpoint configured');\n            throw new Error('Agent does not have an A2A endpoint configured. ' +\n                'The agent must have a valid A2A endpoint URL to receive messages.');\n        }\n        console.log('[Agent.sendMessage] Request:', JSON.stringify(request, null, 2));\n        // Build A2A request format\n        const endpointInfo = await this.getEndpoint();\n        if (!endpointInfo) {\n            throw new Error('Agent endpoint not available 1');\n        }\n        // Extract fromAgentId from metadata/payload if provided, otherwise fallback to payload.agentId, finally 'client'\n        const payloadFromAgentId = request.payload?.fromAgentId;\n        const fallbackAgentId = request.payload?.agentId;\n        const fromAgentId = request.metadata?.fromAgentId ||\n            payloadFromAgentId ||\n            fallbackAgentId ||\n            'client';\n        const a2aRequest = {\n            fromAgentId: fromAgentId,\n            toAgentId: endpointInfo.providerId,\n            message: request.message,\n            payload: request.payload,\n            metadata: request.metadata,\n            skillId: request.skillId,\n        };\n        console.log('[Agent.sendMessage] Sending A2A request:', JSON.stringify(a2aRequest, null, 2));\n        const response = await this.a2aProvider.sendMessage(a2aRequest);\n        console.log('[Agent.sendMessage] Received A2A response:', JSON.stringify(response, null, 2));\n        return response;\n    }\n    /**\n     * Verify the agent by sending an authentication challenge\n     * Creates a signed challenge and sends it to the agent's endpoint\n     * This will force a fresh authentication challenge even if already authenticated\n     * @returns true if verification passed, false otherwise\n     */\n    async verify() {\n        if (!this.a2aProvider) {\n            throw new Error('Agent not initialized. Call initialize(client) first.');\n        }\n        try {\n            // Get endpoint info\n            const endpointInfo = await this.getEndpoint();\n            if (!endpointInfo) {\n                throw new Error('Agent endpoint not available 2');\n            }\n            // Get agent card to determine audience for challenge\n            const agentCard = await this.fetchCard();\n            if (!agentCard?.provider?.url) {\n                throw new Error('Agent card URL is required for verification');\n            }\n            // Reset authentication state to force a fresh challenge\n            // Access the private authenticated flag via type assertion\n            this.a2aProvider.authenticated = false;\n            // Create a signed challenge using the A2A protocol provider\n            // We'll send a minimal message with auth to test verification\n            const a2aRequest = {\n                fromAgentId: 'client',\n                toAgentId: endpointInfo.providerId,\n                message: 'verify', // Minimal message for verification\n                payload: {},\n            };\n            // The sendMessage will automatically create and include auth challenge\n            // since we reset authenticated to false\n            const response = await this.a2aProvider.sendMessage(a2aRequest);\n            // If the response is successful and doesn't contain authentication errors,\n            // verification passed\n            if (response.success === false) {\n                // Check if it's an authentication error\n                if (response.error?.includes('authentication') ||\n                    response.error?.includes('Authentication failed')) {\n                    return false;\n                }\n                // Other errors might be acceptable (e.g., agent doesn't understand the message)\n                // but verification itself passed if no auth error\n                return true;\n            }\n            // Success response means verification passed\n            return true;\n        }\n        catch (error) {\n            // If error contains authentication failure, verification failed\n            const errorMessage = error instanceof Error ? error.message : String(error);\n            if (errorMessage.includes('authentication') ||\n                errorMessage.includes('Authentication failed')) {\n                return false;\n            }\n            // Other errors might indicate verification failed\n            console.error('Verification error:', error);\n            return false;\n        }\n    }\n    /**\n     * Request a feedback authorization token from the agent's A2A endpoint.\n     * Automatically verifies the agent (unless skipVerify=true) before sending the requestAuth message.\n     */\n    async getFeedbackAuth(params) {\n        console.log('[Agent.getFeedbackAuth] Starting getFeedbackAuth');\n        console.log('[Agent.getFeedbackAuth] Agent data:', {\n            agentId: this.data.agentId,\n            chainId: this.data.chainId,\n            agentName: this.data.agentName,\n            a2aEndpoint: this.data.a2aEndpoint,\n            active: this.data.active,\n        });\n        console.log('[Agent.getFeedbackAuth] Params:', JSON.stringify(params, null, 2));\n        // Check if agent is active before attempting to contact A2A endpoint\n        // Only skip if explicitly false; undefined/null means active by default\n        if (this.data.active === false) {\n            console.warn('[Agent.getFeedbackAuth] Agent is not active, skipping A2A request');\n            throw new Error('Agent is not active. Cannot request feedback authorization for inactive agents.');\n        }\n        const clientAddress = params.clientAddress?.toLowerCase();\n        if (!clientAddress ||\n            !clientAddress.startsWith('0x') ||\n            clientAddress.length !== 42) {\n            throw new Error('clientAddress must be a 0x-prefixed 20-byte address');\n        }\n        const resolvedChainId = typeof params.chainId === 'number'\n            ? params.chainId\n            : Number.isFinite(this.data?.chainId)\n                ? Number(this.data.chainId)\n                : _chainConfig__WEBPACK_IMPORTED_MODULE_7__.DEFAULT_CHAIN_ID;\n        const resolveAgentId = (value) => {\n            if (value === undefined || value === null) {\n                return undefined;\n            }\n            try {\n                return BigInt(value).toString();\n            }\n            catch {\n                const stringified = String(value).trim();\n                return stringified.length > 0 ? stringified : undefined;\n            }\n        };\n        const resolvedAgentId = resolveAgentId(params.agentId) ?? resolveAgentId(this.data.agentId);\n        console.log('[Agent.getFeedbackAuth] Resolved agentId:', resolvedAgentId);\n        console.log('[Agent.getFeedbackAuth] Resolved chainId:', resolvedChainId);\n        if (!resolvedAgentId) {\n            throw new Error('Agent ID is required to request feedback auth.');\n        }\n        // Commented out verification - allow A2A endpoint to respond without verification\n        // console.log('[Agent.getFeedbackAuth] Verifying agent...');\n        // const verified = await this.verify();\n        // console.log('[Agent.getFeedbackAuth] Agent verified:', verified);\n        // if (!verified) {\n        //   throw new Error('Agent verification failed before requesting feedback auth.');\n        // }\n        const payload = {\n            clientAddress,\n        };\n        const numericAgentId = Number.parseInt(resolvedAgentId, 10);\n        payload.agentId = Number.isFinite(numericAgentId)\n            ? numericAgentId\n            : resolvedAgentId;\n        if (typeof params.indexLimit === 'number' && params.indexLimit > 0) {\n            payload.indexLimit = params.indexLimit;\n        }\n        if (typeof params.expirySeconds === 'number' && params.expirySeconds > 0) {\n            payload.expirySeconds = params.expirySeconds;\n        }\n        // Forward optional client-built delegation SAR payload (ERC-8092) to the provider.\n        if (params.delegationSar && typeof params.delegationSar === 'object') {\n            payload.delegationSar = params.delegationSar;\n        }\n        const skillId = params.skillId ?? 'oasf:trust.feedback.authorization';\n        const message = params.message ?? 'Request feedback authorization';\n        const metadata = {\n            ...(params.metadata || {}),\n            requestType: 'feedbackAuth',\n            agentId: resolvedAgentId,\n            chainId: resolvedChainId,\n        };\n        const messageRequest = {\n            message,\n            payload,\n            metadata,\n            skillId,\n        };\n        const response = await this.sendMessage(messageRequest);\n        if (!response?.success) {\n            throw new Error(response?.error || 'Provider rejected feedback auth request');\n        }\n        // Some providers respond with payload fields at the top-level (e.g. { success, feedbackAuthId, ... })\n        // rather than nesting under `response`. Support both shapes.\n        const providerPayload = (response.response || response || {});\n        const feedbackAuthId = providerPayload.feedbackAuth ??\n            providerPayload.feedbackAuthId ??\n            providerPayload.feedbackAuthID ??\n            null;\n        if (!feedbackAuthId) {\n            throw new Error('Provider response did not include feedbackAuth');\n        }\n        return {\n            feedbackAuthId,\n            agentId: resolvedAgentId,\n            chainId: resolvedChainId,\n            payload: providerPayload,\n            response,\n        };\n    }\n    /**\n     * Set SessionPackage for this agent instance.\n     * This allows dynamically setting the SessionPackage based on request context\n     * (e.g., subdomain-based routing in provider apps).\n     *\n     * This is server-side only and specific to providerApp configuration.\n     *\n     * @param sessionPackage - The SessionPackage to use for this agent instance\n     */\n    setSessionPackage(sessionPackage) {\n        this.sessionPackage = sessionPackage;\n    }\n    /**\n     * Build a providerApp-like structure from a SessionPackage.\n     * This is used when a SessionPackage is set on the agent instance.\n     */\n    async buildProviderAppFromSessionPackage(sessionPackage) {\n        const { buildDelegationSetup, buildAgentAccountFromSession } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./sessionPackage */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/lib/sessionPackage.js\"));\n        const delegationSetup = buildDelegationSetup(sessionPackage);\n        const agentAccount = await buildAgentAccountFromSession(sessionPackage);\n        // Create wallet client for agent\n        const { createWalletClient, http: httpTransport } = await Promise.all(/*! import() */[__webpack_require__.e(\"vendor-chunks/viem\"), __webpack_require__.e(\"vendor-chunks/abitype\")]).then(__webpack_require__.bind(__webpack_require__, /*! viem */ \"(rsc)/../../node_modules/viem/_esm/index.js\"));\n        const walletClient = createWalletClient({\n            account: agentAccount,\n            chain: delegationSetup.chain,\n            transport: httpTransport(delegationSetup.rpcUrl),\n        });\n        return {\n            sessionPackage,\n            agentAccount,\n            publicClient: delegationSetup.publicClient,\n            walletClient: walletClient,\n            agentId: BigInt(sessionPackage.agentId),\n        };\n    }\n    /**\n     * Issue a feedback authorization on behalf of this agent using the provider app's signer.\n     * If a SessionPackage is set on this agent instance, it will be used instead of the\n     * singleton providerApp. This allows dynamic SessionPackage selection based on request context.\n     */\n    async requestAuth(params) {\n        // Use SessionPackage from agent instance if set, otherwise use singleton providerApp\n        let providerApp;\n        if (this.sessionPackage) {\n            // Build providerApp from the SessionPackage set on this agent instance\n            providerApp = await this.buildProviderAppFromSessionPackage(this.sessionPackage);\n        }\n        else {\n            // Fall back to singleton providerApp\n            const singletonApp = await (0,_userApps_providerApp__WEBPACK_IMPORTED_MODULE_2__.getProviderApp)();\n            if (!singletonApp) {\n                throw new Error('provider app not initialized. Either set a SessionPackage on the agent instance or configure AGENTIC_TRUST_SESSION_PACKAGE_PATH environment variable.');\n            }\n            providerApp = singletonApp;\n        }\n        const clientAddress = params.clientAddress;\n        if (!clientAddress ||\n            typeof clientAddress !== 'string' ||\n            !clientAddress.startsWith('0x')) {\n            throw new Error('clientAddress must be a 0x-prefixed address');\n        }\n        const agentId = params.agentId\n            ? BigInt(params.agentId)\n            : this.data.agentId\n                ? BigInt(this.data.agentId)\n                : providerApp.agentId;\n        const issued = await this.client.createFeedbackAuthWithDelegation({\n            publicClient: providerApp.publicClient,\n            agentId,\n            clientAddress,\n            signer: providerApp.agentAccount,\n            walletClient: providerApp.walletClient,\n            expirySeconds: params.expirySeconds,\n        });\n        return {\n            feedbackAuth: issued.feedbackAuth,\n            delegationAssociation: issued.delegationAssociation,\n            agentId: agentId.toString(),\n            clientAddress,\n            skill: params.skillId || 'oasf:trust.feedback.authorization',\n        };\n    }\n    async buildFeedbackSubmission(params) {\n        const agentId = params.agentId ?? (this.data.agentId ? this.data.agentId.toString() : undefined);\n        if (!agentId) {\n            throw new Error('agentId is required. Provide it in params or ensure agent has agentId in data.');\n        }\n        const chainId = this.data?.chainId && Number.isFinite(this.data.chainId)\n            ? Number(this.data.chainId)\n            : _chainConfig__WEBPACK_IMPORTED_MODULE_7__.DEFAULT_CHAIN_ID;\n        const score = Number(params.score ?? 0);\n        if (!Number.isFinite(score)) {\n            throw new Error('score must be a valid number between 0 and 100');\n        }\n        const normalizedScore = Math.max(0, Math.min(100, Math.round(score)));\n        const feedbackAuth = params.feedbackAuth;\n        if (!feedbackAuth) {\n            throw new Error('feedbackAuth is required to submit feedback');\n        }\n        // Prefer an explicit clientAddress from params (e.g. browser wallet / Web3Auth).\n        // Only fall back to ClientApp (server-side private key) when clientAddress is not provided.\n        let clientAddressHex = params.clientAddress;\n        if (!clientAddressHex) {\n            const { getClientApp } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ../userApps/clientApp */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/userApps/clientApp.js\"));\n            const clientApp = await getClientApp();\n            clientAddressHex = clientApp?.address;\n        }\n        if (!clientAddressHex) {\n            throw new Error('clientAddress is required to submit feedback');\n        }\n        let agentRegistry = '';\n        try {\n            const identityRegistry = (0,_chainConfig__WEBPACK_IMPORTED_MODULE_7__.requireChainEnvVar)('AGENTIC_TRUST_IDENTITY_REGISTRY', chainId);\n            agentRegistry = `eip155:${chainId}:${identityRegistry}`;\n        }\n        catch (error) {\n            console.warn('[Agent.buildFeedbackSubmission] Failed to resolve AGENTIC_TRUST_IDENTITY_REGISTRY; feedbackFile.agentRegistry will be empty:', error);\n        }\n        const clientAddressCaip = `eip155:${chainId}:${clientAddressHex}`;\n        const feedbackFile = {\n            agentRegistry,\n            agentId: Number.parseInt(agentId, 10) || 0,\n            clientAddress: clientAddressCaip || clientAddressHex,\n            createdAt: new Date().toISOString(),\n            feedbackAuth,\n            score: normalizedScore,\n        };\n        if (params.tag1)\n            feedbackFile.tag1 = params.tag1;\n        if (params.tag2)\n            feedbackFile.tag2 = params.tag2;\n        if (params.skill)\n            feedbackFile.skill = params.skill;\n        if (params.context)\n            feedbackFile.context = params.context;\n        if (params.capability)\n            feedbackFile.capability = params.capability;\n        let feedbackUriFromIpfs;\n        let feedbackHashFromIpfs;\n        try {\n            const ipfs = (0,_ipfs__WEBPACK_IMPORTED_MODULE_4__.getIPFSStorage)();\n            const serialized = JSON.stringify(feedbackFile);\n            const uploadResult = await ipfs.upload(serialized, 'feedback.json');\n            feedbackUriFromIpfs = uploadResult.tokenUri;\n            feedbackHashFromIpfs = ethers__WEBPACK_IMPORTED_MODULE_8__.keccak256(ethers__WEBPACK_IMPORTED_MODULE_9__.toUtf8Bytes(serialized));\n        }\n        catch (error) {\n            console.warn('[Agent.buildFeedbackSubmission] Failed to upload FeedbackFile to IPFS; continuing without feedbackUri/feedbackHash:', error);\n        }\n        const giveParams = {\n            agent: agentId,\n            score: normalizedScore,\n            feedback: params.feedback ?? 'Feedback submitted via Agentic Trust admin app.',\n            tag1: params.tag1,\n            tag2: params.tag2,\n            // Updated reputation ABI includes an `endpoint` string.\n            // IMPORTANT: Keep this short and stable. Some deployed registries are strict (and will revert)\n            // on unexpected long URLs or values here. Prefer the agent's A2A endpoint; otherwise fall back\n            // to a best-effort origin (no path/query) from any URL-like value we have.\n            endpoint: (() => {\n                const a2a = typeof this.data?.a2aEndpoint === 'string' ? String(this.data.a2aEndpoint) : '';\n                if (a2a.trim())\n                    return a2a.trim();\n                const raw = typeof this?.endpoint?.url === 'string' ? String(this.endpoint.url) : '';\n                if (!raw.trim())\n                    return '';\n                try {\n                    const u = new URL(raw.trim());\n                    return `${u.protocol}//${u.host}`;\n                }\n                catch {\n                    return '';\n                }\n            })(),\n            feedbackUri: feedbackUriFromIpfs,\n            feedbackHash: feedbackHashFromIpfs,\n            agentId,\n            feedbackAuth,\n        };\n        return {\n            chainId,\n            giveParams,\n        };\n    }\n    /**\n     * Submit client feedback to the reputation contract.\n     */\n    async giveFeedback(params) {\n        if (!params.feedbackAuth) {\n            throw new Error('feedbackAuth is required to submit feedback');\n        }\n        const { chainId, giveParams } = await this.buildFeedbackSubmission({\n            ...params,\n            feedbackAuth: params.feedbackAuth,\n        });\n        const reputationClient = await (0,_singletons_reputationClient__WEBPACK_IMPORTED_MODULE_3__.getReputationRegistryClient)(chainId);\n        return reputationClient.giveClientFeedback(giveParams);\n    }\n    /**\n     * Prepare a giveFeedback transaction for client-side signing.\n     */\n    async prepareGiveFeedback(params) {\n        if (!params.feedbackAuth) {\n            throw new Error('feedbackAuth is required to prepare feedback transaction');\n        }\n        const { chainId, giveParams } = await this.buildFeedbackSubmission({\n            ...params,\n            feedbackAuth: params.feedbackAuth,\n        });\n        const reputationClient = await (0,_singletons_reputationClient__WEBPACK_IMPORTED_MODULE_3__.getReputationRegistryClient)(chainId);\n        const txRequest = await reputationClient.prepareGiveFeedbackTx(giveParams);\n        const toHex = (value) => typeof value === 'bigint' ? `0x${value.toString(16)}` : undefined;\n        const transaction = {\n            to: txRequest.to,\n            data: txRequest.data,\n            value: toHex(txRequest.value) ?? '0x0',\n            gas: toHex(txRequest.gas),\n            gasPrice: toHex(txRequest.gasPrice),\n            maxFeePerGas: toHex(txRequest.maxFeePerGas),\n            maxPriorityFeePerGas: toHex(txRequest.maxPriorityFeePerGas),\n            nonce: txRequest.nonce,\n            chainId,\n        };\n        return {\n            chainId,\n            transaction,\n        };\n    }\n    /**\n     * Get the approved NFT operator address for this agent\n     * Returns the address approved to operate on the agent's NFT token, or null if no operator is set\n     *\n     * @param chainId - Optional chain ID (defaults to the agent's chainId from data, or DEFAULT_CHAIN_ID)\n     * @returns The approved operator address, or null if no operator is set\n     */\n    async getNFTOperator(chainId) {\n        const agentId = this.agentId;\n        if (!agentId) {\n            throw new Error('Agent ID is required to get NFT operator');\n        }\n        const resolvedChainId = chainId ??\n            (Number.isFinite(this.data?.chainId) ? Number(this.data.chainId) : _chainConfig__WEBPACK_IMPORTED_MODULE_7__.DEFAULT_CHAIN_ID);\n        return this.client.agents.getNFTOperator(agentId, resolvedChainId);\n    }\n}\n/**\n * Load a detailed Agent view using a provided AgenticTrustClient.\n * This is the core implementation used by admin and other services.\n *\n * IMPORTANT: This function fetches on-chain NFT metadata (via getAllMetadata),\n * which makes multiple RPC calls. It should ONLY be used for detailed agent views,\n * NOT for list queries. List queries should use searchAgents/listAgents which\n * only fetch data from the GraphQL discovery indexer.\n */\nfunction firstNonEmptyString(...values) {\n    for (const value of values) {\n        if (value === undefined || value === null)\n            continue;\n        if (typeof value === 'string') {\n            const trimmed = value.trim();\n            if (trimmed.length > 0) {\n                return trimmed;\n            }\n            continue;\n        }\n        const asString = String(value).trim();\n        if (asString.length > 0) {\n            return asString;\n        }\n    }\n    return undefined;\n}\nasync function loadAgentDetail(client, agentIdentifier, chainId = _chainConfig__WEBPACK_IMPORTED_MODULE_7__.DEFAULT_CHAIN_ID, options) {\n    const isDid = typeof agentIdentifier === 'string' && agentIdentifier.trim().startsWith('did:8004:');\n    let resolvedChainId = chainId;\n    let agentId;\n    let agentIdBigInt;\n    let did8004;\n    if (isDid) {\n        did8004 = decodeURIComponent(agentIdentifier.trim());\n        const parsed = (0,_agentic_trust_8004_ext_sdk__WEBPACK_IMPORTED_MODULE_1__.parseDid8004)(did8004);\n        resolvedChainId = parsed.chainId;\n        agentId = parsed.agentId;\n        try {\n            agentIdBigInt = BigInt(agentId);\n        }\n        catch {\n            throw new Error(`Invalid agentId in did:8004 identifier: ${did8004}`);\n        }\n    }\n    else {\n        const agentIdInput = agentIdentifier;\n        agentIdBigInt =\n            typeof agentIdInput === 'bigint'\n                ? agentIdInput\n                : (() => {\n                    try {\n                        return BigInt(agentIdInput);\n                    }\n                    catch {\n                        throw new Error(`Invalid agentId: ${agentIdInput}`);\n                    }\n                })();\n        agentId = agentIdBigInt.toString();\n    }\n    const identityClient = await (0,_singletons_identityClient__WEBPACK_IMPORTED_MODULE_5__.getIdentityRegistryClient)(resolvedChainId);\n    const tokenUri = await identityClient.getTokenURI(agentIdBigInt);\n    // Fetch metadata from GraphQL indexer (from searchAgentsGraph with metadata field)\n    // This avoids on-chain RPC calls and rate limiting issues\n    let metadata = {};\n    try {\n        const discoveryClient = await (0,_singletons_discoveryClient__WEBPACK_IMPORTED_MODULE_6__.getDiscoveryClient)();\n        // Try to get agent with metadata from searchAgentsGraph\n        const agentWithMetadata = await discoveryClient.getAgent(resolvedChainId, agentId);\n        if (agentWithMetadata) {\n            const metadataProp = agentWithMetadata.metadata;\n            if (metadataProp && typeof metadataProp === 'object' && Object.keys(metadataProp).length > 0) {\n                metadata = metadataProp;\n                console.log('[loadAgentDetail] Got metadata from searchAgentsGraph:', Object.keys(metadata).length, 'keys');\n            }\n            else {\n                console.log('[loadAgentDetail] No metadata in searchAgentsGraph result, trying getTokenMetadata');\n                const graphQLMetadata = await discoveryClient.getTokenMetadata(resolvedChainId, agentId);\n                if (graphQLMetadata && Object.keys(graphQLMetadata).length > 0) {\n                    metadata = graphQLMetadata;\n                    console.log('[loadAgentDetail] Got metadata from getTokenMetadata:', Object.keys(metadata).length, 'keys');\n                }\n                else {\n                    console.warn('[loadAgentDetail] No metadata found in GraphQL; skipping on-chain metadata to reduce latency');\n                    metadata = {};\n                }\n            }\n        }\n        else {\n            console.warn('[loadAgentDetail] getAgent returned null, trying getTokenMetadata');\n            const graphQLMetadata = await discoveryClient.getTokenMetadata(resolvedChainId, agentId);\n            if (graphQLMetadata && Object.keys(graphQLMetadata).length > 0) {\n                metadata = graphQLMetadata;\n            }\n            else {\n                console.warn('[loadAgentDetail] No metadata found via GraphQL; skipping on-chain metadata to reduce latency');\n                metadata = {};\n            }\n        }\n    }\n    catch (error) {\n        console.warn('[loadAgentDetail] Failed to fetch metadata from GraphQL; skipping on-chain metadata to reduce latency:', error);\n        metadata = {}; // Avoid on-chain fallback to keep responses fast\n    }\n    const identityMetadata = {\n        tokenUri,\n        metadata,\n    };\n    let identityRegistration = null;\n    // IMPORTANT: By default, we do NOT fetch registration JSON from IPFS. UIs should only do that\n    // when the user explicitly opens the Registration tab.\n    const includeRegistration = options?.includeRegistration === true;\n    let discovery = null;\n    try {\n        const agentsApi = client.agents;\n        if (did8004 && typeof agentsApi.getAgentFromDiscoveryByDid === 'function') {\n            discovery = (await agentsApi.getAgentFromDiscoveryByDid(did8004));\n        }\n        else if (typeof agentsApi.getAgentFromDiscovery === 'function') {\n            discovery = (await agentsApi.getAgentFromDiscovery(resolvedChainId, agentId));\n        }\n        else {\n            discovery = null;\n        }\n    }\n    catch (error) {\n        // Check if this is an access code error and provide a clearer message\n        const { rethrowDiscoveryError } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./discoveryErrors */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/lib/discoveryErrors.js\"));\n        try {\n            rethrowDiscoveryError(error, 'loadAgentDetail');\n        }\n        catch (friendlyError) {\n            // If rethrowDiscoveryError determined it's an access code error, log the friendly message\n            console.error('Failed to get GraphQL agent data:', friendlyError instanceof Error ? friendlyError.message : friendlyError);\n            throw friendlyError; // Re-throw the friendly error\n        }\n        // If it's not an access code error, just log and continue\n        console.warn('Failed to get GraphQL agent data:', error);\n        discovery = null;\n    }\n    // Prefer cached registration JSON from discovery row (rawJson) instead of hitting IPFS.\n    // This keeps \"agent details\" fast and avoids gateway dependency.\n    if (tokenUri) {\n        let registrationFromDiscovery = null;\n        try {\n            const rawJsonMaybe = discovery && typeof discovery.rawJson === 'string'\n                ? String(discovery.rawJson)\n                : null;\n            if (rawJsonMaybe && rawJsonMaybe.trim()) {\n                const parsed = JSON.parse(rawJsonMaybe);\n                if (parsed && typeof parsed === 'object' && !Array.isArray(parsed)) {\n                    registrationFromDiscovery = parsed;\n                }\n            }\n        }\n        catch {\n            // ignore\n        }\n        if (registrationFromDiscovery) {\n            identityRegistration = { tokenUri, registration: registrationFromDiscovery };\n        }\n        else if (includeRegistration) {\n            // Explicit opt-in: fetch from IPFS/tokenUri.\n            try {\n                const ipfsStorage = (0,_ipfs__WEBPACK_IMPORTED_MODULE_4__.getIPFSStorage)();\n                const registration = (await ipfsStorage.getJson(tokenUri));\n                identityRegistration = {\n                    tokenUri,\n                    registration,\n                };\n            }\n            catch (error) {\n                console.warn('Failed to get IPFS registration:', error);\n                identityRegistration = {\n                    tokenUri,\n                    registration: null,\n                };\n            }\n        }\n    }\n    const flattened = {};\n    // Priority 1: Data from tokenUri/IPFS registration (highest priority - on-chain source of truth)\n    if (identityRegistration?.registration &&\n        typeof identityRegistration.registration === 'object') {\n        const reg = identityRegistration.registration;\n        // Extract standard fields\n        if (typeof reg.name === 'string')\n            flattened.name = reg.name;\n        if (typeof reg.description === 'string')\n            flattened.description = reg.description;\n        if (typeof reg.image === 'string')\n            flattened.image = reg.image;\n        if (typeof reg.agentAccount === 'string')\n            flattened.agentAccount = reg.agentAccount;\n        if (reg.endpoints)\n            flattened.endpoints = reg.endpoints;\n        if (reg.supportedTrust)\n            flattened.supportedTrust = reg.supportedTrust;\n        if (typeof reg.createdAt !== 'undefined')\n            flattened.createdAt = reg.createdAt;\n        if (typeof reg.updatedAt !== 'undefined')\n            flattened.updatedAt = reg.updatedAt;\n        // Extract all other metadata fields from registration JSON\n        // This includes: tags, glbUrl, agentWallet, capabilities, role, version, rating, pricing, etc.\n        Object.keys(reg).forEach((key) => {\n            // Skip fields we've already handled explicitly\n            if (key !== 'name' &&\n                key !== 'description' &&\n                key !== 'image' &&\n                key !== 'agentAccount' &&\n                key !== 'endpoints' &&\n                key !== 'supportedTrust' &&\n                key !== 'createdAt' &&\n                key !== 'updatedAt' &&\n                key !== 'type' &&\n                key !== 'agentUrl' &&\n                key !== 'metadata' &&\n                key !== 'attributes' &&\n                key !== 'external_url' &&\n                flattened[key] === undefined) {\n                flattened[key] = reg[key];\n            }\n        });\n        // Extract a2aEndpoint from registration\n        // Priority: 1) direct a2aEndpoint field, 2) from endpoints array (name: 'A2A'), 3) from agentUrl\n        /*\n        if (typeof reg.a2aEndpoint === 'string') {\n          flattened.a2aEndpoint = reg.a2aEndpoint;\n        } else if (Array.isArray(reg.endpoints)) {\n          // Find A2A endpoint in endpoints array\n          const a2aEndpointEntry = reg.endpoints.find(\n            (ep: unknown) =>\n              typeof ep === 'object' &&\n              ep !== null &&\n              'name' in ep &&\n              (ep as { name: string }).name === 'A2A' &&\n              'endpoint' in ep &&\n              typeof (ep as { endpoint: unknown }).endpoint === 'string'\n          ) as { endpoint: string } | undefined;\n          if (a2aEndpointEntry) {\n            flattened.a2aEndpoint = a2aEndpointEntry.endpoint;\n          }\n        }\n        */\n    }\n    // Priority 2: On-chain metadata (only fill if not already set from registration)\n    if (metadata.agentName && !flattened.name)\n        flattened.name = metadata.agentName;\n    if (metadata.agentName && !flattened.agentName)\n        flattened.agentName = metadata.agentName;\n    if (metadata.agentAccount && !flattened.agentAccount)\n        flattened.agentAccount = metadata.agentAccount;\n    // Priority 3: Discovery data (GraphQL indexer) - only as fallback when not available from on-chain sources\n    const discoveryRecord = discovery || {};\n    if (discovery && typeof discovery === 'object') {\n        // Only use discovery data if not already set from tokenUri/metadata\n        const agentNameFromDiscovery = typeof discoveryRecord.agentName === 'string'\n            ? discoveryRecord.agentName\n            : undefined;\n        if (agentNameFromDiscovery && !flattened.name)\n            flattened.name = agentNameFromDiscovery;\n        if (agentNameFromDiscovery && !flattened.agentName)\n            flattened.agentName = agentNameFromDiscovery;\n        // a2aEndpoint from discovery only if not in registration\n        const a2aEndpointFromDiscovery = typeof discoveryRecord.a2aEndpoint === 'string'\n            ? discoveryRecord.a2aEndpoint\n            : undefined;\n        //if (a2aEndpointFromDiscovery && !flattened.a2aEndpoint) {\n        //  flattened.a2aEndpoint = a2aEndpointFromDiscovery;\n        //}\n        // Timestamps from discovery only if not in registration\n        const createdAtTimeFromDiscovery = typeof discoveryRecord.createdAtTime !== 'undefined'\n            ? discoveryRecord.createdAtTime\n            : undefined;\n        if (createdAtTimeFromDiscovery !== undefined && flattened.createdAtTime === undefined) {\n            flattened.createdAtTime = createdAtTimeFromDiscovery;\n        }\n        const updatedAtTimeFromDiscovery = typeof discoveryRecord.updatedAtTime !== 'undefined'\n            ? discoveryRecord.updatedAtTime\n            : undefined;\n        if (updatedAtTimeFromDiscovery !== undefined && flattened.updatedAtTime === undefined) {\n            flattened.updatedAtTime = updatedAtTimeFromDiscovery;\n        }\n        // Fill in any other discovery fields that aren't already set\n        // Exclude agentUri and rawJson - these should come from on-chain sources only\n        Object.keys(discoveryRecord).forEach((key) => {\n            if (key !== 'agentId' && key !== 'agentUri' && key !== 'rawJson' && flattened[key] === undefined) {\n                flattened[key] = discoveryRecord[key];\n            }\n        });\n    }\n    // Prioritize: flattened (from tokenUri/IPFS/metadata) > discoveryRecord, but treat\n    // empty/whitespace strings as \"missing\" so we can safely fall back to discovery.\n    const agentNameValue = firstNonEmptyString(flattened.agentName, flattened.name, discoveryRecord.agentName) ?? '';\n    // Prevent later spread of `flattened` from overwriting the resolved agentName\n    // with an empty string or less-preferred source.\n    delete flattened.agentName;\n    delete flattened.name;\n    const agentAccountValue = flattened.agentAccount ??\n        discoveryRecord.agentAccount ??\n        '';\n    const agentIdentityOwnerAccountValue = discoveryRecord.agentIdentityOwnerAccount ?? '';\n    const detail = {\n        // AgentInfo fields\n        agentId,\n        agentName: agentNameValue,\n        chainId: resolvedChainId,\n        agentAccount: agentAccountValue,\n        agentIdentityOwnerAccount: agentIdentityOwnerAccountValue,\n        eoaAgentIdentityOwnerAccount: discoveryRecord.eoaAgentIdentityOwnerAccount ?? null,\n        eoaAgentAccount: discoveryRecord.eoaAgentAccount ?? null,\n        didIdentity: discoveryRecord.didIdentity ?? null,\n        didAccount: discoveryRecord.didAccount ?? null,\n        didName: discoveryRecord.didName ?? null,\n        // agentUri and rawJson will be set after the spread to ensure they're not overwritten\n        createdAtBlock: typeof discoveryRecord.createdAtBlock === 'number' ? discoveryRecord.createdAtBlock : 0,\n        createdAtTime: typeof discoveryRecord.createdAtTime === 'number'\n            ? discoveryRecord.createdAtTime\n            : flattened.createdAtTime ?? 0,\n        updatedAtTime: typeof discoveryRecord.updatedAtTime === 'number'\n            ? discoveryRecord.updatedAtTime\n            : flattened.updatedAtTime ?? null,\n        type: discoveryRecord.type ?? null,\n        // Prioritize: flattened (from tokenUri/IPFS) > discoveryRecord\n        description: flattened.description ??\n            discoveryRecord.description ??\n            null,\n        image: flattened.image ??\n            discoveryRecord.image ??\n            null,\n        a2aEndpoint: flattened.a2aEndpoint ??\n            discoveryRecord.a2aEndpoint ??\n            null,\n        // Prioritize: flattened (from tokenUri/IPFS) > discoveryRecord\n        supportedTrust: flattened.supportedTrust ??\n            discoveryRecord.supportedTrust ??\n            null,\n        agentCardJson: discoveryRecord.agentCardJson ?? null,\n        agentCardReadAt: typeof discoveryRecord.agentCardReadAt === 'number'\n            ? discoveryRecord.agentCardReadAt\n            : discoveryRecord.agentCardReadAt ?? null,\n        did: discoveryRecord.did ?? null,\n        mcp: typeof discoveryRecord.mcp === 'boolean'\n            ? discoveryRecord.mcp\n            : discoveryRecord.mcp ?? null,\n        x402support: typeof discoveryRecord.x402support === 'boolean'\n            ? discoveryRecord.x402support\n            : discoveryRecord.x402support ?? null,\n        active: typeof discoveryRecord.active === 'boolean'\n            ? discoveryRecord.active\n            : discoveryRecord.active ?? null,\n        // AgentDetail-specific fields\n        success: true,\n        identityMetadata,\n        identityRegistration,\n        discovery,\n        // Flattened extra fields\n        ...flattened,\n    };\n    // Set agentUri and rawJson AFTER spread to ensure on-chain values take precedence.\n    // Use on-chain tokenUri as primary source (from contract); in the new discovery schema, this is exposed as `agentUri`.\n    detail.agentUri =\n        identityMetadata.tokenUri !== null && identityMetadata.tokenUri !== undefined\n            ? identityMetadata.tokenUri\n            : (discoveryRecord.agentUri ?? null);\n    // Use registration JSON from tokenUri/IPFS as primary source, fallback to discovery\n    detail.rawJson = identityRegistration?.registration\n        ? JSON.stringify(identityRegistration.registration, null, 2)\n        : (discoveryRecord.rawJson ?? null);\n    return detail;\n}\n/**\n * @deprecated Use loadAgentDetail instead.\n */\nconst buildAgentDetail = loadAgentDetail;\n//# sourceMappingURL=agent.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BhZ2VudGljLXRydXN0L2NvcmUvZGlzdC9zZXJ2ZXIvbGliL2FnZW50LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUM0RDtBQUNEO0FBQ0Y7QUFDb0I7QUFDckM7QUFDaUM7QUFDTjtBQUNFO0FBQ3JDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsVUFBVTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsUUFBUSxFQUFFLE1BQU07QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixxRUFBbUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiwwREFBZ0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRUFBK0UsOEJBQThCO0FBQzdHO0FBQ0Esb0VBQW9FO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IscURBQXFELFFBQVEsOExBQTBCO0FBQ3ZHO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwwQ0FBMEMsUUFBUSx3T0FBYztBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxxRUFBYztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsMERBQWdCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGVBQWUsUUFBUSxtTUFBK0I7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxnRUFBa0I7QUFDdkQsc0NBQXNDLFFBQVEsR0FBRyxpQkFBaUI7QUFDbEU7QUFDQTtBQUNBLDZHQUE2RztBQUM3RztBQUNBLDRDQUE0QyxRQUFRLEdBQUcsaUJBQWlCO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixxREFBYztBQUN2QztBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsNkNBQWdCLENBQUMsK0NBQWtCO0FBQ3RFO0FBQ0E7QUFDQSxpR0FBaUc7QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0ZBQXdGO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLFdBQVcsSUFBSSxPQUFPO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isc0JBQXNCO0FBQ3RDO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsdUNBQXVDLHlGQUEyQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isc0JBQXNCO0FBQ3RDO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsdUNBQXVDLHlGQUEyQjtBQUNsRTtBQUNBLGtFQUFrRSxtQkFBbUI7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRSwwREFBZ0I7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sa0VBQWtFLDBEQUFnQjtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix5RUFBWTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUUsUUFBUTtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsYUFBYTtBQUN6RTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsaUNBQWlDLHFGQUF5QjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLCtFQUFrQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtGQUFrRjtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0VBQStFO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRUFBK0U7QUFDL0UsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix3QkFBd0IsUUFBUSxnTUFBMkI7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxxREFBYztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsY0FBYztBQUNyQztBQUNBLDhCQUE4QixtQkFBbUI7QUFDakQsaUJBQWlCLG1CQUFtQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCIsInNvdXJjZXMiOlsiL2hvbWUvYmFyYi9hYS9Bc3NvY2lhdGVkQWNjb3VudHMvbm9kZV9tb2R1bGVzL0BhZ2VudGljLXRydXN0L2NvcmUvZGlzdC9zZXJ2ZXIvbGliL2FnZW50LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQWdlbnQgY2xhc3NcbiAqXG4gKiBSZXByZXNlbnRzIGEgZGlzY292ZXJlZCBhZ2VudCB3aXRoIHByb3RvY29sIHN1cHBvcnQgKEEyQSwgTUNQLCBldGMuKVxuICogQWJzdHJhY3RzIHByb3RvY29sIGRldGFpbHMgc28gY2xpZW50cyBjYW4gaW50ZXJhY3Qgd2l0aCBhZ2VudHMgd2l0aG91dFxuICoga25vd2luZyB0aGUgdW5kZXJseWluZyBwcm90b2NvbCBpbXBsZW1lbnRhdGlvbi5cbiAqL1xuaW1wb3J0IHsgQTJBUHJvdG9jb2xQcm92aWRlciB9IGZyb20gJy4vYTJhUHJvdG9jb2xQcm92aWRlcic7XG5pbXBvcnQgeyBwYXJzZURpZDgwMDQgfSBmcm9tICdAYWdlbnRpYy10cnVzdC84MDA0LWV4dC1zZGsnO1xuaW1wb3J0IHsgZ2V0UHJvdmlkZXJBcHAgfSBmcm9tICcuLi91c2VyQXBwcy9wcm92aWRlckFwcCc7XG5pbXBvcnQgeyBnZXRSZXB1dGF0aW9uUmVnaXN0cnlDbGllbnQgfSBmcm9tICcuLi9zaW5nbGV0b25zL3JlcHV0YXRpb25DbGllbnQnO1xuaW1wb3J0IHsgZ2V0SVBGU1N0b3JhZ2UgfSBmcm9tICcuL2lwZnMnO1xuaW1wb3J0IHsgZ2V0SWRlbnRpdHlSZWdpc3RyeUNsaWVudCB9IGZyb20gJy4uL3NpbmdsZXRvbnMvaWRlbnRpdHlDbGllbnQnO1xuaW1wb3J0IHsgZ2V0RGlzY292ZXJ5Q2xpZW50IH0gZnJvbSAnLi4vc2luZ2xldG9ucy9kaXNjb3ZlcnlDbGllbnQnO1xuaW1wb3J0IHsgREVGQVVMVF9DSEFJTl9JRCwgcmVxdWlyZUNoYWluRW52VmFyIH0gZnJvbSAnLi9jaGFpbkNvbmZpZyc7XG5pbXBvcnQgeyBldGhlcnMgfSBmcm9tICdldGhlcnMnO1xuLyoqXG4gKiBBZ2VudCBjbGFzcyAtIHJlcHJlc2VudHMgYSBkaXNjb3ZlcmVkIGFnZW50IHdpdGggcHJvdG9jb2wgc3VwcG9ydFxuICovXG5leHBvcnQgY2xhc3MgQWdlbnQge1xuICAgIGRhdGE7XG4gICAgY2xpZW50O1xuICAgIGEyYVByb3ZpZGVyID0gbnVsbDtcbiAgICBhZ2VudENhcmQgPSBudWxsO1xuICAgIGVuZHBvaW50ID0gbnVsbDtcbiAgICBpbml0aWFsaXplZCA9IGZhbHNlO1xuICAgIHNlc3Npb25QYWNrYWdlID0gbnVsbDtcbiAgICBjb25zdHJ1Y3RvcihkYXRhLCBjbGllbnQpIHtcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICAgICAgdGhpcy5jbGllbnQgPSBjbGllbnQ7XG4gICAgICAgIC8vIEF1dG8taW5pdGlhbGl6ZSBpZiBhZ2VudCBoYXMgYW4gYTJhRW5kcG9pbnRcbiAgICAgICAgaWYgKHRoaXMuZGF0YS5hMmFFbmRwb2ludCkge1xuICAgICAgICAgICAgdGhpcy5pbml0aWFsaXplKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGFnZW50IElEXG4gICAgICovXG4gICAgZ2V0IGFnZW50SWQoKSB7XG4gICAgICAgIGNvbnN0IHsgYWdlbnRJZCB9ID0gdGhpcy5kYXRhO1xuICAgICAgICBpZiAodHlwZW9mIGFnZW50SWQgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICByZXR1cm4gYWdlbnRJZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGFnZW50SWQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJzZWQgPSBOdW1iZXIoYWdlbnRJZCk7XG4gICAgICAgICAgICByZXR1cm4gTnVtYmVyLmlzRmluaXRlKHBhcnNlZCkgPyBwYXJzZWQgOiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGFnZW50IG5hbWVcbiAgICAgKi9cbiAgICBnZXQgYWdlbnROYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhLmFnZW50TmFtZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGFnZW50IGFjY291bnQgYWRkcmVzc1xuICAgICAqL1xuICAgIGdldCBhZ2VudEFjY291bnQoKSB7XG4gICAgICAgIGNvbnN0IGFjY291bnQgPSB0aGlzLmRhdGEuYWdlbnRBY2NvdW50O1xuICAgICAgICBpZiAodHlwZW9mIGFjY291bnQgPT09ICdzdHJpbmcnICYmIGFjY291bnQudHJpbSgpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiBhY2NvdW50O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxlZ2FjeUFkZHJlc3MgPSB0aGlzLmRhdGEuYWdlbnRBZGRyZXNzO1xuICAgICAgICBpZiAodHlwZW9mIGxlZ2FjeUFkZHJlc3MgPT09ICdzdHJpbmcnICYmIGxlZ2FjeUFkZHJlc3MudHJpbSgpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiBsZWdhY3lBZGRyZXNzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJhY2t3YXJkcy1jb21wYXRpYmxlIGFsaWFzIGZvciBhZ2VudEFjY291bnRcbiAgICAgKi9cbiAgICBnZXQgYWdlbnRBZGRyZXNzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hZ2VudEFjY291bnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhZ2VudCBpZGVudGl0eSBvd25lciBhY2NvdW50IChzdG9yZWQgYXMgXCJ7Y2hhaW5JZH06ezB4Li4ufVwiKVxuICAgICAqL1xuICAgIGdldCBhZ2VudElkZW50aXR5T3duZXJBY2NvdW50KCkge1xuICAgICAgICBjb25zdCBvd25lciA9IHRoaXMuZGF0YS5hZ2VudElkZW50aXR5T3duZXJBY2NvdW50O1xuICAgICAgICBpZiAodHlwZW9mIG93bmVyID09PSAnc3RyaW5nJyAmJiBvd25lci50cmltKCkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIG93bmVyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBpZGVudGl0eSBESUQgKGUuZy4gZGlkOjgwMDQpXG4gICAgICovXG4gICAgZ2V0IGRpZElkZW50aXR5KCkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuZGF0YS5kaWRJZGVudGl0eTtcbiAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiB2YWx1ZS50cmltKCkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnRyaW0oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgYWNjb3VudCBESUQgKGUuZy4gZGlkOmV0aHIpXG4gICAgICovXG4gICAgZ2V0IGRpZEFjY291bnQoKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5kYXRhLmRpZEFjY291bnQ7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgdmFsdWUudHJpbSgpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS50cmltKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IG5hbWUgRElEIChlLmcuIGRpZDplbnMpXG4gICAgICovXG4gICAgZ2V0IGRpZE5hbWUoKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5kYXRhLmRpZE5hbWU7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgdmFsdWUudHJpbSgpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS50cmltKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHZhbGlkYXRpb24gcGVuZGluZyBjb3VudFxuICAgICAqL1xuICAgIGdldCB2YWxpZGF0aW9uUGVuZGluZ0NvdW50KCkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuZGF0YS52YWxpZGF0aW9uUGVuZGluZ0NvdW50O1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB2YWxpZGF0aW9uIGNvbXBsZXRlZCBjb3VudFxuICAgICAqL1xuICAgIGdldCB2YWxpZGF0aW9uQ29tcGxldGVkQ291bnQoKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5kYXRhLnZhbGlkYXRpb25Db21wbGV0ZWRDb3VudDtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdmFsaWRhdGlvbiByZXF1ZXN0ZWQgY291bnRcbiAgICAgKi9cbiAgICBnZXQgdmFsaWRhdGlvblJlcXVlc3RlZENvdW50KCkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuZGF0YS52YWxpZGF0aW9uUmVxdWVzdGVkQ291bnQ7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGZlZWRiYWNrIGNvdW50XG4gICAgICovXG4gICAgZ2V0IGZlZWRiYWNrQ291bnQoKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5kYXRhLmZlZWRiYWNrQ291bnQ7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGZlZWRiYWNrIGF2ZXJhZ2Ugc2NvcmVcbiAgICAgKi9cbiAgICBnZXQgZmVlZGJhY2tBdmVyYWdlU2NvcmUoKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5kYXRhLmZlZWRiYWNrQXZlcmFnZVNjb3JlO1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBBMkEgZW5kcG9pbnQgVVJMXG4gICAgICovXG4gICAgZ2V0IGEyYUVuZHBvaW50KCkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHRoaXMuZGF0YS5hMmFFbmRwb2ludCA9PT0gJ3N0cmluZydcbiAgICAgICAgICAgID8gdGhpcy5kYXRhLmEyYUVuZHBvaW50XG4gICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaW5pdGlhbGl6ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuaW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuZGF0YS5hMmFFbmRwb2ludCkge1xuICAgICAgICAgICAgcmV0dXJuOyAvLyBObyBlbmRwb2ludCwgYWdlbnQgY2Fubm90IGJlIGluaXRpYWxpemVkXG4gICAgICAgIH1cbiAgICAgICAgLy8gR2V0IFZlcmFtbyBhZ2VudCBmcm9tIHRoZSBjbGllbnRcbiAgICAgICAgY29uc3QgdmVyYW1vQWdlbnQgPSB0aGlzLmNsaWVudC52ZXJhbW8uZ2V0QWdlbnQoKTtcbiAgICAgICAgLy8gVXNlIHRoZSBleHBsaWNpdGx5LWRlZmluZWQgQTJBIGVuZHBvaW50IChubyBob3N0bmFtZS9wYXRoIHJld3JpdGluZykuXG4gICAgICAgIGNvbnN0IGEyYUVuZHBvaW50VXJsID0gdGhpcy5kYXRhLmEyYUVuZHBvaW50O1xuICAgICAgICAvLyBDcmVhdGUgQTJBIFByb3RvY29sIFByb3ZpZGVyIGZvciB0aGlzIGFnZW50XG4gICAgICAgIC8vIFRoaXMgZG9lcyBOT1QgZmV0Y2ggdGhlIGFnZW50IGNhcmQgLSBjYXJkIGlzIGZldGNoZWQgbGF6aWx5IHdoZW4gbmVlZGVkXG4gICAgICAgIHRoaXMuYTJhUHJvdmlkZXIgPSBuZXcgQTJBUHJvdG9jb2xQcm92aWRlcihhMmFFbmRwb2ludFVybCwgdmVyYW1vQWdlbnQpO1xuICAgICAgICB0aGlzLmluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICB9XG4gICAgaXNJbml0aWFsaXplZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5pdGlhbGl6ZWQ7XG4gICAgfVxuICAgIGFzeW5jIGZldGNoQ2FyZCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmEyYVByb3ZpZGVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FnZW50IG5vdCBpbml0aWFsaXplZC4gQ2FsbCBpbml0aWFsaXplKGNsaWVudCkgZmlyc3QuJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTGF6eSBsb2FkOiBvbmx5IGZldGNoIGlmIG5vdCBhbHJlYWR5IGNhY2hlZFxuICAgICAgICBpZiAoIXRoaXMuYWdlbnRDYXJkKSB7XG4gICAgICAgICAgICB0aGlzLmFnZW50Q2FyZCA9IGF3YWl0IHRoaXMuYTJhUHJvdmlkZXIuZmV0Y2hBZ2VudENhcmQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5hZ2VudENhcmQ7XG4gICAgfVxuICAgIGdldENhcmQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFnZW50Q2FyZDtcbiAgICB9XG4gICAgYXN5bmMgZ2V0U2tpbGxzKCkge1xuICAgICAgICBjb25zdCBjYXJkID0gYXdhaXQgdGhpcy5mZXRjaENhcmQoKTsgLy8gTGF6eSBsb2FkXG4gICAgICAgIHJldHVybiBjYXJkPy5za2lsbHMgfHwgW107XG4gICAgfVxuICAgIGFzeW5jIGdldENhcGFiaWxpdGllcygpIHtcbiAgICAgICAgY29uc3QgY2FyZCA9IGF3YWl0IHRoaXMuZmV0Y2hDYXJkKCk7IC8vIExhenkgbG9hZFxuICAgICAgICByZXR1cm4gY2FyZD8uY2FwYWJpbGl0aWVzIHx8IG51bGw7XG4gICAgfVxuICAgIGFzeW5jIHN1cHBvcnRzUHJvdG9jb2woKSB7XG4gICAgICAgIGlmICghdGhpcy5hMmFQcm92aWRlcikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNhcmQgPSBhd2FpdCB0aGlzLmZldGNoQ2FyZCgpO1xuICAgICAgICByZXR1cm4gY2FyZCAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgY2FyZC5za2lsbHMgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgY2FyZC5za2lsbHMubGVuZ3RoID4gMCAmJlxuICAgICAgICAgICAgY2FyZC51cmwgIT09IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgYXN5bmMgZ2V0RW5kcG9pbnQoKSB7XG4gICAgICAgIGlmICghdGhpcy5hMmFQcm92aWRlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBZ2VudCBub3QgaW5pdGlhbGl6ZWQuIENhbGwgaW5pdGlhbGl6ZShjbGllbnQpIGZpcnN0LicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5lbmRwb2ludCkge1xuICAgICAgICAgICAgY29uc3QgZW5kcG9pbnRJbmZvID0gYXdhaXQgdGhpcy5hMmFQcm92aWRlci5nZXRBMkFFbmRwb2ludCgpO1xuICAgICAgICAgICAgaWYgKGVuZHBvaW50SW5mbykge1xuICAgICAgICAgICAgICAgIHRoaXMuZW5kcG9pbnQgPSB7XG4gICAgICAgICAgICAgICAgICAgIHByb3ZpZGVySWQ6IGVuZHBvaW50SW5mby5wcm92aWRlcklkLFxuICAgICAgICAgICAgICAgICAgICB1cmw6IGVuZHBvaW50SW5mby51cmwsXG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogZW5kcG9pbnRJbmZvLm1ldGhvZCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmVuZHBvaW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kIGEgbWVzc2FnZSB0byB0aGUgYWdlbnRcbiAgICAgKi9cbiAgICBhc3luYyBzZW5kTWVzc2FnZShyZXF1ZXN0KSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdbQWdlbnQuc2VuZE1lc3NhZ2VdIFN0YXJ0aW5nIHNlbmRNZXNzYWdlJyk7XG4gICAgICAgIGNvbnNvbGUubG9nKCdbQWdlbnQuc2VuZE1lc3NhZ2VdIEFnZW50IGRhdGE6Jywge1xuICAgICAgICAgICAgYWdlbnRJZDogdGhpcy5kYXRhLmFnZW50SWQsXG4gICAgICAgICAgICBjaGFpbklkOiB0aGlzLmRhdGEuY2hhaW5JZCxcbiAgICAgICAgICAgIGFnZW50TmFtZTogdGhpcy5kYXRhLmFnZW50TmFtZSxcbiAgICAgICAgICAgIGEyYUVuZHBvaW50OiB0aGlzLmRhdGEuYTJhRW5kcG9pbnQsXG4gICAgICAgICAgICBpbml0aWFsaXplZDogdGhpcy5pbml0aWFsaXplZCxcbiAgICAgICAgICAgIGhhc0EyYVByb3ZpZGVyOiAhIXRoaXMuYTJhUHJvdmlkZXIsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIXRoaXMuYTJhUHJvdmlkZXIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1tBZ2VudC5zZW5kTWVzc2FnZV0gQTJBIHByb3ZpZGVyIG5vdCBpbml0aWFsaXplZCcpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBZ2VudCBub3QgaW5pdGlhbGl6ZWQuIENhbGwgaW5pdGlhbGl6ZShjbGllbnQpIGZpcnN0LicpO1xuICAgICAgICB9XG4gICAgICAgIC8vIENoZWNrIGlmIGFnZW50IGhhcyBhIHZhbGlkIEEyQSBlbmRwb2ludFxuICAgICAgICBjb25zb2xlLmxvZygnW0FnZW50LnNlbmRNZXNzYWdlXSBBZ2VudCBhMmFFbmRwb2ludDonLCB0aGlzLmRhdGEuYTJhRW5kcG9pbnQpO1xuICAgICAgICBpZiAoIXRoaXMuZGF0YS5hMmFFbmRwb2ludCkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignW0FnZW50LnNlbmRNZXNzYWdlXSBBZ2VudCBkb2VzIG5vdCBoYXZlIGFuIEEyQSBlbmRwb2ludCBjb25maWd1cmVkJyk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FnZW50IGRvZXMgbm90IGhhdmUgYW4gQTJBIGVuZHBvaW50IGNvbmZpZ3VyZWQuICcgK1xuICAgICAgICAgICAgICAgICdUaGUgYWdlbnQgbXVzdCBoYXZlIGEgdmFsaWQgQTJBIGVuZHBvaW50IFVSTCB0byByZWNlaXZlIG1lc3NhZ2VzLicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnNvbGUubG9nKCdbQWdlbnQuc2VuZE1lc3NhZ2VdIFJlcXVlc3Q6JywgSlNPTi5zdHJpbmdpZnkocmVxdWVzdCwgbnVsbCwgMikpO1xuICAgICAgICAvLyBCdWlsZCBBMkEgcmVxdWVzdCBmb3JtYXRcbiAgICAgICAgY29uc3QgZW5kcG9pbnRJbmZvID0gYXdhaXQgdGhpcy5nZXRFbmRwb2ludCgpO1xuICAgICAgICBpZiAoIWVuZHBvaW50SW5mbykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBZ2VudCBlbmRwb2ludCBub3QgYXZhaWxhYmxlIDEnKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBFeHRyYWN0IGZyb21BZ2VudElkIGZyb20gbWV0YWRhdGEvcGF5bG9hZCBpZiBwcm92aWRlZCwgb3RoZXJ3aXNlIGZhbGxiYWNrIHRvIHBheWxvYWQuYWdlbnRJZCwgZmluYWxseSAnY2xpZW50J1xuICAgICAgICBjb25zdCBwYXlsb2FkRnJvbUFnZW50SWQgPSByZXF1ZXN0LnBheWxvYWQ/LmZyb21BZ2VudElkO1xuICAgICAgICBjb25zdCBmYWxsYmFja0FnZW50SWQgPSByZXF1ZXN0LnBheWxvYWQ/LmFnZW50SWQ7XG4gICAgICAgIGNvbnN0IGZyb21BZ2VudElkID0gcmVxdWVzdC5tZXRhZGF0YT8uZnJvbUFnZW50SWQgfHxcbiAgICAgICAgICAgIHBheWxvYWRGcm9tQWdlbnRJZCB8fFxuICAgICAgICAgICAgZmFsbGJhY2tBZ2VudElkIHx8XG4gICAgICAgICAgICAnY2xpZW50JztcbiAgICAgICAgY29uc3QgYTJhUmVxdWVzdCA9IHtcbiAgICAgICAgICAgIGZyb21BZ2VudElkOiBmcm9tQWdlbnRJZCxcbiAgICAgICAgICAgIHRvQWdlbnRJZDogZW5kcG9pbnRJbmZvLnByb3ZpZGVySWQsXG4gICAgICAgICAgICBtZXNzYWdlOiByZXF1ZXN0Lm1lc3NhZ2UsXG4gICAgICAgICAgICBwYXlsb2FkOiByZXF1ZXN0LnBheWxvYWQsXG4gICAgICAgICAgICBtZXRhZGF0YTogcmVxdWVzdC5tZXRhZGF0YSxcbiAgICAgICAgICAgIHNraWxsSWQ6IHJlcXVlc3Quc2tpbGxJZCxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc29sZS5sb2coJ1tBZ2VudC5zZW5kTWVzc2FnZV0gU2VuZGluZyBBMkEgcmVxdWVzdDonLCBKU09OLnN0cmluZ2lmeShhMmFSZXF1ZXN0LCBudWxsLCAyKSk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5hMmFQcm92aWRlci5zZW5kTWVzc2FnZShhMmFSZXF1ZXN0KTtcbiAgICAgICAgY29uc29sZS5sb2coJ1tBZ2VudC5zZW5kTWVzc2FnZV0gUmVjZWl2ZWQgQTJBIHJlc3BvbnNlOicsIEpTT04uc3RyaW5naWZ5KHJlc3BvbnNlLCBudWxsLCAyKSk7XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVmVyaWZ5IHRoZSBhZ2VudCBieSBzZW5kaW5nIGFuIGF1dGhlbnRpY2F0aW9uIGNoYWxsZW5nZVxuICAgICAqIENyZWF0ZXMgYSBzaWduZWQgY2hhbGxlbmdlIGFuZCBzZW5kcyBpdCB0byB0aGUgYWdlbnQncyBlbmRwb2ludFxuICAgICAqIFRoaXMgd2lsbCBmb3JjZSBhIGZyZXNoIGF1dGhlbnRpY2F0aW9uIGNoYWxsZW5nZSBldmVuIGlmIGFscmVhZHkgYXV0aGVudGljYXRlZFxuICAgICAqIEByZXR1cm5zIHRydWUgaWYgdmVyaWZpY2F0aW9uIHBhc3NlZCwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgICovXG4gICAgYXN5bmMgdmVyaWZ5KCkge1xuICAgICAgICBpZiAoIXRoaXMuYTJhUHJvdmlkZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQWdlbnQgbm90IGluaXRpYWxpemVkLiBDYWxsIGluaXRpYWxpemUoY2xpZW50KSBmaXJzdC4nKTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gR2V0IGVuZHBvaW50IGluZm9cbiAgICAgICAgICAgIGNvbnN0IGVuZHBvaW50SW5mbyA9IGF3YWl0IHRoaXMuZ2V0RW5kcG9pbnQoKTtcbiAgICAgICAgICAgIGlmICghZW5kcG9pbnRJbmZvKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBZ2VudCBlbmRwb2ludCBub3QgYXZhaWxhYmxlIDInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEdldCBhZ2VudCBjYXJkIHRvIGRldGVybWluZSBhdWRpZW5jZSBmb3IgY2hhbGxlbmdlXG4gICAgICAgICAgICBjb25zdCBhZ2VudENhcmQgPSBhd2FpdCB0aGlzLmZldGNoQ2FyZCgpO1xuICAgICAgICAgICAgaWYgKCFhZ2VudENhcmQ/LnByb3ZpZGVyPy51cmwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FnZW50IGNhcmQgVVJMIGlzIHJlcXVpcmVkIGZvciB2ZXJpZmljYXRpb24nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFJlc2V0IGF1dGhlbnRpY2F0aW9uIHN0YXRlIHRvIGZvcmNlIGEgZnJlc2ggY2hhbGxlbmdlXG4gICAgICAgICAgICAvLyBBY2Nlc3MgdGhlIHByaXZhdGUgYXV0aGVudGljYXRlZCBmbGFnIHZpYSB0eXBlIGFzc2VydGlvblxuICAgICAgICAgICAgdGhpcy5hMmFQcm92aWRlci5hdXRoZW50aWNhdGVkID0gZmFsc2U7XG4gICAgICAgICAgICAvLyBDcmVhdGUgYSBzaWduZWQgY2hhbGxlbmdlIHVzaW5nIHRoZSBBMkEgcHJvdG9jb2wgcHJvdmlkZXJcbiAgICAgICAgICAgIC8vIFdlJ2xsIHNlbmQgYSBtaW5pbWFsIG1lc3NhZ2Ugd2l0aCBhdXRoIHRvIHRlc3QgdmVyaWZpY2F0aW9uXG4gICAgICAgICAgICBjb25zdCBhMmFSZXF1ZXN0ID0ge1xuICAgICAgICAgICAgICAgIGZyb21BZ2VudElkOiAnY2xpZW50JyxcbiAgICAgICAgICAgICAgICB0b0FnZW50SWQ6IGVuZHBvaW50SW5mby5wcm92aWRlcklkLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICd2ZXJpZnknLCAvLyBNaW5pbWFsIG1lc3NhZ2UgZm9yIHZlcmlmaWNhdGlvblxuICAgICAgICAgICAgICAgIHBheWxvYWQ6IHt9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIFRoZSBzZW5kTWVzc2FnZSB3aWxsIGF1dG9tYXRpY2FsbHkgY3JlYXRlIGFuZCBpbmNsdWRlIGF1dGggY2hhbGxlbmdlXG4gICAgICAgICAgICAvLyBzaW5jZSB3ZSByZXNldCBhdXRoZW50aWNhdGVkIHRvIGZhbHNlXG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuYTJhUHJvdmlkZXIuc2VuZE1lc3NhZ2UoYTJhUmVxdWVzdCk7XG4gICAgICAgICAgICAvLyBJZiB0aGUgcmVzcG9uc2UgaXMgc3VjY2Vzc2Z1bCBhbmQgZG9lc24ndCBjb250YWluIGF1dGhlbnRpY2F0aW9uIGVycm9ycyxcbiAgICAgICAgICAgIC8vIHZlcmlmaWNhdGlvbiBwYXNzZWRcbiAgICAgICAgICAgIGlmIChyZXNwb25zZS5zdWNjZXNzID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIGl0J3MgYW4gYXV0aGVudGljYXRpb24gZXJyb3JcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UuZXJyb3I/LmluY2x1ZGVzKCdhdXRoZW50aWNhdGlvbicpIHx8XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLmVycm9yPy5pbmNsdWRlcygnQXV0aGVudGljYXRpb24gZmFpbGVkJykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBPdGhlciBlcnJvcnMgbWlnaHQgYmUgYWNjZXB0YWJsZSAoZS5nLiwgYWdlbnQgZG9lc24ndCB1bmRlcnN0YW5kIHRoZSBtZXNzYWdlKVxuICAgICAgICAgICAgICAgIC8vIGJ1dCB2ZXJpZmljYXRpb24gaXRzZWxmIHBhc3NlZCBpZiBubyBhdXRoIGVycm9yXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTdWNjZXNzIHJlc3BvbnNlIG1lYW5zIHZlcmlmaWNhdGlvbiBwYXNzZWRcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgLy8gSWYgZXJyb3IgY29udGFpbnMgYXV0aGVudGljYXRpb24gZmFpbHVyZSwgdmVyaWZpY2F0aW9uIGZhaWxlZFxuICAgICAgICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpO1xuICAgICAgICAgICAgaWYgKGVycm9yTWVzc2FnZS5pbmNsdWRlcygnYXV0aGVudGljYXRpb24nKSB8fFxuICAgICAgICAgICAgICAgIGVycm9yTWVzc2FnZS5pbmNsdWRlcygnQXV0aGVudGljYXRpb24gZmFpbGVkJykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBPdGhlciBlcnJvcnMgbWlnaHQgaW5kaWNhdGUgdmVyaWZpY2F0aW9uIGZhaWxlZFxuICAgICAgICAgICAgY29uc29sZS5lcnJvcignVmVyaWZpY2F0aW9uIGVycm9yOicsIGVycm9yKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXF1ZXN0IGEgZmVlZGJhY2sgYXV0aG9yaXphdGlvbiB0b2tlbiBmcm9tIHRoZSBhZ2VudCdzIEEyQSBlbmRwb2ludC5cbiAgICAgKiBBdXRvbWF0aWNhbGx5IHZlcmlmaWVzIHRoZSBhZ2VudCAodW5sZXNzIHNraXBWZXJpZnk9dHJ1ZSkgYmVmb3JlIHNlbmRpbmcgdGhlIHJlcXVlc3RBdXRoIG1lc3NhZ2UuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0RmVlZGJhY2tBdXRoKHBhcmFtcykge1xuICAgICAgICBjb25zb2xlLmxvZygnW0FnZW50LmdldEZlZWRiYWNrQXV0aF0gU3RhcnRpbmcgZ2V0RmVlZGJhY2tBdXRoJyk7XG4gICAgICAgIGNvbnNvbGUubG9nKCdbQWdlbnQuZ2V0RmVlZGJhY2tBdXRoXSBBZ2VudCBkYXRhOicsIHtcbiAgICAgICAgICAgIGFnZW50SWQ6IHRoaXMuZGF0YS5hZ2VudElkLFxuICAgICAgICAgICAgY2hhaW5JZDogdGhpcy5kYXRhLmNoYWluSWQsXG4gICAgICAgICAgICBhZ2VudE5hbWU6IHRoaXMuZGF0YS5hZ2VudE5hbWUsXG4gICAgICAgICAgICBhMmFFbmRwb2ludDogdGhpcy5kYXRhLmEyYUVuZHBvaW50LFxuICAgICAgICAgICAgYWN0aXZlOiB0aGlzLmRhdGEuYWN0aXZlLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc29sZS5sb2coJ1tBZ2VudC5nZXRGZWVkYmFja0F1dGhdIFBhcmFtczonLCBKU09OLnN0cmluZ2lmeShwYXJhbXMsIG51bGwsIDIpKTtcbiAgICAgICAgLy8gQ2hlY2sgaWYgYWdlbnQgaXMgYWN0aXZlIGJlZm9yZSBhdHRlbXB0aW5nIHRvIGNvbnRhY3QgQTJBIGVuZHBvaW50XG4gICAgICAgIC8vIE9ubHkgc2tpcCBpZiBleHBsaWNpdGx5IGZhbHNlOyB1bmRlZmluZWQvbnVsbCBtZWFucyBhY3RpdmUgYnkgZGVmYXVsdFxuICAgICAgICBpZiAodGhpcy5kYXRhLmFjdGl2ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignW0FnZW50LmdldEZlZWRiYWNrQXV0aF0gQWdlbnQgaXMgbm90IGFjdGl2ZSwgc2tpcHBpbmcgQTJBIHJlcXVlc3QnKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQWdlbnQgaXMgbm90IGFjdGl2ZS4gQ2Fubm90IHJlcXVlc3QgZmVlZGJhY2sgYXV0aG9yaXphdGlvbiBmb3IgaW5hY3RpdmUgYWdlbnRzLicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNsaWVudEFkZHJlc3MgPSBwYXJhbXMuY2xpZW50QWRkcmVzcz8udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKCFjbGllbnRBZGRyZXNzIHx8XG4gICAgICAgICAgICAhY2xpZW50QWRkcmVzcy5zdGFydHNXaXRoKCcweCcpIHx8XG4gICAgICAgICAgICBjbGllbnRBZGRyZXNzLmxlbmd0aCAhPT0gNDIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY2xpZW50QWRkcmVzcyBtdXN0IGJlIGEgMHgtcHJlZml4ZWQgMjAtYnl0ZSBhZGRyZXNzJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzb2x2ZWRDaGFpbklkID0gdHlwZW9mIHBhcmFtcy5jaGFpbklkID09PSAnbnVtYmVyJ1xuICAgICAgICAgICAgPyBwYXJhbXMuY2hhaW5JZFxuICAgICAgICAgICAgOiBOdW1iZXIuaXNGaW5pdGUodGhpcy5kYXRhPy5jaGFpbklkKVxuICAgICAgICAgICAgICAgID8gTnVtYmVyKHRoaXMuZGF0YS5jaGFpbklkKVxuICAgICAgICAgICAgICAgIDogREVGQVVMVF9DSEFJTl9JRDtcbiAgICAgICAgY29uc3QgcmVzb2x2ZUFnZW50SWQgPSAodmFsdWUpID0+IHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEJpZ0ludCh2YWx1ZSkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdHJpbmdpZmllZCA9IFN0cmluZyh2YWx1ZSkudHJpbSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBzdHJpbmdpZmllZC5sZW5ndGggPiAwID8gc3RyaW5naWZpZWQgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlc29sdmVkQWdlbnRJZCA9IHJlc29sdmVBZ2VudElkKHBhcmFtcy5hZ2VudElkKSA/PyByZXNvbHZlQWdlbnRJZCh0aGlzLmRhdGEuYWdlbnRJZCk7XG4gICAgICAgIGNvbnNvbGUubG9nKCdbQWdlbnQuZ2V0RmVlZGJhY2tBdXRoXSBSZXNvbHZlZCBhZ2VudElkOicsIHJlc29sdmVkQWdlbnRJZCk7XG4gICAgICAgIGNvbnNvbGUubG9nKCdbQWdlbnQuZ2V0RmVlZGJhY2tBdXRoXSBSZXNvbHZlZCBjaGFpbklkOicsIHJlc29sdmVkQ2hhaW5JZCk7XG4gICAgICAgIGlmICghcmVzb2x2ZWRBZ2VudElkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FnZW50IElEIGlzIHJlcXVpcmVkIHRvIHJlcXVlc3QgZmVlZGJhY2sgYXV0aC4nKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDb21tZW50ZWQgb3V0IHZlcmlmaWNhdGlvbiAtIGFsbG93IEEyQSBlbmRwb2ludCB0byByZXNwb25kIHdpdGhvdXQgdmVyaWZpY2F0aW9uXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdbQWdlbnQuZ2V0RmVlZGJhY2tBdXRoXSBWZXJpZnlpbmcgYWdlbnQuLi4nKTtcbiAgICAgICAgLy8gY29uc3QgdmVyaWZpZWQgPSBhd2FpdCB0aGlzLnZlcmlmeSgpO1xuICAgICAgICAvLyBjb25zb2xlLmxvZygnW0FnZW50LmdldEZlZWRiYWNrQXV0aF0gQWdlbnQgdmVyaWZpZWQ6JywgdmVyaWZpZWQpO1xuICAgICAgICAvLyBpZiAoIXZlcmlmaWVkKSB7XG4gICAgICAgIC8vICAgdGhyb3cgbmV3IEVycm9yKCdBZ2VudCB2ZXJpZmljYXRpb24gZmFpbGVkIGJlZm9yZSByZXF1ZXN0aW5nIGZlZWRiYWNrIGF1dGguJyk7XG4gICAgICAgIC8vIH1cbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHtcbiAgICAgICAgICAgIGNsaWVudEFkZHJlc3MsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IG51bWVyaWNBZ2VudElkID0gTnVtYmVyLnBhcnNlSW50KHJlc29sdmVkQWdlbnRJZCwgMTApO1xuICAgICAgICBwYXlsb2FkLmFnZW50SWQgPSBOdW1iZXIuaXNGaW5pdGUobnVtZXJpY0FnZW50SWQpXG4gICAgICAgICAgICA/IG51bWVyaWNBZ2VudElkXG4gICAgICAgICAgICA6IHJlc29sdmVkQWdlbnRJZDtcbiAgICAgICAgaWYgKHR5cGVvZiBwYXJhbXMuaW5kZXhMaW1pdCA9PT0gJ251bWJlcicgJiYgcGFyYW1zLmluZGV4TGltaXQgPiAwKSB7XG4gICAgICAgICAgICBwYXlsb2FkLmluZGV4TGltaXQgPSBwYXJhbXMuaW5kZXhMaW1pdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHBhcmFtcy5leHBpcnlTZWNvbmRzID09PSAnbnVtYmVyJyAmJiBwYXJhbXMuZXhwaXJ5U2Vjb25kcyA+IDApIHtcbiAgICAgICAgICAgIHBheWxvYWQuZXhwaXJ5U2Vjb25kcyA9IHBhcmFtcy5leHBpcnlTZWNvbmRzO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZvcndhcmQgb3B0aW9uYWwgY2xpZW50LWJ1aWx0IGRlbGVnYXRpb24gU0FSIHBheWxvYWQgKEVSQy04MDkyKSB0byB0aGUgcHJvdmlkZXIuXG4gICAgICAgIGlmIChwYXJhbXMuZGVsZWdhdGlvblNhciAmJiB0eXBlb2YgcGFyYW1zLmRlbGVnYXRpb25TYXIgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBwYXlsb2FkLmRlbGVnYXRpb25TYXIgPSBwYXJhbXMuZGVsZWdhdGlvblNhcjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBza2lsbElkID0gcGFyYW1zLnNraWxsSWQgPz8gJ29hc2Y6dHJ1c3QuZmVlZGJhY2suYXV0aG9yaXphdGlvbic7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBwYXJhbXMubWVzc2FnZSA/PyAnUmVxdWVzdCBmZWVkYmFjayBhdXRob3JpemF0aW9uJztcbiAgICAgICAgY29uc3QgbWV0YWRhdGEgPSB7XG4gICAgICAgICAgICAuLi4ocGFyYW1zLm1ldGFkYXRhIHx8IHt9KSxcbiAgICAgICAgICAgIHJlcXVlc3RUeXBlOiAnZmVlZGJhY2tBdXRoJyxcbiAgICAgICAgICAgIGFnZW50SWQ6IHJlc29sdmVkQWdlbnRJZCxcbiAgICAgICAgICAgIGNoYWluSWQ6IHJlc29sdmVkQ2hhaW5JZCxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgbWVzc2FnZVJlcXVlc3QgPSB7XG4gICAgICAgICAgICBtZXNzYWdlLFxuICAgICAgICAgICAgcGF5bG9hZCxcbiAgICAgICAgICAgIG1ldGFkYXRhLFxuICAgICAgICAgICAgc2tpbGxJZCxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnNlbmRNZXNzYWdlKG1lc3NhZ2VSZXF1ZXN0KTtcbiAgICAgICAgaWYgKCFyZXNwb25zZT8uc3VjY2Vzcykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHJlc3BvbnNlPy5lcnJvciB8fCAnUHJvdmlkZXIgcmVqZWN0ZWQgZmVlZGJhY2sgYXV0aCByZXF1ZXN0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU29tZSBwcm92aWRlcnMgcmVzcG9uZCB3aXRoIHBheWxvYWQgZmllbGRzIGF0IHRoZSB0b3AtbGV2ZWwgKGUuZy4geyBzdWNjZXNzLCBmZWVkYmFja0F1dGhJZCwgLi4uIH0pXG4gICAgICAgIC8vIHJhdGhlciB0aGFuIG5lc3RpbmcgdW5kZXIgYHJlc3BvbnNlYC4gU3VwcG9ydCBib3RoIHNoYXBlcy5cbiAgICAgICAgY29uc3QgcHJvdmlkZXJQYXlsb2FkID0gKHJlc3BvbnNlLnJlc3BvbnNlIHx8IHJlc3BvbnNlIHx8IHt9KTtcbiAgICAgICAgY29uc3QgZmVlZGJhY2tBdXRoSWQgPSBwcm92aWRlclBheWxvYWQuZmVlZGJhY2tBdXRoID8/XG4gICAgICAgICAgICBwcm92aWRlclBheWxvYWQuZmVlZGJhY2tBdXRoSWQgPz9cbiAgICAgICAgICAgIHByb3ZpZGVyUGF5bG9hZC5mZWVkYmFja0F1dGhJRCA/P1xuICAgICAgICAgICAgbnVsbDtcbiAgICAgICAgaWYgKCFmZWVkYmFja0F1dGhJZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQcm92aWRlciByZXNwb25zZSBkaWQgbm90IGluY2x1ZGUgZmVlZGJhY2tBdXRoJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGZlZWRiYWNrQXV0aElkLFxuICAgICAgICAgICAgYWdlbnRJZDogcmVzb2x2ZWRBZ2VudElkLFxuICAgICAgICAgICAgY2hhaW5JZDogcmVzb2x2ZWRDaGFpbklkLFxuICAgICAgICAgICAgcGF5bG9hZDogcHJvdmlkZXJQYXlsb2FkLFxuICAgICAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCBTZXNzaW9uUGFja2FnZSBmb3IgdGhpcyBhZ2VudCBpbnN0YW5jZS5cbiAgICAgKiBUaGlzIGFsbG93cyBkeW5hbWljYWxseSBzZXR0aW5nIHRoZSBTZXNzaW9uUGFja2FnZSBiYXNlZCBvbiByZXF1ZXN0IGNvbnRleHRcbiAgICAgKiAoZS5nLiwgc3ViZG9tYWluLWJhc2VkIHJvdXRpbmcgaW4gcHJvdmlkZXIgYXBwcykuXG4gICAgICpcbiAgICAgKiBUaGlzIGlzIHNlcnZlci1zaWRlIG9ubHkgYW5kIHNwZWNpZmljIHRvIHByb3ZpZGVyQXBwIGNvbmZpZ3VyYXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc2Vzc2lvblBhY2thZ2UgLSBUaGUgU2Vzc2lvblBhY2thZ2UgdG8gdXNlIGZvciB0aGlzIGFnZW50IGluc3RhbmNlXG4gICAgICovXG4gICAgc2V0U2Vzc2lvblBhY2thZ2Uoc2Vzc2lvblBhY2thZ2UpIHtcbiAgICAgICAgdGhpcy5zZXNzaW9uUGFja2FnZSA9IHNlc3Npb25QYWNrYWdlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBCdWlsZCBhIHByb3ZpZGVyQXBwLWxpa2Ugc3RydWN0dXJlIGZyb20gYSBTZXNzaW9uUGFja2FnZS5cbiAgICAgKiBUaGlzIGlzIHVzZWQgd2hlbiBhIFNlc3Npb25QYWNrYWdlIGlzIHNldCBvbiB0aGUgYWdlbnQgaW5zdGFuY2UuXG4gICAgICovXG4gICAgYXN5bmMgYnVpbGRQcm92aWRlckFwcEZyb21TZXNzaW9uUGFja2FnZShzZXNzaW9uUGFja2FnZSkge1xuICAgICAgICBjb25zdCB7IGJ1aWxkRGVsZWdhdGlvblNldHVwLCBidWlsZEFnZW50QWNjb3VudEZyb21TZXNzaW9uIH0gPSBhd2FpdCBpbXBvcnQoJy4vc2Vzc2lvblBhY2thZ2UnKTtcbiAgICAgICAgY29uc3QgZGVsZWdhdGlvblNldHVwID0gYnVpbGREZWxlZ2F0aW9uU2V0dXAoc2Vzc2lvblBhY2thZ2UpO1xuICAgICAgICBjb25zdCBhZ2VudEFjY291bnQgPSBhd2FpdCBidWlsZEFnZW50QWNjb3VudEZyb21TZXNzaW9uKHNlc3Npb25QYWNrYWdlKTtcbiAgICAgICAgLy8gQ3JlYXRlIHdhbGxldCBjbGllbnQgZm9yIGFnZW50XG4gICAgICAgIGNvbnN0IHsgY3JlYXRlV2FsbGV0Q2xpZW50LCBodHRwOiBodHRwVHJhbnNwb3J0IH0gPSBhd2FpdCBpbXBvcnQoJ3ZpZW0nKTtcbiAgICAgICAgY29uc3Qgd2FsbGV0Q2xpZW50ID0gY3JlYXRlV2FsbGV0Q2xpZW50KHtcbiAgICAgICAgICAgIGFjY291bnQ6IGFnZW50QWNjb3VudCxcbiAgICAgICAgICAgIGNoYWluOiBkZWxlZ2F0aW9uU2V0dXAuY2hhaW4sXG4gICAgICAgICAgICB0cmFuc3BvcnQ6IGh0dHBUcmFuc3BvcnQoZGVsZWdhdGlvblNldHVwLnJwY1VybCksXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc2Vzc2lvblBhY2thZ2UsXG4gICAgICAgICAgICBhZ2VudEFjY291bnQsXG4gICAgICAgICAgICBwdWJsaWNDbGllbnQ6IGRlbGVnYXRpb25TZXR1cC5wdWJsaWNDbGllbnQsXG4gICAgICAgICAgICB3YWxsZXRDbGllbnQ6IHdhbGxldENsaWVudCxcbiAgICAgICAgICAgIGFnZW50SWQ6IEJpZ0ludChzZXNzaW9uUGFja2FnZS5hZ2VudElkKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSXNzdWUgYSBmZWVkYmFjayBhdXRob3JpemF0aW9uIG9uIGJlaGFsZiBvZiB0aGlzIGFnZW50IHVzaW5nIHRoZSBwcm92aWRlciBhcHAncyBzaWduZXIuXG4gICAgICogSWYgYSBTZXNzaW9uUGFja2FnZSBpcyBzZXQgb24gdGhpcyBhZ2VudCBpbnN0YW5jZSwgaXQgd2lsbCBiZSB1c2VkIGluc3RlYWQgb2YgdGhlXG4gICAgICogc2luZ2xldG9uIHByb3ZpZGVyQXBwLiBUaGlzIGFsbG93cyBkeW5hbWljIFNlc3Npb25QYWNrYWdlIHNlbGVjdGlvbiBiYXNlZCBvbiByZXF1ZXN0IGNvbnRleHQuXG4gICAgICovXG4gICAgYXN5bmMgcmVxdWVzdEF1dGgocGFyYW1zKSB7XG4gICAgICAgIC8vIFVzZSBTZXNzaW9uUGFja2FnZSBmcm9tIGFnZW50IGluc3RhbmNlIGlmIHNldCwgb3RoZXJ3aXNlIHVzZSBzaW5nbGV0b24gcHJvdmlkZXJBcHBcbiAgICAgICAgbGV0IHByb3ZpZGVyQXBwO1xuICAgICAgICBpZiAodGhpcy5zZXNzaW9uUGFja2FnZSkge1xuICAgICAgICAgICAgLy8gQnVpbGQgcHJvdmlkZXJBcHAgZnJvbSB0aGUgU2Vzc2lvblBhY2thZ2Ugc2V0IG9uIHRoaXMgYWdlbnQgaW5zdGFuY2VcbiAgICAgICAgICAgIHByb3ZpZGVyQXBwID0gYXdhaXQgdGhpcy5idWlsZFByb3ZpZGVyQXBwRnJvbVNlc3Npb25QYWNrYWdlKHRoaXMuc2Vzc2lvblBhY2thZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gRmFsbCBiYWNrIHRvIHNpbmdsZXRvbiBwcm92aWRlckFwcFxuICAgICAgICAgICAgY29uc3Qgc2luZ2xldG9uQXBwID0gYXdhaXQgZ2V0UHJvdmlkZXJBcHAoKTtcbiAgICAgICAgICAgIGlmICghc2luZ2xldG9uQXBwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwcm92aWRlciBhcHAgbm90IGluaXRpYWxpemVkLiBFaXRoZXIgc2V0IGEgU2Vzc2lvblBhY2thZ2Ugb24gdGhlIGFnZW50IGluc3RhbmNlIG9yIGNvbmZpZ3VyZSBBR0VOVElDX1RSVVNUX1NFU1NJT05fUEFDS0FHRV9QQVRIIGVudmlyb25tZW50IHZhcmlhYmxlLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJvdmlkZXJBcHAgPSBzaW5nbGV0b25BcHA7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2xpZW50QWRkcmVzcyA9IHBhcmFtcy5jbGllbnRBZGRyZXNzO1xuICAgICAgICBpZiAoIWNsaWVudEFkZHJlc3MgfHxcbiAgICAgICAgICAgIHR5cGVvZiBjbGllbnRBZGRyZXNzICE9PSAnc3RyaW5nJyB8fFxuICAgICAgICAgICAgIWNsaWVudEFkZHJlc3Muc3RhcnRzV2l0aCgnMHgnKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjbGllbnRBZGRyZXNzIG11c3QgYmUgYSAweC1wcmVmaXhlZCBhZGRyZXNzJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYWdlbnRJZCA9IHBhcmFtcy5hZ2VudElkXG4gICAgICAgICAgICA/IEJpZ0ludChwYXJhbXMuYWdlbnRJZClcbiAgICAgICAgICAgIDogdGhpcy5kYXRhLmFnZW50SWRcbiAgICAgICAgICAgICAgICA/IEJpZ0ludCh0aGlzLmRhdGEuYWdlbnRJZClcbiAgICAgICAgICAgICAgICA6IHByb3ZpZGVyQXBwLmFnZW50SWQ7XG4gICAgICAgIGNvbnN0IGlzc3VlZCA9IGF3YWl0IHRoaXMuY2xpZW50LmNyZWF0ZUZlZWRiYWNrQXV0aFdpdGhEZWxlZ2F0aW9uKHtcbiAgICAgICAgICAgIHB1YmxpY0NsaWVudDogcHJvdmlkZXJBcHAucHVibGljQ2xpZW50LFxuICAgICAgICAgICAgYWdlbnRJZCxcbiAgICAgICAgICAgIGNsaWVudEFkZHJlc3MsXG4gICAgICAgICAgICBzaWduZXI6IHByb3ZpZGVyQXBwLmFnZW50QWNjb3VudCxcbiAgICAgICAgICAgIHdhbGxldENsaWVudDogcHJvdmlkZXJBcHAud2FsbGV0Q2xpZW50LFxuICAgICAgICAgICAgZXhwaXJ5U2Vjb25kczogcGFyYW1zLmV4cGlyeVNlY29uZHMsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZmVlZGJhY2tBdXRoOiBpc3N1ZWQuZmVlZGJhY2tBdXRoLFxuICAgICAgICAgICAgZGVsZWdhdGlvbkFzc29jaWF0aW9uOiBpc3N1ZWQuZGVsZWdhdGlvbkFzc29jaWF0aW9uLFxuICAgICAgICAgICAgYWdlbnRJZDogYWdlbnRJZC50b1N0cmluZygpLFxuICAgICAgICAgICAgY2xpZW50QWRkcmVzcyxcbiAgICAgICAgICAgIHNraWxsOiBwYXJhbXMuc2tpbGxJZCB8fCAnb2FzZjp0cnVzdC5mZWVkYmFjay5hdXRob3JpemF0aW9uJyxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYXN5bmMgYnVpbGRGZWVkYmFja1N1Ym1pc3Npb24ocGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IGFnZW50SWQgPSBwYXJhbXMuYWdlbnRJZCA/PyAodGhpcy5kYXRhLmFnZW50SWQgPyB0aGlzLmRhdGEuYWdlbnRJZC50b1N0cmluZygpIDogdW5kZWZpbmVkKTtcbiAgICAgICAgaWYgKCFhZ2VudElkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FnZW50SWQgaXMgcmVxdWlyZWQuIFByb3ZpZGUgaXQgaW4gcGFyYW1zIG9yIGVuc3VyZSBhZ2VudCBoYXMgYWdlbnRJZCBpbiBkYXRhLicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNoYWluSWQgPSB0aGlzLmRhdGE/LmNoYWluSWQgJiYgTnVtYmVyLmlzRmluaXRlKHRoaXMuZGF0YS5jaGFpbklkKVxuICAgICAgICAgICAgPyBOdW1iZXIodGhpcy5kYXRhLmNoYWluSWQpXG4gICAgICAgICAgICA6IERFRkFVTFRfQ0hBSU5fSUQ7XG4gICAgICAgIGNvbnN0IHNjb3JlID0gTnVtYmVyKHBhcmFtcy5zY29yZSA/PyAwKTtcbiAgICAgICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoc2NvcmUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Njb3JlIG11c3QgYmUgYSB2YWxpZCBudW1iZXIgYmV0d2VlbiAwIGFuZCAxMDAnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBub3JtYWxpemVkU2NvcmUgPSBNYXRoLm1heCgwLCBNYXRoLm1pbigxMDAsIE1hdGgucm91bmQoc2NvcmUpKSk7XG4gICAgICAgIGNvbnN0IGZlZWRiYWNrQXV0aCA9IHBhcmFtcy5mZWVkYmFja0F1dGg7XG4gICAgICAgIGlmICghZmVlZGJhY2tBdXRoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZlZWRiYWNrQXV0aCBpcyByZXF1aXJlZCB0byBzdWJtaXQgZmVlZGJhY2snKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBQcmVmZXIgYW4gZXhwbGljaXQgY2xpZW50QWRkcmVzcyBmcm9tIHBhcmFtcyAoZS5nLiBicm93c2VyIHdhbGxldCAvIFdlYjNBdXRoKS5cbiAgICAgICAgLy8gT25seSBmYWxsIGJhY2sgdG8gQ2xpZW50QXBwIChzZXJ2ZXItc2lkZSBwcml2YXRlIGtleSkgd2hlbiBjbGllbnRBZGRyZXNzIGlzIG5vdCBwcm92aWRlZC5cbiAgICAgICAgbGV0IGNsaWVudEFkZHJlc3NIZXggPSBwYXJhbXMuY2xpZW50QWRkcmVzcztcbiAgICAgICAgaWYgKCFjbGllbnRBZGRyZXNzSGV4KSB7XG4gICAgICAgICAgICBjb25zdCB7IGdldENsaWVudEFwcCB9ID0gYXdhaXQgaW1wb3J0KCcuLi91c2VyQXBwcy9jbGllbnRBcHAnKTtcbiAgICAgICAgICAgIGNvbnN0IGNsaWVudEFwcCA9IGF3YWl0IGdldENsaWVudEFwcCgpO1xuICAgICAgICAgICAgY2xpZW50QWRkcmVzc0hleCA9IGNsaWVudEFwcD8uYWRkcmVzcztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNsaWVudEFkZHJlc3NIZXgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY2xpZW50QWRkcmVzcyBpcyByZXF1aXJlZCB0byBzdWJtaXQgZmVlZGJhY2snKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgYWdlbnRSZWdpc3RyeSA9ICcnO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgaWRlbnRpdHlSZWdpc3RyeSA9IHJlcXVpcmVDaGFpbkVudlZhcignQUdFTlRJQ19UUlVTVF9JREVOVElUWV9SRUdJU1RSWScsIGNoYWluSWQpO1xuICAgICAgICAgICAgYWdlbnRSZWdpc3RyeSA9IGBlaXAxNTU6JHtjaGFpbklkfToke2lkZW50aXR5UmVnaXN0cnl9YDtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignW0FnZW50LmJ1aWxkRmVlZGJhY2tTdWJtaXNzaW9uXSBGYWlsZWQgdG8gcmVzb2x2ZSBBR0VOVElDX1RSVVNUX0lERU5USVRZX1JFR0lTVFJZOyBmZWVkYmFja0ZpbGUuYWdlbnRSZWdpc3RyeSB3aWxsIGJlIGVtcHR5OicsIGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjbGllbnRBZGRyZXNzQ2FpcCA9IGBlaXAxNTU6JHtjaGFpbklkfToke2NsaWVudEFkZHJlc3NIZXh9YDtcbiAgICAgICAgY29uc3QgZmVlZGJhY2tGaWxlID0ge1xuICAgICAgICAgICAgYWdlbnRSZWdpc3RyeSxcbiAgICAgICAgICAgIGFnZW50SWQ6IE51bWJlci5wYXJzZUludChhZ2VudElkLCAxMCkgfHwgMCxcbiAgICAgICAgICAgIGNsaWVudEFkZHJlc3M6IGNsaWVudEFkZHJlc3NDYWlwIHx8IGNsaWVudEFkZHJlc3NIZXgsXG4gICAgICAgICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgIGZlZWRiYWNrQXV0aCxcbiAgICAgICAgICAgIHNjb3JlOiBub3JtYWxpemVkU2NvcmUsXG4gICAgICAgIH07XG4gICAgICAgIGlmIChwYXJhbXMudGFnMSlcbiAgICAgICAgICAgIGZlZWRiYWNrRmlsZS50YWcxID0gcGFyYW1zLnRhZzE7XG4gICAgICAgIGlmIChwYXJhbXMudGFnMilcbiAgICAgICAgICAgIGZlZWRiYWNrRmlsZS50YWcyID0gcGFyYW1zLnRhZzI7XG4gICAgICAgIGlmIChwYXJhbXMuc2tpbGwpXG4gICAgICAgICAgICBmZWVkYmFja0ZpbGUuc2tpbGwgPSBwYXJhbXMuc2tpbGw7XG4gICAgICAgIGlmIChwYXJhbXMuY29udGV4dClcbiAgICAgICAgICAgIGZlZWRiYWNrRmlsZS5jb250ZXh0ID0gcGFyYW1zLmNvbnRleHQ7XG4gICAgICAgIGlmIChwYXJhbXMuY2FwYWJpbGl0eSlcbiAgICAgICAgICAgIGZlZWRiYWNrRmlsZS5jYXBhYmlsaXR5ID0gcGFyYW1zLmNhcGFiaWxpdHk7XG4gICAgICAgIGxldCBmZWVkYmFja1VyaUZyb21JcGZzO1xuICAgICAgICBsZXQgZmVlZGJhY2tIYXNoRnJvbUlwZnM7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBpcGZzID0gZ2V0SVBGU1N0b3JhZ2UoKTtcbiAgICAgICAgICAgIGNvbnN0IHNlcmlhbGl6ZWQgPSBKU09OLnN0cmluZ2lmeShmZWVkYmFja0ZpbGUpO1xuICAgICAgICAgICAgY29uc3QgdXBsb2FkUmVzdWx0ID0gYXdhaXQgaXBmcy51cGxvYWQoc2VyaWFsaXplZCwgJ2ZlZWRiYWNrLmpzb24nKTtcbiAgICAgICAgICAgIGZlZWRiYWNrVXJpRnJvbUlwZnMgPSB1cGxvYWRSZXN1bHQudG9rZW5Vcmk7XG4gICAgICAgICAgICBmZWVkYmFja0hhc2hGcm9tSXBmcyA9IGV0aGVycy5rZWNjYWsyNTYoZXRoZXJzLnRvVXRmOEJ5dGVzKHNlcmlhbGl6ZWQpKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignW0FnZW50LmJ1aWxkRmVlZGJhY2tTdWJtaXNzaW9uXSBGYWlsZWQgdG8gdXBsb2FkIEZlZWRiYWNrRmlsZSB0byBJUEZTOyBjb250aW51aW5nIHdpdGhvdXQgZmVlZGJhY2tVcmkvZmVlZGJhY2tIYXNoOicsIGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBnaXZlUGFyYW1zID0ge1xuICAgICAgICAgICAgYWdlbnQ6IGFnZW50SWQsXG4gICAgICAgICAgICBzY29yZTogbm9ybWFsaXplZFNjb3JlLFxuICAgICAgICAgICAgZmVlZGJhY2s6IHBhcmFtcy5mZWVkYmFjayA/PyAnRmVlZGJhY2sgc3VibWl0dGVkIHZpYSBBZ2VudGljIFRydXN0IGFkbWluIGFwcC4nLFxuICAgICAgICAgICAgdGFnMTogcGFyYW1zLnRhZzEsXG4gICAgICAgICAgICB0YWcyOiBwYXJhbXMudGFnMixcbiAgICAgICAgICAgIC8vIFVwZGF0ZWQgcmVwdXRhdGlvbiBBQkkgaW5jbHVkZXMgYW4gYGVuZHBvaW50YCBzdHJpbmcuXG4gICAgICAgICAgICAvLyBJTVBPUlRBTlQ6IEtlZXAgdGhpcyBzaG9ydCBhbmQgc3RhYmxlLiBTb21lIGRlcGxveWVkIHJlZ2lzdHJpZXMgYXJlIHN0cmljdCAoYW5kIHdpbGwgcmV2ZXJ0KVxuICAgICAgICAgICAgLy8gb24gdW5leHBlY3RlZCBsb25nIFVSTHMgb3IgdmFsdWVzIGhlcmUuIFByZWZlciB0aGUgYWdlbnQncyBBMkEgZW5kcG9pbnQ7IG90aGVyd2lzZSBmYWxsIGJhY2tcbiAgICAgICAgICAgIC8vIHRvIGEgYmVzdC1lZmZvcnQgb3JpZ2luIChubyBwYXRoL3F1ZXJ5KSBmcm9tIGFueSBVUkwtbGlrZSB2YWx1ZSB3ZSBoYXZlLlxuICAgICAgICAgICAgZW5kcG9pbnQ6ICgoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgYTJhID0gdHlwZW9mIHRoaXMuZGF0YT8uYTJhRW5kcG9pbnQgPT09ICdzdHJpbmcnID8gU3RyaW5nKHRoaXMuZGF0YS5hMmFFbmRwb2ludCkgOiAnJztcbiAgICAgICAgICAgICAgICBpZiAoYTJhLnRyaW0oKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGEyYS50cmltKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmF3ID0gdHlwZW9mIHRoaXM/LmVuZHBvaW50Py51cmwgPT09ICdzdHJpbmcnID8gU3RyaW5nKHRoaXMuZW5kcG9pbnQudXJsKSA6ICcnO1xuICAgICAgICAgICAgICAgIGlmICghcmF3LnRyaW0oKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHUgPSBuZXcgVVJMKHJhdy50cmltKCkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYCR7dS5wcm90b2NvbH0vLyR7dS5ob3N0fWA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKCksXG4gICAgICAgICAgICBmZWVkYmFja1VyaTogZmVlZGJhY2tVcmlGcm9tSXBmcyxcbiAgICAgICAgICAgIGZlZWRiYWNrSGFzaDogZmVlZGJhY2tIYXNoRnJvbUlwZnMsXG4gICAgICAgICAgICBhZ2VudElkLFxuICAgICAgICAgICAgZmVlZGJhY2tBdXRoLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY2hhaW5JZCxcbiAgICAgICAgICAgIGdpdmVQYXJhbXMsXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN1Ym1pdCBjbGllbnQgZmVlZGJhY2sgdG8gdGhlIHJlcHV0YXRpb24gY29udHJhY3QuXG4gICAgICovXG4gICAgYXN5bmMgZ2l2ZUZlZWRiYWNrKHBhcmFtcykge1xuICAgICAgICBpZiAoIXBhcmFtcy5mZWVkYmFja0F1dGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZmVlZGJhY2tBdXRoIGlzIHJlcXVpcmVkIHRvIHN1Ym1pdCBmZWVkYmFjaycpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgY2hhaW5JZCwgZ2l2ZVBhcmFtcyB9ID0gYXdhaXQgdGhpcy5idWlsZEZlZWRiYWNrU3VibWlzc2lvbih7XG4gICAgICAgICAgICAuLi5wYXJhbXMsXG4gICAgICAgICAgICBmZWVkYmFja0F1dGg6IHBhcmFtcy5mZWVkYmFja0F1dGgsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCByZXB1dGF0aW9uQ2xpZW50ID0gYXdhaXQgZ2V0UmVwdXRhdGlvblJlZ2lzdHJ5Q2xpZW50KGNoYWluSWQpO1xuICAgICAgICByZXR1cm4gcmVwdXRhdGlvbkNsaWVudC5naXZlQ2xpZW50RmVlZGJhY2soZ2l2ZVBhcmFtcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByZXBhcmUgYSBnaXZlRmVlZGJhY2sgdHJhbnNhY3Rpb24gZm9yIGNsaWVudC1zaWRlIHNpZ25pbmcuXG4gICAgICovXG4gICAgYXN5bmMgcHJlcGFyZUdpdmVGZWVkYmFjayhwYXJhbXMpIHtcbiAgICAgICAgaWYgKCFwYXJhbXMuZmVlZGJhY2tBdXRoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZlZWRiYWNrQXV0aCBpcyByZXF1aXJlZCB0byBwcmVwYXJlIGZlZWRiYWNrIHRyYW5zYWN0aW9uJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBjaGFpbklkLCBnaXZlUGFyYW1zIH0gPSBhd2FpdCB0aGlzLmJ1aWxkRmVlZGJhY2tTdWJtaXNzaW9uKHtcbiAgICAgICAgICAgIC4uLnBhcmFtcyxcbiAgICAgICAgICAgIGZlZWRiYWNrQXV0aDogcGFyYW1zLmZlZWRiYWNrQXV0aCxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJlcHV0YXRpb25DbGllbnQgPSBhd2FpdCBnZXRSZXB1dGF0aW9uUmVnaXN0cnlDbGllbnQoY2hhaW5JZCk7XG4gICAgICAgIGNvbnN0IHR4UmVxdWVzdCA9IGF3YWl0IHJlcHV0YXRpb25DbGllbnQucHJlcGFyZUdpdmVGZWVkYmFja1R4KGdpdmVQYXJhbXMpO1xuICAgICAgICBjb25zdCB0b0hleCA9ICh2YWx1ZSkgPT4gdHlwZW9mIHZhbHVlID09PSAnYmlnaW50JyA/IGAweCR7dmFsdWUudG9TdHJpbmcoMTYpfWAgOiB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0ge1xuICAgICAgICAgICAgdG86IHR4UmVxdWVzdC50byxcbiAgICAgICAgICAgIGRhdGE6IHR4UmVxdWVzdC5kYXRhLFxuICAgICAgICAgICAgdmFsdWU6IHRvSGV4KHR4UmVxdWVzdC52YWx1ZSkgPz8gJzB4MCcsXG4gICAgICAgICAgICBnYXM6IHRvSGV4KHR4UmVxdWVzdC5nYXMpLFxuICAgICAgICAgICAgZ2FzUHJpY2U6IHRvSGV4KHR4UmVxdWVzdC5nYXNQcmljZSksXG4gICAgICAgICAgICBtYXhGZWVQZXJHYXM6IHRvSGV4KHR4UmVxdWVzdC5tYXhGZWVQZXJHYXMpLFxuICAgICAgICAgICAgbWF4UHJpb3JpdHlGZWVQZXJHYXM6IHRvSGV4KHR4UmVxdWVzdC5tYXhQcmlvcml0eUZlZVBlckdhcyksXG4gICAgICAgICAgICBub25jZTogdHhSZXF1ZXN0Lm5vbmNlLFxuICAgICAgICAgICAgY2hhaW5JZCxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNoYWluSWQsXG4gICAgICAgICAgICB0cmFuc2FjdGlvbixcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBhcHByb3ZlZCBORlQgb3BlcmF0b3IgYWRkcmVzcyBmb3IgdGhpcyBhZ2VudFxuICAgICAqIFJldHVybnMgdGhlIGFkZHJlc3MgYXBwcm92ZWQgdG8gb3BlcmF0ZSBvbiB0aGUgYWdlbnQncyBORlQgdG9rZW4sIG9yIG51bGwgaWYgbm8gb3BlcmF0b3IgaXMgc2V0XG4gICAgICpcbiAgICAgKiBAcGFyYW0gY2hhaW5JZCAtIE9wdGlvbmFsIGNoYWluIElEIChkZWZhdWx0cyB0byB0aGUgYWdlbnQncyBjaGFpbklkIGZyb20gZGF0YSwgb3IgREVGQVVMVF9DSEFJTl9JRClcbiAgICAgKiBAcmV0dXJucyBUaGUgYXBwcm92ZWQgb3BlcmF0b3IgYWRkcmVzcywgb3IgbnVsbCBpZiBubyBvcGVyYXRvciBpcyBzZXRcbiAgICAgKi9cbiAgICBhc3luYyBnZXRORlRPcGVyYXRvcihjaGFpbklkKSB7XG4gICAgICAgIGNvbnN0IGFnZW50SWQgPSB0aGlzLmFnZW50SWQ7XG4gICAgICAgIGlmICghYWdlbnRJZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBZ2VudCBJRCBpcyByZXF1aXJlZCB0byBnZXQgTkZUIG9wZXJhdG9yJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzb2x2ZWRDaGFpbklkID0gY2hhaW5JZCA/P1xuICAgICAgICAgICAgKE51bWJlci5pc0Zpbml0ZSh0aGlzLmRhdGE/LmNoYWluSWQpID8gTnVtYmVyKHRoaXMuZGF0YS5jaGFpbklkKSA6IERFRkFVTFRfQ0hBSU5fSUQpO1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQuYWdlbnRzLmdldE5GVE9wZXJhdG9yKGFnZW50SWQsIHJlc29sdmVkQ2hhaW5JZCk7XG4gICAgfVxufVxuLyoqXG4gKiBMb2FkIGEgZGV0YWlsZWQgQWdlbnQgdmlldyB1c2luZyBhIHByb3ZpZGVkIEFnZW50aWNUcnVzdENsaWVudC5cbiAqIFRoaXMgaXMgdGhlIGNvcmUgaW1wbGVtZW50YXRpb24gdXNlZCBieSBhZG1pbiBhbmQgb3RoZXIgc2VydmljZXMuXG4gKlxuICogSU1QT1JUQU5UOiBUaGlzIGZ1bmN0aW9uIGZldGNoZXMgb24tY2hhaW4gTkZUIG1ldGFkYXRhICh2aWEgZ2V0QWxsTWV0YWRhdGEpLFxuICogd2hpY2ggbWFrZXMgbXVsdGlwbGUgUlBDIGNhbGxzLiBJdCBzaG91bGQgT05MWSBiZSB1c2VkIGZvciBkZXRhaWxlZCBhZ2VudCB2aWV3cyxcbiAqIE5PVCBmb3IgbGlzdCBxdWVyaWVzLiBMaXN0IHF1ZXJpZXMgc2hvdWxkIHVzZSBzZWFyY2hBZ2VudHMvbGlzdEFnZW50cyB3aGljaFxuICogb25seSBmZXRjaCBkYXRhIGZyb20gdGhlIEdyYXBoUUwgZGlzY292ZXJ5IGluZGV4ZXIuXG4gKi9cbmZ1bmN0aW9uIGZpcnN0Tm9uRW1wdHlTdHJpbmcoLi4udmFsdWVzKSB7XG4gICAgZm9yIChjb25zdCB2YWx1ZSBvZiB2YWx1ZXMpIHtcbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsdWUgPT09IG51bGwpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGNvbnN0IHRyaW1tZWQgPSB2YWx1ZS50cmltKCk7XG4gICAgICAgICAgICBpZiAodHJpbW1lZC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRyaW1tZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhc1N0cmluZyA9IFN0cmluZyh2YWx1ZSkudHJpbSgpO1xuICAgICAgICBpZiAoYXNTdHJpbmcubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGFzU3RyaW5nO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gbG9hZEFnZW50RGV0YWlsKGNsaWVudCwgYWdlbnRJZGVudGlmaWVyLCBjaGFpbklkID0gREVGQVVMVF9DSEFJTl9JRCwgb3B0aW9ucykge1xuICAgIGNvbnN0IGlzRGlkID0gdHlwZW9mIGFnZW50SWRlbnRpZmllciA9PT0gJ3N0cmluZycgJiYgYWdlbnRJZGVudGlmaWVyLnRyaW0oKS5zdGFydHNXaXRoKCdkaWQ6ODAwNDonKTtcbiAgICBsZXQgcmVzb2x2ZWRDaGFpbklkID0gY2hhaW5JZDtcbiAgICBsZXQgYWdlbnRJZDtcbiAgICBsZXQgYWdlbnRJZEJpZ0ludDtcbiAgICBsZXQgZGlkODAwNDtcbiAgICBpZiAoaXNEaWQpIHtcbiAgICAgICAgZGlkODAwNCA9IGRlY29kZVVSSUNvbXBvbmVudChhZ2VudElkZW50aWZpZXIudHJpbSgpKTtcbiAgICAgICAgY29uc3QgcGFyc2VkID0gcGFyc2VEaWQ4MDA0KGRpZDgwMDQpO1xuICAgICAgICByZXNvbHZlZENoYWluSWQgPSBwYXJzZWQuY2hhaW5JZDtcbiAgICAgICAgYWdlbnRJZCA9IHBhcnNlZC5hZ2VudElkO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYWdlbnRJZEJpZ0ludCA9IEJpZ0ludChhZ2VudElkKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgYWdlbnRJZCBpbiBkaWQ6ODAwNCBpZGVudGlmaWVyOiAke2RpZDgwMDR9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IGFnZW50SWRJbnB1dCA9IGFnZW50SWRlbnRpZmllcjtcbiAgICAgICAgYWdlbnRJZEJpZ0ludCA9XG4gICAgICAgICAgICB0eXBlb2YgYWdlbnRJZElucHV0ID09PSAnYmlnaW50J1xuICAgICAgICAgICAgICAgID8gYWdlbnRJZElucHV0XG4gICAgICAgICAgICAgICAgOiAoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEJpZ0ludChhZ2VudElkSW5wdXQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBhZ2VudElkOiAke2FnZW50SWRJbnB1dH1gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pKCk7XG4gICAgICAgIGFnZW50SWQgPSBhZ2VudElkQmlnSW50LnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIGNvbnN0IGlkZW50aXR5Q2xpZW50ID0gYXdhaXQgZ2V0SWRlbnRpdHlSZWdpc3RyeUNsaWVudChyZXNvbHZlZENoYWluSWQpO1xuICAgIGNvbnN0IHRva2VuVXJpID0gYXdhaXQgaWRlbnRpdHlDbGllbnQuZ2V0VG9rZW5VUkkoYWdlbnRJZEJpZ0ludCk7XG4gICAgLy8gRmV0Y2ggbWV0YWRhdGEgZnJvbSBHcmFwaFFMIGluZGV4ZXIgKGZyb20gc2VhcmNoQWdlbnRzR3JhcGggd2l0aCBtZXRhZGF0YSBmaWVsZClcbiAgICAvLyBUaGlzIGF2b2lkcyBvbi1jaGFpbiBSUEMgY2FsbHMgYW5kIHJhdGUgbGltaXRpbmcgaXNzdWVzXG4gICAgbGV0IG1ldGFkYXRhID0ge307XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgZGlzY292ZXJ5Q2xpZW50ID0gYXdhaXQgZ2V0RGlzY292ZXJ5Q2xpZW50KCk7XG4gICAgICAgIC8vIFRyeSB0byBnZXQgYWdlbnQgd2l0aCBtZXRhZGF0YSBmcm9tIHNlYXJjaEFnZW50c0dyYXBoXG4gICAgICAgIGNvbnN0IGFnZW50V2l0aE1ldGFkYXRhID0gYXdhaXQgZGlzY292ZXJ5Q2xpZW50LmdldEFnZW50KHJlc29sdmVkQ2hhaW5JZCwgYWdlbnRJZCk7XG4gICAgICAgIGlmIChhZ2VudFdpdGhNZXRhZGF0YSkge1xuICAgICAgICAgICAgY29uc3QgbWV0YWRhdGFQcm9wID0gYWdlbnRXaXRoTWV0YWRhdGEubWV0YWRhdGE7XG4gICAgICAgICAgICBpZiAobWV0YWRhdGFQcm9wICYmIHR5cGVvZiBtZXRhZGF0YVByb3AgPT09ICdvYmplY3QnICYmIE9iamVjdC5rZXlzKG1ldGFkYXRhUHJvcCkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIG1ldGFkYXRhID0gbWV0YWRhdGFQcm9wO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdbbG9hZEFnZW50RGV0YWlsXSBHb3QgbWV0YWRhdGEgZnJvbSBzZWFyY2hBZ2VudHNHcmFwaDonLCBPYmplY3Qua2V5cyhtZXRhZGF0YSkubGVuZ3RoLCAna2V5cycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1tsb2FkQWdlbnREZXRhaWxdIE5vIG1ldGFkYXRhIGluIHNlYXJjaEFnZW50c0dyYXBoIHJlc3VsdCwgdHJ5aW5nIGdldFRva2VuTWV0YWRhdGEnKTtcbiAgICAgICAgICAgICAgICBjb25zdCBncmFwaFFMTWV0YWRhdGEgPSBhd2FpdCBkaXNjb3ZlcnlDbGllbnQuZ2V0VG9rZW5NZXRhZGF0YShyZXNvbHZlZENoYWluSWQsIGFnZW50SWQpO1xuICAgICAgICAgICAgICAgIGlmIChncmFwaFFMTWV0YWRhdGEgJiYgT2JqZWN0LmtleXMoZ3JhcGhRTE1ldGFkYXRhKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhID0gZ3JhcGhRTE1ldGFkYXRhO1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnW2xvYWRBZ2VudERldGFpbF0gR290IG1ldGFkYXRhIGZyb20gZ2V0VG9rZW5NZXRhZGF0YTonLCBPYmplY3Qua2V5cyhtZXRhZGF0YSkubGVuZ3RoLCAna2V5cycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdbbG9hZEFnZW50RGV0YWlsXSBObyBtZXRhZGF0YSBmb3VuZCBpbiBHcmFwaFFMOyBza2lwcGluZyBvbi1jaGFpbiBtZXRhZGF0YSB0byByZWR1Y2UgbGF0ZW5jeScpO1xuICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YSA9IHt9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignW2xvYWRBZ2VudERldGFpbF0gZ2V0QWdlbnQgcmV0dXJuZWQgbnVsbCwgdHJ5aW5nIGdldFRva2VuTWV0YWRhdGEnKTtcbiAgICAgICAgICAgIGNvbnN0IGdyYXBoUUxNZXRhZGF0YSA9IGF3YWl0IGRpc2NvdmVyeUNsaWVudC5nZXRUb2tlbk1ldGFkYXRhKHJlc29sdmVkQ2hhaW5JZCwgYWdlbnRJZCk7XG4gICAgICAgICAgICBpZiAoZ3JhcGhRTE1ldGFkYXRhICYmIE9iamVjdC5rZXlzKGdyYXBoUUxNZXRhZGF0YSkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIG1ldGFkYXRhID0gZ3JhcGhRTE1ldGFkYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdbbG9hZEFnZW50RGV0YWlsXSBObyBtZXRhZGF0YSBmb3VuZCB2aWEgR3JhcGhRTDsgc2tpcHBpbmcgb24tY2hhaW4gbWV0YWRhdGEgdG8gcmVkdWNlIGxhdGVuY3knKTtcbiAgICAgICAgICAgICAgICBtZXRhZGF0YSA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLndhcm4oJ1tsb2FkQWdlbnREZXRhaWxdIEZhaWxlZCB0byBmZXRjaCBtZXRhZGF0YSBmcm9tIEdyYXBoUUw7IHNraXBwaW5nIG9uLWNoYWluIG1ldGFkYXRhIHRvIHJlZHVjZSBsYXRlbmN5OicsIGVycm9yKTtcbiAgICAgICAgbWV0YWRhdGEgPSB7fTsgLy8gQXZvaWQgb24tY2hhaW4gZmFsbGJhY2sgdG8ga2VlcCByZXNwb25zZXMgZmFzdFxuICAgIH1cbiAgICBjb25zdCBpZGVudGl0eU1ldGFkYXRhID0ge1xuICAgICAgICB0b2tlblVyaSxcbiAgICAgICAgbWV0YWRhdGEsXG4gICAgfTtcbiAgICBsZXQgaWRlbnRpdHlSZWdpc3RyYXRpb24gPSBudWxsO1xuICAgIC8vIElNUE9SVEFOVDogQnkgZGVmYXVsdCwgd2UgZG8gTk9UIGZldGNoIHJlZ2lzdHJhdGlvbiBKU09OIGZyb20gSVBGUy4gVUlzIHNob3VsZCBvbmx5IGRvIHRoYXRcbiAgICAvLyB3aGVuIHRoZSB1c2VyIGV4cGxpY2l0bHkgb3BlbnMgdGhlIFJlZ2lzdHJhdGlvbiB0YWIuXG4gICAgY29uc3QgaW5jbHVkZVJlZ2lzdHJhdGlvbiA9IG9wdGlvbnM/LmluY2x1ZGVSZWdpc3RyYXRpb24gPT09IHRydWU7XG4gICAgbGV0IGRpc2NvdmVyeSA9IG51bGw7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgYWdlbnRzQXBpID0gY2xpZW50LmFnZW50cztcbiAgICAgICAgaWYgKGRpZDgwMDQgJiYgdHlwZW9mIGFnZW50c0FwaS5nZXRBZ2VudEZyb21EaXNjb3ZlcnlCeURpZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgZGlzY292ZXJ5ID0gKGF3YWl0IGFnZW50c0FwaS5nZXRBZ2VudEZyb21EaXNjb3ZlcnlCeURpZChkaWQ4MDA0KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGFnZW50c0FwaS5nZXRBZ2VudEZyb21EaXNjb3ZlcnkgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGRpc2NvdmVyeSA9IChhd2FpdCBhZ2VudHNBcGkuZ2V0QWdlbnRGcm9tRGlzY292ZXJ5KHJlc29sdmVkQ2hhaW5JZCwgYWdlbnRJZCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGlzY292ZXJ5ID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBpcyBhbiBhY2Nlc3MgY29kZSBlcnJvciBhbmQgcHJvdmlkZSBhIGNsZWFyZXIgbWVzc2FnZVxuICAgICAgICBjb25zdCB7IHJldGhyb3dEaXNjb3ZlcnlFcnJvciB9ID0gYXdhaXQgaW1wb3J0KCcuL2Rpc2NvdmVyeUVycm9ycycpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0aHJvd0Rpc2NvdmVyeUVycm9yKGVycm9yLCAnbG9hZEFnZW50RGV0YWlsJyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGZyaWVuZGx5RXJyb3IpIHtcbiAgICAgICAgICAgIC8vIElmIHJldGhyb3dEaXNjb3ZlcnlFcnJvciBkZXRlcm1pbmVkIGl0J3MgYW4gYWNjZXNzIGNvZGUgZXJyb3IsIGxvZyB0aGUgZnJpZW5kbHkgbWVzc2FnZVxuICAgICAgICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGdldCBHcmFwaFFMIGFnZW50IGRhdGE6JywgZnJpZW5kbHlFcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZnJpZW5kbHlFcnJvci5tZXNzYWdlIDogZnJpZW5kbHlFcnJvcik7XG4gICAgICAgICAgICB0aHJvdyBmcmllbmRseUVycm9yOyAvLyBSZS10aHJvdyB0aGUgZnJpZW5kbHkgZXJyb3JcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBpdCdzIG5vdCBhbiBhY2Nlc3MgY29kZSBlcnJvciwganVzdCBsb2cgYW5kIGNvbnRpbnVlXG4gICAgICAgIGNvbnNvbGUud2FybignRmFpbGVkIHRvIGdldCBHcmFwaFFMIGFnZW50IGRhdGE6JywgZXJyb3IpO1xuICAgICAgICBkaXNjb3ZlcnkgPSBudWxsO1xuICAgIH1cbiAgICAvLyBQcmVmZXIgY2FjaGVkIHJlZ2lzdHJhdGlvbiBKU09OIGZyb20gZGlzY292ZXJ5IHJvdyAocmF3SnNvbikgaW5zdGVhZCBvZiBoaXR0aW5nIElQRlMuXG4gICAgLy8gVGhpcyBrZWVwcyBcImFnZW50IGRldGFpbHNcIiBmYXN0IGFuZCBhdm9pZHMgZ2F0ZXdheSBkZXBlbmRlbmN5LlxuICAgIGlmICh0b2tlblVyaSkge1xuICAgICAgICBsZXQgcmVnaXN0cmF0aW9uRnJvbURpc2NvdmVyeSA9IG51bGw7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByYXdKc29uTWF5YmUgPSBkaXNjb3ZlcnkgJiYgdHlwZW9mIGRpc2NvdmVyeS5yYXdKc29uID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgICAgID8gU3RyaW5nKGRpc2NvdmVyeS5yYXdKc29uKVxuICAgICAgICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgICAgIGlmIChyYXdKc29uTWF5YmUgJiYgcmF3SnNvbk1heWJlLnRyaW0oKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcnNlZCA9IEpTT04ucGFyc2UocmF3SnNvbk1heWJlKTtcbiAgICAgICAgICAgICAgICBpZiAocGFyc2VkICYmIHR5cGVvZiBwYXJzZWQgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHBhcnNlZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVnaXN0cmF0aW9uRnJvbURpc2NvdmVyeSA9IHBhcnNlZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2gge1xuICAgICAgICAgICAgLy8gaWdub3JlXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlZ2lzdHJhdGlvbkZyb21EaXNjb3ZlcnkpIHtcbiAgICAgICAgICAgIGlkZW50aXR5UmVnaXN0cmF0aW9uID0geyB0b2tlblVyaSwgcmVnaXN0cmF0aW9uOiByZWdpc3RyYXRpb25Gcm9tRGlzY292ZXJ5IH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaW5jbHVkZVJlZ2lzdHJhdGlvbikge1xuICAgICAgICAgICAgLy8gRXhwbGljaXQgb3B0LWluOiBmZXRjaCBmcm9tIElQRlMvdG9rZW5VcmkuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlwZnNTdG9yYWdlID0gZ2V0SVBGU1N0b3JhZ2UoKTtcbiAgICAgICAgICAgICAgICBjb25zdCByZWdpc3RyYXRpb24gPSAoYXdhaXQgaXBmc1N0b3JhZ2UuZ2V0SnNvbih0b2tlblVyaSkpO1xuICAgICAgICAgICAgICAgIGlkZW50aXR5UmVnaXN0cmF0aW9uID0ge1xuICAgICAgICAgICAgICAgICAgICB0b2tlblVyaSxcbiAgICAgICAgICAgICAgICAgICAgcmVnaXN0cmF0aW9uLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ0ZhaWxlZCB0byBnZXQgSVBGUyByZWdpc3RyYXRpb246JywgZXJyb3IpO1xuICAgICAgICAgICAgICAgIGlkZW50aXR5UmVnaXN0cmF0aW9uID0ge1xuICAgICAgICAgICAgICAgICAgICB0b2tlblVyaSxcbiAgICAgICAgICAgICAgICAgICAgcmVnaXN0cmF0aW9uOiBudWxsLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZmxhdHRlbmVkID0ge307XG4gICAgLy8gUHJpb3JpdHkgMTogRGF0YSBmcm9tIHRva2VuVXJpL0lQRlMgcmVnaXN0cmF0aW9uIChoaWdoZXN0IHByaW9yaXR5IC0gb24tY2hhaW4gc291cmNlIG9mIHRydXRoKVxuICAgIGlmIChpZGVudGl0eVJlZ2lzdHJhdGlvbj8ucmVnaXN0cmF0aW9uICYmXG4gICAgICAgIHR5cGVvZiBpZGVudGl0eVJlZ2lzdHJhdGlvbi5yZWdpc3RyYXRpb24gPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGNvbnN0IHJlZyA9IGlkZW50aXR5UmVnaXN0cmF0aW9uLnJlZ2lzdHJhdGlvbjtcbiAgICAgICAgLy8gRXh0cmFjdCBzdGFuZGFyZCBmaWVsZHNcbiAgICAgICAgaWYgKHR5cGVvZiByZWcubmFtZSA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgICBmbGF0dGVuZWQubmFtZSA9IHJlZy5uYW1lO1xuICAgICAgICBpZiAodHlwZW9mIHJlZy5kZXNjcmlwdGlvbiA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgICBmbGF0dGVuZWQuZGVzY3JpcHRpb24gPSByZWcuZGVzY3JpcHRpb247XG4gICAgICAgIGlmICh0eXBlb2YgcmVnLmltYWdlID09PSAnc3RyaW5nJylcbiAgICAgICAgICAgIGZsYXR0ZW5lZC5pbWFnZSA9IHJlZy5pbWFnZTtcbiAgICAgICAgaWYgKHR5cGVvZiByZWcuYWdlbnRBY2NvdW50ID09PSAnc3RyaW5nJylcbiAgICAgICAgICAgIGZsYXR0ZW5lZC5hZ2VudEFjY291bnQgPSByZWcuYWdlbnRBY2NvdW50O1xuICAgICAgICBpZiAocmVnLmVuZHBvaW50cylcbiAgICAgICAgICAgIGZsYXR0ZW5lZC5lbmRwb2ludHMgPSByZWcuZW5kcG9pbnRzO1xuICAgICAgICBpZiAocmVnLnN1cHBvcnRlZFRydXN0KVxuICAgICAgICAgICAgZmxhdHRlbmVkLnN1cHBvcnRlZFRydXN0ID0gcmVnLnN1cHBvcnRlZFRydXN0O1xuICAgICAgICBpZiAodHlwZW9mIHJlZy5jcmVhdGVkQXQgIT09ICd1bmRlZmluZWQnKVxuICAgICAgICAgICAgZmxhdHRlbmVkLmNyZWF0ZWRBdCA9IHJlZy5jcmVhdGVkQXQ7XG4gICAgICAgIGlmICh0eXBlb2YgcmVnLnVwZGF0ZWRBdCAhPT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgICAgICBmbGF0dGVuZWQudXBkYXRlZEF0ID0gcmVnLnVwZGF0ZWRBdDtcbiAgICAgICAgLy8gRXh0cmFjdCBhbGwgb3RoZXIgbWV0YWRhdGEgZmllbGRzIGZyb20gcmVnaXN0cmF0aW9uIEpTT05cbiAgICAgICAgLy8gVGhpcyBpbmNsdWRlczogdGFncywgZ2xiVXJsLCBhZ2VudFdhbGxldCwgY2FwYWJpbGl0aWVzLCByb2xlLCB2ZXJzaW9uLCByYXRpbmcsIHByaWNpbmcsIGV0Yy5cbiAgICAgICAgT2JqZWN0LmtleXMocmVnKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgIC8vIFNraXAgZmllbGRzIHdlJ3ZlIGFscmVhZHkgaGFuZGxlZCBleHBsaWNpdGx5XG4gICAgICAgICAgICBpZiAoa2V5ICE9PSAnbmFtZScgJiZcbiAgICAgICAgICAgICAgICBrZXkgIT09ICdkZXNjcmlwdGlvbicgJiZcbiAgICAgICAgICAgICAgICBrZXkgIT09ICdpbWFnZScgJiZcbiAgICAgICAgICAgICAgICBrZXkgIT09ICdhZ2VudEFjY291bnQnICYmXG4gICAgICAgICAgICAgICAga2V5ICE9PSAnZW5kcG9pbnRzJyAmJlxuICAgICAgICAgICAgICAgIGtleSAhPT0gJ3N1cHBvcnRlZFRydXN0JyAmJlxuICAgICAgICAgICAgICAgIGtleSAhPT0gJ2NyZWF0ZWRBdCcgJiZcbiAgICAgICAgICAgICAgICBrZXkgIT09ICd1cGRhdGVkQXQnICYmXG4gICAgICAgICAgICAgICAga2V5ICE9PSAndHlwZScgJiZcbiAgICAgICAgICAgICAgICBrZXkgIT09ICdhZ2VudFVybCcgJiZcbiAgICAgICAgICAgICAgICBrZXkgIT09ICdtZXRhZGF0YScgJiZcbiAgICAgICAgICAgICAgICBrZXkgIT09ICdhdHRyaWJ1dGVzJyAmJlxuICAgICAgICAgICAgICAgIGtleSAhPT0gJ2V4dGVybmFsX3VybCcgJiZcbiAgICAgICAgICAgICAgICBmbGF0dGVuZWRba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgZmxhdHRlbmVkW2tleV0gPSByZWdba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIEV4dHJhY3QgYTJhRW5kcG9pbnQgZnJvbSByZWdpc3RyYXRpb25cbiAgICAgICAgLy8gUHJpb3JpdHk6IDEpIGRpcmVjdCBhMmFFbmRwb2ludCBmaWVsZCwgMikgZnJvbSBlbmRwb2ludHMgYXJyYXkgKG5hbWU6ICdBMkEnKSwgMykgZnJvbSBhZ2VudFVybFxuICAgICAgICAvKlxuICAgICAgICBpZiAodHlwZW9mIHJlZy5hMmFFbmRwb2ludCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBmbGF0dGVuZWQuYTJhRW5kcG9pbnQgPSByZWcuYTJhRW5kcG9pbnQ7XG4gICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShyZWcuZW5kcG9pbnRzKSkge1xuICAgICAgICAgIC8vIEZpbmQgQTJBIGVuZHBvaW50IGluIGVuZHBvaW50cyBhcnJheVxuICAgICAgICAgIGNvbnN0IGEyYUVuZHBvaW50RW50cnkgPSByZWcuZW5kcG9pbnRzLmZpbmQoXG4gICAgICAgICAgICAoZXA6IHVua25vd24pID0+XG4gICAgICAgICAgICAgIHR5cGVvZiBlcCA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgICAgZXAgIT09IG51bGwgJiZcbiAgICAgICAgICAgICAgJ25hbWUnIGluIGVwICYmXG4gICAgICAgICAgICAgIChlcCBhcyB7IG5hbWU6IHN0cmluZyB9KS5uYW1lID09PSAnQTJBJyAmJlxuICAgICAgICAgICAgICAnZW5kcG9pbnQnIGluIGVwICYmXG4gICAgICAgICAgICAgIHR5cGVvZiAoZXAgYXMgeyBlbmRwb2ludDogdW5rbm93biB9KS5lbmRwb2ludCA9PT0gJ3N0cmluZydcbiAgICAgICAgICApIGFzIHsgZW5kcG9pbnQ6IHN0cmluZyB9IHwgdW5kZWZpbmVkO1xuICAgICAgICAgIGlmIChhMmFFbmRwb2ludEVudHJ5KSB7XG4gICAgICAgICAgICBmbGF0dGVuZWQuYTJhRW5kcG9pbnQgPSBhMmFFbmRwb2ludEVudHJ5LmVuZHBvaW50O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAqL1xuICAgIH1cbiAgICAvLyBQcmlvcml0eSAyOiBPbi1jaGFpbiBtZXRhZGF0YSAob25seSBmaWxsIGlmIG5vdCBhbHJlYWR5IHNldCBmcm9tIHJlZ2lzdHJhdGlvbilcbiAgICBpZiAobWV0YWRhdGEuYWdlbnROYW1lICYmICFmbGF0dGVuZWQubmFtZSlcbiAgICAgICAgZmxhdHRlbmVkLm5hbWUgPSBtZXRhZGF0YS5hZ2VudE5hbWU7XG4gICAgaWYgKG1ldGFkYXRhLmFnZW50TmFtZSAmJiAhZmxhdHRlbmVkLmFnZW50TmFtZSlcbiAgICAgICAgZmxhdHRlbmVkLmFnZW50TmFtZSA9IG1ldGFkYXRhLmFnZW50TmFtZTtcbiAgICBpZiAobWV0YWRhdGEuYWdlbnRBY2NvdW50ICYmICFmbGF0dGVuZWQuYWdlbnRBY2NvdW50KVxuICAgICAgICBmbGF0dGVuZWQuYWdlbnRBY2NvdW50ID0gbWV0YWRhdGEuYWdlbnRBY2NvdW50O1xuICAgIC8vIFByaW9yaXR5IDM6IERpc2NvdmVyeSBkYXRhIChHcmFwaFFMIGluZGV4ZXIpIC0gb25seSBhcyBmYWxsYmFjayB3aGVuIG5vdCBhdmFpbGFibGUgZnJvbSBvbi1jaGFpbiBzb3VyY2VzXG4gICAgY29uc3QgZGlzY292ZXJ5UmVjb3JkID0gZGlzY292ZXJ5IHx8IHt9O1xuICAgIGlmIChkaXNjb3ZlcnkgJiYgdHlwZW9mIGRpc2NvdmVyeSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgLy8gT25seSB1c2UgZGlzY292ZXJ5IGRhdGEgaWYgbm90IGFscmVhZHkgc2V0IGZyb20gdG9rZW5VcmkvbWV0YWRhdGFcbiAgICAgICAgY29uc3QgYWdlbnROYW1lRnJvbURpc2NvdmVyeSA9IHR5cGVvZiBkaXNjb3ZlcnlSZWNvcmQuYWdlbnROYW1lID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgPyBkaXNjb3ZlcnlSZWNvcmQuYWdlbnROYW1lXG4gICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKGFnZW50TmFtZUZyb21EaXNjb3ZlcnkgJiYgIWZsYXR0ZW5lZC5uYW1lKVxuICAgICAgICAgICAgZmxhdHRlbmVkLm5hbWUgPSBhZ2VudE5hbWVGcm9tRGlzY292ZXJ5O1xuICAgICAgICBpZiAoYWdlbnROYW1lRnJvbURpc2NvdmVyeSAmJiAhZmxhdHRlbmVkLmFnZW50TmFtZSlcbiAgICAgICAgICAgIGZsYXR0ZW5lZC5hZ2VudE5hbWUgPSBhZ2VudE5hbWVGcm9tRGlzY292ZXJ5O1xuICAgICAgICAvLyBhMmFFbmRwb2ludCBmcm9tIGRpc2NvdmVyeSBvbmx5IGlmIG5vdCBpbiByZWdpc3RyYXRpb25cbiAgICAgICAgY29uc3QgYTJhRW5kcG9pbnRGcm9tRGlzY292ZXJ5ID0gdHlwZW9mIGRpc2NvdmVyeVJlY29yZC5hMmFFbmRwb2ludCA9PT0gJ3N0cmluZydcbiAgICAgICAgICAgID8gZGlzY292ZXJ5UmVjb3JkLmEyYUVuZHBvaW50XG4gICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgLy9pZiAoYTJhRW5kcG9pbnRGcm9tRGlzY292ZXJ5ICYmICFmbGF0dGVuZWQuYTJhRW5kcG9pbnQpIHtcbiAgICAgICAgLy8gIGZsYXR0ZW5lZC5hMmFFbmRwb2ludCA9IGEyYUVuZHBvaW50RnJvbURpc2NvdmVyeTtcbiAgICAgICAgLy99XG4gICAgICAgIC8vIFRpbWVzdGFtcHMgZnJvbSBkaXNjb3Zlcnkgb25seSBpZiBub3QgaW4gcmVnaXN0cmF0aW9uXG4gICAgICAgIGNvbnN0IGNyZWF0ZWRBdFRpbWVGcm9tRGlzY292ZXJ5ID0gdHlwZW9mIGRpc2NvdmVyeVJlY29yZC5jcmVhdGVkQXRUaW1lICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICAgICAgPyBkaXNjb3ZlcnlSZWNvcmQuY3JlYXRlZEF0VGltZVxuICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChjcmVhdGVkQXRUaW1lRnJvbURpc2NvdmVyeSAhPT0gdW5kZWZpbmVkICYmIGZsYXR0ZW5lZC5jcmVhdGVkQXRUaW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGZsYXR0ZW5lZC5jcmVhdGVkQXRUaW1lID0gY3JlYXRlZEF0VGltZUZyb21EaXNjb3Zlcnk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXBkYXRlZEF0VGltZUZyb21EaXNjb3ZlcnkgPSB0eXBlb2YgZGlzY292ZXJ5UmVjb3JkLnVwZGF0ZWRBdFRpbWUgIT09ICd1bmRlZmluZWQnXG4gICAgICAgICAgICA/IGRpc2NvdmVyeVJlY29yZC51cGRhdGVkQXRUaW1lXG4gICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHVwZGF0ZWRBdFRpbWVGcm9tRGlzY292ZXJ5ICE9PSB1bmRlZmluZWQgJiYgZmxhdHRlbmVkLnVwZGF0ZWRBdFRpbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZmxhdHRlbmVkLnVwZGF0ZWRBdFRpbWUgPSB1cGRhdGVkQXRUaW1lRnJvbURpc2NvdmVyeTtcbiAgICAgICAgfVxuICAgICAgICAvLyBGaWxsIGluIGFueSBvdGhlciBkaXNjb3ZlcnkgZmllbGRzIHRoYXQgYXJlbid0IGFscmVhZHkgc2V0XG4gICAgICAgIC8vIEV4Y2x1ZGUgYWdlbnRVcmkgYW5kIHJhd0pzb24gLSB0aGVzZSBzaG91bGQgY29tZSBmcm9tIG9uLWNoYWluIHNvdXJjZXMgb25seVxuICAgICAgICBPYmplY3Qua2V5cyhkaXNjb3ZlcnlSZWNvcmQpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgaWYgKGtleSAhPT0gJ2FnZW50SWQnICYmIGtleSAhPT0gJ2FnZW50VXJpJyAmJiBrZXkgIT09ICdyYXdKc29uJyAmJiBmbGF0dGVuZWRba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgZmxhdHRlbmVkW2tleV0gPSBkaXNjb3ZlcnlSZWNvcmRba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIFByaW9yaXRpemU6IGZsYXR0ZW5lZCAoZnJvbSB0b2tlblVyaS9JUEZTL21ldGFkYXRhKSA+IGRpc2NvdmVyeVJlY29yZCwgYnV0IHRyZWF0XG4gICAgLy8gZW1wdHkvd2hpdGVzcGFjZSBzdHJpbmdzIGFzIFwibWlzc2luZ1wiIHNvIHdlIGNhbiBzYWZlbHkgZmFsbCBiYWNrIHRvIGRpc2NvdmVyeS5cbiAgICBjb25zdCBhZ2VudE5hbWVWYWx1ZSA9IGZpcnN0Tm9uRW1wdHlTdHJpbmcoZmxhdHRlbmVkLmFnZW50TmFtZSwgZmxhdHRlbmVkLm5hbWUsIGRpc2NvdmVyeVJlY29yZC5hZ2VudE5hbWUpID8/ICcnO1xuICAgIC8vIFByZXZlbnQgbGF0ZXIgc3ByZWFkIG9mIGBmbGF0dGVuZWRgIGZyb20gb3ZlcndyaXRpbmcgdGhlIHJlc29sdmVkIGFnZW50TmFtZVxuICAgIC8vIHdpdGggYW4gZW1wdHkgc3RyaW5nIG9yIGxlc3MtcHJlZmVycmVkIHNvdXJjZS5cbiAgICBkZWxldGUgZmxhdHRlbmVkLmFnZW50TmFtZTtcbiAgICBkZWxldGUgZmxhdHRlbmVkLm5hbWU7XG4gICAgY29uc3QgYWdlbnRBY2NvdW50VmFsdWUgPSBmbGF0dGVuZWQuYWdlbnRBY2NvdW50ID8/XG4gICAgICAgIGRpc2NvdmVyeVJlY29yZC5hZ2VudEFjY291bnQgPz9cbiAgICAgICAgJyc7XG4gICAgY29uc3QgYWdlbnRJZGVudGl0eU93bmVyQWNjb3VudFZhbHVlID0gZGlzY292ZXJ5UmVjb3JkLmFnZW50SWRlbnRpdHlPd25lckFjY291bnQgPz8gJyc7XG4gICAgY29uc3QgZGV0YWlsID0ge1xuICAgICAgICAvLyBBZ2VudEluZm8gZmllbGRzXG4gICAgICAgIGFnZW50SWQsXG4gICAgICAgIGFnZW50TmFtZTogYWdlbnROYW1lVmFsdWUsXG4gICAgICAgIGNoYWluSWQ6IHJlc29sdmVkQ2hhaW5JZCxcbiAgICAgICAgYWdlbnRBY2NvdW50OiBhZ2VudEFjY291bnRWYWx1ZSxcbiAgICAgICAgYWdlbnRJZGVudGl0eU93bmVyQWNjb3VudDogYWdlbnRJZGVudGl0eU93bmVyQWNjb3VudFZhbHVlLFxuICAgICAgICBlb2FBZ2VudElkZW50aXR5T3duZXJBY2NvdW50OiBkaXNjb3ZlcnlSZWNvcmQuZW9hQWdlbnRJZGVudGl0eU93bmVyQWNjb3VudCA/PyBudWxsLFxuICAgICAgICBlb2FBZ2VudEFjY291bnQ6IGRpc2NvdmVyeVJlY29yZC5lb2FBZ2VudEFjY291bnQgPz8gbnVsbCxcbiAgICAgICAgZGlkSWRlbnRpdHk6IGRpc2NvdmVyeVJlY29yZC5kaWRJZGVudGl0eSA/PyBudWxsLFxuICAgICAgICBkaWRBY2NvdW50OiBkaXNjb3ZlcnlSZWNvcmQuZGlkQWNjb3VudCA/PyBudWxsLFxuICAgICAgICBkaWROYW1lOiBkaXNjb3ZlcnlSZWNvcmQuZGlkTmFtZSA/PyBudWxsLFxuICAgICAgICAvLyBhZ2VudFVyaSBhbmQgcmF3SnNvbiB3aWxsIGJlIHNldCBhZnRlciB0aGUgc3ByZWFkIHRvIGVuc3VyZSB0aGV5J3JlIG5vdCBvdmVyd3JpdHRlblxuICAgICAgICBjcmVhdGVkQXRCbG9jazogdHlwZW9mIGRpc2NvdmVyeVJlY29yZC5jcmVhdGVkQXRCbG9jayA9PT0gJ251bWJlcicgPyBkaXNjb3ZlcnlSZWNvcmQuY3JlYXRlZEF0QmxvY2sgOiAwLFxuICAgICAgICBjcmVhdGVkQXRUaW1lOiB0eXBlb2YgZGlzY292ZXJ5UmVjb3JkLmNyZWF0ZWRBdFRpbWUgPT09ICdudW1iZXInXG4gICAgICAgICAgICA/IGRpc2NvdmVyeVJlY29yZC5jcmVhdGVkQXRUaW1lXG4gICAgICAgICAgICA6IGZsYXR0ZW5lZC5jcmVhdGVkQXRUaW1lID8/IDAsXG4gICAgICAgIHVwZGF0ZWRBdFRpbWU6IHR5cGVvZiBkaXNjb3ZlcnlSZWNvcmQudXBkYXRlZEF0VGltZSA9PT0gJ251bWJlcidcbiAgICAgICAgICAgID8gZGlzY292ZXJ5UmVjb3JkLnVwZGF0ZWRBdFRpbWVcbiAgICAgICAgICAgIDogZmxhdHRlbmVkLnVwZGF0ZWRBdFRpbWUgPz8gbnVsbCxcbiAgICAgICAgdHlwZTogZGlzY292ZXJ5UmVjb3JkLnR5cGUgPz8gbnVsbCxcbiAgICAgICAgLy8gUHJpb3JpdGl6ZTogZmxhdHRlbmVkIChmcm9tIHRva2VuVXJpL0lQRlMpID4gZGlzY292ZXJ5UmVjb3JkXG4gICAgICAgIGRlc2NyaXB0aW9uOiBmbGF0dGVuZWQuZGVzY3JpcHRpb24gPz9cbiAgICAgICAgICAgIGRpc2NvdmVyeVJlY29yZC5kZXNjcmlwdGlvbiA/P1xuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgaW1hZ2U6IGZsYXR0ZW5lZC5pbWFnZSA/P1xuICAgICAgICAgICAgZGlzY292ZXJ5UmVjb3JkLmltYWdlID8/XG4gICAgICAgICAgICBudWxsLFxuICAgICAgICBhMmFFbmRwb2ludDogZmxhdHRlbmVkLmEyYUVuZHBvaW50ID8/XG4gICAgICAgICAgICBkaXNjb3ZlcnlSZWNvcmQuYTJhRW5kcG9pbnQgPz9cbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgIC8vIFByaW9yaXRpemU6IGZsYXR0ZW5lZCAoZnJvbSB0b2tlblVyaS9JUEZTKSA+IGRpc2NvdmVyeVJlY29yZFxuICAgICAgICBzdXBwb3J0ZWRUcnVzdDogZmxhdHRlbmVkLnN1cHBvcnRlZFRydXN0ID8/XG4gICAgICAgICAgICBkaXNjb3ZlcnlSZWNvcmQuc3VwcG9ydGVkVHJ1c3QgPz9cbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgIGFnZW50Q2FyZEpzb246IGRpc2NvdmVyeVJlY29yZC5hZ2VudENhcmRKc29uID8/IG51bGwsXG4gICAgICAgIGFnZW50Q2FyZFJlYWRBdDogdHlwZW9mIGRpc2NvdmVyeVJlY29yZC5hZ2VudENhcmRSZWFkQXQgPT09ICdudW1iZXInXG4gICAgICAgICAgICA/IGRpc2NvdmVyeVJlY29yZC5hZ2VudENhcmRSZWFkQXRcbiAgICAgICAgICAgIDogZGlzY292ZXJ5UmVjb3JkLmFnZW50Q2FyZFJlYWRBdCA/PyBudWxsLFxuICAgICAgICBkaWQ6IGRpc2NvdmVyeVJlY29yZC5kaWQgPz8gbnVsbCxcbiAgICAgICAgbWNwOiB0eXBlb2YgZGlzY292ZXJ5UmVjb3JkLm1jcCA9PT0gJ2Jvb2xlYW4nXG4gICAgICAgICAgICA/IGRpc2NvdmVyeVJlY29yZC5tY3BcbiAgICAgICAgICAgIDogZGlzY292ZXJ5UmVjb3JkLm1jcCA/PyBudWxsLFxuICAgICAgICB4NDAyc3VwcG9ydDogdHlwZW9mIGRpc2NvdmVyeVJlY29yZC54NDAyc3VwcG9ydCA9PT0gJ2Jvb2xlYW4nXG4gICAgICAgICAgICA/IGRpc2NvdmVyeVJlY29yZC54NDAyc3VwcG9ydFxuICAgICAgICAgICAgOiBkaXNjb3ZlcnlSZWNvcmQueDQwMnN1cHBvcnQgPz8gbnVsbCxcbiAgICAgICAgYWN0aXZlOiB0eXBlb2YgZGlzY292ZXJ5UmVjb3JkLmFjdGl2ZSA9PT0gJ2Jvb2xlYW4nXG4gICAgICAgICAgICA/IGRpc2NvdmVyeVJlY29yZC5hY3RpdmVcbiAgICAgICAgICAgIDogZGlzY292ZXJ5UmVjb3JkLmFjdGl2ZSA/PyBudWxsLFxuICAgICAgICAvLyBBZ2VudERldGFpbC1zcGVjaWZpYyBmaWVsZHNcbiAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgaWRlbnRpdHlNZXRhZGF0YSxcbiAgICAgICAgaWRlbnRpdHlSZWdpc3RyYXRpb24sXG4gICAgICAgIGRpc2NvdmVyeSxcbiAgICAgICAgLy8gRmxhdHRlbmVkIGV4dHJhIGZpZWxkc1xuICAgICAgICAuLi5mbGF0dGVuZWQsXG4gICAgfTtcbiAgICAvLyBTZXQgYWdlbnRVcmkgYW5kIHJhd0pzb24gQUZURVIgc3ByZWFkIHRvIGVuc3VyZSBvbi1jaGFpbiB2YWx1ZXMgdGFrZSBwcmVjZWRlbmNlLlxuICAgIC8vIFVzZSBvbi1jaGFpbiB0b2tlblVyaSBhcyBwcmltYXJ5IHNvdXJjZSAoZnJvbSBjb250cmFjdCk7IGluIHRoZSBuZXcgZGlzY292ZXJ5IHNjaGVtYSwgdGhpcyBpcyBleHBvc2VkIGFzIGBhZ2VudFVyaWAuXG4gICAgZGV0YWlsLmFnZW50VXJpID1cbiAgICAgICAgaWRlbnRpdHlNZXRhZGF0YS50b2tlblVyaSAhPT0gbnVsbCAmJiBpZGVudGl0eU1ldGFkYXRhLnRva2VuVXJpICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gaWRlbnRpdHlNZXRhZGF0YS50b2tlblVyaVxuICAgICAgICAgICAgOiAoZGlzY292ZXJ5UmVjb3JkLmFnZW50VXJpID8/IG51bGwpO1xuICAgIC8vIFVzZSByZWdpc3RyYXRpb24gSlNPTiBmcm9tIHRva2VuVXJpL0lQRlMgYXMgcHJpbWFyeSBzb3VyY2UsIGZhbGxiYWNrIHRvIGRpc2NvdmVyeVxuICAgIGRldGFpbC5yYXdKc29uID0gaWRlbnRpdHlSZWdpc3RyYXRpb24/LnJlZ2lzdHJhdGlvblxuICAgICAgICA/IEpTT04uc3RyaW5naWZ5KGlkZW50aXR5UmVnaXN0cmF0aW9uLnJlZ2lzdHJhdGlvbiwgbnVsbCwgMilcbiAgICAgICAgOiAoZGlzY292ZXJ5UmVjb3JkLnJhd0pzb24gPz8gbnVsbCk7XG4gICAgcmV0dXJuIGRldGFpbDtcbn1cbi8qKlxuICogQGRlcHJlY2F0ZWQgVXNlIGxvYWRBZ2VudERldGFpbCBpbnN0ZWFkLlxuICovXG5leHBvcnQgY29uc3QgYnVpbGRBZ2VudERldGFpbCA9IGxvYWRBZ2VudERldGFpbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFnZW50LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@agentic-trust/core/dist/server/lib/agent.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@agentic-trust/core/dist/server/lib/agentFeedback.js":
/*!*******************************************************************************!*\
  !*** ../../node_modules/@agentic-trust/core/dist/server/lib/agentFeedback.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createFeedbackAuth: () => (/* binding */ createFeedbackAuth),\n/* harmony export */   createFeedbackAuthWithDelegation: () => (/* binding */ createFeedbackAuthWithDelegation)\n/* harmony export */ });\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ethers */ \"(rsc)/../../node_modules/ethers/lib.esm/address/address.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ethers */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/utf8.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ethers */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ethers */ \"(rsc)/../../node_modules/ethers/lib.esm/abi/abi-coder.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ethers */ \"(rsc)/../../node_modules/ethers/lib.esm/hash/id.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ethers */ \"(rsc)/../../node_modules/ethers/lib.esm/crypto/keccak.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ethers */ \"(rsc)/../../node_modules/ethers/lib.esm/hash/solidity.js\");\n/* harmony import */ var _singletons_reputationClient__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../singletons/reputationClient */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/singletons/reputationClient.js\");\n/* harmony import */ var _association__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./association */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/lib/association.js\");\n/* harmony import */ var _ipfs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ipfs */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/lib/ipfs.js\");\n/**\n * Agent Feedback API\n *\n * Handles feedback authentication for agents\n */\n\n\n\n\n// Cache for the ABI to avoid reloading it multiple times\nlet abiCache = null;\n/**\n * Load IdentityRegistry ABI using dynamic import\n * NOTE: This function should only be called server-side (Next.js API routes)\n */\nconst getIdentityRegistryAbi = async () => {\n    // Return cached ABI if available\n    if (abiCache) {\n        return abiCache;\n    }\n    try {\n        // Dynamic import to avoid bundling JSON in client-side code if this module is tree-shaken improperly\n        const mod = await Promise.resolve(/*! import() */).then(__webpack_require__.t.bind(__webpack_require__, /*! @agentic-trust/8004-ext-sdk/abis/IdentityRegistry.json */ \"(rsc)/../../node_modules/@agentic-trust/8004-ext-sdk/abis/IdentityRegistry.json\", 17));\n        abiCache = mod.default;\n        return abiCache;\n    }\n    catch (error) {\n        console.error('Failed to load IdentityRegistry ABI:', error);\n        throw new Error(`Failed to load IdentityRegistry ABI: ${error instanceof Error ? error.message : String(error)}`);\n    }\n};\nconst U40_MAX = 1099511627775; // 2^40-1\nfunction clampU40(n) {\n    if (!Number.isFinite(n) || n < 0)\n        return 0;\n    return Math.min(Math.floor(n), U40_MAX);\n}\nfunction parseAgentAccountMetadata(value) {\n    if (typeof value !== 'string')\n        return null;\n    const v = value.trim();\n    if (!v)\n        return null;\n    // Supports CAIP-10: \"eip155:<chainId>:0x...\"\n    if (v.startsWith('eip155:')) {\n        const parts = v.split(':');\n        const addr = parts[2];\n        if (addr && /^0x[a-fA-F0-9]{40}$/.test(addr))\n            return ethers__WEBPACK_IMPORTED_MODULE_3__.getAddress(addr);\n    }\n    if (/^0x[a-fA-F0-9]{40}$/.test(v))\n        return ethers__WEBPACK_IMPORTED_MODULE_3__.getAddress(v);\n    return null;\n}\nfunction tryDecodeMetadataString(raw) {\n    if (typeof raw === 'string') {\n        const s = raw.trim();\n        if (!s)\n            return null;\n        // Many `getMetadata` implementations return bytes (0x...) that represent a UTF-8 string.\n        // Try to decode that to a normal string first.\n        if (s.startsWith('0x')) {\n            try {\n                return ethers__WEBPACK_IMPORTED_MODULE_4__.toUtf8String(ethers__WEBPACK_IMPORTED_MODULE_5__.getBytes(s));\n            }\n            catch {\n                // Fall back to the raw hex string.\n                return s;\n            }\n        }\n        return s;\n    }\n    // Some decoders may return Uint8Array-like bytes.\n    try {\n        if (raw && typeof raw === 'object' && 'length' in raw) {\n            return ethers__WEBPACK_IMPORTED_MODULE_4__.toUtf8String(raw);\n        }\n    }\n    catch {\n        // ignore\n    }\n    if (raw === null || raw === undefined)\n        return null;\n    return String(raw);\n}\nfunction toMinimalBigEndianBytes(n) {\n    if (n === 0n)\n        return new Uint8Array([0]);\n    let hex = n.toString(16);\n    if (hex.length % 2)\n        hex = `0${hex}`;\n    return ethers__WEBPACK_IMPORTED_MODULE_5__.getBytes(`0x${hex}`);\n}\n// Mirrors `InteroperableAddress.formatEvmV1(chainid, addr)` from the ERC-8092 reference.\nfunction formatEvmV1(chainId, address) {\n    const addr = ethers__WEBPACK_IMPORTED_MODULE_3__.getAddress(address);\n    const chainRef = toMinimalBigEndianBytes(BigInt(chainId));\n    const head = ethers__WEBPACK_IMPORTED_MODULE_5__.getBytes('0x00010000');\n    const out = ethers__WEBPACK_IMPORTED_MODULE_5__.concat([\n        head,\n        new Uint8Array([chainRef.length]),\n        chainRef,\n        new Uint8Array([20]),\n        ethers__WEBPACK_IMPORTED_MODULE_5__.getBytes(addr),\n    ]);\n    return ethers__WEBPACK_IMPORTED_MODULE_5__.hexlify(out);\n}\nfunction erc8092RecordDigest(rec) {\n    const abiCoder = ethers__WEBPACK_IMPORTED_MODULE_6__.AbiCoder.defaultAbiCoder();\n    const DOMAIN_TYPEHASH = ethers__WEBPACK_IMPORTED_MODULE_7__.id('EIP712Domain(string name,string version)');\n    const NAME_HASH = ethers__WEBPACK_IMPORTED_MODULE_7__.id('AssociatedAccounts');\n    const VERSION_HASH = ethers__WEBPACK_IMPORTED_MODULE_7__.id('1');\n    const MESSAGE_TYPEHASH = ethers__WEBPACK_IMPORTED_MODULE_7__.id('AssociatedAccountRecord(bytes initiator,bytes approver,uint40 validAt,uint40 validUntil,bytes4 interfaceId,bytes data)');\n    const domainSeparator = ethers__WEBPACK_IMPORTED_MODULE_8__.keccak256(abiCoder.encode(['bytes32', 'bytes32', 'bytes32'], [DOMAIN_TYPEHASH, NAME_HASH, VERSION_HASH]));\n    const hashStruct = ethers__WEBPACK_IMPORTED_MODULE_8__.keccak256(abiCoder.encode(['bytes32', 'bytes32', 'bytes32', 'uint40', 'uint40', 'bytes4', 'bytes32'], [\n        MESSAGE_TYPEHASH,\n        ethers__WEBPACK_IMPORTED_MODULE_8__.keccak256(rec.initiator),\n        ethers__WEBPACK_IMPORTED_MODULE_8__.keccak256(rec.approver),\n        rec.validAt,\n        rec.validUntil,\n        rec.interfaceId,\n        ethers__WEBPACK_IMPORTED_MODULE_8__.keccak256(rec.data),\n    ]));\n    return ethers__WEBPACK_IMPORTED_MODULE_8__.keccak256(ethers__WEBPACK_IMPORTED_MODULE_9__.solidityPacked(['bytes2', 'bytes32', 'bytes32'], ['0x1901', domainSeparator, hashStruct]));\n}\n/**\n * Create feedback auth signature\n */\nasync function createFeedbackAuth(params) {\n    const { signedAuth } = await createFeedbackAuthInternal(params);\n    return signedAuth;\n}\n/**\n * Create feedback auth signature and also produce a pre-signed ERC-8092 delegation association\n * record (approver signature only). The client can add the initiator signature and store it\n * on-chain to memorialize the delegation that grants rights to \"give feedback\".\n */\nasync function createFeedbackAuthWithDelegation(params) {\n    const { signedAuth, chainId, indexLimit, expiry, identityRegistry, authorityAddress, } = await createFeedbackAuthInternal(params);\n    // Best-effort: build delegation association. If it fails, still return feedbackAuth.\n    try {\n        const chainIdNum = Number(chainId);\n        if (!Number.isFinite(chainIdNum) || chainIdNum <= 0) {\n            throw new Error(`Invalid chainId for delegation association: ${String(chainId)}`);\n        }\n        // Approver is the *authority* we want the signature to be attributed to (agentAccount smart account).\n        // The actual signature bytes are produced by `params.signer` and must validate via the authority's ERC-1271.\n        const approverAddress = ethers__WEBPACK_IMPORTED_MODULE_3__.getAddress(String(authorityAddress || params.signer?.address || ''));\n        const initiatorAddress = ethers__WEBPACK_IMPORTED_MODULE_3__.getAddress(params.clientAddress);\n        // NOTE: We use validAt=0 to avoid \"validAt in the future\" edge-cases during on-chain store,\n        // where some ERC-8092 store implementations may reject records with validAt > block.timestamp.\n        const validAt = 0;\n        // IMPORTANT: keep validUntil=0 for compatibility with the current server-side association store prep,\n        // which always uses record.validUntil=0. Expiry is still embedded in the delegation payload.\n        const validUntil = 0;\n        const delegation = {\n            kind: 'erc8004.feedbackAuth.delegation',\n            feedbackAuth: signedAuth,\n            agentId: params.agentId.toString(),\n            clientAddress: initiatorAddress,\n            chainId: chainIdNum,\n            indexLimit: indexLimit.toString(),\n            expiry: expiry.toString(),\n            identityRegistry,\n            // Authority address (agentAccount) that the on-chain verifier should attribute the delegation/auth to.\n            signerAddress: approverAddress,\n            // The key that produced the raw signature bytes (useful for debugging); the verifier should still\n            // treat the signature as coming from `signerAddress` via ERC-1271.\n            operatorAddress: ethers__WEBPACK_IMPORTED_MODULE_3__.getAddress(String(params.signer?.address || '')),\n            createdAt: new Date().toISOString(),\n        };\n        // Upload the full delegation payload to IPFS so the ERC-8092 record can carry a small pointer.\n        let payloadTokenUri = null;\n        let payloadCid = null;\n        try {\n            const ipfs = (0,_ipfs__WEBPACK_IMPORTED_MODULE_2__.getIPFSStorage)();\n            const upload = await ipfs.upload(JSON.stringify(delegation, null, 2), 'feedbackAuth-delegation.json');\n            payloadCid = upload.cid;\n            payloadTokenUri = upload.tokenUri; // ipfs://CID\n        }\n        catch (ipfsErr) {\n            console.warn('[createFeedbackAuthWithDelegation] Failed to upload delegation payload to IPFS (continuing):', ipfsErr);\n        }\n        const delegationRef = {\n            type: 'erc8004.feedbackAuth.delegation',\n            payloadUri: payloadTokenUri,\n            payloadCid,\n            // minimal searchable fields\n            agentId: params.agentId.toString(),\n            clientAddress: initiatorAddress,\n            chainId: chainIdNum,\n            createdAt: new Date().toISOString(),\n        };\n        const data = (0,_association__WEBPACK_IMPORTED_MODULE_1__.encodeAssociationData)({\n            assocType: 1,\n            // ERC-8092 record \"ipfs content section\": embed an IPFS URI pointer in the description JSON.\n            description: JSON.stringify(delegationRef),\n        });\n        const record = {\n            initiator: formatEvmV1(chainIdNum, initiatorAddress),\n            approver: formatEvmV1(chainIdNum, approverAddress),\n            validAt,\n            validUntil,\n            interfaceId: '0x00000000',\n            data,\n        };\n        const associationId = erc8092RecordDigest(record);\n        if (!params.walletClient) {\n            throw new Error('walletClient is required to sign delegation association');\n        }\n        // If approverAddress is a smart account (ERC-1271), the signature bytes must be something\n        // that approverAddress will accept for `isValidSignature(digest, signature)`.\n        // Different account implementations expect different signature schemes (EIP-712 digest-signing vs EIP-191 personal_sign).\n        // We'll generate a small set of candidates and pick the one that validates via ERC-1271.\n        const selectApproverSignature = async (candidates) => {\n            try {\n                const code = await params.publicClient.getBytecode({ address: approverAddress });\n                // If not a contract, don't attempt ERC-1271 selection.\n                if (!code || code === '0x') {\n                    return { selected: candidates[0], checked: false, reason: 'approver has no code (EOA/counterfactual)' };\n                }\n                const ERC1271_MAGIC = '0x1626ba7e';\n                const ERC1271_ABI = [\n                    {\n                        type: 'function',\n                        name: 'isValidSignature',\n                        stateMutability: 'view',\n                        inputs: [\n                            { name: 'hash', type: 'bytes32' },\n                            { name: 'signature', type: 'bytes' },\n                        ],\n                        outputs: [{ name: 'magicValue', type: 'bytes4' }],\n                    },\n                ];\n                for (const c of candidates) {\n                    try {\n                        const magic = (await params.publicClient.readContract({\n                            address: approverAddress,\n                            abi: ERC1271_ABI,\n                            functionName: 'isValidSignature',\n                            args: [associationId, c.sig],\n                        }));\n                        if (String(magic).toLowerCase() === ERC1271_MAGIC) {\n                            return { selected: c, checked: true, reason: 'erc1271 magic matched' };\n                        }\n                    }\n                    catch {\n                        // try next\n                    }\n                }\n                return { selected: candidates[0], checked: true, reason: 'no candidate validated via ERC-1271' };\n            }\n            catch (e) {\n                return { selected: candidates[0], checked: false, reason: e?.message || String(e) };\n            }\n        };\n        // IMPORTANT:\n        // Sign using EIP-712 typed data so the signature validates against the raw EIP-712 digest (no EIP-191 prefix).\n        // Our digest scheme uses ONLY domain {name, version} (no chainId/verifyingContract).\n        const sigEip712 = (await params.walletClient.signTypedData({\n            // NOTE: signature bytes are produced by `params.signer` (operator/session key),\n            // but validated against `approverAddress` (agentAccount) via ERC-1271.\n            account: params.signer,\n            domain: { name: 'AssociatedAccounts', version: '1' },\n            types: {\n                AssociatedAccountRecord: [\n                    { name: 'initiator', type: 'bytes' },\n                    { name: 'approver', type: 'bytes' },\n                    { name: 'validAt', type: 'uint40' },\n                    { name: 'validUntil', type: 'uint40' },\n                    { name: 'interfaceId', type: 'bytes4' },\n                    { name: 'data', type: 'bytes' },\n                ],\n            },\n            primaryType: 'AssociatedAccountRecord',\n            message: {\n                initiator: record.initiator,\n                approver: record.approver,\n                validAt: BigInt(record.validAt),\n                validUntil: BigInt(record.validUntil),\n                interfaceId: record.interfaceId,\n                data: record.data,\n            },\n        }));\n        // Candidate 2: EIP-191 personal_sign of the 32-byte digest (some smart accounts validate this scheme).\n        let sigPersonal = '0x';\n        try {\n            sigPersonal = (await params.walletClient.signMessage({\n                account: params.signer,\n                message: { raw: ethers__WEBPACK_IMPORTED_MODULE_5__.getBytes(associationId) },\n            }));\n        }\n        catch {\n            // ignore\n        }\n        const chosen = await selectApproverSignature([\n            { scheme: 'eip712', sig: sigEip712 },\n            ...(sigPersonal && sigPersonal !== '0x' ? [{ scheme: 'personal_sign', sig: sigPersonal }] : []),\n        ]);\n        const approverSignature = chosen.selected.sig;\n        // IMPORTANT: Use K1 (0x0001) for approverKeyType. This is the standard approach.\n        //\n        // The ERC-8092 contract will use OpenZeppelin SignatureChecker which calls:\n        //   agent.isValidSignature(hash, approverSignature)\n        //\n        // MetaMask smart accounts with DTK support delegation-aware ERC-1271 validation.\n        // The delegation-aware validator automatically:\n        // 1. Extracts the signer address from the signature (ecrecover)\n        // 2. Checks if the signer (operator) has a valid delegation from the agent account\n        // 3. Validates the delegation scope covers this signing operation (now includes isValidSignature selector)\n        // 4. Returns 0x1626ba7e (valid) if delegation is valid, 0xffffffff (invalid) otherwise\n        //\n        // This allows the operator's signature to be validated as if it came from the agent account itself.\n        const sar = {\n            revokedAt: 0,\n            // K1 (0x0001) for client EOA initiator signature\n            initiatorKeyType: '0x0001',\n            // DELEGATED (0x8002) keyType to bypass ERC-1271 and validate delegation directly\n            // This checks if the agent account has delegated to the operator EOA directly\n            approverKeyType: '0x8002',\n            initiatorSignature: '0x',\n            approverSignature,\n            record,\n        };\n        return {\n            feedbackAuth: signedAuth,\n            delegationAssociation: {\n                associationId,\n                initiatorAddress,\n                approverAddress,\n                assocType: 1,\n                validAt,\n                validUntil,\n                data,\n                approverSignature,\n                sar,\n                delegation: {\n                    ...delegationRef,\n                    // Include the full payload inline too (best-effort convenience for clients),\n                    // but the canonical copy is the IPFS payload when available.\n                    payload: { ...delegation, signatureScheme: chosen.selected?.scheme, signatureChecked: chosen.checked, signatureCheckReason: chosen.reason },\n                },\n            },\n        };\n    }\n    catch (e) {\n        console.warn('[createFeedbackAuthWithDelegation] Failed to create delegation association (continuing):', e);\n        return { feedbackAuth: signedAuth };\n    }\n}\nasync function createFeedbackAuthInternal(params) {\n    const { publicClient, agentId, clientAddress, signer, walletClient, expirySeconds = 3600, } = params;\n    // Get the shared reputation client singleton (used for auth struct + index queries)\n    const reputationClient = await (0,_singletons_reputationClient__WEBPACK_IMPORTED_MODULE_0__.getReputationRegistryClient)();\n    // Prefer env-configured IdentityRegistry to avoid an extra on-chain call.\n    // This helps in rate-limited environments (e.g. 429s from RPC providers).\n    let identityReg = null;\n    try {\n        const { getChainEnvVar } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./chainConfig */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/lib/chainConfig.js\"));\n        const chainId = Number(publicClient?.chain?.id ?? 0);\n        const fromEnv = chainId ? getChainEnvVar('AGENTIC_TRUST_IDENTITY_REGISTRY', chainId) : null;\n        if (fromEnv && typeof fromEnv === 'string' && /^0x[a-fA-F0-9]{40}$/.test(fromEnv)) {\n            identityReg = fromEnv;\n        }\n    }\n    catch {\n        // ignore\n    }\n    if (!identityReg) {\n        // Fallback: resolve IdentityRegistry from ReputationRegistry on-chain\n        identityReg = (await reputationClient.getIdentityRegistry());\n    }\n    // Load IdentityRegistry ABI (async dynamic import)\n    const identityRegistryAbi = await getIdentityRegistryAbi();\n    // Ensure IdentityRegistry operator approvals are configured for sessionAA\n    console.info(\"**********************************\");\n    console.info(\"createFeedbackAuth: \", agentId, clientAddress, signer.address);\n    try {\n        const ownerOfAgent = await publicClient.readContract({\n            address: identityReg,\n            abi: identityRegistryAbi,\n            functionName: 'ownerOf',\n            args: [agentId],\n        });\n        const isOperator = await publicClient.readContract({\n            address: identityReg,\n            abi: identityRegistryAbi,\n            functionName: 'isApprovedForAll',\n            args: [ownerOfAgent, signer.address],\n        });\n        const tokenApproved = await publicClient.readContract({\n            address: identityReg,\n            abi: identityRegistryAbi,\n            functionName: 'getApproved',\n            args: [agentId],\n        });\n        console.info('IdentityRegistry approvals:', { ownerOfAgent, isOperator, tokenApproved });\n        if (!isOperator && tokenApproved.toLowerCase() !== signer.address.toLowerCase()) {\n            throw new Error(`IdentityRegistry approval missing: neither isApprovedForAll nor getApproved`);\n        }\n    }\n    catch (e) {\n        console.warn('[IdentityRegistry] approval check failed:', e?.message || e);\n        throw e;\n    }\n    // Resolve the agentAccount authority address from on-chain metadata.\n    // This is the address we want verifiers to attribute feedbackAuth/delegations to.\n    let authorityAddress = signer.address;\n    try {\n        const agentAccountRaw = await publicClient.readContract({\n            address: identityReg,\n            abi: identityRegistryAbi,\n            functionName: 'getMetadata',\n            args: [agentId, 'agentAccount'],\n        });\n        const agentAccountStr = tryDecodeMetadataString(agentAccountRaw);\n        const parsed = parseAgentAccountMetadata(agentAccountStr);\n        if (parsed)\n            authorityAddress = parsed;\n        console.info('[FeedbackAuth] Resolved authorityAddress:', {\n            agentId: agentId.toString(),\n            authorityAddress,\n            agentAccountStr,\n        });\n    }\n    catch (e) {\n        console.warn('[FeedbackAuth] Unable to resolve agentAccount from metadata; falling back to signer.address', e);\n    }\n    const nowSec = BigInt(Math.floor(Date.now() / 1000));\n    const chainId = BigInt(publicClient.chain?.id ?? 0);\n    const U64_MAX = 18446744073709551615n;\n    const lastIndexFetched = await reputationClient.getLastIndex(agentId, clientAddress);\n    let indexLimit = lastIndexFetched + 1n;\n    let expiry = nowSec + BigInt(expirySeconds);\n    if (expiry > U64_MAX) {\n        console.warn('[FeedbackAuth] Computed expiry exceeds uint64; clamping to max');\n        expiry = U64_MAX;\n    }\n    // Build FeedbackAuth struct via ReputationClient\n    console.info(\"create feedback auth structure: \", agentId, clientAddress, indexLimit, expiry, chainId, authorityAddress);\n    const authStruct = reputationClient.createFeedbackAuth(agentId, clientAddress, indexLimit, expiry, chainId, \n    // IMPORTANT: attribute auth to agentAccount authority, not the operator key.\n    authorityAddress);\n    // Note: log the struct directly; JSON.stringify cannot handle BigInt values.\n    console.info('authStruct:', authStruct);\n    // Sign keccak256(encoded tuple) with provided signer (sessionAA via ERC-1271)\n    const encoded = ethers__WEBPACK_IMPORTED_MODULE_6__.AbiCoder.defaultAbiCoder().encode(['uint256', 'address', 'uint256', 'uint256', 'uint256', 'address', 'address'], [\n        authStruct.agentId,\n        authStruct.clientAddress,\n        authStruct.indexLimit,\n        authStruct.expiry,\n        authStruct.chainId,\n        authStruct.identityRegistry,\n        authStruct.signerAddress,\n    ]);\n    const messageHash = ethers__WEBPACK_IMPORTED_MODULE_8__.keccak256(encoded);\n    // Sign the message hash using the wallet client\n    if (!walletClient) {\n        throw new Error('walletClient is required for signing feedback auth');\n    }\n    const signature = await walletClient.signMessage({\n        account: signer,\n        message: { raw: ethers__WEBPACK_IMPORTED_MODULE_5__.getBytes(messageHash) },\n    });\n    console.info(\"signature: \", signature);\n    const signedAuth = ethers__WEBPACK_IMPORTED_MODULE_5__.concat([encoded, signature]);\n    return {\n        signedAuth,\n        authStruct,\n        encoded: encoded,\n        chainId,\n        indexLimit,\n        expiry,\n        identityRegistry: identityReg,\n        authorityAddress,\n    };\n}\n//# sourceMappingURL=agentFeedback.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BhZ2VudGljLXRydXN0L2NvcmUvZGlzdC9zZXJ2ZXIvbGliL2FnZW50RmVlZGJhY2suanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNnQztBQUM2QztBQUN2QjtBQUNkO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDJPQUFnRTtBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLHVEQUF1RDtBQUN2SDtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxHQUFHO0FBQ3ZDLG1CQUFtQiw4Q0FBaUI7QUFDcEM7QUFDQSx3QkFBd0IsR0FBRztBQUMzQixlQUFlLDhDQUFpQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGdEQUFtQixDQUFDLDRDQUFlO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsZ0RBQW1CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsSUFBSTtBQUN0QixXQUFXLDRDQUFlLE1BQU0sSUFBSTtBQUNwQztBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsOENBQWlCO0FBQ2xDO0FBQ0EsaUJBQWlCLDRDQUFlO0FBQ2hDLGdCQUFnQiwwQ0FBYTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsNENBQWU7QUFDdkI7QUFDQSxXQUFXLDJDQUFjO0FBQ3pCO0FBQ0E7QUFDQSxxQkFBcUIsNENBQWU7QUFDcEMsNEJBQTRCLHNDQUFTO0FBQ3JDLHNCQUFzQixzQ0FBUztBQUMvQix5QkFBeUIsc0NBQVM7QUFDbEMsNkJBQTZCLHNDQUFTO0FBQ3RDLDRCQUE0Qiw2Q0FBZ0I7QUFDNUMsdUJBQXVCLDZDQUFnQjtBQUN2QztBQUNBLFFBQVEsNkNBQWdCO0FBQ3hCLFFBQVEsNkNBQWdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLFFBQVEsNkNBQWdCO0FBQ3hCO0FBQ0EsV0FBVyw2Q0FBZ0IsQ0FBQyxrREFBcUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLFlBQVksYUFBYTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsWUFBWSwrRUFBK0U7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMkUsZ0JBQWdCO0FBQzNGO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyw4Q0FBaUI7QUFDakQsaUNBQWlDLDhDQUFpQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUZBQXFGO0FBQ3JGO0FBQ0EsNkJBQTZCLDhDQUFpQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIscURBQWM7QUFDdkM7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG1FQUFxQjtBQUMxQztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLDBCQUEwQjtBQUMvRjtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsK0JBQStCO0FBQzdELDhCQUE4QixrQ0FBa0M7QUFDaEU7QUFDQSxvQ0FBb0Msb0NBQW9DO0FBQ3hFLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLGVBQWU7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsMENBQTBDO0FBQ2hFO0FBQ0E7QUFDQSxzQkFBc0Isa0NBQWtDO0FBQ3hELHNCQUFzQixpQ0FBaUM7QUFDdkQsc0JBQXNCLGlDQUFpQztBQUN2RCxzQkFBc0Isb0NBQW9DO0FBQzFELHNCQUFzQixxQ0FBcUM7QUFDM0Qsc0JBQXNCLDZCQUE2QjtBQUNuRDtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLEtBQUssNENBQWUsaUJBQWlCO0FBQ2hFLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxrQ0FBa0M7QUFDaEQseURBQXlELDJDQUEyQztBQUNwRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsZ0lBQWdJO0FBQy9KLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsWUFBWSxvRkFBb0Y7QUFDaEc7QUFDQSxtQ0FBbUMseUZBQTJCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGlCQUFpQixRQUFRLHdMQUF1QjtBQUNoRTtBQUNBO0FBQ0Esc0VBQXNFLEdBQUc7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxzREFBc0QseUNBQXlDO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsbUZBQW1GO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUU7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBLG9CQUFvQiw0Q0FBZTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDZDQUFnQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsS0FBSyw0Q0FBZSxlQUFlO0FBQ3RELEtBQUs7QUFDTDtBQUNBLHVCQUF1QiwwQ0FBYTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL2JhcmIvYWEvQXNzb2NpYXRlZEFjY291bnRzL25vZGVfbW9kdWxlcy9AYWdlbnRpYy10cnVzdC9jb3JlL2Rpc3Qvc2VydmVyL2xpYi9hZ2VudEZlZWRiYWNrLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQWdlbnQgRmVlZGJhY2sgQVBJXG4gKlxuICogSGFuZGxlcyBmZWVkYmFjayBhdXRoZW50aWNhdGlvbiBmb3IgYWdlbnRzXG4gKi9cbmltcG9ydCB7IGV0aGVycyB9IGZyb20gJ2V0aGVycyc7XG5pbXBvcnQgeyBnZXRSZXB1dGF0aW9uUmVnaXN0cnlDbGllbnQgfSBmcm9tICcuLi9zaW5nbGV0b25zL3JlcHV0YXRpb25DbGllbnQnO1xuaW1wb3J0IHsgZW5jb2RlQXNzb2NpYXRpb25EYXRhIH0gZnJvbSAnLi9hc3NvY2lhdGlvbic7XG5pbXBvcnQgeyBnZXRJUEZTU3RvcmFnZSB9IGZyb20gJy4vaXBmcyc7XG4vLyBDYWNoZSBmb3IgdGhlIEFCSSB0byBhdm9pZCByZWxvYWRpbmcgaXQgbXVsdGlwbGUgdGltZXNcbmxldCBhYmlDYWNoZSA9IG51bGw7XG4vKipcbiAqIExvYWQgSWRlbnRpdHlSZWdpc3RyeSBBQkkgdXNpbmcgZHluYW1pYyBpbXBvcnRcbiAqIE5PVEU6IFRoaXMgZnVuY3Rpb24gc2hvdWxkIG9ubHkgYmUgY2FsbGVkIHNlcnZlci1zaWRlIChOZXh0LmpzIEFQSSByb3V0ZXMpXG4gKi9cbmNvbnN0IGdldElkZW50aXR5UmVnaXN0cnlBYmkgPSBhc3luYyAoKSA9PiB7XG4gICAgLy8gUmV0dXJuIGNhY2hlZCBBQkkgaWYgYXZhaWxhYmxlXG4gICAgaWYgKGFiaUNhY2hlKSB7XG4gICAgICAgIHJldHVybiBhYmlDYWNoZTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gRHluYW1pYyBpbXBvcnQgdG8gYXZvaWQgYnVuZGxpbmcgSlNPTiBpbiBjbGllbnQtc2lkZSBjb2RlIGlmIHRoaXMgbW9kdWxlIGlzIHRyZWUtc2hha2VuIGltcHJvcGVybHlcbiAgICAgICAgY29uc3QgbW9kID0gYXdhaXQgaW1wb3J0KCdAYWdlbnRpYy10cnVzdC84MDA0LWV4dC1zZGsvYWJpcy9JZGVudGl0eVJlZ2lzdHJ5Lmpzb24nKTtcbiAgICAgICAgYWJpQ2FjaGUgPSBtb2QuZGVmYXVsdDtcbiAgICAgICAgcmV0dXJuIGFiaUNhY2hlO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGxvYWQgSWRlbnRpdHlSZWdpc3RyeSBBQkk6JywgZXJyb3IpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBsb2FkIElkZW50aXR5UmVnaXN0cnkgQUJJOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKX1gKTtcbiAgICB9XG59O1xuY29uc3QgVTQwX01BWCA9IDEwOTk1MTE2Mjc3NzU7IC8vIDJeNDAtMVxuZnVuY3Rpb24gY2xhbXBVNDAobikge1xuICAgIGlmICghTnVtYmVyLmlzRmluaXRlKG4pIHx8IG4gPCAwKVxuICAgICAgICByZXR1cm4gMDtcbiAgICByZXR1cm4gTWF0aC5taW4oTWF0aC5mbG9vcihuKSwgVTQwX01BWCk7XG59XG5mdW5jdGlvbiBwYXJzZUFnZW50QWNjb3VudE1ldGFkYXRhKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGNvbnN0IHYgPSB2YWx1ZS50cmltKCk7XG4gICAgaWYgKCF2KVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAvLyBTdXBwb3J0cyBDQUlQLTEwOiBcImVpcDE1NTo8Y2hhaW5JZD46MHguLi5cIlxuICAgIGlmICh2LnN0YXJ0c1dpdGgoJ2VpcDE1NTonKSkge1xuICAgICAgICBjb25zdCBwYXJ0cyA9IHYuc3BsaXQoJzonKTtcbiAgICAgICAgY29uc3QgYWRkciA9IHBhcnRzWzJdO1xuICAgICAgICBpZiAoYWRkciAmJiAvXjB4W2EtZkEtRjAtOV17NDB9JC8udGVzdChhZGRyKSlcbiAgICAgICAgICAgIHJldHVybiBldGhlcnMuZ2V0QWRkcmVzcyhhZGRyKTtcbiAgICB9XG4gICAgaWYgKC9eMHhbYS1mQS1GMC05XXs0MH0kLy50ZXN0KHYpKVxuICAgICAgICByZXR1cm4gZXRoZXJzLmdldEFkZHJlc3Modik7XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiB0cnlEZWNvZGVNZXRhZGF0YVN0cmluZyhyYXcpIHtcbiAgICBpZiAodHlwZW9mIHJhdyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgY29uc3QgcyA9IHJhdy50cmltKCk7XG4gICAgICAgIGlmICghcylcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAvLyBNYW55IGBnZXRNZXRhZGF0YWAgaW1wbGVtZW50YXRpb25zIHJldHVybiBieXRlcyAoMHguLi4pIHRoYXQgcmVwcmVzZW50IGEgVVRGLTggc3RyaW5nLlxuICAgICAgICAvLyBUcnkgdG8gZGVjb2RlIHRoYXQgdG8gYSBub3JtYWwgc3RyaW5nIGZpcnN0LlxuICAgICAgICBpZiAocy5zdGFydHNXaXRoKCcweCcpKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBldGhlcnMudG9VdGY4U3RyaW5nKGV0aGVycy5nZXRCeXRlcyhzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCB7XG4gICAgICAgICAgICAgICAgLy8gRmFsbCBiYWNrIHRvIHRoZSByYXcgaGV4IHN0cmluZy5cbiAgICAgICAgICAgICAgICByZXR1cm4gcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcztcbiAgICB9XG4gICAgLy8gU29tZSBkZWNvZGVycyBtYXkgcmV0dXJuIFVpbnQ4QXJyYXktbGlrZSBieXRlcy5cbiAgICB0cnkge1xuICAgICAgICBpZiAocmF3ICYmIHR5cGVvZiByYXcgPT09ICdvYmplY3QnICYmICdsZW5ndGgnIGluIHJhdykge1xuICAgICAgICAgICAgcmV0dXJuIGV0aGVycy50b1V0ZjhTdHJpbmcocmF3KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCB7XG4gICAgICAgIC8vIGlnbm9yZVxuICAgIH1cbiAgICBpZiAocmF3ID09PSBudWxsIHx8IHJhdyA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gU3RyaW5nKHJhdyk7XG59XG5mdW5jdGlvbiB0b01pbmltYWxCaWdFbmRpYW5CeXRlcyhuKSB7XG4gICAgaWYgKG4gPT09IDBuKVxuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWzBdKTtcbiAgICBsZXQgaGV4ID0gbi50b1N0cmluZygxNik7XG4gICAgaWYgKGhleC5sZW5ndGggJSAyKVxuICAgICAgICBoZXggPSBgMCR7aGV4fWA7XG4gICAgcmV0dXJuIGV0aGVycy5nZXRCeXRlcyhgMHgke2hleH1gKTtcbn1cbi8vIE1pcnJvcnMgYEludGVyb3BlcmFibGVBZGRyZXNzLmZvcm1hdEV2bVYxKGNoYWluaWQsIGFkZHIpYCBmcm9tIHRoZSBFUkMtODA5MiByZWZlcmVuY2UuXG5mdW5jdGlvbiBmb3JtYXRFdm1WMShjaGFpbklkLCBhZGRyZXNzKSB7XG4gICAgY29uc3QgYWRkciA9IGV0aGVycy5nZXRBZGRyZXNzKGFkZHJlc3MpO1xuICAgIGNvbnN0IGNoYWluUmVmID0gdG9NaW5pbWFsQmlnRW5kaWFuQnl0ZXMoQmlnSW50KGNoYWluSWQpKTtcbiAgICBjb25zdCBoZWFkID0gZXRoZXJzLmdldEJ5dGVzKCcweDAwMDEwMDAwJyk7XG4gICAgY29uc3Qgb3V0ID0gZXRoZXJzLmNvbmNhdChbXG4gICAgICAgIGhlYWQsXG4gICAgICAgIG5ldyBVaW50OEFycmF5KFtjaGFpblJlZi5sZW5ndGhdKSxcbiAgICAgICAgY2hhaW5SZWYsXG4gICAgICAgIG5ldyBVaW50OEFycmF5KFsyMF0pLFxuICAgICAgICBldGhlcnMuZ2V0Qnl0ZXMoYWRkciksXG4gICAgXSk7XG4gICAgcmV0dXJuIGV0aGVycy5oZXhsaWZ5KG91dCk7XG59XG5mdW5jdGlvbiBlcmM4MDkyUmVjb3JkRGlnZXN0KHJlYykge1xuICAgIGNvbnN0IGFiaUNvZGVyID0gZXRoZXJzLkFiaUNvZGVyLmRlZmF1bHRBYmlDb2RlcigpO1xuICAgIGNvbnN0IERPTUFJTl9UWVBFSEFTSCA9IGV0aGVycy5pZCgnRUlQNzEyRG9tYWluKHN0cmluZyBuYW1lLHN0cmluZyB2ZXJzaW9uKScpO1xuICAgIGNvbnN0IE5BTUVfSEFTSCA9IGV0aGVycy5pZCgnQXNzb2NpYXRlZEFjY291bnRzJyk7XG4gICAgY29uc3QgVkVSU0lPTl9IQVNIID0gZXRoZXJzLmlkKCcxJyk7XG4gICAgY29uc3QgTUVTU0FHRV9UWVBFSEFTSCA9IGV0aGVycy5pZCgnQXNzb2NpYXRlZEFjY291bnRSZWNvcmQoYnl0ZXMgaW5pdGlhdG9yLGJ5dGVzIGFwcHJvdmVyLHVpbnQ0MCB2YWxpZEF0LHVpbnQ0MCB2YWxpZFVudGlsLGJ5dGVzNCBpbnRlcmZhY2VJZCxieXRlcyBkYXRhKScpO1xuICAgIGNvbnN0IGRvbWFpblNlcGFyYXRvciA9IGV0aGVycy5rZWNjYWsyNTYoYWJpQ29kZXIuZW5jb2RlKFsnYnl0ZXMzMicsICdieXRlczMyJywgJ2J5dGVzMzInXSwgW0RPTUFJTl9UWVBFSEFTSCwgTkFNRV9IQVNILCBWRVJTSU9OX0hBU0hdKSk7XG4gICAgY29uc3QgaGFzaFN0cnVjdCA9IGV0aGVycy5rZWNjYWsyNTYoYWJpQ29kZXIuZW5jb2RlKFsnYnl0ZXMzMicsICdieXRlczMyJywgJ2J5dGVzMzInLCAndWludDQwJywgJ3VpbnQ0MCcsICdieXRlczQnLCAnYnl0ZXMzMiddLCBbXG4gICAgICAgIE1FU1NBR0VfVFlQRUhBU0gsXG4gICAgICAgIGV0aGVycy5rZWNjYWsyNTYocmVjLmluaXRpYXRvciksXG4gICAgICAgIGV0aGVycy5rZWNjYWsyNTYocmVjLmFwcHJvdmVyKSxcbiAgICAgICAgcmVjLnZhbGlkQXQsXG4gICAgICAgIHJlYy52YWxpZFVudGlsLFxuICAgICAgICByZWMuaW50ZXJmYWNlSWQsXG4gICAgICAgIGV0aGVycy5rZWNjYWsyNTYocmVjLmRhdGEpLFxuICAgIF0pKTtcbiAgICByZXR1cm4gZXRoZXJzLmtlY2NhazI1NihldGhlcnMuc29saWRpdHlQYWNrZWQoWydieXRlczInLCAnYnl0ZXMzMicsICdieXRlczMyJ10sIFsnMHgxOTAxJywgZG9tYWluU2VwYXJhdG9yLCBoYXNoU3RydWN0XSkpO1xufVxuLyoqXG4gKiBDcmVhdGUgZmVlZGJhY2sgYXV0aCBzaWduYXR1cmVcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZUZlZWRiYWNrQXV0aChwYXJhbXMpIHtcbiAgICBjb25zdCB7IHNpZ25lZEF1dGggfSA9IGF3YWl0IGNyZWF0ZUZlZWRiYWNrQXV0aEludGVybmFsKHBhcmFtcyk7XG4gICAgcmV0dXJuIHNpZ25lZEF1dGg7XG59XG4vKipcbiAqIENyZWF0ZSBmZWVkYmFjayBhdXRoIHNpZ25hdHVyZSBhbmQgYWxzbyBwcm9kdWNlIGEgcHJlLXNpZ25lZCBFUkMtODA5MiBkZWxlZ2F0aW9uIGFzc29jaWF0aW9uXG4gKiByZWNvcmQgKGFwcHJvdmVyIHNpZ25hdHVyZSBvbmx5KS4gVGhlIGNsaWVudCBjYW4gYWRkIHRoZSBpbml0aWF0b3Igc2lnbmF0dXJlIGFuZCBzdG9yZSBpdFxuICogb24tY2hhaW4gdG8gbWVtb3JpYWxpemUgdGhlIGRlbGVnYXRpb24gdGhhdCBncmFudHMgcmlnaHRzIHRvIFwiZ2l2ZSBmZWVkYmFja1wiLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY3JlYXRlRmVlZGJhY2tBdXRoV2l0aERlbGVnYXRpb24ocGFyYW1zKSB7XG4gICAgY29uc3QgeyBzaWduZWRBdXRoLCBjaGFpbklkLCBpbmRleExpbWl0LCBleHBpcnksIGlkZW50aXR5UmVnaXN0cnksIGF1dGhvcml0eUFkZHJlc3MsIH0gPSBhd2FpdCBjcmVhdGVGZWVkYmFja0F1dGhJbnRlcm5hbChwYXJhbXMpO1xuICAgIC8vIEJlc3QtZWZmb3J0OiBidWlsZCBkZWxlZ2F0aW9uIGFzc29jaWF0aW9uLiBJZiBpdCBmYWlscywgc3RpbGwgcmV0dXJuIGZlZWRiYWNrQXV0aC5cbiAgICB0cnkge1xuICAgICAgICBjb25zdCBjaGFpbklkTnVtID0gTnVtYmVyKGNoYWluSWQpO1xuICAgICAgICBpZiAoIU51bWJlci5pc0Zpbml0ZShjaGFpbklkTnVtKSB8fCBjaGFpbklkTnVtIDw9IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBjaGFpbklkIGZvciBkZWxlZ2F0aW9uIGFzc29jaWF0aW9uOiAke1N0cmluZyhjaGFpbklkKX1gKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBcHByb3ZlciBpcyB0aGUgKmF1dGhvcml0eSogd2Ugd2FudCB0aGUgc2lnbmF0dXJlIHRvIGJlIGF0dHJpYnV0ZWQgdG8gKGFnZW50QWNjb3VudCBzbWFydCBhY2NvdW50KS5cbiAgICAgICAgLy8gVGhlIGFjdHVhbCBzaWduYXR1cmUgYnl0ZXMgYXJlIHByb2R1Y2VkIGJ5IGBwYXJhbXMuc2lnbmVyYCBhbmQgbXVzdCB2YWxpZGF0ZSB2aWEgdGhlIGF1dGhvcml0eSdzIEVSQy0xMjcxLlxuICAgICAgICBjb25zdCBhcHByb3ZlckFkZHJlc3MgPSBldGhlcnMuZ2V0QWRkcmVzcyhTdHJpbmcoYXV0aG9yaXR5QWRkcmVzcyB8fCBwYXJhbXMuc2lnbmVyPy5hZGRyZXNzIHx8ICcnKSk7XG4gICAgICAgIGNvbnN0IGluaXRpYXRvckFkZHJlc3MgPSBldGhlcnMuZ2V0QWRkcmVzcyhwYXJhbXMuY2xpZW50QWRkcmVzcyk7XG4gICAgICAgIC8vIE5PVEU6IFdlIHVzZSB2YWxpZEF0PTAgdG8gYXZvaWQgXCJ2YWxpZEF0IGluIHRoZSBmdXR1cmVcIiBlZGdlLWNhc2VzIGR1cmluZyBvbi1jaGFpbiBzdG9yZSxcbiAgICAgICAgLy8gd2hlcmUgc29tZSBFUkMtODA5MiBzdG9yZSBpbXBsZW1lbnRhdGlvbnMgbWF5IHJlamVjdCByZWNvcmRzIHdpdGggdmFsaWRBdCA+IGJsb2NrLnRpbWVzdGFtcC5cbiAgICAgICAgY29uc3QgdmFsaWRBdCA9IDA7XG4gICAgICAgIC8vIElNUE9SVEFOVDoga2VlcCB2YWxpZFVudGlsPTAgZm9yIGNvbXBhdGliaWxpdHkgd2l0aCB0aGUgY3VycmVudCBzZXJ2ZXItc2lkZSBhc3NvY2lhdGlvbiBzdG9yZSBwcmVwLFxuICAgICAgICAvLyB3aGljaCBhbHdheXMgdXNlcyByZWNvcmQudmFsaWRVbnRpbD0wLiBFeHBpcnkgaXMgc3RpbGwgZW1iZWRkZWQgaW4gdGhlIGRlbGVnYXRpb24gcGF5bG9hZC5cbiAgICAgICAgY29uc3QgdmFsaWRVbnRpbCA9IDA7XG4gICAgICAgIGNvbnN0IGRlbGVnYXRpb24gPSB7XG4gICAgICAgICAgICBraW5kOiAnZXJjODAwNC5mZWVkYmFja0F1dGguZGVsZWdhdGlvbicsXG4gICAgICAgICAgICBmZWVkYmFja0F1dGg6IHNpZ25lZEF1dGgsXG4gICAgICAgICAgICBhZ2VudElkOiBwYXJhbXMuYWdlbnRJZC50b1N0cmluZygpLFxuICAgICAgICAgICAgY2xpZW50QWRkcmVzczogaW5pdGlhdG9yQWRkcmVzcyxcbiAgICAgICAgICAgIGNoYWluSWQ6IGNoYWluSWROdW0sXG4gICAgICAgICAgICBpbmRleExpbWl0OiBpbmRleExpbWl0LnRvU3RyaW5nKCksXG4gICAgICAgICAgICBleHBpcnk6IGV4cGlyeS50b1N0cmluZygpLFxuICAgICAgICAgICAgaWRlbnRpdHlSZWdpc3RyeSxcbiAgICAgICAgICAgIC8vIEF1dGhvcml0eSBhZGRyZXNzIChhZ2VudEFjY291bnQpIHRoYXQgdGhlIG9uLWNoYWluIHZlcmlmaWVyIHNob3VsZCBhdHRyaWJ1dGUgdGhlIGRlbGVnYXRpb24vYXV0aCB0by5cbiAgICAgICAgICAgIHNpZ25lckFkZHJlc3M6IGFwcHJvdmVyQWRkcmVzcyxcbiAgICAgICAgICAgIC8vIFRoZSBrZXkgdGhhdCBwcm9kdWNlZCB0aGUgcmF3IHNpZ25hdHVyZSBieXRlcyAodXNlZnVsIGZvciBkZWJ1Z2dpbmcpOyB0aGUgdmVyaWZpZXIgc2hvdWxkIHN0aWxsXG4gICAgICAgICAgICAvLyB0cmVhdCB0aGUgc2lnbmF0dXJlIGFzIGNvbWluZyBmcm9tIGBzaWduZXJBZGRyZXNzYCB2aWEgRVJDLTEyNzEuXG4gICAgICAgICAgICBvcGVyYXRvckFkZHJlc3M6IGV0aGVycy5nZXRBZGRyZXNzKFN0cmluZyhwYXJhbXMuc2lnbmVyPy5hZGRyZXNzIHx8ICcnKSksXG4gICAgICAgICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgfTtcbiAgICAgICAgLy8gVXBsb2FkIHRoZSBmdWxsIGRlbGVnYXRpb24gcGF5bG9hZCB0byBJUEZTIHNvIHRoZSBFUkMtODA5MiByZWNvcmQgY2FuIGNhcnJ5IGEgc21hbGwgcG9pbnRlci5cbiAgICAgICAgbGV0IHBheWxvYWRUb2tlblVyaSA9IG51bGw7XG4gICAgICAgIGxldCBwYXlsb2FkQ2lkID0gbnVsbDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGlwZnMgPSBnZXRJUEZTU3RvcmFnZSgpO1xuICAgICAgICAgICAgY29uc3QgdXBsb2FkID0gYXdhaXQgaXBmcy51cGxvYWQoSlNPTi5zdHJpbmdpZnkoZGVsZWdhdGlvbiwgbnVsbCwgMiksICdmZWVkYmFja0F1dGgtZGVsZWdhdGlvbi5qc29uJyk7XG4gICAgICAgICAgICBwYXlsb2FkQ2lkID0gdXBsb2FkLmNpZDtcbiAgICAgICAgICAgIHBheWxvYWRUb2tlblVyaSA9IHVwbG9hZC50b2tlblVyaTsgLy8gaXBmczovL0NJRFxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChpcGZzRXJyKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ1tjcmVhdGVGZWVkYmFja0F1dGhXaXRoRGVsZWdhdGlvbl0gRmFpbGVkIHRvIHVwbG9hZCBkZWxlZ2F0aW9uIHBheWxvYWQgdG8gSVBGUyAoY29udGludWluZyk6JywgaXBmc0Vycik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGVsZWdhdGlvblJlZiA9IHtcbiAgICAgICAgICAgIHR5cGU6ICdlcmM4MDA0LmZlZWRiYWNrQXV0aC5kZWxlZ2F0aW9uJyxcbiAgICAgICAgICAgIHBheWxvYWRVcmk6IHBheWxvYWRUb2tlblVyaSxcbiAgICAgICAgICAgIHBheWxvYWRDaWQsXG4gICAgICAgICAgICAvLyBtaW5pbWFsIHNlYXJjaGFibGUgZmllbGRzXG4gICAgICAgICAgICBhZ2VudElkOiBwYXJhbXMuYWdlbnRJZC50b1N0cmluZygpLFxuICAgICAgICAgICAgY2xpZW50QWRkcmVzczogaW5pdGlhdG9yQWRkcmVzcyxcbiAgICAgICAgICAgIGNoYWluSWQ6IGNoYWluSWROdW0sXG4gICAgICAgICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZGF0YSA9IGVuY29kZUFzc29jaWF0aW9uRGF0YSh7XG4gICAgICAgICAgICBhc3NvY1R5cGU6IDEsXG4gICAgICAgICAgICAvLyBFUkMtODA5MiByZWNvcmQgXCJpcGZzIGNvbnRlbnQgc2VjdGlvblwiOiBlbWJlZCBhbiBJUEZTIFVSSSBwb2ludGVyIGluIHRoZSBkZXNjcmlwdGlvbiBKU09OLlxuICAgICAgICAgICAgZGVzY3JpcHRpb246IEpTT04uc3RyaW5naWZ5KGRlbGVnYXRpb25SZWYpLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcmVjb3JkID0ge1xuICAgICAgICAgICAgaW5pdGlhdG9yOiBmb3JtYXRFdm1WMShjaGFpbklkTnVtLCBpbml0aWF0b3JBZGRyZXNzKSxcbiAgICAgICAgICAgIGFwcHJvdmVyOiBmb3JtYXRFdm1WMShjaGFpbklkTnVtLCBhcHByb3ZlckFkZHJlc3MpLFxuICAgICAgICAgICAgdmFsaWRBdCxcbiAgICAgICAgICAgIHZhbGlkVW50aWwsXG4gICAgICAgICAgICBpbnRlcmZhY2VJZDogJzB4MDAwMDAwMDAnLFxuICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgYXNzb2NpYXRpb25JZCA9IGVyYzgwOTJSZWNvcmREaWdlc3QocmVjb3JkKTtcbiAgICAgICAgaWYgKCFwYXJhbXMud2FsbGV0Q2xpZW50KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3dhbGxldENsaWVudCBpcyByZXF1aXJlZCB0byBzaWduIGRlbGVnYXRpb24gYXNzb2NpYXRpb24nKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBhcHByb3ZlckFkZHJlc3MgaXMgYSBzbWFydCBhY2NvdW50IChFUkMtMTI3MSksIHRoZSBzaWduYXR1cmUgYnl0ZXMgbXVzdCBiZSBzb21ldGhpbmdcbiAgICAgICAgLy8gdGhhdCBhcHByb3ZlckFkZHJlc3Mgd2lsbCBhY2NlcHQgZm9yIGBpc1ZhbGlkU2lnbmF0dXJlKGRpZ2VzdCwgc2lnbmF0dXJlKWAuXG4gICAgICAgIC8vIERpZmZlcmVudCBhY2NvdW50IGltcGxlbWVudGF0aW9ucyBleHBlY3QgZGlmZmVyZW50IHNpZ25hdHVyZSBzY2hlbWVzIChFSVAtNzEyIGRpZ2VzdC1zaWduaW5nIHZzIEVJUC0xOTEgcGVyc29uYWxfc2lnbikuXG4gICAgICAgIC8vIFdlJ2xsIGdlbmVyYXRlIGEgc21hbGwgc2V0IG9mIGNhbmRpZGF0ZXMgYW5kIHBpY2sgdGhlIG9uZSB0aGF0IHZhbGlkYXRlcyB2aWEgRVJDLTEyNzEuXG4gICAgICAgIGNvbnN0IHNlbGVjdEFwcHJvdmVyU2lnbmF0dXJlID0gYXN5bmMgKGNhbmRpZGF0ZXMpID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29kZSA9IGF3YWl0IHBhcmFtcy5wdWJsaWNDbGllbnQuZ2V0Qnl0ZWNvZGUoeyBhZGRyZXNzOiBhcHByb3ZlckFkZHJlc3MgfSk7XG4gICAgICAgICAgICAgICAgLy8gSWYgbm90IGEgY29udHJhY3QsIGRvbid0IGF0dGVtcHQgRVJDLTEyNzEgc2VsZWN0aW9uLlxuICAgICAgICAgICAgICAgIGlmICghY29kZSB8fCBjb2RlID09PSAnMHgnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHNlbGVjdGVkOiBjYW5kaWRhdGVzWzBdLCBjaGVja2VkOiBmYWxzZSwgcmVhc29uOiAnYXBwcm92ZXIgaGFzIG5vIGNvZGUgKEVPQS9jb3VudGVyZmFjdHVhbCknIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IEVSQzEyNzFfTUFHSUMgPSAnMHgxNjI2YmE3ZSc7XG4gICAgICAgICAgICAgICAgY29uc3QgRVJDMTI3MV9BQkkgPSBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdmdW5jdGlvbicsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnaXNWYWxpZFNpZ25hdHVyZScsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZU11dGFiaWxpdHk6ICd2aWV3JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0czogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ2hhc2gnLCB0eXBlOiAnYnl0ZXMzMicgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWU6ICdzaWduYXR1cmUnLCB0eXBlOiAnYnl0ZXMnIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0czogW3sgbmFtZTogJ21hZ2ljVmFsdWUnLCB0eXBlOiAnYnl0ZXM0JyB9XSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgYyBvZiBjYW5kaWRhdGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtYWdpYyA9IChhd2FpdCBwYXJhbXMucHVibGljQ2xpZW50LnJlYWRDb250cmFjdCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkcmVzczogYXBwcm92ZXJBZGRyZXNzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFiaTogRVJDMTI3MV9BQkksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25OYW1lOiAnaXNWYWxpZFNpZ25hdHVyZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJnczogW2Fzc29jaWF0aW9uSWQsIGMuc2lnXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChTdHJpbmcobWFnaWMpLnRvTG93ZXJDYXNlKCkgPT09IEVSQzEyNzFfTUFHSUMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBzZWxlY3RlZDogYywgY2hlY2tlZDogdHJ1ZSwgcmVhc29uOiAnZXJjMTI3MSBtYWdpYyBtYXRjaGVkJyB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRyeSBuZXh0XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgc2VsZWN0ZWQ6IGNhbmRpZGF0ZXNbMF0sIGNoZWNrZWQ6IHRydWUsIHJlYXNvbjogJ25vIGNhbmRpZGF0ZSB2YWxpZGF0ZWQgdmlhIEVSQy0xMjcxJyB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBzZWxlY3RlZDogY2FuZGlkYXRlc1swXSwgY2hlY2tlZDogZmFsc2UsIHJlYXNvbjogZT8ubWVzc2FnZSB8fCBTdHJpbmcoZSkgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLy8gSU1QT1JUQU5UOlxuICAgICAgICAvLyBTaWduIHVzaW5nIEVJUC03MTIgdHlwZWQgZGF0YSBzbyB0aGUgc2lnbmF0dXJlIHZhbGlkYXRlcyBhZ2FpbnN0IHRoZSByYXcgRUlQLTcxMiBkaWdlc3QgKG5vIEVJUC0xOTEgcHJlZml4KS5cbiAgICAgICAgLy8gT3VyIGRpZ2VzdCBzY2hlbWUgdXNlcyBPTkxZIGRvbWFpbiB7bmFtZSwgdmVyc2lvbn0gKG5vIGNoYWluSWQvdmVyaWZ5aW5nQ29udHJhY3QpLlxuICAgICAgICBjb25zdCBzaWdFaXA3MTIgPSAoYXdhaXQgcGFyYW1zLndhbGxldENsaWVudC5zaWduVHlwZWREYXRhKHtcbiAgICAgICAgICAgIC8vIE5PVEU6IHNpZ25hdHVyZSBieXRlcyBhcmUgcHJvZHVjZWQgYnkgYHBhcmFtcy5zaWduZXJgIChvcGVyYXRvci9zZXNzaW9uIGtleSksXG4gICAgICAgICAgICAvLyBidXQgdmFsaWRhdGVkIGFnYWluc3QgYGFwcHJvdmVyQWRkcmVzc2AgKGFnZW50QWNjb3VudCkgdmlhIEVSQy0xMjcxLlxuICAgICAgICAgICAgYWNjb3VudDogcGFyYW1zLnNpZ25lcixcbiAgICAgICAgICAgIGRvbWFpbjogeyBuYW1lOiAnQXNzb2NpYXRlZEFjY291bnRzJywgdmVyc2lvbjogJzEnIH0sXG4gICAgICAgICAgICB0eXBlczoge1xuICAgICAgICAgICAgICAgIEFzc29jaWF0ZWRBY2NvdW50UmVjb3JkOiBbXG4gICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ2luaXRpYXRvcicsIHR5cGU6ICdieXRlcycgfSxcbiAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAnYXBwcm92ZXInLCB0eXBlOiAnYnl0ZXMnIH0sXG4gICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ3ZhbGlkQXQnLCB0eXBlOiAndWludDQwJyB9LFxuICAgICAgICAgICAgICAgICAgICB7IG5hbWU6ICd2YWxpZFVudGlsJywgdHlwZTogJ3VpbnQ0MCcgfSxcbiAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAnaW50ZXJmYWNlSWQnLCB0eXBlOiAnYnl0ZXM0JyB9LFxuICAgICAgICAgICAgICAgICAgICB7IG5hbWU6ICdkYXRhJywgdHlwZTogJ2J5dGVzJyB9LFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcHJpbWFyeVR5cGU6ICdBc3NvY2lhdGVkQWNjb3VudFJlY29yZCcsXG4gICAgICAgICAgICBtZXNzYWdlOiB7XG4gICAgICAgICAgICAgICAgaW5pdGlhdG9yOiByZWNvcmQuaW5pdGlhdG9yLFxuICAgICAgICAgICAgICAgIGFwcHJvdmVyOiByZWNvcmQuYXBwcm92ZXIsXG4gICAgICAgICAgICAgICAgdmFsaWRBdDogQmlnSW50KHJlY29yZC52YWxpZEF0KSxcbiAgICAgICAgICAgICAgICB2YWxpZFVudGlsOiBCaWdJbnQocmVjb3JkLnZhbGlkVW50aWwpLFxuICAgICAgICAgICAgICAgIGludGVyZmFjZUlkOiByZWNvcmQuaW50ZXJmYWNlSWQsXG4gICAgICAgICAgICAgICAgZGF0YTogcmVjb3JkLmRhdGEsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KSk7XG4gICAgICAgIC8vIENhbmRpZGF0ZSAyOiBFSVAtMTkxIHBlcnNvbmFsX3NpZ24gb2YgdGhlIDMyLWJ5dGUgZGlnZXN0IChzb21lIHNtYXJ0IGFjY291bnRzIHZhbGlkYXRlIHRoaXMgc2NoZW1lKS5cbiAgICAgICAgbGV0IHNpZ1BlcnNvbmFsID0gJzB4JztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHNpZ1BlcnNvbmFsID0gKGF3YWl0IHBhcmFtcy53YWxsZXRDbGllbnQuc2lnbk1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgIGFjY291bnQ6IHBhcmFtcy5zaWduZXIsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogeyByYXc6IGV0aGVycy5nZXRCeXRlcyhhc3NvY2lhdGlvbklkKSB9LFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIHtcbiAgICAgICAgICAgIC8vIGlnbm9yZVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNob3NlbiA9IGF3YWl0IHNlbGVjdEFwcHJvdmVyU2lnbmF0dXJlKFtcbiAgICAgICAgICAgIHsgc2NoZW1lOiAnZWlwNzEyJywgc2lnOiBzaWdFaXA3MTIgfSxcbiAgICAgICAgICAgIC4uLihzaWdQZXJzb25hbCAmJiBzaWdQZXJzb25hbCAhPT0gJzB4JyA/IFt7IHNjaGVtZTogJ3BlcnNvbmFsX3NpZ24nLCBzaWc6IHNpZ1BlcnNvbmFsIH1dIDogW10pLFxuICAgICAgICBdKTtcbiAgICAgICAgY29uc3QgYXBwcm92ZXJTaWduYXR1cmUgPSBjaG9zZW4uc2VsZWN0ZWQuc2lnO1xuICAgICAgICAvLyBJTVBPUlRBTlQ6IFVzZSBLMSAoMHgwMDAxKSBmb3IgYXBwcm92ZXJLZXlUeXBlLiBUaGlzIGlzIHRoZSBzdGFuZGFyZCBhcHByb2FjaC5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gVGhlIEVSQy04MDkyIGNvbnRyYWN0IHdpbGwgdXNlIE9wZW5aZXBwZWxpbiBTaWduYXR1cmVDaGVja2VyIHdoaWNoIGNhbGxzOlxuICAgICAgICAvLyAgIGFnZW50LmlzVmFsaWRTaWduYXR1cmUoaGFzaCwgYXBwcm92ZXJTaWduYXR1cmUpXG4gICAgICAgIC8vXG4gICAgICAgIC8vIE1ldGFNYXNrIHNtYXJ0IGFjY291bnRzIHdpdGggRFRLIHN1cHBvcnQgZGVsZWdhdGlvbi1hd2FyZSBFUkMtMTI3MSB2YWxpZGF0aW9uLlxuICAgICAgICAvLyBUaGUgZGVsZWdhdGlvbi1hd2FyZSB2YWxpZGF0b3IgYXV0b21hdGljYWxseTpcbiAgICAgICAgLy8gMS4gRXh0cmFjdHMgdGhlIHNpZ25lciBhZGRyZXNzIGZyb20gdGhlIHNpZ25hdHVyZSAoZWNyZWNvdmVyKVxuICAgICAgICAvLyAyLiBDaGVja3MgaWYgdGhlIHNpZ25lciAob3BlcmF0b3IpIGhhcyBhIHZhbGlkIGRlbGVnYXRpb24gZnJvbSB0aGUgYWdlbnQgYWNjb3VudFxuICAgICAgICAvLyAzLiBWYWxpZGF0ZXMgdGhlIGRlbGVnYXRpb24gc2NvcGUgY292ZXJzIHRoaXMgc2lnbmluZyBvcGVyYXRpb24gKG5vdyBpbmNsdWRlcyBpc1ZhbGlkU2lnbmF0dXJlIHNlbGVjdG9yKVxuICAgICAgICAvLyA0LiBSZXR1cm5zIDB4MTYyNmJhN2UgKHZhbGlkKSBpZiBkZWxlZ2F0aW9uIGlzIHZhbGlkLCAweGZmZmZmZmZmIChpbnZhbGlkKSBvdGhlcndpc2VcbiAgICAgICAgLy9cbiAgICAgICAgLy8gVGhpcyBhbGxvd3MgdGhlIG9wZXJhdG9yJ3Mgc2lnbmF0dXJlIHRvIGJlIHZhbGlkYXRlZCBhcyBpZiBpdCBjYW1lIGZyb20gdGhlIGFnZW50IGFjY291bnQgaXRzZWxmLlxuICAgICAgICBjb25zdCBzYXIgPSB7XG4gICAgICAgICAgICByZXZva2VkQXQ6IDAsXG4gICAgICAgICAgICAvLyBLMSAoMHgwMDAxKSBmb3IgY2xpZW50IEVPQSBpbml0aWF0b3Igc2lnbmF0dXJlXG4gICAgICAgICAgICBpbml0aWF0b3JLZXlUeXBlOiAnMHgwMDAxJyxcbiAgICAgICAgICAgIC8vIERFTEVHQVRFRCAoMHg4MDAyKSBrZXlUeXBlIHRvIGJ5cGFzcyBFUkMtMTI3MSBhbmQgdmFsaWRhdGUgZGVsZWdhdGlvbiBkaXJlY3RseVxuICAgICAgICAgICAgLy8gVGhpcyBjaGVja3MgaWYgdGhlIGFnZW50IGFjY291bnQgaGFzIGRlbGVnYXRlZCB0byB0aGUgb3BlcmF0b3IgRU9BIGRpcmVjdGx5XG4gICAgICAgICAgICBhcHByb3ZlcktleVR5cGU6ICcweDgwMDInLFxuICAgICAgICAgICAgaW5pdGlhdG9yU2lnbmF0dXJlOiAnMHgnLFxuICAgICAgICAgICAgYXBwcm92ZXJTaWduYXR1cmUsXG4gICAgICAgICAgICByZWNvcmQsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBmZWVkYmFja0F1dGg6IHNpZ25lZEF1dGgsXG4gICAgICAgICAgICBkZWxlZ2F0aW9uQXNzb2NpYXRpb246IHtcbiAgICAgICAgICAgICAgICBhc3NvY2lhdGlvbklkLFxuICAgICAgICAgICAgICAgIGluaXRpYXRvckFkZHJlc3MsXG4gICAgICAgICAgICAgICAgYXBwcm92ZXJBZGRyZXNzLFxuICAgICAgICAgICAgICAgIGFzc29jVHlwZTogMSxcbiAgICAgICAgICAgICAgICB2YWxpZEF0LFxuICAgICAgICAgICAgICAgIHZhbGlkVW50aWwsXG4gICAgICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgICAgICBhcHByb3ZlclNpZ25hdHVyZSxcbiAgICAgICAgICAgICAgICBzYXIsXG4gICAgICAgICAgICAgICAgZGVsZWdhdGlvbjoge1xuICAgICAgICAgICAgICAgICAgICAuLi5kZWxlZ2F0aW9uUmVmLFxuICAgICAgICAgICAgICAgICAgICAvLyBJbmNsdWRlIHRoZSBmdWxsIHBheWxvYWQgaW5saW5lIHRvbyAoYmVzdC1lZmZvcnQgY29udmVuaWVuY2UgZm9yIGNsaWVudHMpLFxuICAgICAgICAgICAgICAgICAgICAvLyBidXQgdGhlIGNhbm9uaWNhbCBjb3B5IGlzIHRoZSBJUEZTIHBheWxvYWQgd2hlbiBhdmFpbGFibGUuXG4gICAgICAgICAgICAgICAgICAgIHBheWxvYWQ6IHsgLi4uZGVsZWdhdGlvbiwgc2lnbmF0dXJlU2NoZW1lOiBjaG9zZW4uc2VsZWN0ZWQ/LnNjaGVtZSwgc2lnbmF0dXJlQ2hlY2tlZDogY2hvc2VuLmNoZWNrZWQsIHNpZ25hdHVyZUNoZWNrUmVhc29uOiBjaG9zZW4ucmVhc29uIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignW2NyZWF0ZUZlZWRiYWNrQXV0aFdpdGhEZWxlZ2F0aW9uXSBGYWlsZWQgdG8gY3JlYXRlIGRlbGVnYXRpb24gYXNzb2NpYXRpb24gKGNvbnRpbnVpbmcpOicsIGUpO1xuICAgICAgICByZXR1cm4geyBmZWVkYmFja0F1dGg6IHNpZ25lZEF1dGggfTtcbiAgICB9XG59XG5hc3luYyBmdW5jdGlvbiBjcmVhdGVGZWVkYmFja0F1dGhJbnRlcm5hbChwYXJhbXMpIHtcbiAgICBjb25zdCB7IHB1YmxpY0NsaWVudCwgYWdlbnRJZCwgY2xpZW50QWRkcmVzcywgc2lnbmVyLCB3YWxsZXRDbGllbnQsIGV4cGlyeVNlY29uZHMgPSAzNjAwLCB9ID0gcGFyYW1zO1xuICAgIC8vIEdldCB0aGUgc2hhcmVkIHJlcHV0YXRpb24gY2xpZW50IHNpbmdsZXRvbiAodXNlZCBmb3IgYXV0aCBzdHJ1Y3QgKyBpbmRleCBxdWVyaWVzKVxuICAgIGNvbnN0IHJlcHV0YXRpb25DbGllbnQgPSBhd2FpdCBnZXRSZXB1dGF0aW9uUmVnaXN0cnlDbGllbnQoKTtcbiAgICAvLyBQcmVmZXIgZW52LWNvbmZpZ3VyZWQgSWRlbnRpdHlSZWdpc3RyeSB0byBhdm9pZCBhbiBleHRyYSBvbi1jaGFpbiBjYWxsLlxuICAgIC8vIFRoaXMgaGVscHMgaW4gcmF0ZS1saW1pdGVkIGVudmlyb25tZW50cyAoZS5nLiA0MjlzIGZyb20gUlBDIHByb3ZpZGVycykuXG4gICAgbGV0IGlkZW50aXR5UmVnID0gbnVsbDtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCB7IGdldENoYWluRW52VmFyIH0gPSBhd2FpdCBpbXBvcnQoJy4vY2hhaW5Db25maWcnKTtcbiAgICAgICAgY29uc3QgY2hhaW5JZCA9IE51bWJlcihwdWJsaWNDbGllbnQ/LmNoYWluPy5pZCA/PyAwKTtcbiAgICAgICAgY29uc3QgZnJvbUVudiA9IGNoYWluSWQgPyBnZXRDaGFpbkVudlZhcignQUdFTlRJQ19UUlVTVF9JREVOVElUWV9SRUdJU1RSWScsIGNoYWluSWQpIDogbnVsbDtcbiAgICAgICAgaWYgKGZyb21FbnYgJiYgdHlwZW9mIGZyb21FbnYgPT09ICdzdHJpbmcnICYmIC9eMHhbYS1mQS1GMC05XXs0MH0kLy50ZXN0KGZyb21FbnYpKSB7XG4gICAgICAgICAgICBpZGVudGl0eVJlZyA9IGZyb21FbnY7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2gge1xuICAgICAgICAvLyBpZ25vcmVcbiAgICB9XG4gICAgaWYgKCFpZGVudGl0eVJlZykge1xuICAgICAgICAvLyBGYWxsYmFjazogcmVzb2x2ZSBJZGVudGl0eVJlZ2lzdHJ5IGZyb20gUmVwdXRhdGlvblJlZ2lzdHJ5IG9uLWNoYWluXG4gICAgICAgIGlkZW50aXR5UmVnID0gKGF3YWl0IHJlcHV0YXRpb25DbGllbnQuZ2V0SWRlbnRpdHlSZWdpc3RyeSgpKTtcbiAgICB9XG4gICAgLy8gTG9hZCBJZGVudGl0eVJlZ2lzdHJ5IEFCSSAoYXN5bmMgZHluYW1pYyBpbXBvcnQpXG4gICAgY29uc3QgaWRlbnRpdHlSZWdpc3RyeUFiaSA9IGF3YWl0IGdldElkZW50aXR5UmVnaXN0cnlBYmkoKTtcbiAgICAvLyBFbnN1cmUgSWRlbnRpdHlSZWdpc3RyeSBvcGVyYXRvciBhcHByb3ZhbHMgYXJlIGNvbmZpZ3VyZWQgZm9yIHNlc3Npb25BQVxuICAgIGNvbnNvbGUuaW5mbyhcIioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcIik7XG4gICAgY29uc29sZS5pbmZvKFwiY3JlYXRlRmVlZGJhY2tBdXRoOiBcIiwgYWdlbnRJZCwgY2xpZW50QWRkcmVzcywgc2lnbmVyLmFkZHJlc3MpO1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IG93bmVyT2ZBZ2VudCA9IGF3YWl0IHB1YmxpY0NsaWVudC5yZWFkQ29udHJhY3Qoe1xuICAgICAgICAgICAgYWRkcmVzczogaWRlbnRpdHlSZWcsXG4gICAgICAgICAgICBhYmk6IGlkZW50aXR5UmVnaXN0cnlBYmksXG4gICAgICAgICAgICBmdW5jdGlvbk5hbWU6ICdvd25lck9mJyxcbiAgICAgICAgICAgIGFyZ3M6IFthZ2VudElkXSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGlzT3BlcmF0b3IgPSBhd2FpdCBwdWJsaWNDbGllbnQucmVhZENvbnRyYWN0KHtcbiAgICAgICAgICAgIGFkZHJlc3M6IGlkZW50aXR5UmVnLFxuICAgICAgICAgICAgYWJpOiBpZGVudGl0eVJlZ2lzdHJ5QWJpLFxuICAgICAgICAgICAgZnVuY3Rpb25OYW1lOiAnaXNBcHByb3ZlZEZvckFsbCcsXG4gICAgICAgICAgICBhcmdzOiBbb3duZXJPZkFnZW50LCBzaWduZXIuYWRkcmVzc10sXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB0b2tlbkFwcHJvdmVkID0gYXdhaXQgcHVibGljQ2xpZW50LnJlYWRDb250cmFjdCh7XG4gICAgICAgICAgICBhZGRyZXNzOiBpZGVudGl0eVJlZyxcbiAgICAgICAgICAgIGFiaTogaWRlbnRpdHlSZWdpc3RyeUFiaSxcbiAgICAgICAgICAgIGZ1bmN0aW9uTmFtZTogJ2dldEFwcHJvdmVkJyxcbiAgICAgICAgICAgIGFyZ3M6IFthZ2VudElkXSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnNvbGUuaW5mbygnSWRlbnRpdHlSZWdpc3RyeSBhcHByb3ZhbHM6JywgeyBvd25lck9mQWdlbnQsIGlzT3BlcmF0b3IsIHRva2VuQXBwcm92ZWQgfSk7XG4gICAgICAgIGlmICghaXNPcGVyYXRvciAmJiB0b2tlbkFwcHJvdmVkLnRvTG93ZXJDYXNlKCkgIT09IHNpZ25lci5hZGRyZXNzLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSWRlbnRpdHlSZWdpc3RyeSBhcHByb3ZhbCBtaXNzaW5nOiBuZWl0aGVyIGlzQXBwcm92ZWRGb3JBbGwgbm9yIGdldEFwcHJvdmVkYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdbSWRlbnRpdHlSZWdpc3RyeV0gYXBwcm92YWwgY2hlY2sgZmFpbGVkOicsIGU/Lm1lc3NhZ2UgfHwgZSk7XG4gICAgICAgIHRocm93IGU7XG4gICAgfVxuICAgIC8vIFJlc29sdmUgdGhlIGFnZW50QWNjb3VudCBhdXRob3JpdHkgYWRkcmVzcyBmcm9tIG9uLWNoYWluIG1ldGFkYXRhLlxuICAgIC8vIFRoaXMgaXMgdGhlIGFkZHJlc3Mgd2Ugd2FudCB2ZXJpZmllcnMgdG8gYXR0cmlidXRlIGZlZWRiYWNrQXV0aC9kZWxlZ2F0aW9ucyB0by5cbiAgICBsZXQgYXV0aG9yaXR5QWRkcmVzcyA9IHNpZ25lci5hZGRyZXNzO1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGFnZW50QWNjb3VudFJhdyA9IGF3YWl0IHB1YmxpY0NsaWVudC5yZWFkQ29udHJhY3Qoe1xuICAgICAgICAgICAgYWRkcmVzczogaWRlbnRpdHlSZWcsXG4gICAgICAgICAgICBhYmk6IGlkZW50aXR5UmVnaXN0cnlBYmksXG4gICAgICAgICAgICBmdW5jdGlvbk5hbWU6ICdnZXRNZXRhZGF0YScsXG4gICAgICAgICAgICBhcmdzOiBbYWdlbnRJZCwgJ2FnZW50QWNjb3VudCddLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgYWdlbnRBY2NvdW50U3RyID0gdHJ5RGVjb2RlTWV0YWRhdGFTdHJpbmcoYWdlbnRBY2NvdW50UmF3KTtcbiAgICAgICAgY29uc3QgcGFyc2VkID0gcGFyc2VBZ2VudEFjY291bnRNZXRhZGF0YShhZ2VudEFjY291bnRTdHIpO1xuICAgICAgICBpZiAocGFyc2VkKVxuICAgICAgICAgICAgYXV0aG9yaXR5QWRkcmVzcyA9IHBhcnNlZDtcbiAgICAgICAgY29uc29sZS5pbmZvKCdbRmVlZGJhY2tBdXRoXSBSZXNvbHZlZCBhdXRob3JpdHlBZGRyZXNzOicsIHtcbiAgICAgICAgICAgIGFnZW50SWQ6IGFnZW50SWQudG9TdHJpbmcoKSxcbiAgICAgICAgICAgIGF1dGhvcml0eUFkZHJlc3MsXG4gICAgICAgICAgICBhZ2VudEFjY291bnRTdHIsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ1tGZWVkYmFja0F1dGhdIFVuYWJsZSB0byByZXNvbHZlIGFnZW50QWNjb3VudCBmcm9tIG1ldGFkYXRhOyBmYWxsaW5nIGJhY2sgdG8gc2lnbmVyLmFkZHJlc3MnLCBlKTtcbiAgICB9XG4gICAgY29uc3Qgbm93U2VjID0gQmlnSW50KE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDEwMDApKTtcbiAgICBjb25zdCBjaGFpbklkID0gQmlnSW50KHB1YmxpY0NsaWVudC5jaGFpbj8uaWQgPz8gMCk7XG4gICAgY29uc3QgVTY0X01BWCA9IDE4NDQ2NzQ0MDczNzA5NTUxNjE1bjtcbiAgICBjb25zdCBsYXN0SW5kZXhGZXRjaGVkID0gYXdhaXQgcmVwdXRhdGlvbkNsaWVudC5nZXRMYXN0SW5kZXgoYWdlbnRJZCwgY2xpZW50QWRkcmVzcyk7XG4gICAgbGV0IGluZGV4TGltaXQgPSBsYXN0SW5kZXhGZXRjaGVkICsgMW47XG4gICAgbGV0IGV4cGlyeSA9IG5vd1NlYyArIEJpZ0ludChleHBpcnlTZWNvbmRzKTtcbiAgICBpZiAoZXhwaXJ5ID4gVTY0X01BWCkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ1tGZWVkYmFja0F1dGhdIENvbXB1dGVkIGV4cGlyeSBleGNlZWRzIHVpbnQ2NDsgY2xhbXBpbmcgdG8gbWF4Jyk7XG4gICAgICAgIGV4cGlyeSA9IFU2NF9NQVg7XG4gICAgfVxuICAgIC8vIEJ1aWxkIEZlZWRiYWNrQXV0aCBzdHJ1Y3QgdmlhIFJlcHV0YXRpb25DbGllbnRcbiAgICBjb25zb2xlLmluZm8oXCJjcmVhdGUgZmVlZGJhY2sgYXV0aCBzdHJ1Y3R1cmU6IFwiLCBhZ2VudElkLCBjbGllbnRBZGRyZXNzLCBpbmRleExpbWl0LCBleHBpcnksIGNoYWluSWQsIGF1dGhvcml0eUFkZHJlc3MpO1xuICAgIGNvbnN0IGF1dGhTdHJ1Y3QgPSByZXB1dGF0aW9uQ2xpZW50LmNyZWF0ZUZlZWRiYWNrQXV0aChhZ2VudElkLCBjbGllbnRBZGRyZXNzLCBpbmRleExpbWl0LCBleHBpcnksIGNoYWluSWQsIFxuICAgIC8vIElNUE9SVEFOVDogYXR0cmlidXRlIGF1dGggdG8gYWdlbnRBY2NvdW50IGF1dGhvcml0eSwgbm90IHRoZSBvcGVyYXRvciBrZXkuXG4gICAgYXV0aG9yaXR5QWRkcmVzcyk7XG4gICAgLy8gTm90ZTogbG9nIHRoZSBzdHJ1Y3QgZGlyZWN0bHk7IEpTT04uc3RyaW5naWZ5IGNhbm5vdCBoYW5kbGUgQmlnSW50IHZhbHVlcy5cbiAgICBjb25zb2xlLmluZm8oJ2F1dGhTdHJ1Y3Q6JywgYXV0aFN0cnVjdCk7XG4gICAgLy8gU2lnbiBrZWNjYWsyNTYoZW5jb2RlZCB0dXBsZSkgd2l0aCBwcm92aWRlZCBzaWduZXIgKHNlc3Npb25BQSB2aWEgRVJDLTEyNzEpXG4gICAgY29uc3QgZW5jb2RlZCA9IGV0aGVycy5BYmlDb2Rlci5kZWZhdWx0QWJpQ29kZXIoKS5lbmNvZGUoWyd1aW50MjU2JywgJ2FkZHJlc3MnLCAndWludDI1NicsICd1aW50MjU2JywgJ3VpbnQyNTYnLCAnYWRkcmVzcycsICdhZGRyZXNzJ10sIFtcbiAgICAgICAgYXV0aFN0cnVjdC5hZ2VudElkLFxuICAgICAgICBhdXRoU3RydWN0LmNsaWVudEFkZHJlc3MsXG4gICAgICAgIGF1dGhTdHJ1Y3QuaW5kZXhMaW1pdCxcbiAgICAgICAgYXV0aFN0cnVjdC5leHBpcnksXG4gICAgICAgIGF1dGhTdHJ1Y3QuY2hhaW5JZCxcbiAgICAgICAgYXV0aFN0cnVjdC5pZGVudGl0eVJlZ2lzdHJ5LFxuICAgICAgICBhdXRoU3RydWN0LnNpZ25lckFkZHJlc3MsXG4gICAgXSk7XG4gICAgY29uc3QgbWVzc2FnZUhhc2ggPSBldGhlcnMua2VjY2FrMjU2KGVuY29kZWQpO1xuICAgIC8vIFNpZ24gdGhlIG1lc3NhZ2UgaGFzaCB1c2luZyB0aGUgd2FsbGV0IGNsaWVudFxuICAgIGlmICghd2FsbGV0Q2xpZW50KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignd2FsbGV0Q2xpZW50IGlzIHJlcXVpcmVkIGZvciBzaWduaW5nIGZlZWRiYWNrIGF1dGgnKTtcbiAgICB9XG4gICAgY29uc3Qgc2lnbmF0dXJlID0gYXdhaXQgd2FsbGV0Q2xpZW50LnNpZ25NZXNzYWdlKHtcbiAgICAgICAgYWNjb3VudDogc2lnbmVyLFxuICAgICAgICBtZXNzYWdlOiB7IHJhdzogZXRoZXJzLmdldEJ5dGVzKG1lc3NhZ2VIYXNoKSB9LFxuICAgIH0pO1xuICAgIGNvbnNvbGUuaW5mbyhcInNpZ25hdHVyZTogXCIsIHNpZ25hdHVyZSk7XG4gICAgY29uc3Qgc2lnbmVkQXV0aCA9IGV0aGVycy5jb25jYXQoW2VuY29kZWQsIHNpZ25hdHVyZV0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIHNpZ25lZEF1dGgsXG4gICAgICAgIGF1dGhTdHJ1Y3QsXG4gICAgICAgIGVuY29kZWQ6IGVuY29kZWQsXG4gICAgICAgIGNoYWluSWQsXG4gICAgICAgIGluZGV4TGltaXQsXG4gICAgICAgIGV4cGlyeSxcbiAgICAgICAgaWRlbnRpdHlSZWdpc3RyeTogaWRlbnRpdHlSZWcsXG4gICAgICAgIGF1dGhvcml0eUFkZHJlc3MsXG4gICAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFnZW50RmVlZGJhY2suanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@agentic-trust/core/dist/server/lib/agentFeedback.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@agentic-trust/core/dist/server/lib/agentRegistration.js":
/*!***********************************************************************************!*\
  !*** ../../node_modules/@agentic-trust/core/dist/server/lib/agentRegistration.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createRegistrationJSON: () => (/* binding */ createRegistrationJSON),\n/* harmony export */   getRegistration: () => (/* binding */ getRegistration),\n/* harmony export */   uploadRegistration: () => (/* binding */ uploadRegistration)\n/* harmony export */ });\n/* harmony import */ var _ipfs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ipfs */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/lib/ipfs.js\");\n/* harmony import */ var _chainConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./chainConfig */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/lib/chainConfig.js\");\n/**\n * ERC-8004 Agent Registration JSON\n *\n * Standard JSON structure for agent registration metadata\n * Stored on IPFS and referenced via Identity Token tokenUri\n */\n\n\n/**\n * Upload agent registration JSON to IPFS\n * @param registration - Registration JSON data\n * @param storage - Optional IPFS storage instance (uses singleton if not provided)\n * @returns Upload result with CID and URL\n */\nasync function uploadRegistration(registration, storage) {\n    const ipfsStorage = storage || (0,_ipfs__WEBPACK_IMPORTED_MODULE_0__.getIPFSStorage)();\n    // Ensure ERC-8004 type is set\n    const registrationWithType = {\n        ...registration,\n        type: registration.type || 'https://eips.ethereum.org/EIPS/eip-8004#registration-v1',\n        // Set timestamps for legacy fields if not provided\n        createdAt: registration.createdAt || new Date().toISOString(),\n        updatedAt: registration.updatedAt || new Date().toISOString(),\n    };\n    console.log('[uploadRegistration] registration.supportedTrust:', registration.supportedTrust);\n    console.log('[uploadRegistration] registrationWithType.supportedTrust:', registrationWithType.supportedTrust);\n    // Convert to JSON string\n    const jsonString = JSON.stringify(registrationWithType, null, 2);\n    console.log('[uploadRegistration] JSON string includes supportedTrust:', jsonString.includes('supportedTrust'));\n    // Upload to IPFS\n    const result = await ipfsStorage.upload(jsonString, 'registration.json');\n    // Return with tokenUri format (ipfs://CID)\n    const tokenUri = `ipfs://${result.cid}`;\n    return {\n        cid: result.cid,\n        url: result.url,\n        tokenUri,\n    };\n}\n/**\n * Retrieve agent registration JSON from IPFS\n * @param cidOrTokenUri - CID, tokenUri (ipfs://CID format), or full gateway URL\n * @param storage - Optional IPFS storage instance (uses singleton if not provided)\n * @returns Registration JSON data\n */\nasync function getRegistration(cidOrTokenUri, storage) {\n    const ipfsStorage = storage || (0,_ipfs__WEBPACK_IMPORTED_MODULE_0__.getIPFSStorage)();\n    // Use the new getJson method which handles all URI formats and gateway fallbacks\n    const registration = await ipfsStorage.getJson(cidOrTokenUri);\n    if (!registration) {\n        throw new Error(`Failed to retrieve registration from IPFS: ${cidOrTokenUri}`);\n    }\n    return registration;\n}\n/**\n * Create registration JSON from agent data\n * Helper function to build ERC-8004 compliant registration JSON\n */\nfunction createRegistrationJSON(params) {\n    const endpoints = (params.endpoints ? params.endpoints.map(e => ({ ...e })) : [])\n        // Never include MCP endpoint entries in registration JSON.\n        .filter(e => e.name !== 'MCP');\n    // If agentUrl is provided, automatically create an A2A endpoint\n    if (params.agentUrl) {\n        const baseUrl = params.agentUrl.replace(/\\/$/, ''); // Remove trailing slash\n        // Upsert A2A endpoint (always align to agentUrl so provider base URLs or other defaults\n        // don't accidentally become the registered A2A endpoint).\n        // Default to the canonical A2A agent card location (agent-card.json).\n        const a2aEndpoint = `${baseUrl}/.well-known/agent-card.json`;\n        const existingA2A = endpoints.find(e => e.name === 'A2A');\n        if (existingA2A) {\n            if (existingA2A.endpoint !== a2aEndpoint) {\n                console.warn('[createRegistrationJSON] Overriding A2A endpoint to match agentUrl:', {\n                    agentUrl: baseUrl,\n                    previous: existingA2A.endpoint,\n                    next: a2aEndpoint,\n                });\n            }\n            existingA2A.endpoint = a2aEndpoint;\n            existingA2A.version = existingA2A.version || '0.30';\n            // Preserve a2aSkills if already set\n        }\n        else {\n            endpoints.push({\n                name: 'A2A',\n                endpoint: a2aEndpoint,\n                version: '0.30',\n            });\n        }\n    }\n    // Build registrations array.\n    // If agentId is known (post-create update), populate it; otherwise leave null.\n    const registrations = [];\n    const registryAddress = params.identityRegistry ??\n        (params.chainId ? (0,_chainConfig__WEBPACK_IMPORTED_MODULE_1__.getChainContractAddress)('AGENTIC_TRUST_IDENTITY_REGISTRY', params.chainId) : undefined);\n    if (params.chainId && registryAddress) {\n        registrations.push({\n            agentId: params.agentId ?? null,\n            agentRegistry: `eip155:${params.chainId}:${String(registryAddress)}`,\n            registeredAt: new Date().toISOString(),\n        });\n    }\n    const registration = {\n        type: 'https://eips.ethereum.org/EIPS/eip-8004#registration-v1',\n        name: params.name,\n        description: params.description,\n        image: params.image,\n        active: typeof params.active === 'boolean' ? params.active : true,\n        endpoints: endpoints.length > 0 ? endpoints : undefined,\n        registrations: registrations.length > 0 ? registrations : undefined,\n        agentAccount: params.agentAccount,\n        // Registry metadata fields\n        registeredBy: 'agentic-trust',\n        registryNamespace: 'erc-8004',\n        uaid: params.uaid,\n        // Legacy fields\n        metadata: params.metadata,\n        external_url: params.external_url,\n        attributes: params.attributes,\n        createdAt: new Date().toISOString(),\n        updatedAt: new Date().toISOString(),\n    };\n    // Explicitly include supportedTrust if it's an array (even if empty)\n    // JSON.stringify will omit undefined properties, but will include arrays\n    if (Array.isArray(params.supportedTrust)) {\n        registration.supportedTrust = params.supportedTrust;\n    }\n    console.log('[createRegistrationJSON] supportedTrust:', params.supportedTrust);\n    console.log('[createRegistrationJSON] registration.supportedTrust:', registration.supportedTrust);\n    return registration;\n}\n//# sourceMappingURL=agentRegistration.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BhZ2VudGljLXRydXN0L2NvcmUvZGlzdC9zZXJ2ZXIvbGliL2FnZW50UmVnaXN0cmF0aW9uLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ3dDO0FBQ2dCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsbUNBQW1DLHFEQUFjO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLFdBQVc7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxtQ0FBbUMscURBQWM7QUFDakQ7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLGNBQWM7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLHVFQUF1RSxNQUFNO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixRQUFRO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RDtBQUNBO0FBQ0EsMEJBQTBCLHFFQUF1QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsZUFBZSxHQUFHLHdCQUF3QjtBQUMvRTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvYmFyYi9hYS9Bc3NvY2lhdGVkQWNjb3VudHMvbm9kZV9tb2R1bGVzL0BhZ2VudGljLXRydXN0L2NvcmUvZGlzdC9zZXJ2ZXIvbGliL2FnZW50UmVnaXN0cmF0aW9uLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogRVJDLTgwMDQgQWdlbnQgUmVnaXN0cmF0aW9uIEpTT05cbiAqXG4gKiBTdGFuZGFyZCBKU09OIHN0cnVjdHVyZSBmb3IgYWdlbnQgcmVnaXN0cmF0aW9uIG1ldGFkYXRhXG4gKiBTdG9yZWQgb24gSVBGUyBhbmQgcmVmZXJlbmNlZCB2aWEgSWRlbnRpdHkgVG9rZW4gdG9rZW5VcmlcbiAqL1xuaW1wb3J0IHsgZ2V0SVBGU1N0b3JhZ2UgfSBmcm9tICcuL2lwZnMnO1xuaW1wb3J0IHsgZ2V0Q2hhaW5Db250cmFjdEFkZHJlc3MgfSBmcm9tICcuL2NoYWluQ29uZmlnJztcbi8qKlxuICogVXBsb2FkIGFnZW50IHJlZ2lzdHJhdGlvbiBKU09OIHRvIElQRlNcbiAqIEBwYXJhbSByZWdpc3RyYXRpb24gLSBSZWdpc3RyYXRpb24gSlNPTiBkYXRhXG4gKiBAcGFyYW0gc3RvcmFnZSAtIE9wdGlvbmFsIElQRlMgc3RvcmFnZSBpbnN0YW5jZSAodXNlcyBzaW5nbGV0b24gaWYgbm90IHByb3ZpZGVkKVxuICogQHJldHVybnMgVXBsb2FkIHJlc3VsdCB3aXRoIENJRCBhbmQgVVJMXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB1cGxvYWRSZWdpc3RyYXRpb24ocmVnaXN0cmF0aW9uLCBzdG9yYWdlKSB7XG4gICAgY29uc3QgaXBmc1N0b3JhZ2UgPSBzdG9yYWdlIHx8IGdldElQRlNTdG9yYWdlKCk7XG4gICAgLy8gRW5zdXJlIEVSQy04MDA0IHR5cGUgaXMgc2V0XG4gICAgY29uc3QgcmVnaXN0cmF0aW9uV2l0aFR5cGUgPSB7XG4gICAgICAgIC4uLnJlZ2lzdHJhdGlvbixcbiAgICAgICAgdHlwZTogcmVnaXN0cmF0aW9uLnR5cGUgfHwgJ2h0dHBzOi8vZWlwcy5ldGhlcmV1bS5vcmcvRUlQUy9laXAtODAwNCNyZWdpc3RyYXRpb24tdjEnLFxuICAgICAgICAvLyBTZXQgdGltZXN0YW1wcyBmb3IgbGVnYWN5IGZpZWxkcyBpZiBub3QgcHJvdmlkZWRcbiAgICAgICAgY3JlYXRlZEF0OiByZWdpc3RyYXRpb24uY3JlYXRlZEF0IHx8IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgdXBkYXRlZEF0OiByZWdpc3RyYXRpb24udXBkYXRlZEF0IHx8IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICB9O1xuICAgIGNvbnNvbGUubG9nKCdbdXBsb2FkUmVnaXN0cmF0aW9uXSByZWdpc3RyYXRpb24uc3VwcG9ydGVkVHJ1c3Q6JywgcmVnaXN0cmF0aW9uLnN1cHBvcnRlZFRydXN0KTtcbiAgICBjb25zb2xlLmxvZygnW3VwbG9hZFJlZ2lzdHJhdGlvbl0gcmVnaXN0cmF0aW9uV2l0aFR5cGUuc3VwcG9ydGVkVHJ1c3Q6JywgcmVnaXN0cmF0aW9uV2l0aFR5cGUuc3VwcG9ydGVkVHJ1c3QpO1xuICAgIC8vIENvbnZlcnQgdG8gSlNPTiBzdHJpbmdcbiAgICBjb25zdCBqc29uU3RyaW5nID0gSlNPTi5zdHJpbmdpZnkocmVnaXN0cmF0aW9uV2l0aFR5cGUsIG51bGwsIDIpO1xuICAgIGNvbnNvbGUubG9nKCdbdXBsb2FkUmVnaXN0cmF0aW9uXSBKU09OIHN0cmluZyBpbmNsdWRlcyBzdXBwb3J0ZWRUcnVzdDonLCBqc29uU3RyaW5nLmluY2x1ZGVzKCdzdXBwb3J0ZWRUcnVzdCcpKTtcbiAgICAvLyBVcGxvYWQgdG8gSVBGU1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGlwZnNTdG9yYWdlLnVwbG9hZChqc29uU3RyaW5nLCAncmVnaXN0cmF0aW9uLmpzb24nKTtcbiAgICAvLyBSZXR1cm4gd2l0aCB0b2tlblVyaSBmb3JtYXQgKGlwZnM6Ly9DSUQpXG4gICAgY29uc3QgdG9rZW5VcmkgPSBgaXBmczovLyR7cmVzdWx0LmNpZH1gO1xuICAgIHJldHVybiB7XG4gICAgICAgIGNpZDogcmVzdWx0LmNpZCxcbiAgICAgICAgdXJsOiByZXN1bHQudXJsLFxuICAgICAgICB0b2tlblVyaSxcbiAgICB9O1xufVxuLyoqXG4gKiBSZXRyaWV2ZSBhZ2VudCByZWdpc3RyYXRpb24gSlNPTiBmcm9tIElQRlNcbiAqIEBwYXJhbSBjaWRPclRva2VuVXJpIC0gQ0lELCB0b2tlblVyaSAoaXBmczovL0NJRCBmb3JtYXQpLCBvciBmdWxsIGdhdGV3YXkgVVJMXG4gKiBAcGFyYW0gc3RvcmFnZSAtIE9wdGlvbmFsIElQRlMgc3RvcmFnZSBpbnN0YW5jZSAodXNlcyBzaW5nbGV0b24gaWYgbm90IHByb3ZpZGVkKVxuICogQHJldHVybnMgUmVnaXN0cmF0aW9uIEpTT04gZGF0YVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0UmVnaXN0cmF0aW9uKGNpZE9yVG9rZW5VcmksIHN0b3JhZ2UpIHtcbiAgICBjb25zdCBpcGZzU3RvcmFnZSA9IHN0b3JhZ2UgfHwgZ2V0SVBGU1N0b3JhZ2UoKTtcbiAgICAvLyBVc2UgdGhlIG5ldyBnZXRKc29uIG1ldGhvZCB3aGljaCBoYW5kbGVzIGFsbCBVUkkgZm9ybWF0cyBhbmQgZ2F0ZXdheSBmYWxsYmFja3NcbiAgICBjb25zdCByZWdpc3RyYXRpb24gPSBhd2FpdCBpcGZzU3RvcmFnZS5nZXRKc29uKGNpZE9yVG9rZW5VcmkpO1xuICAgIGlmICghcmVnaXN0cmF0aW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHJldHJpZXZlIHJlZ2lzdHJhdGlvbiBmcm9tIElQRlM6ICR7Y2lkT3JUb2tlblVyaX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlZ2lzdHJhdGlvbjtcbn1cbi8qKlxuICogQ3JlYXRlIHJlZ2lzdHJhdGlvbiBKU09OIGZyb20gYWdlbnQgZGF0YVxuICogSGVscGVyIGZ1bmN0aW9uIHRvIGJ1aWxkIEVSQy04MDA0IGNvbXBsaWFudCByZWdpc3RyYXRpb24gSlNPTlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlUmVnaXN0cmF0aW9uSlNPTihwYXJhbXMpIHtcbiAgICBjb25zdCBlbmRwb2ludHMgPSAocGFyYW1zLmVuZHBvaW50cyA/IHBhcmFtcy5lbmRwb2ludHMubWFwKGUgPT4gKHsgLi4uZSB9KSkgOiBbXSlcbiAgICAgICAgLy8gTmV2ZXIgaW5jbHVkZSBNQ1AgZW5kcG9pbnQgZW50cmllcyBpbiByZWdpc3RyYXRpb24gSlNPTi5cbiAgICAgICAgLmZpbHRlcihlID0+IGUubmFtZSAhPT0gJ01DUCcpO1xuICAgIC8vIElmIGFnZW50VXJsIGlzIHByb3ZpZGVkLCBhdXRvbWF0aWNhbGx5IGNyZWF0ZSBhbiBBMkEgZW5kcG9pbnRcbiAgICBpZiAocGFyYW1zLmFnZW50VXJsKSB7XG4gICAgICAgIGNvbnN0IGJhc2VVcmwgPSBwYXJhbXMuYWdlbnRVcmwucmVwbGFjZSgvXFwvJC8sICcnKTsgLy8gUmVtb3ZlIHRyYWlsaW5nIHNsYXNoXG4gICAgICAgIC8vIFVwc2VydCBBMkEgZW5kcG9pbnQgKGFsd2F5cyBhbGlnbiB0byBhZ2VudFVybCBzbyBwcm92aWRlciBiYXNlIFVSTHMgb3Igb3RoZXIgZGVmYXVsdHNcbiAgICAgICAgLy8gZG9uJ3QgYWNjaWRlbnRhbGx5IGJlY29tZSB0aGUgcmVnaXN0ZXJlZCBBMkEgZW5kcG9pbnQpLlxuICAgICAgICAvLyBEZWZhdWx0IHRvIHRoZSBjYW5vbmljYWwgQTJBIGFnZW50IGNhcmQgbG9jYXRpb24gKGFnZW50LWNhcmQuanNvbikuXG4gICAgICAgIGNvbnN0IGEyYUVuZHBvaW50ID0gYCR7YmFzZVVybH0vLndlbGwta25vd24vYWdlbnQtY2FyZC5qc29uYDtcbiAgICAgICAgY29uc3QgZXhpc3RpbmdBMkEgPSBlbmRwb2ludHMuZmluZChlID0+IGUubmFtZSA9PT0gJ0EyQScpO1xuICAgICAgICBpZiAoZXhpc3RpbmdBMkEpIHtcbiAgICAgICAgICAgIGlmIChleGlzdGluZ0EyQS5lbmRwb2ludCAhPT0gYTJhRW5kcG9pbnQpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1tjcmVhdGVSZWdpc3RyYXRpb25KU09OXSBPdmVycmlkaW5nIEEyQSBlbmRwb2ludCB0byBtYXRjaCBhZ2VudFVybDonLCB7XG4gICAgICAgICAgICAgICAgICAgIGFnZW50VXJsOiBiYXNlVXJsLFxuICAgICAgICAgICAgICAgICAgICBwcmV2aW91czogZXhpc3RpbmdBMkEuZW5kcG9pbnQsXG4gICAgICAgICAgICAgICAgICAgIG5leHQ6IGEyYUVuZHBvaW50LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXhpc3RpbmdBMkEuZW5kcG9pbnQgPSBhMmFFbmRwb2ludDtcbiAgICAgICAgICAgIGV4aXN0aW5nQTJBLnZlcnNpb24gPSBleGlzdGluZ0EyQS52ZXJzaW9uIHx8ICcwLjMwJztcbiAgICAgICAgICAgIC8vIFByZXNlcnZlIGEyYVNraWxscyBpZiBhbHJlYWR5IHNldFxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZW5kcG9pbnRzLnB1c2goe1xuICAgICAgICAgICAgICAgIG5hbWU6ICdBMkEnLFxuICAgICAgICAgICAgICAgIGVuZHBvaW50OiBhMmFFbmRwb2ludCxcbiAgICAgICAgICAgICAgICB2ZXJzaW9uOiAnMC4zMCcsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBCdWlsZCByZWdpc3RyYXRpb25zIGFycmF5LlxuICAgIC8vIElmIGFnZW50SWQgaXMga25vd24gKHBvc3QtY3JlYXRlIHVwZGF0ZSksIHBvcHVsYXRlIGl0OyBvdGhlcndpc2UgbGVhdmUgbnVsbC5cbiAgICBjb25zdCByZWdpc3RyYXRpb25zID0gW107XG4gICAgY29uc3QgcmVnaXN0cnlBZGRyZXNzID0gcGFyYW1zLmlkZW50aXR5UmVnaXN0cnkgPz9cbiAgICAgICAgKHBhcmFtcy5jaGFpbklkID8gZ2V0Q2hhaW5Db250cmFjdEFkZHJlc3MoJ0FHRU5USUNfVFJVU1RfSURFTlRJVFlfUkVHSVNUUlknLCBwYXJhbXMuY2hhaW5JZCkgOiB1bmRlZmluZWQpO1xuICAgIGlmIChwYXJhbXMuY2hhaW5JZCAmJiByZWdpc3RyeUFkZHJlc3MpIHtcbiAgICAgICAgcmVnaXN0cmF0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgIGFnZW50SWQ6IHBhcmFtcy5hZ2VudElkID8/IG51bGwsXG4gICAgICAgICAgICBhZ2VudFJlZ2lzdHJ5OiBgZWlwMTU1OiR7cGFyYW1zLmNoYWluSWR9OiR7U3RyaW5nKHJlZ2lzdHJ5QWRkcmVzcyl9YCxcbiAgICAgICAgICAgIHJlZ2lzdGVyZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgcmVnaXN0cmF0aW9uID0ge1xuICAgICAgICB0eXBlOiAnaHR0cHM6Ly9laXBzLmV0aGVyZXVtLm9yZy9FSVBTL2VpcC04MDA0I3JlZ2lzdHJhdGlvbi12MScsXG4gICAgICAgIG5hbWU6IHBhcmFtcy5uYW1lLFxuICAgICAgICBkZXNjcmlwdGlvbjogcGFyYW1zLmRlc2NyaXB0aW9uLFxuICAgICAgICBpbWFnZTogcGFyYW1zLmltYWdlLFxuICAgICAgICBhY3RpdmU6IHR5cGVvZiBwYXJhbXMuYWN0aXZlID09PSAnYm9vbGVhbicgPyBwYXJhbXMuYWN0aXZlIDogdHJ1ZSxcbiAgICAgICAgZW5kcG9pbnRzOiBlbmRwb2ludHMubGVuZ3RoID4gMCA/IGVuZHBvaW50cyA6IHVuZGVmaW5lZCxcbiAgICAgICAgcmVnaXN0cmF0aW9uczogcmVnaXN0cmF0aW9ucy5sZW5ndGggPiAwID8gcmVnaXN0cmF0aW9ucyA6IHVuZGVmaW5lZCxcbiAgICAgICAgYWdlbnRBY2NvdW50OiBwYXJhbXMuYWdlbnRBY2NvdW50LFxuICAgICAgICAvLyBSZWdpc3RyeSBtZXRhZGF0YSBmaWVsZHNcbiAgICAgICAgcmVnaXN0ZXJlZEJ5OiAnYWdlbnRpYy10cnVzdCcsXG4gICAgICAgIHJlZ2lzdHJ5TmFtZXNwYWNlOiAnZXJjLTgwMDQnLFxuICAgICAgICB1YWlkOiBwYXJhbXMudWFpZCxcbiAgICAgICAgLy8gTGVnYWN5IGZpZWxkc1xuICAgICAgICBtZXRhZGF0YTogcGFyYW1zLm1ldGFkYXRhLFxuICAgICAgICBleHRlcm5hbF91cmw6IHBhcmFtcy5leHRlcm5hbF91cmwsXG4gICAgICAgIGF0dHJpYnV0ZXM6IHBhcmFtcy5hdHRyaWJ1dGVzLFxuICAgICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgdXBkYXRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgfTtcbiAgICAvLyBFeHBsaWNpdGx5IGluY2x1ZGUgc3VwcG9ydGVkVHJ1c3QgaWYgaXQncyBhbiBhcnJheSAoZXZlbiBpZiBlbXB0eSlcbiAgICAvLyBKU09OLnN0cmluZ2lmeSB3aWxsIG9taXQgdW5kZWZpbmVkIHByb3BlcnRpZXMsIGJ1dCB3aWxsIGluY2x1ZGUgYXJyYXlzXG4gICAgaWYgKEFycmF5LmlzQXJyYXkocGFyYW1zLnN1cHBvcnRlZFRydXN0KSkge1xuICAgICAgICByZWdpc3RyYXRpb24uc3VwcG9ydGVkVHJ1c3QgPSBwYXJhbXMuc3VwcG9ydGVkVHJ1c3Q7XG4gICAgfVxuICAgIGNvbnNvbGUubG9nKCdbY3JlYXRlUmVnaXN0cmF0aW9uSlNPTl0gc3VwcG9ydGVkVHJ1c3Q6JywgcGFyYW1zLnN1cHBvcnRlZFRydXN0KTtcbiAgICBjb25zb2xlLmxvZygnW2NyZWF0ZVJlZ2lzdHJhdGlvbkpTT05dIHJlZ2lzdHJhdGlvbi5zdXBwb3J0ZWRUcnVzdDonLCByZWdpc3RyYXRpb24uc3VwcG9ydGVkVHJ1c3QpO1xuICAgIHJldHVybiByZWdpc3RyYXRpb247XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hZ2VudFJlZ2lzdHJhdGlvbi5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@agentic-trust/core/dist/server/lib/agentRegistration.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@agentic-trust/core/dist/server/lib/agenticTrust.js":
/*!******************************************************************************!*\
  !*** ../../node_modules/@agentic-trust/core/dist/server/lib/agenticTrust.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getAgenticTrustClient: () => (/* binding */ getAgenticTrustClient)\n/* harmony export */ });\n/* harmony import */ var _singletons_agenticTrustClient__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../singletons/agenticTrustClient */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/singletons/agenticTrustClient.js\");\n/* harmony import */ var _chainConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./chainConfig */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/lib/chainConfig.js\");\n/**\n * Environment-configured AgenticTrustClient factory for server-side apps.\n *\n * This helper creates an AgenticTrustClient using environment variables.\n */\n\n\n/**\n * Create an AgenticTrustClient using environment configuration.\n *\n * - Uses AGENTIC_TRUST_DISCOVERY_URL and AGENTIC_TRUST_DISCOVERY_API_KEY for GraphQL.\n * - Uses AGENTIC_TRUST_ADMIN_PRIVATE_KEY for signing.\n * - Derives RPC URL, identity registry, and reputation registry from chain config helpers.\n * - Optionally wires a session package when AGENTIC_TRUST_SESSION_PACKAGE_PATH and\n *   AGENTIC_TRUST_ENS_REGISTRY are configured.\n */\nasync function getAgenticTrustClient() {\n    try {\n        const discoveryUrl = process.env.AGENTIC_TRUST_DISCOVERY_URL;\n        const apiKey = process.env.AGENTIC_TRUST_DISCOVERY_API_KEY;\n        if (!discoveryUrl) {\n            throw new Error('Missing required environment variable: AGENTIC_TRUST_DISCOVERY_URL. ' +\n                'This is required for the AgenticTrustClient to connect to the discovery GraphQL API.');\n        }\n        if (!apiKey) {\n            console.warn('[AgenticTrustClient] Warning: AGENTIC_TRUST_DISCOVERY_API_KEY environment variable is not set. ' +\n                'Discovery API requests may fail with authentication errors. Set AGENTIC_TRUST_DISCOVERY_API_KEY to your access code.');\n        }\n        const privateKey = process.env.AGENTIC_TRUST_ADMIN_PRIVATE_KEY;\n        const rpcUrl = (0,_chainConfig__WEBPACK_IMPORTED_MODULE_1__.getChainRpcUrl)(_chainConfig__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_CHAIN_ID);\n        // Get chain-specific configuration (identity / reputation / ENS registry)\n        const { getChainEnvVar } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./chainConfig */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/lib/chainConfig.js\"));\n        const identityRegistry = getChainEnvVar('AGENTIC_TRUST_IDENTITY_REGISTRY', _chainConfig__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_CHAIN_ID);\n        const reputationRegistry = getChainEnvVar('AGENTIC_TRUST_REPUTATION_REGISTRY', _chainConfig__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_CHAIN_ID);\n        const ensRegistry = getChainEnvVar('AGENTIC_TRUST_ENS_REGISTRY', _chainConfig__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_CHAIN_ID);\n        // Session package configuration (for provider-style deployments)\n        const sessionPackagePath = process.env.AGENTIC_TRUST_SESSION_PACKAGE_PATH;\n        const config = {\n            timeout: 30000,\n            headers: {\n                Accept: 'application/json',\n            },\n        };\n        if (discoveryUrl) {\n            config.graphQLUrl = discoveryUrl;\n        }\n        if (apiKey) {\n            config.apiKey = apiKey;\n        }\n        if (privateKey) {\n            config.privateKey = privateKey;\n        }\n        if (rpcUrl) {\n            config.rpcUrl = rpcUrl;\n        }\n        if (identityRegistry) {\n            config.identityRegistry = identityRegistry;\n        }\n        if (reputationRegistry) {\n            config.reputationRegistry = reputationRegistry;\n        }\n        if (sessionPackagePath && ensRegistry) {\n            config.sessionPackage = {\n                filePath: sessionPackagePath,\n                ensRegistry: ensRegistry,\n            };\n        }\n        return await _singletons_agenticTrustClient__WEBPACK_IMPORTED_MODULE_0__.AgenticTrustClient.create(config);\n    }\n    catch (error) {\n        throw error;\n    }\n}\n//# sourceMappingURL=agenticTrust.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BhZ2VudGljLXRydXN0L2NvcmUvZGlzdC9zZXJ2ZXIvbGliL2FnZW50aWNUcnVzdC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ3NFO0FBQ0w7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsNERBQWMsQ0FBQywwREFBZ0I7QUFDdEQ7QUFDQSxnQkFBZ0IsaUJBQWlCLFFBQVEsd0xBQXVCO0FBQ2hFLG1GQUFtRiwwREFBZ0I7QUFDbkcsdUZBQXVGLDBEQUFnQjtBQUN2Ryx5RUFBeUUsMERBQWdCO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiw4RUFBa0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9iYXJiL2FhL0Fzc29jaWF0ZWRBY2NvdW50cy9ub2RlX21vZHVsZXMvQGFnZW50aWMtdHJ1c3QvY29yZS9kaXN0L3NlcnZlci9saWIvYWdlbnRpY1RydXN0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogRW52aXJvbm1lbnQtY29uZmlndXJlZCBBZ2VudGljVHJ1c3RDbGllbnQgZmFjdG9yeSBmb3Igc2VydmVyLXNpZGUgYXBwcy5cbiAqXG4gKiBUaGlzIGhlbHBlciBjcmVhdGVzIGFuIEFnZW50aWNUcnVzdENsaWVudCB1c2luZyBlbnZpcm9ubWVudCB2YXJpYWJsZXMuXG4gKi9cbmltcG9ydCB7IEFnZW50aWNUcnVzdENsaWVudCB9IGZyb20gJy4uL3NpbmdsZXRvbnMvYWdlbnRpY1RydXN0Q2xpZW50JztcbmltcG9ydCB7IGdldENoYWluUnBjVXJsLCBERUZBVUxUX0NIQUlOX0lEIH0gZnJvbSAnLi9jaGFpbkNvbmZpZyc7XG4vKipcbiAqIENyZWF0ZSBhbiBBZ2VudGljVHJ1c3RDbGllbnQgdXNpbmcgZW52aXJvbm1lbnQgY29uZmlndXJhdGlvbi5cbiAqXG4gKiAtIFVzZXMgQUdFTlRJQ19UUlVTVF9ESVNDT1ZFUllfVVJMIGFuZCBBR0VOVElDX1RSVVNUX0RJU0NPVkVSWV9BUElfS0VZIGZvciBHcmFwaFFMLlxuICogLSBVc2VzIEFHRU5USUNfVFJVU1RfQURNSU5fUFJJVkFURV9LRVkgZm9yIHNpZ25pbmcuXG4gKiAtIERlcml2ZXMgUlBDIFVSTCwgaWRlbnRpdHkgcmVnaXN0cnksIGFuZCByZXB1dGF0aW9uIHJlZ2lzdHJ5IGZyb20gY2hhaW4gY29uZmlnIGhlbHBlcnMuXG4gKiAtIE9wdGlvbmFsbHkgd2lyZXMgYSBzZXNzaW9uIHBhY2thZ2Ugd2hlbiBBR0VOVElDX1RSVVNUX1NFU1NJT05fUEFDS0FHRV9QQVRIIGFuZFxuICogICBBR0VOVElDX1RSVVNUX0VOU19SRUdJU1RSWSBhcmUgY29uZmlndXJlZC5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEFnZW50aWNUcnVzdENsaWVudCgpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBkaXNjb3ZlcnlVcmwgPSBwcm9jZXNzLmVudi5BR0VOVElDX1RSVVNUX0RJU0NPVkVSWV9VUkw7XG4gICAgICAgIGNvbnN0IGFwaUtleSA9IHByb2Nlc3MuZW52LkFHRU5USUNfVFJVU1RfRElTQ09WRVJZX0FQSV9LRVk7XG4gICAgICAgIGlmICghZGlzY292ZXJ5VXJsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgcmVxdWlyZWQgZW52aXJvbm1lbnQgdmFyaWFibGU6IEFHRU5USUNfVFJVU1RfRElTQ09WRVJZX1VSTC4gJyArXG4gICAgICAgICAgICAgICAgJ1RoaXMgaXMgcmVxdWlyZWQgZm9yIHRoZSBBZ2VudGljVHJ1c3RDbGllbnQgdG8gY29ubmVjdCB0byB0aGUgZGlzY292ZXJ5IEdyYXBoUUwgQVBJLicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghYXBpS2V5KSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ1tBZ2VudGljVHJ1c3RDbGllbnRdIFdhcm5pbmc6IEFHRU5USUNfVFJVU1RfRElTQ09WRVJZX0FQSV9LRVkgZW52aXJvbm1lbnQgdmFyaWFibGUgaXMgbm90IHNldC4gJyArXG4gICAgICAgICAgICAgICAgJ0Rpc2NvdmVyeSBBUEkgcmVxdWVzdHMgbWF5IGZhaWwgd2l0aCBhdXRoZW50aWNhdGlvbiBlcnJvcnMuIFNldCBBR0VOVElDX1RSVVNUX0RJU0NPVkVSWV9BUElfS0VZIHRvIHlvdXIgYWNjZXNzIGNvZGUuJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJpdmF0ZUtleSA9IHByb2Nlc3MuZW52LkFHRU5USUNfVFJVU1RfQURNSU5fUFJJVkFURV9LRVk7XG4gICAgICAgIGNvbnN0IHJwY1VybCA9IGdldENoYWluUnBjVXJsKERFRkFVTFRfQ0hBSU5fSUQpO1xuICAgICAgICAvLyBHZXQgY2hhaW4tc3BlY2lmaWMgY29uZmlndXJhdGlvbiAoaWRlbnRpdHkgLyByZXB1dGF0aW9uIC8gRU5TIHJlZ2lzdHJ5KVxuICAgICAgICBjb25zdCB7IGdldENoYWluRW52VmFyIH0gPSBhd2FpdCBpbXBvcnQoJy4vY2hhaW5Db25maWcnKTtcbiAgICAgICAgY29uc3QgaWRlbnRpdHlSZWdpc3RyeSA9IGdldENoYWluRW52VmFyKCdBR0VOVElDX1RSVVNUX0lERU5USVRZX1JFR0lTVFJZJywgREVGQVVMVF9DSEFJTl9JRCk7XG4gICAgICAgIGNvbnN0IHJlcHV0YXRpb25SZWdpc3RyeSA9IGdldENoYWluRW52VmFyKCdBR0VOVElDX1RSVVNUX1JFUFVUQVRJT05fUkVHSVNUUlknLCBERUZBVUxUX0NIQUlOX0lEKTtcbiAgICAgICAgY29uc3QgZW5zUmVnaXN0cnkgPSBnZXRDaGFpbkVudlZhcignQUdFTlRJQ19UUlVTVF9FTlNfUkVHSVNUUlknLCBERUZBVUxUX0NIQUlOX0lEKTtcbiAgICAgICAgLy8gU2Vzc2lvbiBwYWNrYWdlIGNvbmZpZ3VyYXRpb24gKGZvciBwcm92aWRlci1zdHlsZSBkZXBsb3ltZW50cylcbiAgICAgICAgY29uc3Qgc2Vzc2lvblBhY2thZ2VQYXRoID0gcHJvY2Vzcy5lbnYuQUdFTlRJQ19UUlVTVF9TRVNTSU9OX1BBQ0tBR0VfUEFUSDtcbiAgICAgICAgY29uc3QgY29uZmlnID0ge1xuICAgICAgICAgICAgdGltZW91dDogMzAwMDAsXG4gICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgQWNjZXB0OiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICBpZiAoZGlzY292ZXJ5VXJsKSB7XG4gICAgICAgICAgICBjb25maWcuZ3JhcGhRTFVybCA9IGRpc2NvdmVyeVVybDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXBpS2V5KSB7XG4gICAgICAgICAgICBjb25maWcuYXBpS2V5ID0gYXBpS2V5O1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcml2YXRlS2V5KSB7XG4gICAgICAgICAgICBjb25maWcucHJpdmF0ZUtleSA9IHByaXZhdGVLZXk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJwY1VybCkge1xuICAgICAgICAgICAgY29uZmlnLnJwY1VybCA9IHJwY1VybDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaWRlbnRpdHlSZWdpc3RyeSkge1xuICAgICAgICAgICAgY29uZmlnLmlkZW50aXR5UmVnaXN0cnkgPSBpZGVudGl0eVJlZ2lzdHJ5O1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXB1dGF0aW9uUmVnaXN0cnkpIHtcbiAgICAgICAgICAgIGNvbmZpZy5yZXB1dGF0aW9uUmVnaXN0cnkgPSByZXB1dGF0aW9uUmVnaXN0cnk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlc3Npb25QYWNrYWdlUGF0aCAmJiBlbnNSZWdpc3RyeSkge1xuICAgICAgICAgICAgY29uZmlnLnNlc3Npb25QYWNrYWdlID0ge1xuICAgICAgICAgICAgICAgIGZpbGVQYXRoOiBzZXNzaW9uUGFja2FnZVBhdGgsXG4gICAgICAgICAgICAgICAgZW5zUmVnaXN0cnk6IGVuc1JlZ2lzdHJ5LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXdhaXQgQWdlbnRpY1RydXN0Q2xpZW50LmNyZWF0ZShjb25maWcpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWdlbnRpY1RydXN0LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@agentic-trust/core/dist/server/lib/agenticTrust.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@agentic-trust/core/dist/server/lib/agents.js":
/*!************************************************************************!*\
  !*** ../../node_modules/@agentic-trust/core/dist/server/lib/agents.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AgentsAPI: () => (/* binding */ AgentsAPI)\n/* harmony export */ });\n/* harmony import */ var _agentic_trust_8004_ext_sdk__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @agentic-trust/8004-ext-sdk */ \"(rsc)/../../node_modules/@agentic-trust/8004-ext-sdk/dist/index.js\");\n/* harmony import */ var _agentic_trust_8004_sdk__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @agentic-trust/8004-sdk */ \"(rsc)/../../node_modules/@agentic-trust/8004-sdk/dist/index.js\");\n/* harmony import */ var _agent__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./agent */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/lib/agent.js\");\n/* harmony import */ var _singletons_discoveryClient__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../singletons/discoveryClient */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/singletons/discoveryClient.js\");\n/* harmony import */ var _chainConfig__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./chainConfig */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/lib/chainConfig.js\");\n/* harmony import */ var _accounts__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./accounts */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/lib/accounts.js\");\n/* harmony import */ var _agentRegistration__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./agentRegistration */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/lib/agentRegistration.js\");\n/* harmony import */ var _uaid__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./uaid */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/lib/uaid.js\");\n/* harmony import */ var _shared_didEthr__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../shared/didEthr */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/shared/didEthr.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! viem */ \"(rsc)/../../node_modules/viem/_esm/clients/createPublicClient.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! viem */ \"(rsc)/../../node_modules/viem/_esm/clients/transports/http.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! viem */ \"(rsc)/../../node_modules/viem/_esm/utils/abi/encodeFunctionData.js\");\n/* harmony import */ var _userApps_adminApp__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../userApps/adminApp */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/userApps/adminApp.js\");\n/* harmony import */ var _agentic_trust_8004_ext_sdk_abis_IdentityRegistry_json__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @agentic-trust/8004-ext-sdk/abis/IdentityRegistry.json */ \"(rsc)/../../node_modules/@agentic-trust/8004-ext-sdk/abis/IdentityRegistry.json\");\n/* harmony import */ var _metamask_smart_accounts_kit__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! @metamask/smart-accounts-kit */ \"(rsc)/../../node_modules/@metamask/smart-accounts-kit/dist/index.mjs\");\n/* harmony import */ var _metamask_smart_accounts_kit__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! @metamask/smart-accounts-kit */ \"(rsc)/../../node_modules/@metamask/smart-accounts-kit/dist/chunk-7MRTROLV.mjs\");\n/* harmony import */ var viem_account_abstraction__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! viem/account-abstraction */ \"(rsc)/../../node_modules/viem/_esm/account-abstraction/clients/createBundlerClient.js\");\n/* harmony import */ var _names__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./names */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/lib/names.js\");\n/* harmony import */ var _client_accountClient__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../client/accountClient */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/client/accountClient.js\");\n/* harmony import */ var _singletons_ensClient__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../singletons/ensClient */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/singletons/ensClient.js\");\n/* harmony import */ var _discoveryErrors__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./discoveryErrors */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/lib/discoveryErrors.js\");\n\nasync function getAccountNonce(accountClient) {\n    if (typeof accountClient?.getNonce === 'function') {\n        try {\n            const value = await accountClient.getNonce();\n            if (typeof value === 'bigint') {\n                accountClient.nonce = value;\n                return value;\n            }\n        }\n        catch { }\n    }\n    if (typeof accountClient?.nonce === 'bigint') {\n        return accountClient.nonce;\n    }\n    return undefined;\n}\nasync function sendUserOpWithTimeout(params) {\n    const { timeoutMs = 20000, nonce, ...rest } = params;\n    if (typeof nonce === 'bigint') {\n        rest.accountClient.nonce = nonce;\n    }\n    const sendPromise = (async () => {\n        const hash = await (0,_client_accountClient__WEBPACK_IMPORTED_MODULE_1__.sendSponsoredUserOperation)(rest);\n        const receipt = await (0,_client_accountClient__WEBPACK_IMPORTED_MODULE_1__.waitForUserOperationReceipt)({\n            bundlerUrl: rest.bundlerUrl,\n            chain: rest.chain,\n            hash,\n        });\n        return { hash, receipt };\n    })();\n    return await Promise.race([\n        sendPromise,\n        new Promise((_, reject) => setTimeout(() => reject(new Error('Timeout waiting for UserOperation')), timeoutMs)),\n    ]);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst identityRegistryAbi = _agentic_trust_8004_ext_sdk_abis_IdentityRegistry_json__WEBPACK_IMPORTED_MODULE_11__.default ?? _agentic_trust_8004_ext_sdk_abis_IdentityRegistry_json__WEBPACK_IMPORTED_MODULE_11__;\nfunction safeParseJson(value) {\n    try {\n        return JSON.parse(value);\n    }\n    catch {\n        return undefined;\n    }\n}\nfunction normalizeToStringArray(...values) {\n    for (const value of values) {\n        if (Array.isArray(value)) {\n            return value.map((item) => String(item));\n        }\n        if (typeof value === 'string') {\n            return [value];\n        }\n    }\n    return [];\n}\nfunction includesEveryCaseInsensitive(source, expected) {\n    if (!expected.length) {\n        return true;\n    }\n    if (!source.length) {\n        return false;\n    }\n    const sourceLower = source.map((value) => value.toLowerCase());\n    return expected.every((value) => sourceLower.includes(value.toLowerCase()));\n}\nclass AgentsAPI {\n    client;\n    constructor(client) {\n        this.client = client;\n    }\n    /**\n     * List all agents\n     * Query uses the actual schema fields from the API\n     * Returns agents sorted by agentId in descending order\n     * Fetches all agents using pagination if needed\n     */\n    async listAgents(options) {\n        return this.searchAgents(options ?? {});\n    }\n    /**\n     * Get a single agent by ID\n     * @param agentId - The agent ID as a string\n     * @param chainId - Optional chain ID (defaults to 11155111 for Sepolia)\n     */\n    async getAgent(agentId, chainId = 11155111) {\n        return this.client.getAgent(agentId, chainId);\n    }\n    async getAgentByDid(did8004) {\n        return this.client.getAgentByDid(did8004);\n    }\n    /**\n     * Get a fully-hydrated AgentDetail for a given agentId and chainId.\n     * This method is kept for backwards compatibility but simply delegates\n     * to the top-level AgenticTrustClient.getAgentDetails helper.\n     */\n    async getAgentDetails(agentId, chainId) {\n        return this.client.getAgentDetails(agentId, chainId);\n    }\n    /**\n     * Get raw agent data from discovery (for internal use)\n     * Returns the raw AgentData from the discovery indexer\n     */\n    async getAgentFromDiscovery(chainId, agentId) {\n        const discoveryClient = await (0,_singletons_discoveryClient__WEBPACK_IMPORTED_MODULE_4__.getDiscoveryClient)();\n        try {\n            return await discoveryClient.getAgent(chainId, agentId);\n        }\n        catch (error) {\n            // Check if this is an access code/auth error and provide a clearer message\n            (0,_discoveryErrors__WEBPACK_IMPORTED_MODULE_14__.rethrowDiscoveryError)(error, 'agents.getAgentFromDiscovery');\n        }\n    }\n    async getAgentFromDiscoveryByDid(did8004) {\n        const { agentId, chainId } = (0,_agentic_trust_8004_ext_sdk__WEBPACK_IMPORTED_MODULE_0__.parseDid8004)(did8004);\n        return this.getAgentFromDiscovery(chainId, agentId);\n    }\n    /**\n     * Refresh/Index an agent in the GraphQL indexer\n     * Triggers the indexer to re-index the specified agent\n     * @param agentId - Agent ID to refresh (required)\n     * @param chainId - Optional chain ID (defaults to 11155111 for Sepolia)\n     */\n    async refreshAgent(agentId, chainId = 11155111) {\n        const discoveryClient = await (0,_singletons_discoveryClient__WEBPACK_IMPORTED_MODULE_4__.getDiscoveryClient)();\n        try {\n            return await discoveryClient.refreshAgent(agentId, chainId);\n        }\n        catch (error) {\n            (0,_discoveryErrors__WEBPACK_IMPORTED_MODULE_14__.rethrowDiscoveryError)(error, 'agents.refreshAgent');\n        }\n    }\n    async refreshAgentByDid(agentDid) {\n        const { agentId, chainId } = (0,_agentic_trust_8004_ext_sdk__WEBPACK_IMPORTED_MODULE_0__.parseDid8004)(agentDid);\n        return this.refreshAgent(agentId, chainId);\n    }\n    /**\n     * Get the approved NFT operator address for an agent\n     * Returns the address approved to operate on the agent's NFT token, or null if no operator is set\n     *\n     * @param agentId - The agent ID (string or number)\n     * @param chainId - Optional chain ID (defaults to 11155111 for Sepolia)\n     * @returns The approved operator address, or null if no operator is set\n     */\n    async getNFTOperator(agentId, chainId = 11155111) {\n        try {\n            const { getIdentityRegistryClient } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ../singletons/identityClient */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/singletons/identityClient.js\"));\n            const resolvedChainId = chainId || _chainConfig__WEBPACK_IMPORTED_MODULE_5__.DEFAULT_CHAIN_ID;\n            const agentIdBigInt = BigInt(agentId);\n            const identityClient = await getIdentityRegistryClient(resolvedChainId);\n            const operatorAddress = await identityClient.getNFTOperator(agentIdBigInt);\n            if (typeof operatorAddress === 'string' && /^0x[a-fA-F0-9]{40}$/.test(operatorAddress)) {\n                return operatorAddress;\n            }\n            return null;\n        }\n        catch (error) {\n            console.warn('[AgentsAPI.getNFTOperator] Failed to get NFT operator:', error);\n            return null;\n        }\n    }\n    /**\n     * Create a new agent\n     * Requires AdminApp to be initialized (server-side)\n     * @param params - Agent creation parameters\n     * @returns Created agent ID and transaction hash, or prepared transaction for client-side signing\n     */\n    async createAgentWithEOAOwnerUsingWallet(params) {\n        const targetChainId = params.chainId || _chainConfig__WEBPACK_IMPORTED_MODULE_5__.DEFAULT_CHAIN_ID;\n        const adminApp = await (0,_userApps_adminApp__WEBPACK_IMPORTED_MODULE_10__.getAdminApp)(undefined, targetChainId);\n        if (!adminApp) {\n            throw new Error('AdminApp not initialized. Ensure AGENTIC_TRUST_APP_ROLES includes \"admin\" and provide either AGENTIC_TRUST_ADMIN_PRIVATE_KEY or connect via wallet');\n        }\n        const identityRegistry = (0,_chainConfig__WEBPACK_IMPORTED_MODULE_5__.requireChainEnvVar)('AGENTIC_TRUST_IDENTITY_REGISTRY', targetChainId);\n        const identityRegistryHex = identityRegistry.startsWith('0x')\n            ? identityRegistry\n            : `0x${identityRegistry}`;\n        // Create registration JSON and upload to IPFS\n        let tokenUri = '';\n        const chainId = targetChainId;\n        console.log('[agents.createAgentWithEOAOwnerUsingWallet] Using chainId', chainId);\n        let uaid;\n        try {\n            const didEthr = (0,_shared_didEthr__WEBPACK_IMPORTED_MODULE_9__.buildDidEthr)(chainId, params.agentAccount, { encode: false });\n            const uid = didEthr;\n            const nativeId = `eip155:${chainId}:${params.agentAccount}`;\n            const domain = typeof params.agentUrl === 'string' && params.agentUrl.trim()\n                ? (() => {\n                    try {\n                        return new URL(params.agentUrl).hostname;\n                    }\n                    catch {\n                        return undefined;\n                    }\n                })()\n                : undefined;\n            uaid = (await (0,_uaid__WEBPACK_IMPORTED_MODULE_8__.generateHcs14UaidDidTarget)({\n                targetDid: didEthr,\n                routing: {\n                    registry: 'erc-8004',\n                    proto: 'a2a',\n                    nativeId,\n                    uid,\n                    domain,\n                },\n            })).uaid;\n        }\n        catch (error) {\n            console.warn('[agents.createAgentWithEOAOwnerUsingWallet] Failed to generate UAID:', error);\n        }\n        try {\n            const registrationJSON = (0,_agentRegistration__WEBPACK_IMPORTED_MODULE_7__.createRegistrationJSON)({\n                name: params.agentName,\n                agentAccount: params.agentAccount,\n                description: params.description,\n                image: params.image,\n                agentUrl: params.agentUrl,\n                chainId,\n                identityRegistry: identityRegistryHex,\n                supportedTrust: params.supportedTrust,\n                endpoints: params.endpoints,\n                uaid,\n            });\n            const uploadResult = await (0,_agentRegistration__WEBPACK_IMPORTED_MODULE_7__.uploadRegistration)(registrationJSON);\n            tokenUri = uploadResult.tokenUri;\n        }\n        catch (error) {\n            console.error('Failed to upload registration JSON to IPFS:', error);\n            throw new Error(`Failed to create registration JSON: ${error instanceof Error ? error.message : 'Unknown error'}`);\n        }\n        // If no private key, prepare transaction for client-side signing\n        if (!adminApp.hasPrivateKey) {\n            // Prepare transaction for client-side signing\n            // Build metadata array\n            const metadata = [\n                { key: 'agentName', value: params.agentName ? String(params.agentName) : '' },\n                { key: 'agentAccount', value: params.agentAccount ? String(params.agentAccount) : '' },\n                ...(params.agentCategory ? [{ key: 'agentCategory', value: String(params.agentCategory) }] : []),\n                { key: 'registeredBy', value: 'agentic-trust' },\n                { key: 'registryNamespace', value: 'erc-8004' },\n                ...(uaid ? [{ key: 'uaid', value: uaid }] : []),\n            ].filter(m => m.value !== '');\n            // Prepare transaction using AIAgentIdentityClient (all Ethereum logic server-side)\n            // Get chain by ID\n            const chain = (0,_chainConfig__WEBPACK_IMPORTED_MODULE_5__.getChainById)(chainId);\n            const rpcUrl = (0,_chainConfig__WEBPACK_IMPORTED_MODULE_5__.getChainRpcUrl)(chainId);\n            const publicClient = (0,viem__WEBPACK_IMPORTED_MODULE_15__.createPublicClient)({\n                chain: chain,\n                transport: (0,viem__WEBPACK_IMPORTED_MODULE_16__.http)(rpcUrl),\n            });\n            const accountProvider = new _agentic_trust_8004_sdk__WEBPACK_IMPORTED_MODULE_2__.ViemAccountProvider({\n                publicClient: publicClient,\n                walletClient: null, // Read-only for transaction preparation\n                chainConfig: {\n                    id: chainId,\n                    rpcUrl: rpcUrl,\n                    name: chain.name,\n                    chain: chain,\n                },\n            });\n            const aiIdentityClient = new _agentic_trust_8004_ext_sdk__WEBPACK_IMPORTED_MODULE_0__.AIAgentIdentityClient({\n                accountProvider,\n                identityRegistryAddress: identityRegistryHex,\n            });\n            // Prepare complete transaction (encoding, gas estimation, nonce, etc.)\n            // AIAgentIdentityClient handles all Ethereum logic internally using its publicClient\n            const transaction = await aiIdentityClient.prepareRegisterTransaction(tokenUri, metadata, adminApp.address // Only address needed - no publicClient passed\n            );\n            return {\n                requiresClientSigning: true,\n                transaction,\n                tokenUri,\n                metadata: metadata.map(m => ({ key: m.key, value: m.value })),\n            };\n        }\n        // Check wallet balance before attempting transaction\n        try {\n            const balance = await adminApp.publicClient.getBalance({ address: adminApp.address });\n            if (balance === 0n) {\n                throw new Error(`Wallet ${adminApp.address} has zero balance. Please fund the wallet with Sepolia ETH to pay for gas.`);\n            }\n            console.log(`Wallet balance: ${balance.toString()} wei (${(Number(balance) / 1e18).toFixed(6)} ETH)`);\n        }\n        catch (balanceError) {\n            if (balanceError.message.includes('zero balance')) {\n                throw balanceError;\n            }\n            console.warn('Could not check wallet balance:', balanceError.message);\n        }\n        // Create write-capable IdentityClient using AdminApp AccountProvider\n        const identityClient = new _agentic_trust_8004_sdk__WEBPACK_IMPORTED_MODULE_2__.BaseIdentityClient(adminApp.accountProvider, identityRegistryHex);\n        // Build metadata array\n        // For agentAccount (address), we need to pass it as-is since it's already a hex string\n        // IdentityClient.stringToBytes will encode strings as UTF-8, which is fine for agentName\n        // but agentAccount should be treated as an address string (which will be encoded as UTF-8)\n        // Note: The contract expects bytes, and encoding the address string as UTF-8 is acceptable\n        // as long as it's consistently decoded on read\n        const metadata = [\n            { key: 'agentName', value: params.agentName ? String(params.agentName) : '' },\n            { key: 'agentAccount', value: params.agentAccount ? String(params.agentAccount) : '' },\n            ...(params.agentCategory ? [{ key: 'agentCategory', value: String(params.agentCategory) }] : []),\n            { key: 'registeredBy', value: 'agentic-trust' },\n            { key: 'registryNamespace', value: 'erc-8004' },\n            ...(uaid ? [{ key: 'uaid', value: uaid }] : []),\n        ].filter(m => m.value !== ''); // Remove empty values\n        // Use direct EOA transaction path (existing behavior)\n        const result = await identityClient.registerWithMetadata(tokenUri, metadata);\n        // After we have an agentId, write it back by updating tokenUri so registrations[].agentId is populated.\n        try {\n            const agentIdStr = result.agentId.toString();\n            const updatedRegistrationJSON = (0,_agentRegistration__WEBPACK_IMPORTED_MODULE_7__.createRegistrationJSON)({\n                name: params.agentName,\n                agentAccount: params.agentAccount,\n                agentId: agentIdStr,\n                description: params.description,\n                image: params.image,\n                agentUrl: params.agentUrl,\n                chainId,\n                identityRegistry: identityRegistryHex,\n                supportedTrust: params.supportedTrust,\n                endpoints: params.endpoints,\n                uaid,\n            });\n            const updatedUpload = await (0,_agentRegistration__WEBPACK_IMPORTED_MODULE_7__.uploadRegistration)(updatedRegistrationJSON);\n            await identityClient.setAgentUri(BigInt(agentIdStr), updatedUpload.tokenUri);\n        }\n        catch (uaidError) {\n            console.warn('[agents.createAgentWithEOAOwnerUsingWallet] Failed to finalize tokenUri update with agentId:', uaidError);\n        }\n        // Refresh the agent in the GraphQL indexer\n        try {\n            const discoveryClient = await (0,_singletons_discoveryClient__WEBPACK_IMPORTED_MODULE_4__.getDiscoveryClient)();\n            await discoveryClient.refreshAgent(result.agentId.toString(), chainId);\n            console.log(` Refreshed agent ${result.agentId} in GraphQL indexer`);\n        }\n        catch (refreshError) {\n            // Log error but don't fail agent creation if refresh fails\n            console.warn(` Failed to refresh agent ${result.agentId} in GraphQL indexer:`, refreshError);\n        }\n        return result;\n    }\n    /**\n     * Create a new agent for EOA using the server admin private key.\n     * Same interface as createAgentWithEOAOwnerUsingWallet, but always executes the transaction server-side.\n     */\n    async createAgentWithEOAOwnerUsingPrivateKey(params) {\n        const targetChainId = params.chainId || _chainConfig__WEBPACK_IMPORTED_MODULE_5__.DEFAULT_CHAIN_ID;\n        const adminApp = await (0,_userApps_adminApp__WEBPACK_IMPORTED_MODULE_10__.getAdminApp)(undefined, targetChainId);\n        if (!adminApp) {\n            throw new Error('AdminApp not initialized. Ensure AGENTIC_TRUST_APP_ROLES includes \"admin\" and provide AGENTIC_TRUST_ADMIN_PRIVATE_KEY');\n        }\n        if (!adminApp.hasPrivateKey) {\n            throw new Error('Admin private key not available on server. Cannot execute server-side transaction.');\n        }\n        const identityRegistry = (0,_chainConfig__WEBPACK_IMPORTED_MODULE_5__.requireChainEnvVar)('AGENTIC_TRUST_IDENTITY_REGISTRY', targetChainId);\n        const identityRegistryHex = identityRegistry.startsWith('0x') ? identityRegistry : `0x${identityRegistry}`;\n        // Create registration JSON and upload to IPFS\n        let tokenUri = '';\n        let uaid;\n        try {\n            const didEthr = (0,_shared_didEthr__WEBPACK_IMPORTED_MODULE_9__.buildDidEthr)(targetChainId, params.agentAccount, { encode: false });\n            const uid = didEthr;\n            const nativeId = `eip155:${targetChainId}:${params.agentAccount}`;\n            const domain = typeof params.agentUrl === 'string' && params.agentUrl.trim()\n                ? (() => {\n                    try {\n                        return new URL(params.agentUrl).hostname;\n                    }\n                    catch {\n                        return undefined;\n                    }\n                })()\n                : undefined;\n            uaid = (await (0,_uaid__WEBPACK_IMPORTED_MODULE_8__.generateHcs14UaidDidTarget)({\n                targetDid: didEthr,\n                routing: {\n                    registry: 'erc-8004',\n                    proto: 'a2a',\n                    nativeId,\n                    uid,\n                    domain,\n                },\n            })).uaid;\n        }\n        catch (error) {\n            console.warn('[agents.createAgentWithEOAOwnerUsingPrivateKey] Failed to generate UAID:', error);\n        }\n        try {\n            const registrationJSON = (0,_agentRegistration__WEBPACK_IMPORTED_MODULE_7__.createRegistrationJSON)({\n                name: params.agentName,\n                agentAccount: params.agentAccount,\n                description: params.description,\n                image: params.image,\n                agentUrl: params.agentUrl,\n                chainId: targetChainId,\n                identityRegistry: identityRegistryHex,\n                supportedTrust: params.supportedTrust,\n                endpoints: params.endpoints,\n                uaid,\n            });\n            const uploadResult = await (0,_agentRegistration__WEBPACK_IMPORTED_MODULE_7__.uploadRegistration)(registrationJSON);\n            tokenUri = uploadResult.tokenUri;\n        }\n        catch (error) {\n            console.error('Failed to upload registration JSON to IPFS:', error);\n            throw new Error(`Failed to create registration JSON: ${error instanceof Error ? error.message : 'Unknown error'}`);\n        }\n        // Create write-capable IdentityClient using AdminApp AccountProvider\n        const identityClient = new _agentic_trust_8004_sdk__WEBPACK_IMPORTED_MODULE_2__.BaseIdentityClient(adminApp.accountProvider, identityRegistryHex);\n        // Build metadata\n        const metadata = [\n            { key: 'agentName', value: params.agentName ? String(params.agentName) : '' },\n            { key: 'agentAccount', value: params.agentAccount ? String(params.agentAccount) : '' },\n            ...(params.agentCategory ? [{ key: 'agentCategory', value: String(params.agentCategory) }] : []),\n            { key: 'registeredBy', value: 'agentic-trust' },\n            { key: 'registryNamespace', value: 'erc-8004' },\n            ...(uaid ? [{ key: 'uaid', value: uaid }] : []),\n        ].filter(m => m.value !== '');\n        // Execute registration\n        const result = await identityClient.registerWithMetadata(tokenUri, metadata);\n        // After we have an agentId, write it back by updating tokenUri so registrations[].agentId is populated.\n        try {\n            const agentIdStr = result.agentId.toString();\n            const updatedRegistrationJSON = (0,_agentRegistration__WEBPACK_IMPORTED_MODULE_7__.createRegistrationJSON)({\n                name: params.agentName,\n                agentAccount: params.agentAccount,\n                agentId: agentIdStr,\n                description: params.description,\n                image: params.image,\n                agentUrl: params.agentUrl,\n                chainId: targetChainId,\n                identityRegistry: identityRegistryHex,\n                supportedTrust: params.supportedTrust,\n                endpoints: params.endpoints,\n                uaid,\n            });\n            const updatedUpload = await (0,_agentRegistration__WEBPACK_IMPORTED_MODULE_7__.uploadRegistration)(updatedRegistrationJSON);\n            await identityClient.setAgentUri(BigInt(agentIdStr), updatedUpload.tokenUri);\n        }\n        catch (uaidError) {\n            console.warn('[agents.createAgentWithEOAOwnerUsingPrivateKey] Failed to finalize tokenUri update with agentId:', uaidError);\n        }\n        // Refresh in indexer (best-effort)\n        try {\n            const discoveryClient = await (0,_singletons_discoveryClient__WEBPACK_IMPORTED_MODULE_4__.getDiscoveryClient)();\n            await discoveryClient.refreshAgent(result.agentId.toString(), targetChainId);\n        }\n        catch (refreshError) {\n            console.warn(` Failed to refresh agent ${result.agentId} in GraphQL indexer:`, refreshError);\n        }\n        return result;\n    }\n    async createAgentWithSmartAccountOwnerUsingWallet(params) {\n        const chainId = params.chainId || _chainConfig__WEBPACK_IMPORTED_MODULE_5__.DEFAULT_CHAIN_ID;\n        const adminApp = await (0,_userApps_adminApp__WEBPACK_IMPORTED_MODULE_10__.getAdminApp)(undefined, chainId);\n        if (!adminApp) {\n            throw new Error('AdminApp not initialized. Ensure AGENTIC_TRUST_APP_ROLES includes \"admin\" and provide either AGENTIC_TRUST_ADMIN_PRIVATE_KEY or connect via wallet');\n        }\n        const identityRegistry = (0,_chainConfig__WEBPACK_IMPORTED_MODULE_5__.requireChainEnvVar)('AGENTIC_TRUST_IDENTITY_REGISTRY', chainId);\n        const identityRegistryHex = identityRegistry.startsWith('0x')\n            ? identityRegistry\n            : `0x${identityRegistry}`;\n        // UAID in DID-target form using agent account did:ethr (available pre-registration).\n        let uaid;\n        try {\n            const didEthr = (0,_shared_didEthr__WEBPACK_IMPORTED_MODULE_9__.buildDidEthr)(chainId, params.agentAccount, { encode: false });\n            const uid = didEthr;\n            const nativeId = `eip155:${chainId}:${params.agentAccount}`;\n            const domain = typeof params.agentUrl === 'string' && params.agentUrl.trim()\n                ? (() => {\n                    try {\n                        return new URL(params.agentUrl).hostname;\n                    }\n                    catch {\n                        return undefined;\n                    }\n                })()\n                : undefined;\n            const result = await (0,_uaid__WEBPACK_IMPORTED_MODULE_8__.generateHcs14UaidDidTarget)({\n                targetDid: didEthr,\n                routing: {\n                    registry: 'erc-8004',\n                    proto: 'a2a',\n                    nativeId,\n                    uid,\n                    domain,\n                },\n            });\n            uaid = result.uaid;\n        }\n        catch (error) {\n            console.warn('[agents.createAgentWithSmartAccountOwnerUsingWallet] Failed to generate UAID:', error);\n        }\n        // Create registration JSON and upload to IPFS\n        let tokenUri = '';\n        console.log('[agents.createAgentWithSmartAccountOwnerUsingWallet] Using chainId', chainId);\n        try {\n            const registrationJSON = (0,_agentRegistration__WEBPACK_IMPORTED_MODULE_7__.createRegistrationJSON)({\n                name: params.agentName,\n                agentAccount: params.agentAccount,\n                description: params.description,\n                image: params.image,\n                agentUrl: params.agentUrl,\n                chainId,\n                identityRegistry: identityRegistryHex,\n                supportedTrust: params.supportedTrust,\n                endpoints: params.endpoints,\n                uaid,\n            });\n            const uploadResult = await (0,_agentRegistration__WEBPACK_IMPORTED_MODULE_7__.uploadRegistration)(registrationJSON);\n            tokenUri = uploadResult.tokenUri;\n        }\n        catch (error) {\n            console.error('Failed to upload registration JSON to IPFS:', error);\n            throw new Error(`Failed to create registration JSON: ${error instanceof Error ? error.message : 'Unknown error'}`);\n        }\n        // Determine chain based on chainId\n        const chain = (0,_chainConfig__WEBPACK_IMPORTED_MODULE_5__.getChainById)(chainId);\n        const rpcUrl = (0,_chainConfig__WEBPACK_IMPORTED_MODULE_5__.getChainRpcUrl)(chainId);\n        const publicClient = (0,viem__WEBPACK_IMPORTED_MODULE_15__.createPublicClient)({\n            chain: chain,\n            transport: (0,viem__WEBPACK_IMPORTED_MODULE_16__.http)(rpcUrl),\n        });\n        const accountProvider = new _agentic_trust_8004_sdk__WEBPACK_IMPORTED_MODULE_2__.ViemAccountProvider({\n            publicClient: publicClient,\n            walletClient: null,\n            chainConfig: {\n                id: chainId,\n                rpcUrl: rpcUrl,\n                name: chain.name,\n                chain: chain,\n            },\n        });\n        const aiIdentityClient = new _agentic_trust_8004_ext_sdk__WEBPACK_IMPORTED_MODULE_0__.AIAgentIdentityClient({\n            accountProvider,\n            identityRegistryAddress: identityRegistryHex,\n        });\n        const additionalMetadata = [\n            ...(params.agentCategory ? [{ key: 'agentCategory', value: params.agentCategory }] : []),\n            { key: 'registeredBy', value: 'agentic-trust' },\n            { key: 'registryNamespace', value: 'erc-8004' },\n            ...(uaid ? [{ key: 'uaid', value: uaid }] : []),\n        ];\n        const { calls: registerCalls } = await aiIdentityClient.prepareRegisterCalls(params.agentName, params.agentAccount, tokenUri, additionalMetadata);\n        const bundlerUrl = (0,_chainConfig__WEBPACK_IMPORTED_MODULE_5__.getChainBundlerUrl)(params.chainId || _chainConfig__WEBPACK_IMPORTED_MODULE_5__.DEFAULT_CHAIN_ID);\n        return {\n            success: true,\n            bundlerUrl,\n            tokenUri,\n            chainId,\n            calls: registerCalls,\n        };\n    }\n    /**\n     * Create a new agent for AA and execute via server admin private key (no client prompts).\n     * Same input interface as createAgentWithSmartAccountOwnerUsingWallet, but performs the UserOperation using the server key.\n     */\n    async createAgentWithSmartAccountOwnerUsingPrivateKey(params) {\n        const chainId = params.chainId || _chainConfig__WEBPACK_IMPORTED_MODULE_5__.DEFAULT_CHAIN_ID;\n        const adminApp = await (0,_userApps_adminApp__WEBPACK_IMPORTED_MODULE_10__.getAdminApp)(undefined, chainId);\n        if (!adminApp) {\n            throw new Error('AdminApp not initialized. Ensure AGENTIC_TRUST_APP_ROLES includes \"admin\" and provide AGENTIC_TRUST_ADMIN_PRIVATE_KEY');\n        }\n        // First reuse existing preparation to get register calls\n        const prepared = await this.createAgentWithSmartAccountOwnerUsingWallet({\n            ...params,\n            chainId,\n        });\n        // Build AA account client using admin signer\n        const chain = (0,_chainConfig__WEBPACK_IMPORTED_MODULE_5__.getChainById)(chainId);\n        // Deterministic salt based on agentName (matches client computation)\n        const { keccak256, stringToHex } = await Promise.all(/*! import() */[__webpack_require__.e(\"vendor-chunks/viem\"), __webpack_require__.e(\"vendor-chunks/abitype\")]).then(__webpack_require__.bind(__webpack_require__, /*! viem */ \"(rsc)/../../node_modules/viem/_esm/index.js\"));\n        const deploySalt = keccak256(stringToHex(params.agentName));\n        const accountClient = await (0,_metamask_smart_accounts_kit__WEBPACK_IMPORTED_MODULE_17__.toMetaMaskSmartAccount)({\n            client: adminApp.publicClient,\n            implementation: _metamask_smart_accounts_kit__WEBPACK_IMPORTED_MODULE_18__.Implementation.Hybrid,\n            signer: adminApp.walletClient\n                ? { walletClient: adminApp.walletClient }\n                : (adminApp.account ? { account: adminApp.account } : {}),\n            deployParams: [adminApp.address, [], [], []],\n            deploySalt,\n        });\n        // Send UserOperation via bundler\n        const bundlerUrl = prepared.bundlerUrl;\n        const bundlerClient = (0,viem_account_abstraction__WEBPACK_IMPORTED_MODULE_19__.createBundlerClient)({\n            transport: (0,viem__WEBPACK_IMPORTED_MODULE_16__.http)(bundlerUrl),\n            paymaster: true,\n            chain: chain,\n            paymasterContext: { mode: 'SPONSORED' },\n        });\n        // permissionless gas price (optional)\n        let fee = {};\n        try {\n            const { createPimlicoClient } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! permissionless/clients/pimlico */ \"(rsc)/../../node_modules/permissionless/_esm/clients/pimlico.js\"));\n            const pimlico = createPimlicoClient({ transport: (0,viem__WEBPACK_IMPORTED_MODULE_16__.http)(bundlerUrl) });\n            const gas = await pimlico.getUserOperationGasPrice();\n            fee = gas.fast || {};\n        }\n        catch {\n            // optional\n        }\n        const userOperationHash = await bundlerClient.sendUserOperation({\n            account: accountClient,\n            calls: prepared.calls,\n            ...fee,\n        });\n        const receipt = await bundlerClient.waitForUserOperationReceipt({ hash: userOperationHash });\n        // Try to extract agentId (best-effort)\n        let agentId;\n        try {\n            const id = await this.extractAgentIdFromReceipt(receipt, chainId);\n            if (id)\n                agentId = id;\n        }\n        catch { }\n        // If we have an agentId, update tokenUri on-chain so registrations[].agentId is populated.\n        if (agentId) {\n            try {\n                const didEthr = (0,_shared_didEthr__WEBPACK_IMPORTED_MODULE_9__.buildDidEthr)(chainId, params.agentAccount, { encode: false });\n                const uid = didEthr;\n                const nativeId = `eip155:${chainId}:${params.agentAccount}`;\n                const domain = typeof params.agentUrl === 'string' && params.agentUrl.trim()\n                    ? (() => {\n                        try {\n                            return new URL(params.agentUrl).hostname;\n                        }\n                        catch {\n                            return undefined;\n                        }\n                    })()\n                    : undefined;\n                const { uaid } = await (0,_uaid__WEBPACK_IMPORTED_MODULE_8__.generateHcs14UaidDidTarget)({\n                    targetDid: didEthr,\n                    routing: {\n                        registry: 'erc-8004',\n                        proto: 'a2a',\n                        nativeId,\n                        uid,\n                        domain,\n                    },\n                });\n                const identityRegistry = (0,_chainConfig__WEBPACK_IMPORTED_MODULE_5__.requireChainEnvVar)('AGENTIC_TRUST_IDENTITY_REGISTRY', chainId);\n                const identityRegistryHex = identityRegistry.startsWith('0x') ? identityRegistry : `0x${identityRegistry}`;\n                const updatedRegistrationJSON = (0,_agentRegistration__WEBPACK_IMPORTED_MODULE_7__.createRegistrationJSON)({\n                    name: params.agentName,\n                    agentAccount: params.agentAccount,\n                    agentId,\n                    description: params.description,\n                    image: params.image,\n                    agentUrl: params.agentUrl,\n                    chainId,\n                    identityRegistry: identityRegistryHex,\n                    supportedTrust: params.supportedTrust,\n                    endpoints: params.endpoints,\n                    uaid,\n                });\n                const updatedUpload = await (0,_agentRegistration__WEBPACK_IMPORTED_MODULE_7__.uploadRegistration)(updatedRegistrationJSON);\n                const preparedUpdate = await this.admin.prepareUpdateAgent({\n                    agentId,\n                    tokenUri: updatedUpload.tokenUri,\n                    chainId,\n                });\n                const nextNonce = await getAccountNonce(accountClient);\n                await sendUserOpWithTimeout({\n                    bundlerUrl,\n                    chain,\n                    accountClient,\n                    calls: preparedUpdate.calls,\n                    nonce: nextNonce,\n                });\n            }\n            catch (uaidError) {\n                console.warn('[createAgentWithSmartAccountOwnerUsingPrivateKey] Failed to finalize tokenUri update with agentId:', uaidError);\n            }\n        }\n        if (params.ensOptions?.enabled && params.ensOptions.orgName) {\n            try {\n                const ensClient = await (0,_singletons_ensClient__WEBPACK_IMPORTED_MODULE_13__.getENSClient)(chainId);\n                if ((0,_chainConfig__WEBPACK_IMPORTED_MODULE_5__.isL1)(chainId)) {\n                    await (0,_names__WEBPACK_IMPORTED_MODULE_12__.addToL1OrgPK)({\n                        orgName: params.ensOptions.orgName,\n                        agentName: params.agentName,\n                        agentAddress: params.agentAccount,\n                        agentUrl: params.agentUrl,\n                        chainId,\n                    });\n                    const { calls: infoCalls } = await ensClient.prepareSetAgentNameInfoCalls({\n                        orgName: params.ensOptions.orgName,\n                        agentName: params.agentName,\n                        agentAddress: params.agentAccount,\n                        agentUrl: params.agentUrl,\n                        agentDescription: params.description,\n                    });\n                    let nextNonce = await getAccountNonce(accountClient);\n                    if (infoCalls.length > 0) {\n                        const formattedCalls = infoCalls.map((call) => ({\n                            to: call.to,\n                            data: call.data,\n                            value: call.value ?? 0n,\n                        }));\n                        console.info('[createAgentWithSmartAccountOwnerUsingPrivateKey] Submitting L1 ENS metadata calls');\n                        await sendUserOpWithTimeout({\n                            bundlerUrl,\n                            chain,\n                            accountClient,\n                            calls: formattedCalls,\n                            nonce: nextNonce,\n                        });\n                        if (typeof nextNonce === 'bigint') {\n                            nextNonce += 1n;\n                        }\n                    }\n                }\n                else {\n                    console.info('[createAgentWithSmartAccountOwnerUsingPrivateKey] Running L2 ENS setup via agent account');\n                    const { calls: addCalls } = await ensClient.prepareAddAgentNameToOrgCalls({\n                        orgName: params.ensOptions.orgName,\n                        agentName: params.agentName,\n                        agentAddress: params.agentAccount,\n                        agentUrl: params.agentUrl || '',\n                    });\n                    let nextNonce = await getAccountNonce(accountClient);\n                    if (addCalls.length > 0) {\n                        const formattedAddCalls = addCalls.map((call) => ({\n                            to: call.to,\n                            data: call.data,\n                            value: 'value' in call && typeof call.value === 'bigint' ? call.value : 0n,\n                        }));\n                        console.info('[createAgentWithSmartAccountOwnerUsingPrivateKey] Submitting L2 ENS subdomain registration');\n                        await sendUserOpWithTimeout({\n                            bundlerUrl,\n                            chain,\n                            accountClient,\n                            calls: formattedAddCalls,\n                            nonce: nextNonce,\n                        });\n                        if (typeof nextNonce === 'bigint') {\n                            nextNonce += 1n;\n                        }\n                    }\n                    const { calls: infoCalls } = await ensClient.prepareAddAgentInfoCalls({\n                        orgName: params.ensOptions.orgName,\n                        agentName: params.agentName,\n                        agentAddress: params.agentAccount,\n                        agentUrl: params.agentUrl || '',\n                        agentDescription: params.description,\n                    });\n                    if (infoCalls.length > 0) {\n                        const formattedInfoCalls = infoCalls.map((call) => ({\n                            to: call.to,\n                            data: call.data,\n                            value: call.value ?? 0n,\n                        }));\n                        console.info('[createAgentWithSmartAccountOwnerUsingPrivateKey] Submitting L2 ENS metadata calls');\n                        await sendUserOpWithTimeout({\n                            bundlerUrl,\n                            chain,\n                            accountClient,\n                            calls: formattedInfoCalls,\n                            nonce: nextNonce,\n                        });\n                        if (typeof nextNonce === 'bigint') {\n                            nextNonce += 1n;\n                        }\n                    }\n                }\n            }\n            catch (ensError) {\n                console.warn('[createAgentWithSmartAccountOwnerUsingPrivateKey] ENS setup failed:', ensError);\n            }\n        }\n        return { txHash: userOperationHash, agentId };\n    }\n    async extractAgentIdFromReceipt(receipt, chainId = 11155111) {\n        if (!receipt) {\n            return null;\n        }\n        const identityRegistry = (0,_chainConfig__WEBPACK_IMPORTED_MODULE_5__.requireChainEnvVar)('AGENTIC_TRUST_IDENTITY_REGISTRY', chainId);\n        const identityRegistryHex = identityRegistry.startsWith('0x')\n            ? identityRegistry\n            : `0x${identityRegistry}`;\n        const chain = (0,_chainConfig__WEBPACK_IMPORTED_MODULE_5__.getChainById)(chainId);\n        const aiIdentityClient = new _agentic_trust_8004_ext_sdk__WEBPACK_IMPORTED_MODULE_0__.AIAgentIdentityClient({\n            accountProvider: {\n                chainId: async () => chain.id,\n            },\n            identityRegistryAddress: identityRegistryHex,\n        });\n        try {\n            const agentId = aiIdentityClient.extractAgentIdFromReceiptPublic(receipt);\n            return agentId ? agentId.toString() : null;\n        }\n        catch (error) {\n            console.warn('extractAgentIdFromReceipt failed:', error);\n            return null;\n        }\n    }\n    async searchAgents(options) {\n        if (typeof options === 'string') {\n            return this.searchAgents({ query: options });\n        }\n        const discoveryClient = await (0,_singletons_discoveryClient__WEBPACK_IMPORTED_MODULE_4__.getDiscoveryClient)();\n        const advancedDiscoveryClient = discoveryClient;\n        const requestedPage = typeof options?.page === 'number' && Number.isFinite(options.page) ? options.page : 1;\n        const rawPageSize = typeof options?.pageSize === 'number' && options.pageSize > 0\n            ? options.pageSize\n            : undefined;\n        const hasQuery = typeof options?.query === 'string' && options.query.trim().length > 0;\n        const where = this.buildAgentWhereInput(options?.params);\n        // Always ensure we have a pageSize when performing discovery so that\n        // advanced search is used consistently (even when no filters are provided).\n        const effectivePageSize = rawPageSize ?? 50;\n        const hasAdvancedGraph = typeof advancedDiscoveryClient.searchAgentsGraph === 'function';\n        const hasAdvancedLegacy = typeof advancedDiscoveryClient.searchAgentsAdvanced === 'function';\n        // Prefer the advanced discovery APIs (Graph/advanced) whenever available so\n        // that we get an accurate total count and consistent pagination, even when\n        // no filters are supplied.\n        //\n        // IMPORTANT:\n        // - The Graph-based API (`searchAgentsGraph`) currently only supports structured\n        //   filters via `where` and does NOT take the free-text `query` string.\n        // - The legacy advanced API (`searchAgentsAdvanced`) is the one that wires the\n        //   general search query into the discovery backend (and can also take params).\n        //\n        // To ensure the general search box actually filters results, we route:\n        //   - requests WITH a query string through `searchAgentsAdvanced` when available\n        //   - requests WITHOUT a query string (filters / pagination only) through\n        //     `searchAgentsGraph` when available\n        if (effectivePageSize && (hasAdvancedGraph || hasAdvancedLegacy)) {\n            const offset = (Math.max(requestedPage, 1) - 1) * effectivePageSize;\n            try {\n                // If we have a text query and the legacy advanced API is available,\n                // use it so the query string is honored by the discovery service.\n                if (hasQuery && hasAdvancedLegacy) {\n                    const advanced = await advancedDiscoveryClient.searchAgentsAdvanced({\n                        query: options?.query,\n                        params: options?.params,\n                        limit: effectivePageSize,\n                        offset,\n                        orderBy: options?.orderBy,\n                        orderDirection: options?.orderDirection,\n                    });\n                    if (advanced && Array.isArray(advanced.agents)) {\n                        const total = typeof advanced.total === 'number' && advanced.total >= 0\n                            ? advanced.total\n                            : advanced.agents.length + offset;\n                        const totalPages = Math.max(1, Math.ceil(total / effectivePageSize));\n                        const safePage = Math.min(Math.max(requestedPage, 1), totalPages);\n                        const agentInstances = advanced.agents.map((data) => new _agent__WEBPACK_IMPORTED_MODULE_3__.Agent(data, this.client));\n                        return {\n                            agents: agentInstances,\n                            total,\n                            page: safePage,\n                            pageSize: effectivePageSize,\n                            totalPages,\n                        };\n                    }\n                }\n                else if (hasAdvancedGraph) {\n                    const advanced = await advancedDiscoveryClient.searchAgentsGraph({\n                        where,\n                        first: effectivePageSize,\n                        skip: offset,\n                        orderBy: options?.orderBy,\n                        orderDirection: options?.orderDirection,\n                    });\n                    if (advanced && Array.isArray(advanced.agents)) {\n                        const total = typeof advanced.total === 'number' && advanced.total >= 0\n                            ? advanced.total\n                            : advanced.agents.length + offset;\n                        const totalPages = Math.max(1, Math.ceil(total / effectivePageSize));\n                        const safePage = Math.min(Math.max(requestedPage, 1), totalPages);\n                        const agentInstances = advanced.agents.map((data) => new _agent__WEBPACK_IMPORTED_MODULE_3__.Agent(data, this.client));\n                        return {\n                            agents: agentInstances,\n                            total,\n                            page: safePage,\n                            pageSize: effectivePageSize,\n                            totalPages,\n                        };\n                    }\n                }\n                else if (hasAdvancedLegacy) {\n                    // Fallback: no Graph API, but legacy advanced is available (with or\n                    // without a query string).\n                    const advanced = await advancedDiscoveryClient.searchAgentsAdvanced({\n                        query: options?.query,\n                        params: options?.params,\n                        limit: effectivePageSize,\n                        offset,\n                        orderBy: options?.orderBy,\n                        orderDirection: options?.orderDirection,\n                    });\n                    if (advanced && Array.isArray(advanced.agents)) {\n                        const total = typeof advanced.total === 'number' && advanced.total >= 0\n                            ? advanced.total\n                            : advanced.agents.length + offset;\n                        const totalPages = Math.max(1, Math.ceil(total / effectivePageSize));\n                        const safePage = Math.min(Math.max(requestedPage, 1), totalPages);\n                        const agentInstances = advanced.agents.map((data) => new _agent__WEBPACK_IMPORTED_MODULE_3__.Agent(data, this.client));\n                        return {\n                            agents: agentInstances,\n                            total,\n                            page: safePage,\n                            pageSize: effectivePageSize,\n                            totalPages,\n                        };\n                    }\n                }\n            }\n            catch (error) {\n                console.warn('[AgentsAPI.searchAgents] Advanced search failed, returning empty results.', error);\n            }\n            // If advanced search fails or returns null, fall back to the default\n            // pagination logic below which uses listAgents.\n        }\n        // If no filters, use listAgents to get default list from GraphQL endpoint.\n        // Default to 50 agents if no pageSize specified.\n        const defaultPageSize = effectivePageSize ?? 50;\n        const offset = (Math.max(requestedPage, 1) - 1) * defaultPageSize;\n        try {\n            const allAgents = await discoveryClient.listAgents(defaultPageSize, offset);\n            // For listAgents, we don't know the total, so we estimate based on returned results\n            // If we got a full page, there might be more; if less, we're at the end\n            const hasMore = allAgents.length === defaultPageSize;\n            const estimatedTotal = hasMore ? allAgents.length + offset + 1 : allAgents.length + offset;\n            const totalPages = Math.max(1, Math.ceil(estimatedTotal / defaultPageSize));\n            const agentInstances = allAgents.map((data) => new _agent__WEBPACK_IMPORTED_MODULE_3__.Agent(data, this.client));\n            return {\n                agents: agentInstances,\n                total: estimatedTotal,\n                page: requestedPage,\n                pageSize: defaultPageSize,\n                totalPages,\n            };\n        }\n        catch (error) {\n            console.warn('[AgentsAPI.searchAgents] listAgents failed, returning empty results.', error);\n            return {\n                agents: [],\n                total: 0,\n                page: requestedPage ?? 1,\n                pageSize: defaultPageSize,\n                totalPages: 0,\n            };\n        }\n    }\n    /**\n     * Map high-level DiscoverParams to the indexer's AgentWhereInput shape.\n     * This is used for the searchAgentsGraph(where: AgentWhereInput, ...) API.\n     */\n    buildAgentWhereInput(params) {\n        if (!params)\n            return undefined;\n        const where = {};\n        if (params.chains && params.chains !== 'all' && params.chains.length > 0) {\n            where.chainId_in = params.chains;\n        }\n        if (params.agentName?.trim()) {\n            where.agentName_contains_nocase = params.agentName.trim();\n        }\n        if (params.agentCategory?.trim()) {\n            // Best-effort; indexer schemas generally support *_contains_nocase for string fields.\n            where.agentCategory_contains_nocase = params.agentCategory.trim();\n        }\n        if (params.agentId?.trim()) {\n            // Exact match on agentId; you could also expose agentId_in if you later\n            // support multiple IDs.\n            where.agentId = params.agentId.trim();\n        }\n        if (params.description?.trim()) {\n            where.description_contains_nocase = params.description.trim();\n        }\n        if (params.accounts && params.accounts.length > 0) {\n            // New discovery schema: owned-by-EOA filter is `eoaAgentIdentityOwnerAccount`.\n            where.eoaAgentIdentityOwnerAccount_in = params.accounts.map((addr) => addr.toLowerCase());\n        }\n        if (params.operators && params.operators.length > 0) {\n            where.operator_in = params.operators.map((addr) => addr.toLowerCase());\n        }\n        if (typeof params.mcp === 'boolean') {\n            where.mcp = params.mcp;\n        }\n        if (typeof params.a2a === 'boolean') {\n            if (params.a2a) {\n                where.hasA2aEndpoint = true;\n            }\n        }\n        if (params.did?.trim()) {\n            where.did_contains_nocase = params.did.trim();\n        }\n        if (params.agentAccount) {\n            // New discovery schema: filter by agent account EOA via `eoaAgentAccount`.\n            where.eoaAgentAccount = params.agentAccount.toLowerCase();\n        }\n        if (params.supportedTrust && params.supportedTrust.length > 0) {\n            where.supportedTrust_in = params.supportedTrust;\n        }\n        if (params.a2aSkills && params.a2aSkills.length > 0) {\n            where.a2aSkills_in = params.a2aSkills;\n        }\n        if (params.mcpTools && params.mcpTools.length > 0) {\n            where.mcpTools_in = params.mcpTools;\n        }\n        if (params.mcpPrompts && params.mcpPrompts.length > 0) {\n            where.mcpPrompts_in = params.mcpPrompts;\n        }\n        if (params.mcpResources && params.mcpResources.length > 0) {\n            where.mcpResources_in = params.mcpResources;\n        }\n        if (typeof params.active === 'boolean') {\n            where.active = params.active;\n        }\n        if (typeof params.x402support === 'boolean') {\n            where.x402support = params.x402support;\n        }\n        if (typeof params.minFeedbackCount === 'number' && params.minFeedbackCount > 0) {\n            where.feedbackCount_gte = params.minFeedbackCount;\n        }\n        if (typeof params.minValidationCompletedCount === 'number' &&\n            params.minValidationCompletedCount > 0) {\n            where.validationCompletedCount_gte = params.minValidationCompletedCount;\n        }\n        if (typeof params.minFeedbackAverageScore === 'number' &&\n            params.minFeedbackAverageScore > 0) {\n            where.feedbackAverageScore_gte = params.minFeedbackAverageScore;\n        }\n        if (typeof params.minAtiOverallScore === 'number' && params.minAtiOverallScore > 0) {\n            where.atiOverallScore_gte = params.minAtiOverallScore;\n        }\n        if (typeof params.atiComputedWithinDays === 'number' && params.atiComputedWithinDays > 0) {\n            const nowSeconds = Math.floor(Date.now() / 1000);\n            const windowSeconds = Math.floor(params.atiComputedWithinDays * 24 * 60 * 60);\n            const threshold = nowSeconds - windowSeconds;\n            if (threshold > 0) {\n                where.atiComputedAt_gte = threshold;\n            }\n        }\n        if (typeof params.createdWithinDays === 'number' && params.createdWithinDays > 0) {\n            const nowSeconds = Math.floor(Date.now() / 1000);\n            const windowSeconds = Math.floor(params.createdWithinDays * 24 * 60 * 60);\n            const threshold = nowSeconds - windowSeconds;\n            if (threshold > 0) {\n                where.createdAtTime_gte = threshold;\n            }\n        }\n        return Object.keys(where).length > 0 ? where : undefined;\n    }\n    applySearchAndPagination(agentData, options) {\n        const normalizedQuery = options?.query && typeof options.query === 'string'\n            ? options.query.trim().toLowerCase()\n            : '';\n        const params = options?.params;\n        const sortedAgents = (() => {\n            const orderBy = options?.orderBy?.trim();\n            const orderDirection = (options?.orderDirection ?? 'ASC').toUpperCase() === 'DESC' ? 'DESC' : 'ASC';\n            const list = [...agentData];\n            if (orderBy === 'agentName') {\n                list.sort((a, b) => {\n                    const aName = (a.agentName ?? '').toLowerCase();\n                    const bName = (b.agentName ?? '').toLowerCase();\n                    return orderDirection === 'ASC' ? aName.localeCompare(bName) : bName.localeCompare(aName);\n                });\n                return list;\n            }\n            // Default: newest first by agentId desc (back-compat)\n            list.sort((a, b) => {\n                const idA = typeof a.agentId === 'number' ? a.agentId : Number(a.agentId) || 0;\n                const idB = typeof b.agentId === 'number' ? b.agentId : Number(b.agentId) || 0;\n                return idB - idA;\n            });\n            return list;\n        })();\n        const filteredAgents = sortedAgents.filter((data) => {\n            if (normalizedQuery) {\n                const haystack = [\n                    typeof data.agentId === 'number' ? data.agentId.toString() : data.agentId,\n                    data.agentName,\n                    data.agentAccount,\n                    data.agentIdentityOwnerAccount,\n                    data.eoaAgentIdentityOwnerAccount,\n                    data.eoaAgentAccount,\n                    data.description,\n                    data.type,\n                    data.a2aEndpoint,\n                    data.agentUri,\n                    data.supportedTrust,\n                    data.rawJson,\n                ]\n                    .filter(Boolean)\n                    .join(' ')\n                    .toLowerCase();\n                if (!haystack.includes(normalizedQuery)) {\n                    return false;\n                }\n            }\n            if (!params) {\n                return true;\n            }\n            return this.matchesSearchParams(data, params);\n        });\n        const total = filteredAgents.length;\n        const pageSize = typeof options?.pageSize === 'number' && options.pageSize > 0\n            ? options.pageSize\n            : total || 1;\n        const totalPages = Math.max(1, Math.ceil(total / pageSize));\n        const requestedPage = typeof options?.page === 'number' && Number.isFinite(options.page) ? options.page : 1;\n        const safePage = Math.min(Math.max(requestedPage, 1), totalPages);\n        const startIndex = (safePage - 1) * pageSize;\n        const endIndex = startIndex + pageSize;\n        const pageAgents = filteredAgents.slice(startIndex, endIndex);\n        const agentInstances = pageAgents.map((data) => new _agent__WEBPACK_IMPORTED_MODULE_3__.Agent(data, this.client));\n        return {\n            agents: agentInstances,\n            total,\n            page: safePage,\n            pageSize,\n            totalPages,\n        };\n    }\n    matchesSearchParams(agent, params) {\n        const parsedRaw = typeof agent.rawJson === 'string'\n            ? safeParseJson(agent.rawJson)\n            : agent.rawJson && typeof agent.rawJson === 'object'\n                ? agent.rawJson\n                : undefined;\n        const metadata = parsedRaw && typeof parsedRaw === 'object'\n            ? parsedRaw\n            : undefined;\n        if (params.chains && params.chains !== 'all') {\n            const chainId = typeof agent.chainId === 'number' ? agent.chainId : undefined;\n            if (!chainId || !params.chains.includes(chainId)) {\n                return false;\n            }\n        }\n        if (params.agentName) {\n            const name = agent.agentName ?? '';\n            if (!name.toLowerCase().includes(params.agentName.trim().toLowerCase())) {\n                return false;\n            }\n        }\n        if (params.agentCategory) {\n            const cat = agent.agentCategory ?? '';\n            const catStr = typeof cat === 'string' ? cat : String(cat ?? '');\n            if (!catStr.toLowerCase().includes(params.agentCategory.trim().toLowerCase())) {\n                return false;\n            }\n        }\n        if (params.description) {\n            const description = agent.description ?? '';\n            if (!description.toLowerCase().includes(params.description.trim().toLowerCase())) {\n                return false;\n            }\n        }\n        if (params.accounts && params.accounts.length > 0) {\n            const owner = agent.eoaAgentIdentityOwnerAccount?.toLowerCase?.();\n            if (!owner ||\n                !params.accounts.some((addr) => addr.toLowerCase() === owner)) {\n                return false;\n            }\n        }\n        if (params.agentAccount) {\n            const wallet = agent.eoaAgentAccount?.toLowerCase?.();\n            if (!wallet || wallet !== params.agentAccount.toLowerCase()) {\n                return false;\n            }\n        }\n        if (params.did) {\n            const rawDid = (metadata && typeof metadata.did === 'string' && metadata.did) ||\n                (metadata?.identity && typeof metadata.identity?.did === 'string'\n                    ? metadata.identity.did\n                    : undefined);\n            if (!rawDid || rawDid.toLowerCase() !== params.did.trim().toLowerCase()) {\n                return false;\n            }\n        }\n        if (params.supportedTrust && params.supportedTrust.length > 0) {\n            const supportedTrust = normalizeToStringArray(agent.supportedTrust, metadata?.supportedTrust);\n            if (!includesEveryCaseInsensitive(supportedTrust, params.supportedTrust)) {\n                return false;\n            }\n        }\n        if (params.a2aSkills && params.a2aSkills.length > 0) {\n            const skills = normalizeToStringArray(metadata?.a2aSkills, metadata?.a2a?.skills, metadata?.skills);\n            if (!includesEveryCaseInsensitive(skills, params.a2aSkills)) {\n                return false;\n            }\n        }\n        if (params.mcpTools && params.mcpTools.length > 0) {\n            const tools = normalizeToStringArray(metadata?.mcpTools, metadata?.mcp?.tools);\n            if (!includesEveryCaseInsensitive(tools, params.mcpTools)) {\n                return false;\n            }\n        }\n        if (params.mcpPrompts && params.mcpPrompts.length > 0) {\n            const prompts = normalizeToStringArray(metadata?.mcpPrompts, metadata?.mcp?.prompts);\n            if (!includesEveryCaseInsensitive(prompts, params.mcpPrompts)) {\n                return false;\n            }\n        }\n        if (params.mcpResources && params.mcpResources.length > 0) {\n            const resources = normalizeToStringArray(metadata?.mcpResources, metadata?.mcp?.resources);\n            if (!includesEveryCaseInsensitive(resources, params.mcpResources)) {\n                return false;\n            }\n        }\n        if (params.mcp !== undefined) {\n            const hasMcp = metadata?.mcp === true ||\n                metadata?.mcp?.enabled === true ||\n                (Array.isArray(metadata?.mcp?.tools) && metadata.mcp.tools.length > 0);\n            if (params.mcp !== hasMcp) {\n                return false;\n            }\n        }\n        if (params.a2a !== undefined) {\n            const hasA2a = typeof agent.a2aEndpoint === 'string' && agent.a2aEndpoint.length > 0;\n            if (params.a2a !== hasA2a) {\n                return false;\n            }\n        }\n        if (params.operators && params.operators.length > 0) {\n            const operators = normalizeToStringArray(metadata?.operators, metadata?.agentOperators, metadata?.operatorAddresses).map((value) => value.toLowerCase());\n            if (operators.length === 0 ||\n                !params.operators.some((addr) => operators.includes(addr.toLowerCase()))) {\n                return false;\n            }\n        }\n        if (params.active !== undefined) {\n            const active = typeof metadata?.active === 'boolean'\n                ? metadata.active\n                : typeof metadata?.status === 'string'\n                    ? metadata.status.toLowerCase() === 'active'\n                    : undefined;\n            if (active !== undefined && params.active !== active) {\n                return false;\n            }\n        }\n        if (params.x402support !== undefined) {\n            const support = metadata?.x402support === true ||\n                metadata?.x402Support === true ||\n                (Array.isArray(metadata?.protocols) &&\n                    metadata.protocols.map((p) => p.toLowerCase()).includes('x402'));\n            if (params.x402support !== support) {\n                return false;\n            }\n        }\n        if (typeof params.minAtiOverallScore === 'number' && params.minAtiOverallScore > 0) {\n            const scoreRaw = agent.atiOverallScore;\n            const score = typeof scoreRaw === 'number' ? scoreRaw : Number(scoreRaw);\n            if (!Number.isFinite(score) || score < params.minAtiOverallScore) {\n                return false;\n            }\n        }\n        if (typeof params.atiComputedWithinDays === 'number' && params.atiComputedWithinDays > 0) {\n            const computedRaw = agent.atiComputedAt;\n            const computedAt = typeof computedRaw === 'number' ? computedRaw : Number(computedRaw);\n            if (!Number.isFinite(computedAt) || computedAt <= 0) {\n                return false;\n            }\n            const nowSeconds = Math.floor(Date.now() / 1000);\n            const windowSeconds = Math.floor(params.atiComputedWithinDays * 24 * 60 * 60);\n            const threshold = nowSeconds - windowSeconds;\n            if (computedAt < threshold) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Admin API for agent management\n     * These methods require AdminApp to be initialized\n     * Note: createAgent is now available directly on agents (not agents.admin)\n     */\n    admin = {\n        /**\n         * Prepare low-level contract calls to update an agent's token URI and/or\n         * on-chain metadata. These calls can be executed client-side via a bundler\n             * or wallet, similar to createAgentWithSmartAccountOwnerUsingWallet.\n         */\n        prepareUpdateAgent: async (params) => {\n            const chainId = params.chainId || _chainConfig__WEBPACK_IMPORTED_MODULE_5__.DEFAULT_CHAIN_ID;\n            const identityRegistry = (0,_chainConfig__WEBPACK_IMPORTED_MODULE_5__.requireChainEnvVar)('AGENTIC_TRUST_IDENTITY_REGISTRY', chainId);\n            const identityRegistryHex = identityRegistry.startsWith('0x')\n                ? identityRegistry\n                : `0x${identityRegistry}`;\n            const agentId = BigInt(params.agentId);\n            const calls = [];\n            // Token URI update call\n            if (params.tokenUri !== undefined) {\n                const data = (0,viem__WEBPACK_IMPORTED_MODULE_20__.encodeFunctionData)({\n                    abi: identityRegistryAbi,\n                    // Updated ABI name is setAgentURI (capital URI)\n                    functionName: 'setAgentURI',\n                    args: [agentId, params.tokenUri],\n                });\n                calls.push({\n                    to: identityRegistryHex,\n                    data: data,\n                    value: 0n,\n                });\n            }\n            // Metadata update calls\n            if (params.metadata && params.metadata.length > 0) {\n                const encoder = new TextEncoder();\n                for (const entry of params.metadata) {\n                    const valueBytes = encoder.encode(entry.value);\n                    const data = (0,viem__WEBPACK_IMPORTED_MODULE_20__.encodeFunctionData)({\n                        abi: identityRegistryAbi,\n                        functionName: 'setMetadata',\n                        args: [agentId, entry.key, valueBytes],\n                    });\n                    calls.push({\n                        to: identityRegistryHex,\n                        data: data,\n                        value: 0n,\n                    });\n                }\n            }\n            if (calls.length === 0) {\n                throw new Error('No updates provided. Specify tokenUri and/or metadata.');\n            }\n            const bundlerUrl = (0,_chainConfig__WEBPACK_IMPORTED_MODULE_5__.getChainBundlerUrl)(chainId);\n            return {\n                chainId,\n                identityRegistry: identityRegistryHex,\n                bundlerUrl,\n                calls,\n            };\n        },\n        /**\n         * Prepare a create agent transaction for client-side signing\n         * Returns transaction data that can be signed and submitted by the client\n         */\n        prepareCreateAgentTransaction: async (params) => {\n            const chainId = params.chainId || _chainConfig__WEBPACK_IMPORTED_MODULE_5__.DEFAULT_CHAIN_ID;\n            const adminApp = await (0,_userApps_adminApp__WEBPACK_IMPORTED_MODULE_10__.getAdminApp)(undefined, chainId);\n            if (!adminApp) {\n                throw new Error('AdminApp not initialized. Ensure AGENTIC_TRUST_APP_ROLES includes \"admin\" and connect via wallet');\n            }\n            if (adminApp.hasPrivateKey) {\n                throw new Error('prepareCreateAgentTransaction should only be used when no private key is available');\n            }\n            const identityRegistry = (0,_chainConfig__WEBPACK_IMPORTED_MODULE_5__.requireChainEnvVar)('AGENTIC_TRUST_IDENTITY_REGISTRY', chainId);\n            const identityRegistryHex = identityRegistry.startsWith('0x')\n                ? identityRegistry\n                : `0x${identityRegistry}`;\n            // Create read-only IdentityClient using AdminApp's AccountProvider\n            const identityClient = new _agentic_trust_8004_sdk__WEBPACK_IMPORTED_MODULE_2__.BaseIdentityClient(adminApp.accountProvider, identityRegistryHex);\n            // Build metadata array\n            const metadata = [\n                { key: 'agentName', value: params.agentName ? String(params.agentName) : '' },\n                { key: 'agentAccount', value: params.agentAccount ? String(params.agentAccount) : '' },\n                ...(params.agentCategory ? [{ key: 'agentCategory', value: String(params.agentCategory) }] : []),\n                { key: 'registeredBy', value: 'agentic-trust' },\n                { key: 'registryNamespace', value: 'erc-8004' },\n            ].filter(m => m.value !== '');\n            // Create registration JSON and upload to IPFS\n            let tokenUri = '';\n            try {\n                const registrationJSON = (0,_agentRegistration__WEBPACK_IMPORTED_MODULE_7__.createRegistrationJSON)({\n                    name: params.agentName,\n                    agentAccount: params.agentAccount,\n                    description: params.description,\n                    image: params.image,\n                    agentUrl: params.agentUrl,\n                    chainId,\n                    identityRegistry: identityRegistryHex,\n                    supportedTrust: params.supportedTrust,\n                    endpoints: params.endpoints\n                });\n                const uploadResult = await (0,_agentRegistration__WEBPACK_IMPORTED_MODULE_7__.uploadRegistration)(registrationJSON);\n                tokenUri = uploadResult.tokenUri;\n            }\n            catch (error) {\n                console.error('Failed to upload registration JSON to IPFS:', error);\n                throw new Error(`Failed to create registration JSON: ${error instanceof Error ? error.message : 'Unknown error'}`);\n            }\n            // Get chain-specific RPC URL\n            const rpcUrl = (0,_chainConfig__WEBPACK_IMPORTED_MODULE_5__.getChainRpcUrl)(chainId);\n            // Encode the transaction data\n            const aiIdentityClient = new _agentic_trust_8004_ext_sdk__WEBPACK_IMPORTED_MODULE_0__.AIAgentIdentityClient({\n                chainId,\n                rpcUrl,\n                identityRegistryAddress: identityRegistryHex,\n            });\n            // Encode registerWithMetadata function call\n            const encodedData = await aiIdentityClient.encodeRegisterWithMetadata(tokenUri, metadata);\n            // Simulate transaction to get gas estimates\n            let gasEstimate;\n            let gasPrice;\n            let maxFeePerGas;\n            let maxPriorityFeePerGas;\n            let nonce;\n            try {\n                // Get current gas prices\n                const [gasPriceData, blockData] = await Promise.all([\n                    adminApp.publicClient.getGasPrice(),\n                    adminApp.publicClient.getBlock({ blockTag: 'latest' }),\n                ]);\n                gasPrice = gasPriceData;\n                // Try EIP-1559 gas prices if available\n                if (blockData && 'baseFeePerGas' in blockData && blockData.baseFeePerGas) {\n                    maxFeePerGas = (blockData.baseFeePerGas * 2n) / 10n; // 2x base fee\n                    maxPriorityFeePerGas = blockData.baseFeePerGas / 10n; // 10% of base fee\n                }\n                // Estimate gas\n                gasEstimate = await adminApp.publicClient.estimateGas({\n                    account: adminApp.address,\n                    to: identityRegistryHex,\n                    data: encodedData,\n                });\n                // Get nonce\n                nonce = await adminApp.publicClient.getTransactionCount({\n                    address: adminApp.address,\n                    blockTag: 'pending',\n                });\n            }\n            catch (error) {\n                console.warn('Could not estimate gas or get transaction parameters:', error);\n                // Continue without gas estimates - client can estimate\n            }\n            return {\n                requiresClientSigning: true,\n                transaction: {\n                    to: identityRegistryHex,\n                    data: encodedData,\n                    value: '0',\n                    gas: gasEstimate ? gasEstimate.toString() : undefined,\n                    gasPrice: gasPrice ? gasPrice.toString() : undefined,\n                    maxFeePerGas: maxFeePerGas ? maxFeePerGas.toString() : undefined,\n                    maxPriorityFeePerGas: maxPriorityFeePerGas ? maxPriorityFeePerGas.toString() : undefined,\n                    nonce,\n                    chainId,\n                },\n                tokenUri,\n                metadata: metadata.map(m => ({ key: m.key, value: m.value })),\n            };\n        },\n        /**\n         * Update an agent's token URI\n         * @param agentId - The agent ID to update\n         * @param tokenUri - New token URI\n         * @returns Transaction hash\n         */\n        /**\n         * Server-side helper that actually sends the prepared update calls using\n         * AdminApp's AccountProvider. For browser/bundler flows, prefer\n         * prepareUpdateAgent instead.\n         */\n        updateAgent: async (params) => {\n            const chainId = params.chainId || _chainConfig__WEBPACK_IMPORTED_MODULE_5__.DEFAULT_CHAIN_ID;\n            const adminApp = await (0,_userApps_adminApp__WEBPACK_IMPORTED_MODULE_10__.getAdminApp)(undefined, chainId);\n            if (!adminApp) {\n                throw new Error('AdminApp not initialized. Ensure AGENTIC_TRUST_APP_ROLES includes \"admin\" and AGENTIC_TRUST_ADMIN_PRIVATE_KEY is set');\n            }\n            const prepared = await this.admin.prepareUpdateAgent({\n                agentId: params.agentId,\n                tokenUri: params.tokenUri,\n                metadata: params.metadata,\n                chainId,\n            });\n            const results = [];\n            for (const call of prepared.calls) {\n                const tx = await adminApp.accountProvider.send({\n                    to: call.to,\n                    data: call.data,\n                    value: call.value ?? 0n,\n                });\n                results.push({ txHash: tx.hash });\n            }\n            if (results.length === 0) {\n                throw new Error('No updates provided. Specify tokenUri and/or metadata.');\n            }\n            const lastResult = results[results.length - 1];\n            if (!lastResult) {\n                throw new Error('Failed to get transaction hash from update operation');\n            }\n            return { txHash: lastResult.txHash };\n        },\n        updateAgentByDid: async (agentDid, params = {}) => {\n            const { agentId, chainId } = (0,_agentic_trust_8004_ext_sdk__WEBPACK_IMPORTED_MODULE_0__.parseDid8004)(agentDid);\n            return this.admin.updateAgent({\n                agentId,\n                chainId: params.chainId ?? chainId,\n                tokenUri: params.tokenUri,\n                metadata: params.metadata,\n            });\n        },\n        /**\n         * Delete an agent by transferring it to the zero address (burn)\n         * Note: This requires the contract to support transfers to address(0)\n         * @param agentId - The agent ID to delete\n         * @returns Transaction hash\n         */\n        deleteAgent: async (params) => {\n            const chainId = params.chainId || _chainConfig__WEBPACK_IMPORTED_MODULE_5__.DEFAULT_CHAIN_ID;\n            const adminApp = await (0,_userApps_adminApp__WEBPACK_IMPORTED_MODULE_10__.getAdminApp)(undefined, chainId);\n            if (!adminApp) {\n                throw new Error('AdminApp not initialized. Ensure AGENTIC_TRUST_APP_ROLES includes \"admin\" and AGENTIC_TRUST_ADMIN_PRIVATE_KEY is set');\n            }\n            const identityRegistry = (0,_chainConfig__WEBPACK_IMPORTED_MODULE_5__.requireChainEnvVar)('AGENTIC_TRUST_IDENTITY_REGISTRY', chainId);\n            // Import IdentityRegistry ABI for transferFrom\n            const IdentityRegistryABI = identityRegistryAbi;\n            const agentId = BigInt(params.agentId);\n            const from = adminApp.address;\n            const to = '0x0000000000000000000000000000000000000000';\n            // Transfer to zero address (burn)\n            const data = await adminApp.accountProvider.encodeFunctionData({\n                abi: IdentityRegistryABI,\n                functionName: 'transferFrom',\n                args: [from, to, agentId],\n            });\n            const result = await adminApp.accountProvider.send({\n                to: identityRegistry,\n                data,\n                value: 0n,\n            });\n            return { txHash: result.hash };\n        },\n        deleteAgentByDid: async (agentDid, options = {}) => {\n            const { agentId, chainId } = (0,_agentic_trust_8004_ext_sdk__WEBPACK_IMPORTED_MODULE_0__.parseDid8004)(agentDid);\n            return this.admin.deleteAgent({\n                agentId,\n                chainId: options.chainId ?? chainId,\n            });\n        },\n        /**\n         * Transfer an agent to a new owner\n         * @param agentId - The agent ID to transfer\n         * @param to - The new owner address\n         * @returns Transaction hash\n         */\n        transferAgent: async (params) => {\n            const chainId = params.chainId || _chainConfig__WEBPACK_IMPORTED_MODULE_5__.DEFAULT_CHAIN_ID;\n            const adminApp = await (0,_userApps_adminApp__WEBPACK_IMPORTED_MODULE_10__.getAdminApp)(undefined, chainId);\n            if (!adminApp) {\n                throw new Error('AdminApp not initialized. Ensure AGENTIC_TRUST_APP_ROLES includes \"admin\" and AGENTIC_TRUST_ADMIN_PRIVATE_KEY is set');\n            }\n            const identityRegistry = (0,_chainConfig__WEBPACK_IMPORTED_MODULE_5__.requireChainEnvVar)('AGENTIC_TRUST_IDENTITY_REGISTRY', chainId);\n            // Import IdentityRegistry ABI for transferFrom\n            const IdentityRegistryABI = identityRegistryAbi;\n            const agentId = BigInt(params.agentId);\n            const from = adminApp.address;\n            // Transfer to new owner\n            const data = await adminApp.accountProvider.encodeFunctionData({\n                abi: IdentityRegistryABI,\n                functionName: 'transferFrom',\n                args: [from, params.to, agentId],\n            });\n            const result = await adminApp.accountProvider.send({\n                to: identityRegistry,\n                data,\n                value: 0n,\n            });\n            return { txHash: result.hash };\n        },\n        transferAgentByDid: async (fromDid, toDid) => {\n            const { agentId, chainId } = (0,_agentic_trust_8004_ext_sdk__WEBPACK_IMPORTED_MODULE_0__.parseDid8004)(fromDid);\n            // For now we support toDid as did:ethr:... and derive the destination\n            // account from it. Other DID methods can be added later as needed.\n            if (!toDid.startsWith('did:ethr:')) {\n                throw new Error(`Unsupported toDid format for transferAgentByDid: ${toDid}. Expected did:ethr:...`);\n            }\n            const { account } = (0,_accounts__WEBPACK_IMPORTED_MODULE_6__.parseEthrDid)(toDid);\n            return this.admin.transferAgent({\n                agentId,\n                chainId,\n                to: account,\n            });\n        },\n    };\n}\n//# sourceMappingURL=agents.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BhZ2VudGljLXRydXN0L2NvcmUvZGlzdC9zZXJ2ZXIvbGliL2FnZW50cy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG9DQUFvQztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixpRkFBMEI7QUFDckQsOEJBQThCLGtGQUEyQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsaUJBQWlCO0FBQ2pCLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ3FFO0FBQ2M7QUFDbkQ7QUFDbUM7QUFDMkQ7QUFDcEY7QUFDdUM7QUFDN0I7QUFDQTtBQUNnQjtBQUNqQjtBQUMwQztBQUNQO0FBQ3ZCO0FBQ3hCO0FBQzhEO0FBQzlDO0FBQ0c7QUFDMUQsNEJBQTRCLG9GQUF1QixZQUFZLG9GQUF1QjtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLCtFQUFrQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx3RUFBcUI7QUFDakM7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG1CQUFtQixFQUFFLHlFQUFZO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQywrRUFBa0I7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHdFQUFxQjtBQUNqQztBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsbUJBQW1CLEVBQUUseUVBQVk7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDRCQUE0QixRQUFRLGlOQUFzQztBQUM5RiwrQ0FBK0MsMERBQWdCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RSxHQUFHO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELDBEQUFnQjtBQUNoRSwrQkFBK0IsZ0VBQVc7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGdFQUFrQjtBQUNuRDtBQUNBO0FBQ0EsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsNkRBQVksaUNBQWlDLGVBQWU7QUFDeEY7QUFDQSx1Q0FBdUMsUUFBUSxHQUFHLG9CQUFvQjtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsMEJBQTBCLGlFQUEwQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQywwRUFBc0I7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsdUNBQXVDLHNFQUFrQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSx5REFBeUQ7QUFDNUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDJFQUEyRTtBQUM3RixrQkFBa0Isb0ZBQW9GO0FBQ3RHLDhDQUE4QywyREFBMkQ7QUFDekcsa0JBQWtCLDZDQUE2QztBQUMvRCxrQkFBa0IsNkNBQTZDO0FBQy9ELDhCQUE4QiwwQkFBMEI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDBEQUFZO0FBQ3RDLDJCQUEyQiw0REFBYztBQUN6QyxpQ0FBaUMseURBQWtCO0FBQ25EO0FBQ0EsMkJBQTJCLDJDQUFJO0FBQy9CLGFBQWE7QUFDYix3Q0FBd0Msd0VBQW1CO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYix5Q0FBeUMsOEVBQXFCO0FBQzlEO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyw0QkFBNEI7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsMkJBQTJCO0FBQ2hHO0FBQ0EsMENBQTBDLGtCQUFrQjtBQUM1RDtBQUNBLDJDQUEyQyxvQkFBb0IsT0FBTyxxQ0FBcUM7QUFDM0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyx1RUFBa0I7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDJFQUEyRTtBQUN6RixjQUFjLG9GQUFvRjtBQUNsRywwQ0FBMEMsMkRBQTJEO0FBQ3JHLGNBQWMsNkNBQTZDO0FBQzNELGNBQWMsNkNBQTZDO0FBQzNELDBCQUEwQiwwQkFBMEI7QUFDcEQsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsMEVBQXNCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2Isd0NBQXdDLHNFQUFrQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQywrRUFBa0I7QUFDNUQ7QUFDQSw2Q0FBNkMsZ0JBQWdCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxnQkFBZ0I7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCwwREFBZ0I7QUFDaEUsK0JBQStCLGdFQUFXO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxnRUFBa0I7QUFDbkQsZ0dBQWdHLGlCQUFpQjtBQUNqSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qiw2REFBWSx1Q0FBdUMsZUFBZTtBQUM5RjtBQUNBLHVDQUF1QyxjQUFjLEdBQUcsb0JBQW9CO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSwwQkFBMEIsaUVBQTBCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLDBFQUFzQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYix1Q0FBdUMsc0VBQWtCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLHlEQUF5RDtBQUM1SDtBQUNBO0FBQ0EsbUNBQW1DLHVFQUFrQjtBQUNyRDtBQUNBO0FBQ0EsY0FBYywyRUFBMkU7QUFDekYsY0FBYyxvRkFBb0Y7QUFDbEcsMENBQTBDLDJEQUEyRDtBQUNyRyxjQUFjLDZDQUE2QztBQUMzRCxjQUFjLDZDQUE2QztBQUMzRCwwQkFBMEIsMEJBQTBCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QywwRUFBc0I7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYix3Q0FBd0Msc0VBQWtCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLCtFQUFrQjtBQUM1RDtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsZ0JBQWdCO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLDBEQUFnQjtBQUMxRCwrQkFBK0IsZ0VBQVc7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGdFQUFrQjtBQUNuRDtBQUNBO0FBQ0EsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsNkRBQVksaUNBQWlDLGVBQWU7QUFDeEY7QUFDQSx1Q0FBdUMsUUFBUSxHQUFHLG9CQUFvQjtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsaUNBQWlDLGlFQUEwQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLDBFQUFzQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYix1Q0FBdUMsc0VBQWtCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLHlEQUF5RDtBQUM1SDtBQUNBO0FBQ0Esc0JBQXNCLDBEQUFZO0FBQ2xDLHVCQUF1Qiw0REFBYztBQUNyQyw2QkFBNkIseURBQWtCO0FBQy9DO0FBQ0EsdUJBQXVCLDJDQUFJO0FBQzNCLFNBQVM7QUFDVCxvQ0FBb0Msd0VBQW1CO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVCxxQ0FBcUMsOEVBQXFCO0FBQzFEO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSwwQ0FBMEMsbURBQW1EO0FBQzdGLGNBQWMsNkNBQTZDO0FBQzNELGNBQWMsNkNBQTZDO0FBQzNELDBCQUEwQiwwQkFBMEI7QUFDcEQ7QUFDQSxnQkFBZ0IsdUJBQXVCO0FBQ3ZDLDJCQUEyQixnRUFBa0IsbUJBQW1CLDBEQUFnQjtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQywwREFBZ0I7QUFDMUQsK0JBQStCLGdFQUFXO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esc0JBQXNCLDBEQUFZO0FBQ2xDO0FBQ0EsZ0JBQWdCLHlCQUF5QixRQUFRLHdPQUFjO0FBQy9EO0FBQ0Esb0NBQW9DLHFGQUFzQjtBQUMxRDtBQUNBLDRCQUE0Qix5RUFBYztBQUMxQztBQUNBLG9CQUFvQjtBQUNwQix3Q0FBd0MsNEJBQTRCLElBQUk7QUFDeEU7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsOEJBQThCLDhFQUFtQjtBQUNqRCx1QkFBdUIsMkNBQUk7QUFDM0I7QUFDQTtBQUNBLGdDQUFnQyxtQkFBbUI7QUFDbkQsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0IsUUFBUSw2TEFBd0M7QUFDMUYsa0RBQWtELFdBQVcsMkNBQUksY0FBYztBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCwwRUFBMEUseUJBQXlCO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsNkRBQVksaUNBQWlDLGVBQWU7QUFDNUY7QUFDQSwyQ0FBMkMsUUFBUSxHQUFHLG9CQUFvQjtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0Esd0JBQXdCLE9BQU8sUUFBUSxpRUFBMEI7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCLHlDQUF5QyxnRUFBa0I7QUFDM0Qsd0dBQXdHLGlCQUFpQjtBQUN6SCxnREFBZ0QsMEVBQXNCO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsNENBQTRDLHNFQUFrQjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxvRUFBWTtBQUNwRCxvQkFBb0Isa0RBQUk7QUFDeEIsMEJBQTBCLHFEQUFZO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsNEJBQTRCLG1CQUFtQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixrQkFBa0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLG1CQUFtQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxnRUFBa0I7QUFDbkQ7QUFDQTtBQUNBLG1CQUFtQixpQkFBaUI7QUFDcEMsc0JBQXNCLDBEQUFZO0FBQ2xDLHFDQUFxQyw4RUFBcUI7QUFDMUQ7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGdCQUFnQjtBQUN2RDtBQUNBLHNDQUFzQywrRUFBa0I7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlGQUFpRix5Q0FBSztBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRkFBaUYseUNBQUs7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUZBQWlGLHlDQUFLO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0EsK0RBQStELHlDQUFLO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCx5Q0FBSztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsMERBQWdCO0FBQzlELHFDQUFxQyxnRUFBa0I7QUFDdkQ7QUFDQTtBQUNBLHVCQUF1QixpQkFBaUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIseURBQWtCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyx5REFBa0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsZ0VBQWtCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLDBEQUFnQjtBQUM5RCxtQ0FBbUMsZ0VBQVc7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLGdFQUFrQjtBQUN2RDtBQUNBO0FBQ0EsdUJBQXVCLGlCQUFpQjtBQUN4QztBQUNBLHVDQUF1Qyx1RUFBa0I7QUFDekQ7QUFDQTtBQUNBLGtCQUFrQiwyRUFBMkU7QUFDN0Ysa0JBQWtCLG9GQUFvRjtBQUN0Ryw4Q0FBOEMsMkRBQTJEO0FBQ3pHLGtCQUFrQiw2Q0FBNkM7QUFDL0Qsa0JBQWtCLDZDQUE2QztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QywwRUFBc0I7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLDJDQUEyQyxzRUFBa0I7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUUseURBQXlEO0FBQ2hJO0FBQ0E7QUFDQSwyQkFBMkIsNERBQWM7QUFDekM7QUFDQSx5Q0FBeUMsOEVBQXFCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsb0JBQW9CO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFO0FBQ3pFLDBFQUEwRTtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLCtDQUErQyw0QkFBNEI7QUFDM0U7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLDBEQUFnQjtBQUM5RCxtQ0FBbUMsZ0VBQVc7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsK0JBQStCLGlCQUFpQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLFNBQVM7QUFDVCxzREFBc0Q7QUFDdEQsb0JBQW9CLG1CQUFtQixFQUFFLHlFQUFZO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLDBEQUFnQjtBQUM5RCxtQ0FBbUMsZ0VBQVc7QUFDOUM7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLGdFQUFrQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixxQkFBcUI7QUFDckIsU0FBUztBQUNULHVEQUF1RDtBQUN2RCxvQkFBb0IsbUJBQW1CLEVBQUUseUVBQVk7QUFDckQ7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QywwREFBZ0I7QUFDOUQsbUNBQW1DLGdFQUFXO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxnRUFBa0I7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLHFCQUFxQjtBQUNyQixTQUFTO0FBQ1Q7QUFDQSxvQkFBb0IsbUJBQW1CLEVBQUUseUVBQVk7QUFDckQ7QUFDQTtBQUNBO0FBQ0Esb0ZBQW9GLE1BQU07QUFDMUY7QUFDQSxvQkFBb0IsVUFBVSxFQUFFLHVEQUFZO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL2JhcmIvYWEvQXNzb2NpYXRlZEFjY291bnRzL25vZGVfbW9kdWxlcy9AYWdlbnRpYy10cnVzdC9jb3JlL2Rpc3Qvc2VydmVyL2xpYi9hZ2VudHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcGFyc2VEaWQ4MDA0IH0gZnJvbSAnQGFnZW50aWMtdHJ1c3QvODAwNC1leHQtc2RrJztcbmFzeW5jIGZ1bmN0aW9uIGdldEFjY291bnROb25jZShhY2NvdW50Q2xpZW50KSB7XG4gICAgaWYgKHR5cGVvZiBhY2NvdW50Q2xpZW50Py5nZXROb25jZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBhd2FpdCBhY2NvdW50Q2xpZW50LmdldE5vbmNlKCk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnYmlnaW50Jykge1xuICAgICAgICAgICAgICAgIGFjY291bnRDbGllbnQubm9uY2UgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggeyB9XG4gICAgfVxuICAgIGlmICh0eXBlb2YgYWNjb3VudENsaWVudD8ubm9uY2UgPT09ICdiaWdpbnQnKSB7XG4gICAgICAgIHJldHVybiBhY2NvdW50Q2xpZW50Lm5vbmNlO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuYXN5bmMgZnVuY3Rpb24gc2VuZFVzZXJPcFdpdGhUaW1lb3V0KHBhcmFtcykge1xuICAgIGNvbnN0IHsgdGltZW91dE1zID0gMjAwMDAsIG5vbmNlLCAuLi5yZXN0IH0gPSBwYXJhbXM7XG4gICAgaWYgKHR5cGVvZiBub25jZSA9PT0gJ2JpZ2ludCcpIHtcbiAgICAgICAgcmVzdC5hY2NvdW50Q2xpZW50Lm5vbmNlID0gbm9uY2U7XG4gICAgfVxuICAgIGNvbnN0IHNlbmRQcm9taXNlID0gKGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3QgaGFzaCA9IGF3YWl0IHNlbmRTcG9uc29yZWRVc2VyT3BlcmF0aW9uKHJlc3QpO1xuICAgICAgICBjb25zdCByZWNlaXB0ID0gYXdhaXQgd2FpdEZvclVzZXJPcGVyYXRpb25SZWNlaXB0KHtcbiAgICAgICAgICAgIGJ1bmRsZXJVcmw6IHJlc3QuYnVuZGxlclVybCxcbiAgICAgICAgICAgIGNoYWluOiByZXN0LmNoYWluLFxuICAgICAgICAgICAgaGFzaCxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7IGhhc2gsIHJlY2VpcHQgfTtcbiAgICB9KSgpO1xuICAgIHJldHVybiBhd2FpdCBQcm9taXNlLnJhY2UoW1xuICAgICAgICBzZW5kUHJvbWlzZSxcbiAgICAgICAgbmV3IFByb21pc2UoKF8sIHJlamVjdCkgPT4gc2V0VGltZW91dCgoKSA9PiByZWplY3QobmV3IEVycm9yKCdUaW1lb3V0IHdhaXRpbmcgZm9yIFVzZXJPcGVyYXRpb24nKSksIHRpbWVvdXRNcykpLFxuICAgIF0pO1xufVxuaW1wb3J0IHsgQUlBZ2VudElkZW50aXR5Q2xpZW50LCB9IGZyb20gJ0BhZ2VudGljLXRydXN0LzgwMDQtZXh0LXNkayc7XG5pbXBvcnQgeyBWaWVtQWNjb3VudFByb3ZpZGVyLCBCYXNlSWRlbnRpdHlDbGllbnQsIH0gZnJvbSAnQGFnZW50aWMtdHJ1c3QvODAwNC1zZGsnO1xuaW1wb3J0IHsgQWdlbnQgfSBmcm9tICcuL2FnZW50JztcbmltcG9ydCB7IGdldERpc2NvdmVyeUNsaWVudCB9IGZyb20gJy4uL3NpbmdsZXRvbnMvZGlzY292ZXJ5Q2xpZW50JztcbmltcG9ydCB7IHJlcXVpcmVDaGFpbkVudlZhciwgZ2V0Q2hhaW5CeUlkLCBnZXRDaGFpblJwY1VybCwgZ2V0Q2hhaW5CdW5kbGVyVXJsLCBERUZBVUxUX0NIQUlOX0lELCBpc0wxLCB9IGZyb20gJy4vY2hhaW5Db25maWcnO1xuaW1wb3J0IHsgcGFyc2VFdGhyRGlkIH0gZnJvbSAnLi9hY2NvdW50cyc7XG5pbXBvcnQgeyB1cGxvYWRSZWdpc3RyYXRpb24sIGNyZWF0ZVJlZ2lzdHJhdGlvbkpTT04gfSBmcm9tICcuL2FnZW50UmVnaXN0cmF0aW9uJztcbmltcG9ydCB7IGdlbmVyYXRlSGNzMTRVYWlkRGlkVGFyZ2V0IH0gZnJvbSAnLi91YWlkJztcbmltcG9ydCB7IGJ1aWxkRGlkRXRociB9IGZyb20gJy4uLy4uL3NoYXJlZC9kaWRFdGhyJztcbmltcG9ydCB7IGNyZWF0ZVB1YmxpY0NsaWVudCwgZW5jb2RlRnVuY3Rpb25EYXRhLCBodHRwIH0gZnJvbSAndmllbSc7XG5pbXBvcnQgeyBnZXRBZG1pbkFwcCB9IGZyb20gJy4uL3VzZXJBcHBzL2FkbWluQXBwJztcbmltcG9ydCBJZGVudGl0eVJlZ2lzdHJ5QUJJSnNvbiBmcm9tICdAYWdlbnRpYy10cnVzdC84MDA0LWV4dC1zZGsvYWJpcy9JZGVudGl0eVJlZ2lzdHJ5Lmpzb24nO1xuaW1wb3J0IHsgSW1wbGVtZW50YXRpb24sIHRvTWV0YU1hc2tTbWFydEFjY291bnQgfSBmcm9tICdAbWV0YW1hc2svc21hcnQtYWNjb3VudHMta2l0JztcbmltcG9ydCB7IGNyZWF0ZUJ1bmRsZXJDbGllbnQgfSBmcm9tICd2aWVtL2FjY291bnQtYWJzdHJhY3Rpb24nO1xuaW1wb3J0IHsgYWRkVG9MMU9yZ1BLIH0gZnJvbSAnLi9uYW1lcyc7XG5pbXBvcnQgeyBzZW5kU3BvbnNvcmVkVXNlck9wZXJhdGlvbiwgd2FpdEZvclVzZXJPcGVyYXRpb25SZWNlaXB0IH0gZnJvbSAnLi4vLi4vY2xpZW50L2FjY291bnRDbGllbnQnO1xuaW1wb3J0IHsgZ2V0RU5TQ2xpZW50IH0gZnJvbSAnLi4vc2luZ2xldG9ucy9lbnNDbGllbnQnO1xuaW1wb3J0IHsgcmV0aHJvd0Rpc2NvdmVyeUVycm9yIH0gZnJvbSAnLi9kaXNjb3ZlcnlFcnJvcnMnO1xuY29uc3QgaWRlbnRpdHlSZWdpc3RyeUFiaSA9IElkZW50aXR5UmVnaXN0cnlBQklKc29uLmRlZmF1bHQgPz8gSWRlbnRpdHlSZWdpc3RyeUFCSUpzb247XG5mdW5jdGlvbiBzYWZlUGFyc2VKc29uKHZhbHVlKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UodmFsdWUpO1xuICAgIH1cbiAgICBjYXRjaCB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxufVxuZnVuY3Rpb24gbm9ybWFsaXplVG9TdHJpbmdBcnJheSguLi52YWx1ZXMpIHtcbiAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIHZhbHVlcykge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS5tYXAoKGl0ZW0pID0+IFN0cmluZyhpdGVtKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBbdmFsdWVdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBbXTtcbn1cbmZ1bmN0aW9uIGluY2x1ZGVzRXZlcnlDYXNlSW5zZW5zaXRpdmUoc291cmNlLCBleHBlY3RlZCkge1xuICAgIGlmICghZXhwZWN0ZWQubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoIXNvdXJjZS5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBzb3VyY2VMb3dlciA9IHNvdXJjZS5tYXAoKHZhbHVlKSA9PiB2YWx1ZS50b0xvd2VyQ2FzZSgpKTtcbiAgICByZXR1cm4gZXhwZWN0ZWQuZXZlcnkoKHZhbHVlKSA9PiBzb3VyY2VMb3dlci5pbmNsdWRlcyh2YWx1ZS50b0xvd2VyQ2FzZSgpKSk7XG59XG5leHBvcnQgY2xhc3MgQWdlbnRzQVBJIHtcbiAgICBjbGllbnQ7XG4gICAgY29uc3RydWN0b3IoY2xpZW50KSB7XG4gICAgICAgIHRoaXMuY2xpZW50ID0gY2xpZW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMaXN0IGFsbCBhZ2VudHNcbiAgICAgKiBRdWVyeSB1c2VzIHRoZSBhY3R1YWwgc2NoZW1hIGZpZWxkcyBmcm9tIHRoZSBBUElcbiAgICAgKiBSZXR1cm5zIGFnZW50cyBzb3J0ZWQgYnkgYWdlbnRJZCBpbiBkZXNjZW5kaW5nIG9yZGVyXG4gICAgICogRmV0Y2hlcyBhbGwgYWdlbnRzIHVzaW5nIHBhZ2luYXRpb24gaWYgbmVlZGVkXG4gICAgICovXG4gICAgYXN5bmMgbGlzdEFnZW50cyhvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlYXJjaEFnZW50cyhvcHRpb25zID8/IHt9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGEgc2luZ2xlIGFnZW50IGJ5IElEXG4gICAgICogQHBhcmFtIGFnZW50SWQgLSBUaGUgYWdlbnQgSUQgYXMgYSBzdHJpbmdcbiAgICAgKiBAcGFyYW0gY2hhaW5JZCAtIE9wdGlvbmFsIGNoYWluIElEIChkZWZhdWx0cyB0byAxMTE1NTExMSBmb3IgU2Vwb2xpYSlcbiAgICAgKi9cbiAgICBhc3luYyBnZXRBZ2VudChhZ2VudElkLCBjaGFpbklkID0gMTExNTUxMTEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LmdldEFnZW50KGFnZW50SWQsIGNoYWluSWQpO1xuICAgIH1cbiAgICBhc3luYyBnZXRBZ2VudEJ5RGlkKGRpZDgwMDQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LmdldEFnZW50QnlEaWQoZGlkODAwNCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhIGZ1bGx5LWh5ZHJhdGVkIEFnZW50RGV0YWlsIGZvciBhIGdpdmVuIGFnZW50SWQgYW5kIGNoYWluSWQuXG4gICAgICogVGhpcyBtZXRob2QgaXMga2VwdCBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgYnV0IHNpbXBseSBkZWxlZ2F0ZXNcbiAgICAgKiB0byB0aGUgdG9wLWxldmVsIEFnZW50aWNUcnVzdENsaWVudC5nZXRBZ2VudERldGFpbHMgaGVscGVyLlxuICAgICAqL1xuICAgIGFzeW5jIGdldEFnZW50RGV0YWlscyhhZ2VudElkLCBjaGFpbklkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5nZXRBZ2VudERldGFpbHMoYWdlbnRJZCwgY2hhaW5JZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCByYXcgYWdlbnQgZGF0YSBmcm9tIGRpc2NvdmVyeSAoZm9yIGludGVybmFsIHVzZSlcbiAgICAgKiBSZXR1cm5zIHRoZSByYXcgQWdlbnREYXRhIGZyb20gdGhlIGRpc2NvdmVyeSBpbmRleGVyXG4gICAgICovXG4gICAgYXN5bmMgZ2V0QWdlbnRGcm9tRGlzY292ZXJ5KGNoYWluSWQsIGFnZW50SWQpIHtcbiAgICAgICAgY29uc3QgZGlzY292ZXJ5Q2xpZW50ID0gYXdhaXQgZ2V0RGlzY292ZXJ5Q2xpZW50KCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgZGlzY292ZXJ5Q2xpZW50LmdldEFnZW50KGNoYWluSWQsIGFnZW50SWQpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBpcyBhbiBhY2Nlc3MgY29kZS9hdXRoIGVycm9yIGFuZCBwcm92aWRlIGEgY2xlYXJlciBtZXNzYWdlXG4gICAgICAgICAgICByZXRocm93RGlzY292ZXJ5RXJyb3IoZXJyb3IsICdhZ2VudHMuZ2V0QWdlbnRGcm9tRGlzY292ZXJ5Jyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZ2V0QWdlbnRGcm9tRGlzY292ZXJ5QnlEaWQoZGlkODAwNCkge1xuICAgICAgICBjb25zdCB7IGFnZW50SWQsIGNoYWluSWQgfSA9IHBhcnNlRGlkODAwNChkaWQ4MDA0KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QWdlbnRGcm9tRGlzY292ZXJ5KGNoYWluSWQsIGFnZW50SWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWZyZXNoL0luZGV4IGFuIGFnZW50IGluIHRoZSBHcmFwaFFMIGluZGV4ZXJcbiAgICAgKiBUcmlnZ2VycyB0aGUgaW5kZXhlciB0byByZS1pbmRleCB0aGUgc3BlY2lmaWVkIGFnZW50XG4gICAgICogQHBhcmFtIGFnZW50SWQgLSBBZ2VudCBJRCB0byByZWZyZXNoIChyZXF1aXJlZClcbiAgICAgKiBAcGFyYW0gY2hhaW5JZCAtIE9wdGlvbmFsIGNoYWluIElEIChkZWZhdWx0cyB0byAxMTE1NTExMSBmb3IgU2Vwb2xpYSlcbiAgICAgKi9cbiAgICBhc3luYyByZWZyZXNoQWdlbnQoYWdlbnRJZCwgY2hhaW5JZCA9IDExMTU1MTExKSB7XG4gICAgICAgIGNvbnN0IGRpc2NvdmVyeUNsaWVudCA9IGF3YWl0IGdldERpc2NvdmVyeUNsaWVudCgpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IGRpc2NvdmVyeUNsaWVudC5yZWZyZXNoQWdlbnQoYWdlbnRJZCwgY2hhaW5JZCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXRocm93RGlzY292ZXJ5RXJyb3IoZXJyb3IsICdhZ2VudHMucmVmcmVzaEFnZW50Jyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgcmVmcmVzaEFnZW50QnlEaWQoYWdlbnREaWQpIHtcbiAgICAgICAgY29uc3QgeyBhZ2VudElkLCBjaGFpbklkIH0gPSBwYXJzZURpZDgwMDQoYWdlbnREaWQpO1xuICAgICAgICByZXR1cm4gdGhpcy5yZWZyZXNoQWdlbnQoYWdlbnRJZCwgY2hhaW5JZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgYXBwcm92ZWQgTkZUIG9wZXJhdG9yIGFkZHJlc3MgZm9yIGFuIGFnZW50XG4gICAgICogUmV0dXJucyB0aGUgYWRkcmVzcyBhcHByb3ZlZCB0byBvcGVyYXRlIG9uIHRoZSBhZ2VudCdzIE5GVCB0b2tlbiwgb3IgbnVsbCBpZiBubyBvcGVyYXRvciBpcyBzZXRcbiAgICAgKlxuICAgICAqIEBwYXJhbSBhZ2VudElkIC0gVGhlIGFnZW50IElEIChzdHJpbmcgb3IgbnVtYmVyKVxuICAgICAqIEBwYXJhbSBjaGFpbklkIC0gT3B0aW9uYWwgY2hhaW4gSUQgKGRlZmF1bHRzIHRvIDExMTU1MTExIGZvciBTZXBvbGlhKVxuICAgICAqIEByZXR1cm5zIFRoZSBhcHByb3ZlZCBvcGVyYXRvciBhZGRyZXNzLCBvciBudWxsIGlmIG5vIG9wZXJhdG9yIGlzIHNldFxuICAgICAqL1xuICAgIGFzeW5jIGdldE5GVE9wZXJhdG9yKGFnZW50SWQsIGNoYWluSWQgPSAxMTE1NTExMSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgeyBnZXRJZGVudGl0eVJlZ2lzdHJ5Q2xpZW50IH0gPSBhd2FpdCBpbXBvcnQoJy4uL3NpbmdsZXRvbnMvaWRlbnRpdHlDbGllbnQnKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc29sdmVkQ2hhaW5JZCA9IGNoYWluSWQgfHwgREVGQVVMVF9DSEFJTl9JRDtcbiAgICAgICAgICAgIGNvbnN0IGFnZW50SWRCaWdJbnQgPSBCaWdJbnQoYWdlbnRJZCk7XG4gICAgICAgICAgICBjb25zdCBpZGVudGl0eUNsaWVudCA9IGF3YWl0IGdldElkZW50aXR5UmVnaXN0cnlDbGllbnQocmVzb2x2ZWRDaGFpbklkKTtcbiAgICAgICAgICAgIGNvbnN0IG9wZXJhdG9yQWRkcmVzcyA9IGF3YWl0IGlkZW50aXR5Q2xpZW50LmdldE5GVE9wZXJhdG9yKGFnZW50SWRCaWdJbnQpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcGVyYXRvckFkZHJlc3MgPT09ICdzdHJpbmcnICYmIC9eMHhbYS1mQS1GMC05XXs0MH0kLy50ZXN0KG9wZXJhdG9yQWRkcmVzcykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3BlcmF0b3JBZGRyZXNzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ1tBZ2VudHNBUEkuZ2V0TkZUT3BlcmF0b3JdIEZhaWxlZCB0byBnZXQgTkZUIG9wZXJhdG9yOicsIGVycm9yKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBhZ2VudFxuICAgICAqIFJlcXVpcmVzIEFkbWluQXBwIHRvIGJlIGluaXRpYWxpemVkIChzZXJ2ZXItc2lkZSlcbiAgICAgKiBAcGFyYW0gcGFyYW1zIC0gQWdlbnQgY3JlYXRpb24gcGFyYW1ldGVyc1xuICAgICAqIEByZXR1cm5zIENyZWF0ZWQgYWdlbnQgSUQgYW5kIHRyYW5zYWN0aW9uIGhhc2gsIG9yIHByZXBhcmVkIHRyYW5zYWN0aW9uIGZvciBjbGllbnQtc2lkZSBzaWduaW5nXG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlQWdlbnRXaXRoRU9BT3duZXJVc2luZ1dhbGxldChwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0Q2hhaW5JZCA9IHBhcmFtcy5jaGFpbklkIHx8IERFRkFVTFRfQ0hBSU5fSUQ7XG4gICAgICAgIGNvbnN0IGFkbWluQXBwID0gYXdhaXQgZ2V0QWRtaW5BcHAodW5kZWZpbmVkLCB0YXJnZXRDaGFpbklkKTtcbiAgICAgICAgaWYgKCFhZG1pbkFwcCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBZG1pbkFwcCBub3QgaW5pdGlhbGl6ZWQuIEVuc3VyZSBBR0VOVElDX1RSVVNUX0FQUF9ST0xFUyBpbmNsdWRlcyBcImFkbWluXCIgYW5kIHByb3ZpZGUgZWl0aGVyIEFHRU5USUNfVFJVU1RfQURNSU5fUFJJVkFURV9LRVkgb3IgY29ubmVjdCB2aWEgd2FsbGV0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaWRlbnRpdHlSZWdpc3RyeSA9IHJlcXVpcmVDaGFpbkVudlZhcignQUdFTlRJQ19UUlVTVF9JREVOVElUWV9SRUdJU1RSWScsIHRhcmdldENoYWluSWQpO1xuICAgICAgICBjb25zdCBpZGVudGl0eVJlZ2lzdHJ5SGV4ID0gaWRlbnRpdHlSZWdpc3RyeS5zdGFydHNXaXRoKCcweCcpXG4gICAgICAgICAgICA/IGlkZW50aXR5UmVnaXN0cnlcbiAgICAgICAgICAgIDogYDB4JHtpZGVudGl0eVJlZ2lzdHJ5fWA7XG4gICAgICAgIC8vIENyZWF0ZSByZWdpc3RyYXRpb24gSlNPTiBhbmQgdXBsb2FkIHRvIElQRlNcbiAgICAgICAgbGV0IHRva2VuVXJpID0gJyc7XG4gICAgICAgIGNvbnN0IGNoYWluSWQgPSB0YXJnZXRDaGFpbklkO1xuICAgICAgICBjb25zb2xlLmxvZygnW2FnZW50cy5jcmVhdGVBZ2VudFdpdGhFT0FPd25lclVzaW5nV2FsbGV0XSBVc2luZyBjaGFpbklkJywgY2hhaW5JZCk7XG4gICAgICAgIGxldCB1YWlkO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgZGlkRXRociA9IGJ1aWxkRGlkRXRocihjaGFpbklkLCBwYXJhbXMuYWdlbnRBY2NvdW50LCB7IGVuY29kZTogZmFsc2UgfSk7XG4gICAgICAgICAgICBjb25zdCB1aWQgPSBkaWRFdGhyO1xuICAgICAgICAgICAgY29uc3QgbmF0aXZlSWQgPSBgZWlwMTU1OiR7Y2hhaW5JZH06JHtwYXJhbXMuYWdlbnRBY2NvdW50fWA7XG4gICAgICAgICAgICBjb25zdCBkb21haW4gPSB0eXBlb2YgcGFyYW1zLmFnZW50VXJsID09PSAnc3RyaW5nJyAmJiBwYXJhbXMuYWdlbnRVcmwudHJpbSgpXG4gICAgICAgICAgICAgICAgPyAoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBVUkwocGFyYW1zLmFnZW50VXJsKS5ob3N0bmFtZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSkoKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgdWFpZCA9IChhd2FpdCBnZW5lcmF0ZUhjczE0VWFpZERpZFRhcmdldCh7XG4gICAgICAgICAgICAgICAgdGFyZ2V0RGlkOiBkaWRFdGhyLFxuICAgICAgICAgICAgICAgIHJvdXRpbmc6IHtcbiAgICAgICAgICAgICAgICAgICAgcmVnaXN0cnk6ICdlcmMtODAwNCcsXG4gICAgICAgICAgICAgICAgICAgIHByb3RvOiAnYTJhJyxcbiAgICAgICAgICAgICAgICAgICAgbmF0aXZlSWQsXG4gICAgICAgICAgICAgICAgICAgIHVpZCxcbiAgICAgICAgICAgICAgICAgICAgZG9tYWluLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KSkudWFpZDtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignW2FnZW50cy5jcmVhdGVBZ2VudFdpdGhFT0FPd25lclVzaW5nV2FsbGV0XSBGYWlsZWQgdG8gZ2VuZXJhdGUgVUFJRDonLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlZ2lzdHJhdGlvbkpTT04gPSBjcmVhdGVSZWdpc3RyYXRpb25KU09OKHtcbiAgICAgICAgICAgICAgICBuYW1lOiBwYXJhbXMuYWdlbnROYW1lLFxuICAgICAgICAgICAgICAgIGFnZW50QWNjb3VudDogcGFyYW1zLmFnZW50QWNjb3VudCxcbiAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogcGFyYW1zLmRlc2NyaXB0aW9uLFxuICAgICAgICAgICAgICAgIGltYWdlOiBwYXJhbXMuaW1hZ2UsXG4gICAgICAgICAgICAgICAgYWdlbnRVcmw6IHBhcmFtcy5hZ2VudFVybCxcbiAgICAgICAgICAgICAgICBjaGFpbklkLFxuICAgICAgICAgICAgICAgIGlkZW50aXR5UmVnaXN0cnk6IGlkZW50aXR5UmVnaXN0cnlIZXgsXG4gICAgICAgICAgICAgICAgc3VwcG9ydGVkVHJ1c3Q6IHBhcmFtcy5zdXBwb3J0ZWRUcnVzdCxcbiAgICAgICAgICAgICAgICBlbmRwb2ludHM6IHBhcmFtcy5lbmRwb2ludHMsXG4gICAgICAgICAgICAgICAgdWFpZCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgdXBsb2FkUmVzdWx0ID0gYXdhaXQgdXBsb2FkUmVnaXN0cmF0aW9uKHJlZ2lzdHJhdGlvbkpTT04pO1xuICAgICAgICAgICAgdG9rZW5VcmkgPSB1cGxvYWRSZXN1bHQudG9rZW5Vcmk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gdXBsb2FkIHJlZ2lzdHJhdGlvbiBKU09OIHRvIElQRlM6JywgZXJyb3IpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gY3JlYXRlIHJlZ2lzdHJhdGlvbiBKU09OOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InfWApO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIG5vIHByaXZhdGUga2V5LCBwcmVwYXJlIHRyYW5zYWN0aW9uIGZvciBjbGllbnQtc2lkZSBzaWduaW5nXG4gICAgICAgIGlmICghYWRtaW5BcHAuaGFzUHJpdmF0ZUtleSkge1xuICAgICAgICAgICAgLy8gUHJlcGFyZSB0cmFuc2FjdGlvbiBmb3IgY2xpZW50LXNpZGUgc2lnbmluZ1xuICAgICAgICAgICAgLy8gQnVpbGQgbWV0YWRhdGEgYXJyYXlcbiAgICAgICAgICAgIGNvbnN0IG1ldGFkYXRhID0gW1xuICAgICAgICAgICAgICAgIHsga2V5OiAnYWdlbnROYW1lJywgdmFsdWU6IHBhcmFtcy5hZ2VudE5hbWUgPyBTdHJpbmcocGFyYW1zLmFnZW50TmFtZSkgOiAnJyB9LFxuICAgICAgICAgICAgICAgIHsga2V5OiAnYWdlbnRBY2NvdW50JywgdmFsdWU6IHBhcmFtcy5hZ2VudEFjY291bnQgPyBTdHJpbmcocGFyYW1zLmFnZW50QWNjb3VudCkgOiAnJyB9LFxuICAgICAgICAgICAgICAgIC4uLihwYXJhbXMuYWdlbnRDYXRlZ29yeSA/IFt7IGtleTogJ2FnZW50Q2F0ZWdvcnknLCB2YWx1ZTogU3RyaW5nKHBhcmFtcy5hZ2VudENhdGVnb3J5KSB9XSA6IFtdKSxcbiAgICAgICAgICAgICAgICB7IGtleTogJ3JlZ2lzdGVyZWRCeScsIHZhbHVlOiAnYWdlbnRpYy10cnVzdCcgfSxcbiAgICAgICAgICAgICAgICB7IGtleTogJ3JlZ2lzdHJ5TmFtZXNwYWNlJywgdmFsdWU6ICdlcmMtODAwNCcgfSxcbiAgICAgICAgICAgICAgICAuLi4odWFpZCA/IFt7IGtleTogJ3VhaWQnLCB2YWx1ZTogdWFpZCB9XSA6IFtdKSxcbiAgICAgICAgICAgIF0uZmlsdGVyKG0gPT4gbS52YWx1ZSAhPT0gJycpO1xuICAgICAgICAgICAgLy8gUHJlcGFyZSB0cmFuc2FjdGlvbiB1c2luZyBBSUFnZW50SWRlbnRpdHlDbGllbnQgKGFsbCBFdGhlcmV1bSBsb2dpYyBzZXJ2ZXItc2lkZSlcbiAgICAgICAgICAgIC8vIEdldCBjaGFpbiBieSBJRFxuICAgICAgICAgICAgY29uc3QgY2hhaW4gPSBnZXRDaGFpbkJ5SWQoY2hhaW5JZCk7XG4gICAgICAgICAgICBjb25zdCBycGNVcmwgPSBnZXRDaGFpblJwY1VybChjaGFpbklkKTtcbiAgICAgICAgICAgIGNvbnN0IHB1YmxpY0NsaWVudCA9IGNyZWF0ZVB1YmxpY0NsaWVudCh7XG4gICAgICAgICAgICAgICAgY2hhaW46IGNoYWluLFxuICAgICAgICAgICAgICAgIHRyYW5zcG9ydDogaHR0cChycGNVcmwpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBhY2NvdW50UHJvdmlkZXIgPSBuZXcgVmllbUFjY291bnRQcm92aWRlcih7XG4gICAgICAgICAgICAgICAgcHVibGljQ2xpZW50OiBwdWJsaWNDbGllbnQsXG4gICAgICAgICAgICAgICAgd2FsbGV0Q2xpZW50OiBudWxsLCAvLyBSZWFkLW9ubHkgZm9yIHRyYW5zYWN0aW9uIHByZXBhcmF0aW9uXG4gICAgICAgICAgICAgICAgY2hhaW5Db25maWc6IHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IGNoYWluSWQsXG4gICAgICAgICAgICAgICAgICAgIHJwY1VybDogcnBjVXJsLFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiBjaGFpbi5uYW1lLFxuICAgICAgICAgICAgICAgICAgICBjaGFpbjogY2hhaW4sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgYWlJZGVudGl0eUNsaWVudCA9IG5ldyBBSUFnZW50SWRlbnRpdHlDbGllbnQoe1xuICAgICAgICAgICAgICAgIGFjY291bnRQcm92aWRlcixcbiAgICAgICAgICAgICAgICBpZGVudGl0eVJlZ2lzdHJ5QWRkcmVzczogaWRlbnRpdHlSZWdpc3RyeUhleCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gUHJlcGFyZSBjb21wbGV0ZSB0cmFuc2FjdGlvbiAoZW5jb2RpbmcsIGdhcyBlc3RpbWF0aW9uLCBub25jZSwgZXRjLilcbiAgICAgICAgICAgIC8vIEFJQWdlbnRJZGVudGl0eUNsaWVudCBoYW5kbGVzIGFsbCBFdGhlcmV1bSBsb2dpYyBpbnRlcm5hbGx5IHVzaW5nIGl0cyBwdWJsaWNDbGllbnRcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gYXdhaXQgYWlJZGVudGl0eUNsaWVudC5wcmVwYXJlUmVnaXN0ZXJUcmFuc2FjdGlvbih0b2tlblVyaSwgbWV0YWRhdGEsIGFkbWluQXBwLmFkZHJlc3MgLy8gT25seSBhZGRyZXNzIG5lZWRlZCAtIG5vIHB1YmxpY0NsaWVudCBwYXNzZWRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHJlcXVpcmVzQ2xpZW50U2lnbmluZzogdHJ1ZSxcbiAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbixcbiAgICAgICAgICAgICAgICB0b2tlblVyaSxcbiAgICAgICAgICAgICAgICBtZXRhZGF0YTogbWV0YWRhdGEubWFwKG0gPT4gKHsga2V5OiBtLmtleSwgdmFsdWU6IG0udmFsdWUgfSkpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDaGVjayB3YWxsZXQgYmFsYW5jZSBiZWZvcmUgYXR0ZW1wdGluZyB0cmFuc2FjdGlvblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgYmFsYW5jZSA9IGF3YWl0IGFkbWluQXBwLnB1YmxpY0NsaWVudC5nZXRCYWxhbmNlKHsgYWRkcmVzczogYWRtaW5BcHAuYWRkcmVzcyB9KTtcbiAgICAgICAgICAgIGlmIChiYWxhbmNlID09PSAwbikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgV2FsbGV0ICR7YWRtaW5BcHAuYWRkcmVzc30gaGFzIHplcm8gYmFsYW5jZS4gUGxlYXNlIGZ1bmQgdGhlIHdhbGxldCB3aXRoIFNlcG9saWEgRVRIIHRvIHBheSBmb3IgZ2FzLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc29sZS5sb2coYFdhbGxldCBiYWxhbmNlOiAke2JhbGFuY2UudG9TdHJpbmcoKX0gd2VpICgkeyhOdW1iZXIoYmFsYW5jZSkgLyAxZTE4KS50b0ZpeGVkKDYpfSBFVEgpYCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGJhbGFuY2VFcnJvcikge1xuICAgICAgICAgICAgaWYgKGJhbGFuY2VFcnJvci5tZXNzYWdlLmluY2x1ZGVzKCd6ZXJvIGJhbGFuY2UnKSkge1xuICAgICAgICAgICAgICAgIHRocm93IGJhbGFuY2VFcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnNvbGUud2FybignQ291bGQgbm90IGNoZWNrIHdhbGxldCBiYWxhbmNlOicsIGJhbGFuY2VFcnJvci5tZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDcmVhdGUgd3JpdGUtY2FwYWJsZSBJZGVudGl0eUNsaWVudCB1c2luZyBBZG1pbkFwcCBBY2NvdW50UHJvdmlkZXJcbiAgICAgICAgY29uc3QgaWRlbnRpdHlDbGllbnQgPSBuZXcgQmFzZUlkZW50aXR5Q2xpZW50KGFkbWluQXBwLmFjY291bnRQcm92aWRlciwgaWRlbnRpdHlSZWdpc3RyeUhleCk7XG4gICAgICAgIC8vIEJ1aWxkIG1ldGFkYXRhIGFycmF5XG4gICAgICAgIC8vIEZvciBhZ2VudEFjY291bnQgKGFkZHJlc3MpLCB3ZSBuZWVkIHRvIHBhc3MgaXQgYXMtaXMgc2luY2UgaXQncyBhbHJlYWR5IGEgaGV4IHN0cmluZ1xuICAgICAgICAvLyBJZGVudGl0eUNsaWVudC5zdHJpbmdUb0J5dGVzIHdpbGwgZW5jb2RlIHN0cmluZ3MgYXMgVVRGLTgsIHdoaWNoIGlzIGZpbmUgZm9yIGFnZW50TmFtZVxuICAgICAgICAvLyBidXQgYWdlbnRBY2NvdW50IHNob3VsZCBiZSB0cmVhdGVkIGFzIGFuIGFkZHJlc3Mgc3RyaW5nICh3aGljaCB3aWxsIGJlIGVuY29kZWQgYXMgVVRGLTgpXG4gICAgICAgIC8vIE5vdGU6IFRoZSBjb250cmFjdCBleHBlY3RzIGJ5dGVzLCBhbmQgZW5jb2RpbmcgdGhlIGFkZHJlc3Mgc3RyaW5nIGFzIFVURi04IGlzIGFjY2VwdGFibGVcbiAgICAgICAgLy8gYXMgbG9uZyBhcyBpdCdzIGNvbnNpc3RlbnRseSBkZWNvZGVkIG9uIHJlYWRcbiAgICAgICAgY29uc3QgbWV0YWRhdGEgPSBbXG4gICAgICAgICAgICB7IGtleTogJ2FnZW50TmFtZScsIHZhbHVlOiBwYXJhbXMuYWdlbnROYW1lID8gU3RyaW5nKHBhcmFtcy5hZ2VudE5hbWUpIDogJycgfSxcbiAgICAgICAgICAgIHsga2V5OiAnYWdlbnRBY2NvdW50JywgdmFsdWU6IHBhcmFtcy5hZ2VudEFjY291bnQgPyBTdHJpbmcocGFyYW1zLmFnZW50QWNjb3VudCkgOiAnJyB9LFxuICAgICAgICAgICAgLi4uKHBhcmFtcy5hZ2VudENhdGVnb3J5ID8gW3sga2V5OiAnYWdlbnRDYXRlZ29yeScsIHZhbHVlOiBTdHJpbmcocGFyYW1zLmFnZW50Q2F0ZWdvcnkpIH1dIDogW10pLFxuICAgICAgICAgICAgeyBrZXk6ICdyZWdpc3RlcmVkQnknLCB2YWx1ZTogJ2FnZW50aWMtdHJ1c3QnIH0sXG4gICAgICAgICAgICB7IGtleTogJ3JlZ2lzdHJ5TmFtZXNwYWNlJywgdmFsdWU6ICdlcmMtODAwNCcgfSxcbiAgICAgICAgICAgIC4uLih1YWlkID8gW3sga2V5OiAndWFpZCcsIHZhbHVlOiB1YWlkIH1dIDogW10pLFxuICAgICAgICBdLmZpbHRlcihtID0+IG0udmFsdWUgIT09ICcnKTsgLy8gUmVtb3ZlIGVtcHR5IHZhbHVlc1xuICAgICAgICAvLyBVc2UgZGlyZWN0IEVPQSB0cmFuc2FjdGlvbiBwYXRoIChleGlzdGluZyBiZWhhdmlvcilcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgaWRlbnRpdHlDbGllbnQucmVnaXN0ZXJXaXRoTWV0YWRhdGEodG9rZW5VcmksIG1ldGFkYXRhKTtcbiAgICAgICAgLy8gQWZ0ZXIgd2UgaGF2ZSBhbiBhZ2VudElkLCB3cml0ZSBpdCBiYWNrIGJ5IHVwZGF0aW5nIHRva2VuVXJpIHNvIHJlZ2lzdHJhdGlvbnNbXS5hZ2VudElkIGlzIHBvcHVsYXRlZC5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGFnZW50SWRTdHIgPSByZXN1bHQuYWdlbnRJZC50b1N0cmluZygpO1xuICAgICAgICAgICAgY29uc3QgdXBkYXRlZFJlZ2lzdHJhdGlvbkpTT04gPSBjcmVhdGVSZWdpc3RyYXRpb25KU09OKHtcbiAgICAgICAgICAgICAgICBuYW1lOiBwYXJhbXMuYWdlbnROYW1lLFxuICAgICAgICAgICAgICAgIGFnZW50QWNjb3VudDogcGFyYW1zLmFnZW50QWNjb3VudCxcbiAgICAgICAgICAgICAgICBhZ2VudElkOiBhZ2VudElkU3RyLFxuICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBwYXJhbXMuZGVzY3JpcHRpb24sXG4gICAgICAgICAgICAgICAgaW1hZ2U6IHBhcmFtcy5pbWFnZSxcbiAgICAgICAgICAgICAgICBhZ2VudFVybDogcGFyYW1zLmFnZW50VXJsLFxuICAgICAgICAgICAgICAgIGNoYWluSWQsXG4gICAgICAgICAgICAgICAgaWRlbnRpdHlSZWdpc3RyeTogaWRlbnRpdHlSZWdpc3RyeUhleCxcbiAgICAgICAgICAgICAgICBzdXBwb3J0ZWRUcnVzdDogcGFyYW1zLnN1cHBvcnRlZFRydXN0LFxuICAgICAgICAgICAgICAgIGVuZHBvaW50czogcGFyYW1zLmVuZHBvaW50cyxcbiAgICAgICAgICAgICAgICB1YWlkLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCB1cGRhdGVkVXBsb2FkID0gYXdhaXQgdXBsb2FkUmVnaXN0cmF0aW9uKHVwZGF0ZWRSZWdpc3RyYXRpb25KU09OKTtcbiAgICAgICAgICAgIGF3YWl0IGlkZW50aXR5Q2xpZW50LnNldEFnZW50VXJpKEJpZ0ludChhZ2VudElkU3RyKSwgdXBkYXRlZFVwbG9hZC50b2tlblVyaSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKHVhaWRFcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdbYWdlbnRzLmNyZWF0ZUFnZW50V2l0aEVPQU93bmVyVXNpbmdXYWxsZXRdIEZhaWxlZCB0byBmaW5hbGl6ZSB0b2tlblVyaSB1cGRhdGUgd2l0aCBhZ2VudElkOicsIHVhaWRFcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVmcmVzaCB0aGUgYWdlbnQgaW4gdGhlIEdyYXBoUUwgaW5kZXhlclxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgZGlzY292ZXJ5Q2xpZW50ID0gYXdhaXQgZ2V0RGlzY292ZXJ5Q2xpZW50KCk7XG4gICAgICAgICAgICBhd2FpdCBkaXNjb3ZlcnlDbGllbnQucmVmcmVzaEFnZW50KHJlc3VsdC5hZ2VudElkLnRvU3RyaW5nKCksIGNoYWluSWQpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coYOKchSBSZWZyZXNoZWQgYWdlbnQgJHtyZXN1bHQuYWdlbnRJZH0gaW4gR3JhcGhRTCBpbmRleGVyYCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKHJlZnJlc2hFcnJvcikge1xuICAgICAgICAgICAgLy8gTG9nIGVycm9yIGJ1dCBkb24ndCBmYWlsIGFnZW50IGNyZWF0aW9uIGlmIHJlZnJlc2ggZmFpbHNcbiAgICAgICAgICAgIGNvbnNvbGUud2Fybihg4pqg77iPIEZhaWxlZCB0byByZWZyZXNoIGFnZW50ICR7cmVzdWx0LmFnZW50SWR9IGluIEdyYXBoUUwgaW5kZXhlcjpgLCByZWZyZXNoRXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBhZ2VudCBmb3IgRU9BIHVzaW5nIHRoZSBzZXJ2ZXIgYWRtaW4gcHJpdmF0ZSBrZXkuXG4gICAgICogU2FtZSBpbnRlcmZhY2UgYXMgY3JlYXRlQWdlbnRXaXRoRU9BT3duZXJVc2luZ1dhbGxldCwgYnV0IGFsd2F5cyBleGVjdXRlcyB0aGUgdHJhbnNhY3Rpb24gc2VydmVyLXNpZGUuXG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlQWdlbnRXaXRoRU9BT3duZXJVc2luZ1ByaXZhdGVLZXkocGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IHRhcmdldENoYWluSWQgPSBwYXJhbXMuY2hhaW5JZCB8fCBERUZBVUxUX0NIQUlOX0lEO1xuICAgICAgICBjb25zdCBhZG1pbkFwcCA9IGF3YWl0IGdldEFkbWluQXBwKHVuZGVmaW5lZCwgdGFyZ2V0Q2hhaW5JZCk7XG4gICAgICAgIGlmICghYWRtaW5BcHApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQWRtaW5BcHAgbm90IGluaXRpYWxpemVkLiBFbnN1cmUgQUdFTlRJQ19UUlVTVF9BUFBfUk9MRVMgaW5jbHVkZXMgXCJhZG1pblwiIGFuZCBwcm92aWRlIEFHRU5USUNfVFJVU1RfQURNSU5fUFJJVkFURV9LRVknKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWFkbWluQXBwLmhhc1ByaXZhdGVLZXkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQWRtaW4gcHJpdmF0ZSBrZXkgbm90IGF2YWlsYWJsZSBvbiBzZXJ2ZXIuIENhbm5vdCBleGVjdXRlIHNlcnZlci1zaWRlIHRyYW5zYWN0aW9uLicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlkZW50aXR5UmVnaXN0cnkgPSByZXF1aXJlQ2hhaW5FbnZWYXIoJ0FHRU5USUNfVFJVU1RfSURFTlRJVFlfUkVHSVNUUlknLCB0YXJnZXRDaGFpbklkKTtcbiAgICAgICAgY29uc3QgaWRlbnRpdHlSZWdpc3RyeUhleCA9IGlkZW50aXR5UmVnaXN0cnkuc3RhcnRzV2l0aCgnMHgnKSA/IGlkZW50aXR5UmVnaXN0cnkgOiBgMHgke2lkZW50aXR5UmVnaXN0cnl9YDtcbiAgICAgICAgLy8gQ3JlYXRlIHJlZ2lzdHJhdGlvbiBKU09OIGFuZCB1cGxvYWQgdG8gSVBGU1xuICAgICAgICBsZXQgdG9rZW5VcmkgPSAnJztcbiAgICAgICAgbGV0IHVhaWQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBkaWRFdGhyID0gYnVpbGREaWRFdGhyKHRhcmdldENoYWluSWQsIHBhcmFtcy5hZ2VudEFjY291bnQsIHsgZW5jb2RlOiBmYWxzZSB9KTtcbiAgICAgICAgICAgIGNvbnN0IHVpZCA9IGRpZEV0aHI7XG4gICAgICAgICAgICBjb25zdCBuYXRpdmVJZCA9IGBlaXAxNTU6JHt0YXJnZXRDaGFpbklkfToke3BhcmFtcy5hZ2VudEFjY291bnR9YDtcbiAgICAgICAgICAgIGNvbnN0IGRvbWFpbiA9IHR5cGVvZiBwYXJhbXMuYWdlbnRVcmwgPT09ICdzdHJpbmcnICYmIHBhcmFtcy5hZ2VudFVybC50cmltKClcbiAgICAgICAgICAgICAgICA/ICgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFVSTChwYXJhbXMuYWdlbnRVcmwpLmhvc3RuYW1lO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KSgpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB1YWlkID0gKGF3YWl0IGdlbmVyYXRlSGNzMTRVYWlkRGlkVGFyZ2V0KHtcbiAgICAgICAgICAgICAgICB0YXJnZXREaWQ6IGRpZEV0aHIsXG4gICAgICAgICAgICAgICAgcm91dGluZzoge1xuICAgICAgICAgICAgICAgICAgICByZWdpc3RyeTogJ2VyYy04MDA0JyxcbiAgICAgICAgICAgICAgICAgICAgcHJvdG86ICdhMmEnLFxuICAgICAgICAgICAgICAgICAgICBuYXRpdmVJZCxcbiAgICAgICAgICAgICAgICAgICAgdWlkLFxuICAgICAgICAgICAgICAgICAgICBkb21haW4sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pKS51YWlkO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdbYWdlbnRzLmNyZWF0ZUFnZW50V2l0aEVPQU93bmVyVXNpbmdQcml2YXRlS2V5XSBGYWlsZWQgdG8gZ2VuZXJhdGUgVUFJRDonLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlZ2lzdHJhdGlvbkpTT04gPSBjcmVhdGVSZWdpc3RyYXRpb25KU09OKHtcbiAgICAgICAgICAgICAgICBuYW1lOiBwYXJhbXMuYWdlbnROYW1lLFxuICAgICAgICAgICAgICAgIGFnZW50QWNjb3VudDogcGFyYW1zLmFnZW50QWNjb3VudCxcbiAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogcGFyYW1zLmRlc2NyaXB0aW9uLFxuICAgICAgICAgICAgICAgIGltYWdlOiBwYXJhbXMuaW1hZ2UsXG4gICAgICAgICAgICAgICAgYWdlbnRVcmw6IHBhcmFtcy5hZ2VudFVybCxcbiAgICAgICAgICAgICAgICBjaGFpbklkOiB0YXJnZXRDaGFpbklkLFxuICAgICAgICAgICAgICAgIGlkZW50aXR5UmVnaXN0cnk6IGlkZW50aXR5UmVnaXN0cnlIZXgsXG4gICAgICAgICAgICAgICAgc3VwcG9ydGVkVHJ1c3Q6IHBhcmFtcy5zdXBwb3J0ZWRUcnVzdCxcbiAgICAgICAgICAgICAgICBlbmRwb2ludHM6IHBhcmFtcy5lbmRwb2ludHMsXG4gICAgICAgICAgICAgICAgdWFpZCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgdXBsb2FkUmVzdWx0ID0gYXdhaXQgdXBsb2FkUmVnaXN0cmF0aW9uKHJlZ2lzdHJhdGlvbkpTT04pO1xuICAgICAgICAgICAgdG9rZW5VcmkgPSB1cGxvYWRSZXN1bHQudG9rZW5Vcmk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gdXBsb2FkIHJlZ2lzdHJhdGlvbiBKU09OIHRvIElQRlM6JywgZXJyb3IpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gY3JlYXRlIHJlZ2lzdHJhdGlvbiBKU09OOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InfWApO1xuICAgICAgICB9XG4gICAgICAgIC8vIENyZWF0ZSB3cml0ZS1jYXBhYmxlIElkZW50aXR5Q2xpZW50IHVzaW5nIEFkbWluQXBwIEFjY291bnRQcm92aWRlclxuICAgICAgICBjb25zdCBpZGVudGl0eUNsaWVudCA9IG5ldyBCYXNlSWRlbnRpdHlDbGllbnQoYWRtaW5BcHAuYWNjb3VudFByb3ZpZGVyLCBpZGVudGl0eVJlZ2lzdHJ5SGV4KTtcbiAgICAgICAgLy8gQnVpbGQgbWV0YWRhdGFcbiAgICAgICAgY29uc3QgbWV0YWRhdGEgPSBbXG4gICAgICAgICAgICB7IGtleTogJ2FnZW50TmFtZScsIHZhbHVlOiBwYXJhbXMuYWdlbnROYW1lID8gU3RyaW5nKHBhcmFtcy5hZ2VudE5hbWUpIDogJycgfSxcbiAgICAgICAgICAgIHsga2V5OiAnYWdlbnRBY2NvdW50JywgdmFsdWU6IHBhcmFtcy5hZ2VudEFjY291bnQgPyBTdHJpbmcocGFyYW1zLmFnZW50QWNjb3VudCkgOiAnJyB9LFxuICAgICAgICAgICAgLi4uKHBhcmFtcy5hZ2VudENhdGVnb3J5ID8gW3sga2V5OiAnYWdlbnRDYXRlZ29yeScsIHZhbHVlOiBTdHJpbmcocGFyYW1zLmFnZW50Q2F0ZWdvcnkpIH1dIDogW10pLFxuICAgICAgICAgICAgeyBrZXk6ICdyZWdpc3RlcmVkQnknLCB2YWx1ZTogJ2FnZW50aWMtdHJ1c3QnIH0sXG4gICAgICAgICAgICB7IGtleTogJ3JlZ2lzdHJ5TmFtZXNwYWNlJywgdmFsdWU6ICdlcmMtODAwNCcgfSxcbiAgICAgICAgICAgIC4uLih1YWlkID8gW3sga2V5OiAndWFpZCcsIHZhbHVlOiB1YWlkIH1dIDogW10pLFxuICAgICAgICBdLmZpbHRlcihtID0+IG0udmFsdWUgIT09ICcnKTtcbiAgICAgICAgLy8gRXhlY3V0ZSByZWdpc3RyYXRpb25cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgaWRlbnRpdHlDbGllbnQucmVnaXN0ZXJXaXRoTWV0YWRhdGEodG9rZW5VcmksIG1ldGFkYXRhKTtcbiAgICAgICAgLy8gQWZ0ZXIgd2UgaGF2ZSBhbiBhZ2VudElkLCB3cml0ZSBpdCBiYWNrIGJ5IHVwZGF0aW5nIHRva2VuVXJpIHNvIHJlZ2lzdHJhdGlvbnNbXS5hZ2VudElkIGlzIHBvcHVsYXRlZC5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGFnZW50SWRTdHIgPSByZXN1bHQuYWdlbnRJZC50b1N0cmluZygpO1xuICAgICAgICAgICAgY29uc3QgdXBkYXRlZFJlZ2lzdHJhdGlvbkpTT04gPSBjcmVhdGVSZWdpc3RyYXRpb25KU09OKHtcbiAgICAgICAgICAgICAgICBuYW1lOiBwYXJhbXMuYWdlbnROYW1lLFxuICAgICAgICAgICAgICAgIGFnZW50QWNjb3VudDogcGFyYW1zLmFnZW50QWNjb3VudCxcbiAgICAgICAgICAgICAgICBhZ2VudElkOiBhZ2VudElkU3RyLFxuICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBwYXJhbXMuZGVzY3JpcHRpb24sXG4gICAgICAgICAgICAgICAgaW1hZ2U6IHBhcmFtcy5pbWFnZSxcbiAgICAgICAgICAgICAgICBhZ2VudFVybDogcGFyYW1zLmFnZW50VXJsLFxuICAgICAgICAgICAgICAgIGNoYWluSWQ6IHRhcmdldENoYWluSWQsXG4gICAgICAgICAgICAgICAgaWRlbnRpdHlSZWdpc3RyeTogaWRlbnRpdHlSZWdpc3RyeUhleCxcbiAgICAgICAgICAgICAgICBzdXBwb3J0ZWRUcnVzdDogcGFyYW1zLnN1cHBvcnRlZFRydXN0LFxuICAgICAgICAgICAgICAgIGVuZHBvaW50czogcGFyYW1zLmVuZHBvaW50cyxcbiAgICAgICAgICAgICAgICB1YWlkLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCB1cGRhdGVkVXBsb2FkID0gYXdhaXQgdXBsb2FkUmVnaXN0cmF0aW9uKHVwZGF0ZWRSZWdpc3RyYXRpb25KU09OKTtcbiAgICAgICAgICAgIGF3YWl0IGlkZW50aXR5Q2xpZW50LnNldEFnZW50VXJpKEJpZ0ludChhZ2VudElkU3RyKSwgdXBkYXRlZFVwbG9hZC50b2tlblVyaSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKHVhaWRFcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdbYWdlbnRzLmNyZWF0ZUFnZW50V2l0aEVPQU93bmVyVXNpbmdQcml2YXRlS2V5XSBGYWlsZWQgdG8gZmluYWxpemUgdG9rZW5VcmkgdXBkYXRlIHdpdGggYWdlbnRJZDonLCB1YWlkRXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlZnJlc2ggaW4gaW5kZXhlciAoYmVzdC1lZmZvcnQpXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBkaXNjb3ZlcnlDbGllbnQgPSBhd2FpdCBnZXREaXNjb3ZlcnlDbGllbnQoKTtcbiAgICAgICAgICAgIGF3YWl0IGRpc2NvdmVyeUNsaWVudC5yZWZyZXNoQWdlbnQocmVzdWx0LmFnZW50SWQudG9TdHJpbmcoKSwgdGFyZ2V0Q2hhaW5JZCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKHJlZnJlc2hFcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGDimqDvuI8gRmFpbGVkIHRvIHJlZnJlc2ggYWdlbnQgJHtyZXN1bHQuYWdlbnRJZH0gaW4gR3JhcGhRTCBpbmRleGVyOmAsIHJlZnJlc2hFcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgYXN5bmMgY3JlYXRlQWdlbnRXaXRoU21hcnRBY2NvdW50T3duZXJVc2luZ1dhbGxldChwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgY2hhaW5JZCA9IHBhcmFtcy5jaGFpbklkIHx8IERFRkFVTFRfQ0hBSU5fSUQ7XG4gICAgICAgIGNvbnN0IGFkbWluQXBwID0gYXdhaXQgZ2V0QWRtaW5BcHAodW5kZWZpbmVkLCBjaGFpbklkKTtcbiAgICAgICAgaWYgKCFhZG1pbkFwcCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBZG1pbkFwcCBub3QgaW5pdGlhbGl6ZWQuIEVuc3VyZSBBR0VOVElDX1RSVVNUX0FQUF9ST0xFUyBpbmNsdWRlcyBcImFkbWluXCIgYW5kIHByb3ZpZGUgZWl0aGVyIEFHRU5USUNfVFJVU1RfQURNSU5fUFJJVkFURV9LRVkgb3IgY29ubmVjdCB2aWEgd2FsbGV0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaWRlbnRpdHlSZWdpc3RyeSA9IHJlcXVpcmVDaGFpbkVudlZhcignQUdFTlRJQ19UUlVTVF9JREVOVElUWV9SRUdJU1RSWScsIGNoYWluSWQpO1xuICAgICAgICBjb25zdCBpZGVudGl0eVJlZ2lzdHJ5SGV4ID0gaWRlbnRpdHlSZWdpc3RyeS5zdGFydHNXaXRoKCcweCcpXG4gICAgICAgICAgICA/IGlkZW50aXR5UmVnaXN0cnlcbiAgICAgICAgICAgIDogYDB4JHtpZGVudGl0eVJlZ2lzdHJ5fWA7XG4gICAgICAgIC8vIFVBSUQgaW4gRElELXRhcmdldCBmb3JtIHVzaW5nIGFnZW50IGFjY291bnQgZGlkOmV0aHIgKGF2YWlsYWJsZSBwcmUtcmVnaXN0cmF0aW9uKS5cbiAgICAgICAgbGV0IHVhaWQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBkaWRFdGhyID0gYnVpbGREaWRFdGhyKGNoYWluSWQsIHBhcmFtcy5hZ2VudEFjY291bnQsIHsgZW5jb2RlOiBmYWxzZSB9KTtcbiAgICAgICAgICAgIGNvbnN0IHVpZCA9IGRpZEV0aHI7XG4gICAgICAgICAgICBjb25zdCBuYXRpdmVJZCA9IGBlaXAxNTU6JHtjaGFpbklkfToke3BhcmFtcy5hZ2VudEFjY291bnR9YDtcbiAgICAgICAgICAgIGNvbnN0IGRvbWFpbiA9IHR5cGVvZiBwYXJhbXMuYWdlbnRVcmwgPT09ICdzdHJpbmcnICYmIHBhcmFtcy5hZ2VudFVybC50cmltKClcbiAgICAgICAgICAgICAgICA/ICgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFVSTChwYXJhbXMuYWdlbnRVcmwpLmhvc3RuYW1lO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KSgpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBnZW5lcmF0ZUhjczE0VWFpZERpZFRhcmdldCh7XG4gICAgICAgICAgICAgICAgdGFyZ2V0RGlkOiBkaWRFdGhyLFxuICAgICAgICAgICAgICAgIHJvdXRpbmc6IHtcbiAgICAgICAgICAgICAgICAgICAgcmVnaXN0cnk6ICdlcmMtODAwNCcsXG4gICAgICAgICAgICAgICAgICAgIHByb3RvOiAnYTJhJyxcbiAgICAgICAgICAgICAgICAgICAgbmF0aXZlSWQsXG4gICAgICAgICAgICAgICAgICAgIHVpZCxcbiAgICAgICAgICAgICAgICAgICAgZG9tYWluLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHVhaWQgPSByZXN1bHQudWFpZDtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignW2FnZW50cy5jcmVhdGVBZ2VudFdpdGhTbWFydEFjY291bnRPd25lclVzaW5nV2FsbGV0XSBGYWlsZWQgdG8gZ2VuZXJhdGUgVUFJRDonLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ3JlYXRlIHJlZ2lzdHJhdGlvbiBKU09OIGFuZCB1cGxvYWQgdG8gSVBGU1xuICAgICAgICBsZXQgdG9rZW5VcmkgPSAnJztcbiAgICAgICAgY29uc29sZS5sb2coJ1thZ2VudHMuY3JlYXRlQWdlbnRXaXRoU21hcnRBY2NvdW50T3duZXJVc2luZ1dhbGxldF0gVXNpbmcgY2hhaW5JZCcsIGNoYWluSWQpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmVnaXN0cmF0aW9uSlNPTiA9IGNyZWF0ZVJlZ2lzdHJhdGlvbkpTT04oe1xuICAgICAgICAgICAgICAgIG5hbWU6IHBhcmFtcy5hZ2VudE5hbWUsXG4gICAgICAgICAgICAgICAgYWdlbnRBY2NvdW50OiBwYXJhbXMuYWdlbnRBY2NvdW50LFxuICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBwYXJhbXMuZGVzY3JpcHRpb24sXG4gICAgICAgICAgICAgICAgaW1hZ2U6IHBhcmFtcy5pbWFnZSxcbiAgICAgICAgICAgICAgICBhZ2VudFVybDogcGFyYW1zLmFnZW50VXJsLFxuICAgICAgICAgICAgICAgIGNoYWluSWQsXG4gICAgICAgICAgICAgICAgaWRlbnRpdHlSZWdpc3RyeTogaWRlbnRpdHlSZWdpc3RyeUhleCxcbiAgICAgICAgICAgICAgICBzdXBwb3J0ZWRUcnVzdDogcGFyYW1zLnN1cHBvcnRlZFRydXN0LFxuICAgICAgICAgICAgICAgIGVuZHBvaW50czogcGFyYW1zLmVuZHBvaW50cyxcbiAgICAgICAgICAgICAgICB1YWlkLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCB1cGxvYWRSZXN1bHQgPSBhd2FpdCB1cGxvYWRSZWdpc3RyYXRpb24ocmVnaXN0cmF0aW9uSlNPTik7XG4gICAgICAgICAgICB0b2tlblVyaSA9IHVwbG9hZFJlc3VsdC50b2tlblVyaTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byB1cGxvYWQgcmVnaXN0cmF0aW9uIEpTT04gdG8gSVBGUzonLCBlcnJvcik7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBjcmVhdGUgcmVnaXN0cmF0aW9uIEpTT046ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvcid9YCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRGV0ZXJtaW5lIGNoYWluIGJhc2VkIG9uIGNoYWluSWRcbiAgICAgICAgY29uc3QgY2hhaW4gPSBnZXRDaGFpbkJ5SWQoY2hhaW5JZCk7XG4gICAgICAgIGNvbnN0IHJwY1VybCA9IGdldENoYWluUnBjVXJsKGNoYWluSWQpO1xuICAgICAgICBjb25zdCBwdWJsaWNDbGllbnQgPSBjcmVhdGVQdWJsaWNDbGllbnQoe1xuICAgICAgICAgICAgY2hhaW46IGNoYWluLFxuICAgICAgICAgICAgdHJhbnNwb3J0OiBodHRwKHJwY1VybCksXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBhY2NvdW50UHJvdmlkZXIgPSBuZXcgVmllbUFjY291bnRQcm92aWRlcih7XG4gICAgICAgICAgICBwdWJsaWNDbGllbnQ6IHB1YmxpY0NsaWVudCxcbiAgICAgICAgICAgIHdhbGxldENsaWVudDogbnVsbCxcbiAgICAgICAgICAgIGNoYWluQ29uZmlnOiB7XG4gICAgICAgICAgICAgICAgaWQ6IGNoYWluSWQsXG4gICAgICAgICAgICAgICAgcnBjVXJsOiBycGNVcmwsXG4gICAgICAgICAgICAgICAgbmFtZTogY2hhaW4ubmFtZSxcbiAgICAgICAgICAgICAgICBjaGFpbjogY2hhaW4sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgYWlJZGVudGl0eUNsaWVudCA9IG5ldyBBSUFnZW50SWRlbnRpdHlDbGllbnQoe1xuICAgICAgICAgICAgYWNjb3VudFByb3ZpZGVyLFxuICAgICAgICAgICAgaWRlbnRpdHlSZWdpc3RyeUFkZHJlc3M6IGlkZW50aXR5UmVnaXN0cnlIZXgsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBhZGRpdGlvbmFsTWV0YWRhdGEgPSBbXG4gICAgICAgICAgICAuLi4ocGFyYW1zLmFnZW50Q2F0ZWdvcnkgPyBbeyBrZXk6ICdhZ2VudENhdGVnb3J5JywgdmFsdWU6IHBhcmFtcy5hZ2VudENhdGVnb3J5IH1dIDogW10pLFxuICAgICAgICAgICAgeyBrZXk6ICdyZWdpc3RlcmVkQnknLCB2YWx1ZTogJ2FnZW50aWMtdHJ1c3QnIH0sXG4gICAgICAgICAgICB7IGtleTogJ3JlZ2lzdHJ5TmFtZXNwYWNlJywgdmFsdWU6ICdlcmMtODAwNCcgfSxcbiAgICAgICAgICAgIC4uLih1YWlkID8gW3sga2V5OiAndWFpZCcsIHZhbHVlOiB1YWlkIH1dIDogW10pLFxuICAgICAgICBdO1xuICAgICAgICBjb25zdCB7IGNhbGxzOiByZWdpc3RlckNhbGxzIH0gPSBhd2FpdCBhaUlkZW50aXR5Q2xpZW50LnByZXBhcmVSZWdpc3RlckNhbGxzKHBhcmFtcy5hZ2VudE5hbWUsIHBhcmFtcy5hZ2VudEFjY291bnQsIHRva2VuVXJpLCBhZGRpdGlvbmFsTWV0YWRhdGEpO1xuICAgICAgICBjb25zdCBidW5kbGVyVXJsID0gZ2V0Q2hhaW5CdW5kbGVyVXJsKHBhcmFtcy5jaGFpbklkIHx8IERFRkFVTFRfQ0hBSU5fSUQpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgICAgIGJ1bmRsZXJVcmwsXG4gICAgICAgICAgICB0b2tlblVyaSxcbiAgICAgICAgICAgIGNoYWluSWQsXG4gICAgICAgICAgICBjYWxsczogcmVnaXN0ZXJDYWxscyxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IGFnZW50IGZvciBBQSBhbmQgZXhlY3V0ZSB2aWEgc2VydmVyIGFkbWluIHByaXZhdGUga2V5IChubyBjbGllbnQgcHJvbXB0cykuXG4gICAgICogU2FtZSBpbnB1dCBpbnRlcmZhY2UgYXMgY3JlYXRlQWdlbnRXaXRoU21hcnRBY2NvdW50T3duZXJVc2luZ1dhbGxldCwgYnV0IHBlcmZvcm1zIHRoZSBVc2VyT3BlcmF0aW9uIHVzaW5nIHRoZSBzZXJ2ZXIga2V5LlxuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZUFnZW50V2l0aFNtYXJ0QWNjb3VudE93bmVyVXNpbmdQcml2YXRlS2V5KHBhcmFtcykge1xuICAgICAgICBjb25zdCBjaGFpbklkID0gcGFyYW1zLmNoYWluSWQgfHwgREVGQVVMVF9DSEFJTl9JRDtcbiAgICAgICAgY29uc3QgYWRtaW5BcHAgPSBhd2FpdCBnZXRBZG1pbkFwcCh1bmRlZmluZWQsIGNoYWluSWQpO1xuICAgICAgICBpZiAoIWFkbWluQXBwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FkbWluQXBwIG5vdCBpbml0aWFsaXplZC4gRW5zdXJlIEFHRU5USUNfVFJVU1RfQVBQX1JPTEVTIGluY2x1ZGVzIFwiYWRtaW5cIiBhbmQgcHJvdmlkZSBBR0VOVElDX1RSVVNUX0FETUlOX1BSSVZBVEVfS0VZJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmlyc3QgcmV1c2UgZXhpc3RpbmcgcHJlcGFyYXRpb24gdG8gZ2V0IHJlZ2lzdGVyIGNhbGxzXG4gICAgICAgIGNvbnN0IHByZXBhcmVkID0gYXdhaXQgdGhpcy5jcmVhdGVBZ2VudFdpdGhTbWFydEFjY291bnRPd25lclVzaW5nV2FsbGV0KHtcbiAgICAgICAgICAgIC4uLnBhcmFtcyxcbiAgICAgICAgICAgIGNoYWluSWQsXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBCdWlsZCBBQSBhY2NvdW50IGNsaWVudCB1c2luZyBhZG1pbiBzaWduZXJcbiAgICAgICAgY29uc3QgY2hhaW4gPSBnZXRDaGFpbkJ5SWQoY2hhaW5JZCk7XG4gICAgICAgIC8vIERldGVybWluaXN0aWMgc2FsdCBiYXNlZCBvbiBhZ2VudE5hbWUgKG1hdGNoZXMgY2xpZW50IGNvbXB1dGF0aW9uKVxuICAgICAgICBjb25zdCB7IGtlY2NhazI1Niwgc3RyaW5nVG9IZXggfSA9IGF3YWl0IGltcG9ydCgndmllbScpO1xuICAgICAgICBjb25zdCBkZXBsb3lTYWx0ID0ga2VjY2FrMjU2KHN0cmluZ1RvSGV4KHBhcmFtcy5hZ2VudE5hbWUpKTtcbiAgICAgICAgY29uc3QgYWNjb3VudENsaWVudCA9IGF3YWl0IHRvTWV0YU1hc2tTbWFydEFjY291bnQoe1xuICAgICAgICAgICAgY2xpZW50OiBhZG1pbkFwcC5wdWJsaWNDbGllbnQsXG4gICAgICAgICAgICBpbXBsZW1lbnRhdGlvbjogSW1wbGVtZW50YXRpb24uSHlicmlkLFxuICAgICAgICAgICAgc2lnbmVyOiBhZG1pbkFwcC53YWxsZXRDbGllbnRcbiAgICAgICAgICAgICAgICA/IHsgd2FsbGV0Q2xpZW50OiBhZG1pbkFwcC53YWxsZXRDbGllbnQgfVxuICAgICAgICAgICAgICAgIDogKGFkbWluQXBwLmFjY291bnQgPyB7IGFjY291bnQ6IGFkbWluQXBwLmFjY291bnQgfSA6IHt9KSxcbiAgICAgICAgICAgIGRlcGxveVBhcmFtczogW2FkbWluQXBwLmFkZHJlc3MsIFtdLCBbXSwgW11dLFxuICAgICAgICAgICAgZGVwbG95U2FsdCxcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFNlbmQgVXNlck9wZXJhdGlvbiB2aWEgYnVuZGxlclxuICAgICAgICBjb25zdCBidW5kbGVyVXJsID0gcHJlcGFyZWQuYnVuZGxlclVybDtcbiAgICAgICAgY29uc3QgYnVuZGxlckNsaWVudCA9IGNyZWF0ZUJ1bmRsZXJDbGllbnQoe1xuICAgICAgICAgICAgdHJhbnNwb3J0OiBodHRwKGJ1bmRsZXJVcmwpLFxuICAgICAgICAgICAgcGF5bWFzdGVyOiB0cnVlLFxuICAgICAgICAgICAgY2hhaW46IGNoYWluLFxuICAgICAgICAgICAgcGF5bWFzdGVyQ29udGV4dDogeyBtb2RlOiAnU1BPTlNPUkVEJyB9LFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gcGVybWlzc2lvbmxlc3MgZ2FzIHByaWNlIChvcHRpb25hbClcbiAgICAgICAgbGV0IGZlZSA9IHt9O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgeyBjcmVhdGVQaW1saWNvQ2xpZW50IH0gPSBhd2FpdCBpbXBvcnQoJ3Blcm1pc3Npb25sZXNzL2NsaWVudHMvcGltbGljbycpO1xuICAgICAgICAgICAgY29uc3QgcGltbGljbyA9IGNyZWF0ZVBpbWxpY29DbGllbnQoeyB0cmFuc3BvcnQ6IGh0dHAoYnVuZGxlclVybCkgfSk7XG4gICAgICAgICAgICBjb25zdCBnYXMgPSBhd2FpdCBwaW1saWNvLmdldFVzZXJPcGVyYXRpb25HYXNQcmljZSgpO1xuICAgICAgICAgICAgZmVlID0gZ2FzLmZhc3QgfHwge307XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2gge1xuICAgICAgICAgICAgLy8gb3B0aW9uYWxcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1c2VyT3BlcmF0aW9uSGFzaCA9IGF3YWl0IGJ1bmRsZXJDbGllbnQuc2VuZFVzZXJPcGVyYXRpb24oe1xuICAgICAgICAgICAgYWNjb3VudDogYWNjb3VudENsaWVudCxcbiAgICAgICAgICAgIGNhbGxzOiBwcmVwYXJlZC5jYWxscyxcbiAgICAgICAgICAgIC4uLmZlZSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJlY2VpcHQgPSBhd2FpdCBidW5kbGVyQ2xpZW50LndhaXRGb3JVc2VyT3BlcmF0aW9uUmVjZWlwdCh7IGhhc2g6IHVzZXJPcGVyYXRpb25IYXNoIH0pO1xuICAgICAgICAvLyBUcnkgdG8gZXh0cmFjdCBhZ2VudElkIChiZXN0LWVmZm9ydClcbiAgICAgICAgbGV0IGFnZW50SWQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBpZCA9IGF3YWl0IHRoaXMuZXh0cmFjdEFnZW50SWRGcm9tUmVjZWlwdChyZWNlaXB0LCBjaGFpbklkKTtcbiAgICAgICAgICAgIGlmIChpZClcbiAgICAgICAgICAgICAgICBhZ2VudElkID0gaWQ7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggeyB9XG4gICAgICAgIC8vIElmIHdlIGhhdmUgYW4gYWdlbnRJZCwgdXBkYXRlIHRva2VuVXJpIG9uLWNoYWluIHNvIHJlZ2lzdHJhdGlvbnNbXS5hZ2VudElkIGlzIHBvcHVsYXRlZC5cbiAgICAgICAgaWYgKGFnZW50SWQpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGlkRXRociA9IGJ1aWxkRGlkRXRocihjaGFpbklkLCBwYXJhbXMuYWdlbnRBY2NvdW50LCB7IGVuY29kZTogZmFsc2UgfSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdWlkID0gZGlkRXRocjtcbiAgICAgICAgICAgICAgICBjb25zdCBuYXRpdmVJZCA9IGBlaXAxNTU6JHtjaGFpbklkfToke3BhcmFtcy5hZ2VudEFjY291bnR9YDtcbiAgICAgICAgICAgICAgICBjb25zdCBkb21haW4gPSB0eXBlb2YgcGFyYW1zLmFnZW50VXJsID09PSAnc3RyaW5nJyAmJiBwYXJhbXMuYWdlbnRVcmwudHJpbSgpXG4gICAgICAgICAgICAgICAgICAgID8gKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBVUkwocGFyYW1zLmFnZW50VXJsKS5ob3N0bmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KSgpXG4gICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgdWFpZCB9ID0gYXdhaXQgZ2VuZXJhdGVIY3MxNFVhaWREaWRUYXJnZXQoe1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXREaWQ6IGRpZEV0aHIsXG4gICAgICAgICAgICAgICAgICAgIHJvdXRpbmc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZ2lzdHJ5OiAnZXJjLTgwMDQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvdG86ICdhMmEnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmF0aXZlSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICB1aWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBkb21haW4sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY29uc3QgaWRlbnRpdHlSZWdpc3RyeSA9IHJlcXVpcmVDaGFpbkVudlZhcignQUdFTlRJQ19UUlVTVF9JREVOVElUWV9SRUdJU1RSWScsIGNoYWluSWQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlkZW50aXR5UmVnaXN0cnlIZXggPSBpZGVudGl0eVJlZ2lzdHJ5LnN0YXJ0c1dpdGgoJzB4JykgPyBpZGVudGl0eVJlZ2lzdHJ5IDogYDB4JHtpZGVudGl0eVJlZ2lzdHJ5fWA7XG4gICAgICAgICAgICAgICAgY29uc3QgdXBkYXRlZFJlZ2lzdHJhdGlvbkpTT04gPSBjcmVhdGVSZWdpc3RyYXRpb25KU09OKHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogcGFyYW1zLmFnZW50TmFtZSxcbiAgICAgICAgICAgICAgICAgICAgYWdlbnRBY2NvdW50OiBwYXJhbXMuYWdlbnRBY2NvdW50LFxuICAgICAgICAgICAgICAgICAgICBhZ2VudElkLFxuICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogcGFyYW1zLmRlc2NyaXB0aW9uLFxuICAgICAgICAgICAgICAgICAgICBpbWFnZTogcGFyYW1zLmltYWdlLFxuICAgICAgICAgICAgICAgICAgICBhZ2VudFVybDogcGFyYW1zLmFnZW50VXJsLFxuICAgICAgICAgICAgICAgICAgICBjaGFpbklkLFxuICAgICAgICAgICAgICAgICAgICBpZGVudGl0eVJlZ2lzdHJ5OiBpZGVudGl0eVJlZ2lzdHJ5SGV4LFxuICAgICAgICAgICAgICAgICAgICBzdXBwb3J0ZWRUcnVzdDogcGFyYW1zLnN1cHBvcnRlZFRydXN0LFxuICAgICAgICAgICAgICAgICAgICBlbmRwb2ludHM6IHBhcmFtcy5lbmRwb2ludHMsXG4gICAgICAgICAgICAgICAgICAgIHVhaWQsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdXBkYXRlZFVwbG9hZCA9IGF3YWl0IHVwbG9hZFJlZ2lzdHJhdGlvbih1cGRhdGVkUmVnaXN0cmF0aW9uSlNPTik7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJlcGFyZWRVcGRhdGUgPSBhd2FpdCB0aGlzLmFkbWluLnByZXBhcmVVcGRhdGVBZ2VudCh7XG4gICAgICAgICAgICAgICAgICAgIGFnZW50SWQsXG4gICAgICAgICAgICAgICAgICAgIHRva2VuVXJpOiB1cGRhdGVkVXBsb2FkLnRva2VuVXJpLFxuICAgICAgICAgICAgICAgICAgICBjaGFpbklkLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IG5leHROb25jZSA9IGF3YWl0IGdldEFjY291bnROb25jZShhY2NvdW50Q2xpZW50KTtcbiAgICAgICAgICAgICAgICBhd2FpdCBzZW5kVXNlck9wV2l0aFRpbWVvdXQoe1xuICAgICAgICAgICAgICAgICAgICBidW5kbGVyVXJsLFxuICAgICAgICAgICAgICAgICAgICBjaGFpbixcbiAgICAgICAgICAgICAgICAgICAgYWNjb3VudENsaWVudCxcbiAgICAgICAgICAgICAgICAgICAgY2FsbHM6IHByZXBhcmVkVXBkYXRlLmNhbGxzLFxuICAgICAgICAgICAgICAgICAgICBub25jZTogbmV4dE5vbmNlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKHVhaWRFcnJvcikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignW2NyZWF0ZUFnZW50V2l0aFNtYXJ0QWNjb3VudE93bmVyVXNpbmdQcml2YXRlS2V5XSBGYWlsZWQgdG8gZmluYWxpemUgdG9rZW5VcmkgdXBkYXRlIHdpdGggYWdlbnRJZDonLCB1YWlkRXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJhbXMuZW5zT3B0aW9ucz8uZW5hYmxlZCAmJiBwYXJhbXMuZW5zT3B0aW9ucy5vcmdOYW1lKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVuc0NsaWVudCA9IGF3YWl0IGdldEVOU0NsaWVudChjaGFpbklkKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNMMShjaGFpbklkKSkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBhZGRUb0wxT3JnUEsoe1xuICAgICAgICAgICAgICAgICAgICAgICAgb3JnTmFtZTogcGFyYW1zLmVuc09wdGlvbnMub3JnTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFnZW50TmFtZTogcGFyYW1zLmFnZW50TmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFnZW50QWRkcmVzczogcGFyYW1zLmFnZW50QWNjb3VudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFnZW50VXJsOiBwYXJhbXMuYWdlbnRVcmwsXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFpbklkLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBjYWxsczogaW5mb0NhbGxzIH0gPSBhd2FpdCBlbnNDbGllbnQucHJlcGFyZVNldEFnZW50TmFtZUluZm9DYWxscyh7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcmdOYW1lOiBwYXJhbXMuZW5zT3B0aW9ucy5vcmdOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWdlbnROYW1lOiBwYXJhbXMuYWdlbnROYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWdlbnRBZGRyZXNzOiBwYXJhbXMuYWdlbnRBY2NvdW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgYWdlbnRVcmw6IHBhcmFtcy5hZ2VudFVybCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFnZW50RGVzY3JpcHRpb246IHBhcmFtcy5kZXNjcmlwdGlvbixcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBuZXh0Tm9uY2UgPSBhd2FpdCBnZXRBY2NvdW50Tm9uY2UoYWNjb3VudENsaWVudCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmZvQ2FsbHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZm9ybWF0dGVkQ2FsbHMgPSBpbmZvQ2FsbHMubWFwKChjYWxsKSA9PiAoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvOiBjYWxsLnRvLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IGNhbGwuZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogY2FsbC52YWx1ZSA/PyAwbixcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuaW5mbygnW2NyZWF0ZUFnZW50V2l0aFNtYXJ0QWNjb3VudE93bmVyVXNpbmdQcml2YXRlS2V5XSBTdWJtaXR0aW5nIEwxIEVOUyBtZXRhZGF0YSBjYWxscycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgc2VuZFVzZXJPcFdpdGhUaW1lb3V0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBidW5kbGVyVXJsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYWluLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjY291bnRDbGllbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbHM6IGZvcm1hdHRlZENhbGxzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vbmNlOiBuZXh0Tm9uY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbmV4dE5vbmNlID09PSAnYmlnaW50Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHROb25jZSArPSAxbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5pbmZvKCdbY3JlYXRlQWdlbnRXaXRoU21hcnRBY2NvdW50T3duZXJVc2luZ1ByaXZhdGVLZXldIFJ1bm5pbmcgTDIgRU5TIHNldHVwIHZpYSBhZ2VudCBhY2NvdW50Jyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgY2FsbHM6IGFkZENhbGxzIH0gPSBhd2FpdCBlbnNDbGllbnQucHJlcGFyZUFkZEFnZW50TmFtZVRvT3JnQ2FsbHMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgb3JnTmFtZTogcGFyYW1zLmVuc09wdGlvbnMub3JnTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFnZW50TmFtZTogcGFyYW1zLmFnZW50TmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFnZW50QWRkcmVzczogcGFyYW1zLmFnZW50QWNjb3VudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFnZW50VXJsOiBwYXJhbXMuYWdlbnRVcmwgfHwgJycsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBsZXQgbmV4dE5vbmNlID0gYXdhaXQgZ2V0QWNjb3VudE5vbmNlKGFjY291bnRDbGllbnQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWRkQ2FsbHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZm9ybWF0dGVkQWRkQ2FsbHMgPSBhZGRDYWxscy5tYXAoKGNhbGwpID0+ICh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG86IGNhbGwudG8sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogY2FsbC5kYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiAndmFsdWUnIGluIGNhbGwgJiYgdHlwZW9mIGNhbGwudmFsdWUgPT09ICdiaWdpbnQnID8gY2FsbC52YWx1ZSA6IDBuLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5pbmZvKCdbY3JlYXRlQWdlbnRXaXRoU21hcnRBY2NvdW50T3duZXJVc2luZ1ByaXZhdGVLZXldIFN1Ym1pdHRpbmcgTDIgRU5TIHN1YmRvbWFpbiByZWdpc3RyYXRpb24nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHNlbmRVc2VyT3BXaXRoVGltZW91dCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVuZGxlclVybCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFpbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY2NvdW50Q2xpZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxzOiBmb3JtYXR0ZWRBZGRDYWxscyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub25jZTogbmV4dE5vbmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG5leHROb25jZSA9PT0gJ2JpZ2ludCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0Tm9uY2UgKz0gMW47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBjYWxsczogaW5mb0NhbGxzIH0gPSBhd2FpdCBlbnNDbGllbnQucHJlcGFyZUFkZEFnZW50SW5mb0NhbGxzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9yZ05hbWU6IHBhcmFtcy5lbnNPcHRpb25zLm9yZ05hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBhZ2VudE5hbWU6IHBhcmFtcy5hZ2VudE5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBhZ2VudEFkZHJlc3M6IHBhcmFtcy5hZ2VudEFjY291bnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBhZ2VudFVybDogcGFyYW1zLmFnZW50VXJsIHx8ICcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWdlbnREZXNjcmlwdGlvbjogcGFyYW1zLmRlc2NyaXB0aW9uLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluZm9DYWxscy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBmb3JtYXR0ZWRJbmZvQ2FsbHMgPSBpbmZvQ2FsbHMubWFwKChjYWxsKSA9PiAoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvOiBjYWxsLnRvLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IGNhbGwuZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogY2FsbC52YWx1ZSA/PyAwbixcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuaW5mbygnW2NyZWF0ZUFnZW50V2l0aFNtYXJ0QWNjb3VudE93bmVyVXNpbmdQcml2YXRlS2V5XSBTdWJtaXR0aW5nIEwyIEVOUyBtZXRhZGF0YSBjYWxscycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgc2VuZFVzZXJPcFdpdGhUaW1lb3V0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBidW5kbGVyVXJsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYWluLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjY291bnRDbGllbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbHM6IGZvcm1hdHRlZEluZm9DYWxscyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub25jZTogbmV4dE5vbmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG5leHROb25jZSA9PT0gJ2JpZ2ludCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0Tm9uY2UgKz0gMW47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZW5zRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1tjcmVhdGVBZ2VudFdpdGhTbWFydEFjY291bnRPd25lclVzaW5nUHJpdmF0ZUtleV0gRU5TIHNldHVwIGZhaWxlZDonLCBlbnNFcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgdHhIYXNoOiB1c2VyT3BlcmF0aW9uSGFzaCwgYWdlbnRJZCB9O1xuICAgIH1cbiAgICBhc3luYyBleHRyYWN0QWdlbnRJZEZyb21SZWNlaXB0KHJlY2VpcHQsIGNoYWluSWQgPSAxMTE1NTExMSkge1xuICAgICAgICBpZiAoIXJlY2VpcHQpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlkZW50aXR5UmVnaXN0cnkgPSByZXF1aXJlQ2hhaW5FbnZWYXIoJ0FHRU5USUNfVFJVU1RfSURFTlRJVFlfUkVHSVNUUlknLCBjaGFpbklkKTtcbiAgICAgICAgY29uc3QgaWRlbnRpdHlSZWdpc3RyeUhleCA9IGlkZW50aXR5UmVnaXN0cnkuc3RhcnRzV2l0aCgnMHgnKVxuICAgICAgICAgICAgPyBpZGVudGl0eVJlZ2lzdHJ5XG4gICAgICAgICAgICA6IGAweCR7aWRlbnRpdHlSZWdpc3RyeX1gO1xuICAgICAgICBjb25zdCBjaGFpbiA9IGdldENoYWluQnlJZChjaGFpbklkKTtcbiAgICAgICAgY29uc3QgYWlJZGVudGl0eUNsaWVudCA9IG5ldyBBSUFnZW50SWRlbnRpdHlDbGllbnQoe1xuICAgICAgICAgICAgYWNjb3VudFByb3ZpZGVyOiB7XG4gICAgICAgICAgICAgICAgY2hhaW5JZDogYXN5bmMgKCkgPT4gY2hhaW4uaWQsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaWRlbnRpdHlSZWdpc3RyeUFkZHJlc3M6IGlkZW50aXR5UmVnaXN0cnlIZXgsXG4gICAgICAgIH0pO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgYWdlbnRJZCA9IGFpSWRlbnRpdHlDbGllbnQuZXh0cmFjdEFnZW50SWRGcm9tUmVjZWlwdFB1YmxpYyhyZWNlaXB0KTtcbiAgICAgICAgICAgIHJldHVybiBhZ2VudElkID8gYWdlbnRJZC50b1N0cmluZygpIDogbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignZXh0cmFjdEFnZW50SWRGcm9tUmVjZWlwdCBmYWlsZWQ6JywgZXJyb3IpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgc2VhcmNoQWdlbnRzKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VhcmNoQWdlbnRzKHsgcXVlcnk6IG9wdGlvbnMgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGlzY292ZXJ5Q2xpZW50ID0gYXdhaXQgZ2V0RGlzY292ZXJ5Q2xpZW50KCk7XG4gICAgICAgIGNvbnN0IGFkdmFuY2VkRGlzY292ZXJ5Q2xpZW50ID0gZGlzY292ZXJ5Q2xpZW50O1xuICAgICAgICBjb25zdCByZXF1ZXN0ZWRQYWdlID0gdHlwZW9mIG9wdGlvbnM/LnBhZ2UgPT09ICdudW1iZXInICYmIE51bWJlci5pc0Zpbml0ZShvcHRpb25zLnBhZ2UpID8gb3B0aW9ucy5wYWdlIDogMTtcbiAgICAgICAgY29uc3QgcmF3UGFnZVNpemUgPSB0eXBlb2Ygb3B0aW9ucz8ucGFnZVNpemUgPT09ICdudW1iZXInICYmIG9wdGlvbnMucGFnZVNpemUgPiAwXG4gICAgICAgICAgICA/IG9wdGlvbnMucGFnZVNpemVcbiAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBoYXNRdWVyeSA9IHR5cGVvZiBvcHRpb25zPy5xdWVyeSA9PT0gJ3N0cmluZycgJiYgb3B0aW9ucy5xdWVyeS50cmltKCkubGVuZ3RoID4gMDtcbiAgICAgICAgY29uc3Qgd2hlcmUgPSB0aGlzLmJ1aWxkQWdlbnRXaGVyZUlucHV0KG9wdGlvbnM/LnBhcmFtcyk7XG4gICAgICAgIC8vIEFsd2F5cyBlbnN1cmUgd2UgaGF2ZSBhIHBhZ2VTaXplIHdoZW4gcGVyZm9ybWluZyBkaXNjb3Zlcnkgc28gdGhhdFxuICAgICAgICAvLyBhZHZhbmNlZCBzZWFyY2ggaXMgdXNlZCBjb25zaXN0ZW50bHkgKGV2ZW4gd2hlbiBubyBmaWx0ZXJzIGFyZSBwcm92aWRlZCkuXG4gICAgICAgIGNvbnN0IGVmZmVjdGl2ZVBhZ2VTaXplID0gcmF3UGFnZVNpemUgPz8gNTA7XG4gICAgICAgIGNvbnN0IGhhc0FkdmFuY2VkR3JhcGggPSB0eXBlb2YgYWR2YW5jZWREaXNjb3ZlcnlDbGllbnQuc2VhcmNoQWdlbnRzR3JhcGggPT09ICdmdW5jdGlvbic7XG4gICAgICAgIGNvbnN0IGhhc0FkdmFuY2VkTGVnYWN5ID0gdHlwZW9mIGFkdmFuY2VkRGlzY292ZXJ5Q2xpZW50LnNlYXJjaEFnZW50c0FkdmFuY2VkID09PSAnZnVuY3Rpb24nO1xuICAgICAgICAvLyBQcmVmZXIgdGhlIGFkdmFuY2VkIGRpc2NvdmVyeSBBUElzIChHcmFwaC9hZHZhbmNlZCkgd2hlbmV2ZXIgYXZhaWxhYmxlIHNvXG4gICAgICAgIC8vIHRoYXQgd2UgZ2V0IGFuIGFjY3VyYXRlIHRvdGFsIGNvdW50IGFuZCBjb25zaXN0ZW50IHBhZ2luYXRpb24sIGV2ZW4gd2hlblxuICAgICAgICAvLyBubyBmaWx0ZXJzIGFyZSBzdXBwbGllZC5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gSU1QT1JUQU5UOlxuICAgICAgICAvLyAtIFRoZSBHcmFwaC1iYXNlZCBBUEkgKGBzZWFyY2hBZ2VudHNHcmFwaGApIGN1cnJlbnRseSBvbmx5IHN1cHBvcnRzIHN0cnVjdHVyZWRcbiAgICAgICAgLy8gICBmaWx0ZXJzIHZpYSBgd2hlcmVgIGFuZCBkb2VzIE5PVCB0YWtlIHRoZSBmcmVlLXRleHQgYHF1ZXJ5YCBzdHJpbmcuXG4gICAgICAgIC8vIC0gVGhlIGxlZ2FjeSBhZHZhbmNlZCBBUEkgKGBzZWFyY2hBZ2VudHNBZHZhbmNlZGApIGlzIHRoZSBvbmUgdGhhdCB3aXJlcyB0aGVcbiAgICAgICAgLy8gICBnZW5lcmFsIHNlYXJjaCBxdWVyeSBpbnRvIHRoZSBkaXNjb3ZlcnkgYmFja2VuZCAoYW5kIGNhbiBhbHNvIHRha2UgcGFyYW1zKS5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gVG8gZW5zdXJlIHRoZSBnZW5lcmFsIHNlYXJjaCBib3ggYWN0dWFsbHkgZmlsdGVycyByZXN1bHRzLCB3ZSByb3V0ZTpcbiAgICAgICAgLy8gICAtIHJlcXVlc3RzIFdJVEggYSBxdWVyeSBzdHJpbmcgdGhyb3VnaCBgc2VhcmNoQWdlbnRzQWR2YW5jZWRgIHdoZW4gYXZhaWxhYmxlXG4gICAgICAgIC8vICAgLSByZXF1ZXN0cyBXSVRIT1VUIGEgcXVlcnkgc3RyaW5nIChmaWx0ZXJzIC8gcGFnaW5hdGlvbiBvbmx5KSB0aHJvdWdoXG4gICAgICAgIC8vICAgICBgc2VhcmNoQWdlbnRzR3JhcGhgIHdoZW4gYXZhaWxhYmxlXG4gICAgICAgIGlmIChlZmZlY3RpdmVQYWdlU2l6ZSAmJiAoaGFzQWR2YW5jZWRHcmFwaCB8fCBoYXNBZHZhbmNlZExlZ2FjeSkpIHtcbiAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IChNYXRoLm1heChyZXF1ZXN0ZWRQYWdlLCAxKSAtIDEpICogZWZmZWN0aXZlUGFnZVNpemU7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIC8vIElmIHdlIGhhdmUgYSB0ZXh0IHF1ZXJ5IGFuZCB0aGUgbGVnYWN5IGFkdmFuY2VkIEFQSSBpcyBhdmFpbGFibGUsXG4gICAgICAgICAgICAgICAgLy8gdXNlIGl0IHNvIHRoZSBxdWVyeSBzdHJpbmcgaXMgaG9ub3JlZCBieSB0aGUgZGlzY292ZXJ5IHNlcnZpY2UuXG4gICAgICAgICAgICAgICAgaWYgKGhhc1F1ZXJ5ICYmIGhhc0FkdmFuY2VkTGVnYWN5KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFkdmFuY2VkID0gYXdhaXQgYWR2YW5jZWREaXNjb3ZlcnlDbGllbnQuc2VhcmNoQWdlbnRzQWR2YW5jZWQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnk6IG9wdGlvbnM/LnF1ZXJ5LFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiBvcHRpb25zPy5wYXJhbXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW1pdDogZWZmZWN0aXZlUGFnZVNpemUsXG4gICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICBvcmRlckJ5OiBvcHRpb25zPy5vcmRlckJ5LFxuICAgICAgICAgICAgICAgICAgICAgICAgb3JkZXJEaXJlY3Rpb246IG9wdGlvbnM/Lm9yZGVyRGlyZWN0aW9uLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFkdmFuY2VkICYmIEFycmF5LmlzQXJyYXkoYWR2YW5jZWQuYWdlbnRzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdG90YWwgPSB0eXBlb2YgYWR2YW5jZWQudG90YWwgPT09ICdudW1iZXInICYmIGFkdmFuY2VkLnRvdGFsID49IDBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGFkdmFuY2VkLnRvdGFsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBhZHZhbmNlZC5hZ2VudHMubGVuZ3RoICsgb2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdG90YWxQYWdlcyA9IE1hdGgubWF4KDEsIE1hdGguY2VpbCh0b3RhbCAvIGVmZmVjdGl2ZVBhZ2VTaXplKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzYWZlUGFnZSA9IE1hdGgubWluKE1hdGgubWF4KHJlcXVlc3RlZFBhZ2UsIDEpLCB0b3RhbFBhZ2VzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGFnZW50SW5zdGFuY2VzID0gYWR2YW5jZWQuYWdlbnRzLm1hcCgoZGF0YSkgPT4gbmV3IEFnZW50KGRhdGEsIHRoaXMuY2xpZW50KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFnZW50czogYWdlbnRJbnN0YW5jZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG90YWwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFnZTogc2FmZVBhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFnZVNpemU6IGVmZmVjdGl2ZVBhZ2VTaXplLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvdGFsUGFnZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGhhc0FkdmFuY2VkR3JhcGgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYWR2YW5jZWQgPSBhd2FpdCBhZHZhbmNlZERpc2NvdmVyeUNsaWVudC5zZWFyY2hBZ2VudHNHcmFwaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGVyZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpcnN0OiBlZmZlY3RpdmVQYWdlU2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNraXA6IG9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9yZGVyQnk6IG9wdGlvbnM/Lm9yZGVyQnksXG4gICAgICAgICAgICAgICAgICAgICAgICBvcmRlckRpcmVjdGlvbjogb3B0aW9ucz8ub3JkZXJEaXJlY3Rpb24sXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWR2YW5jZWQgJiYgQXJyYXkuaXNBcnJheShhZHZhbmNlZC5hZ2VudHMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0b3RhbCA9IHR5cGVvZiBhZHZhbmNlZC50b3RhbCA9PT0gJ251bWJlcicgJiYgYWR2YW5jZWQudG90YWwgPj0gMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gYWR2YW5jZWQudG90YWxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGFkdmFuY2VkLmFnZW50cy5sZW5ndGggKyBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0b3RhbFBhZ2VzID0gTWF0aC5tYXgoMSwgTWF0aC5jZWlsKHRvdGFsIC8gZWZmZWN0aXZlUGFnZVNpemUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNhZmVQYWdlID0gTWF0aC5taW4oTWF0aC5tYXgocmVxdWVzdGVkUGFnZSwgMSksIHRvdGFsUGFnZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYWdlbnRJbnN0YW5jZXMgPSBhZHZhbmNlZC5hZ2VudHMubWFwKChkYXRhKSA9PiBuZXcgQWdlbnQoZGF0YSwgdGhpcy5jbGllbnQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWdlbnRzOiBhZ2VudEluc3RhbmNlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3RhbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYWdlOiBzYWZlUGFnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYWdlU2l6ZTogZWZmZWN0aXZlUGFnZVNpemUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG90YWxQYWdlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaGFzQWR2YW5jZWRMZWdhY3kpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRmFsbGJhY2s6IG5vIEdyYXBoIEFQSSwgYnV0IGxlZ2FjeSBhZHZhbmNlZCBpcyBhdmFpbGFibGUgKHdpdGggb3JcbiAgICAgICAgICAgICAgICAgICAgLy8gd2l0aG91dCBhIHF1ZXJ5IHN0cmluZykuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFkdmFuY2VkID0gYXdhaXQgYWR2YW5jZWREaXNjb3ZlcnlDbGllbnQuc2VhcmNoQWdlbnRzQWR2YW5jZWQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnk6IG9wdGlvbnM/LnF1ZXJ5LFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiBvcHRpb25zPy5wYXJhbXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW1pdDogZWZmZWN0aXZlUGFnZVNpemUsXG4gICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICBvcmRlckJ5OiBvcHRpb25zPy5vcmRlckJ5LFxuICAgICAgICAgICAgICAgICAgICAgICAgb3JkZXJEaXJlY3Rpb246IG9wdGlvbnM/Lm9yZGVyRGlyZWN0aW9uLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFkdmFuY2VkICYmIEFycmF5LmlzQXJyYXkoYWR2YW5jZWQuYWdlbnRzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdG90YWwgPSB0eXBlb2YgYWR2YW5jZWQudG90YWwgPT09ICdudW1iZXInICYmIGFkdmFuY2VkLnRvdGFsID49IDBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGFkdmFuY2VkLnRvdGFsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBhZHZhbmNlZC5hZ2VudHMubGVuZ3RoICsgb2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdG90YWxQYWdlcyA9IE1hdGgubWF4KDEsIE1hdGguY2VpbCh0b3RhbCAvIGVmZmVjdGl2ZVBhZ2VTaXplKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzYWZlUGFnZSA9IE1hdGgubWluKE1hdGgubWF4KHJlcXVlc3RlZFBhZ2UsIDEpLCB0b3RhbFBhZ2VzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGFnZW50SW5zdGFuY2VzID0gYWR2YW5jZWQuYWdlbnRzLm1hcCgoZGF0YSkgPT4gbmV3IEFnZW50KGRhdGEsIHRoaXMuY2xpZW50KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFnZW50czogYWdlbnRJbnN0YW5jZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG90YWwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFnZTogc2FmZVBhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFnZVNpemU6IGVmZmVjdGl2ZVBhZ2VTaXplLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvdGFsUGFnZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdbQWdlbnRzQVBJLnNlYXJjaEFnZW50c10gQWR2YW5jZWQgc2VhcmNoIGZhaWxlZCwgcmV0dXJuaW5nIGVtcHR5IHJlc3VsdHMuJywgZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgYWR2YW5jZWQgc2VhcmNoIGZhaWxzIG9yIHJldHVybnMgbnVsbCwgZmFsbCBiYWNrIHRvIHRoZSBkZWZhdWx0XG4gICAgICAgICAgICAvLyBwYWdpbmF0aW9uIGxvZ2ljIGJlbG93IHdoaWNoIHVzZXMgbGlzdEFnZW50cy5cbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBubyBmaWx0ZXJzLCB1c2UgbGlzdEFnZW50cyB0byBnZXQgZGVmYXVsdCBsaXN0IGZyb20gR3JhcGhRTCBlbmRwb2ludC5cbiAgICAgICAgLy8gRGVmYXVsdCB0byA1MCBhZ2VudHMgaWYgbm8gcGFnZVNpemUgc3BlY2lmaWVkLlxuICAgICAgICBjb25zdCBkZWZhdWx0UGFnZVNpemUgPSBlZmZlY3RpdmVQYWdlU2l6ZSA/PyA1MDtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gKE1hdGgubWF4KHJlcXVlc3RlZFBhZ2UsIDEpIC0gMSkgKiBkZWZhdWx0UGFnZVNpemU7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBhbGxBZ2VudHMgPSBhd2FpdCBkaXNjb3ZlcnlDbGllbnQubGlzdEFnZW50cyhkZWZhdWx0UGFnZVNpemUsIG9mZnNldCk7XG4gICAgICAgICAgICAvLyBGb3IgbGlzdEFnZW50cywgd2UgZG9uJ3Qga25vdyB0aGUgdG90YWwsIHNvIHdlIGVzdGltYXRlIGJhc2VkIG9uIHJldHVybmVkIHJlc3VsdHNcbiAgICAgICAgICAgIC8vIElmIHdlIGdvdCBhIGZ1bGwgcGFnZSwgdGhlcmUgbWlnaHQgYmUgbW9yZTsgaWYgbGVzcywgd2UncmUgYXQgdGhlIGVuZFxuICAgICAgICAgICAgY29uc3QgaGFzTW9yZSA9IGFsbEFnZW50cy5sZW5ndGggPT09IGRlZmF1bHRQYWdlU2l6ZTtcbiAgICAgICAgICAgIGNvbnN0IGVzdGltYXRlZFRvdGFsID0gaGFzTW9yZSA/IGFsbEFnZW50cy5sZW5ndGggKyBvZmZzZXQgKyAxIDogYWxsQWdlbnRzLmxlbmd0aCArIG9mZnNldDtcbiAgICAgICAgICAgIGNvbnN0IHRvdGFsUGFnZXMgPSBNYXRoLm1heCgxLCBNYXRoLmNlaWwoZXN0aW1hdGVkVG90YWwgLyBkZWZhdWx0UGFnZVNpemUpKTtcbiAgICAgICAgICAgIGNvbnN0IGFnZW50SW5zdGFuY2VzID0gYWxsQWdlbnRzLm1hcCgoZGF0YSkgPT4gbmV3IEFnZW50KGRhdGEsIHRoaXMuY2xpZW50KSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGFnZW50czogYWdlbnRJbnN0YW5jZXMsXG4gICAgICAgICAgICAgICAgdG90YWw6IGVzdGltYXRlZFRvdGFsLFxuICAgICAgICAgICAgICAgIHBhZ2U6IHJlcXVlc3RlZFBhZ2UsXG4gICAgICAgICAgICAgICAgcGFnZVNpemU6IGRlZmF1bHRQYWdlU2l6ZSxcbiAgICAgICAgICAgICAgICB0b3RhbFBhZ2VzLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignW0FnZW50c0FQSS5zZWFyY2hBZ2VudHNdIGxpc3RBZ2VudHMgZmFpbGVkLCByZXR1cm5pbmcgZW1wdHkgcmVzdWx0cy4nLCBlcnJvcik7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGFnZW50czogW10sXG4gICAgICAgICAgICAgICAgdG90YWw6IDAsXG4gICAgICAgICAgICAgICAgcGFnZTogcmVxdWVzdGVkUGFnZSA/PyAxLFxuICAgICAgICAgICAgICAgIHBhZ2VTaXplOiBkZWZhdWx0UGFnZVNpemUsXG4gICAgICAgICAgICAgICAgdG90YWxQYWdlczogMCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogTWFwIGhpZ2gtbGV2ZWwgRGlzY292ZXJQYXJhbXMgdG8gdGhlIGluZGV4ZXIncyBBZ2VudFdoZXJlSW5wdXQgc2hhcGUuXG4gICAgICogVGhpcyBpcyB1c2VkIGZvciB0aGUgc2VhcmNoQWdlbnRzR3JhcGgod2hlcmU6IEFnZW50V2hlcmVJbnB1dCwgLi4uKSBBUEkuXG4gICAgICovXG4gICAgYnVpbGRBZ2VudFdoZXJlSW5wdXQocGFyYW1zKSB7XG4gICAgICAgIGlmICghcGFyYW1zKVxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3Qgd2hlcmUgPSB7fTtcbiAgICAgICAgaWYgKHBhcmFtcy5jaGFpbnMgJiYgcGFyYW1zLmNoYWlucyAhPT0gJ2FsbCcgJiYgcGFyYW1zLmNoYWlucy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB3aGVyZS5jaGFpbklkX2luID0gcGFyYW1zLmNoYWlucztcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFyYW1zLmFnZW50TmFtZT8udHJpbSgpKSB7XG4gICAgICAgICAgICB3aGVyZS5hZ2VudE5hbWVfY29udGFpbnNfbm9jYXNlID0gcGFyYW1zLmFnZW50TmFtZS50cmltKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcmFtcy5hZ2VudENhdGVnb3J5Py50cmltKCkpIHtcbiAgICAgICAgICAgIC8vIEJlc3QtZWZmb3J0OyBpbmRleGVyIHNjaGVtYXMgZ2VuZXJhbGx5IHN1cHBvcnQgKl9jb250YWluc19ub2Nhc2UgZm9yIHN0cmluZyBmaWVsZHMuXG4gICAgICAgICAgICB3aGVyZS5hZ2VudENhdGVnb3J5X2NvbnRhaW5zX25vY2FzZSA9IHBhcmFtcy5hZ2VudENhdGVnb3J5LnRyaW0oKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFyYW1zLmFnZW50SWQ/LnRyaW0oKSkge1xuICAgICAgICAgICAgLy8gRXhhY3QgbWF0Y2ggb24gYWdlbnRJZDsgeW91IGNvdWxkIGFsc28gZXhwb3NlIGFnZW50SWRfaW4gaWYgeW91IGxhdGVyXG4gICAgICAgICAgICAvLyBzdXBwb3J0IG11bHRpcGxlIElEcy5cbiAgICAgICAgICAgIHdoZXJlLmFnZW50SWQgPSBwYXJhbXMuYWdlbnRJZC50cmltKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcmFtcy5kZXNjcmlwdGlvbj8udHJpbSgpKSB7XG4gICAgICAgICAgICB3aGVyZS5kZXNjcmlwdGlvbl9jb250YWluc19ub2Nhc2UgPSBwYXJhbXMuZGVzY3JpcHRpb24udHJpbSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJhbXMuYWNjb3VudHMgJiYgcGFyYW1zLmFjY291bnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIC8vIE5ldyBkaXNjb3Zlcnkgc2NoZW1hOiBvd25lZC1ieS1FT0EgZmlsdGVyIGlzIGBlb2FBZ2VudElkZW50aXR5T3duZXJBY2NvdW50YC5cbiAgICAgICAgICAgIHdoZXJlLmVvYUFnZW50SWRlbnRpdHlPd25lckFjY291bnRfaW4gPSBwYXJhbXMuYWNjb3VudHMubWFwKChhZGRyKSA9PiBhZGRyLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJhbXMub3BlcmF0b3JzICYmIHBhcmFtcy5vcGVyYXRvcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgd2hlcmUub3BlcmF0b3JfaW4gPSBwYXJhbXMub3BlcmF0b3JzLm1hcCgoYWRkcikgPT4gYWRkci50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHBhcmFtcy5tY3AgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgd2hlcmUubWNwID0gcGFyYW1zLm1jcDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHBhcmFtcy5hMmEgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgaWYgKHBhcmFtcy5hMmEpIHtcbiAgICAgICAgICAgICAgICB3aGVyZS5oYXNBMmFFbmRwb2ludCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcmFtcy5kaWQ/LnRyaW0oKSkge1xuICAgICAgICAgICAgd2hlcmUuZGlkX2NvbnRhaW5zX25vY2FzZSA9IHBhcmFtcy5kaWQudHJpbSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJhbXMuYWdlbnRBY2NvdW50KSB7XG4gICAgICAgICAgICAvLyBOZXcgZGlzY292ZXJ5IHNjaGVtYTogZmlsdGVyIGJ5IGFnZW50IGFjY291bnQgRU9BIHZpYSBgZW9hQWdlbnRBY2NvdW50YC5cbiAgICAgICAgICAgIHdoZXJlLmVvYUFnZW50QWNjb3VudCA9IHBhcmFtcy5hZ2VudEFjY291bnQudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFyYW1zLnN1cHBvcnRlZFRydXN0ICYmIHBhcmFtcy5zdXBwb3J0ZWRUcnVzdC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB3aGVyZS5zdXBwb3J0ZWRUcnVzdF9pbiA9IHBhcmFtcy5zdXBwb3J0ZWRUcnVzdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFyYW1zLmEyYVNraWxscyAmJiBwYXJhbXMuYTJhU2tpbGxzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHdoZXJlLmEyYVNraWxsc19pbiA9IHBhcmFtcy5hMmFTa2lsbHM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcmFtcy5tY3BUb29scyAmJiBwYXJhbXMubWNwVG9vbHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgd2hlcmUubWNwVG9vbHNfaW4gPSBwYXJhbXMubWNwVG9vbHM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcmFtcy5tY3BQcm9tcHRzICYmIHBhcmFtcy5tY3BQcm9tcHRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHdoZXJlLm1jcFByb21wdHNfaW4gPSBwYXJhbXMubWNwUHJvbXB0cztcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFyYW1zLm1jcFJlc291cmNlcyAmJiBwYXJhbXMubWNwUmVzb3VyY2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHdoZXJlLm1jcFJlc291cmNlc19pbiA9IHBhcmFtcy5tY3BSZXNvdXJjZXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBwYXJhbXMuYWN0aXZlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIHdoZXJlLmFjdGl2ZSA9IHBhcmFtcy5hY3RpdmU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBwYXJhbXMueDQwMnN1cHBvcnQgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgd2hlcmUueDQwMnN1cHBvcnQgPSBwYXJhbXMueDQwMnN1cHBvcnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBwYXJhbXMubWluRmVlZGJhY2tDb3VudCA9PT0gJ251bWJlcicgJiYgcGFyYW1zLm1pbkZlZWRiYWNrQ291bnQgPiAwKSB7XG4gICAgICAgICAgICB3aGVyZS5mZWVkYmFja0NvdW50X2d0ZSA9IHBhcmFtcy5taW5GZWVkYmFja0NvdW50O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgcGFyYW1zLm1pblZhbGlkYXRpb25Db21wbGV0ZWRDb3VudCA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgICAgIHBhcmFtcy5taW5WYWxpZGF0aW9uQ29tcGxldGVkQ291bnQgPiAwKSB7XG4gICAgICAgICAgICB3aGVyZS52YWxpZGF0aW9uQ29tcGxldGVkQ291bnRfZ3RlID0gcGFyYW1zLm1pblZhbGlkYXRpb25Db21wbGV0ZWRDb3VudDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHBhcmFtcy5taW5GZWVkYmFja0F2ZXJhZ2VTY29yZSA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgICAgIHBhcmFtcy5taW5GZWVkYmFja0F2ZXJhZ2VTY29yZSA+IDApIHtcbiAgICAgICAgICAgIHdoZXJlLmZlZWRiYWNrQXZlcmFnZVNjb3JlX2d0ZSA9IHBhcmFtcy5taW5GZWVkYmFja0F2ZXJhZ2VTY29yZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHBhcmFtcy5taW5BdGlPdmVyYWxsU2NvcmUgPT09ICdudW1iZXInICYmIHBhcmFtcy5taW5BdGlPdmVyYWxsU2NvcmUgPiAwKSB7XG4gICAgICAgICAgICB3aGVyZS5hdGlPdmVyYWxsU2NvcmVfZ3RlID0gcGFyYW1zLm1pbkF0aU92ZXJhbGxTY29yZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHBhcmFtcy5hdGlDb21wdXRlZFdpdGhpbkRheXMgPT09ICdudW1iZXInICYmIHBhcmFtcy5hdGlDb21wdXRlZFdpdGhpbkRheXMgPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBub3dTZWNvbmRzID0gTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMTAwMCk7XG4gICAgICAgICAgICBjb25zdCB3aW5kb3dTZWNvbmRzID0gTWF0aC5mbG9vcihwYXJhbXMuYXRpQ29tcHV0ZWRXaXRoaW5EYXlzICogMjQgKiA2MCAqIDYwKTtcbiAgICAgICAgICAgIGNvbnN0IHRocmVzaG9sZCA9IG5vd1NlY29uZHMgLSB3aW5kb3dTZWNvbmRzO1xuICAgICAgICAgICAgaWYgKHRocmVzaG9sZCA+IDApIHtcbiAgICAgICAgICAgICAgICB3aGVyZS5hdGlDb21wdXRlZEF0X2d0ZSA9IHRocmVzaG9sZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHBhcmFtcy5jcmVhdGVkV2l0aGluRGF5cyA9PT0gJ251bWJlcicgJiYgcGFyYW1zLmNyZWF0ZWRXaXRoaW5EYXlzID4gMCkge1xuICAgICAgICAgICAgY29uc3Qgbm93U2Vjb25kcyA9IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDEwMDApO1xuICAgICAgICAgICAgY29uc3Qgd2luZG93U2Vjb25kcyA9IE1hdGguZmxvb3IocGFyYW1zLmNyZWF0ZWRXaXRoaW5EYXlzICogMjQgKiA2MCAqIDYwKTtcbiAgICAgICAgICAgIGNvbnN0IHRocmVzaG9sZCA9IG5vd1NlY29uZHMgLSB3aW5kb3dTZWNvbmRzO1xuICAgICAgICAgICAgaWYgKHRocmVzaG9sZCA+IDApIHtcbiAgICAgICAgICAgICAgICB3aGVyZS5jcmVhdGVkQXRUaW1lX2d0ZSA9IHRocmVzaG9sZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMod2hlcmUpLmxlbmd0aCA+IDAgPyB3aGVyZSA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgYXBwbHlTZWFyY2hBbmRQYWdpbmF0aW9uKGFnZW50RGF0YSwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBub3JtYWxpemVkUXVlcnkgPSBvcHRpb25zPy5xdWVyeSAmJiB0eXBlb2Ygb3B0aW9ucy5xdWVyeSA9PT0gJ3N0cmluZydcbiAgICAgICAgICAgID8gb3B0aW9ucy5xdWVyeS50cmltKCkudG9Mb3dlckNhc2UoKVxuICAgICAgICAgICAgOiAnJztcbiAgICAgICAgY29uc3QgcGFyYW1zID0gb3B0aW9ucz8ucGFyYW1zO1xuICAgICAgICBjb25zdCBzb3J0ZWRBZ2VudHMgPSAoKCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgb3JkZXJCeSA9IG9wdGlvbnM/Lm9yZGVyQnk/LnRyaW0oKTtcbiAgICAgICAgICAgIGNvbnN0IG9yZGVyRGlyZWN0aW9uID0gKG9wdGlvbnM/Lm9yZGVyRGlyZWN0aW9uID8/ICdBU0MnKS50b1VwcGVyQ2FzZSgpID09PSAnREVTQycgPyAnREVTQycgOiAnQVNDJztcbiAgICAgICAgICAgIGNvbnN0IGxpc3QgPSBbLi4uYWdlbnREYXRhXTtcbiAgICAgICAgICAgIGlmIChvcmRlckJ5ID09PSAnYWdlbnROYW1lJykge1xuICAgICAgICAgICAgICAgIGxpc3Quc29ydCgoYSwgYikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhTmFtZSA9IChhLmFnZW50TmFtZSA/PyAnJykudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYk5hbWUgPSAoYi5hZ2VudE5hbWUgPz8gJycpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvcmRlckRpcmVjdGlvbiA9PT0gJ0FTQycgPyBhTmFtZS5sb2NhbGVDb21wYXJlKGJOYW1lKSA6IGJOYW1lLmxvY2FsZUNvbXBhcmUoYU5hbWUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBsaXN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRGVmYXVsdDogbmV3ZXN0IGZpcnN0IGJ5IGFnZW50SWQgZGVzYyAoYmFjay1jb21wYXQpXG4gICAgICAgICAgICBsaXN0LnNvcnQoKGEsIGIpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBpZEEgPSB0eXBlb2YgYS5hZ2VudElkID09PSAnbnVtYmVyJyA/IGEuYWdlbnRJZCA6IE51bWJlcihhLmFnZW50SWQpIHx8IDA7XG4gICAgICAgICAgICAgICAgY29uc3QgaWRCID0gdHlwZW9mIGIuYWdlbnRJZCA9PT0gJ251bWJlcicgPyBiLmFnZW50SWQgOiBOdW1iZXIoYi5hZ2VudElkKSB8fCAwO1xuICAgICAgICAgICAgICAgIHJldHVybiBpZEIgLSBpZEE7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBsaXN0O1xuICAgICAgICB9KSgpO1xuICAgICAgICBjb25zdCBmaWx0ZXJlZEFnZW50cyA9IHNvcnRlZEFnZW50cy5maWx0ZXIoKGRhdGEpID0+IHtcbiAgICAgICAgICAgIGlmIChub3JtYWxpemVkUXVlcnkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBoYXlzdGFjayA9IFtcbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIGRhdGEuYWdlbnRJZCA9PT0gJ251bWJlcicgPyBkYXRhLmFnZW50SWQudG9TdHJpbmcoKSA6IGRhdGEuYWdlbnRJZCxcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5hZ2VudE5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGRhdGEuYWdlbnRBY2NvdW50LFxuICAgICAgICAgICAgICAgICAgICBkYXRhLmFnZW50SWRlbnRpdHlPd25lckFjY291bnQsXG4gICAgICAgICAgICAgICAgICAgIGRhdGEuZW9hQWdlbnRJZGVudGl0eU93bmVyQWNjb3VudCxcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5lb2FBZ2VudEFjY291bnQsXG4gICAgICAgICAgICAgICAgICAgIGRhdGEuZGVzY3JpcHRpb24sXG4gICAgICAgICAgICAgICAgICAgIGRhdGEudHlwZSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5hMmFFbmRwb2ludCxcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5hZ2VudFVyaSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5zdXBwb3J0ZWRUcnVzdCxcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5yYXdKc29uLFxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihCb29sZWFuKVxuICAgICAgICAgICAgICAgICAgICAuam9pbignICcpXG4gICAgICAgICAgICAgICAgICAgIC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIGlmICghaGF5c3RhY2suaW5jbHVkZXMobm9ybWFsaXplZFF1ZXJ5KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFwYXJhbXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1hdGNoZXNTZWFyY2hQYXJhbXMoZGF0YSwgcGFyYW1zKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHRvdGFsID0gZmlsdGVyZWRBZ2VudHMubGVuZ3RoO1xuICAgICAgICBjb25zdCBwYWdlU2l6ZSA9IHR5cGVvZiBvcHRpb25zPy5wYWdlU2l6ZSA9PT0gJ251bWJlcicgJiYgb3B0aW9ucy5wYWdlU2l6ZSA+IDBcbiAgICAgICAgICAgID8gb3B0aW9ucy5wYWdlU2l6ZVxuICAgICAgICAgICAgOiB0b3RhbCB8fCAxO1xuICAgICAgICBjb25zdCB0b3RhbFBhZ2VzID0gTWF0aC5tYXgoMSwgTWF0aC5jZWlsKHRvdGFsIC8gcGFnZVNpemUpKTtcbiAgICAgICAgY29uc3QgcmVxdWVzdGVkUGFnZSA9IHR5cGVvZiBvcHRpb25zPy5wYWdlID09PSAnbnVtYmVyJyAmJiBOdW1iZXIuaXNGaW5pdGUob3B0aW9ucy5wYWdlKSA/IG9wdGlvbnMucGFnZSA6IDE7XG4gICAgICAgIGNvbnN0IHNhZmVQYWdlID0gTWF0aC5taW4oTWF0aC5tYXgocmVxdWVzdGVkUGFnZSwgMSksIHRvdGFsUGFnZXMpO1xuICAgICAgICBjb25zdCBzdGFydEluZGV4ID0gKHNhZmVQYWdlIC0gMSkgKiBwYWdlU2l6ZTtcbiAgICAgICAgY29uc3QgZW5kSW5kZXggPSBzdGFydEluZGV4ICsgcGFnZVNpemU7XG4gICAgICAgIGNvbnN0IHBhZ2VBZ2VudHMgPSBmaWx0ZXJlZEFnZW50cy5zbGljZShzdGFydEluZGV4LCBlbmRJbmRleCk7XG4gICAgICAgIGNvbnN0IGFnZW50SW5zdGFuY2VzID0gcGFnZUFnZW50cy5tYXAoKGRhdGEpID0+IG5ldyBBZ2VudChkYXRhLCB0aGlzLmNsaWVudCkpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYWdlbnRzOiBhZ2VudEluc3RhbmNlcyxcbiAgICAgICAgICAgIHRvdGFsLFxuICAgICAgICAgICAgcGFnZTogc2FmZVBhZ2UsXG4gICAgICAgICAgICBwYWdlU2l6ZSxcbiAgICAgICAgICAgIHRvdGFsUGFnZXMsXG4gICAgICAgIH07XG4gICAgfVxuICAgIG1hdGNoZXNTZWFyY2hQYXJhbXMoYWdlbnQsIHBhcmFtcykge1xuICAgICAgICBjb25zdCBwYXJzZWRSYXcgPSB0eXBlb2YgYWdlbnQucmF3SnNvbiA9PT0gJ3N0cmluZydcbiAgICAgICAgICAgID8gc2FmZVBhcnNlSnNvbihhZ2VudC5yYXdKc29uKVxuICAgICAgICAgICAgOiBhZ2VudC5yYXdKc29uICYmIHR5cGVvZiBhZ2VudC5yYXdKc29uID09PSAnb2JqZWN0J1xuICAgICAgICAgICAgICAgID8gYWdlbnQucmF3SnNvblxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBtZXRhZGF0YSA9IHBhcnNlZFJhdyAmJiB0eXBlb2YgcGFyc2VkUmF3ID09PSAnb2JqZWN0J1xuICAgICAgICAgICAgPyBwYXJzZWRSYXdcbiAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICBpZiAocGFyYW1zLmNoYWlucyAmJiBwYXJhbXMuY2hhaW5zICE9PSAnYWxsJykge1xuICAgICAgICAgICAgY29uc3QgY2hhaW5JZCA9IHR5cGVvZiBhZ2VudC5jaGFpbklkID09PSAnbnVtYmVyJyA/IGFnZW50LmNoYWluSWQgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAoIWNoYWluSWQgfHwgIXBhcmFtcy5jaGFpbnMuaW5jbHVkZXMoY2hhaW5JZCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcmFtcy5hZ2VudE5hbWUpIHtcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBhZ2VudC5hZ2VudE5hbWUgPz8gJyc7XG4gICAgICAgICAgICBpZiAoIW5hbWUudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhwYXJhbXMuYWdlbnROYW1lLnRyaW0oKS50b0xvd2VyQ2FzZSgpKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocGFyYW1zLmFnZW50Q2F0ZWdvcnkpIHtcbiAgICAgICAgICAgIGNvbnN0IGNhdCA9IGFnZW50LmFnZW50Q2F0ZWdvcnkgPz8gJyc7XG4gICAgICAgICAgICBjb25zdCBjYXRTdHIgPSB0eXBlb2YgY2F0ID09PSAnc3RyaW5nJyA/IGNhdCA6IFN0cmluZyhjYXQgPz8gJycpO1xuICAgICAgICAgICAgaWYgKCFjYXRTdHIudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhwYXJhbXMuYWdlbnRDYXRlZ29yeS50cmltKCkudG9Mb3dlckNhc2UoKSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcmFtcy5kZXNjcmlwdGlvbikge1xuICAgICAgICAgICAgY29uc3QgZGVzY3JpcHRpb24gPSBhZ2VudC5kZXNjcmlwdGlvbiA/PyAnJztcbiAgICAgICAgICAgIGlmICghZGVzY3JpcHRpb24udG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhwYXJhbXMuZGVzY3JpcHRpb24udHJpbSgpLnRvTG93ZXJDYXNlKCkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJhbXMuYWNjb3VudHMgJiYgcGFyYW1zLmFjY291bnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IG93bmVyID0gYWdlbnQuZW9hQWdlbnRJZGVudGl0eU93bmVyQWNjb3VudD8udG9Mb3dlckNhc2U/LigpO1xuICAgICAgICAgICAgaWYgKCFvd25lciB8fFxuICAgICAgICAgICAgICAgICFwYXJhbXMuYWNjb3VudHMuc29tZSgoYWRkcikgPT4gYWRkci50b0xvd2VyQ2FzZSgpID09PSBvd25lcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcmFtcy5hZ2VudEFjY291bnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHdhbGxldCA9IGFnZW50LmVvYUFnZW50QWNjb3VudD8udG9Mb3dlckNhc2U/LigpO1xuICAgICAgICAgICAgaWYgKCF3YWxsZXQgfHwgd2FsbGV0ICE9PSBwYXJhbXMuYWdlbnRBY2NvdW50LnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcmFtcy5kaWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHJhd0RpZCA9IChtZXRhZGF0YSAmJiB0eXBlb2YgbWV0YWRhdGEuZGlkID09PSAnc3RyaW5nJyAmJiBtZXRhZGF0YS5kaWQpIHx8XG4gICAgICAgICAgICAgICAgKG1ldGFkYXRhPy5pZGVudGl0eSAmJiB0eXBlb2YgbWV0YWRhdGEuaWRlbnRpdHk/LmRpZCA9PT0gJ3N0cmluZydcbiAgICAgICAgICAgICAgICAgICAgPyBtZXRhZGF0YS5pZGVudGl0eS5kaWRcbiAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQpO1xuICAgICAgICAgICAgaWYgKCFyYXdEaWQgfHwgcmF3RGlkLnRvTG93ZXJDYXNlKCkgIT09IHBhcmFtcy5kaWQudHJpbSgpLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcmFtcy5zdXBwb3J0ZWRUcnVzdCAmJiBwYXJhbXMuc3VwcG9ydGVkVHJ1c3QubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3Qgc3VwcG9ydGVkVHJ1c3QgPSBub3JtYWxpemVUb1N0cmluZ0FycmF5KGFnZW50LnN1cHBvcnRlZFRydXN0LCBtZXRhZGF0YT8uc3VwcG9ydGVkVHJ1c3QpO1xuICAgICAgICAgICAgaWYgKCFpbmNsdWRlc0V2ZXJ5Q2FzZUluc2Vuc2l0aXZlKHN1cHBvcnRlZFRydXN0LCBwYXJhbXMuc3VwcG9ydGVkVHJ1c3QpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJhbXMuYTJhU2tpbGxzICYmIHBhcmFtcy5hMmFTa2lsbHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3Qgc2tpbGxzID0gbm9ybWFsaXplVG9TdHJpbmdBcnJheShtZXRhZGF0YT8uYTJhU2tpbGxzLCBtZXRhZGF0YT8uYTJhPy5za2lsbHMsIG1ldGFkYXRhPy5za2lsbHMpO1xuICAgICAgICAgICAgaWYgKCFpbmNsdWRlc0V2ZXJ5Q2FzZUluc2Vuc2l0aXZlKHNraWxscywgcGFyYW1zLmEyYVNraWxscykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcmFtcy5tY3BUb29scyAmJiBwYXJhbXMubWNwVG9vbHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3QgdG9vbHMgPSBub3JtYWxpemVUb1N0cmluZ0FycmF5KG1ldGFkYXRhPy5tY3BUb29scywgbWV0YWRhdGE/Lm1jcD8udG9vbHMpO1xuICAgICAgICAgICAgaWYgKCFpbmNsdWRlc0V2ZXJ5Q2FzZUluc2Vuc2l0aXZlKHRvb2xzLCBwYXJhbXMubWNwVG9vbHMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJhbXMubWNwUHJvbXB0cyAmJiBwYXJhbXMubWNwUHJvbXB0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBwcm9tcHRzID0gbm9ybWFsaXplVG9TdHJpbmdBcnJheShtZXRhZGF0YT8ubWNwUHJvbXB0cywgbWV0YWRhdGE/Lm1jcD8ucHJvbXB0cyk7XG4gICAgICAgICAgICBpZiAoIWluY2x1ZGVzRXZlcnlDYXNlSW5zZW5zaXRpdmUocHJvbXB0cywgcGFyYW1zLm1jcFByb21wdHMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJhbXMubWNwUmVzb3VyY2VzICYmIHBhcmFtcy5tY3BSZXNvdXJjZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3QgcmVzb3VyY2VzID0gbm9ybWFsaXplVG9TdHJpbmdBcnJheShtZXRhZGF0YT8ubWNwUmVzb3VyY2VzLCBtZXRhZGF0YT8ubWNwPy5yZXNvdXJjZXMpO1xuICAgICAgICAgICAgaWYgKCFpbmNsdWRlc0V2ZXJ5Q2FzZUluc2Vuc2l0aXZlKHJlc291cmNlcywgcGFyYW1zLm1jcFJlc291cmNlcykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcmFtcy5tY3AgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgaGFzTWNwID0gbWV0YWRhdGE/Lm1jcCA9PT0gdHJ1ZSB8fFxuICAgICAgICAgICAgICAgIG1ldGFkYXRhPy5tY3A/LmVuYWJsZWQgPT09IHRydWUgfHxcbiAgICAgICAgICAgICAgICAoQXJyYXkuaXNBcnJheShtZXRhZGF0YT8ubWNwPy50b29scykgJiYgbWV0YWRhdGEubWNwLnRvb2xzLmxlbmd0aCA+IDApO1xuICAgICAgICAgICAgaWYgKHBhcmFtcy5tY3AgIT09IGhhc01jcCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocGFyYW1zLmEyYSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBoYXNBMmEgPSB0eXBlb2YgYWdlbnQuYTJhRW5kcG9pbnQgPT09ICdzdHJpbmcnICYmIGFnZW50LmEyYUVuZHBvaW50Lmxlbmd0aCA+IDA7XG4gICAgICAgICAgICBpZiAocGFyYW1zLmEyYSAhPT0gaGFzQTJhKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJhbXMub3BlcmF0b3JzICYmIHBhcmFtcy5vcGVyYXRvcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3Qgb3BlcmF0b3JzID0gbm9ybWFsaXplVG9TdHJpbmdBcnJheShtZXRhZGF0YT8ub3BlcmF0b3JzLCBtZXRhZGF0YT8uYWdlbnRPcGVyYXRvcnMsIG1ldGFkYXRhPy5vcGVyYXRvckFkZHJlc3NlcykubWFwKCh2YWx1ZSkgPT4gdmFsdWUudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgICAgICBpZiAob3BlcmF0b3JzLmxlbmd0aCA9PT0gMCB8fFxuICAgICAgICAgICAgICAgICFwYXJhbXMub3BlcmF0b3JzLnNvbWUoKGFkZHIpID0+IG9wZXJhdG9ycy5pbmNsdWRlcyhhZGRyLnRvTG93ZXJDYXNlKCkpKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocGFyYW1zLmFjdGl2ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBhY3RpdmUgPSB0eXBlb2YgbWV0YWRhdGE/LmFjdGl2ZSA9PT0gJ2Jvb2xlYW4nXG4gICAgICAgICAgICAgICAgPyBtZXRhZGF0YS5hY3RpdmVcbiAgICAgICAgICAgICAgICA6IHR5cGVvZiBtZXRhZGF0YT8uc3RhdHVzID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgICAgICAgICA/IG1ldGFkYXRhLnN0YXR1cy50b0xvd2VyQ2FzZSgpID09PSAnYWN0aXZlJ1xuICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmIChhY3RpdmUgIT09IHVuZGVmaW5lZCAmJiBwYXJhbXMuYWN0aXZlICE9PSBhY3RpdmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcmFtcy54NDAyc3VwcG9ydCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBzdXBwb3J0ID0gbWV0YWRhdGE/Lng0MDJzdXBwb3J0ID09PSB0cnVlIHx8XG4gICAgICAgICAgICAgICAgbWV0YWRhdGE/Lng0MDJTdXBwb3J0ID09PSB0cnVlIHx8XG4gICAgICAgICAgICAgICAgKEFycmF5LmlzQXJyYXkobWV0YWRhdGE/LnByb3RvY29scykgJiZcbiAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGEucHJvdG9jb2xzLm1hcCgocCkgPT4gcC50b0xvd2VyQ2FzZSgpKS5pbmNsdWRlcygneDQwMicpKTtcbiAgICAgICAgICAgIGlmIChwYXJhbXMueDQwMnN1cHBvcnQgIT09IHN1cHBvcnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBwYXJhbXMubWluQXRpT3ZlcmFsbFNjb3JlID09PSAnbnVtYmVyJyAmJiBwYXJhbXMubWluQXRpT3ZlcmFsbFNjb3JlID4gMCkge1xuICAgICAgICAgICAgY29uc3Qgc2NvcmVSYXcgPSBhZ2VudC5hdGlPdmVyYWxsU2NvcmU7XG4gICAgICAgICAgICBjb25zdCBzY29yZSA9IHR5cGVvZiBzY29yZVJhdyA9PT0gJ251bWJlcicgPyBzY29yZVJhdyA6IE51bWJlcihzY29yZVJhdyk7XG4gICAgICAgICAgICBpZiAoIU51bWJlci5pc0Zpbml0ZShzY29yZSkgfHwgc2NvcmUgPCBwYXJhbXMubWluQXRpT3ZlcmFsbFNjb3JlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgcGFyYW1zLmF0aUNvbXB1dGVkV2l0aGluRGF5cyA9PT0gJ251bWJlcicgJiYgcGFyYW1zLmF0aUNvbXB1dGVkV2l0aGluRGF5cyA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbXB1dGVkUmF3ID0gYWdlbnQuYXRpQ29tcHV0ZWRBdDtcbiAgICAgICAgICAgIGNvbnN0IGNvbXB1dGVkQXQgPSB0eXBlb2YgY29tcHV0ZWRSYXcgPT09ICdudW1iZXInID8gY29tcHV0ZWRSYXcgOiBOdW1iZXIoY29tcHV0ZWRSYXcpO1xuICAgICAgICAgICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoY29tcHV0ZWRBdCkgfHwgY29tcHV0ZWRBdCA8PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgbm93U2Vjb25kcyA9IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDEwMDApO1xuICAgICAgICAgICAgY29uc3Qgd2luZG93U2Vjb25kcyA9IE1hdGguZmxvb3IocGFyYW1zLmF0aUNvbXB1dGVkV2l0aGluRGF5cyAqIDI0ICogNjAgKiA2MCk7XG4gICAgICAgICAgICBjb25zdCB0aHJlc2hvbGQgPSBub3dTZWNvbmRzIC0gd2luZG93U2Vjb25kcztcbiAgICAgICAgICAgIGlmIChjb21wdXRlZEF0IDwgdGhyZXNob2xkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZG1pbiBBUEkgZm9yIGFnZW50IG1hbmFnZW1lbnRcbiAgICAgKiBUaGVzZSBtZXRob2RzIHJlcXVpcmUgQWRtaW5BcHAgdG8gYmUgaW5pdGlhbGl6ZWRcbiAgICAgKiBOb3RlOiBjcmVhdGVBZ2VudCBpcyBub3cgYXZhaWxhYmxlIGRpcmVjdGx5IG9uIGFnZW50cyAobm90IGFnZW50cy5hZG1pbilcbiAgICAgKi9cbiAgICBhZG1pbiA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByZXBhcmUgbG93LWxldmVsIGNvbnRyYWN0IGNhbGxzIHRvIHVwZGF0ZSBhbiBhZ2VudCdzIHRva2VuIFVSSSBhbmQvb3JcbiAgICAgICAgICogb24tY2hhaW4gbWV0YWRhdGEuIFRoZXNlIGNhbGxzIGNhbiBiZSBleGVjdXRlZCBjbGllbnQtc2lkZSB2aWEgYSBidW5kbGVyXG4gICAgICAgICAgICAgKiBvciB3YWxsZXQsIHNpbWlsYXIgdG8gY3JlYXRlQWdlbnRXaXRoU21hcnRBY2NvdW50T3duZXJVc2luZ1dhbGxldC5cbiAgICAgICAgICovXG4gICAgICAgIHByZXBhcmVVcGRhdGVBZ2VudDogYXN5bmMgKHBhcmFtcykgPT4ge1xuICAgICAgICAgICAgY29uc3QgY2hhaW5JZCA9IHBhcmFtcy5jaGFpbklkIHx8IERFRkFVTFRfQ0hBSU5fSUQ7XG4gICAgICAgICAgICBjb25zdCBpZGVudGl0eVJlZ2lzdHJ5ID0gcmVxdWlyZUNoYWluRW52VmFyKCdBR0VOVElDX1RSVVNUX0lERU5USVRZX1JFR0lTVFJZJywgY2hhaW5JZCk7XG4gICAgICAgICAgICBjb25zdCBpZGVudGl0eVJlZ2lzdHJ5SGV4ID0gaWRlbnRpdHlSZWdpc3RyeS5zdGFydHNXaXRoKCcweCcpXG4gICAgICAgICAgICAgICAgPyBpZGVudGl0eVJlZ2lzdHJ5XG4gICAgICAgICAgICAgICAgOiBgMHgke2lkZW50aXR5UmVnaXN0cnl9YDtcbiAgICAgICAgICAgIGNvbnN0IGFnZW50SWQgPSBCaWdJbnQocGFyYW1zLmFnZW50SWQpO1xuICAgICAgICAgICAgY29uc3QgY2FsbHMgPSBbXTtcbiAgICAgICAgICAgIC8vIFRva2VuIFVSSSB1cGRhdGUgY2FsbFxuICAgICAgICAgICAgaWYgKHBhcmFtcy50b2tlblVyaSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IGVuY29kZUZ1bmN0aW9uRGF0YSh7XG4gICAgICAgICAgICAgICAgICAgIGFiaTogaWRlbnRpdHlSZWdpc3RyeUFiaSxcbiAgICAgICAgICAgICAgICAgICAgLy8gVXBkYXRlZCBBQkkgbmFtZSBpcyBzZXRBZ2VudFVSSSAoY2FwaXRhbCBVUkkpXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uTmFtZTogJ3NldEFnZW50VVJJJyxcbiAgICAgICAgICAgICAgICAgICAgYXJnczogW2FnZW50SWQsIHBhcmFtcy50b2tlblVyaV0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY2FsbHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHRvOiBpZGVudGl0eVJlZ2lzdHJ5SGV4LFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogMG4sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBNZXRhZGF0YSB1cGRhdGUgY2FsbHNcbiAgICAgICAgICAgIGlmIChwYXJhbXMubWV0YWRhdGEgJiYgcGFyYW1zLm1ldGFkYXRhLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBlbnRyeSBvZiBwYXJhbXMubWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWVCeXRlcyA9IGVuY29kZXIuZW5jb2RlKGVudHJ5LnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IGVuY29kZUZ1bmN0aW9uRGF0YSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBhYmk6IGlkZW50aXR5UmVnaXN0cnlBYmksXG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbk5hbWU6ICdzZXRNZXRhZGF0YScsXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzOiBbYWdlbnRJZCwgZW50cnkua2V5LCB2YWx1ZUJ5dGVzXSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgdG86IGlkZW50aXR5UmVnaXN0cnlIZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IDBuLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2FsbHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyB1cGRhdGVzIHByb3ZpZGVkLiBTcGVjaWZ5IHRva2VuVXJpIGFuZC9vciBtZXRhZGF0YS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGJ1bmRsZXJVcmwgPSBnZXRDaGFpbkJ1bmRsZXJVcmwoY2hhaW5JZCk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGNoYWluSWQsXG4gICAgICAgICAgICAgICAgaWRlbnRpdHlSZWdpc3RyeTogaWRlbnRpdHlSZWdpc3RyeUhleCxcbiAgICAgICAgICAgICAgICBidW5kbGVyVXJsLFxuICAgICAgICAgICAgICAgIGNhbGxzLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByZXBhcmUgYSBjcmVhdGUgYWdlbnQgdHJhbnNhY3Rpb24gZm9yIGNsaWVudC1zaWRlIHNpZ25pbmdcbiAgICAgICAgICogUmV0dXJucyB0cmFuc2FjdGlvbiBkYXRhIHRoYXQgY2FuIGJlIHNpZ25lZCBhbmQgc3VibWl0dGVkIGJ5IHRoZSBjbGllbnRcbiAgICAgICAgICovXG4gICAgICAgIHByZXBhcmVDcmVhdGVBZ2VudFRyYW5zYWN0aW9uOiBhc3luYyAocGFyYW1zKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjaGFpbklkID0gcGFyYW1zLmNoYWluSWQgfHwgREVGQVVMVF9DSEFJTl9JRDtcbiAgICAgICAgICAgIGNvbnN0IGFkbWluQXBwID0gYXdhaXQgZ2V0QWRtaW5BcHAodW5kZWZpbmVkLCBjaGFpbklkKTtcbiAgICAgICAgICAgIGlmICghYWRtaW5BcHApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FkbWluQXBwIG5vdCBpbml0aWFsaXplZC4gRW5zdXJlIEFHRU5USUNfVFJVU1RfQVBQX1JPTEVTIGluY2x1ZGVzIFwiYWRtaW5cIiBhbmQgY29ubmVjdCB2aWEgd2FsbGV0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYWRtaW5BcHAuaGFzUHJpdmF0ZUtleSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncHJlcGFyZUNyZWF0ZUFnZW50VHJhbnNhY3Rpb24gc2hvdWxkIG9ubHkgYmUgdXNlZCB3aGVuIG5vIHByaXZhdGUga2V5IGlzIGF2YWlsYWJsZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaWRlbnRpdHlSZWdpc3RyeSA9IHJlcXVpcmVDaGFpbkVudlZhcignQUdFTlRJQ19UUlVTVF9JREVOVElUWV9SRUdJU1RSWScsIGNoYWluSWQpO1xuICAgICAgICAgICAgY29uc3QgaWRlbnRpdHlSZWdpc3RyeUhleCA9IGlkZW50aXR5UmVnaXN0cnkuc3RhcnRzV2l0aCgnMHgnKVxuICAgICAgICAgICAgICAgID8gaWRlbnRpdHlSZWdpc3RyeVxuICAgICAgICAgICAgICAgIDogYDB4JHtpZGVudGl0eVJlZ2lzdHJ5fWA7XG4gICAgICAgICAgICAvLyBDcmVhdGUgcmVhZC1vbmx5IElkZW50aXR5Q2xpZW50IHVzaW5nIEFkbWluQXBwJ3MgQWNjb3VudFByb3ZpZGVyXG4gICAgICAgICAgICBjb25zdCBpZGVudGl0eUNsaWVudCA9IG5ldyBCYXNlSWRlbnRpdHlDbGllbnQoYWRtaW5BcHAuYWNjb3VudFByb3ZpZGVyLCBpZGVudGl0eVJlZ2lzdHJ5SGV4KTtcbiAgICAgICAgICAgIC8vIEJ1aWxkIG1ldGFkYXRhIGFycmF5XG4gICAgICAgICAgICBjb25zdCBtZXRhZGF0YSA9IFtcbiAgICAgICAgICAgICAgICB7IGtleTogJ2FnZW50TmFtZScsIHZhbHVlOiBwYXJhbXMuYWdlbnROYW1lID8gU3RyaW5nKHBhcmFtcy5hZ2VudE5hbWUpIDogJycgfSxcbiAgICAgICAgICAgICAgICB7IGtleTogJ2FnZW50QWNjb3VudCcsIHZhbHVlOiBwYXJhbXMuYWdlbnRBY2NvdW50ID8gU3RyaW5nKHBhcmFtcy5hZ2VudEFjY291bnQpIDogJycgfSxcbiAgICAgICAgICAgICAgICAuLi4ocGFyYW1zLmFnZW50Q2F0ZWdvcnkgPyBbeyBrZXk6ICdhZ2VudENhdGVnb3J5JywgdmFsdWU6IFN0cmluZyhwYXJhbXMuYWdlbnRDYXRlZ29yeSkgfV0gOiBbXSksXG4gICAgICAgICAgICAgICAgeyBrZXk6ICdyZWdpc3RlcmVkQnknLCB2YWx1ZTogJ2FnZW50aWMtdHJ1c3QnIH0sXG4gICAgICAgICAgICAgICAgeyBrZXk6ICdyZWdpc3RyeU5hbWVzcGFjZScsIHZhbHVlOiAnZXJjLTgwMDQnIH0sXG4gICAgICAgICAgICBdLmZpbHRlcihtID0+IG0udmFsdWUgIT09ICcnKTtcbiAgICAgICAgICAgIC8vIENyZWF0ZSByZWdpc3RyYXRpb24gSlNPTiBhbmQgdXBsb2FkIHRvIElQRlNcbiAgICAgICAgICAgIGxldCB0b2tlblVyaSA9ICcnO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZWdpc3RyYXRpb25KU09OID0gY3JlYXRlUmVnaXN0cmF0aW9uSlNPTih7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IHBhcmFtcy5hZ2VudE5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGFnZW50QWNjb3VudDogcGFyYW1zLmFnZW50QWNjb3VudCxcbiAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IHBhcmFtcy5kZXNjcmlwdGlvbixcbiAgICAgICAgICAgICAgICAgICAgaW1hZ2U6IHBhcmFtcy5pbWFnZSxcbiAgICAgICAgICAgICAgICAgICAgYWdlbnRVcmw6IHBhcmFtcy5hZ2VudFVybCxcbiAgICAgICAgICAgICAgICAgICAgY2hhaW5JZCxcbiAgICAgICAgICAgICAgICAgICAgaWRlbnRpdHlSZWdpc3RyeTogaWRlbnRpdHlSZWdpc3RyeUhleCxcbiAgICAgICAgICAgICAgICAgICAgc3VwcG9ydGVkVHJ1c3Q6IHBhcmFtcy5zdXBwb3J0ZWRUcnVzdCxcbiAgICAgICAgICAgICAgICAgICAgZW5kcG9pbnRzOiBwYXJhbXMuZW5kcG9pbnRzXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdXBsb2FkUmVzdWx0ID0gYXdhaXQgdXBsb2FkUmVnaXN0cmF0aW9uKHJlZ2lzdHJhdGlvbkpTT04pO1xuICAgICAgICAgICAgICAgIHRva2VuVXJpID0gdXBsb2FkUmVzdWx0LnRva2VuVXJpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIHVwbG9hZCByZWdpc3RyYXRpb24gSlNPTiB0byBJUEZTOicsIGVycm9yKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBjcmVhdGUgcmVnaXN0cmF0aW9uIEpTT046ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvcid9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBHZXQgY2hhaW4tc3BlY2lmaWMgUlBDIFVSTFxuICAgICAgICAgICAgY29uc3QgcnBjVXJsID0gZ2V0Q2hhaW5ScGNVcmwoY2hhaW5JZCk7XG4gICAgICAgICAgICAvLyBFbmNvZGUgdGhlIHRyYW5zYWN0aW9uIGRhdGFcbiAgICAgICAgICAgIGNvbnN0IGFpSWRlbnRpdHlDbGllbnQgPSBuZXcgQUlBZ2VudElkZW50aXR5Q2xpZW50KHtcbiAgICAgICAgICAgICAgICBjaGFpbklkLFxuICAgICAgICAgICAgICAgIHJwY1VybCxcbiAgICAgICAgICAgICAgICBpZGVudGl0eVJlZ2lzdHJ5QWRkcmVzczogaWRlbnRpdHlSZWdpc3RyeUhleCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gRW5jb2RlIHJlZ2lzdGVyV2l0aE1ldGFkYXRhIGZ1bmN0aW9uIGNhbGxcbiAgICAgICAgICAgIGNvbnN0IGVuY29kZWREYXRhID0gYXdhaXQgYWlJZGVudGl0eUNsaWVudC5lbmNvZGVSZWdpc3RlcldpdGhNZXRhZGF0YSh0b2tlblVyaSwgbWV0YWRhdGEpO1xuICAgICAgICAgICAgLy8gU2ltdWxhdGUgdHJhbnNhY3Rpb24gdG8gZ2V0IGdhcyBlc3RpbWF0ZXNcbiAgICAgICAgICAgIGxldCBnYXNFc3RpbWF0ZTtcbiAgICAgICAgICAgIGxldCBnYXNQcmljZTtcbiAgICAgICAgICAgIGxldCBtYXhGZWVQZXJHYXM7XG4gICAgICAgICAgICBsZXQgbWF4UHJpb3JpdHlGZWVQZXJHYXM7XG4gICAgICAgICAgICBsZXQgbm9uY2U7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIC8vIEdldCBjdXJyZW50IGdhcyBwcmljZXNcbiAgICAgICAgICAgICAgICBjb25zdCBbZ2FzUHJpY2VEYXRhLCBibG9ja0RhdGFdID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgICAgICAgICBhZG1pbkFwcC5wdWJsaWNDbGllbnQuZ2V0R2FzUHJpY2UoKSxcbiAgICAgICAgICAgICAgICAgICAgYWRtaW5BcHAucHVibGljQ2xpZW50LmdldEJsb2NrKHsgYmxvY2tUYWc6ICdsYXRlc3QnIH0pLFxuICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgIGdhc1ByaWNlID0gZ2FzUHJpY2VEYXRhO1xuICAgICAgICAgICAgICAgIC8vIFRyeSBFSVAtMTU1OSBnYXMgcHJpY2VzIGlmIGF2YWlsYWJsZVxuICAgICAgICAgICAgICAgIGlmIChibG9ja0RhdGEgJiYgJ2Jhc2VGZWVQZXJHYXMnIGluIGJsb2NrRGF0YSAmJiBibG9ja0RhdGEuYmFzZUZlZVBlckdhcykge1xuICAgICAgICAgICAgICAgICAgICBtYXhGZWVQZXJHYXMgPSAoYmxvY2tEYXRhLmJhc2VGZWVQZXJHYXMgKiAybikgLyAxMG47IC8vIDJ4IGJhc2UgZmVlXG4gICAgICAgICAgICAgICAgICAgIG1heFByaW9yaXR5RmVlUGVyR2FzID0gYmxvY2tEYXRhLmJhc2VGZWVQZXJHYXMgLyAxMG47IC8vIDEwJSBvZiBiYXNlIGZlZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBFc3RpbWF0ZSBnYXNcbiAgICAgICAgICAgICAgICBnYXNFc3RpbWF0ZSA9IGF3YWl0IGFkbWluQXBwLnB1YmxpY0NsaWVudC5lc3RpbWF0ZUdhcyh7XG4gICAgICAgICAgICAgICAgICAgIGFjY291bnQ6IGFkbWluQXBwLmFkZHJlc3MsXG4gICAgICAgICAgICAgICAgICAgIHRvOiBpZGVudGl0eVJlZ2lzdHJ5SGV4LFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBlbmNvZGVkRGF0YSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAvLyBHZXQgbm9uY2VcbiAgICAgICAgICAgICAgICBub25jZSA9IGF3YWl0IGFkbWluQXBwLnB1YmxpY0NsaWVudC5nZXRUcmFuc2FjdGlvbkNvdW50KHtcbiAgICAgICAgICAgICAgICAgICAgYWRkcmVzczogYWRtaW5BcHAuYWRkcmVzcyxcbiAgICAgICAgICAgICAgICAgICAgYmxvY2tUYWc6ICdwZW5kaW5nJyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignQ291bGQgbm90IGVzdGltYXRlIGdhcyBvciBnZXQgdHJhbnNhY3Rpb24gcGFyYW1ldGVyczonLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgLy8gQ29udGludWUgd2l0aG91dCBnYXMgZXN0aW1hdGVzIC0gY2xpZW50IGNhbiBlc3RpbWF0ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICByZXF1aXJlc0NsaWVudFNpZ25pbmc6IHRydWUsXG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb246IHtcbiAgICAgICAgICAgICAgICAgICAgdG86IGlkZW50aXR5UmVnaXN0cnlIZXgsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGVuY29kZWREYXRhLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogJzAnLFxuICAgICAgICAgICAgICAgICAgICBnYXM6IGdhc0VzdGltYXRlID8gZ2FzRXN0aW1hdGUudG9TdHJpbmcoKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgZ2FzUHJpY2U6IGdhc1ByaWNlID8gZ2FzUHJpY2UudG9TdHJpbmcoKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgbWF4RmVlUGVyR2FzOiBtYXhGZWVQZXJHYXMgPyBtYXhGZWVQZXJHYXMudG9TdHJpbmcoKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgbWF4UHJpb3JpdHlGZWVQZXJHYXM6IG1heFByaW9yaXR5RmVlUGVyR2FzID8gbWF4UHJpb3JpdHlGZWVQZXJHYXMudG9TdHJpbmcoKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgbm9uY2UsXG4gICAgICAgICAgICAgICAgICAgIGNoYWluSWQsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB0b2tlblVyaSxcbiAgICAgICAgICAgICAgICBtZXRhZGF0YTogbWV0YWRhdGEubWFwKG0gPT4gKHsga2V5OiBtLmtleSwgdmFsdWU6IG0udmFsdWUgfSkpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVwZGF0ZSBhbiBhZ2VudCdzIHRva2VuIFVSSVxuICAgICAgICAgKiBAcGFyYW0gYWdlbnRJZCAtIFRoZSBhZ2VudCBJRCB0byB1cGRhdGVcbiAgICAgICAgICogQHBhcmFtIHRva2VuVXJpIC0gTmV3IHRva2VuIFVSSVxuICAgICAgICAgKiBAcmV0dXJucyBUcmFuc2FjdGlvbiBoYXNoXG4gICAgICAgICAqL1xuICAgICAgICAvKipcbiAgICAgICAgICogU2VydmVyLXNpZGUgaGVscGVyIHRoYXQgYWN0dWFsbHkgc2VuZHMgdGhlIHByZXBhcmVkIHVwZGF0ZSBjYWxscyB1c2luZ1xuICAgICAgICAgKiBBZG1pbkFwcCdzIEFjY291bnRQcm92aWRlci4gRm9yIGJyb3dzZXIvYnVuZGxlciBmbG93cywgcHJlZmVyXG4gICAgICAgICAqIHByZXBhcmVVcGRhdGVBZ2VudCBpbnN0ZWFkLlxuICAgICAgICAgKi9cbiAgICAgICAgdXBkYXRlQWdlbnQ6IGFzeW5jIChwYXJhbXMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNoYWluSWQgPSBwYXJhbXMuY2hhaW5JZCB8fCBERUZBVUxUX0NIQUlOX0lEO1xuICAgICAgICAgICAgY29uc3QgYWRtaW5BcHAgPSBhd2FpdCBnZXRBZG1pbkFwcCh1bmRlZmluZWQsIGNoYWluSWQpO1xuICAgICAgICAgICAgaWYgKCFhZG1pbkFwcCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQWRtaW5BcHAgbm90IGluaXRpYWxpemVkLiBFbnN1cmUgQUdFTlRJQ19UUlVTVF9BUFBfUk9MRVMgaW5jbHVkZXMgXCJhZG1pblwiIGFuZCBBR0VOVElDX1RSVVNUX0FETUlOX1BSSVZBVEVfS0VZIGlzIHNldCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcHJlcGFyZWQgPSBhd2FpdCB0aGlzLmFkbWluLnByZXBhcmVVcGRhdGVBZ2VudCh7XG4gICAgICAgICAgICAgICAgYWdlbnRJZDogcGFyYW1zLmFnZW50SWQsXG4gICAgICAgICAgICAgICAgdG9rZW5Vcmk6IHBhcmFtcy50b2tlblVyaSxcbiAgICAgICAgICAgICAgICBtZXRhZGF0YTogcGFyYW1zLm1ldGFkYXRhLFxuICAgICAgICAgICAgICAgIGNoYWluSWQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgY2FsbCBvZiBwcmVwYXJlZC5jYWxscykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHR4ID0gYXdhaXQgYWRtaW5BcHAuYWNjb3VudFByb3ZpZGVyLnNlbmQoe1xuICAgICAgICAgICAgICAgICAgICB0bzogY2FsbC50byxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogY2FsbC5kYXRhLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogY2FsbC52YWx1ZSA/PyAwbixcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goeyB0eEhhc2g6IHR4Lmhhc2ggfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVzdWx0cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHVwZGF0ZXMgcHJvdmlkZWQuIFNwZWNpZnkgdG9rZW5VcmkgYW5kL29yIG1ldGFkYXRhLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbGFzdFJlc3VsdCA9IHJlc3VsdHNbcmVzdWx0cy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIGlmICghbGFzdFJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGdldCB0cmFuc2FjdGlvbiBoYXNoIGZyb20gdXBkYXRlIG9wZXJhdGlvbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHsgdHhIYXNoOiBsYXN0UmVzdWx0LnR4SGFzaCB9O1xuICAgICAgICB9LFxuICAgICAgICB1cGRhdGVBZ2VudEJ5RGlkOiBhc3luYyAoYWdlbnREaWQsIHBhcmFtcyA9IHt9KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IGFnZW50SWQsIGNoYWluSWQgfSA9IHBhcnNlRGlkODAwNChhZ2VudERpZCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hZG1pbi51cGRhdGVBZ2VudCh7XG4gICAgICAgICAgICAgICAgYWdlbnRJZCxcbiAgICAgICAgICAgICAgICBjaGFpbklkOiBwYXJhbXMuY2hhaW5JZCA/PyBjaGFpbklkLFxuICAgICAgICAgICAgICAgIHRva2VuVXJpOiBwYXJhbXMudG9rZW5VcmksXG4gICAgICAgICAgICAgICAgbWV0YWRhdGE6IHBhcmFtcy5tZXRhZGF0YSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogRGVsZXRlIGFuIGFnZW50IGJ5IHRyYW5zZmVycmluZyBpdCB0byB0aGUgemVybyBhZGRyZXNzIChidXJuKVxuICAgICAgICAgKiBOb3RlOiBUaGlzIHJlcXVpcmVzIHRoZSBjb250cmFjdCB0byBzdXBwb3J0IHRyYW5zZmVycyB0byBhZGRyZXNzKDApXG4gICAgICAgICAqIEBwYXJhbSBhZ2VudElkIC0gVGhlIGFnZW50IElEIHRvIGRlbGV0ZVxuICAgICAgICAgKiBAcmV0dXJucyBUcmFuc2FjdGlvbiBoYXNoXG4gICAgICAgICAqL1xuICAgICAgICBkZWxldGVBZ2VudDogYXN5bmMgKHBhcmFtcykgPT4ge1xuICAgICAgICAgICAgY29uc3QgY2hhaW5JZCA9IHBhcmFtcy5jaGFpbklkIHx8IERFRkFVTFRfQ0hBSU5fSUQ7XG4gICAgICAgICAgICBjb25zdCBhZG1pbkFwcCA9IGF3YWl0IGdldEFkbWluQXBwKHVuZGVmaW5lZCwgY2hhaW5JZCk7XG4gICAgICAgICAgICBpZiAoIWFkbWluQXBwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBZG1pbkFwcCBub3QgaW5pdGlhbGl6ZWQuIEVuc3VyZSBBR0VOVElDX1RSVVNUX0FQUF9ST0xFUyBpbmNsdWRlcyBcImFkbWluXCIgYW5kIEFHRU5USUNfVFJVU1RfQURNSU5fUFJJVkFURV9LRVkgaXMgc2V0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBpZGVudGl0eVJlZ2lzdHJ5ID0gcmVxdWlyZUNoYWluRW52VmFyKCdBR0VOVElDX1RSVVNUX0lERU5USVRZX1JFR0lTVFJZJywgY2hhaW5JZCk7XG4gICAgICAgICAgICAvLyBJbXBvcnQgSWRlbnRpdHlSZWdpc3RyeSBBQkkgZm9yIHRyYW5zZmVyRnJvbVxuICAgICAgICAgICAgY29uc3QgSWRlbnRpdHlSZWdpc3RyeUFCSSA9IGlkZW50aXR5UmVnaXN0cnlBYmk7XG4gICAgICAgICAgICBjb25zdCBhZ2VudElkID0gQmlnSW50KHBhcmFtcy5hZ2VudElkKTtcbiAgICAgICAgICAgIGNvbnN0IGZyb20gPSBhZG1pbkFwcC5hZGRyZXNzO1xuICAgICAgICAgICAgY29uc3QgdG8gPSAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJztcbiAgICAgICAgICAgIC8vIFRyYW5zZmVyIHRvIHplcm8gYWRkcmVzcyAoYnVybilcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBhZG1pbkFwcC5hY2NvdW50UHJvdmlkZXIuZW5jb2RlRnVuY3Rpb25EYXRhKHtcbiAgICAgICAgICAgICAgICBhYmk6IElkZW50aXR5UmVnaXN0cnlBQkksXG4gICAgICAgICAgICAgICAgZnVuY3Rpb25OYW1lOiAndHJhbnNmZXJGcm9tJyxcbiAgICAgICAgICAgICAgICBhcmdzOiBbZnJvbSwgdG8sIGFnZW50SWRdLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBhZG1pbkFwcC5hY2NvdW50UHJvdmlkZXIuc2VuZCh7XG4gICAgICAgICAgICAgICAgdG86IGlkZW50aXR5UmVnaXN0cnksXG4gICAgICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogMG4sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB7IHR4SGFzaDogcmVzdWx0Lmhhc2ggfTtcbiAgICAgICAgfSxcbiAgICAgICAgZGVsZXRlQWdlbnRCeURpZDogYXN5bmMgKGFnZW50RGlkLCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgYWdlbnRJZCwgY2hhaW5JZCB9ID0gcGFyc2VEaWQ4MDA0KGFnZW50RGlkKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFkbWluLmRlbGV0ZUFnZW50KHtcbiAgICAgICAgICAgICAgICBhZ2VudElkLFxuICAgICAgICAgICAgICAgIGNoYWluSWQ6IG9wdGlvbnMuY2hhaW5JZCA/PyBjaGFpbklkLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUcmFuc2ZlciBhbiBhZ2VudCB0byBhIG5ldyBvd25lclxuICAgICAgICAgKiBAcGFyYW0gYWdlbnRJZCAtIFRoZSBhZ2VudCBJRCB0byB0cmFuc2ZlclxuICAgICAgICAgKiBAcGFyYW0gdG8gLSBUaGUgbmV3IG93bmVyIGFkZHJlc3NcbiAgICAgICAgICogQHJldHVybnMgVHJhbnNhY3Rpb24gaGFzaFxuICAgICAgICAgKi9cbiAgICAgICAgdHJhbnNmZXJBZ2VudDogYXN5bmMgKHBhcmFtcykgPT4ge1xuICAgICAgICAgICAgY29uc3QgY2hhaW5JZCA9IHBhcmFtcy5jaGFpbklkIHx8IERFRkFVTFRfQ0hBSU5fSUQ7XG4gICAgICAgICAgICBjb25zdCBhZG1pbkFwcCA9IGF3YWl0IGdldEFkbWluQXBwKHVuZGVmaW5lZCwgY2hhaW5JZCk7XG4gICAgICAgICAgICBpZiAoIWFkbWluQXBwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBZG1pbkFwcCBub3QgaW5pdGlhbGl6ZWQuIEVuc3VyZSBBR0VOVElDX1RSVVNUX0FQUF9ST0xFUyBpbmNsdWRlcyBcImFkbWluXCIgYW5kIEFHRU5USUNfVFJVU1RfQURNSU5fUFJJVkFURV9LRVkgaXMgc2V0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBpZGVudGl0eVJlZ2lzdHJ5ID0gcmVxdWlyZUNoYWluRW52VmFyKCdBR0VOVElDX1RSVVNUX0lERU5USVRZX1JFR0lTVFJZJywgY2hhaW5JZCk7XG4gICAgICAgICAgICAvLyBJbXBvcnQgSWRlbnRpdHlSZWdpc3RyeSBBQkkgZm9yIHRyYW5zZmVyRnJvbVxuICAgICAgICAgICAgY29uc3QgSWRlbnRpdHlSZWdpc3RyeUFCSSA9IGlkZW50aXR5UmVnaXN0cnlBYmk7XG4gICAgICAgICAgICBjb25zdCBhZ2VudElkID0gQmlnSW50KHBhcmFtcy5hZ2VudElkKTtcbiAgICAgICAgICAgIGNvbnN0IGZyb20gPSBhZG1pbkFwcC5hZGRyZXNzO1xuICAgICAgICAgICAgLy8gVHJhbnNmZXIgdG8gbmV3IG93bmVyXG4gICAgICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgYWRtaW5BcHAuYWNjb3VudFByb3ZpZGVyLmVuY29kZUZ1bmN0aW9uRGF0YSh7XG4gICAgICAgICAgICAgICAgYWJpOiBJZGVudGl0eVJlZ2lzdHJ5QUJJLFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uTmFtZTogJ3RyYW5zZmVyRnJvbScsXG4gICAgICAgICAgICAgICAgYXJnczogW2Zyb20sIHBhcmFtcy50bywgYWdlbnRJZF0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGFkbWluQXBwLmFjY291bnRQcm92aWRlci5zZW5kKHtcbiAgICAgICAgICAgICAgICB0bzogaWRlbnRpdHlSZWdpc3RyeSxcbiAgICAgICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgICAgIHZhbHVlOiAwbixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHsgdHhIYXNoOiByZXN1bHQuaGFzaCB9O1xuICAgICAgICB9LFxuICAgICAgICB0cmFuc2ZlckFnZW50QnlEaWQ6IGFzeW5jIChmcm9tRGlkLCB0b0RpZCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBhZ2VudElkLCBjaGFpbklkIH0gPSBwYXJzZURpZDgwMDQoZnJvbURpZCk7XG4gICAgICAgICAgICAvLyBGb3Igbm93IHdlIHN1cHBvcnQgdG9EaWQgYXMgZGlkOmV0aHI6Li4uIGFuZCBkZXJpdmUgdGhlIGRlc3RpbmF0aW9uXG4gICAgICAgICAgICAvLyBhY2NvdW50IGZyb20gaXQuIE90aGVyIERJRCBtZXRob2RzIGNhbiBiZSBhZGRlZCBsYXRlciBhcyBuZWVkZWQuXG4gICAgICAgICAgICBpZiAoIXRvRGlkLnN0YXJ0c1dpdGgoJ2RpZDpldGhyOicpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCB0b0RpZCBmb3JtYXQgZm9yIHRyYW5zZmVyQWdlbnRCeURpZDogJHt0b0RpZH0uIEV4cGVjdGVkIGRpZDpldGhyOi4uLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyBhY2NvdW50IH0gPSBwYXJzZUV0aHJEaWQodG9EaWQpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWRtaW4udHJhbnNmZXJBZ2VudCh7XG4gICAgICAgICAgICAgICAgYWdlbnRJZCxcbiAgICAgICAgICAgICAgICBjaGFpbklkLFxuICAgICAgICAgICAgICAgIHRvOiBhY2NvdW50LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFnZW50cy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@agentic-trust/core/dist/server/lib/agents.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@agentic-trust/core/dist/server/lib/association.js":
/*!*****************************************************************************!*\
  !*** ../../node_modules/@agentic-trust/core/dist/server/lib/association.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decodeAssociationData: () => (/* binding */ decodeAssociationData),\n/* harmony export */   encodeAssociationData: () => (/* binding */ encodeAssociationData)\n/* harmony export */ });\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! viem */ \"(rsc)/../../node_modules/viem/_esm/utils/abi/encodeAbiParameters.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! viem */ \"(rsc)/../../node_modules/abitype/dist/esm/human-readable/parseAbiParameters.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! viem */ \"(rsc)/../../node_modules/viem/_esm/utils/abi/decodeAbiParameters.js\");\n/**\n * Association utility functions for encoding/decoding association metadata\n */\n\n/**\n * Encode association type and description into bytes for ERC-8092 association data field\n */\nfunction encodeAssociationData(params) {\n    return (0,viem__WEBPACK_IMPORTED_MODULE_0__.encodeAbiParameters)((0,viem__WEBPACK_IMPORTED_MODULE_1__.parseAbiParameters)('uint8 assocType, string description'), [params.assocType, params.description]);\n}\n/**\n * Decode association type and description from ERC-8092 association data field\n */\nfunction decodeAssociationData(data) {\n    try {\n        const [assocType, description] = (0,viem__WEBPACK_IMPORTED_MODULE_2__.decodeAbiParameters)((0,viem__WEBPACK_IMPORTED_MODULE_1__.parseAbiParameters)('uint8 assocType, string description'), data);\n        return { assocType: Number(assocType), description };\n    }\n    catch (e) {\n        console.warn('[Association] Failed to decode association data:', e);\n        return null;\n    }\n}\n//# sourceMappingURL=association.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BhZ2VudGljLXRydXN0L2NvcmUvZGlzdC9zZXJ2ZXIvbGliL2Fzc29jaWF0aW9uLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ29GO0FBQ3BGO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsV0FBVyx5REFBbUIsQ0FBQyx3REFBa0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EseUNBQXlDLHlEQUFtQixDQUFDLHdEQUFrQjtBQUMvRSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL2JhcmIvYWEvQXNzb2NpYXRlZEFjY291bnRzL25vZGVfbW9kdWxlcy9AYWdlbnRpYy10cnVzdC9jb3JlL2Rpc3Qvc2VydmVyL2xpYi9hc3NvY2lhdGlvbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEFzc29jaWF0aW9uIHV0aWxpdHkgZnVuY3Rpb25zIGZvciBlbmNvZGluZy9kZWNvZGluZyBhc3NvY2lhdGlvbiBtZXRhZGF0YVxuICovXG5pbXBvcnQgeyBlbmNvZGVBYmlQYXJhbWV0ZXJzLCBkZWNvZGVBYmlQYXJhbWV0ZXJzLCBwYXJzZUFiaVBhcmFtZXRlcnMgfSBmcm9tICd2aWVtJztcbi8qKlxuICogRW5jb2RlIGFzc29jaWF0aW9uIHR5cGUgYW5kIGRlc2NyaXB0aW9uIGludG8gYnl0ZXMgZm9yIEVSQy04MDkyIGFzc29jaWF0aW9uIGRhdGEgZmllbGRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZUFzc29jaWF0aW9uRGF0YShwYXJhbXMpIHtcbiAgICByZXR1cm4gZW5jb2RlQWJpUGFyYW1ldGVycyhwYXJzZUFiaVBhcmFtZXRlcnMoJ3VpbnQ4IGFzc29jVHlwZSwgc3RyaW5nIGRlc2NyaXB0aW9uJyksIFtwYXJhbXMuYXNzb2NUeXBlLCBwYXJhbXMuZGVzY3JpcHRpb25dKTtcbn1cbi8qKlxuICogRGVjb2RlIGFzc29jaWF0aW9uIHR5cGUgYW5kIGRlc2NyaXB0aW9uIGZyb20gRVJDLTgwOTIgYXNzb2NpYXRpb24gZGF0YSBmaWVsZFxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlQXNzb2NpYXRpb25EYXRhKGRhdGEpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBbYXNzb2NUeXBlLCBkZXNjcmlwdGlvbl0gPSBkZWNvZGVBYmlQYXJhbWV0ZXJzKHBhcnNlQWJpUGFyYW1ldGVycygndWludDggYXNzb2NUeXBlLCBzdHJpbmcgZGVzY3JpcHRpb24nKSwgZGF0YSk7XG4gICAgICAgIHJldHVybiB7IGFzc29jVHlwZTogTnVtYmVyKGFzc29jVHlwZSksIGRlc2NyaXB0aW9uIH07XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignW0Fzc29jaWF0aW9uXSBGYWlsZWQgdG8gZGVjb2RlIGFzc29jaWF0aW9uIGRhdGE6JywgZSk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFzc29jaWF0aW9uLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@agentic-trust/core/dist/server/lib/association.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@agentic-trust/core/dist/server/lib/chainConfig.js":
/*!*****************************************************************************!*\
  !*** ../../node_modules/@agentic-trust/core/dist/server/lib/chainConfig.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CHAIN_CONFIG: () => (/* binding */ CHAIN_CONFIG),\n/* harmony export */   DEFAULT_CHAIN_ID: () => (/* binding */ DEFAULT_CHAIN_ID),\n/* harmony export */   baseSepolia: () => (/* reexport safe */ viem_chains__WEBPACK_IMPORTED_MODULE_1__.baseSepolia),\n/* harmony export */   getChainBundlerUrl: () => (/* binding */ getChainBundlerUrl),\n/* harmony export */   getChainById: () => (/* binding */ getChainById),\n/* harmony export */   getChainConfig: () => (/* binding */ getChainConfig),\n/* harmony export */   getChainContractAddress: () => (/* binding */ getChainContractAddress),\n/* harmony export */   getChainDisplayMetadata: () => (/* binding */ getChainDisplayMetadata),\n/* harmony export */   getChainEnvVar: () => (/* binding */ getChainEnvVar),\n/* harmony export */   getChainEnvVarDetails: () => (/* binding */ getChainEnvVarDetails),\n/* harmony export */   getChainEnvVarNames: () => (/* binding */ getChainEnvVarNames),\n/* harmony export */   getChainIdHex: () => (/* binding */ getChainIdHex),\n/* harmony export */   getChainLayer: () => (/* binding */ getChainLayer),\n/* harmony export */   getChainRpcUrl: () => (/* binding */ getChainRpcUrl),\n/* harmony export */   getEnsOrgAddress: () => (/* binding */ getEnsOrgAddress),\n/* harmony export */   getEnsOrgName: () => (/* binding */ getEnsOrgName),\n/* harmony export */   getEnsPrivateKey: () => (/* binding */ getEnsPrivateKey),\n/* harmony export */   getSupportedChainIds: () => (/* binding */ getSupportedChainIds),\n/* harmony export */   getWeb3AuthChainSettings: () => (/* binding */ getWeb3AuthChainSettings),\n/* harmony export */   getWeb3AuthClientId: () => (/* binding */ getWeb3AuthClientId),\n/* harmony export */   getWeb3AuthNetwork: () => (/* binding */ getWeb3AuthNetwork),\n/* harmony export */   isChainSupported: () => (/* binding */ isChainSupported),\n/* harmony export */   isL1: () => (/* binding */ isL1),\n/* harmony export */   isL2: () => (/* binding */ isL2),\n/* harmony export */   isPrivateKeyMode: () => (/* binding */ isPrivateKeyMode),\n/* harmony export */   optimismSepolia: () => (/* reexport safe */ viem_chains__WEBPACK_IMPORTED_MODULE_2__.optimismSepolia),\n/* harmony export */   requireChainEnvVar: () => (/* binding */ requireChainEnvVar),\n/* harmony export */   sepolia: () => (/* reexport safe */ viem_chains__WEBPACK_IMPORTED_MODULE_0__.sepolia)\n/* harmony export */ });\n/* harmony import */ var viem_chains__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! viem/chains */ \"(rsc)/../../node_modules/viem/_esm/chains/definitions/sepolia.js\");\n/* harmony import */ var viem_chains__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! viem/chains */ \"(rsc)/../../node_modules/viem/_esm/chains/definitions/baseSepolia.js\");\n/* harmony import */ var viem_chains__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! viem/chains */ \"(rsc)/../../node_modules/viem/_esm/chains/definitions/optimismSepolia.js\");\n/**\n * Centralized Chain Configuration\n *\n * This module provides chain-specific configuration and utilities\n * used throughout the AgenticTrust system.\n */\n\n// Re-export chains for convenience\n\n/**\n * Chain configuration mapping\n */\nconst CHAIN_CONFIG = {\n    11155111: {\n        suffix: 'SEPOLIA',\n        name: 'sepolia',\n        displayName: 'Ethereum Sepolia',\n        layer: 'L1',\n    },\n    84532: {\n        suffix: 'BASE_SEPOLIA',\n        name: 'baseSepolia',\n        displayName: 'Base Sepolia',\n        layer: 'L2',\n    },\n    11155420: {\n        suffix: 'OPTIMISM_SEPOLIA',\n        name: 'optimismSepolia',\n        displayName: 'Optimism Sepolia',\n        layer: 'L2',\n    },\n};\nfunction getChainLayer(chainId) {\n    const cfg = CHAIN_CONFIG[chainId];\n    if (!cfg)\n        throw new Error(`Unsupported chainId: ${chainId}`);\n    return cfg.layer;\n}\nfunction isL1(chainId) {\n    return getChainLayer(chainId) === 'L1';\n}\nfunction isL2(chainId) {\n    return getChainLayer(chainId) === 'L2';\n}\n/**\n * Default chain ID used when no chain is specified\n */\nconst DEFAULT_CHAIN_ID = 11155111; // Ethereum Sepolia\nconst SERVER_CHAIN_RPC_ENV = {\n    11155111: process.env.AGENTIC_TRUST_RPC_URL_SEPOLIA,\n    84532: process.env.AGENTIC_TRUST_RPC_URL_BASE_SEPOLIA,\n    11155420: process.env.AGENTIC_TRUST_RPC_URL_OPTIMISM_SEPOLIA,\n};\nconst CLIENT_CHAIN_RPC_ENV = {\n    11155111: process.env.NEXT_PUBLIC_AGENTIC_TRUST_RPC_URL_SEPOLIA,\n    84532: process.env.NEXT_PUBLIC_AGENTIC_TRUST_RPC_URL_BASE_SEPOLIA,\n    11155420: process.env.NEXT_PUBLIC_AGENTIC_TRUST_RPC_URL_OPTIMISM_SEPOLIA,\n};\nconst SERVER_CHAIN_BUNDLER_ENV = {\n    11155111: process.env.AGENTIC_TRUST_BUNDLER_URL_SEPOLIA,\n    84532: process.env.AGENTIC_TRUST_BUNDLER_URL_BASE_SEPOLIA,\n    11155420: process.env.AGENTIC_TRUST_BUNDLER_URL_OPTIMISM_SEPOLIA,\n};\nconst CLIENT_CHAIN_BUNDLER_ENV = {\n    11155111: process.env.NEXT_PUBLIC_AGENTIC_TRUST_BUNDLER_URL_SEPOLIA,\n    84532: process.env.NEXT_PUBLIC_AGENTIC_TRUST_BUNDLER_URL_BASE_SEPOLIA,\n    11155420: process.env.NEXT_PUBLIC_AGENTIC_TRUST_BUNDLER_URL_OPTIMISM_SEPOLIA,\n};\n// ENS chain-specific variables\nconst SERVER_CHAIN_ENS_PRIVKEY_ENV = {\n    11155111: process.env.AGENTIC_TRUST_ENS_PRIVATE_KEY_SEPOLIA,\n    84532: process.env.AGENTIC_TRUST_ENS_PRIVATE_KEY_BASE_SEPOLIA,\n    11155420: process.env.AGENTIC_TRUST_ENS_PRIVATE_KEY_OPTIMISM_SEPOLIA,\n};\nconst SERVER_CHAIN_ENS_ORG_ADDRESS_ENV = {\n    11155111: process.env.AGENTIC_TRUST_ENS_ORG_ADDRESS_SEPOLIA,\n    84532: process.env.AGENTIC_TRUST_ENS_ORG_ADDRESS_BASE_SEPOLIA,\n    11155420: process.env.AGENTIC_TRUST_ENS_ORG_ADDRESS_OPTIMISM_SEPOLIA,\n};\nconst CLIENT_CHAIN_ENS_ORG_NAME_ENV = {\n    11155111: process.env.NEXT_PUBLIC_AGENTIC_TRUST_ENS_ORG_NAME_SEPOLIA,\n    84532: process.env.NEXT_PUBLIC_AGENTIC_TRUST_ENS_ORG_NAME_BASE_SEPOLIA,\n    11155420: process.env.NEXT_PUBLIC_AGENTIC_TRUST_ENS_ORG_NAME_OPTIMISM_SEPOLIA,\n};\n/**\n * Get chain-specific environment variable\n * @param baseName - Base environment variable name (e.g., 'AGENTIC_TRUST_RPC_URL')\n * @param chainId - Chain ID to get configuration for\n * @returns Chain-specific environment variable value or fallback to base name\n */\nfunction getChainEnvVarDetails(baseName, chainId) {\n    const cfg = CHAIN_CONFIG[chainId];\n    const chainKey = cfg ? `${baseName}_${cfg.suffix}` : `${baseName}_${chainId}`;\n    const fallbackKey = baseName;\n    const chainValue = cfg ? process.env[chainKey] : undefined;\n    const fallbackValue = process.env[fallbackKey];\n    const value = chainValue ?? fallbackValue ?? '';\n    const usedKey = chainValue ? chainKey : fallbackValue ? fallbackKey : chainKey;\n    return {\n        value,\n        chainKey: cfg ? chainKey : fallbackKey,\n        fallbackKey,\n        usedKey,\n    };\n}\nfunction getChainEnvVar(baseName, chainId) {\n    return getChainEnvVarDetails(baseName, chainId).value;\n}\nfunction getChainEnvVarNames(chainId) {\n    const cfg = CHAIN_CONFIG[chainId];\n    if (!cfg) {\n        throw new Error(`Unsupported chainId: ${chainId}`);\n    }\n    return {\n        rpcServer: `AGENTIC_TRUST_RPC_URL_${cfg.suffix}`,\n        rpcClient: `NEXT_PUBLIC_AGENTIC_TRUST_RPC_URL_${cfg.suffix}`,\n        bundlerServer: `AGENTIC_TRUST_BUNDLER_URL_${cfg.suffix}`,\n        bundlerClient: `NEXT_PUBLIC_AGENTIC_TRUST_BUNDLER_URL_${cfg.suffix}`,\n        ensOrgAddressServer: `AGENTIC_TRUST_ENS_ORG_ADDRESS_${cfg.suffix}`,\n        ensOrgNameClient: `NEXT_PUBLIC_AGENTIC_TRUST_ENS_ORG_NAME_${cfg.suffix}`,\n        ensPrivateKeyServer: `AGENTIC_TRUST_ENS_PRIVATE_KEY_${cfg.suffix}`,\n    };\n}\nfunction requireChainEnvVar(baseName, chainId) {\n    const { value, chainKey } = getChainEnvVarDetails(baseName, chainId);\n    if (!value) {\n        throw new Error(`Missing required environment variable: ${chainKey}`);\n    }\n    return value;\n}\n/**\n * Get chain-specific contract address\n * @param baseName - Base environment variable name (e.g., 'AGENTIC_TRUST_ENS_REGISTRY')\n * @param chainId - Chain ID to get configuration for\n * @returns Chain-specific contract address or fallback to base name\n */\nfunction getChainContractAddress(baseName, chainId) {\n    const value = getChainEnvVar(baseName, chainId);\n    return value ? (value.startsWith('0x') ? value : `0x${value}`) : undefined;\n}\n/**\n * Get chain object by chainId\n * @param chainId - Chain ID to get chain object for\n * @returns viem Chain object\n * @throws Error if chainId is not supported\n */\nfunction getChainById(chainId) {\n    const chainConfig = CHAIN_CONFIG[chainId];\n    if (!chainConfig) {\n        throw new Error(`Unsupported chainId: ${chainId}. Supported chains: ${Object.keys(CHAIN_CONFIG).join(', ')}`);\n    }\n    const chainName = chainConfig.name;\n    switch (chainName) {\n        case 'sepolia':\n            return viem_chains__WEBPACK_IMPORTED_MODULE_0__.sepolia;\n        case 'baseSepolia':\n            return viem_chains__WEBPACK_IMPORTED_MODULE_1__.baseSepolia;\n        case 'optimismSepolia':\n            return viem_chains__WEBPACK_IMPORTED_MODULE_2__.optimismSepolia;\n        default:\n            throw new Error(`Chain ${chainName} not implemented`);\n    }\n}\n/**\n * Get all supported chain IDs\n * @returns Array of supported chain IDs\n */\nfunction getSupportedChainIds() {\n    return Object.keys(CHAIN_CONFIG).map(id => parseInt(id, 10));\n}\n/**\n * Check if a chain ID is supported\n * @param chainId - Chain ID to check\n * @returns True if the chain ID is supported\n */\nfunction isChainSupported(chainId) {\n    return chainId in CHAIN_CONFIG;\n}\n/**\n * Get chain configuration by chain ID\n * @param chainId - Chain ID to get configuration for\n * @returns Chain configuration object or null if not supported\n */\nfunction getChainConfig(chainId) {\n    return CHAIN_CONFIG[chainId] || null;\n}\n/**\n * Get chain-specific RPC URL (accessible from both server and client)\n *\n * Requires chain-specific environment variables - throws error if not found:\n * Browser: NEXT_PUBLIC_AGENTIC_TRUST_RPC_URL_{CHAIN_SUFFIX}\n * Server: AGENTIC_TRUST_RPC_URL_{CHAIN_SUFFIX} (preferred) or NEXT_PUBLIC_AGENTIC_TRUST_RPC_URL_{CHAIN_SUFFIX}\n * No generic fallbacks - only chain-specific variables are checked\n *\n * @param chainId - Chain ID to get RPC URL for\n * @returns RPC URL string\n */\nfunction getChainRpcUrl(chainId) {\n    const chainConfig = CHAIN_CONFIG[chainId];\n    if (chainConfig) {\n        // Determine if we're running in browser or server\n        const isBrowser = typeof window !== 'undefined';\n        // Read directly from process.env at runtime instead of using cached values\n        // This ensures we get the current value even if env vars were loaded after module initialization\n        let serverValue;\n        let clientValue;\n        if (chainId === 11155111) {\n            serverValue = process.env.AGENTIC_TRUST_RPC_URL_SEPOLIA;\n            clientValue = process.env.NEXT_PUBLIC_AGENTIC_TRUST_RPC_URL_SEPOLIA;\n        }\n        else if (chainId === 84532) {\n            serverValue = process.env.AGENTIC_TRUST_RPC_URL_BASE_SEPOLIA;\n            clientValue = process.env.NEXT_PUBLIC_AGENTIC_TRUST_RPC_URL_BASE_SEPOLIA;\n        }\n        else if (chainId === 11155420) {\n            serverValue = process.env.AGENTIC_TRUST_RPC_URL_OPTIMISM_SEPOLIA;\n            clientValue = process.env.NEXT_PUBLIC_AGENTIC_TRUST_RPC_URL_OPTIMISM_SEPOLIA;\n        }\n        if (isBrowser) {\n            if (clientValue)\n                return clientValue;\n        }\n        else {\n            if (serverValue)\n                return serverValue;\n            if (clientValue)\n                return clientValue;\n        }\n        // Log all AGENTIC_TRUST variables for debugging\n        const allMatchingKeys = Object.keys(process.env).filter(key => key.startsWith('AGENTIC_TRUST') || key.startsWith('NEXT_PUBLIC_AGENTIC_TRUST'));\n        // No generic fallbacks - throw error if chain-specific variable not configured\n        const envNames = getChainEnvVarNames(chainId);\n        const mask = (val) => (val ? '<set>' : '<missing>');\n        const expectedVar = isBrowser ? envNames.rpcClient : envNames.rpcServer;\n        console.error(`[chainConfig] Missing RPC URL for chain ${chainId} (${chainConfig.name}). Checked env vars ` +\n            `${envNames.rpcServer}=${mask(serverValue)} and ${envNames.rpcClient}=${mask(clientValue)}. ` +\n            `Set ${isBrowser ? envNames.rpcClient : `${envNames.rpcServer} (server) or ${envNames.rpcClient}`}.`);\n        throw new Error(`Missing required RPC URL for chain ${chainId} (${chainConfig.name}). ` +\n            `Set ${expectedVar} environment variable.`);\n    }\n    throw new Error(`Unsupported chain ID: ${chainId}`);\n}\nfunction getChainIdHex(chainId) {\n    return `0x${chainId.toString(16)}`;\n}\nfunction getChainDisplayMetadata(chainId) {\n    const chainConfig = CHAIN_CONFIG[chainId];\n    if (!chainConfig) {\n        throw new Error(`Unsupported chain ID: ${chainId}`);\n    }\n    const chain = getChainById(chainId);\n    const chainIdHex = getChainIdHex(chainId);\n    const rpcUrl = getChainRpcUrl(chainId);\n    const nativeCurrency = chain.nativeCurrency ?? {\n        name: 'Ether',\n        symbol: 'ETH',\n        decimals: 18,\n    };\n    const blockExplorerUrls = [];\n    const defaultExplorerUrl = chain.blockExplorers?.default?.url;\n    if (defaultExplorerUrl) {\n        blockExplorerUrls.push(defaultExplorerUrl);\n    }\n    return {\n        chainId,\n        chainIdHex,\n        chainName: chain.name,\n        displayName: chainConfig.displayName || chain.name,\n        nativeCurrency,\n        rpcUrls: [rpcUrl],\n        blockExplorerUrls,\n    };\n}\nfunction getWeb3AuthChainSettings(chainId) {\n    const metadata = getChainDisplayMetadata(chainId);\n    const nativeCurrency = metadata.nativeCurrency;\n    const rpcTarget = metadata.rpcUrls[0];\n    if (!rpcTarget) {\n        throw new Error(`Missing RPC URL for Web3Auth chain ${chainId}`);\n    }\n    return {\n        chainNamespace: 'eip155',\n        chainId: metadata.chainIdHex,\n        rpcTarget,\n        displayName: metadata.displayName,\n        blockExplorerUrl: metadata.blockExplorerUrls[0],\n        ticker: nativeCurrency.symbol ?? 'ETH',\n        tickerName: nativeCurrency.name ?? 'Ether',\n        decimals: nativeCurrency.decimals ?? 18,\n        nativeCurrency,\n        rpcUrls: metadata.rpcUrls,\n        blockExplorerUrls: metadata.blockExplorerUrls,\n    };\n}\n/**\n * Get chain-specific bundler URL (accessible from both server and client)\n * @param chainId - Chain ID to get bundler URL for\n * @returns Bundler URL string\n */\nfunction getChainBundlerUrl(chainId) {\n    const chainConfig = CHAIN_CONFIG[chainId];\n    if (chainConfig) {\n        // Determine if we're running in browser or server\n        const isBrowser = typeof window !== 'undefined';\n        // Read directly from process.env at runtime instead of using cached values\n        // This ensures we get the current value even if env vars were loaded after module initialization\n        let serverValue;\n        let clientValue;\n        if (chainId === 11155111) {\n            serverValue = process.env.AGENTIC_TRUST_BUNDLER_URL_SEPOLIA;\n            clientValue = process.env.NEXT_PUBLIC_AGENTIC_TRUST_BUNDLER_URL_SEPOLIA;\n            // Debug logging\n            console.log(`[chainConfig] getChainBundlerUrl: chainId=${chainId}, serverValue=${serverValue ? `<set (length: ${serverValue.length})>` : '<missing>'}, clientValue=${clientValue ? `<set>` : '<missing>'}`);\n        }\n        else if (chainId === 84532) {\n            serverValue = process.env.AGENTIC_TRUST_BUNDLER_URL_BASE_SEPOLIA;\n            clientValue = process.env.NEXT_PUBLIC_AGENTIC_TRUST_BUNDLER_URL_BASE_SEPOLIA;\n        }\n        else if (chainId === 11155420) {\n            serverValue = process.env.AGENTIC_TRUST_BUNDLER_URL_OPTIMISM_SEPOLIA;\n            clientValue = process.env.NEXT_PUBLIC_AGENTIC_TRUST_BUNDLER_URL_OPTIMISM_SEPOLIA;\n        }\n        if (isBrowser) {\n            if (clientValue)\n                return clientValue;\n        }\n        else {\n            // Server: try server env var first, then client env var as fallback\n            if (serverValue)\n                return serverValue;\n            if (clientValue)\n                return clientValue;\n        }\n        const envNames = getChainEnvVarNames(chainId);\n        const mask = (val) => (val ? '<set>' : '<missing>');\n        const expectedVar = isBrowser ? envNames.bundlerClient : envNames.bundlerServer;\n        console.error(`[chainConfig] Missing bundler URL for chain ${chainId} (${chainConfig.name}). Checked env vars ` +\n            `${envNames.bundlerServer}=${mask(serverValue)} ` +\n            `and ${envNames.bundlerClient}=${mask(clientValue)}.`);\n        throw new Error(`Missing required bundler URL for chain ${chainId} (${chainConfig.name}). ` +\n            `Set ${expectedVar} environment variable.`);\n    }\n    throw new Error(`Unsupported chain ID: ${chainId}`);\n}\n/**\n * Check if private key mode is enabled (accessible from both server and client)\n * @returns True if private key mode is enabled\n */\nfunction isPrivateKeyMode() {\n    return process.env.NEXT_PUBLIC_AGENTIC_TRUST_USE_PRIVATE_KEY === 'true';\n}\n/**\n * Get ENS organization name (accessible from both server and client), chain-specific.\n * Throws if not configured.\n * @param chainId - target chain (defaults to DEFAULT_CHAIN_ID)\n */\nfunction getEnsOrgName(chainId) {\n    const target = (chainId ?? DEFAULT_CHAIN_ID);\n    const chainConfig = CHAIN_CONFIG[target];\n    const isBrowser = typeof window !== 'undefined';\n    const clientValue = CLIENT_CHAIN_ENS_ORG_NAME_ENV[target];\n    if (clientValue)\n        return clientValue;\n    // Allow server to also read NEXT_PUBLIC_ value (consistency with RPC logic)\n    if (!isBrowser && clientValue)\n        return clientValue;\n    const expectedVar = `NEXT_PUBLIC_AGENTIC_TRUST_ENS_ORG_NAME_${chainConfig.suffix}`;\n    throw new Error(`Missing required ENS org name for chain ${target} (${chainConfig.name}). Set ${expectedVar}.`);\n}\n/**\n * Get ENS org address (server-only), chain-specific. Throws if not configured.\n */\nfunction getEnsOrgAddress(chainId) {\n    const target = chainId;\n    const chainConfig = CHAIN_CONFIG[target];\n    const value = SERVER_CHAIN_ENS_ORG_ADDRESS_ENV[target];\n    if (value && value.startsWith('0x') && value.length === 42)\n        return value;\n    const expectedVar = `AGENTIC_TRUST_ENS_ORG_ADDRESS_${chainConfig.suffix}`;\n    throw new Error(`Missing required ENS org address for chain ${target} (${chainConfig.name}). Set ${expectedVar}.`);\n}\n/**\n * Get ENS private key (server-only), chain-specific. Throws if not configured.\n */\nfunction getEnsPrivateKey(chainId) {\n    const target = chainId;\n    const chainConfig = CHAIN_CONFIG[target];\n    const value = SERVER_CHAIN_ENS_PRIVKEY_ENV[target];\n    if (value)\n        return value.startsWith('0x') ? value : `0x${value}`;\n    const expectedVar = `AGENTIC_TRUST_ENS_PRIVATE_KEY_${chainConfig.suffix}`;\n    throw new Error(`Missing required ENS private key for chain ${target} (${chainConfig.name}). Set ${expectedVar}.`);\n}\n/**\n * Get Web3Auth client ID (accessible from both server and client)\n * @returns Web3Auth client ID\n */\nfunction getWeb3AuthClientId() {\n    return process.env.NEXT_PUBLIC_WEB3AUTH_CLIENT_ID || '';\n}\n/**\n * Get Web3Auth network (accessible from both server and client)\n * @returns Web3Auth network\n */\nfunction getWeb3AuthNetwork() {\n    return process.env.NEXT_PUBLIC_WEB3AUTH_NETWORK || 'sapphire_devnet';\n}\n//# sourceMappingURL=chainConfig.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BhZ2VudGljLXRydXN0L2NvcmUvZGlzdC9zZXJ2ZXIvbGliL2NoYWluQ29uZmlnLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDb0U7QUFDcEU7QUFDaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNPO0FBQ1A7QUFDQTtBQUNBLGdEQUFnRCxRQUFRO0FBQ3hEO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxtQ0FBbUM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLDhCQUE4QixTQUFTLEdBQUcsV0FBVyxPQUFPLFNBQVMsR0FBRyxRQUFRO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLGdEQUFnRCxRQUFRO0FBQ3hEO0FBQ0E7QUFDQSw0Q0FBNEMsV0FBVztBQUN2RCx3REFBd0QsV0FBVztBQUNuRSxvREFBb0QsV0FBVztBQUMvRCxnRUFBZ0UsV0FBVztBQUMzRSw4REFBOEQsV0FBVztBQUN6RSxvRUFBb0UsV0FBVztBQUMvRSw4REFBOEQsV0FBVztBQUN6RTtBQUNBO0FBQ087QUFDUCxZQUFZLGtCQUFrQjtBQUM5QjtBQUNBLGtFQUFrRSxTQUFTO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSwwREFBMEQsTUFBTTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLGdEQUFnRCxRQUFRLHNCQUFzQixxQ0FBcUM7QUFDbkg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsZ0RBQU87QUFDMUI7QUFDQSxtQkFBbUIsb0RBQVc7QUFDOUI7QUFDQSxtQkFBbUIsd0RBQWU7QUFDbEM7QUFDQSxxQ0FBcUMsV0FBVztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DLGtDQUFrQyxjQUFjLGtEQUFrRDtBQUNsRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsU0FBUyxHQUFHLGlCQUFpQjtBQUM5RixlQUFlLG1CQUFtQixHQUFHLG1CQUFtQixNQUFNLG1CQUFtQixHQUFHLGtCQUFrQjtBQUN0RyxtQkFBbUIsb0NBQW9DLG9CQUFvQixjQUFjLG1CQUFtQixFQUFFO0FBQzlHLDhEQUE4RCxTQUFTLEdBQUcsaUJBQWlCO0FBQzNGLG1CQUFtQixhQUFhO0FBQ2hDO0FBQ0EsNkNBQTZDLFFBQVE7QUFDckQ7QUFDTztBQUNQLGdCQUFnQixxQkFBcUI7QUFDckM7QUFDTztBQUNQO0FBQ0E7QUFDQSxpREFBaUQsUUFBUTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELFFBQVE7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLFFBQVEsZ0JBQWdCLCtCQUErQixtQkFBbUIsa0JBQWtCLGdCQUFnQixvQ0FBb0M7QUFDck47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRSxTQUFTLEdBQUcsaUJBQWlCO0FBQ2xHLGVBQWUsdUJBQXVCLEdBQUcsbUJBQW1CO0FBQzVELG1CQUFtQix1QkFBdUIsR0FBRyxrQkFBa0I7QUFDL0Qsa0VBQWtFLFNBQVMsR0FBRyxpQkFBaUI7QUFDL0YsbUJBQW1CLGFBQWE7QUFDaEM7QUFDQSw2Q0FBNkMsUUFBUTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLG1CQUFtQjtBQUNyRiwrREFBK0QsUUFBUSxHQUFHLGlCQUFpQixTQUFTLFlBQVk7QUFDaEg7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsbUJBQW1CO0FBQzVFLGtFQUFrRSxRQUFRLEdBQUcsaUJBQWlCLFNBQVMsWUFBWTtBQUNuSDtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsTUFBTTtBQUMzRCx5REFBeUQsbUJBQW1CO0FBQzVFLGtFQUFrRSxRQUFRLEdBQUcsaUJBQWlCLFNBQVMsWUFBWTtBQUNuSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvYmFyYi9hYS9Bc3NvY2lhdGVkQWNjb3VudHMvbm9kZV9tb2R1bGVzL0BhZ2VudGljLXRydXN0L2NvcmUvZGlzdC9zZXJ2ZXIvbGliL2NoYWluQ29uZmlnLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ2VudHJhbGl6ZWQgQ2hhaW4gQ29uZmlndXJhdGlvblxuICpcbiAqIFRoaXMgbW9kdWxlIHByb3ZpZGVzIGNoYWluLXNwZWNpZmljIGNvbmZpZ3VyYXRpb24gYW5kIHV0aWxpdGllc1xuICogdXNlZCB0aHJvdWdob3V0IHRoZSBBZ2VudGljVHJ1c3Qgc3lzdGVtLlxuICovXG5pbXBvcnQgeyBzZXBvbGlhLCBiYXNlU2Vwb2xpYSwgb3B0aW1pc21TZXBvbGlhIH0gZnJvbSAndmllbS9jaGFpbnMnO1xuLy8gUmUtZXhwb3J0IGNoYWlucyBmb3IgY29udmVuaWVuY2VcbmV4cG9ydCB7IHNlcG9saWEsIGJhc2VTZXBvbGlhLCBvcHRpbWlzbVNlcG9saWEgfTtcbi8qKlxuICogQ2hhaW4gY29uZmlndXJhdGlvbiBtYXBwaW5nXG4gKi9cbmV4cG9ydCBjb25zdCBDSEFJTl9DT05GSUcgPSB7XG4gICAgMTExNTUxMTE6IHtcbiAgICAgICAgc3VmZml4OiAnU0VQT0xJQScsXG4gICAgICAgIG5hbWU6ICdzZXBvbGlhJyxcbiAgICAgICAgZGlzcGxheU5hbWU6ICdFdGhlcmV1bSBTZXBvbGlhJyxcbiAgICAgICAgbGF5ZXI6ICdMMScsXG4gICAgfSxcbiAgICA4NDUzMjoge1xuICAgICAgICBzdWZmaXg6ICdCQVNFX1NFUE9MSUEnLFxuICAgICAgICBuYW1lOiAnYmFzZVNlcG9saWEnLFxuICAgICAgICBkaXNwbGF5TmFtZTogJ0Jhc2UgU2Vwb2xpYScsXG4gICAgICAgIGxheWVyOiAnTDInLFxuICAgIH0sXG4gICAgMTExNTU0MjA6IHtcbiAgICAgICAgc3VmZml4OiAnT1BUSU1JU01fU0VQT0xJQScsXG4gICAgICAgIG5hbWU6ICdvcHRpbWlzbVNlcG9saWEnLFxuICAgICAgICBkaXNwbGF5TmFtZTogJ09wdGltaXNtIFNlcG9saWEnLFxuICAgICAgICBsYXllcjogJ0wyJyxcbiAgICB9LFxufTtcbmV4cG9ydCBmdW5jdGlvbiBnZXRDaGFpbkxheWVyKGNoYWluSWQpIHtcbiAgICBjb25zdCBjZmcgPSBDSEFJTl9DT05GSUdbY2hhaW5JZF07XG4gICAgaWYgKCFjZmcpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgY2hhaW5JZDogJHtjaGFpbklkfWApO1xuICAgIHJldHVybiBjZmcubGF5ZXI7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNMMShjaGFpbklkKSB7XG4gICAgcmV0dXJuIGdldENoYWluTGF5ZXIoY2hhaW5JZCkgPT09ICdMMSc7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNMMihjaGFpbklkKSB7XG4gICAgcmV0dXJuIGdldENoYWluTGF5ZXIoY2hhaW5JZCkgPT09ICdMMic7XG59XG4vKipcbiAqIERlZmF1bHQgY2hhaW4gSUQgdXNlZCB3aGVuIG5vIGNoYWluIGlzIHNwZWNpZmllZFxuICovXG5leHBvcnQgY29uc3QgREVGQVVMVF9DSEFJTl9JRCA9IDExMTU1MTExOyAvLyBFdGhlcmV1bSBTZXBvbGlhXG5jb25zdCBTRVJWRVJfQ0hBSU5fUlBDX0VOViA9IHtcbiAgICAxMTE1NTExMTogcHJvY2Vzcy5lbnYuQUdFTlRJQ19UUlVTVF9SUENfVVJMX1NFUE9MSUEsXG4gICAgODQ1MzI6IHByb2Nlc3MuZW52LkFHRU5USUNfVFJVU1RfUlBDX1VSTF9CQVNFX1NFUE9MSUEsXG4gICAgMTExNTU0MjA6IHByb2Nlc3MuZW52LkFHRU5USUNfVFJVU1RfUlBDX1VSTF9PUFRJTUlTTV9TRVBPTElBLFxufTtcbmNvbnN0IENMSUVOVF9DSEFJTl9SUENfRU5WID0ge1xuICAgIDExMTU1MTExOiBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19BR0VOVElDX1RSVVNUX1JQQ19VUkxfU0VQT0xJQSxcbiAgICA4NDUzMjogcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfQUdFTlRJQ19UUlVTVF9SUENfVVJMX0JBU0VfU0VQT0xJQSxcbiAgICAxMTE1NTQyMDogcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfQUdFTlRJQ19UUlVTVF9SUENfVVJMX09QVElNSVNNX1NFUE9MSUEsXG59O1xuY29uc3QgU0VSVkVSX0NIQUlOX0JVTkRMRVJfRU5WID0ge1xuICAgIDExMTU1MTExOiBwcm9jZXNzLmVudi5BR0VOVElDX1RSVVNUX0JVTkRMRVJfVVJMX1NFUE9MSUEsXG4gICAgODQ1MzI6IHByb2Nlc3MuZW52LkFHRU5USUNfVFJVU1RfQlVORExFUl9VUkxfQkFTRV9TRVBPTElBLFxuICAgIDExMTU1NDIwOiBwcm9jZXNzLmVudi5BR0VOVElDX1RSVVNUX0JVTkRMRVJfVVJMX09QVElNSVNNX1NFUE9MSUEsXG59O1xuY29uc3QgQ0xJRU5UX0NIQUlOX0JVTkRMRVJfRU5WID0ge1xuICAgIDExMTU1MTExOiBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19BR0VOVElDX1RSVVNUX0JVTkRMRVJfVVJMX1NFUE9MSUEsXG4gICAgODQ1MzI6IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0FHRU5USUNfVFJVU1RfQlVORExFUl9VUkxfQkFTRV9TRVBPTElBLFxuICAgIDExMTU1NDIwOiBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19BR0VOVElDX1RSVVNUX0JVTkRMRVJfVVJMX09QVElNSVNNX1NFUE9MSUEsXG59O1xuLy8gRU5TIGNoYWluLXNwZWNpZmljIHZhcmlhYmxlc1xuY29uc3QgU0VSVkVSX0NIQUlOX0VOU19QUklWS0VZX0VOViA9IHtcbiAgICAxMTE1NTExMTogcHJvY2Vzcy5lbnYuQUdFTlRJQ19UUlVTVF9FTlNfUFJJVkFURV9LRVlfU0VQT0xJQSxcbiAgICA4NDUzMjogcHJvY2Vzcy5lbnYuQUdFTlRJQ19UUlVTVF9FTlNfUFJJVkFURV9LRVlfQkFTRV9TRVBPTElBLFxuICAgIDExMTU1NDIwOiBwcm9jZXNzLmVudi5BR0VOVElDX1RSVVNUX0VOU19QUklWQVRFX0tFWV9PUFRJTUlTTV9TRVBPTElBLFxufTtcbmNvbnN0IFNFUlZFUl9DSEFJTl9FTlNfT1JHX0FERFJFU1NfRU5WID0ge1xuICAgIDExMTU1MTExOiBwcm9jZXNzLmVudi5BR0VOVElDX1RSVVNUX0VOU19PUkdfQUREUkVTU19TRVBPTElBLFxuICAgIDg0NTMyOiBwcm9jZXNzLmVudi5BR0VOVElDX1RSVVNUX0VOU19PUkdfQUREUkVTU19CQVNFX1NFUE9MSUEsXG4gICAgMTExNTU0MjA6IHByb2Nlc3MuZW52LkFHRU5USUNfVFJVU1RfRU5TX09SR19BRERSRVNTX09QVElNSVNNX1NFUE9MSUEsXG59O1xuY29uc3QgQ0xJRU5UX0NIQUlOX0VOU19PUkdfTkFNRV9FTlYgPSB7XG4gICAgMTExNTUxMTE6IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0FHRU5USUNfVFJVU1RfRU5TX09SR19OQU1FX1NFUE9MSUEsXG4gICAgODQ1MzI6IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0FHRU5USUNfVFJVU1RfRU5TX09SR19OQU1FX0JBU0VfU0VQT0xJQSxcbiAgICAxMTE1NTQyMDogcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfQUdFTlRJQ19UUlVTVF9FTlNfT1JHX05BTUVfT1BUSU1JU01fU0VQT0xJQSxcbn07XG4vKipcbiAqIEdldCBjaGFpbi1zcGVjaWZpYyBlbnZpcm9ubWVudCB2YXJpYWJsZVxuICogQHBhcmFtIGJhc2VOYW1lIC0gQmFzZSBlbnZpcm9ubWVudCB2YXJpYWJsZSBuYW1lIChlLmcuLCAnQUdFTlRJQ19UUlVTVF9SUENfVVJMJylcbiAqIEBwYXJhbSBjaGFpbklkIC0gQ2hhaW4gSUQgdG8gZ2V0IGNvbmZpZ3VyYXRpb24gZm9yXG4gKiBAcmV0dXJucyBDaGFpbi1zcGVjaWZpYyBlbnZpcm9ubWVudCB2YXJpYWJsZSB2YWx1ZSBvciBmYWxsYmFjayB0byBiYXNlIG5hbWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldENoYWluRW52VmFyRGV0YWlscyhiYXNlTmFtZSwgY2hhaW5JZCkge1xuICAgIGNvbnN0IGNmZyA9IENIQUlOX0NPTkZJR1tjaGFpbklkXTtcbiAgICBjb25zdCBjaGFpbktleSA9IGNmZyA/IGAke2Jhc2VOYW1lfV8ke2NmZy5zdWZmaXh9YCA6IGAke2Jhc2VOYW1lfV8ke2NoYWluSWR9YDtcbiAgICBjb25zdCBmYWxsYmFja0tleSA9IGJhc2VOYW1lO1xuICAgIGNvbnN0IGNoYWluVmFsdWUgPSBjZmcgPyBwcm9jZXNzLmVudltjaGFpbktleV0gOiB1bmRlZmluZWQ7XG4gICAgY29uc3QgZmFsbGJhY2tWYWx1ZSA9IHByb2Nlc3MuZW52W2ZhbGxiYWNrS2V5XTtcbiAgICBjb25zdCB2YWx1ZSA9IGNoYWluVmFsdWUgPz8gZmFsbGJhY2tWYWx1ZSA/PyAnJztcbiAgICBjb25zdCB1c2VkS2V5ID0gY2hhaW5WYWx1ZSA/IGNoYWluS2V5IDogZmFsbGJhY2tWYWx1ZSA/IGZhbGxiYWNrS2V5IDogY2hhaW5LZXk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIGNoYWluS2V5OiBjZmcgPyBjaGFpbktleSA6IGZhbGxiYWNrS2V5LFxuICAgICAgICBmYWxsYmFja0tleSxcbiAgICAgICAgdXNlZEtleSxcbiAgICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldENoYWluRW52VmFyKGJhc2VOYW1lLCBjaGFpbklkKSB7XG4gICAgcmV0dXJuIGdldENoYWluRW52VmFyRGV0YWlscyhiYXNlTmFtZSwgY2hhaW5JZCkudmFsdWU7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0Q2hhaW5FbnZWYXJOYW1lcyhjaGFpbklkKSB7XG4gICAgY29uc3QgY2ZnID0gQ0hBSU5fQ09ORklHW2NoYWluSWRdO1xuICAgIGlmICghY2ZnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgY2hhaW5JZDogJHtjaGFpbklkfWApO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBycGNTZXJ2ZXI6IGBBR0VOVElDX1RSVVNUX1JQQ19VUkxfJHtjZmcuc3VmZml4fWAsXG4gICAgICAgIHJwY0NsaWVudDogYE5FWFRfUFVCTElDX0FHRU5USUNfVFJVU1RfUlBDX1VSTF8ke2NmZy5zdWZmaXh9YCxcbiAgICAgICAgYnVuZGxlclNlcnZlcjogYEFHRU5USUNfVFJVU1RfQlVORExFUl9VUkxfJHtjZmcuc3VmZml4fWAsXG4gICAgICAgIGJ1bmRsZXJDbGllbnQ6IGBORVhUX1BVQkxJQ19BR0VOVElDX1RSVVNUX0JVTkRMRVJfVVJMXyR7Y2ZnLnN1ZmZpeH1gLFxuICAgICAgICBlbnNPcmdBZGRyZXNzU2VydmVyOiBgQUdFTlRJQ19UUlVTVF9FTlNfT1JHX0FERFJFU1NfJHtjZmcuc3VmZml4fWAsXG4gICAgICAgIGVuc09yZ05hbWVDbGllbnQ6IGBORVhUX1BVQkxJQ19BR0VOVElDX1RSVVNUX0VOU19PUkdfTkFNRV8ke2NmZy5zdWZmaXh9YCxcbiAgICAgICAgZW5zUHJpdmF0ZUtleVNlcnZlcjogYEFHRU5USUNfVFJVU1RfRU5TX1BSSVZBVEVfS0VZXyR7Y2ZnLnN1ZmZpeH1gLFxuICAgIH07XG59XG5leHBvcnQgZnVuY3Rpb24gcmVxdWlyZUNoYWluRW52VmFyKGJhc2VOYW1lLCBjaGFpbklkKSB7XG4gICAgY29uc3QgeyB2YWx1ZSwgY2hhaW5LZXkgfSA9IGdldENoYWluRW52VmFyRGV0YWlscyhiYXNlTmFtZSwgY2hhaW5JZCk7XG4gICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE1pc3NpbmcgcmVxdWlyZWQgZW52aXJvbm1lbnQgdmFyaWFibGU6ICR7Y2hhaW5LZXl9YCk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cbi8qKlxuICogR2V0IGNoYWluLXNwZWNpZmljIGNvbnRyYWN0IGFkZHJlc3NcbiAqIEBwYXJhbSBiYXNlTmFtZSAtIEJhc2UgZW52aXJvbm1lbnQgdmFyaWFibGUgbmFtZSAoZS5nLiwgJ0FHRU5USUNfVFJVU1RfRU5TX1JFR0lTVFJZJylcbiAqIEBwYXJhbSBjaGFpbklkIC0gQ2hhaW4gSUQgdG8gZ2V0IGNvbmZpZ3VyYXRpb24gZm9yXG4gKiBAcmV0dXJucyBDaGFpbi1zcGVjaWZpYyBjb250cmFjdCBhZGRyZXNzIG9yIGZhbGxiYWNrIHRvIGJhc2UgbmFtZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q2hhaW5Db250cmFjdEFkZHJlc3MoYmFzZU5hbWUsIGNoYWluSWQpIHtcbiAgICBjb25zdCB2YWx1ZSA9IGdldENoYWluRW52VmFyKGJhc2VOYW1lLCBjaGFpbklkKTtcbiAgICByZXR1cm4gdmFsdWUgPyAodmFsdWUuc3RhcnRzV2l0aCgnMHgnKSA/IHZhbHVlIDogYDB4JHt2YWx1ZX1gKSA6IHVuZGVmaW5lZDtcbn1cbi8qKlxuICogR2V0IGNoYWluIG9iamVjdCBieSBjaGFpbklkXG4gKiBAcGFyYW0gY2hhaW5JZCAtIENoYWluIElEIHRvIGdldCBjaGFpbiBvYmplY3QgZm9yXG4gKiBAcmV0dXJucyB2aWVtIENoYWluIG9iamVjdFxuICogQHRocm93cyBFcnJvciBpZiBjaGFpbklkIGlzIG5vdCBzdXBwb3J0ZWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldENoYWluQnlJZChjaGFpbklkKSB7XG4gICAgY29uc3QgY2hhaW5Db25maWcgPSBDSEFJTl9DT05GSUdbY2hhaW5JZF07XG4gICAgaWYgKCFjaGFpbkNvbmZpZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGNoYWluSWQ6ICR7Y2hhaW5JZH0uIFN1cHBvcnRlZCBjaGFpbnM6ICR7T2JqZWN0LmtleXMoQ0hBSU5fQ09ORklHKS5qb2luKCcsICcpfWApO1xuICAgIH1cbiAgICBjb25zdCBjaGFpbk5hbWUgPSBjaGFpbkNvbmZpZy5uYW1lO1xuICAgIHN3aXRjaCAoY2hhaW5OYW1lKSB7XG4gICAgICAgIGNhc2UgJ3NlcG9saWEnOlxuICAgICAgICAgICAgcmV0dXJuIHNlcG9saWE7XG4gICAgICAgIGNhc2UgJ2Jhc2VTZXBvbGlhJzpcbiAgICAgICAgICAgIHJldHVybiBiYXNlU2Vwb2xpYTtcbiAgICAgICAgY2FzZSAnb3B0aW1pc21TZXBvbGlhJzpcbiAgICAgICAgICAgIHJldHVybiBvcHRpbWlzbVNlcG9saWE7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENoYWluICR7Y2hhaW5OYW1lfSBub3QgaW1wbGVtZW50ZWRgKTtcbiAgICB9XG59XG4vKipcbiAqIEdldCBhbGwgc3VwcG9ydGVkIGNoYWluIElEc1xuICogQHJldHVybnMgQXJyYXkgb2Ygc3VwcG9ydGVkIGNoYWluIElEc1xuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0U3VwcG9ydGVkQ2hhaW5JZHMoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKENIQUlOX0NPTkZJRykubWFwKGlkID0+IHBhcnNlSW50KGlkLCAxMCkpO1xufVxuLyoqXG4gKiBDaGVjayBpZiBhIGNoYWluIElEIGlzIHN1cHBvcnRlZFxuICogQHBhcmFtIGNoYWluSWQgLSBDaGFpbiBJRCB0byBjaGVja1xuICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgY2hhaW4gSUQgaXMgc3VwcG9ydGVkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0NoYWluU3VwcG9ydGVkKGNoYWluSWQpIHtcbiAgICByZXR1cm4gY2hhaW5JZCBpbiBDSEFJTl9DT05GSUc7XG59XG4vKipcbiAqIEdldCBjaGFpbiBjb25maWd1cmF0aW9uIGJ5IGNoYWluIElEXG4gKiBAcGFyYW0gY2hhaW5JZCAtIENoYWluIElEIHRvIGdldCBjb25maWd1cmF0aW9uIGZvclxuICogQHJldHVybnMgQ2hhaW4gY29uZmlndXJhdGlvbiBvYmplY3Qgb3IgbnVsbCBpZiBub3Qgc3VwcG9ydGVkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRDaGFpbkNvbmZpZyhjaGFpbklkKSB7XG4gICAgcmV0dXJuIENIQUlOX0NPTkZJR1tjaGFpbklkXSB8fCBudWxsO1xufVxuLyoqXG4gKiBHZXQgY2hhaW4tc3BlY2lmaWMgUlBDIFVSTCAoYWNjZXNzaWJsZSBmcm9tIGJvdGggc2VydmVyIGFuZCBjbGllbnQpXG4gKlxuICogUmVxdWlyZXMgY2hhaW4tc3BlY2lmaWMgZW52aXJvbm1lbnQgdmFyaWFibGVzIC0gdGhyb3dzIGVycm9yIGlmIG5vdCBmb3VuZDpcbiAqIEJyb3dzZXI6IE5FWFRfUFVCTElDX0FHRU5USUNfVFJVU1RfUlBDX1VSTF97Q0hBSU5fU1VGRklYfVxuICogU2VydmVyOiBBR0VOVElDX1RSVVNUX1JQQ19VUkxfe0NIQUlOX1NVRkZJWH0gKHByZWZlcnJlZCkgb3IgTkVYVF9QVUJMSUNfQUdFTlRJQ19UUlVTVF9SUENfVVJMX3tDSEFJTl9TVUZGSVh9XG4gKiBObyBnZW5lcmljIGZhbGxiYWNrcyAtIG9ubHkgY2hhaW4tc3BlY2lmaWMgdmFyaWFibGVzIGFyZSBjaGVja2VkXG4gKlxuICogQHBhcmFtIGNoYWluSWQgLSBDaGFpbiBJRCB0byBnZXQgUlBDIFVSTCBmb3JcbiAqIEByZXR1cm5zIFJQQyBVUkwgc3RyaW5nXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRDaGFpblJwY1VybChjaGFpbklkKSB7XG4gICAgY29uc3QgY2hhaW5Db25maWcgPSBDSEFJTl9DT05GSUdbY2hhaW5JZF07XG4gICAgaWYgKGNoYWluQ29uZmlnKSB7XG4gICAgICAgIC8vIERldGVybWluZSBpZiB3ZSdyZSBydW5uaW5nIGluIGJyb3dzZXIgb3Igc2VydmVyXG4gICAgICAgIGNvbnN0IGlzQnJvd3NlciA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnO1xuICAgICAgICAvLyBSZWFkIGRpcmVjdGx5IGZyb20gcHJvY2Vzcy5lbnYgYXQgcnVudGltZSBpbnN0ZWFkIG9mIHVzaW5nIGNhY2hlZCB2YWx1ZXNcbiAgICAgICAgLy8gVGhpcyBlbnN1cmVzIHdlIGdldCB0aGUgY3VycmVudCB2YWx1ZSBldmVuIGlmIGVudiB2YXJzIHdlcmUgbG9hZGVkIGFmdGVyIG1vZHVsZSBpbml0aWFsaXphdGlvblxuICAgICAgICBsZXQgc2VydmVyVmFsdWU7XG4gICAgICAgIGxldCBjbGllbnRWYWx1ZTtcbiAgICAgICAgaWYgKGNoYWluSWQgPT09IDExMTU1MTExKSB7XG4gICAgICAgICAgICBzZXJ2ZXJWYWx1ZSA9IHByb2Nlc3MuZW52LkFHRU5USUNfVFJVU1RfUlBDX1VSTF9TRVBPTElBO1xuICAgICAgICAgICAgY2xpZW50VmFsdWUgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19BR0VOVElDX1RSVVNUX1JQQ19VUkxfU0VQT0xJQTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjaGFpbklkID09PSA4NDUzMikge1xuICAgICAgICAgICAgc2VydmVyVmFsdWUgPSBwcm9jZXNzLmVudi5BR0VOVElDX1RSVVNUX1JQQ19VUkxfQkFTRV9TRVBPTElBO1xuICAgICAgICAgICAgY2xpZW50VmFsdWUgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19BR0VOVElDX1RSVVNUX1JQQ19VUkxfQkFTRV9TRVBPTElBO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNoYWluSWQgPT09IDExMTU1NDIwKSB7XG4gICAgICAgICAgICBzZXJ2ZXJWYWx1ZSA9IHByb2Nlc3MuZW52LkFHRU5USUNfVFJVU1RfUlBDX1VSTF9PUFRJTUlTTV9TRVBPTElBO1xuICAgICAgICAgICAgY2xpZW50VmFsdWUgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19BR0VOVElDX1RSVVNUX1JQQ19VUkxfT1BUSU1JU01fU0VQT0xJQTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNCcm93c2VyKSB7XG4gICAgICAgICAgICBpZiAoY2xpZW50VmFsdWUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNsaWVudFZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHNlcnZlclZhbHVlKVxuICAgICAgICAgICAgICAgIHJldHVybiBzZXJ2ZXJWYWx1ZTtcbiAgICAgICAgICAgIGlmIChjbGllbnRWYWx1ZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gY2xpZW50VmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTG9nIGFsbCBBR0VOVElDX1RSVVNUIHZhcmlhYmxlcyBmb3IgZGVidWdnaW5nXG4gICAgICAgIGNvbnN0IGFsbE1hdGNoaW5nS2V5cyA9IE9iamVjdC5rZXlzKHByb2Nlc3MuZW52KS5maWx0ZXIoa2V5ID0+IGtleS5zdGFydHNXaXRoKCdBR0VOVElDX1RSVVNUJykgfHwga2V5LnN0YXJ0c1dpdGgoJ05FWFRfUFVCTElDX0FHRU5USUNfVFJVU1QnKSk7XG4gICAgICAgIC8vIE5vIGdlbmVyaWMgZmFsbGJhY2tzIC0gdGhyb3cgZXJyb3IgaWYgY2hhaW4tc3BlY2lmaWMgdmFyaWFibGUgbm90IGNvbmZpZ3VyZWRcbiAgICAgICAgY29uc3QgZW52TmFtZXMgPSBnZXRDaGFpbkVudlZhck5hbWVzKGNoYWluSWQpO1xuICAgICAgICBjb25zdCBtYXNrID0gKHZhbCkgPT4gKHZhbCA/ICc8c2V0PicgOiAnPG1pc3Npbmc+Jyk7XG4gICAgICAgIGNvbnN0IGV4cGVjdGVkVmFyID0gaXNCcm93c2VyID8gZW52TmFtZXMucnBjQ2xpZW50IDogZW52TmFtZXMucnBjU2VydmVyO1xuICAgICAgICBjb25zb2xlLmVycm9yKGBbY2hhaW5Db25maWddIE1pc3NpbmcgUlBDIFVSTCBmb3IgY2hhaW4gJHtjaGFpbklkfSAoJHtjaGFpbkNvbmZpZy5uYW1lfSkuIENoZWNrZWQgZW52IHZhcnMgYCArXG4gICAgICAgICAgICBgJHtlbnZOYW1lcy5ycGNTZXJ2ZXJ9PSR7bWFzayhzZXJ2ZXJWYWx1ZSl9IGFuZCAke2Vudk5hbWVzLnJwY0NsaWVudH09JHttYXNrKGNsaWVudFZhbHVlKX0uIGAgK1xuICAgICAgICAgICAgYFNldCAke2lzQnJvd3NlciA/IGVudk5hbWVzLnJwY0NsaWVudCA6IGAke2Vudk5hbWVzLnJwY1NlcnZlcn0gKHNlcnZlcikgb3IgJHtlbnZOYW1lcy5ycGNDbGllbnR9YH0uYCk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgTWlzc2luZyByZXF1aXJlZCBSUEMgVVJMIGZvciBjaGFpbiAke2NoYWluSWR9ICgke2NoYWluQ29uZmlnLm5hbWV9KS4gYCArXG4gICAgICAgICAgICBgU2V0ICR7ZXhwZWN0ZWRWYXJ9IGVudmlyb25tZW50IHZhcmlhYmxlLmApO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGNoYWluIElEOiAke2NoYWluSWR9YCk7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0Q2hhaW5JZEhleChjaGFpbklkKSB7XG4gICAgcmV0dXJuIGAweCR7Y2hhaW5JZC50b1N0cmluZygxNil9YDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRDaGFpbkRpc3BsYXlNZXRhZGF0YShjaGFpbklkKSB7XG4gICAgY29uc3QgY2hhaW5Db25maWcgPSBDSEFJTl9DT05GSUdbY2hhaW5JZF07XG4gICAgaWYgKCFjaGFpbkNvbmZpZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGNoYWluIElEOiAke2NoYWluSWR9YCk7XG4gICAgfVxuICAgIGNvbnN0IGNoYWluID0gZ2V0Q2hhaW5CeUlkKGNoYWluSWQpO1xuICAgIGNvbnN0IGNoYWluSWRIZXggPSBnZXRDaGFpbklkSGV4KGNoYWluSWQpO1xuICAgIGNvbnN0IHJwY1VybCA9IGdldENoYWluUnBjVXJsKGNoYWluSWQpO1xuICAgIGNvbnN0IG5hdGl2ZUN1cnJlbmN5ID0gY2hhaW4ubmF0aXZlQ3VycmVuY3kgPz8ge1xuICAgICAgICBuYW1lOiAnRXRoZXInLFxuICAgICAgICBzeW1ib2w6ICdFVEgnLFxuICAgICAgICBkZWNpbWFsczogMTgsXG4gICAgfTtcbiAgICBjb25zdCBibG9ja0V4cGxvcmVyVXJscyA9IFtdO1xuICAgIGNvbnN0IGRlZmF1bHRFeHBsb3JlclVybCA9IGNoYWluLmJsb2NrRXhwbG9yZXJzPy5kZWZhdWx0Py51cmw7XG4gICAgaWYgKGRlZmF1bHRFeHBsb3JlclVybCkge1xuICAgICAgICBibG9ja0V4cGxvcmVyVXJscy5wdXNoKGRlZmF1bHRFeHBsb3JlclVybCk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGNoYWluSWQsXG4gICAgICAgIGNoYWluSWRIZXgsXG4gICAgICAgIGNoYWluTmFtZTogY2hhaW4ubmFtZSxcbiAgICAgICAgZGlzcGxheU5hbWU6IGNoYWluQ29uZmlnLmRpc3BsYXlOYW1lIHx8IGNoYWluLm5hbWUsXG4gICAgICAgIG5hdGl2ZUN1cnJlbmN5LFxuICAgICAgICBycGNVcmxzOiBbcnBjVXJsXSxcbiAgICAgICAgYmxvY2tFeHBsb3JlclVybHMsXG4gICAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRXZWIzQXV0aENoYWluU2V0dGluZ3MoY2hhaW5JZCkge1xuICAgIGNvbnN0IG1ldGFkYXRhID0gZ2V0Q2hhaW5EaXNwbGF5TWV0YWRhdGEoY2hhaW5JZCk7XG4gICAgY29uc3QgbmF0aXZlQ3VycmVuY3kgPSBtZXRhZGF0YS5uYXRpdmVDdXJyZW5jeTtcbiAgICBjb25zdCBycGNUYXJnZXQgPSBtZXRhZGF0YS5ycGNVcmxzWzBdO1xuICAgIGlmICghcnBjVGFyZ2V0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgTWlzc2luZyBSUEMgVVJMIGZvciBXZWIzQXV0aCBjaGFpbiAke2NoYWluSWR9YCk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGNoYWluTmFtZXNwYWNlOiAnZWlwMTU1JyxcbiAgICAgICAgY2hhaW5JZDogbWV0YWRhdGEuY2hhaW5JZEhleCxcbiAgICAgICAgcnBjVGFyZ2V0LFxuICAgICAgICBkaXNwbGF5TmFtZTogbWV0YWRhdGEuZGlzcGxheU5hbWUsXG4gICAgICAgIGJsb2NrRXhwbG9yZXJVcmw6IG1ldGFkYXRhLmJsb2NrRXhwbG9yZXJVcmxzWzBdLFxuICAgICAgICB0aWNrZXI6IG5hdGl2ZUN1cnJlbmN5LnN5bWJvbCA/PyAnRVRIJyxcbiAgICAgICAgdGlja2VyTmFtZTogbmF0aXZlQ3VycmVuY3kubmFtZSA/PyAnRXRoZXInLFxuICAgICAgICBkZWNpbWFsczogbmF0aXZlQ3VycmVuY3kuZGVjaW1hbHMgPz8gMTgsXG4gICAgICAgIG5hdGl2ZUN1cnJlbmN5LFxuICAgICAgICBycGNVcmxzOiBtZXRhZGF0YS5ycGNVcmxzLFxuICAgICAgICBibG9ja0V4cGxvcmVyVXJsczogbWV0YWRhdGEuYmxvY2tFeHBsb3JlclVybHMsXG4gICAgfTtcbn1cbi8qKlxuICogR2V0IGNoYWluLXNwZWNpZmljIGJ1bmRsZXIgVVJMIChhY2Nlc3NpYmxlIGZyb20gYm90aCBzZXJ2ZXIgYW5kIGNsaWVudClcbiAqIEBwYXJhbSBjaGFpbklkIC0gQ2hhaW4gSUQgdG8gZ2V0IGJ1bmRsZXIgVVJMIGZvclxuICogQHJldHVybnMgQnVuZGxlciBVUkwgc3RyaW5nXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRDaGFpbkJ1bmRsZXJVcmwoY2hhaW5JZCkge1xuICAgIGNvbnN0IGNoYWluQ29uZmlnID0gQ0hBSU5fQ09ORklHW2NoYWluSWRdO1xuICAgIGlmIChjaGFpbkNvbmZpZykge1xuICAgICAgICAvLyBEZXRlcm1pbmUgaWYgd2UncmUgcnVubmluZyBpbiBicm93c2VyIG9yIHNlcnZlclxuICAgICAgICBjb25zdCBpc0Jyb3dzZXIgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJztcbiAgICAgICAgLy8gUmVhZCBkaXJlY3RseSBmcm9tIHByb2Nlc3MuZW52IGF0IHJ1bnRpbWUgaW5zdGVhZCBvZiB1c2luZyBjYWNoZWQgdmFsdWVzXG4gICAgICAgIC8vIFRoaXMgZW5zdXJlcyB3ZSBnZXQgdGhlIGN1cnJlbnQgdmFsdWUgZXZlbiBpZiBlbnYgdmFycyB3ZXJlIGxvYWRlZCBhZnRlciBtb2R1bGUgaW5pdGlhbGl6YXRpb25cbiAgICAgICAgbGV0IHNlcnZlclZhbHVlO1xuICAgICAgICBsZXQgY2xpZW50VmFsdWU7XG4gICAgICAgIGlmIChjaGFpbklkID09PSAxMTE1NTExMSkge1xuICAgICAgICAgICAgc2VydmVyVmFsdWUgPSBwcm9jZXNzLmVudi5BR0VOVElDX1RSVVNUX0JVTkRMRVJfVVJMX1NFUE9MSUE7XG4gICAgICAgICAgICBjbGllbnRWYWx1ZSA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0FHRU5USUNfVFJVU1RfQlVORExFUl9VUkxfU0VQT0xJQTtcbiAgICAgICAgICAgIC8vIERlYnVnIGxvZ2dpbmdcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbY2hhaW5Db25maWddIGdldENoYWluQnVuZGxlclVybDogY2hhaW5JZD0ke2NoYWluSWR9LCBzZXJ2ZXJWYWx1ZT0ke3NlcnZlclZhbHVlID8gYDxzZXQgKGxlbmd0aDogJHtzZXJ2ZXJWYWx1ZS5sZW5ndGh9KT5gIDogJzxtaXNzaW5nPid9LCBjbGllbnRWYWx1ZT0ke2NsaWVudFZhbHVlID8gYDxzZXQ+YCA6ICc8bWlzc2luZz4nfWApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNoYWluSWQgPT09IDg0NTMyKSB7XG4gICAgICAgICAgICBzZXJ2ZXJWYWx1ZSA9IHByb2Nlc3MuZW52LkFHRU5USUNfVFJVU1RfQlVORExFUl9VUkxfQkFTRV9TRVBPTElBO1xuICAgICAgICAgICAgY2xpZW50VmFsdWUgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19BR0VOVElDX1RSVVNUX0JVTkRMRVJfVVJMX0JBU0VfU0VQT0xJQTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjaGFpbklkID09PSAxMTE1NTQyMCkge1xuICAgICAgICAgICAgc2VydmVyVmFsdWUgPSBwcm9jZXNzLmVudi5BR0VOVElDX1RSVVNUX0JVTkRMRVJfVVJMX09QVElNSVNNX1NFUE9MSUE7XG4gICAgICAgICAgICBjbGllbnRWYWx1ZSA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0FHRU5USUNfVFJVU1RfQlVORExFUl9VUkxfT1BUSU1JU01fU0VQT0xJQTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNCcm93c2VyKSB7XG4gICAgICAgICAgICBpZiAoY2xpZW50VmFsdWUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNsaWVudFZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gU2VydmVyOiB0cnkgc2VydmVyIGVudiB2YXIgZmlyc3QsIHRoZW4gY2xpZW50IGVudiB2YXIgYXMgZmFsbGJhY2tcbiAgICAgICAgICAgIGlmIChzZXJ2ZXJWYWx1ZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VydmVyVmFsdWU7XG4gICAgICAgICAgICBpZiAoY2xpZW50VmFsdWUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNsaWVudFZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVudk5hbWVzID0gZ2V0Q2hhaW5FbnZWYXJOYW1lcyhjaGFpbklkKTtcbiAgICAgICAgY29uc3QgbWFzayA9ICh2YWwpID0+ICh2YWwgPyAnPHNldD4nIDogJzxtaXNzaW5nPicpO1xuICAgICAgICBjb25zdCBleHBlY3RlZFZhciA9IGlzQnJvd3NlciA/IGVudk5hbWVzLmJ1bmRsZXJDbGllbnQgOiBlbnZOYW1lcy5idW5kbGVyU2VydmVyO1xuICAgICAgICBjb25zb2xlLmVycm9yKGBbY2hhaW5Db25maWddIE1pc3NpbmcgYnVuZGxlciBVUkwgZm9yIGNoYWluICR7Y2hhaW5JZH0gKCR7Y2hhaW5Db25maWcubmFtZX0pLiBDaGVja2VkIGVudiB2YXJzIGAgK1xuICAgICAgICAgICAgYCR7ZW52TmFtZXMuYnVuZGxlclNlcnZlcn09JHttYXNrKHNlcnZlclZhbHVlKX0gYCArXG4gICAgICAgICAgICBgYW5kICR7ZW52TmFtZXMuYnVuZGxlckNsaWVudH09JHttYXNrKGNsaWVudFZhbHVlKX0uYCk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgTWlzc2luZyByZXF1aXJlZCBidW5kbGVyIFVSTCBmb3IgY2hhaW4gJHtjaGFpbklkfSAoJHtjaGFpbkNvbmZpZy5uYW1lfSkuIGAgK1xuICAgICAgICAgICAgYFNldCAke2V4cGVjdGVkVmFyfSBlbnZpcm9ubWVudCB2YXJpYWJsZS5gKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBjaGFpbiBJRDogJHtjaGFpbklkfWApO1xufVxuLyoqXG4gKiBDaGVjayBpZiBwcml2YXRlIGtleSBtb2RlIGlzIGVuYWJsZWQgKGFjY2Vzc2libGUgZnJvbSBib3RoIHNlcnZlciBhbmQgY2xpZW50KVxuICogQHJldHVybnMgVHJ1ZSBpZiBwcml2YXRlIGtleSBtb2RlIGlzIGVuYWJsZWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzUHJpdmF0ZUtleU1vZGUoKSB7XG4gICAgcmV0dXJuIHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0FHRU5USUNfVFJVU1RfVVNFX1BSSVZBVEVfS0VZID09PSAndHJ1ZSc7XG59XG4vKipcbiAqIEdldCBFTlMgb3JnYW5pemF0aW9uIG5hbWUgKGFjY2Vzc2libGUgZnJvbSBib3RoIHNlcnZlciBhbmQgY2xpZW50KSwgY2hhaW4tc3BlY2lmaWMuXG4gKiBUaHJvd3MgaWYgbm90IGNvbmZpZ3VyZWQuXG4gKiBAcGFyYW0gY2hhaW5JZCAtIHRhcmdldCBjaGFpbiAoZGVmYXVsdHMgdG8gREVGQVVMVF9DSEFJTl9JRClcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEVuc09yZ05hbWUoY2hhaW5JZCkge1xuICAgIGNvbnN0IHRhcmdldCA9IChjaGFpbklkID8/IERFRkFVTFRfQ0hBSU5fSUQpO1xuICAgIGNvbnN0IGNoYWluQ29uZmlnID0gQ0hBSU5fQ09ORklHW3RhcmdldF07XG4gICAgY29uc3QgaXNCcm93c2VyID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCc7XG4gICAgY29uc3QgY2xpZW50VmFsdWUgPSBDTElFTlRfQ0hBSU5fRU5TX09SR19OQU1FX0VOVlt0YXJnZXRdO1xuICAgIGlmIChjbGllbnRWYWx1ZSlcbiAgICAgICAgcmV0dXJuIGNsaWVudFZhbHVlO1xuICAgIC8vIEFsbG93IHNlcnZlciB0byBhbHNvIHJlYWQgTkVYVF9QVUJMSUNfIHZhbHVlIChjb25zaXN0ZW5jeSB3aXRoIFJQQyBsb2dpYylcbiAgICBpZiAoIWlzQnJvd3NlciAmJiBjbGllbnRWYWx1ZSlcbiAgICAgICAgcmV0dXJuIGNsaWVudFZhbHVlO1xuICAgIGNvbnN0IGV4cGVjdGVkVmFyID0gYE5FWFRfUFVCTElDX0FHRU5USUNfVFJVU1RfRU5TX09SR19OQU1FXyR7Y2hhaW5Db25maWcuc3VmZml4fWA7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBNaXNzaW5nIHJlcXVpcmVkIEVOUyBvcmcgbmFtZSBmb3IgY2hhaW4gJHt0YXJnZXR9ICgke2NoYWluQ29uZmlnLm5hbWV9KS4gU2V0ICR7ZXhwZWN0ZWRWYXJ9LmApO1xufVxuLyoqXG4gKiBHZXQgRU5TIG9yZyBhZGRyZXNzIChzZXJ2ZXItb25seSksIGNoYWluLXNwZWNpZmljLiBUaHJvd3MgaWYgbm90IGNvbmZpZ3VyZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRFbnNPcmdBZGRyZXNzKGNoYWluSWQpIHtcbiAgICBjb25zdCB0YXJnZXQgPSBjaGFpbklkO1xuICAgIGNvbnN0IGNoYWluQ29uZmlnID0gQ0hBSU5fQ09ORklHW3RhcmdldF07XG4gICAgY29uc3QgdmFsdWUgPSBTRVJWRVJfQ0hBSU5fRU5TX09SR19BRERSRVNTX0VOVlt0YXJnZXRdO1xuICAgIGlmICh2YWx1ZSAmJiB2YWx1ZS5zdGFydHNXaXRoKCcweCcpICYmIHZhbHVlLmxlbmd0aCA9PT0gNDIpXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICBjb25zdCBleHBlY3RlZFZhciA9IGBBR0VOVElDX1RSVVNUX0VOU19PUkdfQUREUkVTU18ke2NoYWluQ29uZmlnLnN1ZmZpeH1gO1xuICAgIHRocm93IG5ldyBFcnJvcihgTWlzc2luZyByZXF1aXJlZCBFTlMgb3JnIGFkZHJlc3MgZm9yIGNoYWluICR7dGFyZ2V0fSAoJHtjaGFpbkNvbmZpZy5uYW1lfSkuIFNldCAke2V4cGVjdGVkVmFyfS5gKTtcbn1cbi8qKlxuICogR2V0IEVOUyBwcml2YXRlIGtleSAoc2VydmVyLW9ubHkpLCBjaGFpbi1zcGVjaWZpYy4gVGhyb3dzIGlmIG5vdCBjb25maWd1cmVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0RW5zUHJpdmF0ZUtleShjaGFpbklkKSB7XG4gICAgY29uc3QgdGFyZ2V0ID0gY2hhaW5JZDtcbiAgICBjb25zdCBjaGFpbkNvbmZpZyA9IENIQUlOX0NPTkZJR1t0YXJnZXRdO1xuICAgIGNvbnN0IHZhbHVlID0gU0VSVkVSX0NIQUlOX0VOU19QUklWS0VZX0VOVlt0YXJnZXRdO1xuICAgIGlmICh2YWx1ZSlcbiAgICAgICAgcmV0dXJuIHZhbHVlLnN0YXJ0c1dpdGgoJzB4JykgPyB2YWx1ZSA6IGAweCR7dmFsdWV9YDtcbiAgICBjb25zdCBleHBlY3RlZFZhciA9IGBBR0VOVElDX1RSVVNUX0VOU19QUklWQVRFX0tFWV8ke2NoYWluQ29uZmlnLnN1ZmZpeH1gO1xuICAgIHRocm93IG5ldyBFcnJvcihgTWlzc2luZyByZXF1aXJlZCBFTlMgcHJpdmF0ZSBrZXkgZm9yIGNoYWluICR7dGFyZ2V0fSAoJHtjaGFpbkNvbmZpZy5uYW1lfSkuIFNldCAke2V4cGVjdGVkVmFyfS5gKTtcbn1cbi8qKlxuICogR2V0IFdlYjNBdXRoIGNsaWVudCBJRCAoYWNjZXNzaWJsZSBmcm9tIGJvdGggc2VydmVyIGFuZCBjbGllbnQpXG4gKiBAcmV0dXJucyBXZWIzQXV0aCBjbGllbnQgSURcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFdlYjNBdXRoQ2xpZW50SWQoKSB7XG4gICAgcmV0dXJuIHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX1dFQjNBVVRIX0NMSUVOVF9JRCB8fCAnJztcbn1cbi8qKlxuICogR2V0IFdlYjNBdXRoIG5ldHdvcmsgKGFjY2Vzc2libGUgZnJvbSBib3RoIHNlcnZlciBhbmQgY2xpZW50KVxuICogQHJldHVybnMgV2ViM0F1dGggbmV0d29ya1xuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0V2ViM0F1dGhOZXR3b3JrKCkge1xuICAgIHJldHVybiBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19XRUIzQVVUSF9ORVRXT1JLIHx8ICdzYXBwaGlyZV9kZXZuZXQnO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2hhaW5Db25maWcuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@agentic-trust/core/dist/server/lib/chainConfig.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@agentic-trust/core/dist/server/lib/delegationAssociation.js":
/*!***************************************************************************************!*\
  !*** ../../node_modules/@agentic-trust/core/dist/server/lib/delegationAssociation.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createDelegationAssociationWithIpfs: () => (/* binding */ createDelegationAssociationWithIpfs)\n/* harmony export */ });\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ethers */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ethers */ \"(rsc)/../../node_modules/ethers/lib.esm/address/address.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ethers */ \"(rsc)/../../node_modules/ethers/lib.esm/abi/abi-coder.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ethers */ \"(rsc)/../../node_modules/ethers/lib.esm/hash/id.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ethers */ \"(rsc)/../../node_modules/ethers/lib.esm/crypto/keccak.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ethers */ \"(rsc)/../../node_modules/ethers/lib.esm/hash/solidity.js\");\n/* harmony import */ var _association__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./association */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/lib/association.js\");\n/* harmony import */ var _ipfs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ipfs */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/lib/ipfs.js\");\n\n\n\nconst U40_MAX = 1099511627775; // 2^40-1\nfunction clampU40(n) {\n    if (!Number.isFinite(n) || n < 0)\n        return 0;\n    return Math.min(Math.floor(n), U40_MAX);\n}\nfunction toMinimalBigEndianBytes(n) {\n    if (n === 0n)\n        return new Uint8Array([0]);\n    let hex = n.toString(16);\n    if (hex.length % 2)\n        hex = `0${hex}`;\n    return ethers__WEBPACK_IMPORTED_MODULE_2__.getBytes(`0x${hex}`);\n}\n// Mirrors `InteroperableAddress.formatEvmV1(chainid, addr)` from the ERC-8092 reference.\nfunction formatEvmV1(chainId, address) {\n    const addr = ethers__WEBPACK_IMPORTED_MODULE_3__.getAddress(address);\n    const chainRef = toMinimalBigEndianBytes(BigInt(chainId));\n    const head = ethers__WEBPACK_IMPORTED_MODULE_2__.getBytes('0x00010000');\n    const out = ethers__WEBPACK_IMPORTED_MODULE_2__.concat([\n        head,\n        new Uint8Array([chainRef.length]),\n        chainRef,\n        new Uint8Array([20]),\n        ethers__WEBPACK_IMPORTED_MODULE_2__.getBytes(addr),\n    ]);\n    return ethers__WEBPACK_IMPORTED_MODULE_2__.hexlify(out);\n}\nfunction erc8092RecordDigest(rec) {\n    const abiCoder = ethers__WEBPACK_IMPORTED_MODULE_4__.AbiCoder.defaultAbiCoder();\n    const DOMAIN_TYPEHASH = ethers__WEBPACK_IMPORTED_MODULE_5__.id('EIP712Domain(string name,string version)');\n    const NAME_HASH = ethers__WEBPACK_IMPORTED_MODULE_5__.id('AssociatedAccounts');\n    const VERSION_HASH = ethers__WEBPACK_IMPORTED_MODULE_5__.id('1');\n    const MESSAGE_TYPEHASH = ethers__WEBPACK_IMPORTED_MODULE_5__.id('AssociatedAccountRecord(bytes initiator,bytes approver,uint40 validAt,uint40 validUntil,bytes4 interfaceId,bytes data)');\n    const domainSeparator = ethers__WEBPACK_IMPORTED_MODULE_6__.keccak256(abiCoder.encode(['bytes32', 'bytes32', 'bytes32'], [DOMAIN_TYPEHASH, NAME_HASH, VERSION_HASH]));\n    const hashStruct = ethers__WEBPACK_IMPORTED_MODULE_6__.keccak256(abiCoder.encode(['bytes32', 'bytes32', 'bytes32', 'uint40', 'uint40', 'bytes4', 'bytes32'], [\n        MESSAGE_TYPEHASH,\n        ethers__WEBPACK_IMPORTED_MODULE_6__.keccak256(rec.initiator),\n        ethers__WEBPACK_IMPORTED_MODULE_6__.keccak256(rec.approver),\n        rec.validAt,\n        rec.validUntil,\n        rec.interfaceId,\n        ethers__WEBPACK_IMPORTED_MODULE_6__.keccak256(rec.data),\n    ]));\n    return ethers__WEBPACK_IMPORTED_MODULE_6__.keccak256(ethers__WEBPACK_IMPORTED_MODULE_7__.solidityPacked(['bytes2', 'bytes32', 'bytes32'], ['0x1901', domainSeparator, hashStruct]));\n}\n/**\n * Create an ERC-8092 Delegation association payload with an IPFS-hosted JSON payload.\n * The return value is approver-signed; the client can add initiatorSignature and store it on-chain.\n */\nasync function createDelegationAssociationWithIpfs(params) {\n    const chainIdNum = Number(params.chainId);\n    if (!Number.isFinite(chainIdNum) || chainIdNum <= 0) {\n        throw new Error(`Invalid chainId for delegation association: ${String(params.chainId)}`);\n    }\n    const initiatorAddress = ethers__WEBPACK_IMPORTED_MODULE_3__.getAddress(params.initiatorAddress);\n    const approverAddress = ethers__WEBPACK_IMPORTED_MODULE_3__.getAddress(params.approverAddress);\n    const createdAt = new Date().toISOString();\n    const payload = { ...params.payload, type: params.payloadType, createdAt };\n    // Upload the full payload to IPFS (best-effort)\n    let payloadTokenUri = null;\n    let payloadCid = null;\n    try {\n        const ipfs = (0,_ipfs__WEBPACK_IMPORTED_MODULE_1__.getIPFSStorage)();\n        const upload = await ipfs.upload(JSON.stringify(payload, null, 2), 'delegation.json');\n        payloadCid = upload.cid;\n        payloadTokenUri = upload.tokenUri;\n    }\n    catch (ipfsErr) {\n        console.warn('[createDelegationAssociationWithIpfs] Failed to upload payload to IPFS (continuing):', ipfsErr);\n    }\n    const delegationRef = {\n        type: params.payloadType,\n        payloadUri: payloadTokenUri,\n        payloadCid,\n        createdAt,\n    };\n    const data = (0,_association__WEBPACK_IMPORTED_MODULE_0__.encodeAssociationData)({\n        assocType: 1,\n        description: JSON.stringify(delegationRef),\n    });\n    const validAt = clampU40(Math.floor(Date.now() / 1000));\n    const record = {\n        initiator: formatEvmV1(chainIdNum, initiatorAddress),\n        approver: formatEvmV1(chainIdNum, approverAddress),\n        validAt,\n        validUntil: 0,\n        interfaceId: '0x00000000',\n        data,\n    };\n    const associationId = erc8092RecordDigest(record);\n    // IMPORTANT:\n    // Sign using EIP-712 typed data so the signature validates against the raw EIP-712 digest (no EIP-191 prefix).\n    // Our digest scheme uses ONLY domain {name, version} (no chainId/verifyingContract).\n    const approverSignature = (await params.walletClient.signTypedData({\n        account: params.signer,\n        domain: { name: 'AssociatedAccounts', version: '1' },\n        types: {\n            AssociatedAccountRecord: [\n                { name: 'initiator', type: 'bytes' },\n                { name: 'approver', type: 'bytes' },\n                { name: 'validAt', type: 'uint40' },\n                { name: 'validUntil', type: 'uint40' },\n                { name: 'interfaceId', type: 'bytes4' },\n                { name: 'data', type: 'bytes' },\n            ],\n        },\n        primaryType: 'AssociatedAccountRecord',\n        message: {\n            initiator: record.initiator,\n            approver: record.approver,\n            validAt: BigInt(record.validAt),\n            validUntil: BigInt(record.validUntil),\n            interfaceId: record.interfaceId,\n            data: record.data,\n        },\n    }));\n    const sar = {\n        revokedAt: 0,\n        initiatorKeyType: '0x0001',\n        approverKeyType: '0x0001',\n        initiatorSignature: '0x',\n        approverSignature,\n        record,\n    };\n    return {\n        associationId,\n        initiatorAddress,\n        approverAddress,\n        assocType: 1,\n        validAt,\n        validUntil: 0,\n        data,\n        approverSignature,\n        sar,\n        delegation: {\n            type: params.payloadType,\n            payloadUri: payloadTokenUri,\n            payloadCid,\n            createdAt,\n            payload,\n        },\n    };\n}\n//# sourceMappingURL=delegationAssociation.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BhZ2VudGljLXRydXN0L2NvcmUvZGlzdC9zZXJ2ZXIvbGliL2RlbGVnYXRpb25Bc3NvY2lhdGlvbi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBZ0M7QUFDc0I7QUFDZDtBQUN4QywrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsSUFBSTtBQUN0QixXQUFXLDRDQUFlLE1BQU0sSUFBSTtBQUNwQztBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsOENBQWlCO0FBQ2xDO0FBQ0EsaUJBQWlCLDRDQUFlO0FBQ2hDLGdCQUFnQiwwQ0FBYTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsNENBQWU7QUFDdkI7QUFDQSxXQUFXLDJDQUFjO0FBQ3pCO0FBQ0E7QUFDQSxxQkFBcUIsNENBQWU7QUFDcEMsNEJBQTRCLHNDQUFTO0FBQ3JDLHNCQUFzQixzQ0FBUztBQUMvQix5QkFBeUIsc0NBQVM7QUFDbEMsNkJBQTZCLHNDQUFTO0FBQ3RDLDRCQUE0Qiw2Q0FBZ0I7QUFDNUMsdUJBQXVCLDZDQUFnQjtBQUN2QztBQUNBLFFBQVEsNkNBQWdCO0FBQ3hCLFFBQVEsNkNBQWdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLFFBQVEsNkNBQWdCO0FBQ3hCO0FBQ0EsV0FBVyw2Q0FBZ0IsQ0FBQyxrREFBcUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ087QUFDUDtBQUNBO0FBQ0EsdUVBQXVFLHVCQUF1QjtBQUM5RjtBQUNBLDZCQUE2Qiw4Q0FBaUI7QUFDOUMsNEJBQTRCLDhDQUFpQjtBQUM3QztBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixxREFBYztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixtRUFBcUI7QUFDdEM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsZUFBZTtBQUMxRDtBQUNBO0FBQ0Esa0JBQWtCLDBDQUEwQztBQUM1RDtBQUNBO0FBQ0Esa0JBQWtCLGtDQUFrQztBQUNwRCxrQkFBa0IsaUNBQWlDO0FBQ25ELGtCQUFrQixpQ0FBaUM7QUFDbkQsa0JBQWtCLG9DQUFvQztBQUN0RCxrQkFBa0IscUNBQXFDO0FBQ3ZELGtCQUFrQiw2QkFBNkI7QUFDL0M7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvYmFyYi9hYS9Bc3NvY2lhdGVkQWNjb3VudHMvbm9kZV9tb2R1bGVzL0BhZ2VudGljLXRydXN0L2NvcmUvZGlzdC9zZXJ2ZXIvbGliL2RlbGVnYXRpb25Bc3NvY2lhdGlvbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBldGhlcnMgfSBmcm9tICdldGhlcnMnO1xuaW1wb3J0IHsgZW5jb2RlQXNzb2NpYXRpb25EYXRhIH0gZnJvbSAnLi9hc3NvY2lhdGlvbic7XG5pbXBvcnQgeyBnZXRJUEZTU3RvcmFnZSB9IGZyb20gJy4vaXBmcyc7XG5jb25zdCBVNDBfTUFYID0gMTA5OTUxMTYyNzc3NTsgLy8gMl40MC0xXG5mdW5jdGlvbiBjbGFtcFU0MChuKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUobikgfHwgbiA8IDApXG4gICAgICAgIHJldHVybiAwO1xuICAgIHJldHVybiBNYXRoLm1pbihNYXRoLmZsb29yKG4pLCBVNDBfTUFYKTtcbn1cbmZ1bmN0aW9uIHRvTWluaW1hbEJpZ0VuZGlhbkJ5dGVzKG4pIHtcbiAgICBpZiAobiA9PT0gMG4pXG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShbMF0pO1xuICAgIGxldCBoZXggPSBuLnRvU3RyaW5nKDE2KTtcbiAgICBpZiAoaGV4Lmxlbmd0aCAlIDIpXG4gICAgICAgIGhleCA9IGAwJHtoZXh9YDtcbiAgICByZXR1cm4gZXRoZXJzLmdldEJ5dGVzKGAweCR7aGV4fWApO1xufVxuLy8gTWlycm9ycyBgSW50ZXJvcGVyYWJsZUFkZHJlc3MuZm9ybWF0RXZtVjEoY2hhaW5pZCwgYWRkcilgIGZyb20gdGhlIEVSQy04MDkyIHJlZmVyZW5jZS5cbmZ1bmN0aW9uIGZvcm1hdEV2bVYxKGNoYWluSWQsIGFkZHJlc3MpIHtcbiAgICBjb25zdCBhZGRyID0gZXRoZXJzLmdldEFkZHJlc3MoYWRkcmVzcyk7XG4gICAgY29uc3QgY2hhaW5SZWYgPSB0b01pbmltYWxCaWdFbmRpYW5CeXRlcyhCaWdJbnQoY2hhaW5JZCkpO1xuICAgIGNvbnN0IGhlYWQgPSBldGhlcnMuZ2V0Qnl0ZXMoJzB4MDAwMTAwMDAnKTtcbiAgICBjb25zdCBvdXQgPSBldGhlcnMuY29uY2F0KFtcbiAgICAgICAgaGVhZCxcbiAgICAgICAgbmV3IFVpbnQ4QXJyYXkoW2NoYWluUmVmLmxlbmd0aF0pLFxuICAgICAgICBjaGFpblJlZixcbiAgICAgICAgbmV3IFVpbnQ4QXJyYXkoWzIwXSksXG4gICAgICAgIGV0aGVycy5nZXRCeXRlcyhhZGRyKSxcbiAgICBdKTtcbiAgICByZXR1cm4gZXRoZXJzLmhleGxpZnkob3V0KTtcbn1cbmZ1bmN0aW9uIGVyYzgwOTJSZWNvcmREaWdlc3QocmVjKSB7XG4gICAgY29uc3QgYWJpQ29kZXIgPSBldGhlcnMuQWJpQ29kZXIuZGVmYXVsdEFiaUNvZGVyKCk7XG4gICAgY29uc3QgRE9NQUlOX1RZUEVIQVNIID0gZXRoZXJzLmlkKCdFSVA3MTJEb21haW4oc3RyaW5nIG5hbWUsc3RyaW5nIHZlcnNpb24pJyk7XG4gICAgY29uc3QgTkFNRV9IQVNIID0gZXRoZXJzLmlkKCdBc3NvY2lhdGVkQWNjb3VudHMnKTtcbiAgICBjb25zdCBWRVJTSU9OX0hBU0ggPSBldGhlcnMuaWQoJzEnKTtcbiAgICBjb25zdCBNRVNTQUdFX1RZUEVIQVNIID0gZXRoZXJzLmlkKCdBc3NvY2lhdGVkQWNjb3VudFJlY29yZChieXRlcyBpbml0aWF0b3IsYnl0ZXMgYXBwcm92ZXIsdWludDQwIHZhbGlkQXQsdWludDQwIHZhbGlkVW50aWwsYnl0ZXM0IGludGVyZmFjZUlkLGJ5dGVzIGRhdGEpJyk7XG4gICAgY29uc3QgZG9tYWluU2VwYXJhdG9yID0gZXRoZXJzLmtlY2NhazI1NihhYmlDb2Rlci5lbmNvZGUoWydieXRlczMyJywgJ2J5dGVzMzInLCAnYnl0ZXMzMiddLCBbRE9NQUlOX1RZUEVIQVNILCBOQU1FX0hBU0gsIFZFUlNJT05fSEFTSF0pKTtcbiAgICBjb25zdCBoYXNoU3RydWN0ID0gZXRoZXJzLmtlY2NhazI1NihhYmlDb2Rlci5lbmNvZGUoWydieXRlczMyJywgJ2J5dGVzMzInLCAnYnl0ZXMzMicsICd1aW50NDAnLCAndWludDQwJywgJ2J5dGVzNCcsICdieXRlczMyJ10sIFtcbiAgICAgICAgTUVTU0FHRV9UWVBFSEFTSCxcbiAgICAgICAgZXRoZXJzLmtlY2NhazI1NihyZWMuaW5pdGlhdG9yKSxcbiAgICAgICAgZXRoZXJzLmtlY2NhazI1NihyZWMuYXBwcm92ZXIpLFxuICAgICAgICByZWMudmFsaWRBdCxcbiAgICAgICAgcmVjLnZhbGlkVW50aWwsXG4gICAgICAgIHJlYy5pbnRlcmZhY2VJZCxcbiAgICAgICAgZXRoZXJzLmtlY2NhazI1NihyZWMuZGF0YSksXG4gICAgXSkpO1xuICAgIHJldHVybiBldGhlcnMua2VjY2FrMjU2KGV0aGVycy5zb2xpZGl0eVBhY2tlZChbJ2J5dGVzMicsICdieXRlczMyJywgJ2J5dGVzMzInXSwgWycweDE5MDEnLCBkb21haW5TZXBhcmF0b3IsIGhhc2hTdHJ1Y3RdKSk7XG59XG4vKipcbiAqIENyZWF0ZSBhbiBFUkMtODA5MiBEZWxlZ2F0aW9uIGFzc29jaWF0aW9uIHBheWxvYWQgd2l0aCBhbiBJUEZTLWhvc3RlZCBKU09OIHBheWxvYWQuXG4gKiBUaGUgcmV0dXJuIHZhbHVlIGlzIGFwcHJvdmVyLXNpZ25lZDsgdGhlIGNsaWVudCBjYW4gYWRkIGluaXRpYXRvclNpZ25hdHVyZSBhbmQgc3RvcmUgaXQgb24tY2hhaW4uXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjcmVhdGVEZWxlZ2F0aW9uQXNzb2NpYXRpb25XaXRoSXBmcyhwYXJhbXMpIHtcbiAgICBjb25zdCBjaGFpbklkTnVtID0gTnVtYmVyKHBhcmFtcy5jaGFpbklkKTtcbiAgICBpZiAoIU51bWJlci5pc0Zpbml0ZShjaGFpbklkTnVtKSB8fCBjaGFpbklkTnVtIDw9IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGNoYWluSWQgZm9yIGRlbGVnYXRpb24gYXNzb2NpYXRpb246ICR7U3RyaW5nKHBhcmFtcy5jaGFpbklkKX1gKTtcbiAgICB9XG4gICAgY29uc3QgaW5pdGlhdG9yQWRkcmVzcyA9IGV0aGVycy5nZXRBZGRyZXNzKHBhcmFtcy5pbml0aWF0b3JBZGRyZXNzKTtcbiAgICBjb25zdCBhcHByb3ZlckFkZHJlc3MgPSBldGhlcnMuZ2V0QWRkcmVzcyhwYXJhbXMuYXBwcm92ZXJBZGRyZXNzKTtcbiAgICBjb25zdCBjcmVhdGVkQXQgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCk7XG4gICAgY29uc3QgcGF5bG9hZCA9IHsgLi4ucGFyYW1zLnBheWxvYWQsIHR5cGU6IHBhcmFtcy5wYXlsb2FkVHlwZSwgY3JlYXRlZEF0IH07XG4gICAgLy8gVXBsb2FkIHRoZSBmdWxsIHBheWxvYWQgdG8gSVBGUyAoYmVzdC1lZmZvcnQpXG4gICAgbGV0IHBheWxvYWRUb2tlblVyaSA9IG51bGw7XG4gICAgbGV0IHBheWxvYWRDaWQgPSBudWxsO1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGlwZnMgPSBnZXRJUEZTU3RvcmFnZSgpO1xuICAgICAgICBjb25zdCB1cGxvYWQgPSBhd2FpdCBpcGZzLnVwbG9hZChKU09OLnN0cmluZ2lmeShwYXlsb2FkLCBudWxsLCAyKSwgJ2RlbGVnYXRpb24uanNvbicpO1xuICAgICAgICBwYXlsb2FkQ2lkID0gdXBsb2FkLmNpZDtcbiAgICAgICAgcGF5bG9hZFRva2VuVXJpID0gdXBsb2FkLnRva2VuVXJpO1xuICAgIH1cbiAgICBjYXRjaCAoaXBmc0Vycikge1xuICAgICAgICBjb25zb2xlLndhcm4oJ1tjcmVhdGVEZWxlZ2F0aW9uQXNzb2NpYXRpb25XaXRoSXBmc10gRmFpbGVkIHRvIHVwbG9hZCBwYXlsb2FkIHRvIElQRlMgKGNvbnRpbnVpbmcpOicsIGlwZnNFcnIpO1xuICAgIH1cbiAgICBjb25zdCBkZWxlZ2F0aW9uUmVmID0ge1xuICAgICAgICB0eXBlOiBwYXJhbXMucGF5bG9hZFR5cGUsXG4gICAgICAgIHBheWxvYWRVcmk6IHBheWxvYWRUb2tlblVyaSxcbiAgICAgICAgcGF5bG9hZENpZCxcbiAgICAgICAgY3JlYXRlZEF0LFxuICAgIH07XG4gICAgY29uc3QgZGF0YSA9IGVuY29kZUFzc29jaWF0aW9uRGF0YSh7XG4gICAgICAgIGFzc29jVHlwZTogMSxcbiAgICAgICAgZGVzY3JpcHRpb246IEpTT04uc3RyaW5naWZ5KGRlbGVnYXRpb25SZWYpLFxuICAgIH0pO1xuICAgIGNvbnN0IHZhbGlkQXQgPSBjbGFtcFU0MChNYXRoLmZsb29yKERhdGUubm93KCkgLyAxMDAwKSk7XG4gICAgY29uc3QgcmVjb3JkID0ge1xuICAgICAgICBpbml0aWF0b3I6IGZvcm1hdEV2bVYxKGNoYWluSWROdW0sIGluaXRpYXRvckFkZHJlc3MpLFxuICAgICAgICBhcHByb3ZlcjogZm9ybWF0RXZtVjEoY2hhaW5JZE51bSwgYXBwcm92ZXJBZGRyZXNzKSxcbiAgICAgICAgdmFsaWRBdCxcbiAgICAgICAgdmFsaWRVbnRpbDogMCxcbiAgICAgICAgaW50ZXJmYWNlSWQ6ICcweDAwMDAwMDAwJyxcbiAgICAgICAgZGF0YSxcbiAgICB9O1xuICAgIGNvbnN0IGFzc29jaWF0aW9uSWQgPSBlcmM4MDkyUmVjb3JkRGlnZXN0KHJlY29yZCk7XG4gICAgLy8gSU1QT1JUQU5UOlxuICAgIC8vIFNpZ24gdXNpbmcgRUlQLTcxMiB0eXBlZCBkYXRhIHNvIHRoZSBzaWduYXR1cmUgdmFsaWRhdGVzIGFnYWluc3QgdGhlIHJhdyBFSVAtNzEyIGRpZ2VzdCAobm8gRUlQLTE5MSBwcmVmaXgpLlxuICAgIC8vIE91ciBkaWdlc3Qgc2NoZW1lIHVzZXMgT05MWSBkb21haW4ge25hbWUsIHZlcnNpb259IChubyBjaGFpbklkL3ZlcmlmeWluZ0NvbnRyYWN0KS5cbiAgICBjb25zdCBhcHByb3ZlclNpZ25hdHVyZSA9IChhd2FpdCBwYXJhbXMud2FsbGV0Q2xpZW50LnNpZ25UeXBlZERhdGEoe1xuICAgICAgICBhY2NvdW50OiBwYXJhbXMuc2lnbmVyLFxuICAgICAgICBkb21haW46IHsgbmFtZTogJ0Fzc29jaWF0ZWRBY2NvdW50cycsIHZlcnNpb246ICcxJyB9LFxuICAgICAgICB0eXBlczoge1xuICAgICAgICAgICAgQXNzb2NpYXRlZEFjY291bnRSZWNvcmQ6IFtcbiAgICAgICAgICAgICAgICB7IG5hbWU6ICdpbml0aWF0b3InLCB0eXBlOiAnYnl0ZXMnIH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiAnYXBwcm92ZXInLCB0eXBlOiAnYnl0ZXMnIH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiAndmFsaWRBdCcsIHR5cGU6ICd1aW50NDAnIH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiAndmFsaWRVbnRpbCcsIHR5cGU6ICd1aW50NDAnIH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiAnaW50ZXJmYWNlSWQnLCB0eXBlOiAnYnl0ZXM0JyB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogJ2RhdGEnLCB0eXBlOiAnYnl0ZXMnIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICB9LFxuICAgICAgICBwcmltYXJ5VHlwZTogJ0Fzc29jaWF0ZWRBY2NvdW50UmVjb3JkJyxcbiAgICAgICAgbWVzc2FnZToge1xuICAgICAgICAgICAgaW5pdGlhdG9yOiByZWNvcmQuaW5pdGlhdG9yLFxuICAgICAgICAgICAgYXBwcm92ZXI6IHJlY29yZC5hcHByb3ZlcixcbiAgICAgICAgICAgIHZhbGlkQXQ6IEJpZ0ludChyZWNvcmQudmFsaWRBdCksXG4gICAgICAgICAgICB2YWxpZFVudGlsOiBCaWdJbnQocmVjb3JkLnZhbGlkVW50aWwpLFxuICAgICAgICAgICAgaW50ZXJmYWNlSWQ6IHJlY29yZC5pbnRlcmZhY2VJZCxcbiAgICAgICAgICAgIGRhdGE6IHJlY29yZC5kYXRhLFxuICAgICAgICB9LFxuICAgIH0pKTtcbiAgICBjb25zdCBzYXIgPSB7XG4gICAgICAgIHJldm9rZWRBdDogMCxcbiAgICAgICAgaW5pdGlhdG9yS2V5VHlwZTogJzB4MDAwMScsXG4gICAgICAgIGFwcHJvdmVyS2V5VHlwZTogJzB4MDAwMScsXG4gICAgICAgIGluaXRpYXRvclNpZ25hdHVyZTogJzB4JyxcbiAgICAgICAgYXBwcm92ZXJTaWduYXR1cmUsXG4gICAgICAgIHJlY29yZCxcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICAgIGFzc29jaWF0aW9uSWQsXG4gICAgICAgIGluaXRpYXRvckFkZHJlc3MsXG4gICAgICAgIGFwcHJvdmVyQWRkcmVzcyxcbiAgICAgICAgYXNzb2NUeXBlOiAxLFxuICAgICAgICB2YWxpZEF0LFxuICAgICAgICB2YWxpZFVudGlsOiAwLFxuICAgICAgICBkYXRhLFxuICAgICAgICBhcHByb3ZlclNpZ25hdHVyZSxcbiAgICAgICAgc2FyLFxuICAgICAgICBkZWxlZ2F0aW9uOiB7XG4gICAgICAgICAgICB0eXBlOiBwYXJhbXMucGF5bG9hZFR5cGUsXG4gICAgICAgICAgICBwYXlsb2FkVXJpOiBwYXlsb2FkVG9rZW5VcmksXG4gICAgICAgICAgICBwYXlsb2FkQ2lkLFxuICAgICAgICAgICAgY3JlYXRlZEF0LFxuICAgICAgICAgICAgcGF5bG9hZCxcbiAgICAgICAgfSxcbiAgICB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVsZWdhdGlvbkFzc29jaWF0aW9uLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@agentic-trust/core/dist/server/lib/delegationAssociation.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@agentic-trust/core/dist/server/lib/discover.js":
/*!**************************************************************************!*\
  !*** ../../node_modules/@agentic-trust/core/dist/server/lib/discover.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   discoverAgents: () => (/* binding */ discoverAgents)\n/* harmony export */ });\n/* harmony import */ var _chainConfig__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chainConfig */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/lib/chainConfig.js\");\n/**\n * Reusable API-layer helper for agent discovery suitable for Next.js route handlers.\n * Parses common search options and maps core Agent objects into a flat JSON\n * payload that UIs can consume directly.\n */\n\n/**\n * Execute an agents search via the core client and map to a flat API payload.\n *\n * @param req Parsed discovery parameters (page/pageSize/query/params/order*)\n * @param getClient Function returning an initialized AgenticTrustClient (app-specific)\n */\nasync function discoverAgents(req, getClient) {\n    const client = await getClient();\n    const options = {\n        page: typeof req.page === 'number' ? req.page : undefined,\n        pageSize: typeof req.pageSize === 'number' ? req.pageSize : undefined,\n        query: typeof req.query === 'string' && req.query.trim().length > 0 ? req.query.trim() : undefined,\n        params: req.params,\n        orderBy: req.orderBy,\n        orderDirection: req.orderDirection,\n    };\n    const { agents, total, page, pageSize, totalPages } = await client.searchAgents(options);\n    const mapped = {\n        agents: (agents || []).map((agent) => {\n            const raw = agent && typeof agent.data === 'object'\n                ? agent.data\n                : agent;\n            const numeric = (value, fallback) => {\n                if (value === undefined || value === null)\n                    return fallback ?? null;\n                const converted = Number(value);\n                return Number.isFinite(converted) ? converted : fallback ?? null;\n            };\n            const booleanish = (value) => {\n                if (value === undefined)\n                    return undefined;\n                if (value === null)\n                    return null;\n                return Boolean(value);\n            };\n            const stringOrNull = (value) => {\n                if (value === undefined)\n                    return undefined;\n                if (value === null)\n                    return null;\n                return String(value);\n            };\n            const chainId = numeric(raw?.chainId, _chainConfig__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_CHAIN_ID) ?? _chainConfig__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_CHAIN_ID;\n            // Extract MCP endpoint from registration data\n            let mcpEndpoint = undefined;\n            try {\n                // First try to extract from rawJson if available\n                const rawJsonStr = stringOrNull(raw?.rawJson);\n                if (rawJsonStr) {\n                    try {\n                        const registration = JSON.parse(rawJsonStr);\n                        if (registration?.endpoints && Array.isArray(registration.endpoints)) {\n                            const mcpEndpointEntry = registration.endpoints.find((ep) => ep && typeof ep.name === 'string' && (ep.name === 'MCP' || ep.name === 'mcp'));\n                            if (mcpEndpointEntry && typeof mcpEndpointEntry.endpoint === 'string') {\n                                mcpEndpoint = mcpEndpointEntry.endpoint;\n                            }\n                        }\n                    }\n                    catch {\n                        // Ignore JSON parse errors\n                    }\n                }\n                // If not found in rawJson, try to extract from endpoints array if available\n                if (!mcpEndpoint && raw?.endpoints && Array.isArray(raw.endpoints)) {\n                    const mcpEndpointEntry = raw.endpoints.find((ep) => ep && typeof ep.name === 'string' && (ep.name === 'MCP' || ep.name === 'mcp'));\n                    if (mcpEndpointEntry && typeof mcpEndpointEntry.endpoint === 'string') {\n                        mcpEndpoint = mcpEndpointEntry.endpoint;\n                    }\n                }\n            }\n            catch {\n                // Ignore errors in MCP endpoint extraction\n            }\n            // Extract agentCategory from metadata if available\n            let agentCategory = undefined;\n            try {\n                // Check if metadata is available as an object\n                if (raw?.metadata && typeof raw.metadata === 'object' && !Array.isArray(raw.metadata)) {\n                    agentCategory = stringOrNull(raw.metadata?.agentCategory);\n                }\n                // Also check if agentCategory is directly on raw (from GraphQL normalization)\n                if (!agentCategory) {\n                    agentCategory = stringOrNull(raw?.agentCategory);\n                }\n            }\n            catch {\n                // Ignore errors in agentCategory extraction\n            }\n            return {\n                chainId,\n                agentId: stringOrNull(raw?.agentId) ?? '',\n                createdAtTime: numeric(raw?.createdAtTime, 0) ?? 0,\n                agentAccount: String(raw?.agentAccount ?? ''),\n                agentIdentityOwnerAccount: String(raw?.agentIdentityOwnerAccount ?? ''),\n                eoaAgentIdentityOwnerAccount: stringOrNull(raw?.eoaAgentIdentityOwnerAccount) ?? undefined,\n                eoaAgentAccount: stringOrNull(raw?.eoaAgentAccount) ?? undefined,\n                contractAddress: stringOrNull(raw?.contractAddress) ?? undefined,\n                agentName: String(raw?.agentName ?? ''),\n                agentCategory: agentCategory, // Add extracted agentCategory\n                didIdentity: stringOrNull(raw?.didIdentity) ?? undefined,\n                didAccount: stringOrNull(raw?.didAccount) ?? undefined,\n                didName: stringOrNull(raw?.didName) ?? undefined,\n                agentUri: stringOrNull(raw?.agentUri) ?? undefined,\n                createdAtBlock: numeric(raw?.createdAtBlock, 0) ?? 0,\n                updatedAtTime: numeric(raw?.updatedAtTime, null),\n                type: stringOrNull(raw?.type) ?? undefined,\n                description: stringOrNull(raw?.description) ?? undefined,\n                image: stringOrNull(raw?.image) ?? undefined,\n                a2aEndpoint: stringOrNull(raw?.a2aEndpoint) ?? undefined,\n                mcpEndpoint: mcpEndpoint, // Add extracted MCP endpoint\n                supportedTrust: stringOrNull(raw?.supportedTrust) ?? undefined,\n                rawJson: stringOrNull(raw?.rawJson) ?? undefined,\n                agentCardJson: stringOrNull(raw?.agentCardJson) ?? undefined,\n                agentCardReadAt: numeric(raw?.agentCardReadAt, null),\n                did: stringOrNull(raw?.did) ?? undefined,\n                mcp: booleanish(raw?.mcp) ?? undefined,\n                x402support: booleanish(raw?.x402support) ?? undefined,\n                active: booleanish(raw?.active) ?? undefined,\n                // Aggregated metrics\n                feedbackCount: numeric(raw?.feedbackCount, 0),\n                feedbackAverageScore: numeric(raw?.feedbackAverageScore, null),\n                validationPendingCount: numeric(raw?.validationPendingCount, 0),\n                validationCompletedCount: numeric(raw?.validationCompletedCount, 0),\n                validationRequestedCount: numeric(raw?.validationRequestedCount, 0),\n                // Association counts come from the discovery indexer. Keep missing values as null\n                // (do not default to 0) so callers can distinguish \"unknown\" from \"zero\".\n                initiatedAssociationCount: numeric(raw?.initiatedAssociationCount, null),\n                approvedAssociationCount: numeric(raw?.approvedAssociationCount, null),\n                // ATI metrics (keep missing as null)\n                atiOverallScore: numeric(raw?.atiOverallScore, null),\n                atiOverallConfidence: numeric(raw?.atiOverallConfidence, null),\n                atiVersion: stringOrNull(raw?.atiVersion) ?? undefined,\n                atiComputedAt: numeric(raw?.atiComputedAt, null),\n                atiBundleJson: stringOrNull(raw?.atiBundleJson) ?? undefined,\n                // Trust Ledger metrics (keep missing as null)\n                trustLedgerScore: numeric(raw?.trustLedgerScore, null),\n                trustLedgerBadgeCount: numeric(raw?.trustLedgerBadgeCount, null),\n                trustLedgerOverallRank: numeric(raw?.trustLedgerOverallRank, null),\n                trustLedgerCapabilityRank: numeric(raw?.trustLedgerCapabilityRank, null),\n            };\n        }),\n        total,\n        page,\n        pageSize,\n        totalPages,\n    };\n    return mapped;\n}\n//# sourceMappingURL=discover.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BhZ2VudGljLXRydXN0L2NvcmUvZGlzdC9zZXJ2ZXIvbGliL2Rpc2NvdmVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksNENBQTRDO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELDBEQUFnQixLQUFLLDBEQUFnQjtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9iYXJiL2FhL0Fzc29jaWF0ZWRBY2NvdW50cy9ub2RlX21vZHVsZXMvQGFnZW50aWMtdHJ1c3QvY29yZS9kaXN0L3NlcnZlci9saWIvZGlzY292ZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBSZXVzYWJsZSBBUEktbGF5ZXIgaGVscGVyIGZvciBhZ2VudCBkaXNjb3Zlcnkgc3VpdGFibGUgZm9yIE5leHQuanMgcm91dGUgaGFuZGxlcnMuXG4gKiBQYXJzZXMgY29tbW9uIHNlYXJjaCBvcHRpb25zIGFuZCBtYXBzIGNvcmUgQWdlbnQgb2JqZWN0cyBpbnRvIGEgZmxhdCBKU09OXG4gKiBwYXlsb2FkIHRoYXQgVUlzIGNhbiBjb25zdW1lIGRpcmVjdGx5LlxuICovXG5pbXBvcnQgeyBERUZBVUxUX0NIQUlOX0lEIH0gZnJvbSAnLi9jaGFpbkNvbmZpZyc7XG4vKipcbiAqIEV4ZWN1dGUgYW4gYWdlbnRzIHNlYXJjaCB2aWEgdGhlIGNvcmUgY2xpZW50IGFuZCBtYXAgdG8gYSBmbGF0IEFQSSBwYXlsb2FkLlxuICpcbiAqIEBwYXJhbSByZXEgUGFyc2VkIGRpc2NvdmVyeSBwYXJhbWV0ZXJzIChwYWdlL3BhZ2VTaXplL3F1ZXJ5L3BhcmFtcy9vcmRlciopXG4gKiBAcGFyYW0gZ2V0Q2xpZW50IEZ1bmN0aW9uIHJldHVybmluZyBhbiBpbml0aWFsaXplZCBBZ2VudGljVHJ1c3RDbGllbnQgKGFwcC1zcGVjaWZpYylcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGRpc2NvdmVyQWdlbnRzKHJlcSwgZ2V0Q2xpZW50KSB7XG4gICAgY29uc3QgY2xpZW50ID0gYXdhaXQgZ2V0Q2xpZW50KCk7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgcGFnZTogdHlwZW9mIHJlcS5wYWdlID09PSAnbnVtYmVyJyA/IHJlcS5wYWdlIDogdW5kZWZpbmVkLFxuICAgICAgICBwYWdlU2l6ZTogdHlwZW9mIHJlcS5wYWdlU2l6ZSA9PT0gJ251bWJlcicgPyByZXEucGFnZVNpemUgOiB1bmRlZmluZWQsXG4gICAgICAgIHF1ZXJ5OiB0eXBlb2YgcmVxLnF1ZXJ5ID09PSAnc3RyaW5nJyAmJiByZXEucXVlcnkudHJpbSgpLmxlbmd0aCA+IDAgPyByZXEucXVlcnkudHJpbSgpIDogdW5kZWZpbmVkLFxuICAgICAgICBwYXJhbXM6IHJlcS5wYXJhbXMsXG4gICAgICAgIG9yZGVyQnk6IHJlcS5vcmRlckJ5LFxuICAgICAgICBvcmRlckRpcmVjdGlvbjogcmVxLm9yZGVyRGlyZWN0aW9uLFxuICAgIH07XG4gICAgY29uc3QgeyBhZ2VudHMsIHRvdGFsLCBwYWdlLCBwYWdlU2l6ZSwgdG90YWxQYWdlcyB9ID0gYXdhaXQgY2xpZW50LnNlYXJjaEFnZW50cyhvcHRpb25zKTtcbiAgICBjb25zdCBtYXBwZWQgPSB7XG4gICAgICAgIGFnZW50czogKGFnZW50cyB8fCBbXSkubWFwKChhZ2VudCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmF3ID0gYWdlbnQgJiYgdHlwZW9mIGFnZW50LmRhdGEgPT09ICdvYmplY3QnXG4gICAgICAgICAgICAgICAgPyBhZ2VudC5kYXRhXG4gICAgICAgICAgICAgICAgOiBhZ2VudDtcbiAgICAgICAgICAgIGNvbnN0IG51bWVyaWMgPSAodmFsdWUsIGZhbGxiYWNrKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsdWUgPT09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxsYmFjayA/PyBudWxsO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbnZlcnRlZCA9IE51bWJlcih2YWx1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE51bWJlci5pc0Zpbml0ZShjb252ZXJ0ZWQpID8gY29udmVydGVkIDogZmFsbGJhY2sgPz8gbnVsbDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBib29sZWFuaXNoID0gKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICByZXR1cm4gQm9vbGVhbih2YWx1ZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3Qgc3RyaW5nT3JOdWxsID0gKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICByZXR1cm4gU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBjaGFpbklkID0gbnVtZXJpYyhyYXc/LmNoYWluSWQsIERFRkFVTFRfQ0hBSU5fSUQpID8/IERFRkFVTFRfQ0hBSU5fSUQ7XG4gICAgICAgICAgICAvLyBFeHRyYWN0IE1DUCBlbmRwb2ludCBmcm9tIHJlZ2lzdHJhdGlvbiBkYXRhXG4gICAgICAgICAgICBsZXQgbWNwRW5kcG9pbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIC8vIEZpcnN0IHRyeSB0byBleHRyYWN0IGZyb20gcmF3SnNvbiBpZiBhdmFpbGFibGVcbiAgICAgICAgICAgICAgICBjb25zdCByYXdKc29uU3RyID0gc3RyaW5nT3JOdWxsKHJhdz8ucmF3SnNvbik7XG4gICAgICAgICAgICAgICAgaWYgKHJhd0pzb25TdHIpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlZ2lzdHJhdGlvbiA9IEpTT04ucGFyc2UocmF3SnNvblN0cik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVnaXN0cmF0aW9uPy5lbmRwb2ludHMgJiYgQXJyYXkuaXNBcnJheShyZWdpc3RyYXRpb24uZW5kcG9pbnRzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1jcEVuZHBvaW50RW50cnkgPSByZWdpc3RyYXRpb24uZW5kcG9pbnRzLmZpbmQoKGVwKSA9PiBlcCAmJiB0eXBlb2YgZXAubmFtZSA9PT0gJ3N0cmluZycgJiYgKGVwLm5hbWUgPT09ICdNQ1AnIHx8IGVwLm5hbWUgPT09ICdtY3AnKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1jcEVuZHBvaW50RW50cnkgJiYgdHlwZW9mIG1jcEVuZHBvaW50RW50cnkuZW5kcG9pbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1jcEVuZHBvaW50ID0gbWNwRW5kcG9pbnRFbnRyeS5lbmRwb2ludDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2gge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWdub3JlIEpTT04gcGFyc2UgZXJyb3JzXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSWYgbm90IGZvdW5kIGluIHJhd0pzb24sIHRyeSB0byBleHRyYWN0IGZyb20gZW5kcG9pbnRzIGFycmF5IGlmIGF2YWlsYWJsZVxuICAgICAgICAgICAgICAgIGlmICghbWNwRW5kcG9pbnQgJiYgcmF3Py5lbmRwb2ludHMgJiYgQXJyYXkuaXNBcnJheShyYXcuZW5kcG9pbnRzKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtY3BFbmRwb2ludEVudHJ5ID0gcmF3LmVuZHBvaW50cy5maW5kKChlcCkgPT4gZXAgJiYgdHlwZW9mIGVwLm5hbWUgPT09ICdzdHJpbmcnICYmIChlcC5uYW1lID09PSAnTUNQJyB8fCBlcC5uYW1lID09PSAnbWNwJykpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWNwRW5kcG9pbnRFbnRyeSAmJiB0eXBlb2YgbWNwRW5kcG9pbnRFbnRyeS5lbmRwb2ludCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1jcEVuZHBvaW50ID0gbWNwRW5kcG9pbnRFbnRyeS5lbmRwb2ludDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIHtcbiAgICAgICAgICAgICAgICAvLyBJZ25vcmUgZXJyb3JzIGluIE1DUCBlbmRwb2ludCBleHRyYWN0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBFeHRyYWN0IGFnZW50Q2F0ZWdvcnkgZnJvbSBtZXRhZGF0YSBpZiBhdmFpbGFibGVcbiAgICAgICAgICAgIGxldCBhZ2VudENhdGVnb3J5ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiBtZXRhZGF0YSBpcyBhdmFpbGFibGUgYXMgYW4gb2JqZWN0XG4gICAgICAgICAgICAgICAgaWYgKHJhdz8ubWV0YWRhdGEgJiYgdHlwZW9mIHJhdy5tZXRhZGF0YSA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocmF3Lm1ldGFkYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICBhZ2VudENhdGVnb3J5ID0gc3RyaW5nT3JOdWxsKHJhdy5tZXRhZGF0YT8uYWdlbnRDYXRlZ29yeSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEFsc28gY2hlY2sgaWYgYWdlbnRDYXRlZ29yeSBpcyBkaXJlY3RseSBvbiByYXcgKGZyb20gR3JhcGhRTCBub3JtYWxpemF0aW9uKVxuICAgICAgICAgICAgICAgIGlmICghYWdlbnRDYXRlZ29yeSkge1xuICAgICAgICAgICAgICAgICAgICBhZ2VudENhdGVnb3J5ID0gc3RyaW5nT3JOdWxsKHJhdz8uYWdlbnRDYXRlZ29yeSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2gge1xuICAgICAgICAgICAgICAgIC8vIElnbm9yZSBlcnJvcnMgaW4gYWdlbnRDYXRlZ29yeSBleHRyYWN0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGNoYWluSWQsXG4gICAgICAgICAgICAgICAgYWdlbnRJZDogc3RyaW5nT3JOdWxsKHJhdz8uYWdlbnRJZCkgPz8gJycsXG4gICAgICAgICAgICAgICAgY3JlYXRlZEF0VGltZTogbnVtZXJpYyhyYXc/LmNyZWF0ZWRBdFRpbWUsIDApID8/IDAsXG4gICAgICAgICAgICAgICAgYWdlbnRBY2NvdW50OiBTdHJpbmcocmF3Py5hZ2VudEFjY291bnQgPz8gJycpLFxuICAgICAgICAgICAgICAgIGFnZW50SWRlbnRpdHlPd25lckFjY291bnQ6IFN0cmluZyhyYXc/LmFnZW50SWRlbnRpdHlPd25lckFjY291bnQgPz8gJycpLFxuICAgICAgICAgICAgICAgIGVvYUFnZW50SWRlbnRpdHlPd25lckFjY291bnQ6IHN0cmluZ09yTnVsbChyYXc/LmVvYUFnZW50SWRlbnRpdHlPd25lckFjY291bnQpID8/IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBlb2FBZ2VudEFjY291bnQ6IHN0cmluZ09yTnVsbChyYXc/LmVvYUFnZW50QWNjb3VudCkgPz8gdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIGNvbnRyYWN0QWRkcmVzczogc3RyaW5nT3JOdWxsKHJhdz8uY29udHJhY3RBZGRyZXNzKSA/PyB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgYWdlbnROYW1lOiBTdHJpbmcocmF3Py5hZ2VudE5hbWUgPz8gJycpLFxuICAgICAgICAgICAgICAgIGFnZW50Q2F0ZWdvcnk6IGFnZW50Q2F0ZWdvcnksIC8vIEFkZCBleHRyYWN0ZWQgYWdlbnRDYXRlZ29yeVxuICAgICAgICAgICAgICAgIGRpZElkZW50aXR5OiBzdHJpbmdPck51bGwocmF3Py5kaWRJZGVudGl0eSkgPz8gdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIGRpZEFjY291bnQ6IHN0cmluZ09yTnVsbChyYXc/LmRpZEFjY291bnQpID8/IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBkaWROYW1lOiBzdHJpbmdPck51bGwocmF3Py5kaWROYW1lKSA/PyB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgYWdlbnRVcmk6IHN0cmluZ09yTnVsbChyYXc/LmFnZW50VXJpKSA/PyB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgY3JlYXRlZEF0QmxvY2s6IG51bWVyaWMocmF3Py5jcmVhdGVkQXRCbG9jaywgMCkgPz8gMCxcbiAgICAgICAgICAgICAgICB1cGRhdGVkQXRUaW1lOiBudW1lcmljKHJhdz8udXBkYXRlZEF0VGltZSwgbnVsbCksXG4gICAgICAgICAgICAgICAgdHlwZTogc3RyaW5nT3JOdWxsKHJhdz8udHlwZSkgPz8gdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBzdHJpbmdPck51bGwocmF3Py5kZXNjcmlwdGlvbikgPz8gdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIGltYWdlOiBzdHJpbmdPck51bGwocmF3Py5pbWFnZSkgPz8gdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIGEyYUVuZHBvaW50OiBzdHJpbmdPck51bGwocmF3Py5hMmFFbmRwb2ludCkgPz8gdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIG1jcEVuZHBvaW50OiBtY3BFbmRwb2ludCwgLy8gQWRkIGV4dHJhY3RlZCBNQ1AgZW5kcG9pbnRcbiAgICAgICAgICAgICAgICBzdXBwb3J0ZWRUcnVzdDogc3RyaW5nT3JOdWxsKHJhdz8uc3VwcG9ydGVkVHJ1c3QpID8/IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICByYXdKc29uOiBzdHJpbmdPck51bGwocmF3Py5yYXdKc29uKSA/PyB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgYWdlbnRDYXJkSnNvbjogc3RyaW5nT3JOdWxsKHJhdz8uYWdlbnRDYXJkSnNvbikgPz8gdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIGFnZW50Q2FyZFJlYWRBdDogbnVtZXJpYyhyYXc/LmFnZW50Q2FyZFJlYWRBdCwgbnVsbCksXG4gICAgICAgICAgICAgICAgZGlkOiBzdHJpbmdPck51bGwocmF3Py5kaWQpID8/IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBtY3A6IGJvb2xlYW5pc2gocmF3Py5tY3ApID8/IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICB4NDAyc3VwcG9ydDogYm9vbGVhbmlzaChyYXc/Lng0MDJzdXBwb3J0KSA/PyB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgYWN0aXZlOiBib29sZWFuaXNoKHJhdz8uYWN0aXZlKSA/PyB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgLy8gQWdncmVnYXRlZCBtZXRyaWNzXG4gICAgICAgICAgICAgICAgZmVlZGJhY2tDb3VudDogbnVtZXJpYyhyYXc/LmZlZWRiYWNrQ291bnQsIDApLFxuICAgICAgICAgICAgICAgIGZlZWRiYWNrQXZlcmFnZVNjb3JlOiBudW1lcmljKHJhdz8uZmVlZGJhY2tBdmVyYWdlU2NvcmUsIG51bGwpLFxuICAgICAgICAgICAgICAgIHZhbGlkYXRpb25QZW5kaW5nQ291bnQ6IG51bWVyaWMocmF3Py52YWxpZGF0aW9uUGVuZGluZ0NvdW50LCAwKSxcbiAgICAgICAgICAgICAgICB2YWxpZGF0aW9uQ29tcGxldGVkQ291bnQ6IG51bWVyaWMocmF3Py52YWxpZGF0aW9uQ29tcGxldGVkQ291bnQsIDApLFxuICAgICAgICAgICAgICAgIHZhbGlkYXRpb25SZXF1ZXN0ZWRDb3VudDogbnVtZXJpYyhyYXc/LnZhbGlkYXRpb25SZXF1ZXN0ZWRDb3VudCwgMCksXG4gICAgICAgICAgICAgICAgLy8gQXNzb2NpYXRpb24gY291bnRzIGNvbWUgZnJvbSB0aGUgZGlzY292ZXJ5IGluZGV4ZXIuIEtlZXAgbWlzc2luZyB2YWx1ZXMgYXMgbnVsbFxuICAgICAgICAgICAgICAgIC8vIChkbyBub3QgZGVmYXVsdCB0byAwKSBzbyBjYWxsZXJzIGNhbiBkaXN0aW5ndWlzaCBcInVua25vd25cIiBmcm9tIFwiemVyb1wiLlxuICAgICAgICAgICAgICAgIGluaXRpYXRlZEFzc29jaWF0aW9uQ291bnQ6IG51bWVyaWMocmF3Py5pbml0aWF0ZWRBc3NvY2lhdGlvbkNvdW50LCBudWxsKSxcbiAgICAgICAgICAgICAgICBhcHByb3ZlZEFzc29jaWF0aW9uQ291bnQ6IG51bWVyaWMocmF3Py5hcHByb3ZlZEFzc29jaWF0aW9uQ291bnQsIG51bGwpLFxuICAgICAgICAgICAgICAgIC8vIEFUSSBtZXRyaWNzIChrZWVwIG1pc3NpbmcgYXMgbnVsbClcbiAgICAgICAgICAgICAgICBhdGlPdmVyYWxsU2NvcmU6IG51bWVyaWMocmF3Py5hdGlPdmVyYWxsU2NvcmUsIG51bGwpLFxuICAgICAgICAgICAgICAgIGF0aU92ZXJhbGxDb25maWRlbmNlOiBudW1lcmljKHJhdz8uYXRpT3ZlcmFsbENvbmZpZGVuY2UsIG51bGwpLFxuICAgICAgICAgICAgICAgIGF0aVZlcnNpb246IHN0cmluZ09yTnVsbChyYXc/LmF0aVZlcnNpb24pID8/IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBhdGlDb21wdXRlZEF0OiBudW1lcmljKHJhdz8uYXRpQ29tcHV0ZWRBdCwgbnVsbCksXG4gICAgICAgICAgICAgICAgYXRpQnVuZGxlSnNvbjogc3RyaW5nT3JOdWxsKHJhdz8uYXRpQnVuZGxlSnNvbikgPz8gdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIC8vIFRydXN0IExlZGdlciBtZXRyaWNzIChrZWVwIG1pc3NpbmcgYXMgbnVsbClcbiAgICAgICAgICAgICAgICB0cnVzdExlZGdlclNjb3JlOiBudW1lcmljKHJhdz8udHJ1c3RMZWRnZXJTY29yZSwgbnVsbCksXG4gICAgICAgICAgICAgICAgdHJ1c3RMZWRnZXJCYWRnZUNvdW50OiBudW1lcmljKHJhdz8udHJ1c3RMZWRnZXJCYWRnZUNvdW50LCBudWxsKSxcbiAgICAgICAgICAgICAgICB0cnVzdExlZGdlck92ZXJhbGxSYW5rOiBudW1lcmljKHJhdz8udHJ1c3RMZWRnZXJPdmVyYWxsUmFuaywgbnVsbCksXG4gICAgICAgICAgICAgICAgdHJ1c3RMZWRnZXJDYXBhYmlsaXR5UmFuazogbnVtZXJpYyhyYXc/LnRydXN0TGVkZ2VyQ2FwYWJpbGl0eVJhbmssIG51bGwpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSksXG4gICAgICAgIHRvdGFsLFxuICAgICAgICBwYWdlLFxuICAgICAgICBwYWdlU2l6ZSxcbiAgICAgICAgdG90YWxQYWdlcyxcbiAgICB9O1xuICAgIHJldHVybiBtYXBwZWQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kaXNjb3Zlci5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@agentic-trust/core/dist/server/lib/discover.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@agentic-trust/core/dist/server/lib/discoveryErrors.js":
/*!*********************************************************************************!*\
  !*** ../../node_modules/@agentic-trust/core/dist/server/lib/discoveryErrors.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   rethrowDiscoveryError: () => (/* binding */ rethrowDiscoveryError)\n/* harmony export */ });\nfunction extractGraphQLErrorMessages(error) {\n    const messages = [];\n    if (error instanceof Error && typeof error.message === 'string' && error.message.trim()) {\n        messages.push(error.message.trim());\n    }\n    if (typeof error === 'object' &&\n        error !== null &&\n        'response' in error &&\n        typeof error.response === 'object' &&\n        error.response !== null) {\n        const response = error.response;\n        if (Array.isArray(response.errors)) {\n            for (const entry of response.errors) {\n                if (typeof entry?.message === 'string' && entry.message.trim()) {\n                    messages.push(entry.message.trim());\n                }\n            }\n        }\n    }\n    return messages;\n}\nfunction resolveStatus(error) {\n    if (typeof error === 'object' &&\n        error !== null &&\n        'response' in error &&\n        typeof error.response === 'object' &&\n        error.response !== null) {\n        const response = error.response;\n        const status = response.status ?? response.statusCode;\n        if (typeof status === 'number') {\n            return status;\n        }\n    }\n    return undefined;\n}\nfunction isAccessCodeError(error) {\n    const status = resolveStatus(error);\n    const combinedMessage = extractGraphQLErrorMessages(error).join(' ').toLowerCase();\n    if (typeof status === 'number' && (status === 401 || status === 403)) {\n        return true;\n    }\n    if (!combinedMessage) {\n        return false;\n    }\n    return (combinedMessage.includes('access code') ||\n        combinedMessage.includes('authorization header') ||\n        combinedMessage.includes('api key') ||\n        combinedMessage.includes('unauthorized'));\n}\nfunction buildAccessCodeMessage(context) {\n    const prefix = context ? `[AgenticTrust:${context}] ` : '[AgenticTrust] ';\n    return (`${prefix}Missing required environment variable: AGENTIC_TRUST_DISCOVERY_API_KEY. ` +\n        `The discovery API rejected the request because no access code was provided. ` +\n        `Set the AGENTIC_TRUST_DISCOVERY_API_KEY environment variable (or provide the apiKey field when ` +\n        `creating AgenticTrustClient) with your Agentic Trust access code. You can generate or ` +\n        `copy your access code by logging in to https://agentictrust.io and opening the API Keys section.`);\n}\n/**\n * Throws a friendly error message for discovery GraphQL authorization failures.\n * Re-throws the original error if it is unrelated to missing credentials.\n */\nfunction rethrowDiscoveryError(error, context) {\n    if (isAccessCodeError(error)) {\n        const friendlyError = new Error(buildAccessCodeMessage(context));\n        if (error instanceof Error) {\n            friendlyError.cause = error;\n        }\n        throw friendlyError;\n    }\n    if (error instanceof Error) {\n        throw error;\n    }\n    throw new Error((context ? `[AgenticTrust:${context}] ` : '[AgenticTrust] ') + 'Unknown discovery error.');\n}\n//# sourceMappingURL=discoveryErrors.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BhZ2VudGljLXRydXN0L2NvcmUvZGlzdC9zZXJ2ZXIvbGliL2Rpc2NvdmVyeUVycm9ycy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxRQUFRO0FBQ3RELGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFFBQVE7QUFDeEQ7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvYmFyYi9hYS9Bc3NvY2lhdGVkQWNjb3VudHMvbm9kZV9tb2R1bGVzL0BhZ2VudGljLXRydXN0L2NvcmUvZGlzdC9zZXJ2ZXIvbGliL2Rpc2NvdmVyeUVycm9ycy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBleHRyYWN0R3JhcGhRTEVycm9yTWVzc2FnZXMoZXJyb3IpIHtcbiAgICBjb25zdCBtZXNzYWdlcyA9IFtdO1xuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmIHR5cGVvZiBlcnJvci5tZXNzYWdlID09PSAnc3RyaW5nJyAmJiBlcnJvci5tZXNzYWdlLnRyaW0oKSkge1xuICAgICAgICBtZXNzYWdlcy5wdXNoKGVycm9yLm1lc3NhZ2UudHJpbSgpKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBlcnJvciA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgZXJyb3IgIT09IG51bGwgJiZcbiAgICAgICAgJ3Jlc3BvbnNlJyBpbiBlcnJvciAmJlxuICAgICAgICB0eXBlb2YgZXJyb3IucmVzcG9uc2UgPT09ICdvYmplY3QnICYmXG4gICAgICAgIGVycm9yLnJlc3BvbnNlICE9PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gZXJyb3IucmVzcG9uc2U7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHJlc3BvbnNlLmVycm9ycykpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZW50cnkgb2YgcmVzcG9uc2UuZXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBlbnRyeT8ubWVzc2FnZSA9PT0gJ3N0cmluZycgJiYgZW50cnkubWVzc2FnZS50cmltKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZXMucHVzaChlbnRyeS5tZXNzYWdlLnRyaW0oKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtZXNzYWdlcztcbn1cbmZ1bmN0aW9uIHJlc29sdmVTdGF0dXMoZXJyb3IpIHtcbiAgICBpZiAodHlwZW9mIGVycm9yID09PSAnb2JqZWN0JyAmJlxuICAgICAgICBlcnJvciAhPT0gbnVsbCAmJlxuICAgICAgICAncmVzcG9uc2UnIGluIGVycm9yICYmXG4gICAgICAgIHR5cGVvZiBlcnJvci5yZXNwb25zZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgZXJyb3IucmVzcG9uc2UgIT09IG51bGwpIHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBlcnJvci5yZXNwb25zZTtcbiAgICAgICAgY29uc3Qgc3RhdHVzID0gcmVzcG9uc2Uuc3RhdHVzID8/IHJlc3BvbnNlLnN0YXR1c0NvZGU7XG4gICAgICAgIGlmICh0eXBlb2Ygc3RhdHVzID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgcmV0dXJuIHN0YXR1cztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gaXNBY2Nlc3NDb2RlRXJyb3IoZXJyb3IpIHtcbiAgICBjb25zdCBzdGF0dXMgPSByZXNvbHZlU3RhdHVzKGVycm9yKTtcbiAgICBjb25zdCBjb21iaW5lZE1lc3NhZ2UgPSBleHRyYWN0R3JhcGhRTEVycm9yTWVzc2FnZXMoZXJyb3IpLmpvaW4oJyAnKS50b0xvd2VyQ2FzZSgpO1xuICAgIGlmICh0eXBlb2Ygc3RhdHVzID09PSAnbnVtYmVyJyAmJiAoc3RhdHVzID09PSA0MDEgfHwgc3RhdHVzID09PSA0MDMpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoIWNvbWJpbmVkTWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiAoY29tYmluZWRNZXNzYWdlLmluY2x1ZGVzKCdhY2Nlc3MgY29kZScpIHx8XG4gICAgICAgIGNvbWJpbmVkTWVzc2FnZS5pbmNsdWRlcygnYXV0aG9yaXphdGlvbiBoZWFkZXInKSB8fFxuICAgICAgICBjb21iaW5lZE1lc3NhZ2UuaW5jbHVkZXMoJ2FwaSBrZXknKSB8fFxuICAgICAgICBjb21iaW5lZE1lc3NhZ2UuaW5jbHVkZXMoJ3VuYXV0aG9yaXplZCcpKTtcbn1cbmZ1bmN0aW9uIGJ1aWxkQWNjZXNzQ29kZU1lc3NhZ2UoY29udGV4dCkge1xuICAgIGNvbnN0IHByZWZpeCA9IGNvbnRleHQgPyBgW0FnZW50aWNUcnVzdDoke2NvbnRleHR9XSBgIDogJ1tBZ2VudGljVHJ1c3RdICc7XG4gICAgcmV0dXJuIChgJHtwcmVmaXh9TWlzc2luZyByZXF1aXJlZCBlbnZpcm9ubWVudCB2YXJpYWJsZTogQUdFTlRJQ19UUlVTVF9ESVNDT1ZFUllfQVBJX0tFWS4gYCArXG4gICAgICAgIGBUaGUgZGlzY292ZXJ5IEFQSSByZWplY3RlZCB0aGUgcmVxdWVzdCBiZWNhdXNlIG5vIGFjY2VzcyBjb2RlIHdhcyBwcm92aWRlZC4gYCArXG4gICAgICAgIGBTZXQgdGhlIEFHRU5USUNfVFJVU1RfRElTQ09WRVJZX0FQSV9LRVkgZW52aXJvbm1lbnQgdmFyaWFibGUgKG9yIHByb3ZpZGUgdGhlIGFwaUtleSBmaWVsZCB3aGVuIGAgK1xuICAgICAgICBgY3JlYXRpbmcgQWdlbnRpY1RydXN0Q2xpZW50KSB3aXRoIHlvdXIgQWdlbnRpYyBUcnVzdCBhY2Nlc3MgY29kZS4gWW91IGNhbiBnZW5lcmF0ZSBvciBgICtcbiAgICAgICAgYGNvcHkgeW91ciBhY2Nlc3MgY29kZSBieSBsb2dnaW5nIGluIHRvIGh0dHBzOi8vYWdlbnRpY3RydXN0LmlvIGFuZCBvcGVuaW5nIHRoZSBBUEkgS2V5cyBzZWN0aW9uLmApO1xufVxuLyoqXG4gKiBUaHJvd3MgYSBmcmllbmRseSBlcnJvciBtZXNzYWdlIGZvciBkaXNjb3ZlcnkgR3JhcGhRTCBhdXRob3JpemF0aW9uIGZhaWx1cmVzLlxuICogUmUtdGhyb3dzIHRoZSBvcmlnaW5hbCBlcnJvciBpZiBpdCBpcyB1bnJlbGF0ZWQgdG8gbWlzc2luZyBjcmVkZW50aWFscy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJldGhyb3dEaXNjb3ZlcnlFcnJvcihlcnJvciwgY29udGV4dCkge1xuICAgIGlmIChpc0FjY2Vzc0NvZGVFcnJvcihlcnJvcikpIHtcbiAgICAgICAgY29uc3QgZnJpZW5kbHlFcnJvciA9IG5ldyBFcnJvcihidWlsZEFjY2Vzc0NvZGVNZXNzYWdlKGNvbnRleHQpKTtcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgIGZyaWVuZGx5RXJyb3IuY2F1c2UgPSBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBmcmllbmRseUVycm9yO1xuICAgIH1cbiAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKChjb250ZXh0ID8gYFtBZ2VudGljVHJ1c3Q6JHtjb250ZXh0fV0gYCA6ICdbQWdlbnRpY1RydXN0XSAnKSArICdVbmtub3duIGRpc2NvdmVyeSBlcnJvci4nKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRpc2NvdmVyeUVycm9ycy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@agentic-trust/core/dist/server/lib/discoveryErrors.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@agentic-trust/core/dist/server/lib/ipfs.js":
/*!**********************************************************************!*\
  !*** ../../node_modules/@agentic-trust/core/dist/server/lib/ipfs.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createIPFSStorage: () => (/* binding */ createIPFSStorage),\n/* harmony export */   getIPFSStorage: () => (/* binding */ getIPFSStorage),\n/* harmony export */   isIPFSStorageInitialized: () => (/* binding */ isIPFSStorageInitialized),\n/* harmony export */   resetIPFSStorage: () => (/* binding */ resetIPFSStorage)\n/* harmony export */ });\n/**\n * IPFS Storage Implementation\n *\n * Consolidated IPFS client for uploading and retrieving data\n * Supports Pinata, Web3.Storage, and multiple IPFS gateways\n * Handles inline data URIs, CID extraction, and gateway fallbacks\n */\n/**\n * Extract CID from various IPFS URI formats\n * Supports: ipfs://CID, https://gateway/ipfs/CID, https://CID.ipfs.gateway, etc.\n */\nfunction extractCid(tokenUri) {\n    if (!tokenUri)\n        return null;\n    // Remove ipfs:// prefix\n    let cid = tokenUri.replace(/^ipfs:\\/\\//, '');\n    // Handle gateway URLs\n    // Match patterns like: https://gateway/ipfs/CID or https://CID.ipfs.gateway\n    const gatewayPatterns = [\n        /\\/ipfs\\/([a-zA-Z0-9]+)/, // https://gateway/ipfs/CID\n        /^https?:\\/\\/([a-zA-Z0-9]+)\\.ipfs\\./, // https://CID.ipfs.gateway\n        /^https?:\\/\\/[^/]+\\/([a-zA-Z0-9]+)$/, // https://gateway/CID (no /ipfs/)\n    ];\n    for (const pattern of gatewayPatterns) {\n        const match = cid.match(pattern);\n        if (match && match[1]) {\n            cid = match[1];\n            break;\n        }\n    }\n    // Remove any remaining URL parts\n    const parts = cid.split('/');\n    const firstPart = parts[0] || cid;\n    const cleanCid = firstPart.split('?')[0] || firstPart;\n    // Validate CID format (basic check - should start with Qm for v0 or be longer for v1)\n    if (cleanCid && /^[a-zA-Z0-9]{46,}$/.test(cleanCid)) {\n        return cleanCid;\n    }\n    return null;\n}\n/**\n * Create a timeout signal for fetch requests\n */\nfunction createTimeoutSignal(timeoutMs) {\n    const controller = new AbortController();\n    setTimeout(() => controller.abort(), timeoutMs);\n    return controller.signal;\n}\n/**\n * Create IPFS storage instance\n */\nfunction createIPFSStorage(config) {\n    const pinataJwt = config.pinataJwt || process.env.PINATA_JWT;\n    const pinataApiKey = config.pinataApiKey || process.env.PINATA_API_KEY;\n    const pinataApiSecret = config.pinataApiSecret || process.env.PINATA_API_SECRET;\n    const web3StorageToken = config.web3StorageToken || process.env.WEB3_STORAGE_TOKEN || process.env.WEB3_STORAGE_API_KEY;\n    const timeout = config.timeout || 10000;\n    // Default to Pinata gateway for uploads\n    const gatewayUrl = config.gatewayUrl || 'https://gateway.pinata.cloud/ipfs/';\n    // Helper function to get URL from CID\n    const getUrlFromCid = (cid) => {\n        // Remove 'ipfs://' prefix if present\n        const cleanCid = cid.replace(/^ipfs:\\/\\//, '');\n        return `${gatewayUrl}${cleanCid}`;\n    };\n    return {\n        async upload(data, filename) {\n            const safeTruncate = (value, max = 2000) => value.length > max ? `${value.slice(0, max)}(truncated)` : value;\n            const safeParseJson = (text) => {\n                try {\n                    return JSON.parse(text);\n                }\n                catch {\n                    return null;\n                }\n            };\n            const formatUnknown = (value) => {\n                if (value == null)\n                    return '';\n                if (typeof value === 'string')\n                    return value;\n                if (typeof value === 'number' || typeof value === 'boolean')\n                    return String(value);\n                try {\n                    return JSON.stringify(value);\n                }\n                catch {\n                    return String(value);\n                }\n            };\n            // Prefer Pinata if available\n            if (pinataJwt || (pinataApiKey && pinataApiSecret)) {\n                try {\n                    let file;\n                    if (typeof data === 'string') {\n                        file = new File([data], filename || 'data.txt', { type: 'text/plain' });\n                    }\n                    else if (data instanceof Blob) {\n                        file = new File([data], filename || 'file', { type: data.type || 'application/octet-stream' });\n                    }\n                    else if (data instanceof File) {\n                        file = data;\n                    }\n                    else {\n                        file = new File([data], filename || 'file', { type: 'application/octet-stream' });\n                    }\n                    const formData = new FormData();\n                    formData.append('file', file);\n                    // Pinata metadata\n                    const metadata = JSON.stringify({\n                        name: filename || file.name,\n                    });\n                    formData.append('pinataMetadata', metadata);\n                    // Pinata options\n                    const pinataOptions = JSON.stringify({\n                        cidVersion: 0,\n                    });\n                    formData.append('pinataOptions', pinataOptions);\n                    // Use JWT or API key/secret\n                    const headers = {};\n                    if (pinataJwt) {\n                        headers['Authorization'] = `Bearer ${pinataJwt}`;\n                    }\n                    else if (pinataApiKey && pinataApiSecret) {\n                        headers['pinata_api_key'] = pinataApiKey;\n                        headers['pinata_secret_api_key'] = pinataApiSecret;\n                    }\n                    const response = await fetch('https://api.pinata.cloud/pinning/pinFileToIPFS', {\n                        method: 'POST',\n                        headers,\n                        body: formData,\n                    });\n                    if (!response.ok) {\n                        const rawBody = await response.text().catch(() => '');\n                        const parsed = rawBody ? safeParseJson(rawBody) : null;\n                        const details = parsed ?? rawBody ?? response.statusText;\n                        throw new Error(`Pinata upload failed (${response.status} ${response.statusText}): ${safeTruncate(formatUnknown(details) || response.statusText)}`);\n                    }\n                    const result = await response.json();\n                    const cid = result.IpfsHash || result.cid;\n                    return {\n                        cid,\n                        url: getUrlFromCid(cid),\n                        tokenUri: `ipfs://${cid}`,\n                        size: file.size,\n                    };\n                }\n                catch (error) {\n                    throw new Error(`Failed to upload to Pinata: ${error instanceof Error ? error.message : 'Unknown error'}`);\n                }\n            }\n            // Fallback to Web3.Storage if available\n            if (web3StorageToken) {\n                try {\n                    // Dynamic import to avoid bundling if not used\n                    // @ts-ignore - web3.storage is optional and may not be installed\n                    const web3StorageModule = await Promise.all(/*! import() */[__webpack_require__.e(\"vendor-chunks/@ipld\"), __webpack_require__.e(\"vendor-chunks/@multiformats\"), __webpack_require__.e(\"vendor-chunks/web-encoding\"), __webpack_require__.e(\"vendor-chunks/ipfs-unixfs-importer\"), __webpack_require__.e(\"vendor-chunks/ipfs-car\"), __webpack_require__.e(\"vendor-chunks/ipfs-unixfs-exporter\"), __webpack_require__.e(\"vendor-chunks/carbites\"), __webpack_require__.e(\"vendor-chunks/hamt-sharding\"), __webpack_require__.e(\"vendor-chunks/@web-std\"), __webpack_require__.e(\"vendor-chunks/blockstore-core\"), __webpack_require__.e(\"vendor-chunks/@protobufjs\"), __webpack_require__.e(\"vendor-chunks/@web3-storage\"), __webpack_require__.e(\"vendor-chunks/retry\"), __webpack_require__.e(\"vendor-chunks/rabin-wasm\"), __webpack_require__.e(\"vendor-chunks/web3.storage\"), __webpack_require__.e(\"vendor-chunks/murmurhash3js-revisited\"), __webpack_require__.e(\"vendor-chunks/merge-options\"), __webpack_require__.e(\"vendor-chunks/files-from-path\"), __webpack_require__.e(\"vendor-chunks/web-streams-polyfill\"), __webpack_require__.e(\"vendor-chunks/streaming-iterables\"), __webpack_require__.e(\"vendor-chunks/mrmime\"), __webpack_require__.e(\"vendor-chunks/throttled-queue\"), __webpack_require__.e(\"vendor-chunks/sparse-array\"), __webpack_require__.e(\"vendor-chunks/p-retry\"), __webpack_require__.e(\"vendor-chunks/minimatch\"), __webpack_require__.e(\"vendor-chunks/it-take\"), __webpack_require__.e(\"vendor-chunks/it-pipe\"), __webpack_require__.e(\"vendor-chunks/it-parallel-batch\"), __webpack_require__.e(\"vendor-chunks/it-filter\"), __webpack_require__.e(\"vendor-chunks/it-drain\"), __webpack_require__.e(\"vendor-chunks/it-batch\"), __webpack_require__.e(\"vendor-chunks/is-plain-obj\"), __webpack_require__.e(\"vendor-chunks/event-target-shim\"), __webpack_require__.e(\"vendor-chunks/err-code\"), __webpack_require__.e(\"vendor-chunks/data-uri-to-buffer\"), __webpack_require__.e(\"vendor-chunks/concat-map\"), __webpack_require__.e(\"vendor-chunks/brace-expansion\"), __webpack_require__.e(\"vendor-chunks/bl\"), __webpack_require__.e(\"vendor-chunks/balanced-match\"), __webpack_require__.e(\"vendor-chunks/abort-controller\"), __webpack_require__.e(\"vendor-chunks/@assemblyscript\")]).then(__webpack_require__.bind(__webpack_require__, /*! web3.storage */ \"(rsc)/../../node_modules/web3.storage/src/lib.js\"));\n                    const Web3Storage = web3StorageModule.Web3Storage;\n                    const web3Storage = new Web3Storage({ token: web3StorageToken });\n                    let file;\n                    if (typeof data === 'string') {\n                        file = new File([data], filename || 'data.txt', { type: 'text/plain' });\n                    }\n                    else if (data instanceof Blob) {\n                        file = new File([data], filename || 'file', { type: data.type || 'application/octet-stream' });\n                    }\n                    else if (data instanceof File) {\n                        file = data;\n                    }\n                    else {\n                        file = new File([data], filename || 'file', { type: 'application/octet-stream' });\n                    }\n                    const cid = await web3Storage.put([file], {\n                        wrapWithDirectory: false,\n                    });\n                    return {\n                        cid,\n                        url: getUrlFromCid(cid),\n                        tokenUri: `ipfs://${cid}`,\n                        size: file.size,\n                    };\n                }\n                catch (error) {\n                    throw new Error(`Failed to upload to Web3.Storage: ${error instanceof Error ? error.message : 'Unknown error'}`);\n                }\n            }\n            // Fallback: Use IPFS API if available\n            if (config.ipfsApiUrl) {\n                try {\n                    let file;\n                    if (typeof data === 'string') {\n                        file = new File([data], filename || 'data.txt', { type: 'text/plain' });\n                    }\n                    else if (data instanceof Blob) {\n                        file = new File([data], filename || 'file', { type: data.type || 'application/octet-stream' });\n                    }\n                    else if (data instanceof File) {\n                        file = data;\n                    }\n                    else {\n                        file = new File([data], filename || 'file', { type: 'application/octet-stream' });\n                    }\n                    const formData = new FormData();\n                    formData.append('file', file);\n                    const response = await fetch(`${config.ipfsApiUrl}/api/v0/add`, {\n                        method: 'POST',\n                        body: formData,\n                    });\n                    if (!response.ok) {\n                        throw new Error(`IPFS API error: ${response.statusText}`);\n                    }\n                    const result = await response.json();\n                    const cid = result.Hash || result.cid;\n                    return {\n                        cid,\n                        url: getUrlFromCid(cid),\n                        tokenUri: `ipfs://${cid}`,\n                        size: file.size,\n                    };\n                }\n                catch (error) {\n                    throw new Error(`Failed to upload to IPFS API: ${error instanceof Error ? error.message : 'Unknown error'}`);\n                }\n            }\n            throw new Error('No IPFS storage method configured. Provide PINATA_JWT or PINATA_API_KEY/PINATA_API_SECRET.');\n        },\n        async get(cidOrTokenUri) {\n            const cid = extractCid(cidOrTokenUri);\n            if (!cid) {\n                throw new Error(`Invalid CID or tokenUri: ${cidOrTokenUri}`);\n            }\n            // Try multiple gateways with fallback\n            const gateways = [\n                `https://gateway.pinata.cloud/ipfs/${cid}`,\n                `https://${cid}.ipfs.mypinata.cloud`,\n                `https://${cid}.ipfs.w3s.link`,\n                `https://w3s.link/ipfs/${cid}`,\n                `https://ipfs.io/ipfs/${cid}`,\n                `https://cloudflare-ipfs.com/ipfs/${cid}`,\n                `https://dweb.link/ipfs/${cid}`,\n                `https://gateway.ipfs.io/ipfs/${cid}`,\n            ];\n            for (const url of gateways) {\n                try {\n                    const timeoutSignal = createTimeoutSignal(timeout);\n                    const response = await fetch(url, { signal: timeoutSignal });\n                    if (response.ok) {\n                        return response.blob();\n                    }\n                }\n                catch (error) {\n                    const errorMsg = error?.message || String(error);\n                    // Don't log timeout errors for every gateway (too noisy)\n                    if (!errorMsg.includes('aborted') && !errorMsg.includes('timeout')) {\n                        console.warn(`IPFS gateway ${url} failed: ${errorMsg}`);\n                    }\n                    // Continue to next gateway\n                    continue;\n                }\n            }\n            throw new Error(`Failed to fetch from IPFS: All gateways failed for CID ${cid}`);\n        },\n        async getJson(tokenUri) {\n            if (!tokenUri)\n                return null;\n            const fetchFn = globalThis.fetch;\n            if (!fetchFn)\n                return null;\n            try {\n                // Handle inline data URIs (data:application/json,...)\n                if (tokenUri.startsWith('data:application/json')) {\n                    console.log('[IPFS] Processing data URI:', tokenUri.substring(0, 100) + '...');\n                    try {\n                        const commaIndex = tokenUri.indexOf(',');\n                        if (commaIndex === -1) {\n                            console.warn('[IPFS] Invalid data URI format (no comma)');\n                            return null;\n                        }\n                        const jsonData = tokenUri.substring(commaIndex + 1);\n                        console.log('[IPFS] Extracted data substring (first 50 chars):', jsonData.substring(0, 50) + '...');\n                        let parsed;\n                        // Check if it's marked as base64 encoded\n                        if (tokenUri.startsWith('data:application/json;base64,')) {\n                            console.log('[IPFS] URI marked as base64');\n                            // If it looks like JSON (starts with { or [), try parsing directly first\n                            // This handles cases where the URI says base64 but content is plain text\n                            const trimmedData = jsonData.trim();\n                            if (trimmedData.startsWith('{') || trimmedData.startsWith('[')) {\n                                console.log('[IPFS] Content looks like plain JSON, trying direct parse first');\n                                try {\n                                    parsed = JSON.parse(jsonData);\n                                    console.log('[IPFS] Direct parse successful');\n                                    return parsed;\n                                }\n                                catch (e) {\n                                    console.log('[IPFS] Direct parse failed, proceeding to base64 decode');\n                                    // If direct parse fails, proceed to base64 decoding\n                                }\n                            }\n                            try {\n                                // Try base64 decode first\n                                console.log('[IPFS] Attempting base64 decode');\n                                let jsonString;\n                                if (typeof atob !== 'undefined') {\n                                    jsonString = atob(jsonData);\n                                }\n                                else {\n                                    // Node.js environment\n                                    const buffer = Buffer.from(jsonData, 'base64');\n                                    jsonString = buffer.toString('utf-8');\n                                }\n                                console.log('[IPFS] Base64 decoded string (first 50 chars):', jsonString.substring(0, 50) + '...');\n                                parsed = JSON.parse(jsonString);\n                                console.log('[IPFS] Base64 parse successful');\n                            }\n                            catch (e) {\n                                console.warn('[IPFS] Base64 decode/parse failed:', e);\n                                // If base64 fails, try parsing as plain JSON (fallback)\n                                try {\n                                    console.log('[IPFS] Trying plain JSON parse as fallback');\n                                    parsed = JSON.parse(jsonData);\n                                    console.log('[IPFS] Fallback plain JSON parse successful');\n                                }\n                                catch (e2) {\n                                    try {\n                                        console.log('[IPFS] Trying URL decoding as fallback');\n                                        const decodedJson = decodeURIComponent(jsonData);\n                                        parsed = JSON.parse(decodedJson);\n                                        console.log('[IPFS] URL decoded parse successful');\n                                    }\n                                    catch (e3) {\n                                        try {\n                                            console.log('[IPFS] Trying URI decode + base64 as final fallback');\n                                            // Final attempt: sometimes base64 strings have URI encoded chars\n                                            const buffer = Buffer.from(decodeURIComponent(jsonData), 'base64');\n                                            parsed = JSON.parse(buffer.toString('utf-8'));\n                                            console.log('[IPFS] URI decode + base64 successful');\n                                        }\n                                        catch (e4) {\n                                            console.error('[IPFS] All parse attempts failed');\n                                            throw e; // Throw original or last error\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                        else {\n                            // Plain JSON - try parsing directly first, then URL decode if needed\n                            try {\n                                parsed = JSON.parse(jsonData);\n                            }\n                            catch (e) {\n                                const decodedJson = decodeURIComponent(jsonData);\n                                parsed = JSON.parse(decodedJson);\n                            }\n                        }\n                        return parsed;\n                    }\n                    catch (e) {\n                        console.warn('Failed to parse inline data URI:', e);\n                        return null;\n                    }\n                }\n                const cid = extractCid(tokenUri);\n                if (cid) {\n                    // Detect if URI suggests a specific service (from URL format)\n                    const isPinataUrl = tokenUri.includes('pinata') || tokenUri.includes('gateway.pinata.cloud');\n                    const isWeb3StorageUrl = tokenUri.includes('w3s.link') || tokenUri.includes('web3.storage');\n                    // Try multiple IPFS gateways as fallbacks\n                    // Prioritize based on detected service, then try all options\n                    const gateways = [];\n                    // Pinata gateways (try first if detected as Pinata, otherwise after Web3Storage)\n                    const pinataGateways = [\n                        { url: `https://gateway.pinata.cloud/ipfs/${cid}`, service: 'Pinata (gateway.pinata.cloud)' },\n                        { url: `https://${cid}.ipfs.mypinata.cloud`, service: 'Pinata (mypinata.cloud subdomain)' },\n                    ];\n                    // Web3Storage gateways (try first if detected as Web3Storage, otherwise try early)\n                    const web3StorageGateways = [\n                        { url: `https://${cid}.ipfs.w3s.link`, service: 'Web3Storage (w3s.link)' },\n                        { url: `https://w3s.link/ipfs/${cid}`, service: 'Web3Storage (w3s.link path)' },\n                    ];\n                    // Public IPFS gateways (fallbacks)\n                    const publicGateways = [\n                        { url: `https://ipfs.io/ipfs/${cid}`, service: 'IPFS.io' },\n                        { url: `https://cloudflare-ipfs.com/ipfs/${cid}`, service: 'Cloudflare IPFS' },\n                        { url: `https://dweb.link/ipfs/${cid}`, service: 'Protocol Labs (dweb.link)' },\n                        { url: `https://gateway.ipfs.io/ipfs/${cid}`, service: 'IPFS Gateway' },\n                    ];\n                    // Build gateway list with priority based on detection\n                    if (isPinataUrl) {\n                        // Pinata detected: try Pinata first, then Web3Storage, then public\n                        gateways.push(...pinataGateways, ...web3StorageGateways, ...publicGateways);\n                    }\n                    else if (isWeb3StorageUrl) {\n                        // Web3Storage detected: try Web3Storage first, then Pinata, then public\n                        gateways.push(...web3StorageGateways, ...pinataGateways, ...publicGateways);\n                    }\n                    else {\n                        // No detection: try Web3Storage first (most common), then Pinata, then public\n                        gateways.push(...web3StorageGateways, ...pinataGateways, ...publicGateways);\n                    }\n                    for (const { url: ipfsUrl, service } of gateways) {\n                        try {\n                            const timeoutSignal = createTimeoutSignal(timeout);\n                            const resp = await fetchFn(ipfsUrl, { signal: timeoutSignal });\n                            if (resp?.ok) {\n                                const json = await resp.json();\n                                return json ?? null;\n                            }\n                        }\n                        catch (e) {\n                            const errorMsg = e?.message || String(e);\n                            // Don't log timeout errors for every gateway (too noisy)\n                            if (!errorMsg.includes('aborted') && !errorMsg.includes('timeout')) {\n                                // Continue silently - will try next gateway\n                            }\n                            // Continue to next gateway\n                            continue;\n                        }\n                    }\n                    console.warn(`All IPFS gateways failed for CID: ${cid}`);\n                }\n                // Try as regular HTTP/HTTPS URL\n                if (/^https?:\\/\\//i.test(tokenUri)) {\n                    const timeoutSignal = createTimeoutSignal(timeout);\n                    const resp = await fetchFn(tokenUri, { signal: timeoutSignal });\n                    if (resp?.ok)\n                        return await resp.json();\n                }\n            }\n            catch (e) {\n                console.warn('Error fetching/parsing token URI:', e);\n            }\n            return null;\n        },\n        getUrl(cidOrTokenUri) {\n            const cid = extractCid(cidOrTokenUri);\n            if (!cid) {\n                // If it's already a full URL, return it\n                if (/^https?:\\/\\//i.test(cidOrTokenUri)) {\n                    return cidOrTokenUri;\n                }\n                throw new Error(`Invalid CID or tokenUri: ${cidOrTokenUri}`);\n            }\n            return getUrlFromCid(cid);\n        },\n    };\n}\n/**\n * Default IPFS storage instance (singleton pattern)\n * Uses environment variables, defaults to Pinata\n */\nlet defaultIPFSStorage = null;\n/**\n * Get or create default IPFS storage instance (singleton)\n * Initializes from environment variables, defaults to Pinata\n */\nfunction getIPFSStorage() {\n    if (!defaultIPFSStorage) {\n        const config = {\n            pinataJwt: process.env.PINATA_JWT,\n            pinataApiKey: process.env.PINATA_API_KEY,\n            pinataApiSecret: process.env.PINATA_API_SECRET,\n            web3StorageToken: process.env.WEB3_STORAGE_TOKEN || process.env.WEB3_STORAGE_API_KEY,\n            gatewayUrl: process.env.IPFS_GATEWAY_URL || 'https://gateway.pinata.cloud/ipfs/',\n            ipfsApiUrl: process.env.IPFS_API_URL,\n            timeout: 10000,\n        };\n        defaultIPFSStorage = createIPFSStorage(config);\n    }\n    return defaultIPFSStorage;\n}\n/**\n * Check if IPFS storage is initialized\n */\nfunction isIPFSStorageInitialized() {\n    return defaultIPFSStorage !== null;\n}\n/**\n * Reset default IPFS storage instance (useful for testing)\n */\nfunction resetIPFSStorage() {\n    defaultIPFSStorage = null;\n}\n//# sourceMappingURL=ipfs.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BhZ2VudGljLXRydXN0L2NvcmUvZGlzdC9zZXJ2ZXIvbGliL2lwZnMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsSUFBSTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsV0FBVyxFQUFFLFNBQVM7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsZ0ZBQWdGLG9CQUFvQjtBQUNwRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEUsb0JBQW9CO0FBQzlGO0FBQ0E7QUFDQSxzRUFBc0UsK0NBQStDO0FBQ3JIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0Usa0NBQWtDO0FBQ3hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxVQUFVO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSxpQkFBaUIsRUFBRSxvQkFBb0IsS0FBSyw0REFBNEQ7QUFDeks7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLElBQUk7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUseURBQXlEO0FBQzVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELHd4RUFBc0I7QUFDMUU7QUFDQSwwREFBMEQseUJBQXlCO0FBQ25GO0FBQ0E7QUFDQSwwRUFBMEUsb0JBQW9CO0FBQzlGO0FBQ0E7QUFDQSxzRUFBc0UsK0NBQStDO0FBQ3JIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0Usa0NBQWtDO0FBQ3hHO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsSUFBSTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSx5REFBeUQ7QUFDbEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEUsb0JBQW9CO0FBQzlGO0FBQ0E7QUFDQSxzRUFBc0UsK0NBQStDO0FBQ3JIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0Usa0NBQWtDO0FBQ3hHO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxrQkFBa0I7QUFDdEU7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLDJEQUEyRCxvQkFBb0I7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLElBQUk7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUseURBQXlEO0FBQzlIO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsY0FBYztBQUMxRTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsSUFBSTtBQUN6RCwyQkFBMkIsSUFBSTtBQUMvQiwyQkFBMkIsSUFBSTtBQUMvQix5Q0FBeUMsSUFBSTtBQUM3Qyx3Q0FBd0MsSUFBSTtBQUM1QyxvREFBb0QsSUFBSTtBQUN4RCwwQ0FBMEMsSUFBSTtBQUM5QyxnREFBZ0QsSUFBSTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCx1QkFBdUI7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxLQUFLLFVBQVUsU0FBUztBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0ZBQXNGLElBQUk7QUFDMUYsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUU7QUFDdkU7QUFDQSxvRUFBb0U7QUFDcEU7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDBDQUEwQyxJQUFJLDZDQUE2QztBQUNySCwwQkFBMEIsZ0JBQWdCLElBQUkscUVBQXFFO0FBQ25IO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixnQkFBZ0IsSUFBSSxvREFBb0Q7QUFDbEcsMEJBQTBCLDhCQUE4QixJQUFJLDJDQUEyQztBQUN2RztBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsNkJBQTZCLElBQUksdUJBQXVCO0FBQ2xGLDBCQUEwQix5Q0FBeUMsSUFBSSwrQkFBK0I7QUFDdEcsMEJBQTBCLCtCQUErQixJQUFJLHlDQUF5QztBQUN0RywwQkFBMEIscUNBQXFDLElBQUksNEJBQTRCO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsd0JBQXdCO0FBQ3pEO0FBQ0E7QUFDQSxrRUFBa0UsdUJBQXVCO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRSxJQUFJO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELHVCQUF1QjtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELGNBQWM7QUFDMUU7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL2JhcmIvYWEvQXNzb2NpYXRlZEFjY291bnRzL25vZGVfbW9kdWxlcy9AYWdlbnRpYy10cnVzdC9jb3JlL2Rpc3Qvc2VydmVyL2xpYi9pcGZzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogSVBGUyBTdG9yYWdlIEltcGxlbWVudGF0aW9uXG4gKlxuICogQ29uc29saWRhdGVkIElQRlMgY2xpZW50IGZvciB1cGxvYWRpbmcgYW5kIHJldHJpZXZpbmcgZGF0YVxuICogU3VwcG9ydHMgUGluYXRhLCBXZWIzLlN0b3JhZ2UsIGFuZCBtdWx0aXBsZSBJUEZTIGdhdGV3YXlzXG4gKiBIYW5kbGVzIGlubGluZSBkYXRhIFVSSXMsIENJRCBleHRyYWN0aW9uLCBhbmQgZ2F0ZXdheSBmYWxsYmFja3NcbiAqL1xuLyoqXG4gKiBFeHRyYWN0IENJRCBmcm9tIHZhcmlvdXMgSVBGUyBVUkkgZm9ybWF0c1xuICogU3VwcG9ydHM6IGlwZnM6Ly9DSUQsIGh0dHBzOi8vZ2F0ZXdheS9pcGZzL0NJRCwgaHR0cHM6Ly9DSUQuaXBmcy5nYXRld2F5LCBldGMuXG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3RDaWQodG9rZW5VcmkpIHtcbiAgICBpZiAoIXRva2VuVXJpKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAvLyBSZW1vdmUgaXBmczovLyBwcmVmaXhcbiAgICBsZXQgY2lkID0gdG9rZW5VcmkucmVwbGFjZSgvXmlwZnM6XFwvXFwvLywgJycpO1xuICAgIC8vIEhhbmRsZSBnYXRld2F5IFVSTHNcbiAgICAvLyBNYXRjaCBwYXR0ZXJucyBsaWtlOiBodHRwczovL2dhdGV3YXkvaXBmcy9DSUQgb3IgaHR0cHM6Ly9DSUQuaXBmcy5nYXRld2F5XG4gICAgY29uc3QgZ2F0ZXdheVBhdHRlcm5zID0gW1xuICAgICAgICAvXFwvaXBmc1xcLyhbYS16QS1aMC05XSspLywgLy8gaHR0cHM6Ly9nYXRld2F5L2lwZnMvQ0lEXG4gICAgICAgIC9eaHR0cHM/OlxcL1xcLyhbYS16QS1aMC05XSspXFwuaXBmc1xcLi8sIC8vIGh0dHBzOi8vQ0lELmlwZnMuZ2F0ZXdheVxuICAgICAgICAvXmh0dHBzPzpcXC9cXC9bXi9dK1xcLyhbYS16QS1aMC05XSspJC8sIC8vIGh0dHBzOi8vZ2F0ZXdheS9DSUQgKG5vIC9pcGZzLylcbiAgICBdO1xuICAgIGZvciAoY29uc3QgcGF0dGVybiBvZiBnYXRld2F5UGF0dGVybnMpIHtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSBjaWQubWF0Y2gocGF0dGVybik7XG4gICAgICAgIGlmIChtYXRjaCAmJiBtYXRjaFsxXSkge1xuICAgICAgICAgICAgY2lkID0gbWF0Y2hbMV07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBSZW1vdmUgYW55IHJlbWFpbmluZyBVUkwgcGFydHNcbiAgICBjb25zdCBwYXJ0cyA9IGNpZC5zcGxpdCgnLycpO1xuICAgIGNvbnN0IGZpcnN0UGFydCA9IHBhcnRzWzBdIHx8IGNpZDtcbiAgICBjb25zdCBjbGVhbkNpZCA9IGZpcnN0UGFydC5zcGxpdCgnPycpWzBdIHx8IGZpcnN0UGFydDtcbiAgICAvLyBWYWxpZGF0ZSBDSUQgZm9ybWF0IChiYXNpYyBjaGVjayAtIHNob3VsZCBzdGFydCB3aXRoIFFtIGZvciB2MCBvciBiZSBsb25nZXIgZm9yIHYxKVxuICAgIGlmIChjbGVhbkNpZCAmJiAvXlthLXpBLVowLTldezQ2LH0kLy50ZXN0KGNsZWFuQ2lkKSkge1xuICAgICAgICByZXR1cm4gY2xlYW5DaWQ7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuLyoqXG4gKiBDcmVhdGUgYSB0aW1lb3V0IHNpZ25hbCBmb3IgZmV0Y2ggcmVxdWVzdHNcbiAqL1xuZnVuY3Rpb24gY3JlYXRlVGltZW91dFNpZ25hbCh0aW1lb3V0TXMpIHtcbiAgICBjb25zdCBjb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIHNldFRpbWVvdXQoKCkgPT4gY29udHJvbGxlci5hYm9ydCgpLCB0aW1lb3V0TXMpO1xuICAgIHJldHVybiBjb250cm9sbGVyLnNpZ25hbDtcbn1cbi8qKlxuICogQ3JlYXRlIElQRlMgc3RvcmFnZSBpbnN0YW5jZVxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlSVBGU1N0b3JhZ2UoY29uZmlnKSB7XG4gICAgY29uc3QgcGluYXRhSnd0ID0gY29uZmlnLnBpbmF0YUp3dCB8fCBwcm9jZXNzLmVudi5QSU5BVEFfSldUO1xuICAgIGNvbnN0IHBpbmF0YUFwaUtleSA9IGNvbmZpZy5waW5hdGFBcGlLZXkgfHwgcHJvY2Vzcy5lbnYuUElOQVRBX0FQSV9LRVk7XG4gICAgY29uc3QgcGluYXRhQXBpU2VjcmV0ID0gY29uZmlnLnBpbmF0YUFwaVNlY3JldCB8fCBwcm9jZXNzLmVudi5QSU5BVEFfQVBJX1NFQ1JFVDtcbiAgICBjb25zdCB3ZWIzU3RvcmFnZVRva2VuID0gY29uZmlnLndlYjNTdG9yYWdlVG9rZW4gfHwgcHJvY2Vzcy5lbnYuV0VCM19TVE9SQUdFX1RPS0VOIHx8IHByb2Nlc3MuZW52LldFQjNfU1RPUkFHRV9BUElfS0VZO1xuICAgIGNvbnN0IHRpbWVvdXQgPSBjb25maWcudGltZW91dCB8fCAxMDAwMDtcbiAgICAvLyBEZWZhdWx0IHRvIFBpbmF0YSBnYXRld2F5IGZvciB1cGxvYWRzXG4gICAgY29uc3QgZ2F0ZXdheVVybCA9IGNvbmZpZy5nYXRld2F5VXJsIHx8ICdodHRwczovL2dhdGV3YXkucGluYXRhLmNsb3VkL2lwZnMvJztcbiAgICAvLyBIZWxwZXIgZnVuY3Rpb24gdG8gZ2V0IFVSTCBmcm9tIENJRFxuICAgIGNvbnN0IGdldFVybEZyb21DaWQgPSAoY2lkKSA9PiB7XG4gICAgICAgIC8vIFJlbW92ZSAnaXBmczovLycgcHJlZml4IGlmIHByZXNlbnRcbiAgICAgICAgY29uc3QgY2xlYW5DaWQgPSBjaWQucmVwbGFjZSgvXmlwZnM6XFwvXFwvLywgJycpO1xuICAgICAgICByZXR1cm4gYCR7Z2F0ZXdheVVybH0ke2NsZWFuQ2lkfWA7XG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgICBhc3luYyB1cGxvYWQoZGF0YSwgZmlsZW5hbWUpIHtcbiAgICAgICAgICAgIGNvbnN0IHNhZmVUcnVuY2F0ZSA9ICh2YWx1ZSwgbWF4ID0gMjAwMCkgPT4gdmFsdWUubGVuZ3RoID4gbWF4ID8gYCR7dmFsdWUuc2xpY2UoMCwgbWF4KX3igKYodHJ1bmNhdGVkKWAgOiB2YWx1ZTtcbiAgICAgICAgICAgIGNvbnN0IHNhZmVQYXJzZUpzb24gPSAodGV4dCkgPT4ge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBKU09OLnBhcnNlKHRleHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBmb3JtYXRVbmtub3duID0gKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBTdHJpbmcodmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyBQcmVmZXIgUGluYXRhIGlmIGF2YWlsYWJsZVxuICAgICAgICAgICAgaWYgKHBpbmF0YUp3dCB8fCAocGluYXRhQXBpS2V5ICYmIHBpbmF0YUFwaVNlY3JldCkpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZmlsZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlsZSA9IG5ldyBGaWxlKFtkYXRhXSwgZmlsZW5hbWUgfHwgJ2RhdGEudHh0JywgeyB0eXBlOiAndGV4dC9wbGFpbicgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZGF0YSBpbnN0YW5jZW9mIEJsb2IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGUgPSBuZXcgRmlsZShbZGF0YV0sIGZpbGVuYW1lIHx8ICdmaWxlJywgeyB0eXBlOiBkYXRhLnR5cGUgfHwgJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbScgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZGF0YSBpbnN0YW5jZW9mIEZpbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGUgPSBkYXRhO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlsZSA9IG5ldyBGaWxlKFtkYXRhXSwgZmlsZW5hbWUgfHwgJ2ZpbGUnLCB7IHR5cGU6ICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKCk7XG4gICAgICAgICAgICAgICAgICAgIGZvcm1EYXRhLmFwcGVuZCgnZmlsZScsIGZpbGUpO1xuICAgICAgICAgICAgICAgICAgICAvLyBQaW5hdGEgbWV0YWRhdGFcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWV0YWRhdGEgPSBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBmaWxlbmFtZSB8fCBmaWxlLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBmb3JtRGF0YS5hcHBlbmQoJ3BpbmF0YU1ldGFkYXRhJywgbWV0YWRhdGEpO1xuICAgICAgICAgICAgICAgICAgICAvLyBQaW5hdGEgb3B0aW9uc1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwaW5hdGFPcHRpb25zID0gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgICAgICAgICAgY2lkVmVyc2lvbjogMCxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGZvcm1EYXRhLmFwcGVuZCgncGluYXRhT3B0aW9ucycsIHBpbmF0YU9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICAvLyBVc2UgSldUIG9yIEFQSSBrZXkvc2VjcmV0XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGhlYWRlcnMgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBpbmF0YUp3dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyc1snQXV0aG9yaXphdGlvbiddID0gYEJlYXJlciAke3BpbmF0YUp3dH1gO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBpbmF0YUFwaUtleSAmJiBwaW5hdGFBcGlTZWNyZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnNbJ3BpbmF0YV9hcGlfa2V5J10gPSBwaW5hdGFBcGlLZXk7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzWydwaW5hdGFfc2VjcmV0X2FwaV9rZXknXSA9IHBpbmF0YUFwaVNlY3JldDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKCdodHRwczovL2FwaS5waW5hdGEuY2xvdWQvcGlubmluZy9waW5GaWxlVG9JUEZTJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICAgICAgYm9keTogZm9ybURhdGEsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByYXdCb2R5ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpLmNhdGNoKCgpID0+ICcnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcnNlZCA9IHJhd0JvZHkgPyBzYWZlUGFyc2VKc29uKHJhd0JvZHkpIDogbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRldGFpbHMgPSBwYXJzZWQgPz8gcmF3Qm9keSA/PyByZXNwb25zZS5zdGF0dXNUZXh0O1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQaW5hdGEgdXBsb2FkIGZhaWxlZCAoJHtyZXNwb25zZS5zdGF0dXN9ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH0pOiAke3NhZmVUcnVuY2F0ZShmb3JtYXRVbmtub3duKGRldGFpbHMpIHx8IHJlc3BvbnNlLnN0YXR1c1RleHQpfWApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2lkID0gcmVzdWx0LklwZnNIYXNoIHx8IHJlc3VsdC5jaWQ7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICB1cmw6IGdldFVybEZyb21DaWQoY2lkKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuVXJpOiBgaXBmczovLyR7Y2lkfWAsXG4gICAgICAgICAgICAgICAgICAgICAgICBzaXplOiBmaWxlLnNpemUsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byB1cGxvYWQgdG8gUGluYXRhOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEZhbGxiYWNrIHRvIFdlYjMuU3RvcmFnZSBpZiBhdmFpbGFibGVcbiAgICAgICAgICAgIGlmICh3ZWIzU3RvcmFnZVRva2VuKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRHluYW1pYyBpbXBvcnQgdG8gYXZvaWQgYnVuZGxpbmcgaWYgbm90IHVzZWRcbiAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSAtIHdlYjMuc3RvcmFnZSBpcyBvcHRpb25hbCBhbmQgbWF5IG5vdCBiZSBpbnN0YWxsZWRcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgd2ViM1N0b3JhZ2VNb2R1bGUgPSBhd2FpdCBpbXBvcnQoJ3dlYjMuc3RvcmFnZScpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBXZWIzU3RvcmFnZSA9IHdlYjNTdG9yYWdlTW9kdWxlLldlYjNTdG9yYWdlO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB3ZWIzU3RvcmFnZSA9IG5ldyBXZWIzU3RvcmFnZSh7IHRva2VuOiB3ZWIzU3RvcmFnZVRva2VuIH0pO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZmlsZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlsZSA9IG5ldyBGaWxlKFtkYXRhXSwgZmlsZW5hbWUgfHwgJ2RhdGEudHh0JywgeyB0eXBlOiAndGV4dC9wbGFpbicgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZGF0YSBpbnN0YW5jZW9mIEJsb2IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGUgPSBuZXcgRmlsZShbZGF0YV0sIGZpbGVuYW1lIHx8ICdmaWxlJywgeyB0eXBlOiBkYXRhLnR5cGUgfHwgJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbScgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZGF0YSBpbnN0YW5jZW9mIEZpbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGUgPSBkYXRhO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlsZSA9IG5ldyBGaWxlKFtkYXRhXSwgZmlsZW5hbWUgfHwgJ2ZpbGUnLCB7IHR5cGU6ICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNpZCA9IGF3YWl0IHdlYjNTdG9yYWdlLnB1dChbZmlsZV0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdyYXBXaXRoRGlyZWN0b3J5OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICB1cmw6IGdldFVybEZyb21DaWQoY2lkKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuVXJpOiBgaXBmczovLyR7Y2lkfWAsXG4gICAgICAgICAgICAgICAgICAgICAgICBzaXplOiBmaWxlLnNpemUsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byB1cGxvYWQgdG8gV2ViMy5TdG9yYWdlOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEZhbGxiYWNrOiBVc2UgSVBGUyBBUEkgaWYgYXZhaWxhYmxlXG4gICAgICAgICAgICBpZiAoY29uZmlnLmlwZnNBcGlVcmwpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZmlsZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlsZSA9IG5ldyBGaWxlKFtkYXRhXSwgZmlsZW5hbWUgfHwgJ2RhdGEudHh0JywgeyB0eXBlOiAndGV4dC9wbGFpbicgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZGF0YSBpbnN0YW5jZW9mIEJsb2IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGUgPSBuZXcgRmlsZShbZGF0YV0sIGZpbGVuYW1lIHx8ICdmaWxlJywgeyB0eXBlOiBkYXRhLnR5cGUgfHwgJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbScgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZGF0YSBpbnN0YW5jZW9mIEZpbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGUgPSBkYXRhO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlsZSA9IG5ldyBGaWxlKFtkYXRhXSwgZmlsZW5hbWUgfHwgJ2ZpbGUnLCB7IHR5cGU6ICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKCk7XG4gICAgICAgICAgICAgICAgICAgIGZvcm1EYXRhLmFwcGVuZCgnZmlsZScsIGZpbGUpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke2NvbmZpZy5pcGZzQXBpVXJsfS9hcGkvdjAvYWRkYCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5OiBmb3JtRGF0YSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSVBGUyBBUEkgZXJyb3I6ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNpZCA9IHJlc3VsdC5IYXNoIHx8IHJlc3VsdC5jaWQ7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICB1cmw6IGdldFVybEZyb21DaWQoY2lkKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuVXJpOiBgaXBmczovLyR7Y2lkfWAsXG4gICAgICAgICAgICAgICAgICAgICAgICBzaXplOiBmaWxlLnNpemUsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byB1cGxvYWQgdG8gSVBGUyBBUEk6ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvcid9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBJUEZTIHN0b3JhZ2UgbWV0aG9kIGNvbmZpZ3VyZWQuIFByb3ZpZGUgUElOQVRBX0pXVCBvciBQSU5BVEFfQVBJX0tFWS9QSU5BVEFfQVBJX1NFQ1JFVC4nKTtcbiAgICAgICAgfSxcbiAgICAgICAgYXN5bmMgZ2V0KGNpZE9yVG9rZW5VcmkpIHtcbiAgICAgICAgICAgIGNvbnN0IGNpZCA9IGV4dHJhY3RDaWQoY2lkT3JUb2tlblVyaSk7XG4gICAgICAgICAgICBpZiAoIWNpZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBDSUQgb3IgdG9rZW5Vcmk6ICR7Y2lkT3JUb2tlblVyaX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRyeSBtdWx0aXBsZSBnYXRld2F5cyB3aXRoIGZhbGxiYWNrXG4gICAgICAgICAgICBjb25zdCBnYXRld2F5cyA9IFtcbiAgICAgICAgICAgICAgICBgaHR0cHM6Ly9nYXRld2F5LnBpbmF0YS5jbG91ZC9pcGZzLyR7Y2lkfWAsXG4gICAgICAgICAgICAgICAgYGh0dHBzOi8vJHtjaWR9LmlwZnMubXlwaW5hdGEuY2xvdWRgLFxuICAgICAgICAgICAgICAgIGBodHRwczovLyR7Y2lkfS5pcGZzLnczcy5saW5rYCxcbiAgICAgICAgICAgICAgICBgaHR0cHM6Ly93M3MubGluay9pcGZzLyR7Y2lkfWAsXG4gICAgICAgICAgICAgICAgYGh0dHBzOi8vaXBmcy5pby9pcGZzLyR7Y2lkfWAsXG4gICAgICAgICAgICAgICAgYGh0dHBzOi8vY2xvdWRmbGFyZS1pcGZzLmNvbS9pcGZzLyR7Y2lkfWAsXG4gICAgICAgICAgICAgICAgYGh0dHBzOi8vZHdlYi5saW5rL2lwZnMvJHtjaWR9YCxcbiAgICAgICAgICAgICAgICBgaHR0cHM6Ly9nYXRld2F5LmlwZnMuaW8vaXBmcy8ke2NpZH1gLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgdXJsIG9mIGdhdGV3YXlzKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGltZW91dFNpZ25hbCA9IGNyZWF0ZVRpbWVvdXRTaWduYWwodGltZW91dCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCB7IHNpZ25hbDogdGltZW91dFNpZ25hbCB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UuYmxvYigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJvck1zZyA9IGVycm9yPy5tZXNzYWdlIHx8IFN0cmluZyhlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIC8vIERvbid0IGxvZyB0aW1lb3V0IGVycm9ycyBmb3IgZXZlcnkgZ2F0ZXdheSAodG9vIG5vaXN5KVxuICAgICAgICAgICAgICAgICAgICBpZiAoIWVycm9yTXNnLmluY2x1ZGVzKCdhYm9ydGVkJykgJiYgIWVycm9yTXNnLmluY2x1ZGVzKCd0aW1lb3V0JykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgSVBGUyBnYXRld2F5ICR7dXJsfSBmYWlsZWQ6ICR7ZXJyb3JNc2d9YCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gQ29udGludWUgdG8gbmV4dCBnYXRld2F5XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGZldGNoIGZyb20gSVBGUzogQWxsIGdhdGV3YXlzIGZhaWxlZCBmb3IgQ0lEICR7Y2lkfWApO1xuICAgICAgICB9LFxuICAgICAgICBhc3luYyBnZXRKc29uKHRva2VuVXJpKSB7XG4gICAgICAgICAgICBpZiAoIXRva2VuVXJpKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgY29uc3QgZmV0Y2hGbiA9IGdsb2JhbFRoaXMuZmV0Y2g7XG4gICAgICAgICAgICBpZiAoIWZldGNoRm4pXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIC8vIEhhbmRsZSBpbmxpbmUgZGF0YSBVUklzIChkYXRhOmFwcGxpY2F0aW9uL2pzb24sLi4uKVxuICAgICAgICAgICAgICAgIGlmICh0b2tlblVyaS5zdGFydHNXaXRoKCdkYXRhOmFwcGxpY2F0aW9uL2pzb24nKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnW0lQRlNdIFByb2Nlc3NpbmcgZGF0YSBVUkk6JywgdG9rZW5Vcmkuc3Vic3RyaW5nKDAsIDEwMCkgKyAnLi4uJyk7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjb21tYUluZGV4ID0gdG9rZW5VcmkuaW5kZXhPZignLCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbW1hSW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdbSVBGU10gSW52YWxpZCBkYXRhIFVSSSBmb3JtYXQgKG5vIGNvbW1hKScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QganNvbkRhdGEgPSB0b2tlblVyaS5zdWJzdHJpbmcoY29tbWFJbmRleCArIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1tJUEZTXSBFeHRyYWN0ZWQgZGF0YSBzdWJzdHJpbmcgKGZpcnN0IDUwIGNoYXJzKTonLCBqc29uRGF0YS5zdWJzdHJpbmcoMCwgNTApICsgJy4uLicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHBhcnNlZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIGl0J3MgbWFya2VkIGFzIGJhc2U2NCBlbmNvZGVkXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW5Vcmkuc3RhcnRzV2l0aCgnZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCwnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdbSVBGU10gVVJJIG1hcmtlZCBhcyBiYXNlNjQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBpdCBsb29rcyBsaWtlIEpTT04gKHN0YXJ0cyB3aXRoIHsgb3IgWyksIHRyeSBwYXJzaW5nIGRpcmVjdGx5IGZpcnN0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBoYW5kbGVzIGNhc2VzIHdoZXJlIHRoZSBVUkkgc2F5cyBiYXNlNjQgYnV0IGNvbnRlbnQgaXMgcGxhaW4gdGV4dFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRyaW1tZWREYXRhID0ganNvbkRhdGEudHJpbSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0cmltbWVkRGF0YS5zdGFydHNXaXRoKCd7JykgfHwgdHJpbW1lZERhdGEuc3RhcnRzV2l0aCgnWycpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdbSVBGU10gQ29udGVudCBsb29rcyBsaWtlIHBsYWluIEpTT04sIHRyeWluZyBkaXJlY3QgcGFyc2UgZmlyc3QnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlZCA9IEpTT04ucGFyc2UoanNvbkRhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1tJUEZTXSBEaXJlY3QgcGFyc2Ugc3VjY2Vzc2Z1bCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1tJUEZTXSBEaXJlY3QgcGFyc2UgZmFpbGVkLCBwcm9jZWVkaW5nIHRvIGJhc2U2NCBkZWNvZGUnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIGRpcmVjdCBwYXJzZSBmYWlscywgcHJvY2VlZCB0byBiYXNlNjQgZGVjb2RpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUcnkgYmFzZTY0IGRlY29kZSBmaXJzdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnW0lQRlNdIEF0dGVtcHRpbmcgYmFzZTY0IGRlY29kZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQganNvblN0cmluZztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBhdG9iICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAganNvblN0cmluZyA9IGF0b2IoanNvbkRhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm9kZS5qcyBlbnZpcm9ubWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYnVmZmVyID0gQnVmZmVyLmZyb20oanNvbkRhdGEsICdiYXNlNjQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpzb25TdHJpbmcgPSBidWZmZXIudG9TdHJpbmcoJ3V0Zi04Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1tJUEZTXSBCYXNlNjQgZGVjb2RlZCBzdHJpbmcgKGZpcnN0IDUwIGNoYXJzKTonLCBqc29uU3RyaW5nLnN1YnN0cmluZygwLCA1MCkgKyAnLi4uJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlZCA9IEpTT04ucGFyc2UoanNvblN0cmluZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdbSVBGU10gQmFzZTY0IHBhcnNlIHN1Y2Nlc3NmdWwnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdbSVBGU10gQmFzZTY0IGRlY29kZS9wYXJzZSBmYWlsZWQ6JywgZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIGJhc2U2NCBmYWlscywgdHJ5IHBhcnNpbmcgYXMgcGxhaW4gSlNPTiAoZmFsbGJhY2spXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnW0lQRlNdIFRyeWluZyBwbGFpbiBKU09OIHBhcnNlIGFzIGZhbGxiYWNrJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZWQgPSBKU09OLnBhcnNlKGpzb25EYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdbSVBGU10gRmFsbGJhY2sgcGxhaW4gSlNPTiBwYXJzZSBzdWNjZXNzZnVsJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdbSVBGU10gVHJ5aW5nIFVSTCBkZWNvZGluZyBhcyBmYWxsYmFjaycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRlY29kZWRKc29uID0gZGVjb2RlVVJJQ29tcG9uZW50KGpzb25EYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZWQgPSBKU09OLnBhcnNlKGRlY29kZWRKc29uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnW0lQRlNdIFVSTCBkZWNvZGVkIHBhcnNlIHN1Y2Nlc3NmdWwnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdbSVBGU10gVHJ5aW5nIFVSSSBkZWNvZGUgKyBiYXNlNjQgYXMgZmluYWwgZmFsbGJhY2snKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmluYWwgYXR0ZW1wdDogc29tZXRpbWVzIGJhc2U2NCBzdHJpbmdzIGhhdmUgVVJJIGVuY29kZWQgY2hhcnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYnVmZmVyID0gQnVmZmVyLmZyb20oZGVjb2RlVVJJQ29tcG9uZW50KGpzb25EYXRhKSwgJ2Jhc2U2NCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZWQgPSBKU09OLnBhcnNlKGJ1ZmZlci50b1N0cmluZygndXRmLTgnKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdbSVBGU10gVVJJIGRlY29kZSArIGJhc2U2NCBzdWNjZXNzZnVsJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlNCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdbSVBGU10gQWxsIHBhcnNlIGF0dGVtcHRzIGZhaWxlZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlOyAvLyBUaHJvdyBvcmlnaW5hbCBvciBsYXN0IGVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUGxhaW4gSlNPTiAtIHRyeSBwYXJzaW5nIGRpcmVjdGx5IGZpcnN0LCB0aGVuIFVSTCBkZWNvZGUgaWYgbmVlZGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VkID0gSlNPTi5wYXJzZShqc29uRGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRlY29kZWRKc29uID0gZGVjb2RlVVJJQ29tcG9uZW50KGpzb25EYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VkID0gSlNPTi5wYXJzZShkZWNvZGVkSnNvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdGYWlsZWQgdG8gcGFyc2UgaW5saW5lIGRhdGEgVVJJOicsIGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgY2lkID0gZXh0cmFjdENpZCh0b2tlblVyaSk7XG4gICAgICAgICAgICAgICAgaWYgKGNpZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBEZXRlY3QgaWYgVVJJIHN1Z2dlc3RzIGEgc3BlY2lmaWMgc2VydmljZSAoZnJvbSBVUkwgZm9ybWF0KVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBpc1BpbmF0YVVybCA9IHRva2VuVXJpLmluY2x1ZGVzKCdwaW5hdGEnKSB8fCB0b2tlblVyaS5pbmNsdWRlcygnZ2F0ZXdheS5waW5hdGEuY2xvdWQnKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaXNXZWIzU3RvcmFnZVVybCA9IHRva2VuVXJpLmluY2x1ZGVzKCd3M3MubGluaycpIHx8IHRva2VuVXJpLmluY2x1ZGVzKCd3ZWIzLnN0b3JhZ2UnKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gVHJ5IG11bHRpcGxlIElQRlMgZ2F0ZXdheXMgYXMgZmFsbGJhY2tzXG4gICAgICAgICAgICAgICAgICAgIC8vIFByaW9yaXRpemUgYmFzZWQgb24gZGV0ZWN0ZWQgc2VydmljZSwgdGhlbiB0cnkgYWxsIG9wdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZ2F0ZXdheXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgLy8gUGluYXRhIGdhdGV3YXlzICh0cnkgZmlyc3QgaWYgZGV0ZWN0ZWQgYXMgUGluYXRhLCBvdGhlcndpc2UgYWZ0ZXIgV2ViM1N0b3JhZ2UpXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBpbmF0YUdhdGV3YXlzID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgeyB1cmw6IGBodHRwczovL2dhdGV3YXkucGluYXRhLmNsb3VkL2lwZnMvJHtjaWR9YCwgc2VydmljZTogJ1BpbmF0YSAoZ2F0ZXdheS5waW5hdGEuY2xvdWQpJyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgeyB1cmw6IGBodHRwczovLyR7Y2lkfS5pcGZzLm15cGluYXRhLmNsb3VkYCwgc2VydmljZTogJ1BpbmF0YSAobXlwaW5hdGEuY2xvdWQgc3ViZG9tYWluKScgfSxcbiAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2ViM1N0b3JhZ2UgZ2F0ZXdheXMgKHRyeSBmaXJzdCBpZiBkZXRlY3RlZCBhcyBXZWIzU3RvcmFnZSwgb3RoZXJ3aXNlIHRyeSBlYXJseSlcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgd2ViM1N0b3JhZ2VHYXRld2F5cyA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgdXJsOiBgaHR0cHM6Ly8ke2NpZH0uaXBmcy53M3MubGlua2AsIHNlcnZpY2U6ICdXZWIzU3RvcmFnZSAodzNzLmxpbmspJyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgeyB1cmw6IGBodHRwczovL3czcy5saW5rL2lwZnMvJHtjaWR9YCwgc2VydmljZTogJ1dlYjNTdG9yYWdlICh3M3MubGluayBwYXRoKScgfSxcbiAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgLy8gUHVibGljIElQRlMgZ2F0ZXdheXMgKGZhbGxiYWNrcylcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHVibGljR2F0ZXdheXMgPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7IHVybDogYGh0dHBzOi8vaXBmcy5pby9pcGZzLyR7Y2lkfWAsIHNlcnZpY2U6ICdJUEZTLmlvJyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgeyB1cmw6IGBodHRwczovL2Nsb3VkZmxhcmUtaXBmcy5jb20vaXBmcy8ke2NpZH1gLCBzZXJ2aWNlOiAnQ2xvdWRmbGFyZSBJUEZTJyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgeyB1cmw6IGBodHRwczovL2R3ZWIubGluay9pcGZzLyR7Y2lkfWAsIHNlcnZpY2U6ICdQcm90b2NvbCBMYWJzIChkd2ViLmxpbmspJyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgeyB1cmw6IGBodHRwczovL2dhdGV3YXkuaXBmcy5pby9pcGZzLyR7Y2lkfWAsIHNlcnZpY2U6ICdJUEZTIEdhdGV3YXknIH0sXG4gICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgIC8vIEJ1aWxkIGdhdGV3YXkgbGlzdCB3aXRoIHByaW9yaXR5IGJhc2VkIG9uIGRldGVjdGlvblxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNQaW5hdGFVcmwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFBpbmF0YSBkZXRlY3RlZDogdHJ5IFBpbmF0YSBmaXJzdCwgdGhlbiBXZWIzU3RvcmFnZSwgdGhlbiBwdWJsaWNcbiAgICAgICAgICAgICAgICAgICAgICAgIGdhdGV3YXlzLnB1c2goLi4ucGluYXRhR2F0ZXdheXMsIC4uLndlYjNTdG9yYWdlR2F0ZXdheXMsIC4uLnB1YmxpY0dhdGV3YXlzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpc1dlYjNTdG9yYWdlVXJsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXZWIzU3RvcmFnZSBkZXRlY3RlZDogdHJ5IFdlYjNTdG9yYWdlIGZpcnN0LCB0aGVuIFBpbmF0YSwgdGhlbiBwdWJsaWNcbiAgICAgICAgICAgICAgICAgICAgICAgIGdhdGV3YXlzLnB1c2goLi4ud2ViM1N0b3JhZ2VHYXRld2F5cywgLi4ucGluYXRhR2F0ZXdheXMsIC4uLnB1YmxpY0dhdGV3YXlzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vIGRldGVjdGlvbjogdHJ5IFdlYjNTdG9yYWdlIGZpcnN0IChtb3N0IGNvbW1vbiksIHRoZW4gUGluYXRhLCB0aGVuIHB1YmxpY1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2F0ZXdheXMucHVzaCguLi53ZWIzU3RvcmFnZUdhdGV3YXlzLCAuLi5waW5hdGFHYXRld2F5cywgLi4ucHVibGljR2F0ZXdheXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgeyB1cmw6IGlwZnNVcmwsIHNlcnZpY2UgfSBvZiBnYXRld2F5cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0aW1lb3V0U2lnbmFsID0gY3JlYXRlVGltZW91dFNpZ25hbCh0aW1lb3V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gYXdhaXQgZmV0Y2hGbihpcGZzVXJsLCB7IHNpZ25hbDogdGltZW91dFNpZ25hbCB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzcD8ub2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QganNvbiA9IGF3YWl0IHJlc3AuanNvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ganNvbiA/PyBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3JNc2cgPSBlPy5tZXNzYWdlIHx8IFN0cmluZyhlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEb24ndCBsb2cgdGltZW91dCBlcnJvcnMgZm9yIGV2ZXJ5IGdhdGV3YXkgKHRvbyBub2lzeSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWVycm9yTXNnLmluY2x1ZGVzKCdhYm9ydGVkJykgJiYgIWVycm9yTXNnLmluY2x1ZGVzKCd0aW1lb3V0JykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29udGludWUgc2lsZW50bHkgLSB3aWxsIHRyeSBuZXh0IGdhdGV3YXlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29udGludWUgdG8gbmV4dCBnYXRld2F5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBBbGwgSVBGUyBnYXRld2F5cyBmYWlsZWQgZm9yIENJRDogJHtjaWR9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFRyeSBhcyByZWd1bGFyIEhUVFAvSFRUUFMgVVJMXG4gICAgICAgICAgICAgICAgaWYgKC9eaHR0cHM/OlxcL1xcLy9pLnRlc3QodG9rZW5VcmkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRpbWVvdXRTaWduYWwgPSBjcmVhdGVUaW1lb3V0U2lnbmFsKHRpbWVvdXQpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gYXdhaXQgZmV0Y2hGbih0b2tlblVyaSwgeyBzaWduYWw6IHRpbWVvdXRTaWduYWwgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXNwPy5vaylcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCByZXNwLmpzb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignRXJyb3IgZmV0Y2hpbmcvcGFyc2luZyB0b2tlbiBVUkk6JywgZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0VXJsKGNpZE9yVG9rZW5VcmkpIHtcbiAgICAgICAgICAgIGNvbnN0IGNpZCA9IGV4dHJhY3RDaWQoY2lkT3JUb2tlblVyaSk7XG4gICAgICAgICAgICBpZiAoIWNpZCkge1xuICAgICAgICAgICAgICAgIC8vIElmIGl0J3MgYWxyZWFkeSBhIGZ1bGwgVVJMLCByZXR1cm4gaXRcbiAgICAgICAgICAgICAgICBpZiAoL15odHRwcz86XFwvXFwvL2kudGVzdChjaWRPclRva2VuVXJpKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2lkT3JUb2tlblVyaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIENJRCBvciB0b2tlblVyaTogJHtjaWRPclRva2VuVXJpfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGdldFVybEZyb21DaWQoY2lkKTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuLyoqXG4gKiBEZWZhdWx0IElQRlMgc3RvcmFnZSBpbnN0YW5jZSAoc2luZ2xldG9uIHBhdHRlcm4pXG4gKiBVc2VzIGVudmlyb25tZW50IHZhcmlhYmxlcywgZGVmYXVsdHMgdG8gUGluYXRhXG4gKi9cbmxldCBkZWZhdWx0SVBGU1N0b3JhZ2UgPSBudWxsO1xuLyoqXG4gKiBHZXQgb3IgY3JlYXRlIGRlZmF1bHQgSVBGUyBzdG9yYWdlIGluc3RhbmNlIChzaW5nbGV0b24pXG4gKiBJbml0aWFsaXplcyBmcm9tIGVudmlyb25tZW50IHZhcmlhYmxlcywgZGVmYXVsdHMgdG8gUGluYXRhXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRJUEZTU3RvcmFnZSgpIHtcbiAgICBpZiAoIWRlZmF1bHRJUEZTU3RvcmFnZSkge1xuICAgICAgICBjb25zdCBjb25maWcgPSB7XG4gICAgICAgICAgICBwaW5hdGFKd3Q6IHByb2Nlc3MuZW52LlBJTkFUQV9KV1QsXG4gICAgICAgICAgICBwaW5hdGFBcGlLZXk6IHByb2Nlc3MuZW52LlBJTkFUQV9BUElfS0VZLFxuICAgICAgICAgICAgcGluYXRhQXBpU2VjcmV0OiBwcm9jZXNzLmVudi5QSU5BVEFfQVBJX1NFQ1JFVCxcbiAgICAgICAgICAgIHdlYjNTdG9yYWdlVG9rZW46IHByb2Nlc3MuZW52LldFQjNfU1RPUkFHRV9UT0tFTiB8fCBwcm9jZXNzLmVudi5XRUIzX1NUT1JBR0VfQVBJX0tFWSxcbiAgICAgICAgICAgIGdhdGV3YXlVcmw6IHByb2Nlc3MuZW52LklQRlNfR0FURVdBWV9VUkwgfHwgJ2h0dHBzOi8vZ2F0ZXdheS5waW5hdGEuY2xvdWQvaXBmcy8nLFxuICAgICAgICAgICAgaXBmc0FwaVVybDogcHJvY2Vzcy5lbnYuSVBGU19BUElfVVJMLFxuICAgICAgICAgICAgdGltZW91dDogMTAwMDAsXG4gICAgICAgIH07XG4gICAgICAgIGRlZmF1bHRJUEZTU3RvcmFnZSA9IGNyZWF0ZUlQRlNTdG9yYWdlKGNvbmZpZyk7XG4gICAgfVxuICAgIHJldHVybiBkZWZhdWx0SVBGU1N0b3JhZ2U7XG59XG4vKipcbiAqIENoZWNrIGlmIElQRlMgc3RvcmFnZSBpcyBpbml0aWFsaXplZFxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNJUEZTU3RvcmFnZUluaXRpYWxpemVkKCkge1xuICAgIHJldHVybiBkZWZhdWx0SVBGU1N0b3JhZ2UgIT09IG51bGw7XG59XG4vKipcbiAqIFJlc2V0IGRlZmF1bHQgSVBGUyBzdG9yYWdlIGluc3RhbmNlICh1c2VmdWwgZm9yIHRlc3RpbmcpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXNldElQRlNTdG9yYWdlKCkge1xuICAgIGRlZmF1bHRJUEZTU3RvcmFnZSA9IG51bGw7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pcGZzLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@agentic-trust/core/dist/server/lib/ipfs.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@agentic-trust/core/dist/server/lib/names.js":
/*!***********************************************************************!*\
  !*** ../../node_modules/@agentic-trust/core/dist/server/lib/names.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addToL1OrgPK: () => (/* binding */ addToL1OrgPK),\n/* harmony export */   setL1NameInfoPK: () => (/* binding */ setL1NameInfoPK)\n/* harmony export */ });\n/* harmony import */ var _singletons_ensClient__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../singletons/ensClient */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/singletons/ensClient.js\");\n/* harmony import */ var _chainConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./chainConfig */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/lib/chainConfig.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! viem */ \"(rsc)/../../node_modules/viem/_esm/clients/createPublicClient.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! viem */ \"(rsc)/../../node_modules/viem/_esm/clients/transports/http.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! viem */ \"(rsc)/../../node_modules/viem/_esm/clients/createWalletClient.js\");\n/* harmony import */ var viem_accounts__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! viem/accounts */ \"(rsc)/../../node_modules/viem/_esm/accounts/privateKeyToAccount.js\");\n/* harmony import */ var _client_accountClient__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../client/accountClient */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/client/accountClient.js\");\n/* harmony import */ var _metamask_smart_accounts_kit__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @metamask/smart-accounts-kit */ \"(rsc)/../../node_modules/@metamask/smart-accounts-kit/dist/index.mjs\");\n/* harmony import */ var _metamask_smart_accounts_kit__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @metamask/smart-accounts-kit */ \"(rsc)/../../node_modules/@metamask/smart-accounts-kit/dist/chunk-7MRTROLV.mjs\");\n\n\n\n\n\n\nasync function addToL1OrgPK(params) {\n    const targetChainId = params.chainId || 11155111;\n    const ensClient = await (0,_singletons_ensClient__WEBPACK_IMPORTED_MODULE_0__.getENSClient)(targetChainId);\n    const { calls } = await ensClient.prepareAddAgentNameToOrgCalls({\n        orgName: params.orgName,\n        agentName: params.agentName,\n        agentAddress: params.agentAddress,\n        agentUrl: params.agentUrl || '',\n    });\n    return await executeEnsCallsWithOrgPK({ calls, chainId: targetChainId });\n}\nasync function setL1NameInfoPK(params) {\n    const targetChainId = params.chainId || 11155111;\n    const ensClient = await (0,_singletons_ensClient__WEBPACK_IMPORTED_MODULE_0__.getENSClient)(targetChainId);\n    const { calls } = await ensClient.prepareSetAgentNameInfoCalls({\n        agentAddress: params.agentAddress,\n        orgName: params.orgName,\n        agentName: params.agentName,\n        agentUrl: params.agentUrl,\n        agentDescription: params.agentDescription,\n    });\n    return await executeEnsCallsWithOrgPK({ calls, chainId: targetChainId });\n}\nasync function executeEnsCallsWithOrgPK(params) {\n    const { calls, chainId } = params;\n    const bundlerUrl = (0,_chainConfig__WEBPACK_IMPORTED_MODULE_1__.requireChainEnvVar)('AGENTIC_TRUST_BUNDLER_URL', chainId);\n    const rpcUrl = (0,_chainConfig__WEBPACK_IMPORTED_MODULE_1__.requireChainEnvVar)('AGENTIC_TRUST_RPC_URL', chainId);\n    const privKey = (0,_chainConfig__WEBPACK_IMPORTED_MODULE_1__.getEnsPrivateKey)(chainId);\n    const orgAddress = (0,_chainConfig__WEBPACK_IMPORTED_MODULE_1__.getEnsOrgAddress)(chainId);\n    const chain = (0,_chainConfig__WEBPACK_IMPORTED_MODULE_1__.getChainById)(chainId);\n    const publicClient = (0,viem__WEBPACK_IMPORTED_MODULE_3__.createPublicClient)({ chain: chain, transport: (0,viem__WEBPACK_IMPORTED_MODULE_4__.http)(rpcUrl) });\n    const walletAccount = (0,viem_accounts__WEBPACK_IMPORTED_MODULE_5__.privateKeyToAccount)(privKey);\n    const walletClient = (0,viem__WEBPACK_IMPORTED_MODULE_6__.createWalletClient)({\n        account: walletAccount,\n        chain: chain,\n        transport: (0,viem__WEBPACK_IMPORTED_MODULE_4__.http)(rpcUrl),\n    });\n    const orgAccountClient = await (0,_metamask_smart_accounts_kit__WEBPACK_IMPORTED_MODULE_7__.toMetaMaskSmartAccount)({\n        address: orgAddress,\n        client: publicClient,\n        implementation: _metamask_smart_accounts_kit__WEBPACK_IMPORTED_MODULE_8__.Implementation.Hybrid,\n        signer: { walletClient: walletClient },\n    });\n    const formattedCalls = calls.map(call => ({\n        to: call.to,\n        data: call.data,\n        value: typeof call.value === 'bigint' ? call.value : BigInt(call.value ?? 0),\n    }));\n    const userOpHash = await (0,_client_accountClient__WEBPACK_IMPORTED_MODULE_2__.sendSponsoredUserOperation)({\n        bundlerUrl,\n        chain,\n        accountClient: orgAccountClient,\n        calls: formattedCalls,\n    });\n    const receipt = await (0,_client_accountClient__WEBPACK_IMPORTED_MODULE_2__.waitForUserOperationReceipt)({ bundlerUrl, chain, hash: userOpHash });\n    return { userOpHash, receipt };\n}\n//# sourceMappingURL=names.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BhZ2VudGljLXRydXN0L2NvcmUvZGlzdC9zZXJ2ZXIvbGliL25hbWVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQXdEO0FBQzhDO0FBQ2xDO0FBQ2hCO0FBQ2tEO0FBQ2hCO0FBQy9FO0FBQ1A7QUFDQSw0QkFBNEIsbUVBQVk7QUFDeEMsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLDRDQUE0QywrQkFBK0I7QUFDM0U7QUFDTztBQUNQO0FBQ0EsNEJBQTRCLG1FQUFZO0FBQ3hDLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLDRDQUE0QywrQkFBK0I7QUFDM0U7QUFDQTtBQUNBLFlBQVksaUJBQWlCO0FBQzdCLHVCQUF1QixnRUFBa0I7QUFDekMsbUJBQW1CLGdFQUFrQjtBQUNyQyxvQkFBb0IsOERBQWdCO0FBQ3BDLHVCQUF1Qiw4REFBZ0I7QUFDdkMsa0JBQWtCLDBEQUFZO0FBQzlCLHlCQUF5Qix3REFBa0IsR0FBRyx5QkFBeUIsMENBQUksVUFBVTtBQUNyRiwwQkFBMEIsa0VBQW1CO0FBQzdDLHlCQUF5Qix3REFBa0I7QUFDM0M7QUFDQTtBQUNBLG1CQUFtQiwwQ0FBSTtBQUN2QixLQUFLO0FBQ0wsbUNBQW1DLG9GQUFzQjtBQUN6RDtBQUNBO0FBQ0Esd0JBQXdCLHdFQUFjO0FBQ3RDLGtCQUFrQiw0QkFBNEI7QUFDOUMsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLDZCQUE2QixpRkFBMEI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsMEJBQTBCLGtGQUEyQixHQUFHLHFDQUFxQztBQUM3RixhQUFhO0FBQ2I7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvYmFyYi9hYS9Bc3NvY2lhdGVkQWNjb3VudHMvbm9kZV9tb2R1bGVzL0BhZ2VudGljLXRydXN0L2NvcmUvZGlzdC9zZXJ2ZXIvbGliL25hbWVzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGdldEVOU0NsaWVudCwgfSBmcm9tICcuLi9zaW5nbGV0b25zL2Vuc0NsaWVudCc7XG5pbXBvcnQgeyByZXF1aXJlQ2hhaW5FbnZWYXIsIGdldEVuc09yZ0FkZHJlc3MsIGdldEVuc1ByaXZhdGVLZXksIGdldENoYWluQnlJZCwgfSBmcm9tICcuL2NoYWluQ29uZmlnJztcbmltcG9ydCB7IGNyZWF0ZVB1YmxpY0NsaWVudCwgY3JlYXRlV2FsbGV0Q2xpZW50LCBodHRwIH0gZnJvbSAndmllbSc7XG5pbXBvcnQgeyBwcml2YXRlS2V5VG9BY2NvdW50IH0gZnJvbSAndmllbS9hY2NvdW50cyc7XG5pbXBvcnQgeyBzZW5kU3BvbnNvcmVkVXNlck9wZXJhdGlvbiwgd2FpdEZvclVzZXJPcGVyYXRpb25SZWNlaXB0LCB9IGZyb20gJy4uLy4uL2NsaWVudC9hY2NvdW50Q2xpZW50JztcbmltcG9ydCB7IEltcGxlbWVudGF0aW9uLCB0b01ldGFNYXNrU21hcnRBY2NvdW50IH0gZnJvbSAnQG1ldGFtYXNrL3NtYXJ0LWFjY291bnRzLWtpdCc7XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gYWRkVG9MMU9yZ1BLKHBhcmFtcykge1xuICAgIGNvbnN0IHRhcmdldENoYWluSWQgPSBwYXJhbXMuY2hhaW5JZCB8fCAxMTE1NTExMTtcbiAgICBjb25zdCBlbnNDbGllbnQgPSBhd2FpdCBnZXRFTlNDbGllbnQodGFyZ2V0Q2hhaW5JZCk7XG4gICAgY29uc3QgeyBjYWxscyB9ID0gYXdhaXQgZW5zQ2xpZW50LnByZXBhcmVBZGRBZ2VudE5hbWVUb09yZ0NhbGxzKHtcbiAgICAgICAgb3JnTmFtZTogcGFyYW1zLm9yZ05hbWUsXG4gICAgICAgIGFnZW50TmFtZTogcGFyYW1zLmFnZW50TmFtZSxcbiAgICAgICAgYWdlbnRBZGRyZXNzOiBwYXJhbXMuYWdlbnRBZGRyZXNzLFxuICAgICAgICBhZ2VudFVybDogcGFyYW1zLmFnZW50VXJsIHx8ICcnLFxuICAgIH0pO1xuICAgIHJldHVybiBhd2FpdCBleGVjdXRlRW5zQ2FsbHNXaXRoT3JnUEsoeyBjYWxscywgY2hhaW5JZDogdGFyZ2V0Q2hhaW5JZCB9KTtcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzZXRMMU5hbWVJbmZvUEsocGFyYW1zKSB7XG4gICAgY29uc3QgdGFyZ2V0Q2hhaW5JZCA9IHBhcmFtcy5jaGFpbklkIHx8IDExMTU1MTExO1xuICAgIGNvbnN0IGVuc0NsaWVudCA9IGF3YWl0IGdldEVOU0NsaWVudCh0YXJnZXRDaGFpbklkKTtcbiAgICBjb25zdCB7IGNhbGxzIH0gPSBhd2FpdCBlbnNDbGllbnQucHJlcGFyZVNldEFnZW50TmFtZUluZm9DYWxscyh7XG4gICAgICAgIGFnZW50QWRkcmVzczogcGFyYW1zLmFnZW50QWRkcmVzcyxcbiAgICAgICAgb3JnTmFtZTogcGFyYW1zLm9yZ05hbWUsXG4gICAgICAgIGFnZW50TmFtZTogcGFyYW1zLmFnZW50TmFtZSxcbiAgICAgICAgYWdlbnRVcmw6IHBhcmFtcy5hZ2VudFVybCxcbiAgICAgICAgYWdlbnREZXNjcmlwdGlvbjogcGFyYW1zLmFnZW50RGVzY3JpcHRpb24sXG4gICAgfSk7XG4gICAgcmV0dXJuIGF3YWl0IGV4ZWN1dGVFbnNDYWxsc1dpdGhPcmdQSyh7IGNhbGxzLCBjaGFpbklkOiB0YXJnZXRDaGFpbklkIH0pO1xufVxuYXN5bmMgZnVuY3Rpb24gZXhlY3V0ZUVuc0NhbGxzV2l0aE9yZ1BLKHBhcmFtcykge1xuICAgIGNvbnN0IHsgY2FsbHMsIGNoYWluSWQgfSA9IHBhcmFtcztcbiAgICBjb25zdCBidW5kbGVyVXJsID0gcmVxdWlyZUNoYWluRW52VmFyKCdBR0VOVElDX1RSVVNUX0JVTkRMRVJfVVJMJywgY2hhaW5JZCk7XG4gICAgY29uc3QgcnBjVXJsID0gcmVxdWlyZUNoYWluRW52VmFyKCdBR0VOVElDX1RSVVNUX1JQQ19VUkwnLCBjaGFpbklkKTtcbiAgICBjb25zdCBwcml2S2V5ID0gZ2V0RW5zUHJpdmF0ZUtleShjaGFpbklkKTtcbiAgICBjb25zdCBvcmdBZGRyZXNzID0gZ2V0RW5zT3JnQWRkcmVzcyhjaGFpbklkKTtcbiAgICBjb25zdCBjaGFpbiA9IGdldENoYWluQnlJZChjaGFpbklkKTtcbiAgICBjb25zdCBwdWJsaWNDbGllbnQgPSBjcmVhdGVQdWJsaWNDbGllbnQoeyBjaGFpbjogY2hhaW4sIHRyYW5zcG9ydDogaHR0cChycGNVcmwpIH0pO1xuICAgIGNvbnN0IHdhbGxldEFjY291bnQgPSBwcml2YXRlS2V5VG9BY2NvdW50KHByaXZLZXkpO1xuICAgIGNvbnN0IHdhbGxldENsaWVudCA9IGNyZWF0ZVdhbGxldENsaWVudCh7XG4gICAgICAgIGFjY291bnQ6IHdhbGxldEFjY291bnQsXG4gICAgICAgIGNoYWluOiBjaGFpbixcbiAgICAgICAgdHJhbnNwb3J0OiBodHRwKHJwY1VybCksXG4gICAgfSk7XG4gICAgY29uc3Qgb3JnQWNjb3VudENsaWVudCA9IGF3YWl0IHRvTWV0YU1hc2tTbWFydEFjY291bnQoe1xuICAgICAgICBhZGRyZXNzOiBvcmdBZGRyZXNzLFxuICAgICAgICBjbGllbnQ6IHB1YmxpY0NsaWVudCxcbiAgICAgICAgaW1wbGVtZW50YXRpb246IEltcGxlbWVudGF0aW9uLkh5YnJpZCxcbiAgICAgICAgc2lnbmVyOiB7IHdhbGxldENsaWVudDogd2FsbGV0Q2xpZW50IH0sXG4gICAgfSk7XG4gICAgY29uc3QgZm9ybWF0dGVkQ2FsbHMgPSBjYWxscy5tYXAoY2FsbCA9PiAoe1xuICAgICAgICB0bzogY2FsbC50byxcbiAgICAgICAgZGF0YTogY2FsbC5kYXRhLFxuICAgICAgICB2YWx1ZTogdHlwZW9mIGNhbGwudmFsdWUgPT09ICdiaWdpbnQnID8gY2FsbC52YWx1ZSA6IEJpZ0ludChjYWxsLnZhbHVlID8/IDApLFxuICAgIH0pKTtcbiAgICBjb25zdCB1c2VyT3BIYXNoID0gYXdhaXQgc2VuZFNwb25zb3JlZFVzZXJPcGVyYXRpb24oe1xuICAgICAgICBidW5kbGVyVXJsLFxuICAgICAgICBjaGFpbixcbiAgICAgICAgYWNjb3VudENsaWVudDogb3JnQWNjb3VudENsaWVudCxcbiAgICAgICAgY2FsbHM6IGZvcm1hdHRlZENhbGxzLFxuICAgIH0pO1xuICAgIGNvbnN0IHJlY2VpcHQgPSBhd2FpdCB3YWl0Rm9yVXNlck9wZXJhdGlvblJlY2VpcHQoeyBidW5kbGVyVXJsLCBjaGFpbiwgaGFzaDogdXNlck9wSGFzaCB9KTtcbiAgICByZXR1cm4geyB1c2VyT3BIYXNoLCByZWNlaXB0IH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1uYW1lcy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@agentic-trust/core/dist/server/lib/names.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@agentic-trust/core/dist/server/lib/resolveAccount.js":
/*!********************************************************************************!*\
  !*** ../../node_modules/@agentic-trust/core/dist/server/lib/resolveAccount.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   handleResolveAccount: () => (/* binding */ handleResolveAccount)\n/* harmony export */ });\n/* harmony import */ var _accounts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./accounts */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/lib/accounts.js\");\n/**\n * Reusable API route handler for resolving agent account by name\n * Handles ENS resolution\n */\n\nconst ZERO_ADDRESS = '0x0000000000000000000000000000000000000000';\nfunction isValidAddress(value) {\n    return (typeof value === 'string' &&\n        value.startsWith('0x') &&\n        value.length === 42 &&\n        value.toLowerCase() !== ZERO_ADDRESS);\n}\n/**\n * Resolve agent account by name\n * Tries ENS resolution first, then returns null (client should compute deterministically)\n *\n * @param body - Request body with agent name\n * @param getClient - Function to get the AgenticTrustClient instance (app-specific)\n * @returns Response with resolved account address or null\n */\nasync function handleResolveAccount(body, getClient) {\n    try {\n        const { agentName } = body;\n        console.log(\"*********** zzz handleResolveAccount agentName\", agentName);\n        if (!agentName || !agentName.trim()) {\n            return {\n                account: null,\n                method: null,\n                error: 'agentName is required',\n            };\n        }\n        const client = await getClient();\n        const ensClient = await client.getENSClient();\n        if (!ensClient) {\n            return {\n                account: null,\n                method: null,\n                error: 'ENS client not available',\n            };\n        }\n        // Check if ENS client is properly configured\n        const ensRegistryAddress = ensClient?.suilookeen_registrar ?? ensClient?.ensRegistryAddress;\n        if (!ensRegistryAddress || ensRegistryAddress === '' || ensRegistryAddress === '0x0000000000000000000000000000000000000000') {\n            return {\n                account: null,\n                method: null,\n                error: 'ENS client not properly configured',\n            };\n        }\n        // Try to resolve via ENS -> agent-identity -> agentId -> on-chain account\n        try {\n            const { agentId, account } = await ensClient.getAgentIdentityByName(agentName.trim());\n            if (isValidAddress(account)) {\n                return {\n                    account: account,\n                    method: 'ens-identity',\n                };\n            }\n        }\n        catch (ensError) {\n            console.warn('ENS identity resolution failed:', ensError);\n        }\n        // Try to get agent account via ENS name directly\n        try {\n            const ensAgentAddress = await ensClient.getAgentAccountByName(agentName);\n            if (isValidAddress(ensAgentAddress)) {\n                return {\n                    account: ensAgentAddress,\n                    method: 'ens-direct',\n                };\n            }\n        }\n        catch (ensError) {\n            console.warn('ENS direct resolution failed:', ensError);\n        }\n        // Try discovery client lookup\n        try {\n            const discoveryClient = await client.getDiscoveryClient();\n            if (discoveryClient) {\n                const discoveryAgent = await discoveryClient.getAgentByName(agentName.trim());\n                console.log(\"*********** zzz handleResolveAccount discoveryAgent\", discoveryAgent);\n                const discoveryAccount = (0,_accounts__WEBPACK_IMPORTED_MODULE_0__.extractAgentAccountFromDiscovery)(discoveryAgent);\n                console.log(\"*********** zzz handleResolveAccount discoveryAccount\", discoveryAccount);\n                if (isValidAddress(discoveryAccount)) {\n                    return {\n                        account: discoveryAccount,\n                        method: 'discovery',\n                    };\n                }\n                const a2aEndpoint = typeof discoveryAgent?.a2aEndpoint === 'string'\n                    ? discoveryAgent.a2aEndpoint.trim()\n                    : '';\n                if (a2aEndpoint) {\n                    try {\n                        const response = await fetch(a2aEndpoint, {\n                            headers: {\n                                Accept: 'application/json, text/plain;q=0.9',\n                            },\n                        });\n                        if (response.ok) {\n                            const json = await response.json();\n                            const endpointAccount = (json && typeof json === 'object'\n                                ? (json.agentAccount || json.agent?.account || json.account || null)\n                                : null);\n                            const derivedAccount = isValidAddress(endpointAccount)\n                                ? endpointAccount\n                                : (0,_accounts__WEBPACK_IMPORTED_MODULE_0__.extractAgentAccountFromDiscovery)(json);\n                            if (isValidAddress(derivedAccount)) {\n                                return {\n                                    account: derivedAccount,\n                                    method: 'discovery',\n                                };\n                            }\n                        }\n                    }\n                    catch (endpointError) {\n                        console.warn('Failed to fetch agent data from discovery endpoint:', endpointError);\n                    }\n                }\n            }\n        }\n        catch (discoveryError) {\n            console.warn('Discovery lookup failed:', discoveryError);\n        }\n        // No ENS resolution found - client should compute deterministically\n        return {\n            account: null,\n            method: 'deterministic',\n        };\n    }\n    catch (error) {\n        console.error('Error resolving account:', error);\n        const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n        return {\n            account: null,\n            method: null,\n            error: errorMessage,\n        };\n    }\n}\n//# sourceMappingURL=resolveAccount.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BhZ2VudGljLXRydXN0L2NvcmUvZGlzdC9zZXJ2ZXIvbGliL3Jlc29sdmVBY2NvdW50LmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLGdCQUFnQixZQUFZO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1CQUFtQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLDJFQUFnQztBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFO0FBQ3RFLDZCQUE2QjtBQUM3Qix5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsMkVBQWdDO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9iYXJiL2FhL0Fzc29jaWF0ZWRBY2NvdW50cy9ub2RlX21vZHVsZXMvQGFnZW50aWMtdHJ1c3QvY29yZS9kaXN0L3NlcnZlci9saWIvcmVzb2x2ZUFjY291bnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBSZXVzYWJsZSBBUEkgcm91dGUgaGFuZGxlciBmb3IgcmVzb2x2aW5nIGFnZW50IGFjY291bnQgYnkgbmFtZVxuICogSGFuZGxlcyBFTlMgcmVzb2x1dGlvblxuICovXG5pbXBvcnQgeyBleHRyYWN0QWdlbnRBY2NvdW50RnJvbURpc2NvdmVyeSB9IGZyb20gJy4vYWNjb3VudHMnO1xuY29uc3QgWkVST19BRERSRVNTID0gJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCc7XG5mdW5jdGlvbiBpc1ZhbGlkQWRkcmVzcyh2YWx1ZSkge1xuICAgIHJldHVybiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJlxuICAgICAgICB2YWx1ZS5zdGFydHNXaXRoKCcweCcpICYmXG4gICAgICAgIHZhbHVlLmxlbmd0aCA9PT0gNDIgJiZcbiAgICAgICAgdmFsdWUudG9Mb3dlckNhc2UoKSAhPT0gWkVST19BRERSRVNTKTtcbn1cbi8qKlxuICogUmVzb2x2ZSBhZ2VudCBhY2NvdW50IGJ5IG5hbWVcbiAqIFRyaWVzIEVOUyByZXNvbHV0aW9uIGZpcnN0LCB0aGVuIHJldHVybnMgbnVsbCAoY2xpZW50IHNob3VsZCBjb21wdXRlIGRldGVybWluaXN0aWNhbGx5KVxuICpcbiAqIEBwYXJhbSBib2R5IC0gUmVxdWVzdCBib2R5IHdpdGggYWdlbnQgbmFtZVxuICogQHBhcmFtIGdldENsaWVudCAtIEZ1bmN0aW9uIHRvIGdldCB0aGUgQWdlbnRpY1RydXN0Q2xpZW50IGluc3RhbmNlIChhcHAtc3BlY2lmaWMpXG4gKiBAcmV0dXJucyBSZXNwb25zZSB3aXRoIHJlc29sdmVkIGFjY291bnQgYWRkcmVzcyBvciBudWxsXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBoYW5kbGVSZXNvbHZlQWNjb3VudChib2R5LCBnZXRDbGllbnQpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCB7IGFnZW50TmFtZSB9ID0gYm9keTtcbiAgICAgICAgY29uc29sZS5sb2coXCIqKioqKioqKioqKiB6enogaGFuZGxlUmVzb2x2ZUFjY291bnQgYWdlbnROYW1lXCIsIGFnZW50TmFtZSk7XG4gICAgICAgIGlmICghYWdlbnROYW1lIHx8ICFhZ2VudE5hbWUudHJpbSgpKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGFjY291bnQ6IG51bGwsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiBudWxsLFxuICAgICAgICAgICAgICAgIGVycm9yOiAnYWdlbnROYW1lIGlzIHJlcXVpcmVkJyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2xpZW50ID0gYXdhaXQgZ2V0Q2xpZW50KCk7XG4gICAgICAgIGNvbnN0IGVuc0NsaWVudCA9IGF3YWl0IGNsaWVudC5nZXRFTlNDbGllbnQoKTtcbiAgICAgICAgaWYgKCFlbnNDbGllbnQpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYWNjb3VudDogbnVsbCxcbiAgICAgICAgICAgICAgICBtZXRob2Q6IG51bGwsXG4gICAgICAgICAgICAgICAgZXJyb3I6ICdFTlMgY2xpZW50IG5vdCBhdmFpbGFibGUnLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDaGVjayBpZiBFTlMgY2xpZW50IGlzIHByb3Blcmx5IGNvbmZpZ3VyZWRcbiAgICAgICAgY29uc3QgZW5zUmVnaXN0cnlBZGRyZXNzID0gZW5zQ2xpZW50Py5zdWlsb29rZWVuX3JlZ2lzdHJhciA/PyBlbnNDbGllbnQ/LmVuc1JlZ2lzdHJ5QWRkcmVzcztcbiAgICAgICAgaWYgKCFlbnNSZWdpc3RyeUFkZHJlc3MgfHwgZW5zUmVnaXN0cnlBZGRyZXNzID09PSAnJyB8fCBlbnNSZWdpc3RyeUFkZHJlc3MgPT09ICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGFjY291bnQ6IG51bGwsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiBudWxsLFxuICAgICAgICAgICAgICAgIGVycm9yOiAnRU5TIGNsaWVudCBub3QgcHJvcGVybHkgY29uZmlndXJlZCcsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIC8vIFRyeSB0byByZXNvbHZlIHZpYSBFTlMgLT4gYWdlbnQtaWRlbnRpdHkgLT4gYWdlbnRJZCAtPiBvbi1jaGFpbiBhY2NvdW50XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB7IGFnZW50SWQsIGFjY291bnQgfSA9IGF3YWl0IGVuc0NsaWVudC5nZXRBZ2VudElkZW50aXR5QnlOYW1lKGFnZW50TmFtZS50cmltKCkpO1xuICAgICAgICAgICAgaWYgKGlzVmFsaWRBZGRyZXNzKGFjY291bnQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgYWNjb3VudDogYWNjb3VudCxcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAnZW5zLWlkZW50aXR5JyxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlbnNFcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdFTlMgaWRlbnRpdHkgcmVzb2x1dGlvbiBmYWlsZWQ6JywgZW5zRXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRyeSB0byBnZXQgYWdlbnQgYWNjb3VudCB2aWEgRU5TIG5hbWUgZGlyZWN0bHlcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGVuc0FnZW50QWRkcmVzcyA9IGF3YWl0IGVuc0NsaWVudC5nZXRBZ2VudEFjY291bnRCeU5hbWUoYWdlbnROYW1lKTtcbiAgICAgICAgICAgIGlmIChpc1ZhbGlkQWRkcmVzcyhlbnNBZ2VudEFkZHJlc3MpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgYWNjb3VudDogZW5zQWdlbnRBZGRyZXNzLFxuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6ICdlbnMtZGlyZWN0JyxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlbnNFcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdFTlMgZGlyZWN0IHJlc29sdXRpb24gZmFpbGVkOicsIGVuc0Vycm9yKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUcnkgZGlzY292ZXJ5IGNsaWVudCBsb29rdXBcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGRpc2NvdmVyeUNsaWVudCA9IGF3YWl0IGNsaWVudC5nZXREaXNjb3ZlcnlDbGllbnQoKTtcbiAgICAgICAgICAgIGlmIChkaXNjb3ZlcnlDbGllbnQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkaXNjb3ZlcnlBZ2VudCA9IGF3YWl0IGRpc2NvdmVyeUNsaWVudC5nZXRBZ2VudEJ5TmFtZShhZ2VudE5hbWUudHJpbSgpKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIioqKioqKioqKioqIHp6eiBoYW5kbGVSZXNvbHZlQWNjb3VudCBkaXNjb3ZlcnlBZ2VudFwiLCBkaXNjb3ZlcnlBZ2VudCk7XG4gICAgICAgICAgICAgICAgY29uc3QgZGlzY292ZXJ5QWNjb3VudCA9IGV4dHJhY3RBZ2VudEFjY291bnRGcm9tRGlzY292ZXJ5KGRpc2NvdmVyeUFnZW50KTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIioqKioqKioqKioqIHp6eiBoYW5kbGVSZXNvbHZlQWNjb3VudCBkaXNjb3ZlcnlBY2NvdW50XCIsIGRpc2NvdmVyeUFjY291bnQpO1xuICAgICAgICAgICAgICAgIGlmIChpc1ZhbGlkQWRkcmVzcyhkaXNjb3ZlcnlBY2NvdW50KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWNjb3VudDogZGlzY292ZXJ5QWNjb3VudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZDogJ2Rpc2NvdmVyeScsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGEyYUVuZHBvaW50ID0gdHlwZW9mIGRpc2NvdmVyeUFnZW50Py5hMmFFbmRwb2ludCA9PT0gJ3N0cmluZydcbiAgICAgICAgICAgICAgICAgICAgPyBkaXNjb3ZlcnlBZ2VudC5hMmFFbmRwb2ludC50cmltKClcbiAgICAgICAgICAgICAgICAgICAgOiAnJztcbiAgICAgICAgICAgICAgICBpZiAoYTJhRW5kcG9pbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYTJhRW5kcG9pbnQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFjY2VwdDogJ2FwcGxpY2F0aW9uL2pzb24sIHRleHQvcGxhaW47cT0wLjknLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGpzb24gPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZW5kcG9pbnRBY2NvdW50ID0gKGpzb24gJiYgdHlwZW9mIGpzb24gPT09ICdvYmplY3QnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gKGpzb24uYWdlbnRBY2NvdW50IHx8IGpzb24uYWdlbnQ/LmFjY291bnQgfHwganNvbi5hY2NvdW50IHx8IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogbnVsbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGVyaXZlZEFjY291bnQgPSBpc1ZhbGlkQWRkcmVzcyhlbmRwb2ludEFjY291bnQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gZW5kcG9pbnRBY2NvdW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogZXh0cmFjdEFnZW50QWNjb3VudEZyb21EaXNjb3ZlcnkoanNvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzVmFsaWRBZGRyZXNzKGRlcml2ZWRBY2NvdW50KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWNjb3VudDogZGVyaXZlZEFjY291bnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRob2Q6ICdkaXNjb3ZlcnknLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZW5kcG9pbnRFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdGYWlsZWQgdG8gZmV0Y2ggYWdlbnQgZGF0YSBmcm9tIGRpc2NvdmVyeSBlbmRwb2ludDonLCBlbmRwb2ludEVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZGlzY292ZXJ5RXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignRGlzY292ZXJ5IGxvb2t1cCBmYWlsZWQ6JywgZGlzY292ZXJ5RXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5vIEVOUyByZXNvbHV0aW9uIGZvdW5kIC0gY2xpZW50IHNob3VsZCBjb21wdXRlIGRldGVybWluaXN0aWNhbGx5XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhY2NvdW50OiBudWxsLFxuICAgICAgICAgICAgbWV0aG9kOiAnZGV0ZXJtaW5pc3RpYycsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciByZXNvbHZpbmcgYWNjb3VudDonLCBlcnJvcik7XG4gICAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYWNjb3VudDogbnVsbCxcbiAgICAgICAgICAgIG1ldGhvZDogbnVsbCxcbiAgICAgICAgICAgIGVycm9yOiBlcnJvck1lc3NhZ2UsXG4gICAgICAgIH07XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVzb2x2ZUFjY291bnQuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@agentic-trust/core/dist/server/lib/resolveAccount.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@agentic-trust/core/dist/server/lib/sessionPackage.js":
/*!********************************************************************************!*\
  !*** ../../node_modules/@agentic-trust/core/dist/server/lib/sessionPackage.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   buildAgentAccountFromSession: () => (/* binding */ buildAgentAccountFromSession),\n/* harmony export */   buildDelegationSetup: () => (/* binding */ buildDelegationSetup),\n/* harmony export */   buildSessionPackage: () => (/* binding */ buildSessionPackage),\n/* harmony export */   loadSessionPackage: () => (/* binding */ loadSessionPackage),\n/* harmony export */   validateSessionPackage: () => (/* binding */ validateSessionPackage)\n/* harmony export */ });\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fs */ \"fs\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! path */ \"path\");\n/* harmony import */ var url__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! url */ \"url\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! viem */ \"(rsc)/../../node_modules/viem/_esm/utils/chain/defineChain.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! viem */ \"(rsc)/../../node_modules/viem/_esm/clients/createPublicClient.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! viem */ \"(rsc)/../../node_modules/viem/_esm/clients/transports/http.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! viem */ \"(rsc)/../../node_modules/viem/_esm/clients/createWalletClient.js\");\n/* harmony import */ var viem_accounts__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! viem/accounts */ \"(rsc)/../../node_modules/viem/_esm/accounts/privateKeyToAccount.js\");\n/* harmony import */ var _chainConfig__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./chainConfig */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/lib/chainConfig.js\");\n/* harmony import */ var _metamask_smart_accounts_kit__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @metamask/smart-accounts-kit */ \"(rsc)/../../node_modules/@metamask/smart-accounts-kit/dist/index.mjs\");\n/* harmony import */ var _metamask_smart_accounts_kit__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @metamask/smart-accounts-kit */ \"(rsc)/../../node_modules/@metamask/smart-accounts-kit/dist/chunk-7MRTROLV.mjs\");\n/**\n * Session Package Utilities\n *\n * Handles loading and validation of session packages for agent delegation\n * NOTE: These functions should only be called server-side (Next.js API routes, server components)\n */\n\n\n\n\n\n\n\n/**\n * Build an in-memory SessionPackage JSON object from the parameters produced by\n * the session creation flow (AA, session AA, session key, delegation, etc.).\n *\n * This is the canonical shape used by auth/session and downstream helpers.\n */\nfunction buildSessionPackage(params) {\n    const { agentId, chainId, aa, sessionAA, selector, sessionKey, entryPoint, bundlerUrl, signedDelegation, delegationRedeemData, } = params;\n    return {\n        agentId,\n        chainId,\n        aa,\n        sessionAA,\n        selector,\n        sessionKey,\n        entryPoint,\n        bundlerUrl,\n        signedDelegation,\n        delegationRedeemData,\n    };\n}\n/**\n * Load session package from file\n * @param filePath - Optional path to session package file (defaults to sessionPackage.json.secret in same directory)\n */\nfunction loadSessionPackage(filePath) {\n    let p;\n    if (filePath) {\n        p = path__WEBPACK_IMPORTED_MODULE_1__.resolve(filePath);\n    }\n    else {\n        // Try environment variable first\n        const envPath = process.env.AGENTIC_TRUST_SESSION_PACKAGE_PATH;\n        if (envPath) {\n            p = path__WEBPACK_IMPORTED_MODULE_1__.resolve(envPath);\n        }\n        else {\n            // Try current working directory\n            p = path__WEBPACK_IMPORTED_MODULE_1__.join(process.cwd(), 'sessionPackage.json.secret');\n            // If not found, try relative to this file's directory\n            if (!fs__WEBPACK_IMPORTED_MODULE_0__.existsSync(p)) {\n                try {\n                    const __filename = (0,url__WEBPACK_IMPORTED_MODULE_2__.fileURLToPath)(\"file:///home/barb/aa/AssociatedAccounts/node_modules/@agentic-trust/core/dist/server/lib/sessionPackage.js\");\n                    const __dirname = path__WEBPACK_IMPORTED_MODULE_1__.dirname(__filename);\n                    p = path__WEBPACK_IMPORTED_MODULE_1__.join(__dirname, 'sessionPackage.json.secret');\n                }\n                catch {\n                    // Last resort: use cwd\n                    p = path__WEBPACK_IMPORTED_MODULE_1__.join(process.cwd(), 'sessionPackage.json.secret');\n                }\n            }\n        }\n    }\n    if (!fs__WEBPACK_IMPORTED_MODULE_0__.existsSync(p)) {\n        throw new Error(`Session package file not found: ${p}\\n` +\n            'Set AGENTIC_TRUST_SESSION_PACKAGE_PATH environment variable or provide filePath parameter.');\n    }\n    const raw = fs__WEBPACK_IMPORTED_MODULE_0__.readFileSync(p, 'utf-8');\n    const parsed = JSON.parse(raw);\n    return parsed;\n}\n/**\n * Validate session package structure\n * Note: bundlerUrl and reputationRegistry can come from environment variables\n */\nfunction validateSessionPackage(pkg) {\n    if (!pkg.chainId)\n        throw new Error('sessionPackage.chainId is required');\n    if (!pkg.aa)\n        throw new Error('sessionPackage.aa is required');\n    if (!pkg.entryPoint)\n        throw new Error('sessionPackage.entryPoint is required');\n    // Check if bundlerUrl is in package or env var\n    const envBundlerUrl = process.env.AGENTIC_TRUST_BUNDLER_URL;\n    if (!pkg.bundlerUrl && !envBundlerUrl) {\n        throw new Error('sessionPackage.bundlerUrl is required (or set AGENTIC_TRUST_BUNDLER_URL env var)');\n    }\n    if (!pkg.sessionKey?.privateKey || !pkg.sessionKey?.address) {\n        throw new Error('sessionPackage.sessionKey.privateKey and address are required');\n    }\n    if (!pkg.signedDelegation?.signature) {\n        throw new Error('sessionPackage.signedDelegation.signature is required');\n    }\n    // Validate delegation structure: either message (legacy) or flattened (new)\n    const hasFlattened = 'delegate' in pkg.signedDelegation && 'delegator' in pkg.signedDelegation;\n    if (!hasFlattened) {\n        throw new Error('sessionPackage.signedDelegation must have either message (legacy) or flattened delegation properties (delegate, delegator, etc.)');\n    }\n    // Check if reputationRegistry is in package or env var\n    const envReputationRegistry = (0,_chainConfig__WEBPACK_IMPORTED_MODULE_3__.getChainEnvVar)('AGENTIC_TRUST_REPUTATION_REGISTRY', pkg.chainId);\n    if (!envReputationRegistry) {\n        throw new Error('sessionPackage.reputationRegistry is required (or set AGENTIC_TRUST_REPUTATION_REGISTRY env var)');\n    }\n}\n/**\n * Get default RPC URL for a chain ID\n */\nfunction defaultRpcUrlFor(chainId) {\n    if (process.env.RPC_URL)\n        return process.env.RPC_URL;\n    if (process.env.JSON_RPC_URL)\n        return process.env.JSON_RPC_URL;\n    switch (chainId) {\n        case 11155111: return 'https://rpc.sepolia.org';\n        case 1: return 'https://rpc.ankr.com/eth';\n        default: return null;\n    }\n}\n/**\n * Build delegation setup from session package\n * Uses environment variables only (no overrides allowed)\n * Priority: env vars > session package defaults\n */\nfunction buildDelegationSetup(pkg) {\n    const session = pkg || loadSessionPackage();\n    validateSessionPackage(session);\n    // RPC URL: env var or default, then session package\n    const envRpcUrl = (0,_chainConfig__WEBPACK_IMPORTED_MODULE_3__.getChainEnvVar)('AGENTIC_TRUST_RPC_URL', session.chainId);\n    const rpcUrl = envRpcUrl || defaultRpcUrlFor(session.chainId);\n    if (!rpcUrl) {\n        throw new Error(`RPC URL not provided and no default known for chainId ${session.chainId}`);\n    }\n    // Bundler URL: env var, then session package\n    const envBundlerUrl = (0,_chainConfig__WEBPACK_IMPORTED_MODULE_3__.getChainEnvVar)('AGENTIC_TRUST_BUNDLER_URL', session.chainId);\n    const bundlerUrl = envBundlerUrl || session.bundlerUrl;\n    const chain = (0,viem__WEBPACK_IMPORTED_MODULE_4__.defineChain)({\n        id: session.chainId,\n        name: `chain-${session.chainId}`,\n        nativeCurrency: { name: 'Ether', symbol: 'ETH', decimals: 18 },\n        rpcUrls: { default: { http: [rpcUrl] }, public: { http: [rpcUrl] } },\n    });\n    // Create public client with timeout configuration\n    // Default timeout: 30 seconds (30000ms)\n    const publicClient = (0,viem__WEBPACK_IMPORTED_MODULE_5__.createPublicClient)({\n        chain,\n        transport: (0,viem__WEBPACK_IMPORTED_MODULE_6__.http)(rpcUrl, {\n            timeout: 30000, // 30 seconds\n            retryCount: 3,\n            retryDelay: 1000,\n        }),\n    });\n    return {\n        agentId: session.agentId,\n        chainId: session.chainId,\n        chain,\n        rpcUrl,\n        bundlerUrl,\n        entryPoint: session.entryPoint,\n        aa: session.aa,\n        sessionAA: session.sessionAA,\n        selector: session.selector,\n        sessionKey: session.sessionKey,\n        signedDelegation: session.signedDelegation,\n        delegationRedeemData: session.delegationRedeemData,\n        publicClient,\n    };\n}\nasync function buildAgentAccountFromSession(sessionPackage) {\n    if (!sessionPackage) {\n        throw new Error('sessionPackage is required to build agent account');\n    }\n    const delegationSetup = buildDelegationSetup(sessionPackage);\n    const publicClient = (0,viem__WEBPACK_IMPORTED_MODULE_5__.createPublicClient)({\n        chain: delegationSetup.chain,\n        transport: (0,viem__WEBPACK_IMPORTED_MODULE_6__.http)(delegationSetup.rpcUrl),\n    });\n    const agentOwnerEOA = (0,viem_accounts__WEBPACK_IMPORTED_MODULE_7__.privateKeyToAccount)(delegationSetup.sessionKey.privateKey);\n    // Create wallet client from the account\n    const walletClient = (0,viem__WEBPACK_IMPORTED_MODULE_8__.createWalletClient)({\n        account: agentOwnerEOA,\n        chain: delegationSetup.chain,\n        transport: (0,viem__WEBPACK_IMPORTED_MODULE_6__.http)(delegationSetup.rpcUrl),\n    });\n    // Use agent account (aa) as the address, not sessionAA, since we want to sign as the agent account\n    const agentAccountAddress = delegationSetup.aa;\n    const agentAccountClient = await (0,_metamask_smart_accounts_kit__WEBPACK_IMPORTED_MODULE_9__.toMetaMaskSmartAccount)({\n        address: agentAccountAddress,\n        client: publicClient,\n        implementation: _metamask_smart_accounts_kit__WEBPACK_IMPORTED_MODULE_10__.Implementation.Hybrid,\n        signer: { walletClient },\n    });\n    return agentAccountClient;\n}\n//# sourceMappingURL=sessionPackage.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BhZ2VudGljLXRydXN0L2NvcmUvZGlzdC9zZXJ2ZXIvbGliL3Nlc3Npb25QYWNrYWdlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDb0I7QUFDSTtBQUNZO0FBQzZDO0FBQzdCO0FBQ0w7QUFDdUM7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxZQUFZLHlIQUF5SDtBQUNySTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EsWUFBWSx5Q0FBWTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHlDQUFZO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixzQ0FBUztBQUN6QjtBQUNBLGlCQUFpQiwwQ0FBYTtBQUM5QjtBQUNBLHVDQUF1QyxrREFBYSxDQUFDLDRHQUFlO0FBQ3BFLHNDQUFzQyx5Q0FBWTtBQUNsRCx3QkFBd0Isc0NBQVM7QUFDakM7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHNDQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUywwQ0FBYTtBQUN0QiwyREFBMkQsRUFBRTtBQUM3RDtBQUNBO0FBQ0EsZ0JBQWdCLDRDQUFlO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLDREQUFjO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiw0REFBYztBQUNwQztBQUNBO0FBQ0EsaUZBQWlGLGdCQUFnQjtBQUNqRztBQUNBO0FBQ0EsMEJBQTBCLDREQUFjO0FBQ3hDO0FBQ0Esa0JBQWtCLGlEQUFXO0FBQzdCO0FBQ0EsdUJBQXVCLGdCQUFnQjtBQUN2QywwQkFBMEIsNENBQTRDO0FBQ3RFLG1CQUFtQixXQUFXLGdCQUFnQixZQUFZLGtCQUFrQjtBQUM1RSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHlCQUF5Qix3REFBa0I7QUFDM0M7QUFDQSxtQkFBbUIsMENBQUk7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsd0RBQWtCO0FBQzNDO0FBQ0EsbUJBQW1CLDBDQUFJO0FBQ3ZCLEtBQUs7QUFDTCwwQkFBMEIsa0VBQW1CO0FBQzdDO0FBQ0EseUJBQXlCLHdEQUFrQjtBQUMzQztBQUNBO0FBQ0EsbUJBQW1CLDBDQUFJO0FBQ3ZCLEtBQUs7QUFDTDtBQUNBO0FBQ0EscUNBQXFDLG9GQUFzQjtBQUMzRDtBQUNBO0FBQ0Esd0JBQXdCLHlFQUFjO0FBQ3RDLGtCQUFrQixjQUFjO0FBQ2hDLEtBQUs7QUFDTDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL2JhcmIvYWEvQXNzb2NpYXRlZEFjY291bnRzL25vZGVfbW9kdWxlcy9AYWdlbnRpYy10cnVzdC9jb3JlL2Rpc3Qvc2VydmVyL2xpYi9zZXNzaW9uUGFja2FnZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFNlc3Npb24gUGFja2FnZSBVdGlsaXRpZXNcbiAqXG4gKiBIYW5kbGVzIGxvYWRpbmcgYW5kIHZhbGlkYXRpb24gb2Ygc2Vzc2lvbiBwYWNrYWdlcyBmb3IgYWdlbnQgZGVsZWdhdGlvblxuICogTk9URTogVGhlc2UgZnVuY3Rpb25zIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBzZXJ2ZXItc2lkZSAoTmV4dC5qcyBBUEkgcm91dGVzLCBzZXJ2ZXIgY29tcG9uZW50cylcbiAqL1xuaW1wb3J0IGZzIGZyb20gJ2ZzJztcbmltcG9ydCBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0IHsgZmlsZVVSTFRvUGF0aCB9IGZyb20gJ3VybCc7XG5pbXBvcnQgeyBkZWZpbmVDaGFpbiwgaHR0cCwgY3JlYXRlUHVibGljQ2xpZW50LCBjcmVhdGVXYWxsZXRDbGllbnQgfSBmcm9tICd2aWVtJztcbmltcG9ydCB7IHByaXZhdGVLZXlUb0FjY291bnQgfSBmcm9tICd2aWVtL2FjY291bnRzJztcbmltcG9ydCB7IGdldENoYWluRW52VmFyIH0gZnJvbSAnLi9jaGFpbkNvbmZpZyc7XG5pbXBvcnQgeyBJbXBsZW1lbnRhdGlvbiwgdG9NZXRhTWFza1NtYXJ0QWNjb3VudCB9IGZyb20gJ0BtZXRhbWFzay9zbWFydC1hY2NvdW50cy1raXQnO1xuLyoqXG4gKiBCdWlsZCBhbiBpbi1tZW1vcnkgU2Vzc2lvblBhY2thZ2UgSlNPTiBvYmplY3QgZnJvbSB0aGUgcGFyYW1ldGVycyBwcm9kdWNlZCBieVxuICogdGhlIHNlc3Npb24gY3JlYXRpb24gZmxvdyAoQUEsIHNlc3Npb24gQUEsIHNlc3Npb24ga2V5LCBkZWxlZ2F0aW9uLCBldGMuKS5cbiAqXG4gKiBUaGlzIGlzIHRoZSBjYW5vbmljYWwgc2hhcGUgdXNlZCBieSBhdXRoL3Nlc3Npb24gYW5kIGRvd25zdHJlYW0gaGVscGVycy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkU2Vzc2lvblBhY2thZ2UocGFyYW1zKSB7XG4gICAgY29uc3QgeyBhZ2VudElkLCBjaGFpbklkLCBhYSwgc2Vzc2lvbkFBLCBzZWxlY3Rvciwgc2Vzc2lvbktleSwgZW50cnlQb2ludCwgYnVuZGxlclVybCwgc2lnbmVkRGVsZWdhdGlvbiwgZGVsZWdhdGlvblJlZGVlbURhdGEsIH0gPSBwYXJhbXM7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYWdlbnRJZCxcbiAgICAgICAgY2hhaW5JZCxcbiAgICAgICAgYWEsXG4gICAgICAgIHNlc3Npb25BQSxcbiAgICAgICAgc2VsZWN0b3IsXG4gICAgICAgIHNlc3Npb25LZXksXG4gICAgICAgIGVudHJ5UG9pbnQsXG4gICAgICAgIGJ1bmRsZXJVcmwsXG4gICAgICAgIHNpZ25lZERlbGVnYXRpb24sXG4gICAgICAgIGRlbGVnYXRpb25SZWRlZW1EYXRhLFxuICAgIH07XG59XG4vKipcbiAqIExvYWQgc2Vzc2lvbiBwYWNrYWdlIGZyb20gZmlsZVxuICogQHBhcmFtIGZpbGVQYXRoIC0gT3B0aW9uYWwgcGF0aCB0byBzZXNzaW9uIHBhY2thZ2UgZmlsZSAoZGVmYXVsdHMgdG8gc2Vzc2lvblBhY2thZ2UuanNvbi5zZWNyZXQgaW4gc2FtZSBkaXJlY3RvcnkpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsb2FkU2Vzc2lvblBhY2thZ2UoZmlsZVBhdGgpIHtcbiAgICBsZXQgcDtcbiAgICBpZiAoZmlsZVBhdGgpIHtcbiAgICAgICAgcCA9IHBhdGgucmVzb2x2ZShmaWxlUGF0aCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBUcnkgZW52aXJvbm1lbnQgdmFyaWFibGUgZmlyc3RcbiAgICAgICAgY29uc3QgZW52UGF0aCA9IHByb2Nlc3MuZW52LkFHRU5USUNfVFJVU1RfU0VTU0lPTl9QQUNLQUdFX1BBVEg7XG4gICAgICAgIGlmIChlbnZQYXRoKSB7XG4gICAgICAgICAgICBwID0gcGF0aC5yZXNvbHZlKGVudlBhdGgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gVHJ5IGN1cnJlbnQgd29ya2luZyBkaXJlY3RvcnlcbiAgICAgICAgICAgIHAgPSBwYXRoLmpvaW4ocHJvY2Vzcy5jd2QoKSwgJ3Nlc3Npb25QYWNrYWdlLmpzb24uc2VjcmV0Jyk7XG4gICAgICAgICAgICAvLyBJZiBub3QgZm91bmQsIHRyeSByZWxhdGl2ZSB0byB0aGlzIGZpbGUncyBkaXJlY3RvcnlcbiAgICAgICAgICAgIGlmICghZnMuZXhpc3RzU3luYyhwKSkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IF9fZmlsZW5hbWUgPSBmaWxlVVJMVG9QYXRoKGltcG9ydC5tZXRhLnVybCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IF9fZGlybmFtZSA9IHBhdGguZGlybmFtZShfX2ZpbGVuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgcCA9IHBhdGguam9pbihfX2Rpcm5hbWUsICdzZXNzaW9uUGFja2FnZS5qc29uLnNlY3JldCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCB7XG4gICAgICAgICAgICAgICAgICAgIC8vIExhc3QgcmVzb3J0OiB1c2UgY3dkXG4gICAgICAgICAgICAgICAgICAgIHAgPSBwYXRoLmpvaW4ocHJvY2Vzcy5jd2QoKSwgJ3Nlc3Npb25QYWNrYWdlLmpzb24uc2VjcmV0Jyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghZnMuZXhpc3RzU3luYyhwKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFNlc3Npb24gcGFja2FnZSBmaWxlIG5vdCBmb3VuZDogJHtwfVxcbmAgK1xuICAgICAgICAgICAgJ1NldCBBR0VOVElDX1RSVVNUX1NFU1NJT05fUEFDS0FHRV9QQVRIIGVudmlyb25tZW50IHZhcmlhYmxlIG9yIHByb3ZpZGUgZmlsZVBhdGggcGFyYW1ldGVyLicpO1xuICAgIH1cbiAgICBjb25zdCByYXcgPSBmcy5yZWFkRmlsZVN5bmMocCwgJ3V0Zi04Jyk7XG4gICAgY29uc3QgcGFyc2VkID0gSlNPTi5wYXJzZShyYXcpO1xuICAgIHJldHVybiBwYXJzZWQ7XG59XG4vKipcbiAqIFZhbGlkYXRlIHNlc3Npb24gcGFja2FnZSBzdHJ1Y3R1cmVcbiAqIE5vdGU6IGJ1bmRsZXJVcmwgYW5kIHJlcHV0YXRpb25SZWdpc3RyeSBjYW4gY29tZSBmcm9tIGVudmlyb25tZW50IHZhcmlhYmxlc1xuICovXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVTZXNzaW9uUGFja2FnZShwa2cpIHtcbiAgICBpZiAoIXBrZy5jaGFpbklkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Nlc3Npb25QYWNrYWdlLmNoYWluSWQgaXMgcmVxdWlyZWQnKTtcbiAgICBpZiAoIXBrZy5hYSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzZXNzaW9uUGFja2FnZS5hYSBpcyByZXF1aXJlZCcpO1xuICAgIGlmICghcGtnLmVudHJ5UG9pbnQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignc2Vzc2lvblBhY2thZ2UuZW50cnlQb2ludCBpcyByZXF1aXJlZCcpO1xuICAgIC8vIENoZWNrIGlmIGJ1bmRsZXJVcmwgaXMgaW4gcGFja2FnZSBvciBlbnYgdmFyXG4gICAgY29uc3QgZW52QnVuZGxlclVybCA9IHByb2Nlc3MuZW52LkFHRU5USUNfVFJVU1RfQlVORExFUl9VUkw7XG4gICAgaWYgKCFwa2cuYnVuZGxlclVybCAmJiAhZW52QnVuZGxlclVybCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Nlc3Npb25QYWNrYWdlLmJ1bmRsZXJVcmwgaXMgcmVxdWlyZWQgKG9yIHNldCBBR0VOVElDX1RSVVNUX0JVTkRMRVJfVVJMIGVudiB2YXIpJyk7XG4gICAgfVxuICAgIGlmICghcGtnLnNlc3Npb25LZXk/LnByaXZhdGVLZXkgfHwgIXBrZy5zZXNzaW9uS2V5Py5hZGRyZXNzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignc2Vzc2lvblBhY2thZ2Uuc2Vzc2lvbktleS5wcml2YXRlS2V5IGFuZCBhZGRyZXNzIGFyZSByZXF1aXJlZCcpO1xuICAgIH1cbiAgICBpZiAoIXBrZy5zaWduZWREZWxlZ2F0aW9uPy5zaWduYXR1cmUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzZXNzaW9uUGFja2FnZS5zaWduZWREZWxlZ2F0aW9uLnNpZ25hdHVyZSBpcyByZXF1aXJlZCcpO1xuICAgIH1cbiAgICAvLyBWYWxpZGF0ZSBkZWxlZ2F0aW9uIHN0cnVjdHVyZTogZWl0aGVyIG1lc3NhZ2UgKGxlZ2FjeSkgb3IgZmxhdHRlbmVkIChuZXcpXG4gICAgY29uc3QgaGFzRmxhdHRlbmVkID0gJ2RlbGVnYXRlJyBpbiBwa2cuc2lnbmVkRGVsZWdhdGlvbiAmJiAnZGVsZWdhdG9yJyBpbiBwa2cuc2lnbmVkRGVsZWdhdGlvbjtcbiAgICBpZiAoIWhhc0ZsYXR0ZW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Nlc3Npb25QYWNrYWdlLnNpZ25lZERlbGVnYXRpb24gbXVzdCBoYXZlIGVpdGhlciBtZXNzYWdlIChsZWdhY3kpIG9yIGZsYXR0ZW5lZCBkZWxlZ2F0aW9uIHByb3BlcnRpZXMgKGRlbGVnYXRlLCBkZWxlZ2F0b3IsIGV0Yy4pJyk7XG4gICAgfVxuICAgIC8vIENoZWNrIGlmIHJlcHV0YXRpb25SZWdpc3RyeSBpcyBpbiBwYWNrYWdlIG9yIGVudiB2YXJcbiAgICBjb25zdCBlbnZSZXB1dGF0aW9uUmVnaXN0cnkgPSBnZXRDaGFpbkVudlZhcignQUdFTlRJQ19UUlVTVF9SRVBVVEFUSU9OX1JFR0lTVFJZJywgcGtnLmNoYWluSWQpO1xuICAgIGlmICghZW52UmVwdXRhdGlvblJlZ2lzdHJ5KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignc2Vzc2lvblBhY2thZ2UucmVwdXRhdGlvblJlZ2lzdHJ5IGlzIHJlcXVpcmVkIChvciBzZXQgQUdFTlRJQ19UUlVTVF9SRVBVVEFUSU9OX1JFR0lTVFJZIGVudiB2YXIpJyk7XG4gICAgfVxufVxuLyoqXG4gKiBHZXQgZGVmYXVsdCBSUEMgVVJMIGZvciBhIGNoYWluIElEXG4gKi9cbmZ1bmN0aW9uIGRlZmF1bHRScGNVcmxGb3IoY2hhaW5JZCkge1xuICAgIGlmIChwcm9jZXNzLmVudi5SUENfVVJMKVxuICAgICAgICByZXR1cm4gcHJvY2Vzcy5lbnYuUlBDX1VSTDtcbiAgICBpZiAocHJvY2Vzcy5lbnYuSlNPTl9SUENfVVJMKVxuICAgICAgICByZXR1cm4gcHJvY2Vzcy5lbnYuSlNPTl9SUENfVVJMO1xuICAgIHN3aXRjaCAoY2hhaW5JZCkge1xuICAgICAgICBjYXNlIDExMTU1MTExOiByZXR1cm4gJ2h0dHBzOi8vcnBjLnNlcG9saWEub3JnJztcbiAgICAgICAgY2FzZSAxOiByZXR1cm4gJ2h0dHBzOi8vcnBjLmFua3IuY29tL2V0aCc7XG4gICAgICAgIGRlZmF1bHQ6IHJldHVybiBudWxsO1xuICAgIH1cbn1cbi8qKlxuICogQnVpbGQgZGVsZWdhdGlvbiBzZXR1cCBmcm9tIHNlc3Npb24gcGFja2FnZVxuICogVXNlcyBlbnZpcm9ubWVudCB2YXJpYWJsZXMgb25seSAobm8gb3ZlcnJpZGVzIGFsbG93ZWQpXG4gKiBQcmlvcml0eTogZW52IHZhcnMgPiBzZXNzaW9uIHBhY2thZ2UgZGVmYXVsdHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkRGVsZWdhdGlvblNldHVwKHBrZykge1xuICAgIGNvbnN0IHNlc3Npb24gPSBwa2cgfHwgbG9hZFNlc3Npb25QYWNrYWdlKCk7XG4gICAgdmFsaWRhdGVTZXNzaW9uUGFja2FnZShzZXNzaW9uKTtcbiAgICAvLyBSUEMgVVJMOiBlbnYgdmFyIG9yIGRlZmF1bHQsIHRoZW4gc2Vzc2lvbiBwYWNrYWdlXG4gICAgY29uc3QgZW52UnBjVXJsID0gZ2V0Q2hhaW5FbnZWYXIoJ0FHRU5USUNfVFJVU1RfUlBDX1VSTCcsIHNlc3Npb24uY2hhaW5JZCk7XG4gICAgY29uc3QgcnBjVXJsID0gZW52UnBjVXJsIHx8IGRlZmF1bHRScGNVcmxGb3Ioc2Vzc2lvbi5jaGFpbklkKTtcbiAgICBpZiAoIXJwY1VybCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFJQQyBVUkwgbm90IHByb3ZpZGVkIGFuZCBubyBkZWZhdWx0IGtub3duIGZvciBjaGFpbklkICR7c2Vzc2lvbi5jaGFpbklkfWApO1xuICAgIH1cbiAgICAvLyBCdW5kbGVyIFVSTDogZW52IHZhciwgdGhlbiBzZXNzaW9uIHBhY2thZ2VcbiAgICBjb25zdCBlbnZCdW5kbGVyVXJsID0gZ2V0Q2hhaW5FbnZWYXIoJ0FHRU5USUNfVFJVU1RfQlVORExFUl9VUkwnLCBzZXNzaW9uLmNoYWluSWQpO1xuICAgIGNvbnN0IGJ1bmRsZXJVcmwgPSBlbnZCdW5kbGVyVXJsIHx8IHNlc3Npb24uYnVuZGxlclVybDtcbiAgICBjb25zdCBjaGFpbiA9IGRlZmluZUNoYWluKHtcbiAgICAgICAgaWQ6IHNlc3Npb24uY2hhaW5JZCxcbiAgICAgICAgbmFtZTogYGNoYWluLSR7c2Vzc2lvbi5jaGFpbklkfWAsXG4gICAgICAgIG5hdGl2ZUN1cnJlbmN5OiB7IG5hbWU6ICdFdGhlcicsIHN5bWJvbDogJ0VUSCcsIGRlY2ltYWxzOiAxOCB9LFxuICAgICAgICBycGNVcmxzOiB7IGRlZmF1bHQ6IHsgaHR0cDogW3JwY1VybF0gfSwgcHVibGljOiB7IGh0dHA6IFtycGNVcmxdIH0gfSxcbiAgICB9KTtcbiAgICAvLyBDcmVhdGUgcHVibGljIGNsaWVudCB3aXRoIHRpbWVvdXQgY29uZmlndXJhdGlvblxuICAgIC8vIERlZmF1bHQgdGltZW91dDogMzAgc2Vjb25kcyAoMzAwMDBtcylcbiAgICBjb25zdCBwdWJsaWNDbGllbnQgPSBjcmVhdGVQdWJsaWNDbGllbnQoe1xuICAgICAgICBjaGFpbixcbiAgICAgICAgdHJhbnNwb3J0OiBodHRwKHJwY1VybCwge1xuICAgICAgICAgICAgdGltZW91dDogMzAwMDAsIC8vIDMwIHNlY29uZHNcbiAgICAgICAgICAgIHJldHJ5Q291bnQ6IDMsXG4gICAgICAgICAgICByZXRyeURlbGF5OiAxMDAwLFxuICAgICAgICB9KSxcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgICBhZ2VudElkOiBzZXNzaW9uLmFnZW50SWQsXG4gICAgICAgIGNoYWluSWQ6IHNlc3Npb24uY2hhaW5JZCxcbiAgICAgICAgY2hhaW4sXG4gICAgICAgIHJwY1VybCxcbiAgICAgICAgYnVuZGxlclVybCxcbiAgICAgICAgZW50cnlQb2ludDogc2Vzc2lvbi5lbnRyeVBvaW50LFxuICAgICAgICBhYTogc2Vzc2lvbi5hYSxcbiAgICAgICAgc2Vzc2lvbkFBOiBzZXNzaW9uLnNlc3Npb25BQSxcbiAgICAgICAgc2VsZWN0b3I6IHNlc3Npb24uc2VsZWN0b3IsXG4gICAgICAgIHNlc3Npb25LZXk6IHNlc3Npb24uc2Vzc2lvbktleSxcbiAgICAgICAgc2lnbmVkRGVsZWdhdGlvbjogc2Vzc2lvbi5zaWduZWREZWxlZ2F0aW9uLFxuICAgICAgICBkZWxlZ2F0aW9uUmVkZWVtRGF0YTogc2Vzc2lvbi5kZWxlZ2F0aW9uUmVkZWVtRGF0YSxcbiAgICAgICAgcHVibGljQ2xpZW50LFxuICAgIH07XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gYnVpbGRBZ2VudEFjY291bnRGcm9tU2Vzc2lvbihzZXNzaW9uUGFja2FnZSkge1xuICAgIGlmICghc2Vzc2lvblBhY2thZ2UpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzZXNzaW9uUGFja2FnZSBpcyByZXF1aXJlZCB0byBidWlsZCBhZ2VudCBhY2NvdW50Jyk7XG4gICAgfVxuICAgIGNvbnN0IGRlbGVnYXRpb25TZXR1cCA9IGJ1aWxkRGVsZWdhdGlvblNldHVwKHNlc3Npb25QYWNrYWdlKTtcbiAgICBjb25zdCBwdWJsaWNDbGllbnQgPSBjcmVhdGVQdWJsaWNDbGllbnQoe1xuICAgICAgICBjaGFpbjogZGVsZWdhdGlvblNldHVwLmNoYWluLFxuICAgICAgICB0cmFuc3BvcnQ6IGh0dHAoZGVsZWdhdGlvblNldHVwLnJwY1VybCksXG4gICAgfSk7XG4gICAgY29uc3QgYWdlbnRPd25lckVPQSA9IHByaXZhdGVLZXlUb0FjY291bnQoZGVsZWdhdGlvblNldHVwLnNlc3Npb25LZXkucHJpdmF0ZUtleSk7XG4gICAgLy8gQ3JlYXRlIHdhbGxldCBjbGllbnQgZnJvbSB0aGUgYWNjb3VudFxuICAgIGNvbnN0IHdhbGxldENsaWVudCA9IGNyZWF0ZVdhbGxldENsaWVudCh7XG4gICAgICAgIGFjY291bnQ6IGFnZW50T3duZXJFT0EsXG4gICAgICAgIGNoYWluOiBkZWxlZ2F0aW9uU2V0dXAuY2hhaW4sXG4gICAgICAgIHRyYW5zcG9ydDogaHR0cChkZWxlZ2F0aW9uU2V0dXAucnBjVXJsKSxcbiAgICB9KTtcbiAgICAvLyBVc2UgYWdlbnQgYWNjb3VudCAoYWEpIGFzIHRoZSBhZGRyZXNzLCBub3Qgc2Vzc2lvbkFBLCBzaW5jZSB3ZSB3YW50IHRvIHNpZ24gYXMgdGhlIGFnZW50IGFjY291bnRcbiAgICBjb25zdCBhZ2VudEFjY291bnRBZGRyZXNzID0gZGVsZWdhdGlvblNldHVwLmFhO1xuICAgIGNvbnN0IGFnZW50QWNjb3VudENsaWVudCA9IGF3YWl0IHRvTWV0YU1hc2tTbWFydEFjY291bnQoe1xuICAgICAgICBhZGRyZXNzOiBhZ2VudEFjY291bnRBZGRyZXNzLFxuICAgICAgICBjbGllbnQ6IHB1YmxpY0NsaWVudCxcbiAgICAgICAgaW1wbGVtZW50YXRpb246IEltcGxlbWVudGF0aW9uLkh5YnJpZCxcbiAgICAgICAgc2lnbmVyOiB7IHdhbGxldENsaWVudCB9LFxuICAgIH0pO1xuICAgIHJldHVybiBhZ2VudEFjY291bnRDbGllbnQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZXNzaW9uUGFja2FnZS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@agentic-trust/core/dist/server/lib/sessionPackage.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@agentic-trust/core/dist/server/lib/uaid.js":
/*!**********************************************************************!*\
  !*** ../../node_modules/@agentic-trust/core/dist/server/lib/uaid.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   generateHcs14UaidDidTarget: () => (/* binding */ generateHcs14UaidDidTarget)\n/* harmony export */ });\nfunction encodeParamValue(value) {\n    // UAID params are delimited with ';' and '='. We only encode the characters that\n    // would break parsing, while keeping CAIP-10 / DID strings human-readable.\n    return value\n        .replace(/%/g, '%25')\n        .replace(/;/g, '%3B')\n        .replace(/=/g, '%3D');\n}\nfunction didMethodSpecificId(did) {\n    const decoded = decodeURIComponent((did || '').trim());\n    if (!decoded) {\n        throw new Error('Missing DID');\n    }\n    const parts = decoded.split(':');\n    // did:<method>:<method-specific-id...>\n    if (parts.length < 3 || parts[0] !== 'did') {\n        throw new Error(`Invalid DID: ${decoded}`);\n    }\n    return parts.slice(2).join(':');\n}\n/**\n * Generate an HCS-14 UAID in DID-target form:\n *   uaid:did:<did:ethr...>;uid=...;registry=...;proto=...;nativeId=...;domain=...\n *\n * This allows construction *before* ERC-8004 identity registration, since the\n * agent account DID (did:ethr) exists prior to minting the identity NFT.\n */\nasync function generateHcs14UaidDidTarget(params) {\n    const targetDid = String(params.targetDid ?? '').trim();\n    const methodSpecificId = didMethodSpecificId(targetDid);\n    const routing = params.routing || {};\n    const parts = [];\n    for (const [key, value] of Object.entries(routing)) {\n        if (value === undefined || value === null)\n            continue;\n        const trimmed = String(value).trim();\n        if (!trimmed)\n            continue;\n        parts.push(`${key}=${encodeParamValue(trimmed)}`);\n    }\n    const suffix = parts.length > 0 ? `;${parts.join(';')}` : '';\n    return {\n        // For uaid:did, {id} is the DID method-specific identifier (no \"did:<method>:\" prefix).\n        uaid: `uaid:did:${methodSpecificId}${suffix}`,\n    };\n}\n//# sourceMappingURL=uaid.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BhZ2VudGljLXRydXN0L2NvcmUvZGlzdC9zZXJ2ZXIvbGliL3VhaWQuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxRQUFRO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsUUFBUSxhQUFhLFVBQVUsYUFBYTtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsSUFBSSxHQUFHLDBCQUEwQjtBQUN2RDtBQUNBLHdDQUF3QyxFQUFFLGFBQWEsR0FBRztBQUMxRDtBQUNBLDBCQUEwQixJQUFJO0FBQzlCLDBCQUEwQixpQkFBaUIsRUFBRSxPQUFPO0FBQ3BEO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvYmFyYi9hYS9Bc3NvY2lhdGVkQWNjb3VudHMvbm9kZV9tb2R1bGVzL0BhZ2VudGljLXRydXN0L2NvcmUvZGlzdC9zZXJ2ZXIvbGliL3VhaWQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gZW5jb2RlUGFyYW1WYWx1ZSh2YWx1ZSkge1xuICAgIC8vIFVBSUQgcGFyYW1zIGFyZSBkZWxpbWl0ZWQgd2l0aCAnOycgYW5kICc9Jy4gV2Ugb25seSBlbmNvZGUgdGhlIGNoYXJhY3RlcnMgdGhhdFxuICAgIC8vIHdvdWxkIGJyZWFrIHBhcnNpbmcsIHdoaWxlIGtlZXBpbmcgQ0FJUC0xMCAvIERJRCBzdHJpbmdzIGh1bWFuLXJlYWRhYmxlLlxuICAgIHJldHVybiB2YWx1ZVxuICAgICAgICAucmVwbGFjZSgvJS9nLCAnJTI1JylcbiAgICAgICAgLnJlcGxhY2UoLzsvZywgJyUzQicpXG4gICAgICAgIC5yZXBsYWNlKC89L2csICclM0QnKTtcbn1cbmZ1bmN0aW9uIGRpZE1ldGhvZFNwZWNpZmljSWQoZGlkKSB7XG4gICAgY29uc3QgZGVjb2RlZCA9IGRlY29kZVVSSUNvbXBvbmVudCgoZGlkIHx8ICcnKS50cmltKCkpO1xuICAgIGlmICghZGVjb2RlZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgRElEJyk7XG4gICAgfVxuICAgIGNvbnN0IHBhcnRzID0gZGVjb2RlZC5zcGxpdCgnOicpO1xuICAgIC8vIGRpZDo8bWV0aG9kPjo8bWV0aG9kLXNwZWNpZmljLWlkLi4uPlxuICAgIGlmIChwYXJ0cy5sZW5ndGggPCAzIHx8IHBhcnRzWzBdICE9PSAnZGlkJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgRElEOiAke2RlY29kZWR9YCk7XG4gICAgfVxuICAgIHJldHVybiBwYXJ0cy5zbGljZSgyKS5qb2luKCc6Jyk7XG59XG4vKipcbiAqIEdlbmVyYXRlIGFuIEhDUy0xNCBVQUlEIGluIERJRC10YXJnZXQgZm9ybTpcbiAqICAgdWFpZDpkaWQ6PGRpZDpldGhyLi4uPjt1aWQ9Li4uO3JlZ2lzdHJ5PS4uLjtwcm90bz0uLi47bmF0aXZlSWQ9Li4uO2RvbWFpbj0uLi5cbiAqXG4gKiBUaGlzIGFsbG93cyBjb25zdHJ1Y3Rpb24gKmJlZm9yZSogRVJDLTgwMDQgaWRlbnRpdHkgcmVnaXN0cmF0aW9uLCBzaW5jZSB0aGVcbiAqIGFnZW50IGFjY291bnQgRElEIChkaWQ6ZXRocikgZXhpc3RzIHByaW9yIHRvIG1pbnRpbmcgdGhlIGlkZW50aXR5IE5GVC5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdlbmVyYXRlSGNzMTRVYWlkRGlkVGFyZ2V0KHBhcmFtcykge1xuICAgIGNvbnN0IHRhcmdldERpZCA9IFN0cmluZyhwYXJhbXMudGFyZ2V0RGlkID8/ICcnKS50cmltKCk7XG4gICAgY29uc3QgbWV0aG9kU3BlY2lmaWNJZCA9IGRpZE1ldGhvZFNwZWNpZmljSWQodGFyZ2V0RGlkKTtcbiAgICBjb25zdCByb3V0aW5nID0gcGFyYW1zLnJvdXRpbmcgfHwge307XG4gICAgY29uc3QgcGFydHMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhyb3V0aW5nKSkge1xuICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWx1ZSA9PT0gbnVsbClcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBjb25zdCB0cmltbWVkID0gU3RyaW5nKHZhbHVlKS50cmltKCk7XG4gICAgICAgIGlmICghdHJpbW1lZClcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBwYXJ0cy5wdXNoKGAke2tleX09JHtlbmNvZGVQYXJhbVZhbHVlKHRyaW1tZWQpfWApO1xuICAgIH1cbiAgICBjb25zdCBzdWZmaXggPSBwYXJ0cy5sZW5ndGggPiAwID8gYDske3BhcnRzLmpvaW4oJzsnKX1gIDogJyc7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLy8gRm9yIHVhaWQ6ZGlkLCB7aWR9IGlzIHRoZSBESUQgbWV0aG9kLXNwZWNpZmljIGlkZW50aWZpZXIgKG5vIFwiZGlkOjxtZXRob2Q+OlwiIHByZWZpeCkuXG4gICAgICAgIHVhaWQ6IGB1YWlkOmRpZDoke21ldGhvZFNwZWNpZmljSWR9JHtzdWZmaXh9YCxcbiAgICB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dWFpZC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@agentic-trust/core/dist/server/lib/uaid.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@agentic-trust/core/dist/server/lib/validations.js":
/*!*****************************************************************************!*\
  !*** ../../node_modules/@agentic-trust/core/dist/server/lib/validations.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createValidatorAccountAbstraction: () => (/* binding */ createValidatorAccountAbstraction),\n/* harmony export */   getAgentValidationsSummary: () => (/* binding */ getAgentValidationsSummary),\n/* harmony export */   getValidatorAddressValidations: () => (/* binding */ getValidatorAddressValidations)\n/* harmony export */ });\n/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../index */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/index.js\");\n/* harmony import */ var _singletons_validationClient__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../singletons/validationClient */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/singletons/validationClient.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! viem */ \"(rsc)/../../node_modules/viem/_esm/clients/createPublicClient.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! viem */ \"(rsc)/../../node_modules/viem/_esm/clients/transports/http.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! viem */ \"(rsc)/../../node_modules/viem/_esm/clients/createWalletClient.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! viem */ \"(rsc)/../../node_modules/viem/_esm/utils/hash/keccak256.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! viem */ \"(rsc)/../../node_modules/viem/_esm/utils/encoding/toHex.js\");\n/* harmony import */ var _metamask_smart_accounts_kit__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @metamask/smart-accounts-kit */ \"(rsc)/../../node_modules/@metamask/smart-accounts-kit/dist/chunk-7MRTROLV.mjs\");\n/* harmony import */ var _metamask_smart_accounts_kit__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @metamask/smart-accounts-kit */ \"(rsc)/../../node_modules/@metamask/smart-accounts-kit/dist/index.mjs\");\n/* harmony import */ var viem_accounts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! viem/accounts */ \"(rsc)/../../node_modules/viem/_esm/accounts/privateKeyToAccount.js\");\n/* harmony import */ var _chainConfig__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./chainConfig */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/lib/chainConfig.js\");\n\n\n\n\n\n\nasync function getAgentValidationsSummary(chainId, agentId) {\n    const client = await (0,_singletons_validationClient__WEBPACK_IMPORTED_MODULE_1__.getValidationRegistryClient)(chainId);\n    const numericAgentId = typeof agentId === 'string' ? Number.parseInt(agentId, 10) : Number(agentId);\n    if (!Number.isFinite(numericAgentId) || numericAgentId <= 0) {\n        throw new Error('Invalid agentId');\n    }\n    const agentIdBigInt = BigInt(numericAgentId);\n    const requestHashes = await client.getAgentValidations(agentIdBigInt);\n    console.log(`[getAgentValidationsSummary] Found ${requestHashes.length} validation request hash(es) for agent ${numericAgentId} on chain ${chainId}`);\n    const pending = [];\n    const completed = [];\n    for (const hash of requestHashes) {\n        try {\n            const status = await client.getValidationStatus(hash);\n            console.log(`[getAgentValidationsSummary] Validation ${hash}: response=${status.response}, validator=${status.validatorAddress}`);\n            const entry = {\n                requestHash: hash,\n                ...status,\n            };\n            if (status.response === 0) {\n                pending.push(entry);\n            }\n            else {\n                completed.push(entry);\n            }\n        }\n        catch (error) {\n            console.warn(`[getAgentValidationsSummary] Failed to get status for hash ${hash}:`, error);\n            // Ignore invalid entries but continue\n        }\n    }\n    const did8004 = (0,_index__WEBPACK_IMPORTED_MODULE_0__.buildDid8004)(chainId, numericAgentId);\n    console.log(`[getAgentValidationsSummary] Summary for agent ${numericAgentId}: pending=${pending.length}, completed=${completed.length}`);\n    return {\n        agentId: String(numericAgentId),\n        chainId,\n        did8004,\n        pending,\n        completed,\n    };\n}\n/**\n * Create a validator account abstraction using the name 'name-validator' as the seed from a private key.\n * The validator address is determined server-side based on AGENTIC_TRUST_VALIDATOR_PRIVATE_KEY.\n */\nasync function createValidatorAccountAbstraction(validatorName, validatorPrivateKey, chainId) {\n    const targetChainId = chainId || _chainConfig__WEBPACK_IMPORTED_MODULE_2__.DEFAULT_CHAIN_ID;\n    const chain = (0,_chainConfig__WEBPACK_IMPORTED_MODULE_2__.getChainById)(targetChainId);\n    const rpcUrl = (0,_chainConfig__WEBPACK_IMPORTED_MODULE_2__.requireChainEnvVar)('AGENTIC_TRUST_RPC_URL', targetChainId);\n    // Normalize private key\n    const normalizedKey = validatorPrivateKey.startsWith('0x')\n        ? validatorPrivateKey\n        : `0x${validatorPrivateKey}`;\n    // Create account from private key\n    const account = (0,viem_accounts__WEBPACK_IMPORTED_MODULE_3__.privateKeyToAccount)(normalizedKey);\n    const eoaAddress = account.address;\n    // Create public and wallet clients\n    const publicClient = (0,viem__WEBPACK_IMPORTED_MODULE_4__.createPublicClient)({\n        chain: chain,\n        transport: (0,viem__WEBPACK_IMPORTED_MODULE_5__.http)(rpcUrl),\n    });\n    const walletClient = (0,viem__WEBPACK_IMPORTED_MODULE_6__.createWalletClient)({\n        account,\n        chain: chain,\n        transport: (0,viem__WEBPACK_IMPORTED_MODULE_5__.http)(rpcUrl),\n    });\n    // Create salt from validator name 'name-validator'\n    const salt = (0,viem__WEBPACK_IMPORTED_MODULE_7__.keccak256)((0,viem__WEBPACK_IMPORTED_MODULE_8__.stringToHex)(validatorName));\n    // Create account abstraction with validator name as seed\n    const clientConfig = {\n        client: publicClient,\n        implementation: _metamask_smart_accounts_kit__WEBPACK_IMPORTED_MODULE_9__.Implementation.Hybrid,\n        signer: {\n            walletClient,\n        },\n        deployParams: [eoaAddress, [], [], []],\n        deploySalt: salt,\n    };\n    const accountClient = await (0,_metamask_smart_accounts_kit__WEBPACK_IMPORTED_MODULE_10__.toMetaMaskSmartAccount)(clientConfig);\n    const validatorAddress = accountClient.address;\n    return { accountClient, address: validatorAddress };\n}\n/**\n * Get validation requests for a validator address\n */\nasync function getValidatorAddressValidations(chainId, validatorAddress) {\n    const client = await (0,_singletons_validationClient__WEBPACK_IMPORTED_MODULE_1__.getValidationRegistryClient)(chainId);\n    const requestHashes = await client.getValidatorRequests(validatorAddress);\n    console.log(`[getValidatorAddressValidations] Found ${requestHashes.length} validation request hash(es) for validator ${validatorAddress} on chain ${chainId}`);\n    const results = [];\n    for (const hash of requestHashes) {\n        try {\n            const status = await client.getValidationStatus(hash);\n            const entry = {\n                requestHash: hash,\n                ...status,\n            };\n            results.push(entry);\n        }\n        catch (error) {\n            console.warn(`[getValidatorAddressValidations] Failed to get status for hash ${hash}:`, error);\n            // Ignore invalid entries but continue\n        }\n    }\n    return results;\n}\n//# sourceMappingURL=validations.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BhZ2VudGljLXRydXN0L2NvcmUvZGlzdC9zZXJ2ZXIvbGliL3ZhbGlkYXRpb25zLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQTJDO0FBQ2tDO0FBQ2U7QUFDTjtBQUNsQztBQUMrQjtBQUM1RTtBQUNQLHlCQUF5Qix5RkFBMkI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELHNCQUFzQix3Q0FBd0MsZ0JBQWdCLFdBQVcsUUFBUTtBQUN2SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLEtBQUssYUFBYSxnQkFBZ0IsY0FBYyx3QkFBd0I7QUFDM0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUZBQXVGLEtBQUs7QUFDNUY7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9EQUFZO0FBQ2hDLGtFQUFrRSxlQUFlLFlBQVksZUFBZSxjQUFjLGlCQUFpQjtBQUMzSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLHFDQUFxQywwREFBZ0I7QUFDckQsa0JBQWtCLDBEQUFZO0FBQzlCLG1CQUFtQixnRUFBa0I7QUFDckM7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQkFBb0I7QUFDbkM7QUFDQSxvQkFBb0Isa0VBQW1CO0FBQ3ZDO0FBQ0E7QUFDQSx5QkFBeUIsd0RBQWtCO0FBQzNDO0FBQ0EsbUJBQW1CLDBDQUFJO0FBQ3ZCLEtBQUs7QUFDTCx5QkFBeUIsd0RBQWtCO0FBQzNDO0FBQ0E7QUFDQSxtQkFBbUIsMENBQUk7QUFDdkIsS0FBSztBQUNMO0FBQ0EsaUJBQWlCLCtDQUFTLENBQUMsaURBQVc7QUFDdEM7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHdFQUFjO0FBQ3RDO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHFGQUFzQjtBQUN0RDtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AseUJBQXlCLHlGQUEyQjtBQUNwRDtBQUNBLDBEQUEwRCxzQkFBc0IsNENBQTRDLGtCQUFrQixXQUFXLFFBQVE7QUFDaks7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJGQUEyRixLQUFLO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvYmFyYi9hYS9Bc3NvY2lhdGVkQWNjb3VudHMvbm9kZV9tb2R1bGVzL0BhZ2VudGljLXRydXN0L2NvcmUvZGlzdC9zZXJ2ZXIvbGliL3ZhbGlkYXRpb25zLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGJ1aWxkRGlkODAwNCB9IGZyb20gJy4uLy4uL2luZGV4JztcbmltcG9ydCB7IGdldFZhbGlkYXRpb25SZWdpc3RyeUNsaWVudCB9IGZyb20gJy4uL3NpbmdsZXRvbnMvdmFsaWRhdGlvbkNsaWVudCc7XG5pbXBvcnQgeyBrZWNjYWsyNTYsIHN0cmluZ1RvSGV4LCBjcmVhdGVQdWJsaWNDbGllbnQsIGh0dHAsIGNyZWF0ZVdhbGxldENsaWVudCB9IGZyb20gJ3ZpZW0nO1xuaW1wb3J0IHsgdG9NZXRhTWFza1NtYXJ0QWNjb3VudCwgSW1wbGVtZW50YXRpb24gfSBmcm9tICdAbWV0YW1hc2svc21hcnQtYWNjb3VudHMta2l0JztcbmltcG9ydCB7IHByaXZhdGVLZXlUb0FjY291bnQgfSBmcm9tICd2aWVtL2FjY291bnRzJztcbmltcG9ydCB7IGdldENoYWluQnlJZCwgREVGQVVMVF9DSEFJTl9JRCwgcmVxdWlyZUNoYWluRW52VmFyIH0gZnJvbSAnLi9jaGFpbkNvbmZpZyc7XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0QWdlbnRWYWxpZGF0aW9uc1N1bW1hcnkoY2hhaW5JZCwgYWdlbnRJZCkge1xuICAgIGNvbnN0IGNsaWVudCA9IGF3YWl0IGdldFZhbGlkYXRpb25SZWdpc3RyeUNsaWVudChjaGFpbklkKTtcbiAgICBjb25zdCBudW1lcmljQWdlbnRJZCA9IHR5cGVvZiBhZ2VudElkID09PSAnc3RyaW5nJyA/IE51bWJlci5wYXJzZUludChhZ2VudElkLCAxMCkgOiBOdW1iZXIoYWdlbnRJZCk7XG4gICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUobnVtZXJpY0FnZW50SWQpIHx8IG51bWVyaWNBZ2VudElkIDw9IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFnZW50SWQnKTtcbiAgICB9XG4gICAgY29uc3QgYWdlbnRJZEJpZ0ludCA9IEJpZ0ludChudW1lcmljQWdlbnRJZCk7XG4gICAgY29uc3QgcmVxdWVzdEhhc2hlcyA9IGF3YWl0IGNsaWVudC5nZXRBZ2VudFZhbGlkYXRpb25zKGFnZW50SWRCaWdJbnQpO1xuICAgIGNvbnNvbGUubG9nKGBbZ2V0QWdlbnRWYWxpZGF0aW9uc1N1bW1hcnldIEZvdW5kICR7cmVxdWVzdEhhc2hlcy5sZW5ndGh9IHZhbGlkYXRpb24gcmVxdWVzdCBoYXNoKGVzKSBmb3IgYWdlbnQgJHtudW1lcmljQWdlbnRJZH0gb24gY2hhaW4gJHtjaGFpbklkfWApO1xuICAgIGNvbnN0IHBlbmRpbmcgPSBbXTtcbiAgICBjb25zdCBjb21wbGV0ZWQgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGhhc2ggb2YgcmVxdWVzdEhhc2hlcykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3Qgc3RhdHVzID0gYXdhaXQgY2xpZW50LmdldFZhbGlkYXRpb25TdGF0dXMoaGFzaCk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgW2dldEFnZW50VmFsaWRhdGlvbnNTdW1tYXJ5XSBWYWxpZGF0aW9uICR7aGFzaH06IHJlc3BvbnNlPSR7c3RhdHVzLnJlc3BvbnNlfSwgdmFsaWRhdG9yPSR7c3RhdHVzLnZhbGlkYXRvckFkZHJlc3N9YCk7XG4gICAgICAgICAgICBjb25zdCBlbnRyeSA9IHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0SGFzaDogaGFzaCxcbiAgICAgICAgICAgICAgICAuLi5zdGF0dXMsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHN0YXR1cy5yZXNwb25zZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHBlbmRpbmcucHVzaChlbnRyeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb21wbGV0ZWQucHVzaChlbnRyeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYFtnZXRBZ2VudFZhbGlkYXRpb25zU3VtbWFyeV0gRmFpbGVkIHRvIGdldCBzdGF0dXMgZm9yIGhhc2ggJHtoYXNofTpgLCBlcnJvcik7XG4gICAgICAgICAgICAvLyBJZ25vcmUgaW52YWxpZCBlbnRyaWVzIGJ1dCBjb250aW51ZVxuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGRpZDgwMDQgPSBidWlsZERpZDgwMDQoY2hhaW5JZCwgbnVtZXJpY0FnZW50SWQpO1xuICAgIGNvbnNvbGUubG9nKGBbZ2V0QWdlbnRWYWxpZGF0aW9uc1N1bW1hcnldIFN1bW1hcnkgZm9yIGFnZW50ICR7bnVtZXJpY0FnZW50SWR9OiBwZW5kaW5nPSR7cGVuZGluZy5sZW5ndGh9LCBjb21wbGV0ZWQ9JHtjb21wbGV0ZWQubGVuZ3RofWApO1xuICAgIHJldHVybiB7XG4gICAgICAgIGFnZW50SWQ6IFN0cmluZyhudW1lcmljQWdlbnRJZCksXG4gICAgICAgIGNoYWluSWQsXG4gICAgICAgIGRpZDgwMDQsXG4gICAgICAgIHBlbmRpbmcsXG4gICAgICAgIGNvbXBsZXRlZCxcbiAgICB9O1xufVxuLyoqXG4gKiBDcmVhdGUgYSB2YWxpZGF0b3IgYWNjb3VudCBhYnN0cmFjdGlvbiB1c2luZyB0aGUgbmFtZSAnbmFtZS12YWxpZGF0b3InIGFzIHRoZSBzZWVkIGZyb20gYSBwcml2YXRlIGtleS5cbiAqIFRoZSB2YWxpZGF0b3IgYWRkcmVzcyBpcyBkZXRlcm1pbmVkIHNlcnZlci1zaWRlIGJhc2VkIG9uIEFHRU5USUNfVFJVU1RfVkFMSURBVE9SX1BSSVZBVEVfS0VZLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY3JlYXRlVmFsaWRhdG9yQWNjb3VudEFic3RyYWN0aW9uKHZhbGlkYXRvck5hbWUsIHZhbGlkYXRvclByaXZhdGVLZXksIGNoYWluSWQpIHtcbiAgICBjb25zdCB0YXJnZXRDaGFpbklkID0gY2hhaW5JZCB8fCBERUZBVUxUX0NIQUlOX0lEO1xuICAgIGNvbnN0IGNoYWluID0gZ2V0Q2hhaW5CeUlkKHRhcmdldENoYWluSWQpO1xuICAgIGNvbnN0IHJwY1VybCA9IHJlcXVpcmVDaGFpbkVudlZhcignQUdFTlRJQ19UUlVTVF9SUENfVVJMJywgdGFyZ2V0Q2hhaW5JZCk7XG4gICAgLy8gTm9ybWFsaXplIHByaXZhdGUga2V5XG4gICAgY29uc3Qgbm9ybWFsaXplZEtleSA9IHZhbGlkYXRvclByaXZhdGVLZXkuc3RhcnRzV2l0aCgnMHgnKVxuICAgICAgICA/IHZhbGlkYXRvclByaXZhdGVLZXlcbiAgICAgICAgOiBgMHgke3ZhbGlkYXRvclByaXZhdGVLZXl9YDtcbiAgICAvLyBDcmVhdGUgYWNjb3VudCBmcm9tIHByaXZhdGUga2V5XG4gICAgY29uc3QgYWNjb3VudCA9IHByaXZhdGVLZXlUb0FjY291bnQobm9ybWFsaXplZEtleSk7XG4gICAgY29uc3QgZW9hQWRkcmVzcyA9IGFjY291bnQuYWRkcmVzcztcbiAgICAvLyBDcmVhdGUgcHVibGljIGFuZCB3YWxsZXQgY2xpZW50c1xuICAgIGNvbnN0IHB1YmxpY0NsaWVudCA9IGNyZWF0ZVB1YmxpY0NsaWVudCh7XG4gICAgICAgIGNoYWluOiBjaGFpbixcbiAgICAgICAgdHJhbnNwb3J0OiBodHRwKHJwY1VybCksXG4gICAgfSk7XG4gICAgY29uc3Qgd2FsbGV0Q2xpZW50ID0gY3JlYXRlV2FsbGV0Q2xpZW50KHtcbiAgICAgICAgYWNjb3VudCxcbiAgICAgICAgY2hhaW46IGNoYWluLFxuICAgICAgICB0cmFuc3BvcnQ6IGh0dHAocnBjVXJsKSxcbiAgICB9KTtcbiAgICAvLyBDcmVhdGUgc2FsdCBmcm9tIHZhbGlkYXRvciBuYW1lICduYW1lLXZhbGlkYXRvcidcbiAgICBjb25zdCBzYWx0ID0ga2VjY2FrMjU2KHN0cmluZ1RvSGV4KHZhbGlkYXRvck5hbWUpKTtcbiAgICAvLyBDcmVhdGUgYWNjb3VudCBhYnN0cmFjdGlvbiB3aXRoIHZhbGlkYXRvciBuYW1lIGFzIHNlZWRcbiAgICBjb25zdCBjbGllbnRDb25maWcgPSB7XG4gICAgICAgIGNsaWVudDogcHVibGljQ2xpZW50LFxuICAgICAgICBpbXBsZW1lbnRhdGlvbjogSW1wbGVtZW50YXRpb24uSHlicmlkLFxuICAgICAgICBzaWduZXI6IHtcbiAgICAgICAgICAgIHdhbGxldENsaWVudCxcbiAgICAgICAgfSxcbiAgICAgICAgZGVwbG95UGFyYW1zOiBbZW9hQWRkcmVzcywgW10sIFtdLCBbXV0sXG4gICAgICAgIGRlcGxveVNhbHQ6IHNhbHQsXG4gICAgfTtcbiAgICBjb25zdCBhY2NvdW50Q2xpZW50ID0gYXdhaXQgdG9NZXRhTWFza1NtYXJ0QWNjb3VudChjbGllbnRDb25maWcpO1xuICAgIGNvbnN0IHZhbGlkYXRvckFkZHJlc3MgPSBhY2NvdW50Q2xpZW50LmFkZHJlc3M7XG4gICAgcmV0dXJuIHsgYWNjb3VudENsaWVudCwgYWRkcmVzczogdmFsaWRhdG9yQWRkcmVzcyB9O1xufVxuLyoqXG4gKiBHZXQgdmFsaWRhdGlvbiByZXF1ZXN0cyBmb3IgYSB2YWxpZGF0b3IgYWRkcmVzc1xuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0VmFsaWRhdG9yQWRkcmVzc1ZhbGlkYXRpb25zKGNoYWluSWQsIHZhbGlkYXRvckFkZHJlc3MpIHtcbiAgICBjb25zdCBjbGllbnQgPSBhd2FpdCBnZXRWYWxpZGF0aW9uUmVnaXN0cnlDbGllbnQoY2hhaW5JZCk7XG4gICAgY29uc3QgcmVxdWVzdEhhc2hlcyA9IGF3YWl0IGNsaWVudC5nZXRWYWxpZGF0b3JSZXF1ZXN0cyh2YWxpZGF0b3JBZGRyZXNzKTtcbiAgICBjb25zb2xlLmxvZyhgW2dldFZhbGlkYXRvckFkZHJlc3NWYWxpZGF0aW9uc10gRm91bmQgJHtyZXF1ZXN0SGFzaGVzLmxlbmd0aH0gdmFsaWRhdGlvbiByZXF1ZXN0IGhhc2goZXMpIGZvciB2YWxpZGF0b3IgJHt2YWxpZGF0b3JBZGRyZXNzfSBvbiBjaGFpbiAke2NoYWluSWR9YCk7XG4gICAgY29uc3QgcmVzdWx0cyA9IFtdO1xuICAgIGZvciAoY29uc3QgaGFzaCBvZiByZXF1ZXN0SGFzaGVzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBzdGF0dXMgPSBhd2FpdCBjbGllbnQuZ2V0VmFsaWRhdGlvblN0YXR1cyhoYXNoKTtcbiAgICAgICAgICAgIGNvbnN0IGVudHJ5ID0ge1xuICAgICAgICAgICAgICAgIHJlcXVlc3RIYXNoOiBoYXNoLFxuICAgICAgICAgICAgICAgIC4uLnN0YXR1cyxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXN1bHRzLnB1c2goZW50cnkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGBbZ2V0VmFsaWRhdG9yQWRkcmVzc1ZhbGlkYXRpb25zXSBGYWlsZWQgdG8gZ2V0IHN0YXR1cyBmb3IgaGFzaCAke2hhc2h9OmAsIGVycm9yKTtcbiAgICAgICAgICAgIC8vIElnbm9yZSBpbnZhbGlkIGVudHJpZXMgYnV0IGNvbnRpbnVlXG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdHM7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD12YWxpZGF0aW9ucy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@agentic-trust/core/dist/server/lib/validations.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@agentic-trust/core/dist/server/lib/veramo.js":
/*!************************************************************************!*\
  !*** ../../node_modules/@agentic-trust/core/dist/server/lib/veramo.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   VeramoAPI: () => (/* binding */ VeramoAPI)\n/* harmony export */ });\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! viem */ \"(rsc)/../../node_modules/viem/_esm/utils/signature/verifyMessage.js\");\n/**\n * Veramo Agent integration for AgenticTrustClient\n */\n\n/**\n * Check if we're running in Cloudflare Workers\n * This check must happen at runtime, not module load time\n */\nfunction isCloudflareWorkers() {\n    // Check for Workers-specific globals that exist at runtime\n    if (typeof globalThis !== 'undefined') {\n        // Workers have these globals\n        if (typeof globalThis.caches !== 'undefined') {\n            return true;\n        }\n        // Workers environment binding\n        if (typeof globalThis.env !== 'undefined') {\n            return true;\n        }\n    }\n    // Workers don't have Node.js process\n    if (typeof process === 'undefined') {\n        return true;\n    }\n    // If we have process but no node version, might be Workers\n    if (typeof process !== 'undefined' && !process.versions?.node) {\n        return true;\n    }\n    return false;\n}\n/**\n * Nonce store for replay protection (singleton)\n *\n * In Cloudflare Workers, we don't use setInterval because:\n * 1. It's not allowed at module load time\n * 2. Workers have request isolation, so nonces won't persist across requests anyway\n */\nclass NonceStore {\n    nonces = null;\n    cleanupInterval = null; // Use 'any' to avoid NodeJS.Timeout type issues in Workers\n    cleanupInitialized = false;\n    isWorkers;\n    constructor() {\n        // Check if we're in Workers at construction time (but don't do anything with it yet)\n        // This check is safe because it's just reading globals, not calling disallowed functions\n        this.isWorkers = isCloudflareWorkers();\n    }\n    /**\n     * Get or create the nonces Set (lazy initialization)\n     */\n    getNonces() {\n        if (!this.nonces) {\n            this.nonces = new Set();\n        }\n        return this.nonces;\n    }\n    /**\n     * Initialize cleanup interval (only in Node.js, never in Workers)\n     * Called lazily when first needed, not in constructor\n     */\n    initializeCleanup() {\n        if (this.cleanupInitialized)\n            return;\n        this.cleanupInitialized = true;\n        // In Workers, never initialize cleanup - just return\n        if (this.isWorkers) {\n            return;\n        }\n        // Only in Node.js: try to set up cleanup interval\n        // Use dynamic access to setInterval to avoid Workers detecting it\n        try {\n            const setIntervalFn = globalThis.setInterval || global.setInterval;\n            if (typeof setIntervalFn === 'function') {\n                // Clean up old nonces every 10 minutes (only in Node.js)\n                this.cleanupInterval = setIntervalFn(() => {\n                    const nonces = this.getNonces();\n                    if (nonces.size > 10000) {\n                        nonces.clear();\n                    }\n                }, 10 * 60 * 1000);\n            }\n        }\n        catch (error) {\n            // If setInterval fails, continue without cleanup\n            // This is safe because Workers have request isolation\n        }\n    }\n    /**\n     * Check if nonce exists (replay attack)\n     */\n    has(nonce) {\n        // In Workers, nonces don't persist anyway, so we can skip initialization\n        if (this.isWorkers) {\n            return this.getNonces().has(nonce);\n        }\n        this.initializeCleanup(); // Lazy initialization (Node.js only)\n        return this.getNonces().has(nonce);\n    }\n    /**\n     * Add nonce to store\n     */\n    add(nonce) {\n        // In Workers, nonces don't persist anyway, but we still track them per request\n        if (this.isWorkers) {\n            this.getNonces().add(nonce);\n            return;\n        }\n        this.initializeCleanup(); // Lazy initialization (Node.js only)\n        this.getNonces().add(nonce);\n    }\n    /**\n     * Clean up\n     */\n    destroy() {\n        if (!this.isWorkers && this.cleanupInterval) {\n            const clearIntervalFn = globalThis.clearInterval || global.clearInterval;\n            if (typeof clearIntervalFn === 'function') {\n                clearIntervalFn(this.cleanupInterval);\n            }\n        }\n        if (this.nonces) {\n            this.nonces.clear();\n        }\n    }\n}\n// Lazy singleton nonce store - only create when first accessed\n// This prevents setInterval from running at module load time in Cloudflare Workers\nlet nonceStoreInstance = null;\nfunction getNonceStore() {\n    if (!nonceStoreInstance) {\n        nonceStoreInstance = new NonceStore();\n    }\n    return nonceStoreInstance;\n}\n/**\n * Veramo integration API\n * Provides access to the connected Veramo agent and verification methods\n */\nclass VeramoAPI {\n    agent = null;\n    /**\n     * Connect a Veramo agent instance to the client\n     */\n    connect(agent) {\n        this.agent = agent;\n    }\n    /**\n     * Get the connected Veramo agent\n     * Agent is always connected after client construction\n     */\n    getAgent() {\n        if (!this.agent) {\n            throw new Error('Veramo agent not connected. This should not happen.');\n        }\n        return this.agent;\n    }\n    /**\n     * Check if an agent is connected\n     */\n    isConnected() {\n        return this.agent !== null;\n    }\n    /**\n     * Disconnect the agent\n     */\n    disconnect() {\n        this.agent = null;\n    }\n    /**\n     * Verify a signed challenge\n     * Handles all Veramo agent logic internally - no Veramo exposure at app level\n     *\n     * @param auth - The authentication challenge with signature\n     * @param expectedAudience - Expected audience (provider URL) for validation\n     * @returns Verification result with client address if valid\n     */\n    async verifyChallenge(auth, expectedAudience) {\n        if (!this.agent) {\n            throw new Error('Veramo agent not connected');\n        }\n        try {\n            // Extract nonce from challenge for replay protection\n            const challengeLines = auth.challenge.split('\\n');\n            const nonceLine = challengeLines.find((line) => line.startsWith('nonce='));\n            const nonce = nonceLine?.split('=')[1];\n            // Check for replay attacks\n            if (nonce && getNonceStore().has(nonce)) {\n                return { valid: false, error: 'Replay attack detected: nonce already used' };\n            }\n            // Parse challenge to extract fields\n            if (challengeLines[0] !== 'orgtrust-challenge') {\n                return { valid: false, error: 'Invalid challenge format' };\n            }\n            const challengeData = {};\n            for (let i = 1; i < challengeLines.length; i++) {\n                const line = challengeLines[i];\n                if (line) {\n                    const [key, value] = line.split('=');\n                    if (key && value) {\n                        challengeData[key] = value;\n                    }\n                }\n            }\n            const iss = challengeData.iss;\n            const aud = challengeData.aud;\n            const iat = parseInt(challengeData.iat || '0', 10);\n            // Validate issuer matches DID\n            if (iss !== auth.did) {\n                return { valid: false, error: 'Issuer does not match DID' };\n            }\n            // Validate audience\n            if (aud !== expectedAudience) {\n                return { valid: false, error: 'Audience mismatch' };\n            }\n            // Validate expiration (5 minutes)\n            const now = Date.now();\n            const expiration = 5 * 60 * 1000; // 5 minutes\n            if (now - iat > expiration) {\n                return { valid: false, error: 'Challenge expired' };\n            }\n            // For ethr DIDs with eth_signMessage, try DID resolution first, then fall back to direct verification\n            let ethereumAddress = null;\n            let valid = false;\n            if (auth.did.startsWith('did:ethr:') && auth.algorithm === 'eth_signMessage') {\n                // Try to resolve the DID first (if it's on-chain)\n                let resolvedAddress = null;\n                try {\n                    const didResolutionResult = await this.agent.resolveDid({ didUrl: auth.did });\n                    if (didResolutionResult && didResolutionResult.didDocument) {\n                        // Try to extract address from verification method\n                        const verificationMethod = didResolutionResult.didDocument.verificationMethod?.find((vm) => vm.ethereumAddress || vm.blockchainAccountId);\n                        if (verificationMethod) {\n                            const vmAddress = verificationMethod.ethereumAddress ||\n                                (verificationMethod.blockchainAccountId?.split(':').pop() || null);\n                            if (vmAddress) {\n                                resolvedAddress = vmAddress.toLowerCase();\n                            }\n                        }\n                    }\n                }\n                catch (error) {\n                    // Could not resolve DID (may not be on-chain), will use direct address verification\n                }\n                // Determine which address to use for verification\n                if (resolvedAddress) {\n                    ethereumAddress = resolvedAddress;\n                }\n                else if (auth.ethereumAddress) {\n                    ethereumAddress = auth.ethereumAddress.toLowerCase();\n                }\n                else {\n                    // Fallback: extract from DID\n                    const didParts = auth.did.split(':');\n                    let addressPart = didParts[didParts.length - 1];\n                    if (addressPart) {\n                        addressPart = addressPart.split('#')[0];\n                        if (didParts.length === 4 && didParts[3]) {\n                            addressPart = didParts[3];\n                        }\n                        else if (didParts.length === 3 && didParts[2]) {\n                            addressPart = didParts[2];\n                        }\n                        if (addressPart) {\n                            ethereumAddress = addressPart.startsWith('0x') ? addressPart : `0x${addressPart}`;\n                            ethereumAddress = ethereumAddress.toLowerCase();\n                        }\n                    }\n                }\n                // Verify signature directly using the address\n                if (!ethereumAddress) {\n                    return { valid: false, error: 'No Ethereum address available for verification' };\n                }\n                try {\n                    valid = await (0,viem__WEBPACK_IMPORTED_MODULE_0__.verifyMessage)({\n                        address: ethereumAddress,\n                        message: auth.challenge,\n                        signature: auth.signature,\n                    });\n                }\n                catch (error) {\n                    return { valid: false, error: 'Signature verification failed' };\n                }\n            }\n            else {\n                // For other DID methods or algorithms, resolve DID and use verification method\n                const didResolutionResult = await this.agent.resolveDid({ didUrl: auth.did });\n                if (!didResolutionResult || !didResolutionResult.didDocument) {\n                    return { valid: false, error: 'Could not resolve DID' };\n                }\n                const didDocument = didResolutionResult.didDocument;\n                // Find verification method by kid\n                const verificationMethod = didDocument.verificationMethod?.find((vm) => vm.id === auth.kid || vm.id.endsWith(`#${auth.kid.split('#').pop()}`));\n                if (!verificationMethod) {\n                    return { valid: false, error: 'Verification method not found' };\n                }\n                // Verify signature based on algorithm\n                if (auth.algorithm === 'eth_signMessage' || auth.algorithm.startsWith('eth_')) {\n                    const vmAddress = verificationMethod.ethereumAddress ||\n                        (verificationMethod.blockchainAccountId?.split(':').pop());\n                    if (!vmAddress) {\n                        return { valid: false, error: 'No Ethereum address in verification method' };\n                    }\n                    try {\n                        valid = await (0,viem__WEBPACK_IMPORTED_MODULE_0__.verifyMessage)({\n                            address: vmAddress,\n                            message: auth.challenge,\n                            signature: auth.signature,\n                        });\n                    }\n                    catch (error) {\n                        return { valid: false, error: 'Signature verification failed' };\n                    }\n                }\n                else if (auth.algorithm === 'ES256K' || auth.algorithm === 'EdDSA') {\n                    // For ES256K/EdDSA, we need to use Veramo's verification\n                    // This is a simplified check - in production, use proper crypto verification\n                    if (!auth.signature || auth.signature.length === 0) {\n                        return { valid: false, error: 'Invalid signature' };\n                    }\n                    // TODO: Implement proper ES256K/EdDSA verification using Veramo\n                    // For now, we'll accept the signature if it exists (not secure in production)\n                    console.warn('ES256K/EdDSA verification not fully implemented, accepting signature');\n                    valid = true;\n                }\n                else {\n                    return { valid: false, error: `Unsupported algorithm: ${auth.algorithm}` };\n                }\n            }\n            // If valid, add nonce to store and extract client address\n            if (valid && nonce) {\n                getNonceStore().add(nonce);\n            }\n            // Extract client address from auth\n            let clientAddress;\n            if (auth.ethereumAddress) {\n                clientAddress = auth.ethereumAddress;\n            }\n            else if (auth.did?.startsWith('did:ethr:')) {\n                // Extract address from ethr DID\n                const addressMatch = auth.did.match(/did:ethr:(0x[a-fA-F0-9]{40})/);\n                if (addressMatch) {\n                    clientAddress = addressMatch[1];\n                }\n                else if (ethereumAddress) {\n                    clientAddress = ethereumAddress;\n                }\n            }\n            else if (ethereumAddress) {\n                clientAddress = ethereumAddress;\n            }\n            return {\n                valid,\n                error: valid ? undefined : 'Signature verification failed',\n                clientAddress,\n            };\n        }\n        catch (error) {\n            console.error('Challenge verification error:', error);\n            return {\n                valid: false,\n                error: error instanceof Error ? error.message : 'Unknown verification error',\n            };\n        }\n    }\n}\n//# sourceMappingURL=veramo.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BhZ2VudGljLXRydXN0L2NvcmUvZGlzdC9zZXJ2ZXIvbGliL3ZlcmFtby5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLDRCQUE0QiwyQkFBMkI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFLGtCQUFrQjtBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0dBQWdHLFlBQVk7QUFDNUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSxrQ0FBa0MsbURBQWE7QUFDL0M7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEUsa0JBQWtCO0FBQzVGO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLGlJQUFpSSwwQkFBMEI7QUFDM0o7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQSxzQ0FBc0MsbURBQWE7QUFDbkQ7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLCtDQUErQyxlQUFlO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFLEdBQUc7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvYmFyYi9hYS9Bc3NvY2lhdGVkQWNjb3VudHMvbm9kZV9tb2R1bGVzL0BhZ2VudGljLXRydXN0L2NvcmUvZGlzdC9zZXJ2ZXIvbGliL3ZlcmFtby5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFZlcmFtbyBBZ2VudCBpbnRlZ3JhdGlvbiBmb3IgQWdlbnRpY1RydXN0Q2xpZW50XG4gKi9cbmltcG9ydCB7IHZlcmlmeU1lc3NhZ2UgfSBmcm9tICd2aWVtJztcbi8qKlxuICogQ2hlY2sgaWYgd2UncmUgcnVubmluZyBpbiBDbG91ZGZsYXJlIFdvcmtlcnNcbiAqIFRoaXMgY2hlY2sgbXVzdCBoYXBwZW4gYXQgcnVudGltZSwgbm90IG1vZHVsZSBsb2FkIHRpbWVcbiAqL1xuZnVuY3Rpb24gaXNDbG91ZGZsYXJlV29ya2VycygpIHtcbiAgICAvLyBDaGVjayBmb3IgV29ya2Vycy1zcGVjaWZpYyBnbG9iYWxzIHRoYXQgZXhpc3QgYXQgcnVudGltZVxuICAgIGlmICh0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgLy8gV29ya2VycyBoYXZlIHRoZXNlIGdsb2JhbHNcbiAgICAgICAgaWYgKHR5cGVvZiBnbG9iYWxUaGlzLmNhY2hlcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdvcmtlcnMgZW52aXJvbm1lbnQgYmluZGluZ1xuICAgICAgICBpZiAodHlwZW9mIGdsb2JhbFRoaXMuZW52ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gV29ya2VycyBkb24ndCBoYXZlIE5vZGUuanMgcHJvY2Vzc1xuICAgIGlmICh0eXBlb2YgcHJvY2VzcyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8vIElmIHdlIGhhdmUgcHJvY2VzcyBidXQgbm8gbm9kZSB2ZXJzaW9uLCBtaWdodCBiZSBXb3JrZXJzXG4gICAgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiAhcHJvY2Vzcy52ZXJzaW9ucz8ubm9kZSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuLyoqXG4gKiBOb25jZSBzdG9yZSBmb3IgcmVwbGF5IHByb3RlY3Rpb24gKHNpbmdsZXRvbilcbiAqXG4gKiBJbiBDbG91ZGZsYXJlIFdvcmtlcnMsIHdlIGRvbid0IHVzZSBzZXRJbnRlcnZhbCBiZWNhdXNlOlxuICogMS4gSXQncyBub3QgYWxsb3dlZCBhdCBtb2R1bGUgbG9hZCB0aW1lXG4gKiAyLiBXb3JrZXJzIGhhdmUgcmVxdWVzdCBpc29sYXRpb24sIHNvIG5vbmNlcyB3b24ndCBwZXJzaXN0IGFjcm9zcyByZXF1ZXN0cyBhbnl3YXlcbiAqL1xuY2xhc3MgTm9uY2VTdG9yZSB7XG4gICAgbm9uY2VzID0gbnVsbDtcbiAgICBjbGVhbnVwSW50ZXJ2YWwgPSBudWxsOyAvLyBVc2UgJ2FueScgdG8gYXZvaWQgTm9kZUpTLlRpbWVvdXQgdHlwZSBpc3N1ZXMgaW4gV29ya2Vyc1xuICAgIGNsZWFudXBJbml0aWFsaXplZCA9IGZhbHNlO1xuICAgIGlzV29ya2VycztcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgLy8gQ2hlY2sgaWYgd2UncmUgaW4gV29ya2VycyBhdCBjb25zdHJ1Y3Rpb24gdGltZSAoYnV0IGRvbid0IGRvIGFueXRoaW5nIHdpdGggaXQgeWV0KVxuICAgICAgICAvLyBUaGlzIGNoZWNrIGlzIHNhZmUgYmVjYXVzZSBpdCdzIGp1c3QgcmVhZGluZyBnbG9iYWxzLCBub3QgY2FsbGluZyBkaXNhbGxvd2VkIGZ1bmN0aW9uc1xuICAgICAgICB0aGlzLmlzV29ya2VycyA9IGlzQ2xvdWRmbGFyZVdvcmtlcnMoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IG9yIGNyZWF0ZSB0aGUgbm9uY2VzIFNldCAobGF6eSBpbml0aWFsaXphdGlvbilcbiAgICAgKi9cbiAgICBnZXROb25jZXMoKSB7XG4gICAgICAgIGlmICghdGhpcy5ub25jZXMpIHtcbiAgICAgICAgICAgIHRoaXMubm9uY2VzID0gbmV3IFNldCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm5vbmNlcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZSBjbGVhbnVwIGludGVydmFsIChvbmx5IGluIE5vZGUuanMsIG5ldmVyIGluIFdvcmtlcnMpXG4gICAgICogQ2FsbGVkIGxhemlseSB3aGVuIGZpcnN0IG5lZWRlZCwgbm90IGluIGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgaW5pdGlhbGl6ZUNsZWFudXAoKSB7XG4gICAgICAgIGlmICh0aGlzLmNsZWFudXBJbml0aWFsaXplZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5jbGVhbnVwSW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgICAvLyBJbiBXb3JrZXJzLCBuZXZlciBpbml0aWFsaXplIGNsZWFudXAgLSBqdXN0IHJldHVyblxuICAgICAgICBpZiAodGhpcy5pc1dvcmtlcnMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBPbmx5IGluIE5vZGUuanM6IHRyeSB0byBzZXQgdXAgY2xlYW51cCBpbnRlcnZhbFxuICAgICAgICAvLyBVc2UgZHluYW1pYyBhY2Nlc3MgdG8gc2V0SW50ZXJ2YWwgdG8gYXZvaWQgV29ya2VycyBkZXRlY3RpbmcgaXRcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHNldEludGVydmFsRm4gPSBnbG9iYWxUaGlzLnNldEludGVydmFsIHx8IGdsb2JhbC5zZXRJbnRlcnZhbDtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc2V0SW50ZXJ2YWxGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIC8vIENsZWFuIHVwIG9sZCBub25jZXMgZXZlcnkgMTAgbWludXRlcyAob25seSBpbiBOb2RlLmpzKVxuICAgICAgICAgICAgICAgIHRoaXMuY2xlYW51cEludGVydmFsID0gc2V0SW50ZXJ2YWxGbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5vbmNlcyA9IHRoaXMuZ2V0Tm9uY2VzKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub25jZXMuc2l6ZSA+IDEwMDAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBub25jZXMuY2xlYXIoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIDEwICogNjAgKiAxMDAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIC8vIElmIHNldEludGVydmFsIGZhaWxzLCBjb250aW51ZSB3aXRob3V0IGNsZWFudXBcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgc2FmZSBiZWNhdXNlIFdvcmtlcnMgaGF2ZSByZXF1ZXN0IGlzb2xhdGlvblxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIG5vbmNlIGV4aXN0cyAocmVwbGF5IGF0dGFjaylcbiAgICAgKi9cbiAgICBoYXMobm9uY2UpIHtcbiAgICAgICAgLy8gSW4gV29ya2Vycywgbm9uY2VzIGRvbid0IHBlcnNpc3QgYW55d2F5LCBzbyB3ZSBjYW4gc2tpcCBpbml0aWFsaXphdGlvblxuICAgICAgICBpZiAodGhpcy5pc1dvcmtlcnMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldE5vbmNlcygpLmhhcyhub25jZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbml0aWFsaXplQ2xlYW51cCgpOyAvLyBMYXp5IGluaXRpYWxpemF0aW9uIChOb2RlLmpzIG9ubHkpXG4gICAgICAgIHJldHVybiB0aGlzLmdldE5vbmNlcygpLmhhcyhub25jZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCBub25jZSB0byBzdG9yZVxuICAgICAqL1xuICAgIGFkZChub25jZSkge1xuICAgICAgICAvLyBJbiBXb3JrZXJzLCBub25jZXMgZG9uJ3QgcGVyc2lzdCBhbnl3YXksIGJ1dCB3ZSBzdGlsbCB0cmFjayB0aGVtIHBlciByZXF1ZXN0XG4gICAgICAgIGlmICh0aGlzLmlzV29ya2Vycykge1xuICAgICAgICAgICAgdGhpcy5nZXROb25jZXMoKS5hZGQobm9uY2UpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZUNsZWFudXAoKTsgLy8gTGF6eSBpbml0aWFsaXphdGlvbiAoTm9kZS5qcyBvbmx5KVxuICAgICAgICB0aGlzLmdldE5vbmNlcygpLmFkZChub25jZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsZWFuIHVwXG4gICAgICovXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzV29ya2VycyAmJiB0aGlzLmNsZWFudXBJbnRlcnZhbCkge1xuICAgICAgICAgICAgY29uc3QgY2xlYXJJbnRlcnZhbEZuID0gZ2xvYmFsVGhpcy5jbGVhckludGVydmFsIHx8IGdsb2JhbC5jbGVhckludGVydmFsO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjbGVhckludGVydmFsRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBjbGVhckludGVydmFsRm4odGhpcy5jbGVhbnVwSW50ZXJ2YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm5vbmNlcykge1xuICAgICAgICAgICAgdGhpcy5ub25jZXMuY2xlYXIoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8vIExhenkgc2luZ2xldG9uIG5vbmNlIHN0b3JlIC0gb25seSBjcmVhdGUgd2hlbiBmaXJzdCBhY2Nlc3NlZFxuLy8gVGhpcyBwcmV2ZW50cyBzZXRJbnRlcnZhbCBmcm9tIHJ1bm5pbmcgYXQgbW9kdWxlIGxvYWQgdGltZSBpbiBDbG91ZGZsYXJlIFdvcmtlcnNcbmxldCBub25jZVN0b3JlSW5zdGFuY2UgPSBudWxsO1xuZnVuY3Rpb24gZ2V0Tm9uY2VTdG9yZSgpIHtcbiAgICBpZiAoIW5vbmNlU3RvcmVJbnN0YW5jZSkge1xuICAgICAgICBub25jZVN0b3JlSW5zdGFuY2UgPSBuZXcgTm9uY2VTdG9yZSgpO1xuICAgIH1cbiAgICByZXR1cm4gbm9uY2VTdG9yZUluc3RhbmNlO1xufVxuLyoqXG4gKiBWZXJhbW8gaW50ZWdyYXRpb24gQVBJXG4gKiBQcm92aWRlcyBhY2Nlc3MgdG8gdGhlIGNvbm5lY3RlZCBWZXJhbW8gYWdlbnQgYW5kIHZlcmlmaWNhdGlvbiBtZXRob2RzXG4gKi9cbmV4cG9ydCBjbGFzcyBWZXJhbW9BUEkge1xuICAgIGFnZW50ID0gbnVsbDtcbiAgICAvKipcbiAgICAgKiBDb25uZWN0IGEgVmVyYW1vIGFnZW50IGluc3RhbmNlIHRvIHRoZSBjbGllbnRcbiAgICAgKi9cbiAgICBjb25uZWN0KGFnZW50KSB7XG4gICAgICAgIHRoaXMuYWdlbnQgPSBhZ2VudDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjb25uZWN0ZWQgVmVyYW1vIGFnZW50XG4gICAgICogQWdlbnQgaXMgYWx3YXlzIGNvbm5lY3RlZCBhZnRlciBjbGllbnQgY29uc3RydWN0aW9uXG4gICAgICovXG4gICAgZ2V0QWdlbnQoKSB7XG4gICAgICAgIGlmICghdGhpcy5hZ2VudCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdWZXJhbW8gYWdlbnQgbm90IGNvbm5lY3RlZC4gVGhpcyBzaG91bGQgbm90IGhhcHBlbi4nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5hZ2VudDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgYW4gYWdlbnQgaXMgY29ubmVjdGVkXG4gICAgICovXG4gICAgaXNDb25uZWN0ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFnZW50ICE9PSBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEaXNjb25uZWN0IHRoZSBhZ2VudFxuICAgICAqL1xuICAgIGRpc2Nvbm5lY3QoKSB7XG4gICAgICAgIHRoaXMuYWdlbnQgPSBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBWZXJpZnkgYSBzaWduZWQgY2hhbGxlbmdlXG4gICAgICogSGFuZGxlcyBhbGwgVmVyYW1vIGFnZW50IGxvZ2ljIGludGVybmFsbHkgLSBubyBWZXJhbW8gZXhwb3N1cmUgYXQgYXBwIGxldmVsXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYXV0aCAtIFRoZSBhdXRoZW50aWNhdGlvbiBjaGFsbGVuZ2Ugd2l0aCBzaWduYXR1cmVcbiAgICAgKiBAcGFyYW0gZXhwZWN0ZWRBdWRpZW5jZSAtIEV4cGVjdGVkIGF1ZGllbmNlIChwcm92aWRlciBVUkwpIGZvciB2YWxpZGF0aW9uXG4gICAgICogQHJldHVybnMgVmVyaWZpY2F0aW9uIHJlc3VsdCB3aXRoIGNsaWVudCBhZGRyZXNzIGlmIHZhbGlkXG4gICAgICovXG4gICAgYXN5bmMgdmVyaWZ5Q2hhbGxlbmdlKGF1dGgsIGV4cGVjdGVkQXVkaWVuY2UpIHtcbiAgICAgICAgaWYgKCF0aGlzLmFnZW50KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1ZlcmFtbyBhZ2VudCBub3QgY29ubmVjdGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIEV4dHJhY3Qgbm9uY2UgZnJvbSBjaGFsbGVuZ2UgZm9yIHJlcGxheSBwcm90ZWN0aW9uXG4gICAgICAgICAgICBjb25zdCBjaGFsbGVuZ2VMaW5lcyA9IGF1dGguY2hhbGxlbmdlLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICAgIGNvbnN0IG5vbmNlTGluZSA9IGNoYWxsZW5nZUxpbmVzLmZpbmQoKGxpbmUpID0+IGxpbmUuc3RhcnRzV2l0aCgnbm9uY2U9JykpO1xuICAgICAgICAgICAgY29uc3Qgbm9uY2UgPSBub25jZUxpbmU/LnNwbGl0KCc9JylbMV07XG4gICAgICAgICAgICAvLyBDaGVjayBmb3IgcmVwbGF5IGF0dGFja3NcbiAgICAgICAgICAgIGlmIChub25jZSAmJiBnZXROb25jZVN0b3JlKCkuaGFzKG5vbmNlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbGlkOiBmYWxzZSwgZXJyb3I6ICdSZXBsYXkgYXR0YWNrIGRldGVjdGVkOiBub25jZSBhbHJlYWR5IHVzZWQnIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBQYXJzZSBjaGFsbGVuZ2UgdG8gZXh0cmFjdCBmaWVsZHNcbiAgICAgICAgICAgIGlmIChjaGFsbGVuZ2VMaW5lc1swXSAhPT0gJ29yZ3RydXN0LWNoYWxsZW5nZScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB2YWxpZDogZmFsc2UsIGVycm9yOiAnSW52YWxpZCBjaGFsbGVuZ2UgZm9ybWF0JyB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY2hhbGxlbmdlRGF0YSA9IHt9O1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBjaGFsbGVuZ2VMaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxpbmUgPSBjaGFsbGVuZ2VMaW5lc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAobGluZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBba2V5LCB2YWx1ZV0gPSBsaW5lLnNwbGl0KCc9Jyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXkgJiYgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYWxsZW5nZURhdGFba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaXNzID0gY2hhbGxlbmdlRGF0YS5pc3M7XG4gICAgICAgICAgICBjb25zdCBhdWQgPSBjaGFsbGVuZ2VEYXRhLmF1ZDtcbiAgICAgICAgICAgIGNvbnN0IGlhdCA9IHBhcnNlSW50KGNoYWxsZW5nZURhdGEuaWF0IHx8ICcwJywgMTApO1xuICAgICAgICAgICAgLy8gVmFsaWRhdGUgaXNzdWVyIG1hdGNoZXMgRElEXG4gICAgICAgICAgICBpZiAoaXNzICE9PSBhdXRoLmRpZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbGlkOiBmYWxzZSwgZXJyb3I6ICdJc3N1ZXIgZG9lcyBub3QgbWF0Y2ggRElEJyB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVmFsaWRhdGUgYXVkaWVuY2VcbiAgICAgICAgICAgIGlmIChhdWQgIT09IGV4cGVjdGVkQXVkaWVuY2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB2YWxpZDogZmFsc2UsIGVycm9yOiAnQXVkaWVuY2UgbWlzbWF0Y2gnIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBWYWxpZGF0ZSBleHBpcmF0aW9uICg1IG1pbnV0ZXMpXG4gICAgICAgICAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgY29uc3QgZXhwaXJhdGlvbiA9IDUgKiA2MCAqIDEwMDA7IC8vIDUgbWludXRlc1xuICAgICAgICAgICAgaWYgKG5vdyAtIGlhdCA+IGV4cGlyYXRpb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB2YWxpZDogZmFsc2UsIGVycm9yOiAnQ2hhbGxlbmdlIGV4cGlyZWQnIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBGb3IgZXRociBESURzIHdpdGggZXRoX3NpZ25NZXNzYWdlLCB0cnkgRElEIHJlc29sdXRpb24gZmlyc3QsIHRoZW4gZmFsbCBiYWNrIHRvIGRpcmVjdCB2ZXJpZmljYXRpb25cbiAgICAgICAgICAgIGxldCBldGhlcmV1bUFkZHJlc3MgPSBudWxsO1xuICAgICAgICAgICAgbGV0IHZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoYXV0aC5kaWQuc3RhcnRzV2l0aCgnZGlkOmV0aHI6JykgJiYgYXV0aC5hbGdvcml0aG0gPT09ICdldGhfc2lnbk1lc3NhZ2UnKSB7XG4gICAgICAgICAgICAgICAgLy8gVHJ5IHRvIHJlc29sdmUgdGhlIERJRCBmaXJzdCAoaWYgaXQncyBvbi1jaGFpbilcbiAgICAgICAgICAgICAgICBsZXQgcmVzb2x2ZWRBZGRyZXNzID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkaWRSZXNvbHV0aW9uUmVzdWx0ID0gYXdhaXQgdGhpcy5hZ2VudC5yZXNvbHZlRGlkKHsgZGlkVXJsOiBhdXRoLmRpZCB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRpZFJlc29sdXRpb25SZXN1bHQgJiYgZGlkUmVzb2x1dGlvblJlc3VsdC5kaWREb2N1bWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVHJ5IHRvIGV4dHJhY3QgYWRkcmVzcyBmcm9tIHZlcmlmaWNhdGlvbiBtZXRob2RcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHZlcmlmaWNhdGlvbk1ldGhvZCA9IGRpZFJlc29sdXRpb25SZXN1bHQuZGlkRG9jdW1lbnQudmVyaWZpY2F0aW9uTWV0aG9kPy5maW5kKCh2bSkgPT4gdm0uZXRoZXJldW1BZGRyZXNzIHx8IHZtLmJsb2NrY2hhaW5BY2NvdW50SWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZlcmlmaWNhdGlvbk1ldGhvZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHZtQWRkcmVzcyA9IHZlcmlmaWNhdGlvbk1ldGhvZC5ldGhlcmV1bUFkZHJlc3MgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHZlcmlmaWNhdGlvbk1ldGhvZC5ibG9ja2NoYWluQWNjb3VudElkPy5zcGxpdCgnOicpLnBvcCgpIHx8IG51bGwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2bUFkZHJlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZWRBZGRyZXNzID0gdm1BZGRyZXNzLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAvLyBDb3VsZCBub3QgcmVzb2x2ZSBESUQgKG1heSBub3QgYmUgb24tY2hhaW4pLCB3aWxsIHVzZSBkaXJlY3QgYWRkcmVzcyB2ZXJpZmljYXRpb25cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gRGV0ZXJtaW5lIHdoaWNoIGFkZHJlc3MgdG8gdXNlIGZvciB2ZXJpZmljYXRpb25cbiAgICAgICAgICAgICAgICBpZiAocmVzb2x2ZWRBZGRyZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIGV0aGVyZXVtQWRkcmVzcyA9IHJlc29sdmVkQWRkcmVzcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYXV0aC5ldGhlcmV1bUFkZHJlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgZXRoZXJldW1BZGRyZXNzID0gYXV0aC5ldGhlcmV1bUFkZHJlc3MudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZhbGxiYWNrOiBleHRyYWN0IGZyb20gRElEXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRpZFBhcnRzID0gYXV0aC5kaWQuc3BsaXQoJzonKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGFkZHJlc3NQYXJ0ID0gZGlkUGFydHNbZGlkUGFydHMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChhZGRyZXNzUGFydCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkcmVzc1BhcnQgPSBhZGRyZXNzUGFydC5zcGxpdCgnIycpWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRpZFBhcnRzLmxlbmd0aCA9PT0gNCAmJiBkaWRQYXJ0c1szXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZHJlc3NQYXJ0ID0gZGlkUGFydHNbM107XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChkaWRQYXJ0cy5sZW5ndGggPT09IDMgJiYgZGlkUGFydHNbMl0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzUGFydCA9IGRpZFBhcnRzWzJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFkZHJlc3NQYXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXRoZXJldW1BZGRyZXNzID0gYWRkcmVzc1BhcnQuc3RhcnRzV2l0aCgnMHgnKSA/IGFkZHJlc3NQYXJ0IDogYDB4JHthZGRyZXNzUGFydH1gO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV0aGVyZXVtQWRkcmVzcyA9IGV0aGVyZXVtQWRkcmVzcy50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFZlcmlmeSBzaWduYXR1cmUgZGlyZWN0bHkgdXNpbmcgdGhlIGFkZHJlc3NcbiAgICAgICAgICAgICAgICBpZiAoIWV0aGVyZXVtQWRkcmVzcykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB2YWxpZDogZmFsc2UsIGVycm9yOiAnTm8gRXRoZXJldW0gYWRkcmVzcyBhdmFpbGFibGUgZm9yIHZlcmlmaWNhdGlvbicgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdmFsaWQgPSBhd2FpdCB2ZXJpZnlNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZHJlc3M6IGV0aGVyZXVtQWRkcmVzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGF1dGguY2hhbGxlbmdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2lnbmF0dXJlOiBhdXRoLnNpZ25hdHVyZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB2YWxpZDogZmFsc2UsIGVycm9yOiAnU2lnbmF0dXJlIHZlcmlmaWNhdGlvbiBmYWlsZWQnIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gRm9yIG90aGVyIERJRCBtZXRob2RzIG9yIGFsZ29yaXRobXMsIHJlc29sdmUgRElEIGFuZCB1c2UgdmVyaWZpY2F0aW9uIG1ldGhvZFxuICAgICAgICAgICAgICAgIGNvbnN0IGRpZFJlc29sdXRpb25SZXN1bHQgPSBhd2FpdCB0aGlzLmFnZW50LnJlc29sdmVEaWQoeyBkaWRVcmw6IGF1dGguZGlkIH0pO1xuICAgICAgICAgICAgICAgIGlmICghZGlkUmVzb2x1dGlvblJlc3VsdCB8fCAhZGlkUmVzb2x1dGlvblJlc3VsdC5kaWREb2N1bWVudCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB2YWxpZDogZmFsc2UsIGVycm9yOiAnQ291bGQgbm90IHJlc29sdmUgRElEJyB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBkaWREb2N1bWVudCA9IGRpZFJlc29sdXRpb25SZXN1bHQuZGlkRG9jdW1lbnQ7XG4gICAgICAgICAgICAgICAgLy8gRmluZCB2ZXJpZmljYXRpb24gbWV0aG9kIGJ5IGtpZFxuICAgICAgICAgICAgICAgIGNvbnN0IHZlcmlmaWNhdGlvbk1ldGhvZCA9IGRpZERvY3VtZW50LnZlcmlmaWNhdGlvbk1ldGhvZD8uZmluZCgodm0pID0+IHZtLmlkID09PSBhdXRoLmtpZCB8fCB2bS5pZC5lbmRzV2l0aChgIyR7YXV0aC5raWQuc3BsaXQoJyMnKS5wb3AoKX1gKSk7XG4gICAgICAgICAgICAgICAgaWYgKCF2ZXJpZmljYXRpb25NZXRob2QpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsaWQ6IGZhbHNlLCBlcnJvcjogJ1ZlcmlmaWNhdGlvbiBtZXRob2Qgbm90IGZvdW5kJyB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBWZXJpZnkgc2lnbmF0dXJlIGJhc2VkIG9uIGFsZ29yaXRobVxuICAgICAgICAgICAgICAgIGlmIChhdXRoLmFsZ29yaXRobSA9PT0gJ2V0aF9zaWduTWVzc2FnZScgfHwgYXV0aC5hbGdvcml0aG0uc3RhcnRzV2l0aCgnZXRoXycpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZtQWRkcmVzcyA9IHZlcmlmaWNhdGlvbk1ldGhvZC5ldGhlcmV1bUFkZHJlc3MgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICh2ZXJpZmljYXRpb25NZXRob2QuYmxvY2tjaGFpbkFjY291bnRJZD8uc3BsaXQoJzonKS5wb3AoKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdm1BZGRyZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB2YWxpZDogZmFsc2UsIGVycm9yOiAnTm8gRXRoZXJldW0gYWRkcmVzcyBpbiB2ZXJpZmljYXRpb24gbWV0aG9kJyB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZCA9IGF3YWl0IHZlcmlmeU1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZHJlc3M6IHZtQWRkcmVzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBhdXRoLmNoYWxsZW5nZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaWduYXR1cmU6IGF1dGguc2lnbmF0dXJlLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB2YWxpZDogZmFsc2UsIGVycm9yOiAnU2lnbmF0dXJlIHZlcmlmaWNhdGlvbiBmYWlsZWQnIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYXV0aC5hbGdvcml0aG0gPT09ICdFUzI1NksnIHx8IGF1dGguYWxnb3JpdGhtID09PSAnRWREU0EnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZvciBFUzI1NksvRWREU0EsIHdlIG5lZWQgdG8gdXNlIFZlcmFtbydzIHZlcmlmaWNhdGlvblxuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIGEgc2ltcGxpZmllZCBjaGVjayAtIGluIHByb2R1Y3Rpb24sIHVzZSBwcm9wZXIgY3J5cHRvIHZlcmlmaWNhdGlvblxuICAgICAgICAgICAgICAgICAgICBpZiAoIWF1dGguc2lnbmF0dXJlIHx8IGF1dGguc2lnbmF0dXJlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsaWQ6IGZhbHNlLCBlcnJvcjogJ0ludmFsaWQgc2lnbmF0dXJlJyB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IEltcGxlbWVudCBwcm9wZXIgRVMyNTZLL0VkRFNBIHZlcmlmaWNhdGlvbiB1c2luZyBWZXJhbW9cbiAgICAgICAgICAgICAgICAgICAgLy8gRm9yIG5vdywgd2UnbGwgYWNjZXB0IHRoZSBzaWduYXR1cmUgaWYgaXQgZXhpc3RzIChub3Qgc2VjdXJlIGluIHByb2R1Y3Rpb24pXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignRVMyNTZLL0VkRFNBIHZlcmlmaWNhdGlvbiBub3QgZnVsbHkgaW1wbGVtZW50ZWQsIGFjY2VwdGluZyBzaWduYXR1cmUnKTtcbiAgICAgICAgICAgICAgICAgICAgdmFsaWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsaWQ6IGZhbHNlLCBlcnJvcjogYFVuc3VwcG9ydGVkIGFsZ29yaXRobTogJHthdXRoLmFsZ29yaXRobX1gIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgdmFsaWQsIGFkZCBub25jZSB0byBzdG9yZSBhbmQgZXh0cmFjdCBjbGllbnQgYWRkcmVzc1xuICAgICAgICAgICAgaWYgKHZhbGlkICYmIG5vbmNlKSB7XG4gICAgICAgICAgICAgICAgZ2V0Tm9uY2VTdG9yZSgpLmFkZChub25jZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBFeHRyYWN0IGNsaWVudCBhZGRyZXNzIGZyb20gYXV0aFxuICAgICAgICAgICAgbGV0IGNsaWVudEFkZHJlc3M7XG4gICAgICAgICAgICBpZiAoYXV0aC5ldGhlcmV1bUFkZHJlc3MpIHtcbiAgICAgICAgICAgICAgICBjbGllbnRBZGRyZXNzID0gYXV0aC5ldGhlcmV1bUFkZHJlc3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChhdXRoLmRpZD8uc3RhcnRzV2l0aCgnZGlkOmV0aHI6JykpIHtcbiAgICAgICAgICAgICAgICAvLyBFeHRyYWN0IGFkZHJlc3MgZnJvbSBldGhyIERJRFxuICAgICAgICAgICAgICAgIGNvbnN0IGFkZHJlc3NNYXRjaCA9IGF1dGguZGlkLm1hdGNoKC9kaWQ6ZXRocjooMHhbYS1mQS1GMC05XXs0MH0pLyk7XG4gICAgICAgICAgICAgICAgaWYgKGFkZHJlc3NNYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICBjbGllbnRBZGRyZXNzID0gYWRkcmVzc01hdGNoWzFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChldGhlcmV1bUFkZHJlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xpZW50QWRkcmVzcyA9IGV0aGVyZXVtQWRkcmVzcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChldGhlcmV1bUFkZHJlc3MpIHtcbiAgICAgICAgICAgICAgICBjbGllbnRBZGRyZXNzID0gZXRoZXJldW1BZGRyZXNzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB2YWxpZCxcbiAgICAgICAgICAgICAgICBlcnJvcjogdmFsaWQgPyB1bmRlZmluZWQgOiAnU2lnbmF0dXJlIHZlcmlmaWNhdGlvbiBmYWlsZWQnLFxuICAgICAgICAgICAgICAgIGNsaWVudEFkZHJlc3MsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignQ2hhbGxlbmdlIHZlcmlmaWNhdGlvbiBlcnJvcjonLCBlcnJvcik7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHZhbGlkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biB2ZXJpZmljYXRpb24gZXJyb3InLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZlcmFtby5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@agentic-trust/core/dist/server/lib/veramo.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@agentic-trust/core/dist/server/lib/veramoFactory.js":
/*!*******************************************************************************!*\
  !*** ../../node_modules/@agentic-trust/core/dist/server/lib/veramoFactory.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createVeramoAgentForClient: () => (/* binding */ createVeramoAgentForClient)\n/* harmony export */ });\n/* harmony import */ var _veramo_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @veramo/core */ \"(rsc)/../../node_modules/@veramo/core/build/index.js\");\n/* harmony import */ var _veramo_key_manager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @veramo/key-manager */ \"(rsc)/../../node_modules/@veramo/key-manager/build/index.js\");\n/* harmony import */ var _veramo_kms_local__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @veramo/kms-local */ \"(rsc)/../../node_modules/@veramo/kms-local/build/index.js\");\n/* harmony import */ var _veramo_did_manager__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @veramo/did-manager */ \"(rsc)/../../node_modules/@veramo/did-manager/build/index.js\");\n/* harmony import */ var _veramo_did_resolver__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @veramo/did-resolver */ \"(rsc)/../../node_modules/@veramo/did-resolver/build/index.js\");\n/* harmony import */ var did_resolver__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! did-resolver */ \"(rsc)/../../node_modules/did-resolver/lib/resolver.module.js\");\n/* harmony import */ var ethr_did_resolver__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ethr-did-resolver */ \"(rsc)/../../node_modules/ethr-did-resolver/esm/index.js\");\n/* harmony import */ var _veramo_did_provider_ethr__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @veramo/did-provider-ethr */ \"(rsc)/../../node_modules/@veramo/did-provider-ethr/build/index.js\");\n/* harmony import */ var viem_accounts__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! viem/accounts */ \"(rsc)/../../node_modules/viem/_esm/accounts/generatePrivateKey.js\");\n/* harmony import */ var web3__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! web3 */ \"(rsc)/../../node_modules/web3/lib/index.js\");\n/* harmony import */ var _agentic_trust_veramo_agent_extension__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @agentic-trust/veramo-agent-extension */ \"(rsc)/../../node_modules/@agentic-trust/veramo-agent-extension/dist/index.js\");\n/**\n * Veramo Agent Factory\n *\n * Creates a Veramo agent instance for AgenticTrust client use\n * This allows the core package to create agents internally without requiring\n * the consuming application to set up Veramo\n */\n\n\n\n\n\n\n\n\n\n\n\n/**\n * Create a Veramo agent instance for AgenticTrust client\n *\n * @param privateKey - Optional Ethereum private key (hex string with or without 0x prefix)\n *                     If not provided, a key will be generated for the session\n * @param rpcUrl - Optional Sepolia testnet RPC URL\n */\nasync function createVeramoAgentForClient(privateKey, rpcUrl) {\n    // Initialize DID providers for AA and Agent DIDs\n    const aaDidProviders = {};\n    const agentDidProviders = {};\n    // Initialize KMS instances\n    const aaKMS = new _agentic_trust_veramo_agent_extension__WEBPACK_IMPORTED_MODULE_8__.AAKeyManagementSystem(aaDidProviders);\n    const agentKMS = new _agentic_trust_veramo_agent_extension__WEBPACK_IMPORTED_MODULE_8__.AgentKeyManagementSystem(agentDidProviders);\n    // Get Ethereum RPC URLs from parameters or defaults\n    const rpc = rpcUrl || 'https://sepolia.drpc.org';\n    // Create Web3 providers for ethr-did-resolver\n    const web3SepoliaProvider = new web3__WEBPACK_IMPORTED_MODULE_7__.providers.HttpProvider(rpc);\n    // Create ethr DID provider for client DIDs\n    const ethrDidProvider = new _veramo_did_provider_ethr__WEBPACK_IMPORTED_MODULE_6__.EthrDIDProvider({\n        defaultKms: 'local',\n        networks: [\n            {\n                name: 'sepolia',\n                rpcUrl: rpc,\n            },\n        ],\n    });\n    // Create the agent with required plugins\n    const agent = (0,_veramo_core__WEBPACK_IMPORTED_MODULE_0__.createAgent)({\n        plugins: [\n            // Credential issuer for EIP-1271 signatures\n            new _agentic_trust_veramo_agent_extension__WEBPACK_IMPORTED_MODULE_8__.AgentCredentialIssuerEIP1271(),\n            // Key Manager with AA, Agent, and local KMS\n            // Local KMS is needed for ethr DIDs and importing private keys\n            new _veramo_key_manager__WEBPACK_IMPORTED_MODULE_1__.KeyManager({\n                store: new _veramo_key_manager__WEBPACK_IMPORTED_MODULE_1__.MemoryKeyStore(),\n                kms: {\n                    local: new _veramo_kms_local__WEBPACK_IMPORTED_MODULE_2__.KeyManagementSystem(new _veramo_key_manager__WEBPACK_IMPORTED_MODULE_1__.MemoryPrivateKeyStore()),\n                    aa: aaKMS,\n                    agent: agentKMS,\n                },\n            }),\n            // DID Manager - use ethr for client DIDs (simpler than agent DIDs)\n            new _veramo_did_manager__WEBPACK_IMPORTED_MODULE_3__.DIDManager({\n                store: new _veramo_did_manager__WEBPACK_IMPORTED_MODULE_3__.MemoryDIDStore(),\n                defaultProvider: 'did:ethr',\n                providers: {\n                    'did:ethr': ethrDidProvider,\n                    ...agentDidProviders,\n                },\n            }),\n            // DID Resolver for multiple DID methods\n            new _veramo_did_resolver__WEBPACK_IMPORTED_MODULE_4__.DIDResolverPlugin({\n                resolver: new did_resolver__WEBPACK_IMPORTED_MODULE_9__.Resolver({\n                    ...(0,_agentic_trust_veramo_agent_extension__WEBPACK_IMPORTED_MODULE_8__.getAAResolver)(),\n                    ...(0,_agentic_trust_veramo_agent_extension__WEBPACK_IMPORTED_MODULE_8__.getAgentResolver)(),\n                    ...(0,ethr_did_resolver__WEBPACK_IMPORTED_MODULE_5__.getResolver)({\n                        networks: [\n                            {\n                                name: 'sepolia',\n                                provider: web3SepoliaProvider,\n                            },\n                        ],\n                    }),\n                }),\n            }),\n        ],\n    });\n    // If a private key is provided, import it and create DID with it\n    // Otherwise, generate a key for this session\n    let finalPrivateKey = privateKey;\n    if (!finalPrivateKey) {\n        // Generate a new private key for this session\n        finalPrivateKey = (0,viem_accounts__WEBPACK_IMPORTED_MODULE_10__.generatePrivateKey)();\n    }\n    else {\n    }\n    // Normalize and validate private key\n    // Remove any whitespace, newlines, or other invalid characters\n    let cleanedKey = finalPrivateKey.trim().replace(/\\s+/g, '');\n    // Remove 0x prefix if present (we'll add it back)\n    if (cleanedKey.startsWith('0x')) {\n        cleanedKey = cleanedKey.slice(2);\n    }\n    // Validate it's a valid hex string (64 characters for 32 bytes)\n    if (!/^[0-9a-fA-F]{64}$/.test(cleanedKey)) {\n        throw new Error(`Invalid private key format. Expected 64 hex characters (32 bytes), ` +\n            `got ${cleanedKey.length} characters. ` +\n            `Key starts with: ${cleanedKey.substring(0, 10)}...`);\n    }\n    // Add 0x prefix\n    const normalizedKey = `0x${cleanedKey}`;\n    // Import the private key into the key manager\n    const importedKey = await agent.keyManagerImport({\n        type: 'Secp256k1',\n        privateKeyHex: normalizedKey,\n        kms: 'local',\n    });\n    // Create DID with the imported key\n    const identifier = await agent.didManagerCreate({\n        alias: 'default',\n        provider: 'did:ethr',\n        options: {\n            keyRef: importedKey.kid,\n        },\n    });\n    return agent;\n}\n//# sourceMappingURL=veramoFactory.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BhZ2VudGljLXRydXN0L2NvcmUvZGlzdC9zZXJ2ZXIvbGliL3ZlcmFtb0ZhY3RvcnkuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDMkM7QUFDNkM7QUFDaEM7QUFDUztBQUNSO0FBQ2pCO0FBQzJCO0FBQ1A7QUFDVDtBQUMzQjtBQUNxTDtBQUM3TTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isd0ZBQXFCO0FBQzNDLHlCQUF5QiwyRkFBd0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLDJDQUFjO0FBQ2xEO0FBQ0EsZ0NBQWdDLHNFQUFlO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxLQUFLO0FBQ0w7QUFDQSxrQkFBa0IseURBQVc7QUFDN0I7QUFDQTtBQUNBLGdCQUFnQiwrRkFBNEI7QUFDNUM7QUFDQTtBQUNBLGdCQUFnQiwyREFBVTtBQUMxQiwyQkFBMkIsK0RBQWM7QUFDekM7QUFDQSwrQkFBK0Isa0VBQW1CLEtBQUssc0VBQXFCO0FBQzVFO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0EsZ0JBQWdCLDJEQUFVO0FBQzFCLDJCQUEyQiwrREFBYztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQSxnQkFBZ0IsbUVBQWlCO0FBQ2pDLDhCQUE4QixrREFBUTtBQUN0Qyx1QkFBdUIsb0ZBQWE7QUFDcEMsdUJBQXVCLHVGQUFnQjtBQUN2Qyx1QkFBdUIsOERBQWU7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGtFQUFrQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLEdBQUc7QUFDMUI7QUFDQSxtQkFBbUIsbUJBQW1CO0FBQ3RDLGdDQUFnQyw0QkFBNEI7QUFDNUQ7QUFDQTtBQUNBLCtCQUErQixXQUFXO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL2JhcmIvYWEvQXNzb2NpYXRlZEFjY291bnRzL25vZGVfbW9kdWxlcy9AYWdlbnRpYy10cnVzdC9jb3JlL2Rpc3Qvc2VydmVyL2xpYi92ZXJhbW9GYWN0b3J5LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogVmVyYW1vIEFnZW50IEZhY3RvcnlcbiAqXG4gKiBDcmVhdGVzIGEgVmVyYW1vIGFnZW50IGluc3RhbmNlIGZvciBBZ2VudGljVHJ1c3QgY2xpZW50IHVzZVxuICogVGhpcyBhbGxvd3MgdGhlIGNvcmUgcGFja2FnZSB0byBjcmVhdGUgYWdlbnRzIGludGVybmFsbHkgd2l0aG91dCByZXF1aXJpbmdcbiAqIHRoZSBjb25zdW1pbmcgYXBwbGljYXRpb24gdG8gc2V0IHVwIFZlcmFtb1xuICovXG5pbXBvcnQgeyBjcmVhdGVBZ2VudCB9IGZyb20gJ0B2ZXJhbW8vY29yZSc7XG5pbXBvcnQgeyBLZXlNYW5hZ2VyLCBNZW1vcnlLZXlTdG9yZSwgTWVtb3J5UHJpdmF0ZUtleVN0b3JlIH0gZnJvbSAnQHZlcmFtby9rZXktbWFuYWdlcic7XG5pbXBvcnQgeyBLZXlNYW5hZ2VtZW50U3lzdGVtIH0gZnJvbSAnQHZlcmFtby9rbXMtbG9jYWwnO1xuaW1wb3J0IHsgRElETWFuYWdlciwgTWVtb3J5RElEU3RvcmUgfSBmcm9tICdAdmVyYW1vL2RpZC1tYW5hZ2VyJztcbmltcG9ydCB7IERJRFJlc29sdmVyUGx1Z2luIH0gZnJvbSAnQHZlcmFtby9kaWQtcmVzb2x2ZXInO1xuaW1wb3J0IHsgUmVzb2x2ZXIgfSBmcm9tICdkaWQtcmVzb2x2ZXInO1xuaW1wb3J0IHsgZ2V0UmVzb2x2ZXIgYXMgZXRockRpZFJlc29sdmVyIH0gZnJvbSAnZXRoci1kaWQtcmVzb2x2ZXInO1xuaW1wb3J0IHsgRXRockRJRFByb3ZpZGVyIH0gZnJvbSAnQHZlcmFtby9kaWQtcHJvdmlkZXItZXRocic7XG5pbXBvcnQgeyBnZW5lcmF0ZVByaXZhdGVLZXkgfSBmcm9tICd2aWVtL2FjY291bnRzJztcbmltcG9ydCBXZWIzIGZyb20gJ3dlYjMnO1xuaW1wb3J0IHsgZ2V0QUFSZXNvbHZlciBhcyBhYURpZFJlc29sdmVyLCBnZXRBZ2VudFJlc29sdmVyIGFzIGFnZW50RGlkUmVzb2x2ZXIsIEFBS2V5TWFuYWdlbWVudFN5c3RlbSwgQWdlbnRLZXlNYW5hZ2VtZW50U3lzdGVtLCBBZ2VudENyZWRlbnRpYWxJc3N1ZXJFSVAxMjcxLCB9IGZyb20gJ0BhZ2VudGljLXRydXN0L3ZlcmFtby1hZ2VudC1leHRlbnNpb24nO1xuLyoqXG4gKiBDcmVhdGUgYSBWZXJhbW8gYWdlbnQgaW5zdGFuY2UgZm9yIEFnZW50aWNUcnVzdCBjbGllbnRcbiAqXG4gKiBAcGFyYW0gcHJpdmF0ZUtleSAtIE9wdGlvbmFsIEV0aGVyZXVtIHByaXZhdGUga2V5IChoZXggc3RyaW5nIHdpdGggb3Igd2l0aG91dCAweCBwcmVmaXgpXG4gKiAgICAgICAgICAgICAgICAgICAgIElmIG5vdCBwcm92aWRlZCwgYSBrZXkgd2lsbCBiZSBnZW5lcmF0ZWQgZm9yIHRoZSBzZXNzaW9uXG4gKiBAcGFyYW0gcnBjVXJsIC0gT3B0aW9uYWwgU2Vwb2xpYSB0ZXN0bmV0IFJQQyBVUkxcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZVZlcmFtb0FnZW50Rm9yQ2xpZW50KHByaXZhdGVLZXksIHJwY1VybCkge1xuICAgIC8vIEluaXRpYWxpemUgRElEIHByb3ZpZGVycyBmb3IgQUEgYW5kIEFnZW50IERJRHNcbiAgICBjb25zdCBhYURpZFByb3ZpZGVycyA9IHt9O1xuICAgIGNvbnN0IGFnZW50RGlkUHJvdmlkZXJzID0ge307XG4gICAgLy8gSW5pdGlhbGl6ZSBLTVMgaW5zdGFuY2VzXG4gICAgY29uc3QgYWFLTVMgPSBuZXcgQUFLZXlNYW5hZ2VtZW50U3lzdGVtKGFhRGlkUHJvdmlkZXJzKTtcbiAgICBjb25zdCBhZ2VudEtNUyA9IG5ldyBBZ2VudEtleU1hbmFnZW1lbnRTeXN0ZW0oYWdlbnREaWRQcm92aWRlcnMpO1xuICAgIC8vIEdldCBFdGhlcmV1bSBSUEMgVVJMcyBmcm9tIHBhcmFtZXRlcnMgb3IgZGVmYXVsdHNcbiAgICBjb25zdCBycGMgPSBycGNVcmwgfHwgJ2h0dHBzOi8vc2Vwb2xpYS5kcnBjLm9yZyc7XG4gICAgLy8gQ3JlYXRlIFdlYjMgcHJvdmlkZXJzIGZvciBldGhyLWRpZC1yZXNvbHZlclxuICAgIGNvbnN0IHdlYjNTZXBvbGlhUHJvdmlkZXIgPSBuZXcgV2ViMy5wcm92aWRlcnMuSHR0cFByb3ZpZGVyKHJwYyk7XG4gICAgLy8gQ3JlYXRlIGV0aHIgRElEIHByb3ZpZGVyIGZvciBjbGllbnQgRElEc1xuICAgIGNvbnN0IGV0aHJEaWRQcm92aWRlciA9IG5ldyBFdGhyRElEUHJvdmlkZXIoe1xuICAgICAgICBkZWZhdWx0S21zOiAnbG9jYWwnLFxuICAgICAgICBuZXR3b3JrczogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6ICdzZXBvbGlhJyxcbiAgICAgICAgICAgICAgICBycGNVcmw6IHJwYyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgfSk7XG4gICAgLy8gQ3JlYXRlIHRoZSBhZ2VudCB3aXRoIHJlcXVpcmVkIHBsdWdpbnNcbiAgICBjb25zdCBhZ2VudCA9IGNyZWF0ZUFnZW50KHtcbiAgICAgICAgcGx1Z2luczogW1xuICAgICAgICAgICAgLy8gQ3JlZGVudGlhbCBpc3N1ZXIgZm9yIEVJUC0xMjcxIHNpZ25hdHVyZXNcbiAgICAgICAgICAgIG5ldyBBZ2VudENyZWRlbnRpYWxJc3N1ZXJFSVAxMjcxKCksXG4gICAgICAgICAgICAvLyBLZXkgTWFuYWdlciB3aXRoIEFBLCBBZ2VudCwgYW5kIGxvY2FsIEtNU1xuICAgICAgICAgICAgLy8gTG9jYWwgS01TIGlzIG5lZWRlZCBmb3IgZXRociBESURzIGFuZCBpbXBvcnRpbmcgcHJpdmF0ZSBrZXlzXG4gICAgICAgICAgICBuZXcgS2V5TWFuYWdlcih7XG4gICAgICAgICAgICAgICAgc3RvcmU6IG5ldyBNZW1vcnlLZXlTdG9yZSgpLFxuICAgICAgICAgICAgICAgIGttczoge1xuICAgICAgICAgICAgICAgICAgICBsb2NhbDogbmV3IEtleU1hbmFnZW1lbnRTeXN0ZW0obmV3IE1lbW9yeVByaXZhdGVLZXlTdG9yZSgpKSxcbiAgICAgICAgICAgICAgICAgICAgYWE6IGFhS01TLFxuICAgICAgICAgICAgICAgICAgICBhZ2VudDogYWdlbnRLTVMsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgLy8gRElEIE1hbmFnZXIgLSB1c2UgZXRociBmb3IgY2xpZW50IERJRHMgKHNpbXBsZXIgdGhhbiBhZ2VudCBESURzKVxuICAgICAgICAgICAgbmV3IERJRE1hbmFnZXIoe1xuICAgICAgICAgICAgICAgIHN0b3JlOiBuZXcgTWVtb3J5RElEU3RvcmUoKSxcbiAgICAgICAgICAgICAgICBkZWZhdWx0UHJvdmlkZXI6ICdkaWQ6ZXRocicsXG4gICAgICAgICAgICAgICAgcHJvdmlkZXJzOiB7XG4gICAgICAgICAgICAgICAgICAgICdkaWQ6ZXRocic6IGV0aHJEaWRQcm92aWRlcixcbiAgICAgICAgICAgICAgICAgICAgLi4uYWdlbnREaWRQcm92aWRlcnMsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgLy8gRElEIFJlc29sdmVyIGZvciBtdWx0aXBsZSBESUQgbWV0aG9kc1xuICAgICAgICAgICAgbmV3IERJRFJlc29sdmVyUGx1Z2luKHtcbiAgICAgICAgICAgICAgICByZXNvbHZlcjogbmV3IFJlc29sdmVyKHtcbiAgICAgICAgICAgICAgICAgICAgLi4uYWFEaWRSZXNvbHZlcigpLFxuICAgICAgICAgICAgICAgICAgICAuLi5hZ2VudERpZFJlc29sdmVyKCksXG4gICAgICAgICAgICAgICAgICAgIC4uLmV0aHJEaWRSZXNvbHZlcih7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXR3b3JrczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3NlcG9saWEnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlcjogd2ViM1NlcG9saWFQcm92aWRlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgXSxcbiAgICB9KTtcbiAgICAvLyBJZiBhIHByaXZhdGUga2V5IGlzIHByb3ZpZGVkLCBpbXBvcnQgaXQgYW5kIGNyZWF0ZSBESUQgd2l0aCBpdFxuICAgIC8vIE90aGVyd2lzZSwgZ2VuZXJhdGUgYSBrZXkgZm9yIHRoaXMgc2Vzc2lvblxuICAgIGxldCBmaW5hbFByaXZhdGVLZXkgPSBwcml2YXRlS2V5O1xuICAgIGlmICghZmluYWxQcml2YXRlS2V5KSB7XG4gICAgICAgIC8vIEdlbmVyYXRlIGEgbmV3IHByaXZhdGUga2V5IGZvciB0aGlzIHNlc3Npb25cbiAgICAgICAgZmluYWxQcml2YXRlS2V5ID0gZ2VuZXJhdGVQcml2YXRlS2V5KCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgIH1cbiAgICAvLyBOb3JtYWxpemUgYW5kIHZhbGlkYXRlIHByaXZhdGUga2V5XG4gICAgLy8gUmVtb3ZlIGFueSB3aGl0ZXNwYWNlLCBuZXdsaW5lcywgb3Igb3RoZXIgaW52YWxpZCBjaGFyYWN0ZXJzXG4gICAgbGV0IGNsZWFuZWRLZXkgPSBmaW5hbFByaXZhdGVLZXkudHJpbSgpLnJlcGxhY2UoL1xccysvZywgJycpO1xuICAgIC8vIFJlbW92ZSAweCBwcmVmaXggaWYgcHJlc2VudCAod2UnbGwgYWRkIGl0IGJhY2spXG4gICAgaWYgKGNsZWFuZWRLZXkuc3RhcnRzV2l0aCgnMHgnKSkge1xuICAgICAgICBjbGVhbmVkS2V5ID0gY2xlYW5lZEtleS5zbGljZSgyKTtcbiAgICB9XG4gICAgLy8gVmFsaWRhdGUgaXQncyBhIHZhbGlkIGhleCBzdHJpbmcgKDY0IGNoYXJhY3RlcnMgZm9yIDMyIGJ5dGVzKVxuICAgIGlmICghL15bMC05YS1mQS1GXXs2NH0kLy50ZXN0KGNsZWFuZWRLZXkpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBwcml2YXRlIGtleSBmb3JtYXQuIEV4cGVjdGVkIDY0IGhleCBjaGFyYWN0ZXJzICgzMiBieXRlcyksIGAgK1xuICAgICAgICAgICAgYGdvdCAke2NsZWFuZWRLZXkubGVuZ3RofSBjaGFyYWN0ZXJzLiBgICtcbiAgICAgICAgICAgIGBLZXkgc3RhcnRzIHdpdGg6ICR7Y2xlYW5lZEtleS5zdWJzdHJpbmcoMCwgMTApfS4uLmApO1xuICAgIH1cbiAgICAvLyBBZGQgMHggcHJlZml4XG4gICAgY29uc3Qgbm9ybWFsaXplZEtleSA9IGAweCR7Y2xlYW5lZEtleX1gO1xuICAgIC8vIEltcG9ydCB0aGUgcHJpdmF0ZSBrZXkgaW50byB0aGUga2V5IG1hbmFnZXJcbiAgICBjb25zdCBpbXBvcnRlZEtleSA9IGF3YWl0IGFnZW50LmtleU1hbmFnZXJJbXBvcnQoe1xuICAgICAgICB0eXBlOiAnU2VjcDI1NmsxJyxcbiAgICAgICAgcHJpdmF0ZUtleUhleDogbm9ybWFsaXplZEtleSxcbiAgICAgICAga21zOiAnbG9jYWwnLFxuICAgIH0pO1xuICAgIC8vIENyZWF0ZSBESUQgd2l0aCB0aGUgaW1wb3J0ZWQga2V5XG4gICAgY29uc3QgaWRlbnRpZmllciA9IGF3YWl0IGFnZW50LmRpZE1hbmFnZXJDcmVhdGUoe1xuICAgICAgICBhbGlhczogJ2RlZmF1bHQnLFxuICAgICAgICBwcm92aWRlcjogJ2RpZDpldGhyJyxcbiAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAga2V5UmVmOiBpbXBvcnRlZEtleS5raWQsXG4gICAgICAgIH0sXG4gICAgfSk7XG4gICAgcmV0dXJuIGFnZW50O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmVyYW1vRmFjdG9yeS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@agentic-trust/core/dist/server/lib/veramoFactory.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@agentic-trust/core/dist/server/services/delegatedAssociation.js":
/*!*******************************************************************************************!*\
  !*** ../../node_modules/@agentic-trust/core/dist/server/services/delegatedAssociation.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   buildDelegatedAssociationContext: () => (/* binding */ buildDelegatedAssociationContext),\n/* harmony export */   storeErc8092AssociationWithSessionDelegation: () => (/* binding */ storeErc8092AssociationWithSessionDelegation)\n/* harmony export */ });\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! viem */ \"(rsc)/../../node_modules/viem/_esm/clients/createPublicClient.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! viem */ \"(rsc)/../../node_modules/viem/_esm/clients/transports/http.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! viem */ \"(rsc)/../../node_modules/viem/_esm/clients/createWalletClient.js\");\n/* harmony import */ var viem_accounts__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! viem/accounts */ \"(rsc)/../../node_modules/viem/_esm/accounts/privateKeyToAccount.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! viem */ \"(rsc)/../../node_modules/abitype/dist/esm/human-readable/parseAbi.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! viem */ \"(rsc)/../../node_modules/viem/_esm/utils/abi/encodeFunctionData.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ethers */ \"(rsc)/../../node_modules/ethers/lib.esm/address/address.js\");\n/* harmony import */ var _metamask_smart_accounts_kit__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @metamask/smart-accounts-kit */ \"(rsc)/../../node_modules/@metamask/smart-accounts-kit/dist/index.mjs\");\n/* harmony import */ var _metamask_smart_accounts_kit__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @metamask/smart-accounts-kit */ \"(rsc)/../../node_modules/@metamask/smart-accounts-kit/dist/chunk-7MRTROLV.mjs\");\n/* harmony import */ var _metamask_smart_accounts_kit__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @metamask/smart-accounts-kit */ \"(rsc)/../../node_modules/@metamask/smart-accounts-kit/dist/chunk-CPLIK3VF.mjs\");\n/* harmony import */ var _metamask_smart_accounts_kit_contracts__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @metamask/smart-accounts-kit/contracts */ \"(rsc)/../../node_modules/@metamask/smart-accounts-kit/dist/chunk-6RN5RBOR.mjs\");\n/* harmony import */ var _lib_sessionPackage__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/sessionPackage */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/lib/sessionPackage.js\");\n/* harmony import */ var _lib_chainConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/chainConfig */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/lib/chainConfig.js\");\n/* harmony import */ var _client_accountClient__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../client/accountClient */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/client/accountClient.js\");\n\n\n\n\n\n// @ts-ignore contracts path\n\n\n\n\nconst ASSOCIATIONS_STORE_ABI = (0,viem__WEBPACK_IMPORTED_MODULE_3__.parseAbi)([\n    'function storeAssociation((uint40 revokedAt,bytes2 initiatorKeyType,bytes2 approverKeyType,bytes initiatorSignature,bytes approverSignature,(bytes initiator,bytes approver,uint40 validAt,uint40 validUntil,bytes4 interfaceId,bytes data) record) sar)',\n]);\nasync function buildDelegatedAssociationContext(sessionPackage, chainId = _lib_chainConfig__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_CHAIN_ID) {\n    const delegationSetup = (0,_lib_sessionPackage__WEBPACK_IMPORTED_MODULE_0__.buildDelegationSetup)(sessionPackage);\n    const bundlerUrl = (0,_lib_chainConfig__WEBPACK_IMPORTED_MODULE_1__.getChainBundlerUrl)(chainId);\n    if (!bundlerUrl) {\n        throw new Error(`Bundler URL not configured for chain ${chainId}.`);\n    }\n    const chain = (0,_lib_chainConfig__WEBPACK_IMPORTED_MODULE_1__.getChainById)(chainId);\n    const publicClient = (0,viem__WEBPACK_IMPORTED_MODULE_4__.createPublicClient)({\n        chain: delegationSetup.chain,\n        transport: (0,viem__WEBPACK_IMPORTED_MODULE_5__.http)(delegationSetup.rpcUrl),\n    });\n    const agentOwnerEOA = (0,viem_accounts__WEBPACK_IMPORTED_MODULE_6__.privateKeyToAccount)(delegationSetup.sessionKey.privateKey);\n    const walletClient = (0,viem__WEBPACK_IMPORTED_MODULE_7__.createWalletClient)({\n        account: agentOwnerEOA,\n        chain: delegationSetup.chain,\n        transport: (0,viem__WEBPACK_IMPORTED_MODULE_5__.http)(delegationSetup.rpcUrl),\n    });\n    if (!delegationSetup.sessionAA) {\n        throw new Error('SessionPackage.sessionAA is required to submit delegated storeAssociation.');\n    }\n    const sessionAccountClient = await (0,_metamask_smart_accounts_kit__WEBPACK_IMPORTED_MODULE_8__.toMetaMaskSmartAccount)({\n        address: delegationSetup.sessionAA,\n        client: publicClient,\n        implementation: _metamask_smart_accounts_kit__WEBPACK_IMPORTED_MODULE_9__.Implementation.Hybrid,\n        signer: { walletClient },\n        delegation: {\n            delegation: delegationSetup.signedDelegation,\n            delegator: delegationSetup.aa,\n        },\n    });\n    return {\n        sessionAccountClient,\n        walletClient,\n        publicClient,\n        delegationSetup,\n        bundlerUrl,\n        chain,\n    };\n}\nfunction getAssociationsProxyAddress() {\n    const addr = process.env.ASSOCIATIONS_STORE_PROXY ||\n        process.env.ASSOCIATIONS_PROXY_ADDRESS ||\n        '0xaF7428906D31918dDA2986D1405E2Ded06561E59';\n    if (!addr.startsWith('0x') || addr.length !== 42) {\n        throw new Error(`Invalid associations proxy address: ${addr}`);\n    }\n    try {\n        return ethers__WEBPACK_IMPORTED_MODULE_10__.getAddress(addr);\n    }\n    catch {\n        return ethers__WEBPACK_IMPORTED_MODULE_10__.getAddress(addr.toLowerCase());\n    }\n}\nasync function storeErc8092AssociationWithSessionDelegation(params) {\n    const chainId = params.chainId ?? params.sessionPackage.chainId ?? _lib_chainConfig__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_CHAIN_ID;\n    const { sessionAccountClient, delegationSetup, bundlerUrl, chain } = await buildDelegatedAssociationContext(params.sessionPackage, chainId);\n    const proxy = getAssociationsProxyAddress();\n    const data = (0,viem__WEBPACK_IMPORTED_MODULE_11__.encodeFunctionData)({\n        abi: ASSOCIATIONS_STORE_ABI,\n        functionName: 'storeAssociation',\n        args: [params.sar],\n    });\n    const includedExecutions = [\n        {\n            target: proxy,\n            value: 0n,\n            callData: data,\n        },\n    ];\n    const signedDelegation = delegationSetup.signedDelegation;\n    const delegationMessage = {\n        delegate: ethers__WEBPACK_IMPORTED_MODULE_10__.getAddress((signedDelegation.message?.delegate ?? signedDelegation.delegate)),\n        delegator: ethers__WEBPACK_IMPORTED_MODULE_10__.getAddress((signedDelegation.message?.delegator ?? signedDelegation.delegator)),\n        authority: (signedDelegation.message?.authority ?? signedDelegation.authority),\n        caveats: (signedDelegation.message?.caveats ?? signedDelegation.caveats),\n        salt: (signedDelegation.message?.salt ?? signedDelegation.salt),\n        signature: (signedDelegation.signature ?? signedDelegation.message?.signature),\n    };\n    const redemptionData = _metamask_smart_accounts_kit_contracts__WEBPACK_IMPORTED_MODULE_12__.DelegationManager_exports.encode.redeemDelegations({\n        delegations: [[delegationMessage]],\n        modes: [_metamask_smart_accounts_kit__WEBPACK_IMPORTED_MODULE_13__.ExecutionMode.SingleDefault],\n        executions: [includedExecutions],\n    });\n    const redemptionCall = {\n        to: delegationSetup.sessionAA,\n        data: redemptionData,\n        value: 0n,\n    };\n    const userOpHash = await (0,_client_accountClient__WEBPACK_IMPORTED_MODULE_2__.sendSponsoredUserOperation)({\n        bundlerUrl,\n        chain,\n        accountClient: sessionAccountClient,\n        calls: [redemptionCall],\n    });\n    const receipt = await (0,_client_accountClient__WEBPACK_IMPORTED_MODULE_2__.waitForUserOperationReceipt)({\n        bundlerUrl,\n        chain,\n        hash: userOpHash,\n    });\n    const txHash = receipt?.transactionHash || receipt?.receipt?.transactionHash || userOpHash;\n    return { txHash };\n}\n//# sourceMappingURL=delegatedAssociation.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BhZ2VudGljLXRydXN0L2NvcmUvZGlzdC9zZXJ2ZXIvc2VydmljZXMvZGVsZWdhdGVkQXNzb2NpYXRpb24uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFvRTtBQUNoQjtBQUNBO0FBQ3BCO0FBQ3NFO0FBQ3RHO0FBQzJFO0FBQ2Q7QUFDMkI7QUFDYTtBQUNyRywrQkFBK0IsOENBQVE7QUFDdkM7QUFDQTtBQUNPLDBFQUEwRSw4REFBZ0I7QUFDakcsNEJBQTRCLHlFQUFvQjtBQUNoRCx1QkFBdUIsb0VBQWtCO0FBQ3pDO0FBQ0EsZ0VBQWdFLFFBQVE7QUFDeEU7QUFDQSxrQkFBa0IsOERBQVk7QUFDOUIseUJBQXlCLHdEQUFrQjtBQUMzQztBQUNBLG1CQUFtQiwwQ0FBSTtBQUN2QixLQUFLO0FBQ0wsMEJBQTBCLGtFQUFtQjtBQUM3Qyx5QkFBeUIsd0RBQWtCO0FBQzNDO0FBQ0E7QUFDQSxtQkFBbUIsMENBQUk7QUFDdkIsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxvRkFBc0I7QUFDN0Q7QUFDQTtBQUNBLHdCQUF3Qix3RUFBYztBQUN0QyxrQkFBa0IsY0FBYztBQUNoQztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0QsS0FBSztBQUNwRTtBQUNBO0FBQ0EsZUFBZSwrQ0FBaUI7QUFDaEM7QUFDQTtBQUNBLGVBQWUsK0NBQWlCO0FBQ2hDO0FBQ0E7QUFDTztBQUNQLHVFQUF1RSw4REFBZ0I7QUFDdkYsWUFBWSwyREFBMkQ7QUFDdkU7QUFDQSxpQkFBaUIseURBQWtCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiwrQ0FBaUI7QUFDbkMsbUJBQW1CLCtDQUFpQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDhGQUFpQjtBQUM1QztBQUNBLGdCQUFnQix3RUFBYTtBQUM3QjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGlGQUEwQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCwwQkFBMEIsa0ZBQTJCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGFBQWE7QUFDYjtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9iYXJiL2FhL0Fzc29jaWF0ZWRBY2NvdW50cy9ub2RlX21vZHVsZXMvQGFnZW50aWMtdHJ1c3QvY29yZS9kaXN0L3NlcnZlci9zZXJ2aWNlcy9kZWxlZ2F0ZWRBc3NvY2lhdGlvbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjcmVhdGVQdWJsaWNDbGllbnQsIGNyZWF0ZVdhbGxldENsaWVudCwgaHR0cCB9IGZyb20gJ3ZpZW0nO1xuaW1wb3J0IHsgcHJpdmF0ZUtleVRvQWNjb3VudCB9IGZyb20gJ3ZpZW0vYWNjb3VudHMnO1xuaW1wb3J0IHsgZW5jb2RlRnVuY3Rpb25EYXRhLCBwYXJzZUFiaSB9IGZyb20gJ3ZpZW0nO1xuaW1wb3J0IHsgZXRoZXJzIH0gZnJvbSAnZXRoZXJzJztcbmltcG9ydCB7IEltcGxlbWVudGF0aW9uLCB0b01ldGFNYXNrU21hcnRBY2NvdW50LCBFeGVjdXRpb25Nb2RlLCB9IGZyb20gJ0BtZXRhbWFzay9zbWFydC1hY2NvdW50cy1raXQnO1xuLy8gQHRzLWlnbm9yZSBjb250cmFjdHMgcGF0aFxuaW1wb3J0IHsgRGVsZWdhdGlvbk1hbmFnZXIgfSBmcm9tICdAbWV0YW1hc2svc21hcnQtYWNjb3VudHMta2l0L2NvbnRyYWN0cyc7XG5pbXBvcnQgeyBidWlsZERlbGVnYXRpb25TZXR1cCB9IGZyb20gJy4uL2xpYi9zZXNzaW9uUGFja2FnZSc7XG5pbXBvcnQgeyBERUZBVUxUX0NIQUlOX0lELCBnZXRDaGFpbkJ1bmRsZXJVcmwsIGdldENoYWluQnlJZCB9IGZyb20gJy4uL2xpYi9jaGFpbkNvbmZpZyc7XG5pbXBvcnQgeyBzZW5kU3BvbnNvcmVkVXNlck9wZXJhdGlvbiwgd2FpdEZvclVzZXJPcGVyYXRpb25SZWNlaXB0IH0gZnJvbSAnLi4vLi4vY2xpZW50L2FjY291bnRDbGllbnQnO1xuY29uc3QgQVNTT0NJQVRJT05TX1NUT1JFX0FCSSA9IHBhcnNlQWJpKFtcbiAgICAnZnVuY3Rpb24gc3RvcmVBc3NvY2lhdGlvbigodWludDQwIHJldm9rZWRBdCxieXRlczIgaW5pdGlhdG9yS2V5VHlwZSxieXRlczIgYXBwcm92ZXJLZXlUeXBlLGJ5dGVzIGluaXRpYXRvclNpZ25hdHVyZSxieXRlcyBhcHByb3ZlclNpZ25hdHVyZSwoYnl0ZXMgaW5pdGlhdG9yLGJ5dGVzIGFwcHJvdmVyLHVpbnQ0MCB2YWxpZEF0LHVpbnQ0MCB2YWxpZFVudGlsLGJ5dGVzNCBpbnRlcmZhY2VJZCxieXRlcyBkYXRhKSByZWNvcmQpIHNhciknLFxuXSk7XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gYnVpbGREZWxlZ2F0ZWRBc3NvY2lhdGlvbkNvbnRleHQoc2Vzc2lvblBhY2thZ2UsIGNoYWluSWQgPSBERUZBVUxUX0NIQUlOX0lEKSB7XG4gICAgY29uc3QgZGVsZWdhdGlvblNldHVwID0gYnVpbGREZWxlZ2F0aW9uU2V0dXAoc2Vzc2lvblBhY2thZ2UpO1xuICAgIGNvbnN0IGJ1bmRsZXJVcmwgPSBnZXRDaGFpbkJ1bmRsZXJVcmwoY2hhaW5JZCk7XG4gICAgaWYgKCFidW5kbGVyVXJsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQnVuZGxlciBVUkwgbm90IGNvbmZpZ3VyZWQgZm9yIGNoYWluICR7Y2hhaW5JZH0uYCk7XG4gICAgfVxuICAgIGNvbnN0IGNoYWluID0gZ2V0Q2hhaW5CeUlkKGNoYWluSWQpO1xuICAgIGNvbnN0IHB1YmxpY0NsaWVudCA9IGNyZWF0ZVB1YmxpY0NsaWVudCh7XG4gICAgICAgIGNoYWluOiBkZWxlZ2F0aW9uU2V0dXAuY2hhaW4sXG4gICAgICAgIHRyYW5zcG9ydDogaHR0cChkZWxlZ2F0aW9uU2V0dXAucnBjVXJsKSxcbiAgICB9KTtcbiAgICBjb25zdCBhZ2VudE93bmVyRU9BID0gcHJpdmF0ZUtleVRvQWNjb3VudChkZWxlZ2F0aW9uU2V0dXAuc2Vzc2lvbktleS5wcml2YXRlS2V5KTtcbiAgICBjb25zdCB3YWxsZXRDbGllbnQgPSBjcmVhdGVXYWxsZXRDbGllbnQoe1xuICAgICAgICBhY2NvdW50OiBhZ2VudE93bmVyRU9BLFxuICAgICAgICBjaGFpbjogZGVsZWdhdGlvblNldHVwLmNoYWluLFxuICAgICAgICB0cmFuc3BvcnQ6IGh0dHAoZGVsZWdhdGlvblNldHVwLnJwY1VybCksXG4gICAgfSk7XG4gICAgaWYgKCFkZWxlZ2F0aW9uU2V0dXAuc2Vzc2lvbkFBKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignU2Vzc2lvblBhY2thZ2Uuc2Vzc2lvbkFBIGlzIHJlcXVpcmVkIHRvIHN1Ym1pdCBkZWxlZ2F0ZWQgc3RvcmVBc3NvY2lhdGlvbi4nKTtcbiAgICB9XG4gICAgY29uc3Qgc2Vzc2lvbkFjY291bnRDbGllbnQgPSBhd2FpdCB0b01ldGFNYXNrU21hcnRBY2NvdW50KHtcbiAgICAgICAgYWRkcmVzczogZGVsZWdhdGlvblNldHVwLnNlc3Npb25BQSxcbiAgICAgICAgY2xpZW50OiBwdWJsaWNDbGllbnQsXG4gICAgICAgIGltcGxlbWVudGF0aW9uOiBJbXBsZW1lbnRhdGlvbi5IeWJyaWQsXG4gICAgICAgIHNpZ25lcjogeyB3YWxsZXRDbGllbnQgfSxcbiAgICAgICAgZGVsZWdhdGlvbjoge1xuICAgICAgICAgICAgZGVsZWdhdGlvbjogZGVsZWdhdGlvblNldHVwLnNpZ25lZERlbGVnYXRpb24sXG4gICAgICAgICAgICBkZWxlZ2F0b3I6IGRlbGVnYXRpb25TZXR1cC5hYSxcbiAgICAgICAgfSxcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgICBzZXNzaW9uQWNjb3VudENsaWVudCxcbiAgICAgICAgd2FsbGV0Q2xpZW50LFxuICAgICAgICBwdWJsaWNDbGllbnQsXG4gICAgICAgIGRlbGVnYXRpb25TZXR1cCxcbiAgICAgICAgYnVuZGxlclVybCxcbiAgICAgICAgY2hhaW4sXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGdldEFzc29jaWF0aW9uc1Byb3h5QWRkcmVzcygpIHtcbiAgICBjb25zdCBhZGRyID0gcHJvY2Vzcy5lbnYuQVNTT0NJQVRJT05TX1NUT1JFX1BST1hZIHx8XG4gICAgICAgIHByb2Nlc3MuZW52LkFTU09DSUFUSU9OU19QUk9YWV9BRERSRVNTIHx8XG4gICAgICAgICcweGFGNzQyODkwNkQzMTkxOGREQTI5ODZEMTQwNUUyRGVkMDY1NjFFNTknO1xuICAgIGlmICghYWRkci5zdGFydHNXaXRoKCcweCcpIHx8IGFkZHIubGVuZ3RoICE9PSA0Mikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgYXNzb2NpYXRpb25zIHByb3h5IGFkZHJlc3M6ICR7YWRkcn1gKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGV0aGVycy5nZXRBZGRyZXNzKGFkZHIpO1xuICAgIH1cbiAgICBjYXRjaCB7XG4gICAgICAgIHJldHVybiBldGhlcnMuZ2V0QWRkcmVzcyhhZGRyLnRvTG93ZXJDYXNlKCkpO1xuICAgIH1cbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzdG9yZUVyYzgwOTJBc3NvY2lhdGlvbldpdGhTZXNzaW9uRGVsZWdhdGlvbihwYXJhbXMpIHtcbiAgICBjb25zdCBjaGFpbklkID0gcGFyYW1zLmNoYWluSWQgPz8gcGFyYW1zLnNlc3Npb25QYWNrYWdlLmNoYWluSWQgPz8gREVGQVVMVF9DSEFJTl9JRDtcbiAgICBjb25zdCB7IHNlc3Npb25BY2NvdW50Q2xpZW50LCBkZWxlZ2F0aW9uU2V0dXAsIGJ1bmRsZXJVcmwsIGNoYWluIH0gPSBhd2FpdCBidWlsZERlbGVnYXRlZEFzc29jaWF0aW9uQ29udGV4dChwYXJhbXMuc2Vzc2lvblBhY2thZ2UsIGNoYWluSWQpO1xuICAgIGNvbnN0IHByb3h5ID0gZ2V0QXNzb2NpYXRpb25zUHJveHlBZGRyZXNzKCk7XG4gICAgY29uc3QgZGF0YSA9IGVuY29kZUZ1bmN0aW9uRGF0YSh7XG4gICAgICAgIGFiaTogQVNTT0NJQVRJT05TX1NUT1JFX0FCSSxcbiAgICAgICAgZnVuY3Rpb25OYW1lOiAnc3RvcmVBc3NvY2lhdGlvbicsXG4gICAgICAgIGFyZ3M6IFtwYXJhbXMuc2FyXSxcbiAgICB9KTtcbiAgICBjb25zdCBpbmNsdWRlZEV4ZWN1dGlvbnMgPSBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRhcmdldDogcHJveHksXG4gICAgICAgICAgICB2YWx1ZTogMG4sXG4gICAgICAgICAgICBjYWxsRGF0YTogZGF0YSxcbiAgICAgICAgfSxcbiAgICBdO1xuICAgIGNvbnN0IHNpZ25lZERlbGVnYXRpb24gPSBkZWxlZ2F0aW9uU2V0dXAuc2lnbmVkRGVsZWdhdGlvbjtcbiAgICBjb25zdCBkZWxlZ2F0aW9uTWVzc2FnZSA9IHtcbiAgICAgICAgZGVsZWdhdGU6IGV0aGVycy5nZXRBZGRyZXNzKChzaWduZWREZWxlZ2F0aW9uLm1lc3NhZ2U/LmRlbGVnYXRlID8/IHNpZ25lZERlbGVnYXRpb24uZGVsZWdhdGUpKSxcbiAgICAgICAgZGVsZWdhdG9yOiBldGhlcnMuZ2V0QWRkcmVzcygoc2lnbmVkRGVsZWdhdGlvbi5tZXNzYWdlPy5kZWxlZ2F0b3IgPz8gc2lnbmVkRGVsZWdhdGlvbi5kZWxlZ2F0b3IpKSxcbiAgICAgICAgYXV0aG9yaXR5OiAoc2lnbmVkRGVsZWdhdGlvbi5tZXNzYWdlPy5hdXRob3JpdHkgPz8gc2lnbmVkRGVsZWdhdGlvbi5hdXRob3JpdHkpLFxuICAgICAgICBjYXZlYXRzOiAoc2lnbmVkRGVsZWdhdGlvbi5tZXNzYWdlPy5jYXZlYXRzID8/IHNpZ25lZERlbGVnYXRpb24uY2F2ZWF0cyksXG4gICAgICAgIHNhbHQ6IChzaWduZWREZWxlZ2F0aW9uLm1lc3NhZ2U/LnNhbHQgPz8gc2lnbmVkRGVsZWdhdGlvbi5zYWx0KSxcbiAgICAgICAgc2lnbmF0dXJlOiAoc2lnbmVkRGVsZWdhdGlvbi5zaWduYXR1cmUgPz8gc2lnbmVkRGVsZWdhdGlvbi5tZXNzYWdlPy5zaWduYXR1cmUpLFxuICAgIH07XG4gICAgY29uc3QgcmVkZW1wdGlvbkRhdGEgPSBEZWxlZ2F0aW9uTWFuYWdlci5lbmNvZGUucmVkZWVtRGVsZWdhdGlvbnMoe1xuICAgICAgICBkZWxlZ2F0aW9uczogW1tkZWxlZ2F0aW9uTWVzc2FnZV1dLFxuICAgICAgICBtb2RlczogW0V4ZWN1dGlvbk1vZGUuU2luZ2xlRGVmYXVsdF0sXG4gICAgICAgIGV4ZWN1dGlvbnM6IFtpbmNsdWRlZEV4ZWN1dGlvbnNdLFxuICAgIH0pO1xuICAgIGNvbnN0IHJlZGVtcHRpb25DYWxsID0ge1xuICAgICAgICB0bzogZGVsZWdhdGlvblNldHVwLnNlc3Npb25BQSxcbiAgICAgICAgZGF0YTogcmVkZW1wdGlvbkRhdGEsXG4gICAgICAgIHZhbHVlOiAwbixcbiAgICB9O1xuICAgIGNvbnN0IHVzZXJPcEhhc2ggPSBhd2FpdCBzZW5kU3BvbnNvcmVkVXNlck9wZXJhdGlvbih7XG4gICAgICAgIGJ1bmRsZXJVcmwsXG4gICAgICAgIGNoYWluLFxuICAgICAgICBhY2NvdW50Q2xpZW50OiBzZXNzaW9uQWNjb3VudENsaWVudCxcbiAgICAgICAgY2FsbHM6IFtyZWRlbXB0aW9uQ2FsbF0sXG4gICAgfSk7XG4gICAgY29uc3QgcmVjZWlwdCA9IGF3YWl0IHdhaXRGb3JVc2VyT3BlcmF0aW9uUmVjZWlwdCh7XG4gICAgICAgIGJ1bmRsZXJVcmwsXG4gICAgICAgIGNoYWluLFxuICAgICAgICBoYXNoOiB1c2VyT3BIYXNoLFxuICAgIH0pO1xuICAgIGNvbnN0IHR4SGFzaCA9IHJlY2VpcHQ/LnRyYW5zYWN0aW9uSGFzaCB8fCByZWNlaXB0Py5yZWNlaXB0Py50cmFuc2FjdGlvbkhhc2ggfHwgdXNlck9wSGFzaDtcbiAgICByZXR1cm4geyB0eEhhc2ggfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlbGVnYXRlZEFzc29jaWF0aW9uLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@agentic-trust/core/dist/server/services/delegatedAssociation.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@agentic-trust/core/dist/server/services/delegatedValidation.js":
/*!******************************************************************************************!*\
  !*** ../../node_modules/@agentic-trust/core/dist/server/services/delegatedValidation.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   buildDelegatedValidationContext: () => (/* binding */ buildDelegatedValidationContext),\n/* harmony export */   processValidationRequestsWithSessionPackage: () => (/* binding */ processValidationRequestsWithSessionPackage)\n/* harmony export */ });\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! viem */ \"(rsc)/../../node_modules/viem/_esm/clients/createPublicClient.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! viem */ \"(rsc)/../../node_modules/viem/_esm/clients/transports/http.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! viem */ \"(rsc)/../../node_modules/viem/_esm/clients/createWalletClient.js\");\n/* harmony import */ var viem_accounts__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! viem/accounts */ \"(rsc)/../../node_modules/viem/_esm/accounts/privateKeyToAccount.js\");\n/* harmony import */ var _metamask_smart_accounts_kit__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @metamask/smart-accounts-kit */ \"(rsc)/../../node_modules/@metamask/smart-accounts-kit/dist/index.mjs\");\n/* harmony import */ var _metamask_smart_accounts_kit__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @metamask/smart-accounts-kit */ \"(rsc)/../../node_modules/@metamask/smart-accounts-kit/dist/chunk-7MRTROLV.mjs\");\n/* harmony import */ var _metamask_smart_accounts_kit__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @metamask/smart-accounts-kit */ \"(rsc)/../../node_modules/@metamask/smart-accounts-kit/dist/chunk-CPLIK3VF.mjs\");\n/* harmony import */ var _metamask_smart_accounts_kit_contracts__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @metamask/smart-accounts-kit/contracts */ \"(rsc)/../../node_modules/@metamask/smart-accounts-kit/dist/chunk-6RN5RBOR.mjs\");\n/* harmony import */ var _lib_sessionPackage__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/sessionPackage */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/lib/sessionPackage.js\");\n/* harmony import */ var _lib_chainConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/chainConfig */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/lib/chainConfig.js\");\n/* harmony import */ var _lib_agenticTrust__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/agenticTrust */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/lib/agenticTrust.js\");\n/* harmony import */ var _singletons_validationClient__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../singletons/validationClient */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/singletons/validationClient.js\");\n/* harmony import */ var _client_accountClient__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../client/accountClient */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/client/accountClient.js\");\n\n\n\n// @ts-ignore contracts path\n\n\n\n\n\n\nconst ZERO_ADDRESS = '0x0000000000000000000000000000000000000000';\nasync function buildDelegatedValidationContext(sessionPackage, chainId = _lib_chainConfig__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_CHAIN_ID) {\n    const delegationSetup = (0,_lib_sessionPackage__WEBPACK_IMPORTED_MODULE_0__.buildDelegationSetup)(sessionPackage);\n    const bundlerUrl = (0,_lib_chainConfig__WEBPACK_IMPORTED_MODULE_1__.getChainBundlerUrl)(chainId);\n    if (!bundlerUrl) {\n        throw new Error(`Bundler URL not configured for chain ${chainId}.`);\n    }\n    const chain = (0,_lib_chainConfig__WEBPACK_IMPORTED_MODULE_1__.getChainById)(chainId);\n    const publicClient = (0,viem__WEBPACK_IMPORTED_MODULE_5__.createPublicClient)({\n        chain: delegationSetup.chain,\n        transport: (0,viem__WEBPACK_IMPORTED_MODULE_6__.http)(delegationSetup.rpcUrl),\n    });\n    const agentOwnerEOA = (0,viem_accounts__WEBPACK_IMPORTED_MODULE_7__.privateKeyToAccount)(delegationSetup.sessionKey.privateKey);\n    const walletClient = (0,viem__WEBPACK_IMPORTED_MODULE_8__.createWalletClient)({\n        account: agentOwnerEOA,\n        chain: delegationSetup.chain,\n        transport: (0,viem__WEBPACK_IMPORTED_MODULE_6__.http)(delegationSetup.rpcUrl),\n    });\n    const sessionAccountClient = await (0,_metamask_smart_accounts_kit__WEBPACK_IMPORTED_MODULE_9__.toMetaMaskSmartAccount)({\n        address: delegationSetup.sessionAA,\n        client: publicClient,\n        implementation: _metamask_smart_accounts_kit__WEBPACK_IMPORTED_MODULE_10__.Implementation.Hybrid,\n        signer: {\n            walletClient,\n        },\n        delegation: {\n            delegation: delegationSetup.signedDelegation,\n            delegator: delegationSetup.aa,\n        },\n    });\n    return {\n        sessionAccountClient,\n        walletClient,\n        publicClient,\n        delegationSetup,\n        validatorAddress: delegationSetup.aa,\n        bundlerUrl,\n        chain,\n    };\n}\nasync function processValidationRequestsWithSessionPackage(params) {\n    const { sessionPackage, chainId = _lib_chainConfig__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_CHAIN_ID, agentIdFilter, requestHashFilter, responseScore = 100, responseUri, responseTag = 'agent-validation', validatorValidated, } = params;\n    const results = [];\n    const context = await buildDelegatedValidationContext(sessionPackage, chainId);\n    const { sessionAccountClient, delegationSetup, validatorAddress, bundlerUrl, chain } = context;\n    const validationRegistryClient = await (0,_singletons_validationClient__WEBPACK_IMPORTED_MODULE_3__.getValidationRegistryClient)(chainId);\n    let requestHashes = [];\n    // If requestHashFilter is provided, use it directly instead of querying all validator requests\n    // This is more efficient and avoids missing requests that might not be in the list\n    if (requestHashFilter) {\n        console.log('[delegatedValidation] Using provided requestHashFilter:', requestHashFilter);\n        requestHashes = [requestHashFilter];\n    }\n    else {\n        console.log('[delegatedValidation] Querying all validator requests for:', delegationSetup.aa);\n        requestHashes = await validationRegistryClient.getValidatorRequests(delegationSetup.aa);\n        console.log('[delegatedValidation] Found validator requests:', requestHashes.length, requestHashes);\n    }\n    const client = await (0,_lib_agenticTrust__WEBPACK_IMPORTED_MODULE_2__.getAgenticTrustClient)();\n    console.log('[delegatedValidation] =========================================');\n    console.log('[delegatedValidation] Processing validation requests');\n    console.log('[delegatedValidation] =========================================');\n    console.log('[delegatedValidation] Input parameters:', {\n        requestHashesCount: requestHashes.length,\n        requestHashes,\n        validatorAddress: `${validatorAddress} (from SessionPackage - this is the validator)`,\n        agentIdFilter: agentIdFilter ? `${agentIdFilter} (agent being validated, not used for filtering)` : 'none',\n        requestHashFilter,\n        responseScore,\n        responseTag,\n        chainId,\n    });\n    for (const requestHash of requestHashes) {\n        let currentAgentId = 'unknown';\n        try {\n            console.log('[delegatedValidation] ---');\n            console.log('[delegatedValidation] Checking requestHash:', requestHash);\n            const status = await validationRegistryClient.getValidationStatus(requestHash);\n            console.log('[delegatedValidation] Validation status from chain:', {\n                requestHash,\n                response: status.response,\n                validatorAddress: `${status.validatorAddress} (validator expected by this request)`,\n                agentId: `${status.agentId?.toString()} (agent being validated)`,\n            });\n            console.log('[delegatedValidation] Validator address check:', {\n                requestHashExpectedValidatorAddress: status.validatorAddress.toLowerCase(),\n                sessionPackageValidatorAddress: validatorAddress.toLowerCase(),\n                match: status.validatorAddress.toLowerCase() === validatorAddress.toLowerCase(),\n            });\n            if (status.response !== 0) {\n                console.log('[delegatedValidation]  Skipping: validation already responded (response =', status.response, '!= 0)');\n                continue;\n            }\n            if (status.validatorAddress.toLowerCase() !== validatorAddress.toLowerCase()) {\n                console.log('[delegatedValidation]  Skipping: VALIDATOR ADDRESS MISMATCH');\n                console.log('[delegatedValidation]   The validation request expects validator:', status.validatorAddress);\n                console.log('[delegatedValidation]   But SessionPackage validator address is:', validatorAddress);\n                console.log('[delegatedValidation]   This validation request cannot be processed by this validator.');\n                continue;\n            }\n            console.log('[delegatedValidation]  Validator address matches');\n            // Check if validator is defined (not zero address)\n            const hasValidator = status.validatorAddress.toLowerCase() !== ZERO_ADDRESS.toLowerCase();\n            if (hasValidator) {\n                console.log('[delegatedValidation] Validator is defined for this request, checking if validator has returned \"validated\"');\n                // Check if validator has explicitly validated\n                // The validatorValidated parameter comes from the validator class (e.g., ens-validator)\n                // It must be true for the on-chain response to be created\n                if (validatorValidated !== true) {\n                    console.log('[delegatedValidation]  Skipping: Validator has not returned \"validated: true\"');\n                    console.log('[delegatedValidation]   Validator must explicitly return \"validated: true\" before on-chain response can be created');\n                    console.log('[delegatedValidation]   Current validatorValidated value:', validatorValidated);\n                    results.push({\n                        requestHash,\n                        agentId: status.agentId?.toString() || 'unknown',\n                        chainId,\n                        success: false,\n                        error: 'Validator must return \"validated: true\" before validation response can be created on-chain',\n                    });\n                    continue;\n                }\n                console.log('[delegatedValidation]  Validator has returned \"validated: true\" - proceeding with validation response');\n            }\n            else {\n                console.log('[delegatedValidation] No validator defined for this request - proceeding with validation response');\n            }\n            const agentId = status.agentId.toString();\n            currentAgentId = agentId;\n            console.log('[delegatedValidation] Agent being validated:', agentId);\n            console.log('[delegatedValidation] Note: agentIdFilter parameter (', agentIdFilter, ') is not used for filtering');\n            console.log('[delegatedValidation] The validator is identified by validatorAddress from SessionPackage, not by agentIdFilter');\n            const agent = await client.agents.getAgent(agentId, chainId);\n            if (!agent?.agentName || !agent.agentAccount) {\n                console.log('[delegatedValidation] Agent missing name or account:', { agentId, agentName: agent?.agentName, agentAccount: agent?.agentAccount });\n                results.push({\n                    requestHash,\n                    agentId,\n                    chainId,\n                    success: false,\n                    error: `Agent ${agentId} is missing name or account`,\n                });\n                continue;\n            }\n            console.log('[delegatedValidation]  All checks passed - preparing validation response transaction');\n            console.log('[delegatedValidation] Transaction parameters:', {\n                requestHash,\n                responseScore,\n                responseUri: responseUri || '(none)',\n                responseTag,\n            });\n            const txRequest = await validationRegistryClient.prepareValidationResponseTx({\n                requestHash,\n                response: responseScore,\n                responseUri: responseUri || undefined,\n                tag: responseTag,\n            });\n            const signedDelegation = delegationSetup.signedDelegation;\n            const delegationMessage = {\n                delegate: signedDelegation.delegate,\n                delegator: signedDelegation.delegator,\n                authority: signedDelegation.authority,\n                caveats: signedDelegation.caveats,\n                salt: signedDelegation.salt,\n                signature: signedDelegation.signature,\n            };\n            const includedExecutions = [\n                {\n                    target: txRequest.to,\n                    value: BigInt(txRequest.value || '0'),\n                    callData: txRequest.data,\n                },\n            ];\n            const redemptionData = _metamask_smart_accounts_kit_contracts__WEBPACK_IMPORTED_MODULE_11__.DelegationManager_exports.encode.redeemDelegations({\n                delegations: [[delegationMessage]],\n                modes: [_metamask_smart_accounts_kit__WEBPACK_IMPORTED_MODULE_12__.ExecutionMode.SingleDefault],\n                executions: [includedExecutions],\n            });\n            const redemptionCall = {\n                to: delegationSetup.sessionAA,\n                data: redemptionData,\n                value: 0n,\n            };\n            const userOpHash = await (0,_client_accountClient__WEBPACK_IMPORTED_MODULE_4__.sendSponsoredUserOperation)({\n                bundlerUrl,\n                chain,\n                accountClient: sessionAccountClient,\n                calls: [redemptionCall],\n            });\n            const receipt = await (0,_client_accountClient__WEBPACK_IMPORTED_MODULE_4__.waitForUserOperationReceipt)({\n                bundlerUrl,\n                chain,\n                hash: userOpHash,\n            });\n            const txHash = receipt?.transactionHash || receipt?.receipt?.transactionHash || userOpHash;\n            console.log('[delegatedValidation] Validation response transaction successful:', {\n                requestHash,\n                agentId,\n                txHash,\n            });\n            results.push({\n                requestHash,\n                agentId,\n                chainId,\n                success: true,\n                txHash,\n            });\n        }\n        catch (error) {\n            console.error('[delegatedValidation] Error processing validation request:', {\n                requestHash,\n                agentId: currentAgentId,\n                error: error instanceof Error ? error.message : 'Unknown error',\n                errorStack: error instanceof Error ? error.stack : undefined,\n            });\n            results.push({\n                requestHash,\n                agentId: currentAgentId,\n                chainId,\n                success: false,\n                error: error instanceof Error ? error.message : 'Unknown error',\n            });\n        }\n    }\n    console.log('[delegatedValidation] =========================================');\n    console.log('[delegatedValidation] Final results summary');\n    console.log('[delegatedValidation] =========================================');\n    console.log('[delegatedValidation] Results count:', results.length);\n    if (results.length === 0) {\n        console.log('[delegatedValidation]   No results - validation request was not processed');\n        console.log('[delegatedValidation] This could be due to:');\n        console.log('[delegatedValidation]   - Validator address mismatch (request expects different validator)');\n        console.log('[delegatedValidation]   - Validation already responded');\n        console.log('[delegatedValidation]   - Error during processing');\n    }\n    else {\n        results.forEach((r, idx) => {\n            console.log(`[delegatedValidation] Result ${idx + 1}:`, {\n                requestHash: r.requestHash,\n                agentId: r.agentId,\n                success: r.success ? ' SUCCESS' : ' FAILED',\n                error: r.error || '(none)',\n                txHash: r.txHash || '(none)',\n            });\n        });\n    }\n    console.log('[delegatedValidation] =========================================');\n    return results;\n}\n//# sourceMappingURL=delegatedValidation.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BhZ2VudGljLXRydXN0L2NvcmUvZGlzdC9zZXJ2ZXIvc2VydmljZXMvZGVsZWdhdGVkVmFsaWRhdGlvbi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBb0U7QUFDaEI7QUFDa0Q7QUFDdEc7QUFDMkU7QUFDYjtBQUMyQjtBQUM3QjtBQUNpQjtBQUN5QjtBQUN0RztBQUNPLHlFQUF5RSw4REFBZ0I7QUFDaEcsNEJBQTRCLHlFQUFvQjtBQUNoRCx1QkFBdUIsb0VBQWtCO0FBQ3pDO0FBQ0EsZ0VBQWdFLFFBQVE7QUFDeEU7QUFDQSxrQkFBa0IsOERBQVk7QUFDOUIseUJBQXlCLHdEQUFrQjtBQUMzQztBQUNBLG1CQUFtQiwwQ0FBSTtBQUN2QixLQUFLO0FBQ0wsMEJBQTBCLGtFQUFtQjtBQUM3Qyx5QkFBeUIsd0RBQWtCO0FBQzNDO0FBQ0E7QUFDQSxtQkFBbUIsMENBQUk7QUFDdkIsS0FBSztBQUNMLHVDQUF1QyxvRkFBc0I7QUFDN0Q7QUFDQTtBQUNBLHdCQUF3Qix5RUFBYztBQUN0QztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLFlBQVksMEJBQTBCLDhEQUFnQiw4SEFBOEg7QUFDcEw7QUFDQTtBQUNBLFlBQVksNkVBQTZFO0FBQ3pGLDJDQUEyQyx5RkFBMkI7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHdFQUFxQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsa0JBQWtCO0FBQy9DLDBDQUEwQyxlQUFlO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyx5QkFBeUI7QUFDOUQsNEJBQTRCLDRCQUE0QjtBQUN4RCxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0ZBQXNGLHlFQUF5RTtBQUMvSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFNBQVM7QUFDN0MsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsbUNBQW1DLDhGQUFpQjtBQUNwRDtBQUNBLHdCQUF3Qix3RUFBYTtBQUNyQztBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLGlGQUEwQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixrQ0FBa0Msa0ZBQTJCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELFFBQVE7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvYmFyYi9hYS9Bc3NvY2lhdGVkQWNjb3VudHMvbm9kZV9tb2R1bGVzL0BhZ2VudGljLXRydXN0L2NvcmUvZGlzdC9zZXJ2ZXIvc2VydmljZXMvZGVsZWdhdGVkVmFsaWRhdGlvbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjcmVhdGVQdWJsaWNDbGllbnQsIGNyZWF0ZVdhbGxldENsaWVudCwgaHR0cCB9IGZyb20gJ3ZpZW0nO1xuaW1wb3J0IHsgcHJpdmF0ZUtleVRvQWNjb3VudCB9IGZyb20gJ3ZpZW0vYWNjb3VudHMnO1xuaW1wb3J0IHsgSW1wbGVtZW50YXRpb24sIHRvTWV0YU1hc2tTbWFydEFjY291bnQsIEV4ZWN1dGlvbk1vZGUsIH0gZnJvbSAnQG1ldGFtYXNrL3NtYXJ0LWFjY291bnRzLWtpdCc7XG4vLyBAdHMtaWdub3JlIGNvbnRyYWN0cyBwYXRoXG5pbXBvcnQgeyBEZWxlZ2F0aW9uTWFuYWdlciB9IGZyb20gJ0BtZXRhbWFzay9zbWFydC1hY2NvdW50cy1raXQvY29udHJhY3RzJztcbmltcG9ydCB7IGJ1aWxkRGVsZWdhdGlvblNldHVwLCB9IGZyb20gJy4uL2xpYi9zZXNzaW9uUGFja2FnZSc7XG5pbXBvcnQgeyBERUZBVUxUX0NIQUlOX0lELCBnZXRDaGFpbkJ1bmRsZXJVcmwsIGdldENoYWluQnlJZCwgfSBmcm9tICcuLi9saWIvY2hhaW5Db25maWcnO1xuaW1wb3J0IHsgZ2V0QWdlbnRpY1RydXN0Q2xpZW50IH0gZnJvbSAnLi4vbGliL2FnZW50aWNUcnVzdCc7XG5pbXBvcnQgeyBnZXRWYWxpZGF0aW9uUmVnaXN0cnlDbGllbnQgfSBmcm9tICcuLi9zaW5nbGV0b25zL3ZhbGlkYXRpb25DbGllbnQnO1xuaW1wb3J0IHsgc2VuZFNwb25zb3JlZFVzZXJPcGVyYXRpb24sIHdhaXRGb3JVc2VyT3BlcmF0aW9uUmVjZWlwdCwgfSBmcm9tICcuLi8uLi9jbGllbnQvYWNjb3VudENsaWVudCc7XG5jb25zdCBaRVJPX0FERFJFU1MgPSAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJztcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBidWlsZERlbGVnYXRlZFZhbGlkYXRpb25Db250ZXh0KHNlc3Npb25QYWNrYWdlLCBjaGFpbklkID0gREVGQVVMVF9DSEFJTl9JRCkge1xuICAgIGNvbnN0IGRlbGVnYXRpb25TZXR1cCA9IGJ1aWxkRGVsZWdhdGlvblNldHVwKHNlc3Npb25QYWNrYWdlKTtcbiAgICBjb25zdCBidW5kbGVyVXJsID0gZ2V0Q2hhaW5CdW5kbGVyVXJsKGNoYWluSWQpO1xuICAgIGlmICghYnVuZGxlclVybCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEJ1bmRsZXIgVVJMIG5vdCBjb25maWd1cmVkIGZvciBjaGFpbiAke2NoYWluSWR9LmApO1xuICAgIH1cbiAgICBjb25zdCBjaGFpbiA9IGdldENoYWluQnlJZChjaGFpbklkKTtcbiAgICBjb25zdCBwdWJsaWNDbGllbnQgPSBjcmVhdGVQdWJsaWNDbGllbnQoe1xuICAgICAgICBjaGFpbjogZGVsZWdhdGlvblNldHVwLmNoYWluLFxuICAgICAgICB0cmFuc3BvcnQ6IGh0dHAoZGVsZWdhdGlvblNldHVwLnJwY1VybCksXG4gICAgfSk7XG4gICAgY29uc3QgYWdlbnRPd25lckVPQSA9IHByaXZhdGVLZXlUb0FjY291bnQoZGVsZWdhdGlvblNldHVwLnNlc3Npb25LZXkucHJpdmF0ZUtleSk7XG4gICAgY29uc3Qgd2FsbGV0Q2xpZW50ID0gY3JlYXRlV2FsbGV0Q2xpZW50KHtcbiAgICAgICAgYWNjb3VudDogYWdlbnRPd25lckVPQSxcbiAgICAgICAgY2hhaW46IGRlbGVnYXRpb25TZXR1cC5jaGFpbixcbiAgICAgICAgdHJhbnNwb3J0OiBodHRwKGRlbGVnYXRpb25TZXR1cC5ycGNVcmwpLFxuICAgIH0pO1xuICAgIGNvbnN0IHNlc3Npb25BY2NvdW50Q2xpZW50ID0gYXdhaXQgdG9NZXRhTWFza1NtYXJ0QWNjb3VudCh7XG4gICAgICAgIGFkZHJlc3M6IGRlbGVnYXRpb25TZXR1cC5zZXNzaW9uQUEsXG4gICAgICAgIGNsaWVudDogcHVibGljQ2xpZW50LFxuICAgICAgICBpbXBsZW1lbnRhdGlvbjogSW1wbGVtZW50YXRpb24uSHlicmlkLFxuICAgICAgICBzaWduZXI6IHtcbiAgICAgICAgICAgIHdhbGxldENsaWVudCxcbiAgICAgICAgfSxcbiAgICAgICAgZGVsZWdhdGlvbjoge1xuICAgICAgICAgICAgZGVsZWdhdGlvbjogZGVsZWdhdGlvblNldHVwLnNpZ25lZERlbGVnYXRpb24sXG4gICAgICAgICAgICBkZWxlZ2F0b3I6IGRlbGVnYXRpb25TZXR1cC5hYSxcbiAgICAgICAgfSxcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgICBzZXNzaW9uQWNjb3VudENsaWVudCxcbiAgICAgICAgd2FsbGV0Q2xpZW50LFxuICAgICAgICBwdWJsaWNDbGllbnQsXG4gICAgICAgIGRlbGVnYXRpb25TZXR1cCxcbiAgICAgICAgdmFsaWRhdG9yQWRkcmVzczogZGVsZWdhdGlvblNldHVwLmFhLFxuICAgICAgICBidW5kbGVyVXJsLFxuICAgICAgICBjaGFpbixcbiAgICB9O1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHByb2Nlc3NWYWxpZGF0aW9uUmVxdWVzdHNXaXRoU2Vzc2lvblBhY2thZ2UocGFyYW1zKSB7XG4gICAgY29uc3QgeyBzZXNzaW9uUGFja2FnZSwgY2hhaW5JZCA9IERFRkFVTFRfQ0hBSU5fSUQsIGFnZW50SWRGaWx0ZXIsIHJlcXVlc3RIYXNoRmlsdGVyLCByZXNwb25zZVNjb3JlID0gMTAwLCByZXNwb25zZVVyaSwgcmVzcG9uc2VUYWcgPSAnYWdlbnQtdmFsaWRhdGlvbicsIHZhbGlkYXRvclZhbGlkYXRlZCwgfSA9IHBhcmFtcztcbiAgICBjb25zdCByZXN1bHRzID0gW107XG4gICAgY29uc3QgY29udGV4dCA9IGF3YWl0IGJ1aWxkRGVsZWdhdGVkVmFsaWRhdGlvbkNvbnRleHQoc2Vzc2lvblBhY2thZ2UsIGNoYWluSWQpO1xuICAgIGNvbnN0IHsgc2Vzc2lvbkFjY291bnRDbGllbnQsIGRlbGVnYXRpb25TZXR1cCwgdmFsaWRhdG9yQWRkcmVzcywgYnVuZGxlclVybCwgY2hhaW4gfSA9IGNvbnRleHQ7XG4gICAgY29uc3QgdmFsaWRhdGlvblJlZ2lzdHJ5Q2xpZW50ID0gYXdhaXQgZ2V0VmFsaWRhdGlvblJlZ2lzdHJ5Q2xpZW50KGNoYWluSWQpO1xuICAgIGxldCByZXF1ZXN0SGFzaGVzID0gW107XG4gICAgLy8gSWYgcmVxdWVzdEhhc2hGaWx0ZXIgaXMgcHJvdmlkZWQsIHVzZSBpdCBkaXJlY3RseSBpbnN0ZWFkIG9mIHF1ZXJ5aW5nIGFsbCB2YWxpZGF0b3IgcmVxdWVzdHNcbiAgICAvLyBUaGlzIGlzIG1vcmUgZWZmaWNpZW50IGFuZCBhdm9pZHMgbWlzc2luZyByZXF1ZXN0cyB0aGF0IG1pZ2h0IG5vdCBiZSBpbiB0aGUgbGlzdFxuICAgIGlmIChyZXF1ZXN0SGFzaEZpbHRlcikge1xuICAgICAgICBjb25zb2xlLmxvZygnW2RlbGVnYXRlZFZhbGlkYXRpb25dIFVzaW5nIHByb3ZpZGVkIHJlcXVlc3RIYXNoRmlsdGVyOicsIHJlcXVlc3RIYXNoRmlsdGVyKTtcbiAgICAgICAgcmVxdWVzdEhhc2hlcyA9IFtyZXF1ZXN0SGFzaEZpbHRlcl07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zb2xlLmxvZygnW2RlbGVnYXRlZFZhbGlkYXRpb25dIFF1ZXJ5aW5nIGFsbCB2YWxpZGF0b3IgcmVxdWVzdHMgZm9yOicsIGRlbGVnYXRpb25TZXR1cC5hYSk7XG4gICAgICAgIHJlcXVlc3RIYXNoZXMgPSBhd2FpdCB2YWxpZGF0aW9uUmVnaXN0cnlDbGllbnQuZ2V0VmFsaWRhdG9yUmVxdWVzdHMoZGVsZWdhdGlvblNldHVwLmFhKTtcbiAgICAgICAgY29uc29sZS5sb2coJ1tkZWxlZ2F0ZWRWYWxpZGF0aW9uXSBGb3VuZCB2YWxpZGF0b3IgcmVxdWVzdHM6JywgcmVxdWVzdEhhc2hlcy5sZW5ndGgsIHJlcXVlc3RIYXNoZXMpO1xuICAgIH1cbiAgICBjb25zdCBjbGllbnQgPSBhd2FpdCBnZXRBZ2VudGljVHJ1c3RDbGllbnQoKTtcbiAgICBjb25zb2xlLmxvZygnW2RlbGVnYXRlZFZhbGlkYXRpb25dID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Jyk7XG4gICAgY29uc29sZS5sb2coJ1tkZWxlZ2F0ZWRWYWxpZGF0aW9uXSBQcm9jZXNzaW5nIHZhbGlkYXRpb24gcmVxdWVzdHMnKTtcbiAgICBjb25zb2xlLmxvZygnW2RlbGVnYXRlZFZhbGlkYXRpb25dID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Jyk7XG4gICAgY29uc29sZS5sb2coJ1tkZWxlZ2F0ZWRWYWxpZGF0aW9uXSBJbnB1dCBwYXJhbWV0ZXJzOicsIHtcbiAgICAgICAgcmVxdWVzdEhhc2hlc0NvdW50OiByZXF1ZXN0SGFzaGVzLmxlbmd0aCxcbiAgICAgICAgcmVxdWVzdEhhc2hlcyxcbiAgICAgICAgdmFsaWRhdG9yQWRkcmVzczogYCR7dmFsaWRhdG9yQWRkcmVzc30gKGZyb20gU2Vzc2lvblBhY2thZ2UgLSB0aGlzIGlzIHRoZSB2YWxpZGF0b3IpYCxcbiAgICAgICAgYWdlbnRJZEZpbHRlcjogYWdlbnRJZEZpbHRlciA/IGAke2FnZW50SWRGaWx0ZXJ9IChhZ2VudCBiZWluZyB2YWxpZGF0ZWQsIG5vdCB1c2VkIGZvciBmaWx0ZXJpbmcpYCA6ICdub25lJyxcbiAgICAgICAgcmVxdWVzdEhhc2hGaWx0ZXIsXG4gICAgICAgIHJlc3BvbnNlU2NvcmUsXG4gICAgICAgIHJlc3BvbnNlVGFnLFxuICAgICAgICBjaGFpbklkLFxuICAgIH0pO1xuICAgIGZvciAoY29uc3QgcmVxdWVzdEhhc2ggb2YgcmVxdWVzdEhhc2hlcykge1xuICAgICAgICBsZXQgY3VycmVudEFnZW50SWQgPSAndW5rbm93bic7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnW2RlbGVnYXRlZFZhbGlkYXRpb25dIC0tLScpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ1tkZWxlZ2F0ZWRWYWxpZGF0aW9uXSBDaGVja2luZyByZXF1ZXN0SGFzaDonLCByZXF1ZXN0SGFzaCk7XG4gICAgICAgICAgICBjb25zdCBzdGF0dXMgPSBhd2FpdCB2YWxpZGF0aW9uUmVnaXN0cnlDbGllbnQuZ2V0VmFsaWRhdGlvblN0YXR1cyhyZXF1ZXN0SGFzaCk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnW2RlbGVnYXRlZFZhbGlkYXRpb25dIFZhbGlkYXRpb24gc3RhdHVzIGZyb20gY2hhaW46Jywge1xuICAgICAgICAgICAgICAgIHJlcXVlc3RIYXNoLFxuICAgICAgICAgICAgICAgIHJlc3BvbnNlOiBzdGF0dXMucmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgdmFsaWRhdG9yQWRkcmVzczogYCR7c3RhdHVzLnZhbGlkYXRvckFkZHJlc3N9ICh2YWxpZGF0b3IgZXhwZWN0ZWQgYnkgdGhpcyByZXF1ZXN0KWAsXG4gICAgICAgICAgICAgICAgYWdlbnRJZDogYCR7c3RhdHVzLmFnZW50SWQ/LnRvU3RyaW5nKCl9IChhZ2VudCBiZWluZyB2YWxpZGF0ZWQpYCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ1tkZWxlZ2F0ZWRWYWxpZGF0aW9uXSBWYWxpZGF0b3IgYWRkcmVzcyBjaGVjazonLCB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdEhhc2hFeHBlY3RlZFZhbGlkYXRvckFkZHJlc3M6IHN0YXR1cy52YWxpZGF0b3JBZGRyZXNzLnRvTG93ZXJDYXNlKCksXG4gICAgICAgICAgICAgICAgc2Vzc2lvblBhY2thZ2VWYWxpZGF0b3JBZGRyZXNzOiB2YWxpZGF0b3JBZGRyZXNzLnRvTG93ZXJDYXNlKCksXG4gICAgICAgICAgICAgICAgbWF0Y2g6IHN0YXR1cy52YWxpZGF0b3JBZGRyZXNzLnRvTG93ZXJDYXNlKCkgPT09IHZhbGlkYXRvckFkZHJlc3MudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHN0YXR1cy5yZXNwb25zZSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdbZGVsZWdhdGVkVmFsaWRhdGlvbl0g4p2MIFNraXBwaW5nOiB2YWxpZGF0aW9uIGFscmVhZHkgcmVzcG9uZGVkIChyZXNwb25zZSA9Jywgc3RhdHVzLnJlc3BvbnNlLCAnIT0gMCknKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdGF0dXMudmFsaWRhdG9yQWRkcmVzcy50b0xvd2VyQ2FzZSgpICE9PSB2YWxpZGF0b3JBZGRyZXNzLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnW2RlbGVnYXRlZFZhbGlkYXRpb25dIOKdjCBTa2lwcGluZzogVkFMSURBVE9SIEFERFJFU1MgTUlTTUFUQ0gnKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnW2RlbGVnYXRlZFZhbGlkYXRpb25dICAgVGhlIHZhbGlkYXRpb24gcmVxdWVzdCBleHBlY3RzIHZhbGlkYXRvcjonLCBzdGF0dXMudmFsaWRhdG9yQWRkcmVzcyk7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1tkZWxlZ2F0ZWRWYWxpZGF0aW9uXSAgIEJ1dCBTZXNzaW9uUGFja2FnZSB2YWxpZGF0b3IgYWRkcmVzcyBpczonLCB2YWxpZGF0b3JBZGRyZXNzKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnW2RlbGVnYXRlZFZhbGlkYXRpb25dICAgVGhpcyB2YWxpZGF0aW9uIHJlcXVlc3QgY2Fubm90IGJlIHByb2Nlc3NlZCBieSB0aGlzIHZhbGlkYXRvci4nKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdbZGVsZWdhdGVkVmFsaWRhdGlvbl0g4pyFIFZhbGlkYXRvciBhZGRyZXNzIG1hdGNoZXMnKTtcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHZhbGlkYXRvciBpcyBkZWZpbmVkIChub3QgemVybyBhZGRyZXNzKVxuICAgICAgICAgICAgY29uc3QgaGFzVmFsaWRhdG9yID0gc3RhdHVzLnZhbGlkYXRvckFkZHJlc3MudG9Mb3dlckNhc2UoKSAhPT0gWkVST19BRERSRVNTLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBpZiAoaGFzVmFsaWRhdG9yKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1tkZWxlZ2F0ZWRWYWxpZGF0aW9uXSBWYWxpZGF0b3IgaXMgZGVmaW5lZCBmb3IgdGhpcyByZXF1ZXN0LCBjaGVja2luZyBpZiB2YWxpZGF0b3IgaGFzIHJldHVybmVkIFwidmFsaWRhdGVkXCInKTtcbiAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiB2YWxpZGF0b3IgaGFzIGV4cGxpY2l0bHkgdmFsaWRhdGVkXG4gICAgICAgICAgICAgICAgLy8gVGhlIHZhbGlkYXRvclZhbGlkYXRlZCBwYXJhbWV0ZXIgY29tZXMgZnJvbSB0aGUgdmFsaWRhdG9yIGNsYXNzIChlLmcuLCBlbnMtdmFsaWRhdG9yKVxuICAgICAgICAgICAgICAgIC8vIEl0IG11c3QgYmUgdHJ1ZSBmb3IgdGhlIG9uLWNoYWluIHJlc3BvbnNlIHRvIGJlIGNyZWF0ZWRcbiAgICAgICAgICAgICAgICBpZiAodmFsaWRhdG9yVmFsaWRhdGVkICE9PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdbZGVsZWdhdGVkVmFsaWRhdGlvbl0g4p2MIFNraXBwaW5nOiBWYWxpZGF0b3IgaGFzIG5vdCByZXR1cm5lZCBcInZhbGlkYXRlZDogdHJ1ZVwiJyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdbZGVsZWdhdGVkVmFsaWRhdGlvbl0gICBWYWxpZGF0b3IgbXVzdCBleHBsaWNpdGx5IHJldHVybiBcInZhbGlkYXRlZDogdHJ1ZVwiIGJlZm9yZSBvbi1jaGFpbiByZXNwb25zZSBjYW4gYmUgY3JlYXRlZCcpO1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnW2RlbGVnYXRlZFZhbGlkYXRpb25dICAgQ3VycmVudCB2YWxpZGF0b3JWYWxpZGF0ZWQgdmFsdWU6JywgdmFsaWRhdG9yVmFsaWRhdGVkKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RIYXNoLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWdlbnRJZDogc3RhdHVzLmFnZW50SWQ/LnRvU3RyaW5nKCkgfHwgJ3Vua25vd24nLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2hhaW5JZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6ICdWYWxpZGF0b3IgbXVzdCByZXR1cm4gXCJ2YWxpZGF0ZWQ6IHRydWVcIiBiZWZvcmUgdmFsaWRhdGlvbiByZXNwb25zZSBjYW4gYmUgY3JlYXRlZCBvbi1jaGFpbicsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1tkZWxlZ2F0ZWRWYWxpZGF0aW9uXSDinIUgVmFsaWRhdG9yIGhhcyByZXR1cm5lZCBcInZhbGlkYXRlZDogdHJ1ZVwiIC0gcHJvY2VlZGluZyB3aXRoIHZhbGlkYXRpb24gcmVzcG9uc2UnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdbZGVsZWdhdGVkVmFsaWRhdGlvbl0gTm8gdmFsaWRhdG9yIGRlZmluZWQgZm9yIHRoaXMgcmVxdWVzdCAtIHByb2NlZWRpbmcgd2l0aCB2YWxpZGF0aW9uIHJlc3BvbnNlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhZ2VudElkID0gc3RhdHVzLmFnZW50SWQudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGN1cnJlbnRBZ2VudElkID0gYWdlbnRJZDtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdbZGVsZWdhdGVkVmFsaWRhdGlvbl0gQWdlbnQgYmVpbmcgdmFsaWRhdGVkOicsIGFnZW50SWQpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ1tkZWxlZ2F0ZWRWYWxpZGF0aW9uXSBOb3RlOiBhZ2VudElkRmlsdGVyIHBhcmFtZXRlciAoJywgYWdlbnRJZEZpbHRlciwgJykgaXMgbm90IHVzZWQgZm9yIGZpbHRlcmluZycpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ1tkZWxlZ2F0ZWRWYWxpZGF0aW9uXSBUaGUgdmFsaWRhdG9yIGlzIGlkZW50aWZpZWQgYnkgdmFsaWRhdG9yQWRkcmVzcyBmcm9tIFNlc3Npb25QYWNrYWdlLCBub3QgYnkgYWdlbnRJZEZpbHRlcicpO1xuICAgICAgICAgICAgY29uc3QgYWdlbnQgPSBhd2FpdCBjbGllbnQuYWdlbnRzLmdldEFnZW50KGFnZW50SWQsIGNoYWluSWQpO1xuICAgICAgICAgICAgaWYgKCFhZ2VudD8uYWdlbnROYW1lIHx8ICFhZ2VudC5hZ2VudEFjY291bnQpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnW2RlbGVnYXRlZFZhbGlkYXRpb25dIEFnZW50IG1pc3NpbmcgbmFtZSBvciBhY2NvdW50OicsIHsgYWdlbnRJZCwgYWdlbnROYW1lOiBhZ2VudD8uYWdlbnROYW1lLCBhZ2VudEFjY291bnQ6IGFnZW50Py5hZ2VudEFjY291bnQgfSk7XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdEhhc2gsXG4gICAgICAgICAgICAgICAgICAgIGFnZW50SWQsXG4gICAgICAgICAgICAgICAgICAgIGNoYWluSWQsXG4gICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBlcnJvcjogYEFnZW50ICR7YWdlbnRJZH0gaXMgbWlzc2luZyBuYW1lIG9yIGFjY291bnRgLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc29sZS5sb2coJ1tkZWxlZ2F0ZWRWYWxpZGF0aW9uXSDinIUgQWxsIGNoZWNrcyBwYXNzZWQgLSBwcmVwYXJpbmcgdmFsaWRhdGlvbiByZXNwb25zZSB0cmFuc2FjdGlvbicpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ1tkZWxlZ2F0ZWRWYWxpZGF0aW9uXSBUcmFuc2FjdGlvbiBwYXJhbWV0ZXJzOicsIHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0SGFzaCxcbiAgICAgICAgICAgICAgICByZXNwb25zZVNjb3JlLFxuICAgICAgICAgICAgICAgIHJlc3BvbnNlVXJpOiByZXNwb25zZVVyaSB8fCAnKG5vbmUpJyxcbiAgICAgICAgICAgICAgICByZXNwb25zZVRhZyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgdHhSZXF1ZXN0ID0gYXdhaXQgdmFsaWRhdGlvblJlZ2lzdHJ5Q2xpZW50LnByZXBhcmVWYWxpZGF0aW9uUmVzcG9uc2VUeCh7XG4gICAgICAgICAgICAgICAgcmVxdWVzdEhhc2gsXG4gICAgICAgICAgICAgICAgcmVzcG9uc2U6IHJlc3BvbnNlU2NvcmUsXG4gICAgICAgICAgICAgICAgcmVzcG9uc2VVcmk6IHJlc3BvbnNlVXJpIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICB0YWc6IHJlc3BvbnNlVGFnLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBzaWduZWREZWxlZ2F0aW9uID0gZGVsZWdhdGlvblNldHVwLnNpZ25lZERlbGVnYXRpb247XG4gICAgICAgICAgICBjb25zdCBkZWxlZ2F0aW9uTWVzc2FnZSA9IHtcbiAgICAgICAgICAgICAgICBkZWxlZ2F0ZTogc2lnbmVkRGVsZWdhdGlvbi5kZWxlZ2F0ZSxcbiAgICAgICAgICAgICAgICBkZWxlZ2F0b3I6IHNpZ25lZERlbGVnYXRpb24uZGVsZWdhdG9yLFxuICAgICAgICAgICAgICAgIGF1dGhvcml0eTogc2lnbmVkRGVsZWdhdGlvbi5hdXRob3JpdHksXG4gICAgICAgICAgICAgICAgY2F2ZWF0czogc2lnbmVkRGVsZWdhdGlvbi5jYXZlYXRzLFxuICAgICAgICAgICAgICAgIHNhbHQ6IHNpZ25lZERlbGVnYXRpb24uc2FsdCxcbiAgICAgICAgICAgICAgICBzaWduYXR1cmU6IHNpZ25lZERlbGVnYXRpb24uc2lnbmF0dXJlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IGluY2x1ZGVkRXhlY3V0aW9ucyA9IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldDogdHhSZXF1ZXN0LnRvLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogQmlnSW50KHR4UmVxdWVzdC52YWx1ZSB8fCAnMCcpLFxuICAgICAgICAgICAgICAgICAgICBjYWxsRGF0YTogdHhSZXF1ZXN0LmRhdGEsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICBjb25zdCByZWRlbXB0aW9uRGF0YSA9IERlbGVnYXRpb25NYW5hZ2VyLmVuY29kZS5yZWRlZW1EZWxlZ2F0aW9ucyh7XG4gICAgICAgICAgICAgICAgZGVsZWdhdGlvbnM6IFtbZGVsZWdhdGlvbk1lc3NhZ2VdXSxcbiAgICAgICAgICAgICAgICBtb2RlczogW0V4ZWN1dGlvbk1vZGUuU2luZ2xlRGVmYXVsdF0sXG4gICAgICAgICAgICAgICAgZXhlY3V0aW9uczogW2luY2x1ZGVkRXhlY3V0aW9uc10sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHJlZGVtcHRpb25DYWxsID0ge1xuICAgICAgICAgICAgICAgIHRvOiBkZWxlZ2F0aW9uU2V0dXAuc2Vzc2lvbkFBLFxuICAgICAgICAgICAgICAgIGRhdGE6IHJlZGVtcHRpb25EYXRhLFxuICAgICAgICAgICAgICAgIHZhbHVlOiAwbixcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCB1c2VyT3BIYXNoID0gYXdhaXQgc2VuZFNwb25zb3JlZFVzZXJPcGVyYXRpb24oe1xuICAgICAgICAgICAgICAgIGJ1bmRsZXJVcmwsXG4gICAgICAgICAgICAgICAgY2hhaW4sXG4gICAgICAgICAgICAgICAgYWNjb3VudENsaWVudDogc2Vzc2lvbkFjY291bnRDbGllbnQsXG4gICAgICAgICAgICAgICAgY2FsbHM6IFtyZWRlbXB0aW9uQ2FsbF0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHJlY2VpcHQgPSBhd2FpdCB3YWl0Rm9yVXNlck9wZXJhdGlvblJlY2VpcHQoe1xuICAgICAgICAgICAgICAgIGJ1bmRsZXJVcmwsXG4gICAgICAgICAgICAgICAgY2hhaW4sXG4gICAgICAgICAgICAgICAgaGFzaDogdXNlck9wSGFzaCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgdHhIYXNoID0gcmVjZWlwdD8udHJhbnNhY3Rpb25IYXNoIHx8IHJlY2VpcHQ/LnJlY2VpcHQ/LnRyYW5zYWN0aW9uSGFzaCB8fCB1c2VyT3BIYXNoO1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ1tkZWxlZ2F0ZWRWYWxpZGF0aW9uXSBWYWxpZGF0aW9uIHJlc3BvbnNlIHRyYW5zYWN0aW9uIHN1Y2Nlc3NmdWw6Jywge1xuICAgICAgICAgICAgICAgIHJlcXVlc3RIYXNoLFxuICAgICAgICAgICAgICAgIGFnZW50SWQsXG4gICAgICAgICAgICAgICAgdHhIYXNoLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXN1bHRzLnB1c2goe1xuICAgICAgICAgICAgICAgIHJlcXVlc3RIYXNoLFxuICAgICAgICAgICAgICAgIGFnZW50SWQsXG4gICAgICAgICAgICAgICAgY2hhaW5JZCxcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICAgICAgICAgIHR4SGFzaCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignW2RlbGVnYXRlZFZhbGlkYXRpb25dIEVycm9yIHByb2Nlc3NpbmcgdmFsaWRhdGlvbiByZXF1ZXN0OicsIHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0SGFzaCxcbiAgICAgICAgICAgICAgICBhZ2VudElkOiBjdXJyZW50QWdlbnRJZCxcbiAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvcicsXG4gICAgICAgICAgICAgICAgZXJyb3JTdGFjazogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLnN0YWNrIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXN1bHRzLnB1c2goe1xuICAgICAgICAgICAgICAgIHJlcXVlc3RIYXNoLFxuICAgICAgICAgICAgICAgIGFnZW50SWQ6IGN1cnJlbnRBZ2VudElkLFxuICAgICAgICAgICAgICAgIGNoYWluSWQsXG4gICAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc29sZS5sb2coJ1tkZWxlZ2F0ZWRWYWxpZGF0aW9uXSA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PScpO1xuICAgIGNvbnNvbGUubG9nKCdbZGVsZWdhdGVkVmFsaWRhdGlvbl0gRmluYWwgcmVzdWx0cyBzdW1tYXJ5Jyk7XG4gICAgY29uc29sZS5sb2coJ1tkZWxlZ2F0ZWRWYWxpZGF0aW9uXSA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PScpO1xuICAgIGNvbnNvbGUubG9nKCdbZGVsZWdhdGVkVmFsaWRhdGlvbl0gUmVzdWx0cyBjb3VudDonLCByZXN1bHRzLmxlbmd0aCk7XG4gICAgaWYgKHJlc3VsdHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdbZGVsZWdhdGVkVmFsaWRhdGlvbl0g4pqg77iPICBObyByZXN1bHRzIC0gdmFsaWRhdGlvbiByZXF1ZXN0IHdhcyBub3QgcHJvY2Vzc2VkJyk7XG4gICAgICAgIGNvbnNvbGUubG9nKCdbZGVsZWdhdGVkVmFsaWRhdGlvbl0gVGhpcyBjb3VsZCBiZSBkdWUgdG86Jyk7XG4gICAgICAgIGNvbnNvbGUubG9nKCdbZGVsZWdhdGVkVmFsaWRhdGlvbl0gICAtIFZhbGlkYXRvciBhZGRyZXNzIG1pc21hdGNoIChyZXF1ZXN0IGV4cGVjdHMgZGlmZmVyZW50IHZhbGlkYXRvciknKTtcbiAgICAgICAgY29uc29sZS5sb2coJ1tkZWxlZ2F0ZWRWYWxpZGF0aW9uXSAgIC0gVmFsaWRhdGlvbiBhbHJlYWR5IHJlc3BvbmRlZCcpO1xuICAgICAgICBjb25zb2xlLmxvZygnW2RlbGVnYXRlZFZhbGlkYXRpb25dICAgLSBFcnJvciBkdXJpbmcgcHJvY2Vzc2luZycpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmVzdWx0cy5mb3JFYWNoKChyLCBpZHgpID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbZGVsZWdhdGVkVmFsaWRhdGlvbl0gUmVzdWx0ICR7aWR4ICsgMX06YCwge1xuICAgICAgICAgICAgICAgIHJlcXVlc3RIYXNoOiByLnJlcXVlc3RIYXNoLFxuICAgICAgICAgICAgICAgIGFnZW50SWQ6IHIuYWdlbnRJZCxcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiByLnN1Y2Nlc3MgPyAn4pyFIFNVQ0NFU1MnIDogJ+KdjCBGQUlMRUQnLFxuICAgICAgICAgICAgICAgIGVycm9yOiByLmVycm9yIHx8ICcobm9uZSknLFxuICAgICAgICAgICAgICAgIHR4SGFzaDogci50eEhhc2ggfHwgJyhub25lKScsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnNvbGUubG9nKCdbZGVsZWdhdGVkVmFsaWRhdGlvbl0gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0nKTtcbiAgICByZXR1cm4gcmVzdWx0cztcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlbGVnYXRlZFZhbGlkYXRpb24uanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@agentic-trust/core/dist/server/services/delegatedValidation.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@agentic-trust/core/dist/server/singletons/agenticTrustClient.js":
/*!*******************************************************************************************!*\
  !*** ../../node_modules/@agentic-trust/core/dist/server/singletons/agenticTrustClient.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AgenticTrustClient: () => (/* binding */ AgenticTrustClient)\n/* harmony export */ });\n/* harmony import */ var graphql_request__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! graphql-request */ \"(rsc)/../../node_modules/graphql-request/build/esm/index.js\");\n/* harmony import */ var _lib_agents__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/agents */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/lib/agents.js\");\n/* harmony import */ var _lib_a2aProtocolProvider__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/a2aProtocolProvider */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/lib/a2aProtocolProvider.js\");\n/* harmony import */ var _lib_veramo__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../lib/veramo */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/lib/veramo.js\");\n/* harmony import */ var _ensClient__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ensClient */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/singletons/ensClient.js\");\n/* harmony import */ var _discoveryClient__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./discoveryClient */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/singletons/discoveryClient.js\");\n/* harmony import */ var _reputationClient__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./reputationClient */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/singletons/reputationClient.js\");\n/* harmony import */ var _singletons_identityClient__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../singletons/identityClient */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/singletons/identityClient.js\");\n/* harmony import */ var _lib_chainConfig__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../lib/chainConfig */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/lib/chainConfig.js\");\n/* harmony import */ var _userApps_userApp__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../userApps/userApp */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/userApps/userApp.js\");\n/* harmony import */ var _lib_veramoFactory__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../lib/veramoFactory */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/lib/veramoFactory.js\");\n/* harmony import */ var _lib_agent__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../lib/agent */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/lib/agent.js\");\n/* harmony import */ var _lib_agentFeedback__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../lib/agentFeedback */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/lib/agentFeedback.js\");\n/* harmony import */ var _agentic_trust_8004_ext_sdk__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @agentic-trust/8004-ext-sdk */ \"(rsc)/../../node_modules/@agentic-trust/8004-ext-sdk/dist/index.js\");\n/**\n * AgenticTrust API Client\n *\n * Client for interacting with the AgenticTrust GraphQL API\n */ \n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst DEFAULT_DISCOVERY_URL = 'https://8004-agent.io';\nconst DEFAULT_DISCOVERY_API_KEY = '9073051bb4bb81de87567794f24caf78f77d7985f79bc1cf6f79c33ce2cafdc3';\n// Best-known defaults (can be overridden by env vars or explicit params).\nconst DEFAULT_REGISTRIES_BY_CHAIN = {\n    11155111: {\n        identityRegistry: '0x8004a6090Cd10A7288092483047B097295Fb8847',\n        reputationRegistry: '0x8004B8FD1A363aa02fDC07635C0c5F94f6Af5B7E'\n    },\n    84532: {\n        identityRegistry: '0x8004AA63c570c570eBF15376c0dB199918BFe9Fb',\n        reputationRegistry: '0x8004bd8daB57f14Ed299135749a5CB5c42d341BF'\n    }\n};\nfunction as0xAddress(value) {\n    const v = String(value || '').trim();\n    if (!v) return undefined;\n    const with0x = v.startsWith('0x') ? v : `0x${v}`;\n    if (!/^0x[a-fA-F0-9]{40}$/.test(with0x)) return undefined;\n    return with0x;\n}\nclass AgenticTrustClient {\n    constructor(configOrParams){\n        const config = 'chainId' in configOrParams ? (()=>{\n            const params = configOrParams;\n            const chainId = Number(params.chainId);\n            if (!Number.isFinite(chainId)) {\n                throw new Error('chainId is required');\n            }\n            const envIdentity = as0xAddress((0,_lib_chainConfig__WEBPACK_IMPORTED_MODULE_8__.getChainEnvVar)('AGENTIC_TRUST_IDENTITY_REGISTRY', chainId));\n            const envReputation = as0xAddress((0,_lib_chainConfig__WEBPACK_IMPORTED_MODULE_8__.getChainEnvVar)('AGENTIC_TRUST_REPUTATION_REGISTRY', chainId));\n            const baked = DEFAULT_REGISTRIES_BY_CHAIN[chainId];\n            const identityRegistry = params.identityRegistry || envIdentity || baked?.identityRegistry;\n            const reputationRegistry = params.reputationRegistry || envReputation || baked?.reputationRegistry;\n            if (!identityRegistry || !reputationRegistry) {\n                throw new Error(`Missing default registry addresses for chainId=${chainId}. ` + `Provide identityRegistry/reputationRegistry explicitly or set ` + `AGENTIC_TRUST_IDENTITY_REGISTRY_<CHAIN> and AGENTIC_TRUST_REPUTATION_REGISTRY_<CHAIN>.`);\n            }\n            const graphQLUrl = (params.discoveryUrl || DEFAULT_DISCOVERY_URL).trim();\n            const apiKey = (params.discoveryApiKey || DEFAULT_DISCOVERY_API_KEY).trim();\n            return {\n                graphQLUrl,\n                apiKey,\n                privateKey: String(params.privateKey || '').trim(),\n                rpcUrl: String(params.rpcUrl || '').trim(),\n                identityRegistry,\n                reputationRegistry\n            };\n        })() : configOrParams;\n        this.config = {\n            ...config\n        };\n        // Construct GraphQL endpoint URL\n        if (!config.graphQLUrl) {\n            throw new Error('graphQLUrl is required in ApiClientConfig. ' + 'Set the AGENTIC_TRUST_DISCOVERY_URL environment variable (or provide graphQLUrl in config).');\n        }\n        const endpoint = config.graphQLUrl.endsWith('/graphql') ? config.graphQLUrl : `${config.graphQLUrl.replace(/\\/$/, '')}/graphql`;\n        // Build headers\n        const headers = {\n            'Content-Type': 'application/json',\n            Accept: 'application/json',\n            ...config.headers\n        };\n        // Add API key if provided\n        if (config.apiKey) {\n            headers['Authorization'] = `Bearer ${config.apiKey}`;\n        }\n        // Create GraphQL client\n        this.graphQLClient = new graphql_request__WEBPACK_IMPORTED_MODULE_0__.GraphQLClient(endpoint, {\n            headers\n        });\n        // Initialize discovery client singleton with this client's config\n        // This ensures the singleton uses the same configuration as this client\n        // Initialize lazily (will be initialized when first used)\n        Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./discoveryClient */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/singletons/discoveryClient.js\")).then(({ getDiscoveryClient })=>{\n            getDiscoveryClient({\n                endpoint,\n                apiKey: config.apiKey,\n                headers: config.headers\n            }).catch((error)=>{\n                console.warn('Failed to initialize DiscoveryClient singleton:', error);\n            });\n        });\n        // Initialize API namespaces\n        this.agents = new _lib_agents__WEBPACK_IMPORTED_MODULE_1__.AgentsAPI(this);\n        this.a2aProtocolProvider = new _lib_a2aProtocolProvider__WEBPACK_IMPORTED_MODULE_2__.A2AProtocolProviderAPI(this.graphQLClient);\n        this.veramo = new _lib_veramo__WEBPACK_IMPORTED_MODULE_3__.VeramoAPI();\n        // Kick off async initialization. Users can await `client.ready` if they need\n        // Veramo / reputation client to be ready before making calls.\n        this.ready = (async ()=>{\n            // Step 1: Initialize Veramo agent (always happens - either provided or created from privateKey)\n            await this.initializeVeramoAgent(config);\n            // Step 2: Initialize reputation client if configured\n            // Priority: sessionPackage > reputation config > top-level config with identity/reputation registry\n            if (config.sessionPackage) {\n                console.log(' create: Initializing reputation from session package...');\n                await this.initializeReputationFromSessionPackage(config.sessionPackage);\n            } else if (config.identityRegistry && config.reputationRegistry) {\n                // Initialize reputation from top-level config (identityRegistry and reputationRegistry)\n                // Uses the EOA derived from privateKey (same as VeramoAgent)\n                // Note: Reputation client requires private key for signing operations\n                if (config.privateKey) {\n                    console.log(' create: Initializing reputation from top-level config...');\n                    await this.initializeClientReputationFromConfig(config);\n                }\n            }\n            // Step 3: Eagerly initialize core domain clients (best-effort)\n            // so downstream calls don't pay first-call initialization cost.\n            const defaultChainId = _lib_chainConfig__WEBPACK_IMPORTED_MODULE_8__.DEFAULT_CHAIN_ID;\n            try {\n                await Promise.allSettled([\n                    (0,_discoveryClient__WEBPACK_IMPORTED_MODULE_5__.getDiscoveryClient)(),\n                    (0,_ensClient__WEBPACK_IMPORTED_MODULE_4__.getENSClient)(defaultChainId),\n                    (0,_singletons_identityClient__WEBPACK_IMPORTED_MODULE_7__.getIdentityRegistryClient)(defaultChainId),\n                    (0,_reputationClient__WEBPACK_IMPORTED_MODULE_6__.getReputationRegistryClient)(defaultChainId)\n                ]);\n            } catch  {\n            // Individual domain client initialization errors are logged\n            // in their respective modules; we don't fail client creation.\n            }\n        })();\n    }\n    /**\n     * Initialize the Veramo agent (internal method)\n     * Called automatically during create() if not provided in config\n     */ async initializeVeramoAgent(config) {\n        if (config.veramoAgent) {\n            // Use provided agent\n            this.veramo.connect(config.veramoAgent);\n        } else {\n            // Create agent internally\n            const agent = await (0,_lib_veramoFactory__WEBPACK_IMPORTED_MODULE_10__.createVeramoAgentForClient)(config.privateKey, config.rpcUrl);\n            this.veramo.connect(agent);\n        }\n    }\n    /**\n     * Create a new AgenticTrust client instance\n     */ static async create(config) {\n        const client = new AgenticTrustClient(config);\n        await client.ready;\n        return client;\n    }\n    /** @deprecated Use `new AgenticTrustClient({ privateKey, chainId, rpcUrl, ... })` instead. */ static async createWithDefaults(params) {\n        const client = new AgenticTrustClient(params);\n        await client.ready;\n        return client;\n    }\n    /**\n     * High-level agent search API exposed directly on the AgenticTrustClient.\n     * This is a thin wrapper around AgentsAPI.searchAgents so that apps can call\n     * client.searchAgents(...) instead of client.agents.searchAgents(...).\n     */ async searchAgents(options) {\n        return this.agents.searchAgents(options);\n    }\n    /**\n     * High-level feedbackAuth helper exposed directly on AgenticTrustClient.\n     * This delegates to the shared server-side createFeedbackAuth implementation,\n     * which uses the ReputationClient singleton and IdentityRegistry checks.\n     */ async createFeedbackAuth(params) {\n        return (0,_lib_agentFeedback__WEBPACK_IMPORTED_MODULE_12__.createFeedbackAuth)(params);\n    }\n    /**\n     * Create a feedbackAuth and also produce a pre-signed ERC-8092 delegation association\n     * payload (approver signature only).\n     */ async createFeedbackAuthWithDelegation(params) {\n        return (0,_lib_agentFeedback__WEBPACK_IMPORTED_MODULE_12__.createFeedbackAuthWithDelegation)(params);\n    }\n    /**\n     * Fetch feedback entries for a given agent.\n     *\n     * Strategy:\n     *  1. Try the discovery indexer's feedback search GraphQL API\n     *     (e.g. searchFeedbacksGraph) when available.\n     *  2. If that fails or is not supported, fall back to on-chain\n     *     `readAllFeedback` on the ReputationRegistry via the ReputationClient.\n     *\n     * The return type is intentionally un-opinionated (`unknown[]`) so callers\n     * can evolve their own view models without being tightly coupled to the\n     * underlying indexer/contract schema.\n     */ async getAgentFeedback(params) {\n        const { agentId, chainId, clientAddresses, tag1, tag2, includeRevoked = false, limit, offset } = params;\n        const trimmed = (agentId ?? '').toString().trim();\n        if (!trimmed) {\n            throw new Error('agentId is required for getAgentFeedback');\n        }\n        const resolvedChainId = Number.isFinite(chainId ?? NaN) && (chainId ?? 0) > 0 ? chainId : _lib_chainConfig__WEBPACK_IMPORTED_MODULE_8__.DEFAULT_CHAIN_ID;\n        let agentIdBigInt;\n        try {\n            agentIdBigInt = BigInt(trimmed);\n        } catch  {\n            throw new Error(`Invalid agentId for getAgentFeedback: ${agentId}`);\n        }\n        // 1. Try discovery indexer feedback search first (best-effort)\n        try {\n            const discoveryClient = await (0,_discoveryClient__WEBPACK_IMPORTED_MODULE_5__.getDiscoveryClient)();\n            const query = `\n        query SearchFeedbacksGraph(\n          $where: FeedbackWhereInput\n          $first: Int\n          $skip: Int\n        ) {\n          searchFeedbacksGraph(\n            where: $where\n            first: $first\n            skip: $skip\n          ) {\n            feedbacks {\n              id\n              agentId\n              clientAddress\n              score\n              feedbackUri\n              feedbackJson\n              comment\n              ratingPct\n              txHash\n              blockNumber\n              timestamp\n              isRevoked\n              responseCount\n            }\n            total\n            hasMore\n          }\n        }\n      `;\n            const variables = {\n                where: {\n                    agentId: trimmed,\n                    chainId: resolvedChainId\n                },\n                first: typeof limit === 'number' ? limit : 100,\n                skip: typeof offset === 'number' ? offset : 0\n            };\n            const result = await discoveryClient.request(query, variables);\n            if (result && result.searchFeedbacksGraph) {\n                const node = result.searchFeedbacksGraph;\n                const list = Array.isArray(node.feedbacks) ? node.feedbacks : [];\n                return list;\n            }\n        } catch (error) {\n            console.warn('[AgenticTrustClient.getAgentFeedback] discovery feedback search failed; falling back to on-chain readAllFeedback:', error);\n        }\n        // 2. Fallback: on-chain ReputationRegistry readAllFeedback\n        const reputationClient = await (0,_reputationClient__WEBPACK_IMPORTED_MODULE_6__.getReputationRegistryClient)(resolvedChainId);\n        const raw = await reputationClient.readAllFeedback(agentIdBigInt, clientAddresses, tag1, tag2, includeRevoked);\n        const clients = raw?.clientAddresses ?? [];\n        const scores = raw?.scores ?? [];\n        const tag1s = raw?.tag1s ?? [];\n        const tag2s = raw?.tag2s ?? [];\n        const revokedStatuses = raw?.revokedStatuses ?? [];\n        const maxLen = Math.max(clients.length, scores.length, tag1s.length, tag2s.length, revokedStatuses.length);\n        const records = [];\n        for(let i = 0; i < maxLen; i++){\n            records.push({\n                agentId: trimmed,\n                chainId: resolvedChainId,\n                clientAddress: clients[i],\n                score: scores[i],\n                tag1: tag1s[i],\n                tag2: tag2s[i],\n                isRevoked: revokedStatuses[i],\n                index: i\n            });\n        }\n        return records;\n    }\n    /**\n     * Get aggregated reputation summary for an agentId from the on-chain\n     * ReputationRegistry via the ReputationClient.\n     */ async getReputationSummary(params) {\n        const { agentId, chainId, clientAddresses, tag1, tag2 } = params;\n        const trimmed = (agentId ?? '').toString().trim();\n        if (!trimmed) {\n            throw new Error('agentId is required for getReputationSummary');\n        }\n        const resolvedChainId = Number.isFinite(chainId ?? NaN) && (chainId ?? 0) > 0 ? chainId : _lib_chainConfig__WEBPACK_IMPORTED_MODULE_8__.DEFAULT_CHAIN_ID;\n        let agentIdBigInt;\n        try {\n            agentIdBigInt = BigInt(trimmed);\n        } catch  {\n            throw new Error(`Invalid agentId for getReputationSummary: ${agentId}`);\n        }\n        const reputationClient = await (0,_reputationClient__WEBPACK_IMPORTED_MODULE_6__.getReputationRegistryClient)(resolvedChainId);\n        return reputationClient.getSummary(agentIdBigInt, clientAddresses, tag1, tag2);\n    }\n    /**\n     * ENS helpers exposed via AgenticTrustClient so that apps do not talk to\n     * the ENS singleton directly.\n     */ async isENSNameAvailable(ensName, chainId) {\n        const { isENSNameAvailable } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./ensClient */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/singletons/ensClient.js\"));\n        return isENSNameAvailable(ensName, chainId);\n    }\n    async getENSInfo(ensName, chainId) {\n        const { getENSInfo } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./ensClient */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/singletons/ensClient.js\"));\n        return getENSInfo(ensName, chainId);\n    }\n    async addAgentNameToL1Org(params) {\n        const { addAgentNameToL1Org } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./ensClient */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/singletons/ensClient.js\"));\n        return addAgentNameToL1Org(params);\n    }\n    async addAgentNameToL2Org(params) {\n        const { addAgentNameToL2Org } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./ensClient */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/singletons/ensClient.js\"));\n        return addAgentNameToL2Org(params);\n    }\n    /**\n     * Set the token URI (registration tokenUri) for an existing agent NFT\n     * in the IdentityRegistry. This delegates to the Admin Agents API and\n     * requires AdminApp / admin permissions to be configured.\n     */ async setAgentTokenUri(params) {\n        const { agentId, chainId, tokenUri } = params;\n        if (!tokenUri || typeof tokenUri !== 'string' || tokenUri.trim().length === 0) {\n            throw new Error('tokenUri is required for setAgentTokenUri');\n        }\n        const idAsString = typeof agentId === 'bigint' ? agentId.toString(10) : String(agentId || '').trim();\n        if (!idAsString) {\n            throw new Error('agentId is required for setAgentTokenUri');\n        }\n        return this.agents.admin.updateAgent({\n            agentId: idAsString,\n            chainId,\n            tokenUri: tokenUri\n        });\n    }\n    /**\n     * Transfer an agent NFT to a new owner address.\n     * Thin wrapper over AgentsAPI.admin.transferAgent.\n     */ async transferAgent(params) {\n        const { agentId, to, chainId } = params;\n        const idAsString = typeof agentId === 'bigint' ? agentId.toString(10) : String(agentId || '').trim();\n        if (!idAsString) {\n            throw new Error('agentId is required for transferAgent');\n        }\n        if (!to || typeof to !== 'string' || !to.startsWith('0x') || to.length !== 42) {\n            throw new Error(`Invalid destination address for transferAgent: ${to}`);\n        }\n        return this.agents.admin.transferAgent({\n            agentId: idAsString,\n            chainId,\n            to\n        });\n    }\n    /**\n     * Update the on-chain metadata keys `agentName` and/or `agentAccount`\n     * in the IdentityRegistry for an existing agent NFT.\n     *\n     * This is a thin wrapper over AgentsAPI.admin.updateAgent that builds the\n     * appropriate metadata entries. Requires AdminApp / admin permissions.\n     */ async updateNameAndAccountMetadata(params) {\n        const { agentId, chainId, agentName, agentAccount } = params;\n        const idAsString = typeof agentId === 'bigint' ? agentId.toString(10) : String(agentId || '').trim();\n        if (!idAsString) {\n            throw new Error('agentId is required for updateNameAndAccountMetadata');\n        }\n        const metadata = [];\n        if (agentName && agentName.toString().trim().length > 0) {\n            metadata.push({\n                key: 'agentName',\n                value: agentName.toString().trim()\n            });\n        }\n        if (agentAccount && agentAccount.toString().trim().length > 0) {\n            metadata.push({\n                key: 'agentAccount',\n                value: agentAccount.toString().trim()\n            });\n        }\n        if (metadata.length === 0) {\n            throw new Error('At least one of agentName or agentAccount must be provided for updateNameAndAccountMetadata');\n        }\n        return this.agents.admin.updateAgent({\n            agentId: idAsString,\n            chainId,\n            metadata\n        });\n    }\n    /**\n     * Prepare low-level calls for updating an agent's token URI and/or metadata,\n     * suitable for client-side AA/bundler execution. Mirrors AgentsAPI.admin.prepareUpdateAgent.\n     */ async prepareUpdateAgent(params) {\n        const { agentId, chainId, tokenUri, metadata } = params;\n        const idAsString = typeof agentId === 'bigint' ? agentId.toString(10) : String(agentId || '').trim();\n        if (!idAsString) {\n            throw new Error('agentId is required for prepareUpdateAgent');\n        }\n        return this.agents.admin.prepareUpdateAgent({\n            agentId: idAsString,\n            chainId,\n            tokenUri,\n            metadata\n        });\n    }\n    async prepareL1AgentNameInfoCalls(params) {\n        const { prepareL1AgentNameInfoCalls } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./ensClient */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/singletons/ensClient.js\"));\n        return prepareL1AgentNameInfoCalls(params);\n    }\n    async prepareL2AgentNameInfoCalls(params) {\n        const { prepareL2AgentNameInfoCalls } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./ensClient */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/singletons/ensClient.js\"));\n        return prepareL2AgentNameInfoCalls(params);\n    }\n    /**\n     * High-level createAgent helper that routes to the appropriate underlying\n     * AgentsAPI method based on ownerType (EOA vs AA) and executionMode.\n     *\n     * - ownerType: 'eoa' | 'smartAccount'\n     * - executionMode:\n     *    - 'auto'   (default): use server if an admin/private key is configured, otherwise client\n     *    - 'server' : execute on server (requires admin/private key, otherwise falls back to 'client')\n     *    - 'client' : prepare transactions/calls for client-side signing/execution\n     */ async createAgent(params) {\n        const { ownerType, executionMode = 'auto', ...rest } = params;\n        const hasPrivateKey = !!this.config.privateKey || !!process.env.AGENTIC_TRUST_ADMIN_PRIVATE_KEY;\n        let mode = executionMode;\n        if (executionMode === 'auto') {\n            mode = hasPrivateKey ? 'server' : 'client';\n        } else if (executionMode === 'server' && !hasPrivateKey) {\n            console.warn('[AgenticTrustClient.createAgent] executionMode=\"server\" requested but no admin/private key configured; falling back to \"client\" mode.');\n            mode = 'client';\n        }\n        if (ownerType === 'eoa') {\n            if (mode === 'server') {\n                return await this.agents.createAgentWithEOAOwnerUsingPrivateKey(rest);\n            }\n            return await this.agents.createAgentWithEOAOwnerUsingWallet(rest);\n        }\n        // ownerType === 'smartAccount'\n        if (mode === 'server') {\n            return await this.agents.createAgentWithSmartAccountOwnerUsingPrivateKey(rest);\n        }\n        return await this.agents.createAgentWithSmartAccountOwnerUsingWallet(rest);\n    }\n    /**\n     * Get a single agent by ID.\n     * Uses loadAgentDetail to get the latest data from the NFT contract,\n     * with discovery data used as fallback for missing fields.\n     */ async getAgent(agentId, chainId = _lib_chainConfig__WEBPACK_IMPORTED_MODULE_8__.DEFAULT_CHAIN_ID, options) {\n        try {\n            // Default to skipping registration/tokenURI/IPFS reads unless explicitly requested.\n            // This keeps hot paths (like feedback auth) resilient to IPFS and reduces RPC load.\n            const agentDetail = await (0,_lib_agent__WEBPACK_IMPORTED_MODULE_11__.loadAgentDetail)(this, agentId, chainId, {\n                includeRegistration: options?.includeRegistration ?? false\n            });\n            // Convert AgentDetail to AgentData format expected by Agent constructor\n            // AgentDetail extends AgentInfo which has all the fields needed\n            const agentData = {\n                agentId: agentDetail.agentId,\n                agentName: agentDetail.agentName,\n                chainId: agentDetail.chainId,\n                agentAccount: agentDetail.agentAccount,\n                agentIdentityOwnerAccount: agentDetail.agentIdentityOwnerAccount,\n                eoaAgentIdentityOwnerAccount: agentDetail.eoaAgentIdentityOwnerAccount ?? undefined,\n                eoaAgentAccount: agentDetail.eoaAgentAccount ?? undefined,\n                contractAddress: agentDetail.contractAddress ?? undefined,\n                didIdentity: agentDetail.didIdentity ?? undefined,\n                didAccount: agentDetail.didAccount ?? undefined,\n                didName: agentDetail.didName ?? undefined,\n                agentUri: agentDetail.agentUri ?? undefined,\n                createdAtBlock: agentDetail.createdAtBlock,\n                createdAtTime: agentDetail.createdAtTime,\n                updatedAtTime: agentDetail.updatedAtTime ?? undefined,\n                type: agentDetail.type ?? undefined,\n                description: agentDetail.description ?? undefined,\n                image: agentDetail.image ?? undefined,\n                a2aEndpoint: agentDetail.a2aEndpoint ?? undefined,\n                supportedTrust: agentDetail.supportedTrust ?? undefined,\n                rawJson: agentDetail.rawJson ?? undefined,\n                agentCardJson: agentDetail.agentCardJson ?? undefined,\n                agentCardReadAt: agentDetail.agentCardReadAt ?? undefined,\n                did: agentDetail.did ?? undefined,\n                mcp: agentDetail.mcp ?? undefined,\n                x402support: agentDetail.x402support ?? undefined,\n                active: agentDetail.active ?? undefined\n            };\n            return new _lib_agent__WEBPACK_IMPORTED_MODULE_11__.Agent(agentData, this);\n        } catch (error) {\n            console.warn(`[AgenticTrustClient.getAgent] Failed to load agent ${agentId} on chain ${chainId}:`, error);\n            return null;\n        }\n    }\n    /**\n     * Resolve and load an agent by its registered name using the discovery indexer.\n     * Returns an Agent instance bound to this client or null if not found.\n     */ async getAgentByName(agentName) {\n        const discoveryClient = await (0,_discoveryClient__WEBPACK_IMPORTED_MODULE_5__.getDiscoveryClient)();\n        const agentData = await discoveryClient.getAgentByName(agentName);\n        if (!agentData) {\n            return null;\n        }\n        return new _lib_agent__WEBPACK_IMPORTED_MODULE_11__.Agent(agentData, this);\n    }\n    /**\n     * Get the on-chain owner (EOA or account) of an agentId from the IdentityRegistry.\n     * Returns null if the owner cannot be resolved (e.g. token does not exist).\n     */ async getAgentOwner(agentId, chainId) {\n        const resolvedChainId = chainId ?? _lib_chainConfig__WEBPACK_IMPORTED_MODULE_8__.DEFAULT_CHAIN_ID;\n        const trimmed = agentId.trim();\n        let agentIdBigInt;\n        try {\n            agentIdBigInt = BigInt(trimmed);\n        } catch  {\n            throw new Error(`Invalid agentId for getAgentOwner: ${agentId}`);\n        }\n        try {\n            const identityClient = await (0,_singletons_identityClient__WEBPACK_IMPORTED_MODULE_7__.getIdentityRegistryClient)(resolvedChainId);\n            const owner = await identityClient.getOwner(agentIdBigInt);\n            if (owner && typeof owner === 'string' && /^0x[a-fA-F0-9]{40}$/.test(owner)) {\n                return owner;\n            }\n            return null;\n        } catch (error) {\n            console.warn('[AgenticTrustClient.getAgentOwner] Failed to resolve owner:', error);\n            return null;\n        }\n    }\n    /**\n     * Check if a wallet address owns an agent.\n     * Performs blockchain verification to determine ownership relationship.\n     * Agent NFT  Agent Account (AA)  EOA (wallet)\n     */ async isOwner(did8004, walletAddress, chainId) {\n        const resolvedChainId = chainId ?? _lib_chainConfig__WEBPACK_IMPORTED_MODULE_8__.DEFAULT_CHAIN_ID;\n        // Parse the DID to get agent info\n        let agentId;\n        try {\n            const parsed = (0,_agentic_trust_8004_ext_sdk__WEBPACK_IMPORTED_MODULE_13__.parseDid8004)(did8004);\n            agentId = parsed.agentId;\n        } catch (error) {\n            console.warn('[AgenticTrustClient.isOwner] Invalid DID format:', did8004, error);\n            return false;\n        }\n        const lowerWallet = walletAddress.toLowerCase();\n        try {\n            // Create a client for the chain\n            const chain = (0,_lib_chainConfig__WEBPACK_IMPORTED_MODULE_8__.getChainById)(resolvedChainId);\n            const rpcUrl = (0,_lib_chainConfig__WEBPACK_IMPORTED_MODULE_8__.getChainRpcUrl)(resolvedChainId);\n            if (!rpcUrl) {\n                console.warn('[AgenticTrustClient.isOwner] No RPC URL for chain:', resolvedChainId);\n                return false;\n            }\n            const { createPublicClient, http } = await Promise.all(/*! import() */[__webpack_require__.e(\"vendor-chunks/viem\"), __webpack_require__.e(\"vendor-chunks/abitype\")]).then(__webpack_require__.bind(__webpack_require__, /*! viem */ \"(rsc)/../../node_modules/viem/_esm/index.js\"));\n            const client = createPublicClient({\n                chain,\n                transport: http(rpcUrl)\n            });\n            // Resolve identity registry + on-chain ownership without loading AgentDetail (no IPFS).\n            const identityClient = await (0,_singletons_identityClient__WEBPACK_IMPORTED_MODULE_7__.getIdentityRegistryClient)(resolvedChainId);\n            const identityRegistryAddress = identityClient?.identityRegistryAddress;\n            if (!identityRegistryAddress) {\n                console.warn('[AgenticTrustClient.isOwner] Missing identityRegistryAddress');\n                return false;\n            }\n            const tokenId = BigInt(agentId);\n            const IDENTITY_ABI = [\n                {\n                    type: 'function',\n                    name: 'ownerOf',\n                    stateMutability: 'view',\n                    inputs: [\n                        {\n                            name: 'tokenId',\n                            type: 'uint256'\n                        }\n                    ],\n                    outputs: [\n                        {\n                            name: 'owner',\n                            type: 'address'\n                        }\n                    ]\n                },\n                {\n                    type: 'function',\n                    name: 'getAgentWallet',\n                    stateMutability: 'view',\n                    inputs: [\n                        {\n                            name: 'agentId',\n                            type: 'uint256'\n                        }\n                    ],\n                    outputs: [\n                        {\n                            name: 'wallet',\n                            type: 'address'\n                        }\n                    ]\n                }\n            ];\n            // 1) Direct NFT owner check\n            let nftOwner = null;\n            try {\n                nftOwner = await client.readContract({\n                    address: identityRegistryAddress,\n                    abi: IDENTITY_ABI,\n                    functionName: 'ownerOf',\n                    args: [\n                        tokenId\n                    ]\n                });\n            } catch (e) {\n                console.warn('[AgenticTrustClient.isOwner] ownerOf failed:', e);\n                nftOwner = null;\n            }\n            if (nftOwner && nftOwner.toLowerCase() === lowerWallet) {\n                return true;\n            }\n            // 2) If not the NFT owner, check controller of configured agent wallet (AA)\n            let agentAccount = null;\n            try {\n                agentAccount = await client.readContract({\n                    address: identityRegistryAddress,\n                    abi: IDENTITY_ABI,\n                    functionName: 'getAgentWallet',\n                    args: [\n                        tokenId\n                    ]\n                });\n            } catch (e) {\n                // If getAgentWallet is unavailable on a deployment, fall back to false.\n                console.warn('[AgenticTrustClient.isOwner] getAgentWallet failed:', e);\n                agentAccount = null;\n            }\n            if (!agentAccount || !agentAccount.startsWith('0x')) {\n                return false;\n            }\n            // Get bytecode to check if it's a contract\n            const code = await client.getBytecode({\n                address: agentAccount\n            });\n            // EOA ownership: direct address comparison\n            if (!code || code === '0x') {\n                return agentAccount.toLowerCase() === lowerWallet;\n            }\n            // Smart contract ownership: try different patterns\n            let controller = null;\n            // Try ERC-173 owner() function\n            try {\n                controller = await client.readContract({\n                    address: agentAccount,\n                    abi: [\n                        {\n                            name: 'owner',\n                            type: 'function',\n                            stateMutability: 'view',\n                            inputs: [],\n                            outputs: [\n                                {\n                                    type: 'address'\n                                }\n                            ]\n                        }\n                    ],\n                    functionName: 'owner'\n                });\n            } catch  {\n            // ignore\n            }\n            // Fallback: try getOwner() function\n            if (!controller) {\n                try {\n                    controller = await client.readContract({\n                        address: agentAccount,\n                        abi: [\n                            {\n                                name: 'getOwner',\n                                type: 'function',\n                                stateMutability: 'view',\n                                inputs: [],\n                                outputs: [\n                                    {\n                                        type: 'address'\n                                    }\n                                ]\n                            }\n                        ],\n                        functionName: 'getOwner'\n                    });\n                } catch  {\n                // ignore\n                }\n            }\n            // Fallback: try owners() array function\n            if (!controller) {\n                try {\n                    const owners = await client.readContract({\n                        address: agentAccount,\n                        abi: [\n                            {\n                                name: 'owners',\n                                type: 'function',\n                                stateMutability: 'view',\n                                inputs: [],\n                                outputs: [\n                                    {\n                                        type: 'address[]'\n                                    }\n                                ]\n                            }\n                        ],\n                        functionName: 'owners'\n                    });\n                    controller = owners?.[0] ?? null;\n                } catch  {\n                // ignore\n                }\n            }\n            return Boolean(controller && controller.toLowerCase() === lowerWallet);\n        } catch (error) {\n            console.warn('[AgenticTrustClient.isOwner] Ownership check failed:', error);\n            return false;\n        }\n    }\n    /**\n     * Resolve and load an agent by did:8004 identifier.\n     */ async getAgentByDid(did8004) {\n        const { agentId, chainId } = (0,_agentic_trust_8004_ext_sdk__WEBPACK_IMPORTED_MODULE_13__.parseDid8004)(did8004);\n        return this.getAgent(agentId, chainId);\n    }\n    /**\n     * Get a fully-hydrated AgentDetail for a given agentId and chainId.\n     * This reuses the shared buildAgentDetail implementation so that\n     * discovery, identity, and registration data are resolved consistently.\n     */ async getAgentDetails(agentId, chainId) {\n        const resolvedChainId = chainId ?? _lib_chainConfig__WEBPACK_IMPORTED_MODULE_8__.DEFAULT_CHAIN_ID;\n        const trimmed = agentId.trim();\n        let agentIdBigInt;\n        try {\n            agentIdBigInt = BigInt(trimmed);\n        } catch  {\n            throw new Error(`Invalid agentId for getAgentDetails: ${agentId}`);\n        }\n        return (0,_lib_agent__WEBPACK_IMPORTED_MODULE_11__.loadAgentDetail)(this, agentIdBigInt, resolvedChainId);\n    }\n    /**\n     * Get a fully-hydrated AgentDetail for a given did:8004 identifier.\n     */ async getAgentDetailsByDid(did8004, options) {\n        // loadAgentDetail will parse did:8004 and derive chainId/agentId internally.\n        return (0,_lib_agent__WEBPACK_IMPORTED_MODULE_11__.loadAgentDetail)(this, did8004, _lib_chainConfig__WEBPACK_IMPORTED_MODULE_8__.DEFAULT_CHAIN_ID, options);\n    }\n    /**\n     * Resolve an agent by its owner account address.\n     *\n     * Strategy:\n     *  1. Try ENS reverse lookup via ENS client (getAgentIdentityByAccount)\n     *  2. If not found, fall back to discovery search by account address\n     *  3. If an agentId is resolved, return fully-hydrated AgentDetail\n     *\n     * Returns null if no agent can be resolved for the given account.\n     */ async getAgentByAccount(account, chainId) {\n        let workingChainId = Number.isFinite(chainId ?? NaN) && (chainId ?? 0) > 0 ? chainId : _lib_chainConfig__WEBPACK_IMPORTED_MODULE_8__.DEFAULT_CHAIN_ID;\n        let agentId = null;\n        // 1. Try ENS reverse lookup first\n        try {\n            const ensClient = await (0,_ensClient__WEBPACK_IMPORTED_MODULE_4__.getENSClient)(workingChainId);\n            const identity = await ensClient.getAgentIdentityByAccount(account);\n            if (identity?.agentId) {\n                agentId = identity.agentId.toString();\n            }\n        } catch (error) {\n            console.warn('getAgentByAccount: Reverse ENS lookup by account failed:', error);\n        }\n        // 2. Fall back to discovery search by account if needed\n        if (!agentId) {\n            try {\n                const searchResults = await this.searchAgents({\n                    query: account,\n                    page: 1,\n                    pageSize: 1\n                });\n                const candidate = searchResults.agents?.[0];\n                if (candidate && typeof candidate === 'object') {\n                    const candidateObject = candidate;\n                    const candidateDataRaw = candidateObject.data;\n                    const candidateData = candidateDataRaw && typeof candidateDataRaw === 'object' ? candidateDataRaw : null;\n                    const candidateAgentIdValue = candidateData && candidateData.agentId !== undefined ? candidateData.agentId : candidateObject.agentId;\n                    if (candidateAgentIdValue !== undefined && candidateAgentIdValue !== null) {\n                        if (typeof candidateAgentIdValue === 'bigint') {\n                            agentId = candidateAgentIdValue.toString();\n                        } else if (typeof candidateAgentIdValue === 'number' && Number.isFinite(candidateAgentIdValue)) {\n                            agentId = Math.trunc(candidateAgentIdValue).toString();\n                        } else if (typeof candidateAgentIdValue === 'string' && candidateAgentIdValue.trim().length > 0) {\n                            agentId = candidateAgentIdValue.trim();\n                        }\n                    }\n                    const candidateChainId = candidateData && typeof candidateData.chainId === 'number' ? candidateData.chainId : undefined;\n                    if ((!workingChainId || Number.isNaN(workingChainId)) && typeof candidateChainId === 'number') {\n                        workingChainId = candidateChainId;\n                    }\n                }\n            } catch (error) {\n                console.warn('getAgentByAccount: Discovery search by account failed:', error);\n            }\n        }\n        if (!agentId) {\n            return null;\n        }\n        const effectiveChainId = Number.isFinite(workingChainId) && workingChainId > 0 ? workingChainId : _lib_chainConfig__WEBPACK_IMPORTED_MODULE_8__.DEFAULT_CHAIN_ID;\n        return this.getAgentDetails(agentId, effectiveChainId);\n    }\n    /**\n     * Extract an agentId from a transaction receipt using the on-chain IdentityRegistry.\n     * Thin wrapper around AgentsAPI.extractAgentIdFromReceipt so apps can call\n     * client.extractAgentIdFromReceipt(...) directly.\n     */ async extractAgentIdFromReceipt(receipt, chainId) {\n        return this.agents.extractAgentIdFromReceipt(receipt, chainId ?? _lib_chainConfig__WEBPACK_IMPORTED_MODULE_8__.DEFAULT_CHAIN_ID);\n    }\n    /**\n     * Revoke a previously submitted feedback entry for an agent.\n     *\n     * This is a high-level helper that:\n     *  - resolves the ReputationClient singleton for the given chain\n     *  - converts the provided agentId/feedbackIndex into bigint\n     *  - calls the underlying ReputationRegistry.revokeFeedback(...)\n     */ async revokeFeedback(params) {\n        const { agentId, feedbackIndex, chainId } = params;\n        const resolvedChainId = chainId ?? _lib_chainConfig__WEBPACK_IMPORTED_MODULE_8__.DEFAULT_CHAIN_ID;\n        const trimmed = agentId.trim();\n        let agentIdBigInt;\n        try {\n            agentIdBigInt = BigInt(trimmed);\n        } catch  {\n            throw new Error(`Invalid agentId for revokeFeedback: ${agentId}`);\n        }\n        const feedbackIndexBigInt = typeof feedbackIndex === 'bigint' ? feedbackIndex : BigInt(feedbackIndex);\n        const reputationClient = await (0,_reputationClient__WEBPACK_IMPORTED_MODULE_6__.getReputationRegistryClient)(resolvedChainId);\n        return reputationClient.revokeFeedback(agentIdBigInt, feedbackIndexBigInt);\n    }\n    /**\n     * Append a response to an existing feedback entry for an agent.\n     *\n     * High-level helper that converts string/number inputs to bigint and delegates\n     * to the ReputationClient's appendToFeedback implementation.\n     */ async appendToFeedback(params) {\n        const { agentId, clientAddress, feedbackIndex, responseUri, responseHash, chainId } = params;\n        const resolvedChainId = chainId ?? _lib_chainConfig__WEBPACK_IMPORTED_MODULE_8__.DEFAULT_CHAIN_ID;\n        const trimmed = agentId.trim();\n        let agentIdBigInt;\n        try {\n            agentIdBigInt = BigInt(trimmed);\n        } catch  {\n            throw new Error(`Invalid agentId for appendToFeedback: ${agentId}`);\n        }\n        const feedbackIndexBigInt = typeof feedbackIndex === 'bigint' ? feedbackIndex : BigInt(feedbackIndex);\n        const reputationClient = await (0,_reputationClient__WEBPACK_IMPORTED_MODULE_6__.getReputationRegistryClient)(resolvedChainId);\n        return reputationClient.appendToFeedback({\n            agentId: agentIdBigInt,\n            clientAddress,\n            feedbackIndex: feedbackIndexBigInt,\n            responseUri,\n            responseHash\n        });\n    }\n    /**\n     * Get the ENS client singleton\n     * @returns The ENS client instance\n     */ async getENSClient() {\n        const { getENSClient } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./ensClient */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/singletons/ensClient.js\"));\n        return await getENSClient();\n    }\n    async getDiscoveryClient() {\n        const { getDiscoveryClient } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./discoveryClient */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/singletons/discoveryClient.js\"));\n        return await getDiscoveryClient();\n    }\n    /**\n     * Search validation requests for an agent using GraphQL\n     */ async searchValidationRequestsAdvanced(params) {\n        const { getDiscoveryClient } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./discoveryClient */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/singletons/discoveryClient.js\"));\n        const discoveryClient = await getDiscoveryClient();\n        if (!discoveryClient || typeof discoveryClient.searchValidationRequestsAdvanced !== 'function') {\n            return null;\n        }\n        return await discoveryClient.searchValidationRequestsAdvanced(params);\n    }\n    /**\n     * Search feedback for an agent using GraphQL\n     */ async searchFeedbackAdvanced(params) {\n        const { getDiscoveryClient } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./discoveryClient */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/singletons/discoveryClient.js\"));\n        const discoveryClient = await getDiscoveryClient();\n        if (!discoveryClient || typeof discoveryClient.searchFeedbackAdvanced !== 'function') {\n            return null;\n        }\n        return await discoveryClient.searchFeedbackAdvanced(params);\n    }\n    /**\n     * Verify a signed challenge\n     * Handles all Veramo agent logic internally - no Veramo exposure at app level\n     *\n     * @param auth - The authentication challenge with signature\n     * @param expectedAudience - Expected audience (provider URL) for validation\n     * @returns Verification result with client address if valid\n     */ async verifyChallenge(auth, expectedAudience) {\n        return this.veramo.verifyChallenge(auth, expectedAudience);\n    }\n    /**\n     * Initialize reputation client from session package\n     * Uses environment variables only (no overrides allowed)\n     * @internal\n     */ async initializeReputationFromSessionPackage(config) {\n        console.log(' initializeReputationFromSessionPackage: Starting...');\n        const { loadSessionPackage, buildDelegationSetup, buildAgentAccountFromSession } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ../lib/sessionPackage */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/lib/sessionPackage.js\"));\n        // Load session package\n        const sessionPackage = config.package || loadSessionPackage(config.filePath);\n        // buildDelegationSetup uses env vars only (no overrides)\n        const delegationSetup = buildDelegationSetup(sessionPackage);\n        // Build agent account from session\n        console.log(' initializeReputationFromSessionPackage: Building agent account from session package...');\n        const agentAccount = await buildAgentAccountFromSession(sessionPackage);\n        // Create wallet client\n        console.log(' initializeReputationFromSessionPackage: Creating wallet client...');\n        console.log(\"agentAccount inside initializeReputationFromSessionPackage -----> \", agentAccount.address);\n        const { createWalletClient, http: httpTransport } = await Promise.all(/*! import() */[__webpack_require__.e(\"vendor-chunks/viem\"), __webpack_require__.e(\"vendor-chunks/abitype\")]).then(__webpack_require__.bind(__webpack_require__, /*! viem */ \"(rsc)/../../node_modules/viem/_esm/index.js\"));\n        const walletClient = createWalletClient({\n            account: agentAccount,\n            chain: delegationSetup.chain,\n            transport: httpTransport(delegationSetup.rpcUrl)\n        });\n        const reputationRegistry = this.config.reputationRegistry;\n        if (!reputationRegistry) {\n            throw new Error('reputationRegistry is required. Set AGENTIC_TRUST_REPUTATION_REGISTRY environment variable.');\n        }\n        const identityRegistry = this.config.identityRegistry;\n        if (!identityRegistry) {\n            throw new Error('identityRegistry is required. Set AGENTIC_TRUST_IDENTITY_REGISTRY environment variable.');\n        }\n    }\n    /**\n     * Initialize reputation client from top-level config (identityRegistry and reputationRegistry)\n     * Uses the EOA (Externally Owned Account) derived from the private key\n     * @internal\n     */ async initializeClientReputationFromConfig(config) {\n        console.log(' initializeReputationFromConfig: Starting...');\n        const identityRegistry = config.identityRegistry;\n        const reputationRegistry = config.reputationRegistry;\n        if (!identityRegistry || !reputationRegistry) {\n            throw new Error('identityRegistry and reputationRegistry are required. Set AGENTIC_TRUST_IDENTITY_REGISTRY and AGENTIC_TRUST_REPUTATION_REGISTRY environment variables.');\n        }\n        const rpcUrl = config.rpcUrl;\n        if (!rpcUrl) {\n            throw new Error('RPC URL is required. Set AGENTIC_TRUST_RPC_URL environment variable.');\n        }\n        // Get ENS registry (optional, but recommended)\n        const ensRegistry = config.sessionPackage?.ensRegistry || (0,_lib_chainConfig__WEBPACK_IMPORTED_MODULE_8__.getChainEnvVar)('AGENTIC_TRUST_ENS_REGISTRY', _lib_chainConfig__WEBPACK_IMPORTED_MODULE_8__.DEFAULT_CHAIN_ID) || undefined;\n        if (!ensRegistry) {\n            console.log(' ENS registry not provided. which might be ok.');\n        }\n        // Try to get AccountProvider from AdminApp or ClientApp (supports wallet providers)\n        // If not available, fall back to privateKey-based creation\n        let accountProvider;\n        let eoaAddress;\n        // Try AdminApp first (for admin operations) if this process has admin role\n        if ((0,_userApps_userApp__WEBPACK_IMPORTED_MODULE_9__.isUserAppEnabled)('admin')) {\n            try {\n                const { getAdminApp } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ../userApps/adminApp */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/userApps/adminApp.js\"));\n                const adminApp = await getAdminApp();\n                if (adminApp && adminApp.accountProvider) {\n                    // Use AdminApp's AccountProvider (works with private key OR wallet provider)\n                    accountProvider = adminApp.accountProvider; // For admin, agent and client are the same\n                    eoaAddress = adminApp.address;\n                    console.log(' initializeReputationFromConfig: Using AdminApp AccountProvider', eoaAddress);\n                }\n            } catch (error) {\n                // AdminApp not available, try ClientApp\n                console.log(' initializeReputationFromConfig: AdminApp not available, trying ClientApp...');\n            }\n        } else {\n            // Skip AdminApp for non-admin apps (web, provider, etc.)\n            console.log(' initializeReputationFromConfig: Skipping AdminApp (no admin role), trying ClientApp...');\n        }\n        // Try ClientApp if AdminApp didn't work\n        if (!accountProvider) {\n            try {\n                const { getClientApp } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ../userApps/clientApp */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/userApps/clientApp.js\"));\n                const clientApp = await getClientApp();\n                if (clientApp && clientApp.accountProvider) {\n                    // Use ClientApp's AccountProvider\n                    const { ViemAccountProvider } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! @agentic-trust/8004-sdk */ \"(rsc)/../../node_modules/@agentic-trust/8004-sdk/dist/index.js\"));\n                    accountProvider = new ViemAccountProvider({\n                        publicClient: clientApp.publicClient,\n                        walletClient: clientApp.walletClient,\n                        account: clientApp.account,\n                        chainConfig: {\n                            id: clientApp.publicClient.chain?.id || 11155111,\n                            rpcUrl: clientApp.publicClient.transport?.url || '',\n                            name: clientApp.publicClient.chain?.name || 'Unknown',\n                            chain: clientApp.publicClient.chain || undefined\n                        }\n                    });\n                    accountProvider = clientApp.accountProvider;\n                    eoaAddress = clientApp.address;\n                    console.log(' initializeReputationFromConfig: Using ClientApp AccountProvider', eoaAddress);\n                }\n            } catch (error) {\n                // ClientApp not available, fall back to privateKey\n                console.log(' initializeReputationFromConfig: ClientApp not available, falling back to privateKey...');\n            }\n        }\n        // Fall back to privateKey-based creation if no wallet/app available\n        if (!accountProvider && config.privateKey) {\n            console.log(' initializeReputationFromConfig: Creating AccountProvider from privateKey...');\n            // Normalize private key (same logic as veramoFactory)\n            let cleanedKey = config.privateKey.trim().replace(/\\s+/g, '');\n            if (cleanedKey.startsWith('0x')) {\n                cleanedKey = cleanedKey.slice(2);\n            }\n            if (!/^[0-9a-fA-F]{64}$/.test(cleanedKey)) {\n                throw new Error('Invalid private key format');\n            }\n            const normalizedKey = `0x${cleanedKey}`;\n            // Create account from private key\n            const { privateKeyToAccount } = await Promise.all(/*! import() */[__webpack_require__.e(\"vendor-chunks/viem\"), __webpack_require__.e(\"vendor-chunks/@noble\")]).then(__webpack_require__.bind(__webpack_require__, /*! viem/accounts */ \"(rsc)/../../node_modules/viem/_esm/accounts/index.js\"));\n            const account = privateKeyToAccount(normalizedKey);\n            eoaAddress = account.address;\n            // Create public and wallet clients\n            const { createPublicClient, createWalletClient, http: httpTransport } = await Promise.all(/*! import() */[__webpack_require__.e(\"vendor-chunks/viem\"), __webpack_require__.e(\"vendor-chunks/abitype\")]).then(__webpack_require__.bind(__webpack_require__, /*! viem */ \"(rsc)/../../node_modules/viem/_esm/index.js\"));\n            const { sepolia } = await __webpack_require__.e(/*! import() */ \"vendor-chunks/viem\").then(__webpack_require__.bind(__webpack_require__, /*! viem/chains */ \"(rsc)/../../node_modules/viem/_esm/chains/index.js\"));\n            const publicClient = createPublicClient({\n                chain: sepolia,\n                transport: httpTransport(rpcUrl)\n            });\n            const walletClient = createWalletClient({\n                account,\n                chain: sepolia,\n                transport: httpTransport(rpcUrl)\n            });\n            // Create AccountProviders\n            const { ViemAccountProvider } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! @agentic-trust/8004-sdk */ \"(rsc)/../../node_modules/@agentic-trust/8004-sdk/dist/index.js\"));\n            accountProvider = new ViemAccountProvider({\n                publicClient,\n                walletClient,\n                account,\n                chainConfig: {\n                    id: sepolia.id,\n                    rpcUrl,\n                    name: sepolia.name,\n                    chain: sepolia\n                }\n            });\n            console.log(' initializeReputationFromConfig: Using EOA from private key', eoaAddress);\n        }\n        // If we still don't have AccountProviders, throw error\n        if (!accountProvider) {\n            throw new Error('Cannot initialize reputation client: No wallet available. ' + 'Provide either:\\n' + '  1. Wallet connection (MetaMask/Web3Auth) - AdminApp will be used\\n' + '  2. Private key via AGENTIC_TRUST_ADMIN_PRIVATE_KEY or config.privateKey\\n' + '  3. ClientApp initialization (add \"client\" to AGENTIC_TRUST_APP_ROLES)');\n        }\n        // Create the reputation client using the AccountProviders\n        // The AccountProviders can be from AdminApp (wallet provider), ClientApp, or created from privateKey\n        const { AIAgentReputationClient } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! @agentic-trust/8004-ext-sdk */ \"(rsc)/../../node_modules/@agentic-trust/8004-ext-sdk/dist/index.js\"));\n        const reputationClient = await AIAgentReputationClient.create(accountProvider, identityRegistry, reputationRegistry, ensRegistry || '0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e' // Default ENS registry on Sepolia\n        );\n        // Store the reputation client in the singleton\n        // Import the singleton module and set it directly\n        //const reputationClientModule = await import('./reputationClient');\n        // Access the singleton instance variable (we need to export a setter or access it)\n        // For now, we'll use a workaround - the singleton will be initialized when getReputationRegistryClient is called\n        // But we've created the client here, so future calls to getReputationRegistryClient should use the singleton's logic\n        // Actually, the singleton pattern creates its own instance, so we need to either:\n        // 1. Store this instance somewhere accessible to the singleton, or\n        // 2. Make sure the singleton uses the same adapters\n        // Since the singleton recreates the client, we need to ensure it uses the same adapters\n        // The singleton logic in reputationClient.ts will use getAdminApp/getClientApp which should return the same adapters\n        // So the singleton should work correctly\n        console.log(' initializeReputationFromConfig: Reputation client created with walletClient/adapter', eoaAddress);\n    }\n    /**\n     * Execute a GraphQL query\n     */ async query(query, variables) {\n        return this.graphQLClient.request(query, variables);\n    }\n    /**\n     * Execute a GraphQL mutation\n     */ async mutate(mutation, variables) {\n        return this.graphQLClient.request(mutation, variables);\n    }\n    /**\n     * Get the underlying GraphQL client (for advanced usage)\n     */ getGraphQLClient() {\n        return this.graphQLClient;\n    }\n    /**\n     * Update the API key and recreate the client\n     */ setApiKey(apiKey) {\n        this.config.apiKey = apiKey;\n        const graphQLUrl = this.config.graphQLUrl || '';\n        // Recreate client with new API key\n        const endpoint = graphQLUrl.endsWith('/graphql') ? graphQLUrl : `${graphQLUrl.replace(/\\/$/, '')}/graphql`;\n        const headers = {\n            'Content-Type': 'application/json',\n            Accept: 'application/json',\n            Authorization: `Bearer ${apiKey}`,\n            ...this.config.headers\n        };\n        this.graphQLClient = new graphql_request__WEBPACK_IMPORTED_MODULE_0__.GraphQLClient(endpoint, {\n            headers\n        });\n        // Recreate APIs with new client (keep existing Veramo connection)\n        this.agents = new _lib_agents__WEBPACK_IMPORTED_MODULE_1__.AgentsAPI(this);\n        this.a2aProtocolProvider = new _lib_a2aProtocolProvider__WEBPACK_IMPORTED_MODULE_2__.A2AProtocolProviderAPI(this.graphQLClient);\n    }\n    /**\n     * Get current configuration\n     */ getConfig() {\n        return {\n            ...this.config\n        };\n    }\n    /**\n   * Get the admin EOA address derived from AGENTIC_TRUST_ADMIN_PRIVATE_KEY\n   * @returns The admin's Ethereum address\n   * @throws Error if AGENTIC_TRUST_ADMIN_PRIVATE_KEY is not set or invalid\n   */ async getAdminEOAAddress() {\n        const privateKey = process.env.AGENTIC_TRUST_ADMIN_PRIVATE_KEY;\n        if (!privateKey) {\n            throw new Error('AGENTIC_TRUST_ADMIN_PRIVATE_KEY environment variable is required');\n        }\n        const { privateKeyToAccount } = await Promise.all(/*! import() */[__webpack_require__.e(\"vendor-chunks/viem\"), __webpack_require__.e(\"vendor-chunks/@noble\")]).then(__webpack_require__.bind(__webpack_require__, /*! viem/accounts */ \"(rsc)/../../node_modules/viem/_esm/accounts/index.js\"));\n        const normalizedKey = privateKey.startsWith('0x') ? privateKey : `0x${privateKey}`;\n        const account = privateKeyToAccount(normalizedKey);\n        return account.address;\n    }\n} //# sourceMappingURL=agenticTrustClient.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BhZ2VudGljLXRydXN0L2NvcmUvZGlzdC9zZXJ2ZXIvc2luZ2xldG9ucy9hZ2VudGljVHJ1c3RDbGllbnQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7R0FJRyxDQUU2QztBQUVOO0FBRTBCO0FBQzRCO0FBR3JEO0FBQ1k7QUFDZ0U7QUFDOUM7QUFDUDtBQUdYO0FBQ1c7QUFDSTtBQUNoQjtBQUVtRjtBQUU5RTtBQVEzRCxNQUFNLHFCQUFxQixHQUFHLHVCQUF1QixDQUFDO0FBQ3RELE1BQU0seUJBQXlCLEdBQzdCLGtFQUFrRSxDQUFDO0FBRXJFLDBFQUEwRTtBQUMxRSxNQUFNLDJCQUEyQixHQUMvQjtJQUNFLFFBQVEsRUFBRTtRQUNSLGdCQUFnQixFQUFFLDRDQUE0QztRQUM5RCxrQkFBa0IsRUFBRSw0Q0FBNEM7S0FDakU7SUFDRCxLQUFLLEVBQUU7UUFDTCxnQkFBZ0IsRUFBRSw0Q0FBNEM7UUFDOUQsa0JBQWtCLEVBQUUsNENBQTRDO0tBQ2pFO0NBQ0YsQ0FBQztBQUVKLFNBQVMsV0FBVyxDQUFDLEtBQXlCO0lBQzVDLE1BQU0sQ0FBQyxHQUFHLE1BQU0sQ0FBQyxLQUFLLElBQUksRUFBRSxDQUFDLENBQUMsSUFBSSxFQUFFLENBQUM7SUFDckMsSUFBSSxDQUFDLENBQUMsRUFBRSxPQUFPLFNBQVMsQ0FBQztJQUN6QixNQUFNLE1BQU0sR0FBRyxDQUFDLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUM7SUFDakQsSUFBSSxDQUFDLHFCQUFxQixDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRSxPQUFPLFNBQVMsQ0FBQztJQUMxRCxPQUFPLE1BQXVCLENBQUM7QUFDakMsQ0FBQztBQXNDSyxNQUFPLGtCQUFrQjtJQVM3QixZQUNFLGNBVUs7UUFFTCxNQUFNLE1BQU0sR0FDVixTQUFTLElBQUssY0FBc0IsR0FDaEMsQ0FBQyxHQUFHLEVBQUU7WUFDSixNQUFNLE1BQU0sR0FBRyxjQVFkLENBQUM7WUFFRixNQUFNLE9BQU8sR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1lBQ3ZDLElBQUksQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxFQUFFLENBQUM7Z0JBQzlCLE1BQU0sSUFBSSxLQUFLLENBQUMscUJBQXFCLENBQUMsQ0FBQztZQUN6QyxDQUFDO1lBRUQsTUFBTSxXQUFXLEdBQUcsV0FBVyxDQUFDLGdFQUFjLENBQUMsaUNBQWlDLEVBQUUsT0FBTyxDQUFDLENBQUMsQ0FBQztZQUM1RixNQUFNLGFBQWEsR0FBRyxXQUFXLENBQUMsZ0VBQWMsQ0FBQyxtQ0FBbUMsRUFBRSxPQUFPLENBQUMsQ0FBQyxDQUFDO1lBQ2hHLE1BQU0sS0FBSyxHQUFHLDJCQUEyQixDQUFDLE9BQU8sQ0FBQyxDQUFDO1lBRW5ELE1BQU0sZ0JBQWdCLEdBQ3BCLE1BQU0sQ0FBQyxnQkFBZ0IsSUFBSSxXQUFXLElBQUksS0FBSyxFQUFFLGdCQUFnQixDQUFDO1lBQ3BFLE1BQU0sa0JBQWtCLEdBQ3RCLE1BQU0sQ0FBQyxrQkFBa0IsSUFBSSxhQUFhLElBQUksS0FBSyxFQUFFLGtCQUFrQixDQUFDO1lBRTFFLElBQUksQ0FBQyxnQkFBZ0IsSUFBSSxDQUFDLGtCQUFrQixFQUFFLENBQUM7Z0JBQzdDLE1BQU0sSUFBSSxLQUFLLENBQ2Isa0RBQWtELE9BQU8sSUFBSSxHQUMzRCxnRUFBZ0UsR0FDaEUsd0ZBQXdGLENBQzNGLENBQUM7WUFDSixDQUFDO1lBRUQsTUFBTSxVQUFVLEdBQUcsQ0FBQyxNQUFNLENBQUMsWUFBWSxJQUFJLHNCQUFxQixDQUFDLElBQUssRUFBRSxDQUFDO1lBQ3pFLE1BQU0sTUFBTSxHQUFHLENBQUMsTUFBTSxDQUFDLGVBQWUsSUFBSSwwQkFBeUIsQ0FBQyxJQUFLLEVBQUUsQ0FBQztZQUU1RSxPQUFPO2dCQUNMLFVBQVU7Z0JBQ1YsTUFBTTtnQkFDTixVQUFVLEVBQUUsTUFBTSxDQUFDLE1BQU0sQ0FBQyxVQUFVLElBQUksRUFBRSxDQUFDLENBQUMsSUFBSSxFQUFFO2dCQUNsRCxNQUFNLEVBQUUsTUFBTSxDQUFDLE1BQU0sQ0FBQyxNQUFNLElBQUksRUFBRSxDQUFDLENBQUMsSUFBSSxFQUFFO2dCQUMxQyxnQkFBZ0I7Z0JBQ2hCLGtCQUFrQjthQUNPLENBQUM7U0FDOUIsQ0FBQyxDQUFDLEVBQUUsRUFDSCxjQUFrQyxDQUFDO1FBRTFDLElBQUksQ0FBQyxNQUFNLEdBQUc7WUFBRSxHQUFHLE1BQU07UUFBQSxDQUFFLENBQUM7UUFFNUIsaUNBQWlDO1FBQ2pDLElBQUksQ0FBQyxNQUFNLENBQUMsVUFBVSxFQUFFLENBQUM7WUFDdkIsTUFBTSxJQUFJLEtBQUssQ0FDYiw2Q0FBNkMsR0FDN0MsNkZBQTZGLENBQzlGLENBQUM7UUFDSixDQUFDO1FBRUQsTUFBTSxRQUFRLEdBQUcsTUFBTSxDQUFDLFVBQVUsQ0FBQyxRQUFRLENBQUMsVUFBVSxDQUFDLEdBQ25ELE1BQU0sQ0FBQyxVQUFVLEdBQ2pCLEdBQUcsTUFBTSxDQUFDLFVBQVUsQ0FBQyxPQUFPLENBQUMsS0FBSyxFQUFFLEVBQUUsQ0FBQyxVQUFVLENBQUM7UUFFdEQsZ0JBQWdCO1FBQ2hCLE1BQU0sT0FBTyxHQUEyQjtZQUN0QyxjQUFjLEVBQUUsa0JBQWtCO1lBQ2xDLE1BQU0sRUFBRSxrQkFBa0I7WUFDMUIsR0FBRyxNQUFNLENBQUMsT0FBTztTQUNsQixDQUFDO1FBRUYsMEJBQTBCO1FBQzFCLElBQUksTUFBTSxDQUFDLE1BQU0sRUFBRSxDQUFDO1lBQ2xCLE9BQU8sQ0FBQyxlQUFlLENBQUMsR0FBRyxVQUFVLE1BQU0sQ0FBQyxNQUFNLEVBQUUsQ0FBQztRQUN2RCxDQUFDO1FBRUQsd0JBQXdCO1FBQ3hCLElBQUksQ0FBQyxhQUFhLEdBQUcsSUFBSSwwREFBYSxDQUFDLFFBQVEsRUFBRTtZQUMvQyxPQUFPO1NBQ1IsQ0FBQyxDQUFDO1FBRUgsa0VBQWtFO1FBQ2xFLHdFQUF3RTtRQUN4RSwwREFBMEQ7UUFDMUQsdU1BQTJCLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRSxrQkFBa0IsRUFBRSxFQUFFLEVBQUU7WUFDMUQsa0JBQWtCLENBQUM7Z0JBQ2pCLFFBQVE7Z0JBQ1IsTUFBTSxFQUFFLE1BQU0sQ0FBQyxNQUFNO2dCQUNyQixPQUFPLEVBQUUsTUFBTSxDQUFDLE9BQU87YUFDeEIsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLEtBQUssRUFBRSxFQUFFO2dCQUNqQixPQUFPLENBQUMsSUFBSSxDQUFDLGlEQUFpRCxFQUFFLEtBQUssQ0FBQyxDQUFDO1lBQ3pFLENBQUMsQ0FBQyxDQUFDO1FBQ0wsQ0FBQyxDQUFDLENBQUM7UUFFSCw0QkFBNEI7UUFDNUIsSUFBSSxDQUFDLE1BQU0sR0FBRyxJQUFJLGtEQUFTLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDbEMsSUFBSSxDQUFDLG1CQUFtQixHQUFHLElBQUksNEVBQXNCLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxDQUFDO1FBQzFFLElBQUksQ0FBQyxNQUFNLEdBQUcsSUFBSSxrREFBUyxFQUFFLENBQUM7UUFFOUIsNkVBQTZFO1FBQzdFLDhEQUE4RDtRQUM5RCxJQUFJLENBQUMsS0FBSyxHQUFHLENBQUMsS0FBSyxJQUFJLEVBQUU7WUFDdkIsZ0dBQWdHO1lBQ2hHLE1BQU0sSUFBSSxDQUFDLHFCQUFxQixDQUFDLE1BQU0sQ0FBQyxDQUFDO1lBRXpDLHFEQUFxRDtZQUNyRCxvR0FBb0c7WUFDcEcsSUFBSSxNQUFNLENBQUMsY0FBYyxFQUFFLENBQUM7Z0JBQzFCLE9BQU8sQ0FBQyxHQUFHLENBQUMsNERBQTRELENBQUMsQ0FBQztnQkFDMUUsTUFBTSxJQUFJLENBQUMsc0NBQXNDLENBQy9DLE1BQU0sQ0FBQyxjQUE2RixDQUNyRyxDQUFDO1lBQ0osQ0FBQyxNQUFNLElBQUksTUFBTSxDQUFDLGdCQUFnQixJQUFJLE1BQU0sQ0FBQyxrQkFBa0IsRUFBRSxDQUFDO2dCQUNoRSx3RkFBd0Y7Z0JBQ3hGLDZEQUE2RDtnQkFDN0Qsc0VBQXNFO2dCQUN0RSxJQUFJLE1BQU0sQ0FBQyxVQUFVLEVBQUUsQ0FBQztvQkFDdEIsT0FBTyxDQUFDLEdBQUcsQ0FBQyw2REFBNkQsQ0FBQyxDQUFDO29CQUMzRSxNQUFNLElBQUksQ0FBQyxvQ0FBb0MsQ0FBQyxNQUFNLENBQUMsQ0FBQztnQkFDMUQsQ0FBQztZQUNILENBQUM7WUFFRCwrREFBK0Q7WUFDL0QsZ0VBQWdFO1lBQ2hFLE1BQU0sY0FBYyxHQUFHLDhEQUFnQixDQUFDO1lBQ3hDLElBQUksQ0FBQztnQkFDSCxNQUFNLE9BQU8sQ0FBQyxVQUFVLENBQUM7b0JBQ3ZCLG9FQUFrQixFQUFFO29CQUNwQix3REFBWSxDQUFDLGNBQWMsQ0FBQztvQkFDNUIscUZBQXlCLENBQUMsY0FBYyxDQUFDO29CQUN6Qyw4RUFBMkIsQ0FBQyxjQUFjLENBQUM7aUJBQzVDLENBQUMsQ0FBQztZQUNMLENBQUMsQ0FBQyxPQUFNLENBQUM7WUFDUCw0REFBNEQ7WUFDNUQsOERBQThEO1lBQ2hFLENBQUM7U0FDSCxDQUFDLENBQUMsRUFBRTtJQUNOLENBQUM7SUFFRDs7O09BR0csQ0FDSyxLQUFLLENBQUMscUJBQXFCLENBQUMsTUFBdUI7UUFHekQsSUFBSSxNQUFNLENBQUMsV0FBVyxFQUFFLENBQUM7WUFDdkIscUJBQXFCO1lBQ3JCLElBQUksQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxXQUFXLENBQUMsQ0FBQztRQUMxQyxDQUFDLE1BQU0sQ0FBQztZQUVOLDBCQUEwQjtZQUMxQixNQUFNLEtBQUssR0FBRyxNQUFNLCtFQUEwQixDQUM1QyxNQUFNLENBQUMsVUFBVSxFQUNqQixNQUFNLENBQUMsTUFBTSxDQUNkLENBQUM7WUFDRixJQUFJLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUM3QixDQUFDO0lBQ0gsQ0FBQztJQUVEOztPQUVHLENBQ0gsTUFBTSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsTUFBdUI7UUFDekMsTUFBTSxNQUFNLEdBQUcsSUFBSSxrQkFBa0IsQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUM5QyxNQUFNLE1BQU0sQ0FBQyxLQUFLLENBQUM7UUFDbkIsT0FBTyxNQUFNLENBQUM7SUFDaEIsQ0FBQztJQUVELDhGQUE4RixDQUM5RixNQUFNLENBQUMsS0FBSyxDQUFDLGtCQUFrQixDQUFDLE1BUS9CO1FBQ0MsTUFBTSxNQUFNLEdBQUcsSUFBSSxrQkFBa0IsQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUM5QyxNQUFNLE1BQU0sQ0FBQyxLQUFLLENBQUM7UUFDbkIsT0FBTyxNQUFNLENBQUM7SUFDaEIsQ0FBQztJQUVEOzs7O09BSUcsQ0FDSCxLQUFLLENBQUMsWUFBWSxDQUNoQixPQUF3QztRQUV4QyxPQUFPLElBQUksQ0FBQyxNQUFNLENBQUMsWUFBWSxDQUFDLE9BQWMsQ0FBQyxDQUFDO0lBQ2xELENBQUM7SUFFRDs7OztPQUlHLENBQ0gsS0FBSyxDQUFDLGtCQUFrQixDQUFDLE1BQXlCO1FBQ2hELE9BQU8sdUVBQWtCLENBQUMsTUFBTSxDQUFDLENBQUM7SUFDcEMsQ0FBQztJQUVEOzs7T0FHRyxDQUNILEtBQUssQ0FBQyxnQ0FBZ0MsQ0FDcEMsTUFBeUI7UUFFekIsT0FBTyxxRkFBZ0MsQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUNsRCxDQUFDO0lBRUQ7Ozs7Ozs7Ozs7OztPQVlHLENBQ0gsS0FBSyxDQUFDLGdCQUFnQixDQUFDLE1BU3RCO1FBQ0MsTUFBTSxFQUNKLE9BQU8sRUFDUCxPQUFPLEVBQ1AsZUFBZSxFQUNmLElBQUksRUFDSixJQUFJLEVBQ0osY0FBYyxHQUFHLEtBQUssRUFDdEIsS0FBSyxFQUNMLE1BQU0sRUFDUCxHQUFHLE1BQU0sQ0FBQztRQUVYLE1BQU0sT0FBTyxHQUFHLENBQUMsT0FBTyxJQUFJLEdBQUUsQ0FBQyxRQUFTLEVBQUUsQ0FBQyxJQUFJLEVBQUUsQ0FBQztRQUNsRCxJQUFJLENBQUMsT0FBTyxFQUFFLENBQUM7WUFDYixNQUFNLElBQUksS0FBSyxDQUFDLDBDQUEwQyxDQUFDLENBQUM7UUFDOUQsQ0FBQztRQUVELE1BQU0sZUFBZSxHQUNuQixNQUFNLENBQUMsUUFBUSxDQUFDLE9BQU8sSUFBSSxHQUFHLENBQUMsSUFBSSxDQUFDLE9BQU8sS0FBSSxDQUFDLENBQUMsRUFBRyxDQUFDLEdBQ2hELE9BQWtCLEdBQ25CLDhEQUFnQixDQUFDO1FBRXZCLElBQUksYUFBcUIsQ0FBQztRQUMxQixJQUFJLENBQUM7WUFDSCxhQUFhLEdBQUcsTUFBTSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBQ2xDLENBQUMsQ0FBQyxPQUFNLENBQUM7WUFDUCxNQUFNLElBQUksS0FBSyxDQUFDLHlDQUF5QyxPQUFPLEVBQUUsQ0FBQyxDQUFDO1FBQ3RFLENBQUM7UUFFRCwrREFBK0Q7UUFDL0QsSUFBSSxDQUFDO1lBQ0gsTUFBTSxlQUFlLEdBQUcsTUFBTSxvRUFBa0IsRUFBRSxDQUFDO1lBRW5ELE1BQU0sS0FBSyxHQUFHOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0E4QmIsQ0FBQztZQUVGLE1BQU0sU0FBUyxHQUE0QjtnQkFDekMsS0FBSyxFQUFFO29CQUNMLE9BQU8sRUFBRSxPQUFPO29CQUNoQixPQUFPLEVBQUUsZUFBZTtpQkFDekI7Z0JBQ0QsS0FBSyxFQUFFLE9BQU8sS0FBSyxLQUFLLFFBQVEsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxHQUFHO2dCQUM5QyxJQUFJLEVBQUUsT0FBTyxNQUFNLEtBQUssUUFBUSxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUM7YUFDOUMsQ0FBQztZQUVGLE1BQU0sTUFBTSxHQUFHLE1BQU0sZUFBZSxDQUFDLE9BQU8sQ0FNekMsS0FBSyxFQUFFLFNBQVMsQ0FBQyxDQUFDO1lBRXJCLElBQUksTUFBTSxJQUFLLE1BQWMsQ0FBQyxvQkFBb0IsRUFBRSxDQUFDO2dCQUNuRCxNQUFNLElBQUksR0FBSSxNQUFjLENBQUMsb0JBQW9CLENBQUM7Z0JBQ2xELE1BQU0sSUFBSSxHQUFHLEtBQUssQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUM7Z0JBQ2pFLE9BQU8sSUFBaUIsQ0FBQztZQUMzQixDQUFDO1FBQ0gsQ0FBQyxDQUFDLE9BQU8sS0FBSyxFQUFFLENBQUM7WUFDZixPQUFPLENBQUMsSUFBSSxDQUNWLG1IQUFtSCxFQUNuSCxLQUFLLENBQ04sQ0FBQztRQUNKLENBQUM7UUFFRCwyREFBMkQ7UUFDM0QsTUFBTSxnQkFBZ0IsR0FBRyxNQUFNLDhFQUEyQixDQUFDLGVBQWUsQ0FBQyxDQUFDO1FBQzVFLE1BQU0sR0FBRyxHQUFHLE1BQU8sZ0JBQXdCLENBQUMsZUFBZSxDQUN6RCxhQUFhLEVBQ2IsZUFBZSxFQUNmLElBQUksRUFDSixJQUFJLEVBQ0osY0FBYyxDQUNmLENBQUM7UUFFRixNQUFNLE9BQU8sR0FBYSxHQUFHLEVBQUUsZUFBZSxJQUFJLEVBQUUsQ0FBQztRQUNyRCxNQUFNLE1BQU0sR0FBYSxHQUFHLEVBQUUsTUFBTSxJQUFJLEVBQUUsQ0FBQztRQUMzQyxNQUFNLEtBQUssR0FBYSxHQUFHLEVBQUUsS0FBSyxJQUFJLEVBQUUsQ0FBQztRQUN6QyxNQUFNLEtBQUssR0FBYSxHQUFHLEVBQUUsS0FBSyxJQUFJLEVBQUUsQ0FBQztRQUN6QyxNQUFNLGVBQWUsR0FBYyxHQUFHLEVBQUUsZUFBZSxJQUFJLEVBQUUsQ0FBQztRQUU5RCxNQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsR0FBRyxDQUNyQixPQUFPLENBQUMsTUFBTSxFQUNkLE1BQU0sQ0FBQyxNQUFNLEVBQ2IsS0FBSyxDQUFDLE1BQU0sRUFDWixLQUFLLENBQUMsTUFBTSxFQUNaLGVBQWUsQ0FBQyxNQUFNLENBQ3ZCLENBQUM7UUFFRixNQUFNLE9BQU8sR0FBYyxFQUFFLENBQUM7UUFDOUIsSUFBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLE1BQU0sRUFBRSxDQUFDLEVBQUUsQ0FBRSxDQUFDO1lBQ2hDLE9BQU8sQ0FBQyxJQUFJLENBQUM7Z0JBQ1gsT0FBTyxFQUFFLE9BQU87Z0JBQ2hCLE9BQU8sRUFBRSxlQUFlO2dCQUN4QixhQUFhLEVBQUUsT0FBTyxDQUFDLENBQUMsQ0FBQztnQkFDekIsS0FBSyxFQUFFLE1BQU0sQ0FBQyxDQUFDLENBQUM7Z0JBQ2hCLElBQUksRUFBRSxLQUFLLENBQUMsQ0FBQyxDQUFDO2dCQUNkLElBQUksRUFBRSxLQUFLLENBQUMsQ0FBQyxDQUFDO2dCQUNkLFNBQVMsRUFBRSxlQUFlLENBQUMsQ0FBQyxDQUFDO2dCQUM3QixLQUFLLEVBQUUsQ0FBQzthQUNULENBQUMsQ0FBQztRQUNMLENBQUM7UUFFRCxPQUFPLE9BQU8sQ0FBQztJQUNqQixDQUFDO0lBRUQ7OztPQUdHLENBQ0gsS0FBSyxDQUFDLG9CQUFvQixDQUFDLE1BTTFCO1FBQ0MsTUFBTSxFQUFFLE9BQU8sRUFBRSxPQUFPLEVBQUUsZUFBZSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsR0FBRyxNQUFNLENBQUM7UUFFakUsTUFBTSxPQUFPLEdBQUcsQ0FBQyxPQUFPLElBQUksR0FBRSxDQUFDLFFBQVMsRUFBRSxDQUFDLElBQUksRUFBRSxDQUFDO1FBQ2xELElBQUksQ0FBQyxPQUFPLEVBQUUsQ0FBQztZQUNiLE1BQU0sSUFBSSxLQUFLLENBQUMsOENBQThDLENBQUMsQ0FBQztRQUNsRSxDQUFDO1FBRUQsTUFBTSxlQUFlLEdBQ25CLE1BQU0sQ0FBQyxRQUFRLENBQUMsT0FBTyxJQUFJLEdBQUcsQ0FBQyxJQUFJLENBQUMsT0FBTyxLQUFJLENBQUMsQ0FBQyxFQUFHLENBQUMsR0FDaEQsT0FBa0IsR0FDbkIsOERBQWdCLENBQUM7UUFFdkIsSUFBSSxhQUFxQixDQUFDO1FBQzFCLElBQUksQ0FBQztZQUNILGFBQWEsR0FBRyxNQUFNLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDbEMsQ0FBQyxDQUFDLE9BQU0sQ0FBQztZQUNQLE1BQU0sSUFBSSxLQUFLLENBQUMsNkNBQTZDLE9BQU8sRUFBRSxDQUFDLENBQUM7UUFDMUUsQ0FBQztRQUVELE1BQU0sZ0JBQWdCLEdBQUcsTUFBTSw4RUFBMkIsQ0FBQyxlQUFlLENBQUMsQ0FBQztRQUM1RSxPQUFRLGdCQUF3QixDQUFDLFVBQVUsQ0FDekMsYUFBYSxFQUNiLGVBQWUsRUFDZixJQUFJLEVBQ0osSUFBSSxDQUNMLENBQUM7SUFDSixDQUFDO0lBRUQ7OztPQUdHLENBQ0gsS0FBSyxDQUFDLGtCQUFrQixDQUN0QixPQUFlLEVBQ2YsT0FBZ0I7UUFFaEIsTUFBTSxFQUFFLGtCQUFrQixFQUFFLEdBQUcsTUFBTSwyTEFBcUIsQ0FBQztRQUMzRCxPQUFPLGtCQUFrQixDQUFDLE9BQU8sRUFBRSxPQUFPLENBQUMsQ0FBQztJQUM5QyxDQUFDO0lBRUQsS0FBSyxDQUFDLFVBQVUsQ0FDZCxPQUFlLEVBQ2YsT0FBZ0I7UUFVaEIsTUFBTSxFQUFFLFVBQVUsRUFBRSxHQUFHLE1BQU0sMkxBQXFCLENBQUM7UUFDbkQsT0FBTyxVQUFVLENBQUMsT0FBTyxFQUFFLE9BQU8sQ0FBQyxDQUFDO0lBQ3RDLENBQUM7SUFFRCxLQUFLLENBQUMsbUJBQW1CLENBQUMsTUFNekI7UUFDQyxNQUFNLEVBQUUsbUJBQW1CLEVBQUUsR0FBRyxNQUFNLDJMQUFxQixDQUFDO1FBQzVELE9BQU8sbUJBQW1CLENBQUMsTUFBYSxDQUFDLENBQUM7SUFDNUMsQ0FBQztJQUVELEtBQUssQ0FBQyxtQkFBbUIsQ0FBQyxNQVF6QjtRQU9DLE1BQU0sRUFBRSxtQkFBbUIsRUFBRSxHQUFHLE1BQU0sMkxBQXFCLENBQUM7UUFDNUQsT0FBTyxtQkFBbUIsQ0FBQyxNQUFhLENBQUMsQ0FBQztJQUM1QyxDQUFDO0lBRUQ7Ozs7T0FJRyxDQUNILEtBQUssQ0FBQyxnQkFBZ0IsQ0FBQyxNQUl0QjtRQUNDLE1BQU0sRUFBRSxPQUFPLEVBQUUsT0FBTyxFQUFFLFFBQVEsRUFBRSxHQUFHLE1BQU0sQ0FBQztRQUM5QyxJQUFJLENBQUMsUUFBUSxJQUFJLE9BQU8sUUFBUSxLQUFLLFFBQVEsSUFBSSxRQUFRLENBQUMsSUFBSSxFQUFFLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRSxDQUFDO1lBQzlFLE1BQU0sSUFBSSxLQUFLLENBQUMsMkNBQTJDLENBQUMsQ0FBQztRQUMvRCxDQUFDO1FBRUQsTUFBTSxVQUFVLEdBQ2QsT0FBTyxPQUFPLEtBQUssUUFBUSxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsT0FBTyxJQUFJLEVBQUUsQ0FBQyxDQUFDLElBQUksRUFBRSxDQUFDO1FBQ3BGLElBQUksQ0FBQyxVQUFVLEVBQUUsQ0FBQztZQUNoQixNQUFNLElBQUksS0FBSyxDQUFDLDBDQUEwQyxDQUFDLENBQUM7UUFDOUQsQ0FBQztRQUVELE9BQU8sSUFBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsV0FBVyxDQUFDO1lBQ25DLE9BQU8sRUFBRSxVQUFVO1lBQ25CLE9BQU87WUFDUCxRQUFRLEVBQUUsUUFBUTtTQUNuQixDQUFDLENBQUM7SUFDTCxDQUFDO0lBRUQ7OztPQUdHLENBQ0gsS0FBSyxDQUFDLGFBQWEsQ0FBQyxNQUluQjtRQUNDLE1BQU0sRUFBRSxPQUFPLEVBQUUsRUFBRSxFQUFFLE9BQU8sRUFBRSxHQUFHLE1BQU0sQ0FBQztRQUV4QyxNQUFNLFVBQVUsR0FDZCxPQUFPLE9BQU8sS0FBSyxRQUFRLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxPQUFPLElBQUksRUFBRSxDQUFDLENBQUMsSUFBSSxFQUFFLENBQUM7UUFDcEYsSUFBSSxDQUFDLFVBQVUsRUFBRSxDQUFDO1lBQ2hCLE1BQU0sSUFBSSxLQUFLLENBQUMsdUNBQXVDLENBQUMsQ0FBQztRQUMzRCxDQUFDO1FBRUQsSUFBSSxDQUFDLEVBQUUsSUFBSSxPQUFPLEVBQUUsS0FBSyxRQUFRLElBQUksQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsQ0FBQyxNQUFNLEtBQUssRUFBRSxFQUFFLENBQUM7WUFDOUUsTUFBTSxJQUFJLEtBQUssQ0FBQyxrREFBa0QsRUFBRSxFQUFFLENBQUMsQ0FBQztRQUMxRSxDQUFDO1FBRUQsT0FBTyxJQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxhQUFhLENBQUM7WUFDckMsT0FBTyxFQUFFLFVBQVU7WUFDbkIsT0FBTztZQUNQLEVBQUU7U0FDSCxDQUFDLENBQUM7SUFDTCxDQUFDO0lBRUQ7Ozs7OztPQU1HLENBQ0gsS0FBSyxDQUFDLDRCQUE0QixDQUFDLE1BS2xDO1FBQ0MsTUFBTSxFQUFFLE9BQU8sRUFBRSxPQUFPLEVBQUUsU0FBUyxFQUFFLFlBQVksRUFBRSxHQUFHLE1BQU0sQ0FBQztRQUU3RCxNQUFNLFVBQVUsR0FDZCxPQUFPLE9BQU8sS0FBSyxRQUFRLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxPQUFPLElBQUksRUFBRSxDQUFDLENBQUMsSUFBSSxFQUFFLENBQUM7UUFDcEYsSUFBSSxDQUFDLFVBQVUsRUFBRSxDQUFDO1lBQ2hCLE1BQU0sSUFBSSxLQUFLLENBQUMsc0RBQXNELENBQUMsQ0FBQztRQUMxRSxDQUFDO1FBRUQsTUFBTSxRQUFRLEdBQTBDLEVBQUUsQ0FBQztRQUUzRCxJQUFJLFNBQVMsSUFBSSxTQUFTLENBQUMsUUFBUSxFQUFFLENBQUMsSUFBSSxFQUFFLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRSxDQUFDO1lBQ3hELFFBQVEsQ0FBQyxJQUFJLENBQUM7Z0JBQ1osR0FBRyxFQUFFLFdBQVc7Z0JBQ2hCLEtBQUssRUFBRSxTQUFTLENBQUMsUUFBUSxFQUFFLENBQUMsSUFBSSxFQUFFO2FBQ25DLENBQUMsQ0FBQztRQUNMLENBQUM7UUFFRCxJQUFJLFlBQVksSUFBSSxZQUFZLENBQUMsUUFBUSxFQUFFLENBQUMsSUFBSSxFQUFFLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRSxDQUFDO1lBQzlELFFBQVEsQ0FBQyxJQUFJLENBQUM7Z0JBQ1osR0FBRyxFQUFFLGNBQWM7Z0JBQ25CLEtBQUssRUFBRSxZQUFZLENBQUMsUUFBUSxFQUFFLENBQUMsSUFBSSxFQUFFO2FBQ3RDLENBQUMsQ0FBQztRQUNMLENBQUM7UUFFRCxJQUFJLFFBQVEsQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFLENBQUM7WUFDMUIsTUFBTSxJQUFJLEtBQUssQ0FDYiw2RkFBNkYsQ0FDOUYsQ0FBQztRQUNKLENBQUM7UUFFRCxPQUFPLElBQUksQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLFdBQVcsQ0FBQztZQUNuQyxPQUFPLEVBQUUsVUFBVTtZQUNuQixPQUFPO1lBQ1AsUUFBUTtTQUNULENBQUMsQ0FBQztJQUNMLENBQUM7SUFFRDs7O09BR0csQ0FDSCxLQUFLLENBQUMsa0JBQWtCLENBQUMsTUFLeEI7UUFNQyxNQUFNLEVBQUUsT0FBTyxFQUFFLE9BQU8sRUFBRSxRQUFRLEVBQUUsUUFBUSxFQUFFLEdBQUcsTUFBTSxDQUFDO1FBQ3hELE1BQU0sVUFBVSxHQUNkLE9BQU8sT0FBTyxLQUFLLFFBQVEsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLE9BQU8sSUFBSSxFQUFFLENBQUMsQ0FBQyxJQUFJLEVBQUUsQ0FBQztRQUNwRixJQUFJLENBQUMsVUFBVSxFQUFFLENBQUM7WUFDaEIsTUFBTSxJQUFJLEtBQUssQ0FBQyw0Q0FBNEMsQ0FBQyxDQUFDO1FBQ2hFLENBQUM7UUFFRCxPQUFPLElBQUksQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLGtCQUFrQixDQUFDO1lBQzFDLE9BQU8sRUFBRSxVQUFVO1lBQ25CLE9BQU87WUFDUCxRQUFRO1lBQ1IsUUFBUTtTQUNGLENBQUMsQ0FBQztJQUNaLENBQUM7SUFFRCxLQUFLLENBQUMsMkJBQTJCLENBQUMsTUFPakM7UUFPQyxNQUFNLEVBQUUsMkJBQTJCLEVBQUUsR0FBRyxNQUFNLDJMQUFxQixDQUFDO1FBQ3BFLE9BQU8sMkJBQTJCLENBQUMsTUFBYSxDQUFDLENBQUM7SUFDcEQsQ0FBQztJQUVELEtBQUssQ0FBQywyQkFBMkIsQ0FBQyxNQVFqQztRQU9DLE1BQU0sRUFBRSwyQkFBMkIsRUFBRSxHQUFHLE1BQU0sMkxBQXFCLENBQUM7UUFDcEUsT0FBTywyQkFBMkIsQ0FBQyxNQUFhLENBQUMsQ0FBQztJQUNwRCxDQUFDO0lBRUQ7Ozs7Ozs7OztPQVNHLENBQ0gsS0FBSyxDQUFDLFdBQVcsQ0FBQyxNQUdPO1FBQ3ZCLE1BQU0sRUFBRSxTQUFTLEVBQUUsYUFBYSxHQUFHLE1BQU0sRUFBRSxHQUFHLElBQUksRUFBRSxHQUFHLE1BQU0sQ0FBQztRQUU5RCxNQUFNLGFBQWEsR0FDakIsQ0FBQyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsVUFBVSxJQUFJLENBQUMsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLCtCQUErQixDQUFDO1FBRTVFLElBQUksSUFBSSxHQUFrQixhQUFhLENBQUM7UUFDeEMsSUFBSSxhQUFhLEtBQUssTUFBTSxFQUFFLENBQUM7WUFDN0IsSUFBSSxHQUFHLGFBQWEsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUM7UUFDN0MsQ0FBQyxNQUFNLElBQUksYUFBYSxLQUFLLFFBQVEsSUFBSSxDQUFDLGFBQWEsRUFBRSxDQUFDO1lBQ3hELE9BQU8sQ0FBQyxJQUFJLENBQ1YsdUlBQXVJLENBQ3hJLENBQUM7WUFDRixJQUFJLEdBQUcsUUFBUSxDQUFDO1FBQ2xCLENBQUM7UUFFRCxJQUFJLFNBQVMsS0FBSyxLQUFLLEVBQUUsQ0FBQztZQUN4QixJQUFJLElBQUksS0FBSyxRQUFRLEVBQUUsQ0FBQztnQkFDdEIsT0FBTyxNQUFPLElBQUksQ0FBQyxNQUFNLENBQUMsc0NBQXNDLENBQUMsSUFBSSxDQUFDLENBQWlEO1lBQ3pILENBQUM7WUFDRCxPQUFPLE1BQU8sSUFBSSxDQUFDLE1BQU0sQ0FBQyxrQ0FBa0MsQ0FBQyxJQUFJLENBQUMsQ0FBNkM7UUFDakgsQ0FBQztRQUVELCtCQUErQjtRQUMvQixJQUFJLElBQUksS0FBSyxRQUFRLEVBQUUsQ0FBQztZQUN0QixPQUFPLE1BQU8sSUFBSSxDQUFDLE1BQU0sQ0FBQywrQ0FBK0MsQ0FBQyxJQUFJLENBQUMsQ0FBMEQ7UUFDM0ksQ0FBQztRQUNELE9BQU8sTUFBTyxJQUFJLENBQUMsTUFBTSxDQUFDLDJDQUEyQyxDQUFDLElBQUksQ0FBQyxDQUFzRDtJQUNuSSxDQUFDO0lBRUQ7Ozs7T0FJRyxDQUNILEtBQUssQ0FBQyxRQUFRLENBQ1osT0FBZSxFQUNmLFVBQWtCLDhEQUFnQixFQUNsQyxPQUEyQztRQUUzQyxJQUFJLENBQUM7WUFDSCxvRkFBb0Y7WUFDcEYsb0ZBQW9GO1lBQ3BGLE1BQU0sV0FBVyxHQUFHLE1BQU0sNERBQWUsQ0FBQyxJQUFJLEVBQUUsT0FBTyxFQUFFLE9BQU8sRUFBRTtnQkFDaEUsbUJBQW1CLEVBQUUsT0FBTyxFQUFFLG1CQUFtQixJQUFJLEtBQUs7YUFDM0QsQ0FBQyxDQUFDO1lBRUgsd0VBQXdFO1lBQ3hFLGdFQUFnRTtZQUNoRSxNQUFNLFNBQVMsR0FBa0I7Z0JBQy9CLE9BQU8sRUFBRSxXQUFXLENBQUMsT0FBTztnQkFDNUIsU0FBUyxFQUFFLFdBQVcsQ0FBQyxTQUFTO2dCQUNoQyxPQUFPLEVBQUUsV0FBVyxDQUFDLE9BQU87Z0JBQzVCLFlBQVksRUFBRSxXQUFXLENBQUMsWUFBWTtnQkFDdEMseUJBQXlCLEVBQUUsV0FBVyxDQUFDLHlCQUF5QjtnQkFDaEUsNEJBQTRCLEVBQUUsV0FBVyxDQUFDLDRCQUE0QixJQUFJLFNBQVM7Z0JBQ25GLGVBQWUsRUFBRSxXQUFXLENBQUMsZUFBZSxJQUFJLFNBQVM7Z0JBQ3pELGVBQWUsRUFBRSxXQUFXLENBQUMsZUFBZSxJQUFJLFNBQVM7Z0JBQ3pELFdBQVcsRUFBRSxXQUFXLENBQUMsV0FBVyxJQUFJLFNBQVM7Z0JBQ2pELFVBQVUsRUFBRSxXQUFXLENBQUMsVUFBVSxJQUFJLFNBQVM7Z0JBQy9DLE9BQU8sRUFBRSxXQUFXLENBQUMsT0FBTyxJQUFJLFNBQVM7Z0JBQ3pDLFFBQVEsRUFBRSxXQUFXLENBQUMsUUFBUSxJQUFJLFNBQVM7Z0JBQzNDLGNBQWMsRUFBRSxXQUFXLENBQUMsY0FBYztnQkFDMUMsYUFBYSxFQUFFLFdBQVcsQ0FBQyxhQUFhO2dCQUN4QyxhQUFhLEVBQUUsV0FBVyxDQUFDLGFBQWEsSUFBSSxTQUFTO2dCQUNyRCxJQUFJLEVBQUUsV0FBVyxDQUFDLElBQUksSUFBSSxTQUFTO2dCQUNuQyxXQUFXLEVBQUUsV0FBVyxDQUFDLFdBQVcsSUFBSSxTQUFTO2dCQUNqRCxLQUFLLEVBQUUsV0FBVyxDQUFDLEtBQUssSUFBSSxTQUFTO2dCQUNyQyxXQUFXLEVBQUUsV0FBVyxDQUFDLFdBQVcsSUFBSSxTQUFTO2dCQUNqRCxjQUFjLEVBQUUsV0FBVyxDQUFDLGNBQWMsSUFBSSxTQUFTO2dCQUN2RCxPQUFPLEVBQUUsV0FBVyxDQUFDLE9BQU8sSUFBSSxTQUFTO2dCQUN6QyxhQUFhLEVBQUUsV0FBVyxDQUFDLGFBQWEsSUFBSSxTQUFTO2dCQUNyRCxlQUFlLEVBQUUsV0FBVyxDQUFDLGVBQWUsSUFBSSxTQUFTO2dCQUN6RCxHQUFHLEVBQUUsV0FBVyxDQUFDLEdBQUcsSUFBSSxTQUFTO2dCQUNqQyxHQUFHLEVBQUUsV0FBVyxDQUFDLEdBQUcsSUFBSSxTQUFTO2dCQUNqQyxXQUFXLEVBQUUsV0FBVyxDQUFDLFdBQVcsSUFBSSxTQUFTO2dCQUNqRCxNQUFNLEVBQUUsV0FBVyxDQUFDLE1BQU0sSUFBSSxTQUFTO2FBQ3hDLENBQUM7WUFFRixPQUFPLElBQUksOENBQUssQ0FBQyxTQUFTLEVBQUUsSUFBSSxDQUFDLENBQUM7UUFDcEMsQ0FBQyxDQUFDLE9BQU8sS0FBSyxFQUFFLENBQUM7WUFDZixPQUFPLENBQUMsSUFBSSxDQUFDLHNEQUFzRCxPQUFPLGFBQWEsT0FBTyxHQUFHLEVBQUUsS0FBSyxDQUFDLENBQUM7WUFDMUcsT0FBTyxJQUFJLENBQUM7UUFDZCxDQUFDO0lBQ0gsQ0FBQztJQUVEOzs7T0FHRyxDQUNILEtBQUssQ0FBQyxjQUFjLENBQUMsU0FBaUI7UUFDcEMsTUFBTSxlQUFlLEdBQUcsTUFBTSxvRUFBa0IsRUFBRSxDQUFDO1FBQ25ELE1BQU0sU0FBUyxHQUFHLE1BQU0sZUFBZSxDQUFDLGNBQWMsQ0FBQyxTQUFTLENBQUMsQ0FBQztRQUVsRSxJQUFJLENBQUMsU0FBUyxFQUFFLENBQUM7WUFDZixPQUFPLElBQUksQ0FBQztRQUNkLENBQUM7UUFFRCxPQUFPLElBQUksOENBQUssQ0FBQyxTQUFTLEVBQUUsSUFBSSxDQUFDLENBQUM7SUFDcEMsQ0FBQztJQUVEOzs7T0FHRyxDQUNILEtBQUssQ0FBQyxhQUFhLENBQ2pCLE9BQWUsRUFDZixPQUFnQjtRQUVoQixNQUFNLGVBQWUsR0FBRyxPQUFPLElBQUksOERBQWdCLENBQUM7UUFFcEQsTUFBTSxPQUFPLEdBQUcsT0FBTyxDQUFDLElBQUksRUFBRSxDQUFDO1FBQy9CLElBQUksYUFBcUIsQ0FBQztRQUMxQixJQUFJLENBQUM7WUFDSCxhQUFhLEdBQUcsTUFBTSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBQ2xDLENBQUMsQ0FBQyxPQUFNLENBQUM7WUFDUCxNQUFNLElBQUksS0FBSyxDQUFDLHNDQUFzQyxPQUFPLEVBQUUsQ0FBQyxDQUFDO1FBQ25FLENBQUM7UUFFRCxJQUFJLENBQUM7WUFDSCxNQUFNLGNBQWMsR0FBRyxNQUFNLHFGQUF5QixDQUFDLGVBQWUsQ0FBQyxDQUFDO1lBQ3hFLE1BQU0sS0FBSyxHQUFHLE1BQU8sY0FBc0IsQ0FBQyxRQUFRLENBQUMsYUFBYSxDQUFDLENBQUM7WUFDcEUsSUFBSSxLQUFLLElBQUksT0FBTyxLQUFLLEtBQUssUUFBUSxJQUFJLHFCQUFxQixDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDO2dCQUM1RSxPQUFPLEtBQXNCLENBQUM7WUFDaEMsQ0FBQztZQUNELE9BQU8sSUFBSSxDQUFDO1FBQ2QsQ0FBQyxDQUFDLE9BQU8sS0FBSyxFQUFFLENBQUM7WUFDZixPQUFPLENBQUMsSUFBSSxDQUFDLDZEQUE2RCxFQUFFLEtBQUssQ0FBQyxDQUFDO1lBQ25GLE9BQU8sSUFBSSxDQUFDO1FBQ2QsQ0FBQztJQUNILENBQUM7SUFFRDs7OztPQUlHLENBQ0gsS0FBSyxDQUFDLE9BQU8sQ0FDWCxPQUFlLEVBQ2YsYUFBNEIsRUFDNUIsT0FBZ0I7UUFFaEIsTUFBTSxlQUFlLEdBQUcsT0FBTyxJQUFJLDhEQUFnQixDQUFDO1FBRXBELGtDQUFrQztRQUNsQyxJQUFJLE9BQWUsQ0FBQztRQUNwQixJQUFJLENBQUM7WUFDSCxNQUFNLE1BQU0sR0FBRywwRUFBWSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1lBQ3JDLE9BQU8sR0FBRyxNQUFNLENBQUMsT0FBTyxDQUFDO1FBQzNCLENBQUMsQ0FBQyxPQUFPLEtBQUssRUFBRSxDQUFDO1lBQ2YsT0FBTyxDQUFDLElBQUksQ0FBQyxrREFBa0QsRUFBRSxPQUFPLEVBQUUsS0FBSyxDQUFDLENBQUM7WUFDakYsT0FBTyxLQUFLLENBQUM7UUFDZixDQUFDO1FBRUQsTUFBTSxXQUFXLEdBQUcsYUFBYSxDQUFDLFdBQVcsRUFBRSxDQUFDO1FBRWhELElBQUksQ0FBQztZQUNILGdDQUFnQztZQUNoQyxNQUFNLEtBQUssR0FBRyw4REFBWSxDQUFDLGVBQWUsQ0FBQyxDQUFDO1lBQzVDLE1BQU0sTUFBTSxHQUFHLGdFQUFjLENBQUMsZUFBZSxDQUFDLENBQUM7WUFDL0MsSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDO2dCQUNaLE9BQU8sQ0FBQyxJQUFJLENBQUMsb0RBQW9ELEVBQUUsZUFBZSxDQUFDLENBQUM7Z0JBQ3BGLE9BQU8sS0FBSyxDQUFDO1lBQ2YsQ0FBQztZQUVELE1BQU0sRUFBRSxrQkFBa0IsRUFBRSxJQUFJLEVBQUUsR0FBRyxNQUFNLHdPQUFjLENBQUM7WUFDMUQsTUFBTSxNQUFNLEdBQUcsa0JBQWtCLENBQUM7Z0JBQ2hDLEtBQUs7Z0JBQ0wsU0FBUyxFQUFFLElBQUksQ0FBQyxNQUFNLENBQUM7YUFDeEIsQ0FBQyxDQUFDO1lBRUgsd0ZBQXdGO1lBQ3hGLE1BQU0sY0FBYyxHQUFHLE1BQU0scUZBQXlCLENBQUMsZUFBZSxDQUFDLENBQUM7WUFDeEUsTUFBTSx1QkFBdUIsR0FBSSxjQUFzQixFQUFFLHVCQUE4QyxDQUFDO1lBQ3hHLElBQUksQ0FBQyx1QkFBdUIsRUFBRSxDQUFDO2dCQUM3QixPQUFPLENBQUMsSUFBSSxDQUFDLDhEQUE4RCxDQUFDLENBQUM7Z0JBQzdFLE9BQU8sS0FBSyxDQUFDO1lBQ2YsQ0FBQztZQUVELE1BQU0sT0FBTyxHQUFHLE1BQU0sQ0FBQyxPQUFPLENBQUMsQ0FBQztZQUVoQyxNQUFNLFlBQVksR0FBRztnQkFDbkI7b0JBQ0UsSUFBSSxFQUFFLFVBQVU7b0JBQ2hCLElBQUksRUFBRSxTQUFTO29CQUNmLGVBQWUsRUFBRSxNQUFNO29CQUN2QixNQUFNLEVBQUU7d0JBQUM7NEJBQUUsSUFBSSxFQUFFLFNBQVM7NEJBQUUsSUFBSSxFQUFFLFNBQVM7d0JBQUEsQ0FBRTtxQkFBQztvQkFDOUMsT0FBTyxFQUFFO3dCQUFDOzRCQUFFLElBQUksRUFBRSxPQUFPOzRCQUFFLElBQUksRUFBRSxTQUFTO3dCQUFBLENBQUU7cUJBQUM7aUJBQzlDO2dCQUNEO29CQUNFLElBQUksRUFBRSxVQUFVO29CQUNoQixJQUFJLEVBQUUsZ0JBQWdCO29CQUN0QixlQUFlLEVBQUUsTUFBTTtvQkFDdkIsTUFBTSxFQUFFO3dCQUFDOzRCQUFFLElBQUksRUFBRSxTQUFTOzRCQUFFLElBQUksRUFBRSxTQUFTO3dCQUFBLENBQUU7cUJBQUM7b0JBQzlDLE9BQU8sRUFBRTt3QkFBQzs0QkFBRSxJQUFJLEVBQUUsUUFBUTs0QkFBRSxJQUFJLEVBQUUsU0FBUzt3QkFBQSxDQUFFO3FCQUFDO2lCQUMvQzthQUNPLENBQUM7WUFFWCw0QkFBNEI7WUFDNUIsSUFBSSxRQUFRLEdBQWtCLElBQUksQ0FBQztZQUNuQyxJQUFJLENBQUM7Z0JBQ0gsUUFBUSxHQUFHLE1BQU8sTUFBTSxDQUFDLFlBQVksQ0FBQztvQkFDcEMsT0FBTyxFQUFFLHVCQUF1QjtvQkFDaEMsR0FBRyxFQUFFLFlBQVk7b0JBQ2pCLFlBQVksRUFBRSxTQUFTO29CQUN2QixJQUFJLEVBQUU7d0JBQUMsT0FBTztxQkFBQztpQkFDaEIsQ0FBQyxDQUFXO1lBQ2YsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxFQUFFLENBQUM7Z0JBQ1gsT0FBTyxDQUFDLElBQUksQ0FBQyw4Q0FBOEMsRUFBRSxDQUFDLENBQUMsQ0FBQztnQkFDaEUsUUFBUSxHQUFHLElBQUksQ0FBQztZQUNsQixDQUFDO1lBRUQsSUFBSSxRQUFRLElBQUksUUFBUSxDQUFDLFdBQVcsRUFBRSxLQUFLLFdBQVcsRUFBRSxDQUFDO2dCQUN2RCxPQUFPLElBQUksQ0FBQztZQUNkLENBQUM7WUFFRCw0RUFBNEU7WUFDNUUsSUFBSSxZQUFZLEdBQWtCLElBQUksQ0FBQztZQUN2QyxJQUFJLENBQUM7Z0JBQ0gsWUFBWSxHQUFHLE1BQU8sTUFBTSxDQUFDLFlBQVksQ0FBQztvQkFDeEMsT0FBTyxFQUFFLHVCQUF1QjtvQkFDaEMsR0FBRyxFQUFFLFlBQVk7b0JBQ2pCLFlBQVksRUFBRSxnQkFBZ0I7b0JBQzlCLElBQUksRUFBRTt3QkFBQyxPQUFPO3FCQUFDO2lCQUNoQixDQUFDLENBQVc7WUFDZixDQUFDLENBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQztnQkFDWCx3RUFBd0U7Z0JBQ3hFLE9BQU8sQ0FBQyxJQUFJLENBQUMscURBQXFELEVBQUUsQ0FBQyxDQUFDLENBQUM7Z0JBQ3ZFLFlBQVksR0FBRyxJQUFJLENBQUM7WUFDdEIsQ0FBQztZQUVELElBQUksQ0FBQyxZQUFZLElBQUksQ0FBQyxZQUFZLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUM7Z0JBQ3BELE9BQU8sS0FBSyxDQUFDO1lBQ2YsQ0FBQztZQUVELDJDQUEyQztZQUMzQyxNQUFNLElBQUksR0FBRyxNQUFNLE1BQU0sQ0FBQyxXQUFXLENBQUM7Z0JBQUUsT0FBTyxFQUFFLFlBQXVCO1lBQUEsQ0FBRSxDQUFDLENBQUM7WUFFNUUsMkNBQTJDO1lBQzNDLElBQUksQ0FBQyxJQUFJLElBQUksSUFBSSxLQUFLLElBQUksRUFBRSxDQUFDO2dCQUMzQixPQUFPLFlBQVksQ0FBQyxXQUFXLEVBQUUsS0FBSyxXQUFXLENBQUM7WUFDcEQsQ0FBQztZQUVELG1EQUFtRDtZQUNuRCxJQUFJLFVBQVUsR0FBa0IsSUFBSSxDQUFDO1lBRXJDLCtCQUErQjtZQUMvQixJQUFJLENBQUM7Z0JBQ0gsVUFBVSxHQUFHLE1BQU8sTUFBTSxDQUFDLFlBQVksQ0FBQztvQkFDdEMsT0FBTyxFQUFFLFlBQXVCO29CQUNoQyxHQUFHLEVBQUU7d0JBQ0g7NEJBQ0UsSUFBSSxFQUFFLE9BQU87NEJBQ2IsSUFBSSxFQUFFLFVBQVU7NEJBQ2hCLGVBQWUsRUFBRSxNQUFlOzRCQUNoQyxNQUFNLEVBQUUsRUFBRTs0QkFDVixPQUFPLEVBQUU7Z0NBQUM7b0NBQUUsSUFBSSxFQUFFLFNBQVM7Z0NBQUEsQ0FBRTs2QkFBQzt5QkFDL0I7cUJBQ0Y7b0JBQ0QsWUFBWSxFQUFFLE9BQU87aUJBQ3RCLENBQUMsQ0FBVztZQUNmLENBQUMsQ0FBQyxPQUFNLENBQUM7WUFDUCxTQUFTO1lBQ1gsQ0FBQztZQUVELG9DQUFvQztZQUNwQyxJQUFJLENBQUMsVUFBVSxFQUFFLENBQUM7Z0JBQ2hCLElBQUksQ0FBQztvQkFDSCxVQUFVLEdBQUcsTUFBTyxNQUFNLENBQUMsWUFBWSxDQUFDO3dCQUN0QyxPQUFPLEVBQUUsWUFBdUI7d0JBQ2hDLEdBQUcsRUFBRTs0QkFDSDtnQ0FDRSxJQUFJLEVBQUUsVUFBVTtnQ0FDaEIsSUFBSSxFQUFFLFVBQVU7Z0NBQ2hCLGVBQWUsRUFBRSxNQUFlO2dDQUNoQyxNQUFNLEVBQUUsRUFBRTtnQ0FDVixPQUFPLEVBQUU7b0NBQUM7d0NBQUUsSUFBSSxFQUFFLFNBQVM7b0NBQUEsQ0FBRTtpQ0FBQzs2QkFDL0I7eUJBQ0Y7d0JBQ0QsWUFBWSxFQUFFLFVBQVU7cUJBQ3pCLENBQUMsQ0FBVztnQkFDZixDQUFDLENBQUMsT0FBTSxDQUFDO2dCQUNQLFNBQVM7Z0JBQ1gsQ0FBQztZQUNILENBQUM7WUFFRCx3Q0FBd0M7WUFDeEMsSUFBSSxDQUFDLFVBQVUsRUFBRSxDQUFDO2dCQUNoQixJQUFJLENBQUM7b0JBQ0gsTUFBTSxNQUFNLEdBQUcsTUFBTyxNQUFNLENBQUMsWUFBWSxDQUFDO3dCQUN4QyxPQUFPLEVBQUUsWUFBdUI7d0JBQ2hDLEdBQUcsRUFBRTs0QkFDSDtnQ0FDRSxJQUFJLEVBQUUsUUFBUTtnQ0FDZCxJQUFJLEVBQUUsVUFBVTtnQ0FDaEIsZUFBZSxFQUFFLE1BQWU7Z0NBQ2hDLE1BQU0sRUFBRSxFQUFFO2dDQUNWLE9BQU8sRUFBRTtvQ0FBQzt3Q0FBRSxJQUFJLEVBQUUsV0FBVztvQ0FBQSxDQUFFO2lDQUFDOzZCQUNqQzt5QkFDRjt3QkFDRCxZQUFZLEVBQUUsUUFBUTtxQkFDdkIsQ0FBQyxDQUFhO29CQUNmLFVBQVUsR0FBRyxNQUFNLEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxJQUFJLENBQUM7Z0JBQ25DLENBQUMsQ0FBQyxPQUFNLENBQUM7Z0JBQ1AsU0FBUztnQkFDWCxDQUFDO1lBQ0gsQ0FBQztZQUVELE9BQU8sT0FBTyxDQUFDLFVBQVUsSUFBSSxVQUFVLENBQUMsV0FBVyxFQUFFLEtBQUssV0FBVyxDQUFDLENBQUM7UUFDekUsQ0FBQyxDQUFDLE9BQU8sS0FBSyxFQUFFLENBQUM7WUFDZixPQUFPLENBQUMsSUFBSSxDQUFDLHNEQUFzRCxFQUFFLEtBQUssQ0FBQyxDQUFDO1lBQzVFLE9BQU8sS0FBSyxDQUFDO1FBQ2YsQ0FBQztJQUNILENBQUM7SUFFRDs7T0FFRyxDQUNILEtBQUssQ0FBQyxhQUFhLENBQUMsT0FBZTtRQUNqQyxNQUFNLEVBQUUsT0FBTyxFQUFFLE9BQU8sRUFBRSxHQUFHLDBFQUFZLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDbkQsT0FBTyxJQUFJLENBQUMsUUFBUSxDQUFDLE9BQU8sRUFBRSxPQUFPLENBQUMsQ0FBQztJQUN6QyxDQUFDO0lBRUQ7Ozs7T0FJRyxDQUNILEtBQUssQ0FBQyxlQUFlLENBQ25CLE9BQWUsRUFDZixPQUFnQjtRQUVoQixNQUFNLGVBQWUsR0FBRyxPQUFPLElBQUksOERBQWdCLENBQUM7UUFDcEQsTUFBTSxPQUFPLEdBQUcsT0FBTyxDQUFDLElBQUksRUFBRSxDQUFDO1FBQy9CLElBQUksYUFBcUIsQ0FBQztRQUMxQixJQUFJLENBQUM7WUFDSCxhQUFhLEdBQUcsTUFBTSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBQ2xDLENBQUMsQ0FBQyxPQUFNLENBQUM7WUFDUCxNQUFNLElBQUksS0FBSyxDQUFDLHdDQUF3QyxPQUFPLEVBQUUsQ0FBQyxDQUFDO1FBQ3JFLENBQUM7UUFDRCxPQUFPLDREQUFlLENBQUMsSUFBSSxFQUFFLGFBQWEsRUFBRSxlQUFlLENBQUMsQ0FBQztJQUMvRCxDQUFDO0lBRUQ7O09BRUcsQ0FDSCxLQUFLLENBQUMsb0JBQW9CLENBQ3hCLE9BQWUsRUFDZixPQUEyQztRQUUzQyw2RUFBNkU7UUFDN0UsT0FBTyw0REFBZSxDQUFDLElBQUksRUFBRSxPQUFPLEVBQUUsOERBQWdCLEVBQUUsT0FBTyxDQUFDLENBQUM7SUFDbkUsQ0FBQztJQUVEOzs7Ozs7Ozs7T0FTRyxDQUNILEtBQUssQ0FBQyxpQkFBaUIsQ0FDckIsT0FBc0IsRUFDdEIsT0FBZ0I7UUFFaEIsSUFBSSxjQUFjLEdBQUcsTUFBTSxDQUFDLFFBQVEsQ0FBQyxPQUFPLElBQUksR0FBRyxDQUFDLElBQUksQ0FBQyxPQUFPLEtBQUksQ0FBQyxDQUFDLEVBQUcsQ0FBQyxHQUNyRSxPQUFrQixHQUNuQiw4REFBZ0IsQ0FBQztRQUVyQixJQUFJLE9BQU8sR0FBa0IsSUFBSSxDQUFDO1FBRWxDLGtDQUFrQztRQUNsQyxJQUFJLENBQUM7WUFDSCxNQUFNLFNBQVMsR0FBRyxNQUFNLHdEQUFZLENBQUMsY0FBYyxDQUFDLENBQUM7WUFDckQsTUFBTSxRQUFRLEdBQUcsTUFBTyxTQUFpQixDQUFDLHlCQUF5QixDQUFDLE9BQU8sQ0FBQyxDQUFDO1lBQzdFLElBQUksUUFBUSxFQUFFLE9BQU8sRUFBRSxDQUFDO2dCQUN0QixPQUFPLEdBQUcsUUFBUSxDQUFDLE9BQU8sQ0FBQyxRQUFRLEVBQUUsQ0FBQztZQUN4QyxDQUFDO1FBQ0gsQ0FBQyxDQUFDLE9BQU8sS0FBSyxFQUFFLENBQUM7WUFDZixPQUFPLENBQUMsSUFBSSxDQUFDLDBEQUEwRCxFQUFFLEtBQUssQ0FBQyxDQUFDO1FBQ2xGLENBQUM7UUFFRCx3REFBd0Q7UUFDeEQsSUFBSSxDQUFDLE9BQU8sRUFBRSxDQUFDO1lBQ2IsSUFBSSxDQUFDO2dCQUNILE1BQU0sYUFBYSxHQUFHLE1BQU0sSUFBSSxDQUFDLFlBQVksQ0FBQztvQkFDNUMsS0FBSyxFQUFFLE9BQU87b0JBQ2QsSUFBSSxFQUFFLENBQUM7b0JBQ1AsUUFBUSxFQUFFLENBQUM7aUJBQ1osQ0FBQyxDQUFDO2dCQUVILE1BQU0sU0FBUyxHQUFHLGFBQWEsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFDNUMsSUFBSSxTQUFTLElBQUksT0FBTyxTQUFTLEtBQUssUUFBUSxFQUFFLENBQUM7b0JBQy9DLE1BQU0sZUFBZSxHQUFHLFNBQStDLENBQUM7b0JBQ3hFLE1BQU0sZ0JBQWdCLEdBQUcsZUFBZSxDQUFDLElBQUksQ0FBQztvQkFDOUMsTUFBTSxhQUFhLEdBQ2pCLGdCQUFnQixJQUFJLE9BQU8sZ0JBQWdCLEtBQUssUUFBUSxHQUNuRCxnQkFBNEMsR0FDN0MsSUFBSSxDQUFDO29CQUVYLE1BQU0scUJBQXFCLEdBQ3pCLGFBQWEsSUFBSSxhQUFhLENBQUMsT0FBTyxLQUFLLFNBQVMsR0FDL0MsYUFBcUIsQ0FBQyxPQUFPLEdBQzdCLGVBQXVCLENBQUMsT0FBTyxDQUFDO29CQUV2QyxJQUFJLHFCQUFxQixLQUFLLFNBQVMsSUFBSSxxQkFBcUIsS0FBSyxJQUFJLEVBQUUsQ0FBQzt3QkFDMUUsSUFBSSxPQUFPLHFCQUFxQixLQUFLLFFBQVEsRUFBRSxDQUFDOzRCQUM5QyxPQUFPLEdBQUcscUJBQXFCLENBQUMsUUFBUSxFQUFFLENBQUM7d0JBQzdDLENBQUMsTUFBTSxJQUNMLE9BQU8scUJBQXFCLEtBQUssUUFBUSxJQUN6QyxNQUFNLENBQUMsUUFBUSxDQUFDLHFCQUFxQixDQUFDLEVBQ3RDLENBQUM7NEJBQ0QsT0FBTyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMscUJBQXFCLENBQUMsQ0FBQyxRQUFRLEVBQUUsQ0FBQzt3QkFDekQsQ0FBQyxNQUFNLElBQ0wsT0FBTyxxQkFBcUIsS0FBSyxRQUFRLElBQ3pDLHFCQUFxQixDQUFDLElBQUksRUFBRSxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQ3ZDLENBQUM7NEJBQ0QsT0FBTyxHQUFHLHFCQUFxQixDQUFDLElBQUksRUFBRSxDQUFDO3dCQUN6QyxDQUFDO29CQUNILENBQUM7b0JBRUQsTUFBTSxnQkFBZ0IsR0FDcEIsYUFBYSxJQUFJLE9BQVEsYUFBcUIsQ0FBQyxPQUFPLEtBQUssUUFBUSxHQUM5RCxhQUFxQixDQUFDLE9BQU8sR0FDOUIsU0FBUyxDQUFDO29CQUNoQixJQUFJLENBQUMsQ0FBQyxjQUFjLElBQUksTUFBTSxDQUFDLEtBQUssQ0FBQyxlQUFjLENBQUMsQ0FBQyxHQUFJLE9BQU8sZ0JBQWdCLEtBQUssUUFBUSxFQUFFLENBQUM7d0JBQzlGLGNBQWMsR0FBRyxnQkFBZ0IsQ0FBQztvQkFDcEMsQ0FBQztnQkFDSCxDQUFDO1lBQ0gsQ0FBQyxDQUFDLE9BQU8sS0FBSyxFQUFFLENBQUM7Z0JBQ2YsT0FBTyxDQUFDLElBQUksQ0FBQyx3REFBd0QsRUFBRSxLQUFLLENBQUMsQ0FBQztZQUNoRixDQUFDO1FBQ0gsQ0FBQztRQUVELElBQUksQ0FBQyxPQUFPLEVBQUUsQ0FBQztZQUNiLE9BQU8sSUFBSSxDQUFDO1FBQ2QsQ0FBQztRQUVELE1BQU0sZ0JBQWdCLEdBQ3BCLE1BQU0sQ0FBQyxRQUFRLENBQUMsY0FBYyxDQUFDLElBQUksY0FBYyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsY0FBYyxDQUFDLENBQUMsQ0FBQyw4REFBZ0IsQ0FBQztRQUU1RixPQUFPLElBQUksQ0FBQyxlQUFlLENBQUMsT0FBTyxFQUFFLGdCQUFnQixDQUFDLENBQUM7SUFDekQsQ0FBQztJQUlEOzs7O09BSUcsQ0FDSCxLQUFLLENBQUMseUJBQXlCLENBQzdCLE9BQVksRUFDWixPQUFnQjtRQUVoQixPQUFPLElBQUksQ0FBQyxNQUFNLENBQUMseUJBQXlCLENBQzFDLE9BQU8sRUFDUCxPQUFPLElBQUksOERBQWdCLENBQzVCLENBQUM7SUFDSixDQUFDO0lBSUQ7Ozs7Ozs7T0FPRyxDQUNILEtBQUssQ0FBQyxjQUFjLENBQUMsTUFJcEI7UUFDQyxNQUFNLEVBQUUsT0FBTyxFQUFFLGFBQWEsRUFBRSxPQUFPLEVBQUUsR0FBRyxNQUFNLENBQUM7UUFDbkQsTUFBTSxlQUFlLEdBQUcsT0FBTyxJQUFJLDhEQUFnQixDQUFDO1FBRXBELE1BQU0sT0FBTyxHQUFHLE9BQU8sQ0FBQyxJQUFJLEVBQUUsQ0FBQztRQUMvQixJQUFJLGFBQXFCLENBQUM7UUFDMUIsSUFBSSxDQUFDO1lBQ0gsYUFBYSxHQUFHLE1BQU0sQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUNsQyxDQUFDLENBQUMsT0FBTSxDQUFDO1lBQ1AsTUFBTSxJQUFJLEtBQUssQ0FBQyx1Q0FBdUMsT0FBTyxFQUFFLENBQUMsQ0FBQztRQUNwRSxDQUFDO1FBRUQsTUFBTSxtQkFBbUIsR0FDdkIsT0FBTyxhQUFhLEtBQUssUUFBUSxDQUFDLENBQUMsQ0FBQyxhQUFhLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxhQUFhLENBQUMsQ0FBQztRQUU1RSxNQUFNLGdCQUFnQixHQUFHLE1BQU0sOEVBQTJCLENBQUMsZUFBZSxDQUFDLENBQUM7UUFDNUUsT0FBUSxnQkFBd0IsQ0FBQyxjQUFjLENBQUMsYUFBYSxFQUFFLG1CQUFtQixDQUFDLENBQUM7SUFDdEYsQ0FBQztJQUdEOzs7OztPQUtHLENBQ0gsS0FBSyxDQUFDLGdCQUFnQixDQUFDLE1BT3RCO1FBQ0MsTUFBTSxFQUFFLE9BQU8sRUFBRSxhQUFhLEVBQUUsYUFBYSxFQUFFLFdBQVcsRUFBRSxZQUFZLEVBQUUsT0FBTyxFQUFFLEdBQUcsTUFBTSxDQUFDO1FBQzdGLE1BQU0sZUFBZSxHQUFHLE9BQU8sSUFBSSw4REFBZ0IsQ0FBQztRQUVwRCxNQUFNLE9BQU8sR0FBRyxPQUFPLENBQUMsSUFBSSxFQUFFLENBQUM7UUFDL0IsSUFBSSxhQUFxQixDQUFDO1FBQzFCLElBQUksQ0FBQztZQUNILGFBQWEsR0FBRyxNQUFNLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDbEMsQ0FBQyxDQUFDLE9BQU0sQ0FBQztZQUNQLE1BQU0sSUFBSSxLQUFLLENBQUMseUNBQXlDLE9BQU8sRUFBRSxDQUFDLENBQUM7UUFDdEUsQ0FBQztRQUVELE1BQU0sbUJBQW1CLEdBQ3ZCLE9BQU8sYUFBYSxLQUFLLFFBQVEsQ0FBQyxDQUFDLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsYUFBYSxDQUFDLENBQUM7UUFFNUUsTUFBTSxnQkFBZ0IsR0FBRyxNQUFNLDhFQUEyQixDQUFDLGVBQWUsQ0FBQyxDQUFDO1FBQzVFLE9BQVEsZ0JBQXdCLENBQUMsZ0JBQWdCLENBQUM7WUFDaEQsT0FBTyxFQUFFLGFBQWE7WUFDdEIsYUFBYTtZQUNiLGFBQWEsRUFBRSxtQkFBbUI7WUFDbEMsV0FBVztZQUNYLFlBQVk7U0FDYixDQUFDLENBQUM7SUFDTCxDQUFDO0lBRUQ7OztPQUdHLENBQ0gsS0FBSyxDQUFDLFlBQVk7UUFDaEIsTUFBTSxFQUFFLFlBQVksRUFBRSxHQUFHLE1BQU0sMkxBQXFCLENBQUM7UUFDckQsT0FBTyxNQUFNLFlBQVksRUFBRSxDQUFDO0lBQzlCLENBQUM7SUFFRCxLQUFLLENBQUMsa0JBQWtCO1FBQ3RCLE1BQU0sRUFBRSxrQkFBa0IsRUFBRSxHQUFHLE1BQU0sdU1BQTJCLENBQUM7UUFDakUsT0FBTyxNQUFNLGtCQUFrQixFQUFFLENBQUM7SUFDcEMsQ0FBQztJQUVEOztPQUVHLENBQ0gsS0FBSyxDQUFDLGdDQUFnQyxDQUFDLE1BT3RDO1FBQ0MsTUFBTSxFQUFFLGtCQUFrQixFQUFFLEdBQUcsTUFBTSx1TUFBMkIsQ0FBQztRQUNqRSxNQUFNLGVBQWUsR0FBRyxNQUFNLGtCQUFrQixFQUFFLENBQUM7UUFDbkQsSUFBSSxDQUFDLGVBQWUsSUFBSSxPQUFPLGVBQWUsQ0FBQyxnQ0FBZ0MsS0FBSyxVQUFVLEVBQUUsQ0FBQztZQUMvRixPQUFPLElBQUksQ0FBQztRQUNkLENBQUM7UUFDRCxPQUFPLE1BQU0sZUFBZSxDQUFDLGdDQUFnQyxDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBQ3hFLENBQUM7SUFFRDs7T0FFRyxDQUNILEtBQUssQ0FBQyxzQkFBc0IsQ0FBQyxNQU81QjtRQUNDLE1BQU0sRUFBRSxrQkFBa0IsRUFBRSxHQUFHLE1BQU0sdU1BQTJCLENBQUM7UUFDakUsTUFBTSxlQUFlLEdBQUcsTUFBTSxrQkFBa0IsRUFBRSxDQUFDO1FBQ25ELElBQUksQ0FBQyxlQUFlLElBQUksT0FBTyxlQUFlLENBQUMsc0JBQXNCLEtBQUssVUFBVSxFQUFFLENBQUM7WUFDckYsT0FBTyxJQUFJLENBQUM7UUFDZCxDQUFDO1FBQ0QsT0FBTyxNQUFNLGVBQWUsQ0FBQyxzQkFBc0IsQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUM5RCxDQUFDO0lBRUQ7Ozs7Ozs7T0FPRyxDQUNILEtBQUssQ0FBQyxlQUFlLENBQ25CLElBQW1CLEVBQ25CLGdCQUF3QjtRQUV4QixPQUFPLElBQUksQ0FBQyxNQUFNLENBQUMsZUFBZSxDQUFDLElBQUksRUFBRSxnQkFBZ0IsQ0FBQyxDQUFDO0lBQzdELENBQUM7SUFHRDs7OztPQUlHLENBQ0ssS0FBSyxDQUFDLHNDQUFzQyxDQUFDLE1BSXBEO1FBQ0MsT0FBTyxDQUFDLEdBQUcsQ0FBQyx3REFBd0QsQ0FBQyxDQUFDO1FBQ3RFLE1BQU0sRUFBRSxrQkFBa0IsRUFBRSxvQkFBb0IsRUFBRSw0QkFBNEIsRUFBRSxHQUFHLE1BQU0sbU1BQStCLENBQUM7UUFFekgsdUJBQXVCO1FBQ3ZCLE1BQU0sY0FBYyxHQUFHLE1BQU0sQ0FBQyxPQUFPLElBQUksa0JBQWtCLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1FBQzdFLHlEQUF5RDtRQUN6RCxNQUFNLGVBQWUsR0FBRyxvQkFBb0IsQ0FBQyxjQUFjLENBQUMsQ0FBQztRQUU3RCxtQ0FBbUM7UUFDbkMsT0FBTyxDQUFDLEdBQUcsQ0FBQywyRkFBMkYsQ0FBQyxDQUFDO1FBQ3pHLE1BQU0sWUFBWSxHQUFHLE1BQU0sNEJBQTRCLENBQUMsY0FBYyxDQUFDLENBQUM7UUFFeEUsdUJBQXVCO1FBQ3ZCLE9BQU8sQ0FBQyxHQUFHLENBQUMsc0VBQXNFLENBQUM7UUFDbkYsT0FBTyxDQUFDLEdBQUcsQ0FBQyxvRUFBb0UsRUFBRSxZQUFZLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDeEcsTUFBTSxFQUFFLGtCQUFrQixFQUFFLElBQUksRUFBRSxhQUFhLEVBQUUsR0FBRyxNQUFNLHdPQUFjLENBQUM7UUFDekUsTUFBTSxZQUFZLEdBQUcsa0JBQWtCLENBQUM7WUFDdEMsT0FBTyxFQUFFLFlBQVk7WUFDckIsS0FBSyxFQUFFLGVBQWUsQ0FBQyxLQUFLO1lBQzVCLFNBQVMsRUFBRSxhQUFhLENBQUMsZUFBZSxDQUFDLE1BQU0sQ0FBQztTQUNqRCxDQUFDLENBQUM7UUFHSCxNQUFNLGtCQUFrQixHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsa0JBQWtCLENBQUM7UUFDMUQsSUFBSSxDQUFDLGtCQUFrQixFQUFFLENBQUM7WUFDeEIsTUFBTSxJQUFJLEtBQUssQ0FDYiw2RkFBNkYsQ0FDOUYsQ0FBQztRQUNKLENBQUM7UUFFRCxNQUFNLGdCQUFnQixHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsZ0JBQWdCLENBQUM7UUFDdEQsSUFBSSxDQUFDLGdCQUFnQixFQUFFLENBQUM7WUFDdEIsTUFBTSxJQUFJLEtBQUssQ0FDYix5RkFBeUYsQ0FDMUYsQ0FBQztRQUNKLENBQUM7SUFFSCxDQUFDO0lBRUQ7Ozs7T0FJRyxDQUNLLEtBQUssQ0FBQyxvQ0FBb0MsQ0FBQyxNQUF1QjtRQUN4RSxPQUFPLENBQUMsR0FBRyxDQUFDLGdEQUFnRCxDQUFDLENBQUM7UUFFOUQsTUFBTSxnQkFBZ0IsR0FBRyxNQUFNLENBQUMsZ0JBQWdCLENBQUM7UUFDakQsTUFBTSxrQkFBa0IsR0FBRyxNQUFNLENBQUMsa0JBQWtCLENBQUM7UUFFckQsSUFBSSxDQUFDLGdCQUFnQixJQUFJLENBQUMsa0JBQWtCLEVBQUUsQ0FBQztZQUM3QyxNQUFNLElBQUksS0FBSyxDQUNiLHdKQUF3SixDQUN6SixDQUFDO1FBQ0osQ0FBQztRQUdELE1BQU0sTUFBTSxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUM7UUFDN0IsSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDO1lBQ1osTUFBTSxJQUFJLEtBQUssQ0FDYixzRUFBc0UsQ0FDdkUsQ0FBQztRQUNKLENBQUM7UUFFRCwrQ0FBK0M7UUFDL0MsTUFBTSxXQUFXLEdBQUcsTUFBTSxDQUFDLGNBQWMsRUFBRSxXQUFXLElBQ25ELGdFQUFjLENBQUMsNEJBQTRCLEVBQUUsOERBQWdCLENBQUMsSUFBSSxTQUFTLENBQThCO1FBRTVHLElBQUksQ0FBQyxXQUFXLEVBQUUsQ0FBQztZQUNqQixPQUFPLENBQUMsR0FBRyxDQUFDLGtEQUFrRCxDQUFDLENBQUM7UUFDbEUsQ0FBQztRQUVELG9GQUFvRjtRQUNwRiwyREFBMkQ7UUFDM0QsSUFBSSxlQUFvQixDQUFDO1FBQ3pCLElBQUksVUFBcUMsQ0FBQztRQUUxQywyRUFBMkU7UUFDM0UsSUFBSSxtRUFBZ0IsQ0FBQyxPQUFPLENBQUMsRUFBRSxDQUFDO1lBQzlCLElBQUksQ0FBQztnQkFDSCxNQUFNLEVBQUUsV0FBVyxFQUFFLEdBQUcsTUFBTSxpTUFBOEIsQ0FBQztnQkFDN0QsTUFBTSxRQUFRLEdBQUcsTUFBTSxXQUFXLEVBQUUsQ0FBQztnQkFDckMsSUFBSSxRQUFRLElBQUksUUFBUSxDQUFDLGVBQWUsRUFBRSxDQUFDO29CQUN6Qyw2RUFBNkU7b0JBQzdFLGVBQWUsR0FBRyxRQUFRLENBQUMsZUFBZSxDQUFDLENBQUMsMkNBQTJDO29CQUN2RixVQUFVLEdBQUcsUUFBUSxDQUFDLE9BQU8sQ0FBQztvQkFDOUIsT0FBTyxDQUFDLEdBQUcsQ0FBQyxtRUFBbUUsRUFBRSxVQUFVLENBQUMsQ0FBQztnQkFDL0YsQ0FBQztZQUNILENBQUMsQ0FBQyxPQUFPLEtBQUssRUFBRSxDQUFDO2dCQUNmLHdDQUF3QztnQkFDeEMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxnRkFBZ0YsQ0FBQyxDQUFDO1lBQ2hHLENBQUM7UUFDSCxDQUFDLE1BQU0sQ0FBQztZQUNOLHlEQUF5RDtZQUN6RCxPQUFPLENBQUMsR0FBRyxDQUFDLDJGQUEyRixDQUFDLENBQUM7UUFDM0csQ0FBQztRQUVELHdDQUF3QztRQUN4QyxJQUFJLENBQUMsZUFBZSxFQUFFLENBQUM7WUFDckIsSUFBSSxDQUFDO2dCQUNILE1BQU0sRUFBRSxZQUFZLEVBQUUsR0FBRyxNQUFNLG1NQUErQixDQUFDO2dCQUMvRCxNQUFNLFNBQVMsR0FBRyxNQUFNLFlBQVksRUFBRSxDQUFDO2dCQUN2QyxJQUFJLFNBQVMsSUFBSSxTQUFTLENBQUMsZUFBZSxFQUFFLENBQUM7b0JBQzNDLGtDQUFrQztvQkFDbEMsTUFBTSxFQUFFLG1CQUFtQixFQUFFLEdBQUcsTUFBTSxxTEFBaUMsQ0FBQztvQkFDeEUsZUFBZSxHQUFHLElBQUksbUJBQW1CLENBQUM7d0JBQ3hDLFlBQVksRUFBRSxTQUFTLENBQUMsWUFBWTt3QkFDcEMsWUFBWSxFQUFFLFNBQVMsQ0FBQyxZQUFtQjt3QkFDM0MsT0FBTyxFQUFFLFNBQVMsQ0FBQyxPQUFPO3dCQUMxQixXQUFXLEVBQUU7NEJBQ1gsRUFBRSxFQUFFLFNBQVMsQ0FBQyxZQUFZLENBQUMsS0FBSyxFQUFFLEVBQUUsSUFBSSxRQUFROzRCQUNoRCxNQUFNLEVBQUcsU0FBUyxDQUFDLFlBQVksQ0FBQyxTQUFpQixFQUFFLEdBQUcsSUFBSSxFQUFFOzRCQUM1RCxJQUFJLEVBQUUsU0FBUyxDQUFDLFlBQVksQ0FBQyxLQUFLLEVBQUUsSUFBSSxJQUFJLFNBQVM7NEJBQ3JELEtBQUssRUFBRSxTQUFTLENBQUMsWUFBWSxDQUFDLEtBQUssSUFBSSxTQUFTO3lCQUNqRDtxQkFDRixDQUFDLENBQUM7b0JBQ0gsZUFBZSxHQUFHLFNBQVMsQ0FBQyxlQUFlLENBQUM7b0JBQzVDLFVBQVUsR0FBRyxTQUFTLENBQUMsT0FBTyxDQUFDO29CQUMvQixPQUFPLENBQUMsR0FBRyxDQUFDLG9FQUFvRSxFQUFFLFVBQVUsQ0FBQyxDQUFDO2dCQUNoRyxDQUFDO1lBQ0gsQ0FBQyxDQUFDLE9BQU8sS0FBSyxFQUFFLENBQUM7Z0JBQ2YsbURBQW1EO2dCQUNuRCxPQUFPLENBQUMsR0FBRyxDQUFDLDJGQUEyRixDQUFDLENBQUM7WUFDM0csQ0FBQztRQUNILENBQUM7UUFFRCxvRUFBb0U7UUFDcEUsSUFBSSxDQUFDLGVBQWUsSUFBSSxNQUFNLENBQUMsVUFBVSxFQUFFLENBQUM7WUFDMUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxnRkFBZ0YsQ0FBQyxDQUFDO1lBRTlGLHNEQUFzRDtZQUN0RCxJQUFJLFVBQVUsR0FBRyxNQUFNLENBQUMsVUFBVSxDQUFDLElBQUksRUFBRSxDQUFDLE9BQU8sQ0FBQyxNQUFNLEVBQUUsRUFBRSxDQUFDLENBQUM7WUFDOUQsSUFBSSxVQUFVLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUM7Z0JBQ2hDLFVBQVUsR0FBRyxVQUFVLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ25DLENBQUM7WUFDRCxJQUFJLENBQUMsbUJBQW1CLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxFQUFFLENBQUM7Z0JBQzFDLE1BQU0sSUFBSSxLQUFLLENBQUMsNEJBQTRCLENBQUMsQ0FBQztZQUNoRCxDQUFDO1lBQ0QsTUFBTSxhQUFhLEdBQUcsS0FBSyxVQUFVLEVBQW1CLENBQUM7WUFFekQsa0NBQWtDO1lBQ2xDLE1BQU0sRUFBRSxtQkFBbUIsRUFBRSxHQUFHLE1BQU0seVBBQXVCLENBQUM7WUFDOUQsTUFBTSxPQUFPLEdBQUcsbUJBQW1CLENBQUMsYUFBYSxDQUFDLENBQUM7WUFDbkQsVUFBVSxHQUFHLE9BQU8sQ0FBQyxPQUF3QixDQUFDO1lBRTlDLG1DQUFtQztZQUNuQyxNQUFNLEVBQUUsa0JBQWtCLEVBQUUsa0JBQWtCLEVBQUUsSUFBSSxFQUFFLGFBQWEsRUFBRSxHQUFHLE1BQU0sd09BQWMsQ0FBQztZQUM3RixNQUFNLEVBQUUsT0FBTyxFQUFFLEdBQUcsTUFBTSx3TEFBcUIsQ0FBQztZQUVoRCxNQUFNLFlBQVksR0FBRyxrQkFBa0IsQ0FBQztnQkFDdEMsS0FBSyxFQUFFLE9BQU87Z0JBQ2QsU0FBUyxFQUFFLGFBQWEsQ0FBQyxNQUFNLENBQUM7YUFDakMsQ0FBQyxDQUFDO1lBRUgsTUFBTSxZQUFZLEdBQUcsa0JBQWtCLENBQUM7Z0JBQ3RDLE9BQU87Z0JBQ1AsS0FBSyxFQUFFLE9BQU87Z0JBQ2QsU0FBUyxFQUFFLGFBQWEsQ0FBQyxNQUFNLENBQUM7YUFDakMsQ0FBQyxDQUFDO1lBRUgsMEJBQTBCO1lBQzFCLE1BQU0sRUFBRSxtQkFBbUIsRUFBRSxHQUFHLE1BQU0scUxBQWlDLENBQUM7WUFDeEUsZUFBZSxHQUFHLElBQUksbUJBQW1CLENBQUM7Z0JBQ3hDLFlBQVk7Z0JBQ1osWUFBWTtnQkFDWixPQUFPO2dCQUNQLFdBQVcsRUFBRTtvQkFDWCxFQUFFLEVBQUUsT0FBTyxDQUFDLEVBQUU7b0JBQ2QsTUFBTTtvQkFDTixJQUFJLEVBQUUsT0FBTyxDQUFDLElBQUk7b0JBQ2xCLEtBQUssRUFBRSxPQUFPO2lCQUNmO2FBQ0YsQ0FBQyxDQUFDO1lBQ0gsT0FBTyxDQUFDLEdBQUcsQ0FBQywrREFBK0QsRUFBRSxVQUFVLENBQUMsQ0FBQztRQUMzRixDQUFDO1FBRUQsdURBQXVEO1FBQ3ZELElBQUksQ0FBQyxlQUFlLEVBQUUsQ0FBQztZQUNyQixNQUFNLElBQUksS0FBSyxDQUNiLDREQUE0RCxHQUM1RCxtQkFBbUIsR0FDbkIsc0VBQXNFLEdBQ3RFLDZFQUE2RSxHQUM3RSx5RUFBeUUsQ0FDMUUsQ0FBQztRQUNKLENBQUM7UUFFRCwwREFBMEQ7UUFDMUQscUdBQXFHO1FBQ3JHLE1BQU0sRUFBRSx1QkFBdUIsRUFBRSxHQUFHLE1BQU0sNkxBQXFDLENBQUM7UUFFaEYsTUFBTSxnQkFBZ0IsR0FBRyxNQUFNLHVCQUF1QixDQUFDLE1BQU0sQ0FDM0QsZUFBZSxFQUNmLGdCQUFnQixFQUNoQixrQkFBa0IsRUFDbEIsV0FBWSxJQUFJLDRDQUE0QyxDQUFrQixrQ0FBbUM7O1FBR25ILCtDQUErQztRQUMvQyxrREFBa0Q7UUFDbEQsb0VBQW9FO1FBQ3BFLG1GQUFtRjtRQUNuRixpSEFBaUg7UUFDakgscUhBQXFIO1FBQ3JILGtGQUFrRjtRQUNsRixtRUFBbUU7UUFDbkUsb0RBQW9EO1FBRXBELHdGQUF3RjtRQUN4RixxSEFBcUg7UUFDckgseUNBQXlDO1FBRXpDLE9BQU8sQ0FBQyxHQUFHLENBQUMsdUZBQXVGLEVBQUUsVUFBVSxDQUFDLENBQUM7SUFDbkgsQ0FBQztJQUVEOztPQUVHLENBQ0gsS0FBSyxDQUFDLEtBQUssQ0FDVCxLQUFhLEVBQ2IsU0FBbUM7UUFFbkMsT0FBTyxJQUFJLENBQUMsYUFBYSxDQUFDLE9BQU8sQ0FBSSxLQUFLLEVBQUUsU0FBUyxDQUFDLENBQUM7SUFDekQsQ0FBQztJQUVEOztPQUVHLENBQ0gsS0FBSyxDQUFDLE1BQU0sQ0FDVixRQUFnQixFQUNoQixTQUFtQztRQUVuQyxPQUFPLElBQUksQ0FBQyxhQUFhLENBQUMsT0FBTyxDQUFJLFFBQVEsRUFBRSxTQUFTLENBQUMsQ0FBQztJQUM1RCxDQUFDO0lBRUQ7O09BRUcsQ0FDSCxnQkFBZ0I7UUFDZCxPQUFPLElBQUksQ0FBQyxhQUFhLENBQUM7SUFDNUIsQ0FBQztJQUVEOztPQUVHLENBQ0gsU0FBUyxDQUFDLE1BQWM7UUFDdEIsSUFBSSxDQUFDLE1BQU0sQ0FBQyxNQUFNLEdBQUcsTUFBTSxDQUFDO1FBRTVCLE1BQU0sVUFBVSxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsVUFBVSxJQUFJLEVBQUUsQ0FBQztRQUVoRCxtQ0FBbUM7UUFDbkMsTUFBTSxRQUFRLEdBQUcsVUFBVSxDQUFDLFFBQVEsQ0FBQyxVQUFVLENBQUMsR0FDNUMsVUFBVSxHQUNWLEdBQUcsVUFBVSxDQUFDLE9BQU8sQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUFDLFVBQVUsQ0FBQztRQUUvQyxNQUFNLE9BQU8sR0FBMkI7WUFDdEMsY0FBYyxFQUFFLGtCQUFrQjtZQUNsQyxNQUFNLEVBQUUsa0JBQWtCO1lBQzFCLGFBQWEsRUFBRSxVQUFVLE1BQU0sRUFBRTtZQUNqQyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsT0FBTztTQUN2QixDQUFDO1FBRUYsSUFBSSxDQUFDLGFBQWEsR0FBRyxJQUFJLDBEQUFhLENBQUMsUUFBUSxFQUFFO1lBQy9DLE9BQU87U0FDUixDQUFDLENBQUM7UUFFSCxrRUFBa0U7UUFDbEUsSUFBSSxDQUFDLE1BQU0sR0FBRyxJQUFJLGtEQUFTLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDbEMsSUFBSSxDQUFDLG1CQUFtQixHQUFHLElBQUksNEVBQXNCLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxDQUFDO0lBQzVFLENBQUM7SUFFRDs7T0FFRyxDQUNILFNBQVM7UUFDUCxPQUFPO1lBQUUsR0FBRyxJQUFJLENBQUMsTUFBTTtRQUFBLENBQUUsQ0FBQztJQUM1QixDQUFDO0lBRUM7Ozs7S0FJQyxDQUNELEtBQUssQ0FBQyxrQkFBa0I7UUFDdEIsTUFBTSxVQUFVLEdBQUcsT0FBTyxDQUFDLEdBQUcsQ0FBQywrQkFBK0IsQ0FBQztRQUUvRCxJQUFJLENBQUMsVUFBVSxFQUFFLENBQUM7WUFDaEIsTUFBTSxJQUFJLEtBQUssQ0FBQyxrRUFBa0UsQ0FBQyxDQUFDO1FBQ3RGLENBQUM7UUFFRCxNQUFNLEVBQUUsbUJBQW1CLEVBQUUsR0FBRyxNQUFNLHlQQUF1QixDQUFDO1FBQzlELE1BQU0sYUFBYSxHQUFHLFVBQVUsQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsS0FBSyxVQUFVLEVBQUUsQ0FBQztRQUNuRixNQUFNLE9BQU8sR0FBRyxtQkFBbUIsQ0FBQyxhQUE4QixDQUFDLENBQUM7UUFFcEUsT0FBTyxPQUFPLENBQUMsT0FBd0IsQ0FBQztJQUMxQyxDQUFDO0NBQ0oiLCJzb3VyY2VzIjpbIi9ob21lL2JhcmIvYWEvc3JjL3NlcnZlci9zaW5nbGV0b25zL2FnZW50aWNUcnVzdENsaWVudC50cyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@agentic-trust/core/dist/server/singletons/agenticTrustClient.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@agentic-trust/core/dist/server/singletons/associationClient.js":
/*!******************************************************************************************!*\
  !*** ../../node_modules/@agentic-trust/core/dist/server/singletons/associationClient.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getAssociationsClient: () => (/* binding */ getAssociationsClient),\n/* harmony export */   isAssociationsClientInitialized: () => (/* binding */ isAssociationsClientInitialized),\n/* harmony export */   resetAssociationsClient: () => (/* binding */ resetAssociationsClient)\n/* harmony export */ });\n/* harmony import */ var _agentic_trust_8004_ext_sdk__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @agentic-trust/8004-ext-sdk */ \"(rsc)/../../node_modules/@agentic-trust/8004-ext-sdk/dist/index.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ethers */ \"(rsc)/../../node_modules/ethers/lib.esm/address/address.js\");\n/* harmony import */ var _lib_chainConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/chainConfig */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/lib/chainConfig.js\");\n/* harmony import */ var _domainClient__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./domainClient */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/singletons/domainClient.js\");\n/* harmony import */ var _domainAccountProviders__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./domainAccountProviders */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/singletons/domainAccountProviders.js\");\n/**\n * Association Client Singleton\n *\n * Manages a singleton instance of AssociationsStoreClient\n * Initialized from environment variables and domain AccountProvider\n */\n\n\n\n\n\n// Associations proxy address - defaults from env or hardcoded\nfunction getAssociationsProxyAddress() {\n    const addr = process.env.ASSOCIATIONS_STORE_PROXY ||\n        process.env.ASSOCIATIONS_PROXY_ADDRESS ||\n        '0xaF7428906D31918dDA2986D1405E2Ded06561E59'; // Default Sepolia deployment\n    if (!addr.startsWith('0x') || addr.length !== 42) {\n        throw new Error(`Invalid ASSOCIATIONS_STORE_PROXY: ${addr}`);\n    }\n    // Accept non-checksummed mixed-case env values by normalizing.\n    try {\n        return ethers__WEBPACK_IMPORTED_MODULE_4__.getAddress(addr);\n    }\n    catch {\n        return ethers__WEBPACK_IMPORTED_MODULE_4__.getAddress(addr.toLowerCase());\n    }\n}\nclass AssociationDomainClient extends _domainClient__WEBPACK_IMPORTED_MODULE_2__.DomainClient {\n    constructor() {\n        super('association');\n    }\n    async buildClient(targetChainId, initArg) {\n        // Get associations proxy address (defaults to Sepolia deployment)\n        const associationsProxyAddress = getAssociationsProxyAddress();\n        const rpcUrl = (0,_lib_chainConfig__WEBPACK_IMPORTED_MODULE_1__.requireChainEnvVar)('AGENTIC_TRUST_RPC_URL', targetChainId);\n        // Create AccountProvider for associations (similar to validation)\n        const init = (initArg || {});\n        const userApps = init.userApps ?? (await (0,_domainAccountProviders__WEBPACK_IMPORTED_MODULE_3__.resolveDomainUserApps)());\n        const accountProvider = await (0,_domainAccountProviders__WEBPACK_IMPORTED_MODULE_3__.resolveValidationAccountProvider)(targetChainId, rpcUrl, userApps);\n        const associationClient = await _agentic_trust_8004_ext_sdk__WEBPACK_IMPORTED_MODULE_0__.AIAgentAssociationClient.create(accountProvider, associationsProxyAddress);\n        return associationClient;\n    }\n}\nconst associationDomainClient = new AssociationDomainClient();\nasync function getAssociationsClient(chainId) {\n    const targetChainId = chainId || _lib_chainConfig__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_CHAIN_ID;\n    return associationDomainClient.get(targetChainId);\n}\nfunction isAssociationsClientInitialized(chainId) {\n    const targetChainId = chainId || _lib_chainConfig__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_CHAIN_ID;\n    return associationDomainClient.isInitialized(targetChainId);\n}\nfunction resetAssociationsClient(chainId) {\n    const targetChainId = chainId || _lib_chainConfig__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_CHAIN_ID;\n    associationDomainClient.reset(targetChainId);\n}\n//# sourceMappingURL=associationClient.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BhZ2VudGljLXRydXN0L2NvcmUvZGlzdC9zZXJ2ZXIvc2luZ2xldG9ucy9hc3NvY2lhdGlvbkNsaWVudC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUN1RTtBQUN2QztBQUMwQztBQUM1QjtBQUVYO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0EsNkRBQTZELEtBQUs7QUFDbEU7QUFDQTtBQUNBO0FBQ0EsZUFBZSw4Q0FBaUI7QUFDaEM7QUFDQTtBQUNBLGVBQWUsOENBQWlCO0FBQ2hDO0FBQ0E7QUFDQSxzQ0FBc0MsdURBQVk7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLG9FQUFrQjtBQUN6QztBQUNBLG1DQUFtQztBQUNuQyxpREFBaUQsOEVBQXFCO0FBQ3RFLHNDQUFzQyx5RkFBZ0M7QUFDdEUsd0NBQXdDLGlGQUF3QjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AscUNBQXFDLDhEQUFnQjtBQUNyRDtBQUNBO0FBQ087QUFDUCxxQ0FBcUMsOERBQWdCO0FBQ3JEO0FBQ0E7QUFDTztBQUNQLHFDQUFxQyw4REFBZ0I7QUFDckQ7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9iYXJiL2FhL0Fzc29jaWF0ZWRBY2NvdW50cy9ub2RlX21vZHVsZXMvQGFnZW50aWMtdHJ1c3QvY29yZS9kaXN0L3NlcnZlci9zaW5nbGV0b25zL2Fzc29jaWF0aW9uQ2xpZW50LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQXNzb2NpYXRpb24gQ2xpZW50IFNpbmdsZXRvblxuICpcbiAqIE1hbmFnZXMgYSBzaW5nbGV0b24gaW5zdGFuY2Ugb2YgQXNzb2NpYXRpb25zU3RvcmVDbGllbnRcbiAqIEluaXRpYWxpemVkIGZyb20gZW52aXJvbm1lbnQgdmFyaWFibGVzIGFuZCBkb21haW4gQWNjb3VudFByb3ZpZGVyXG4gKi9cbmltcG9ydCB7IEFJQWdlbnRBc3NvY2lhdGlvbkNsaWVudCB9IGZyb20gJ0BhZ2VudGljLXRydXN0LzgwMDQtZXh0LXNkayc7XG5pbXBvcnQgeyBldGhlcnMgfSBmcm9tICdldGhlcnMnO1xuaW1wb3J0IHsgcmVxdWlyZUNoYWluRW52VmFyLCBERUZBVUxUX0NIQUlOX0lEIH0gZnJvbSAnLi4vbGliL2NoYWluQ29uZmlnJztcbmltcG9ydCB7IERvbWFpbkNsaWVudCB9IGZyb20gJy4vZG9tYWluQ2xpZW50JztcbmltcG9ydCB7IHJlc29sdmVEb21haW5Vc2VyQXBwcywgcmVzb2x2ZVZhbGlkYXRpb25BY2NvdW50UHJvdmlkZXIsIC8vIFJldXNlIHZhbGlkYXRpb24gYWNjb3VudCBwcm92aWRlciBwYXR0ZXJuXG4gfSBmcm9tICcuL2RvbWFpbkFjY291bnRQcm92aWRlcnMnO1xuLy8gQXNzb2NpYXRpb25zIHByb3h5IGFkZHJlc3MgLSBkZWZhdWx0cyBmcm9tIGVudiBvciBoYXJkY29kZWRcbmZ1bmN0aW9uIGdldEFzc29jaWF0aW9uc1Byb3h5QWRkcmVzcygpIHtcbiAgICBjb25zdCBhZGRyID0gcHJvY2Vzcy5lbnYuQVNTT0NJQVRJT05TX1NUT1JFX1BST1hZIHx8XG4gICAgICAgIHByb2Nlc3MuZW52LkFTU09DSUFUSU9OU19QUk9YWV9BRERSRVNTIHx8XG4gICAgICAgICcweGFGNzQyODkwNkQzMTkxOGREQTI5ODZEMTQwNUUyRGVkMDY1NjFFNTknOyAvLyBEZWZhdWx0IFNlcG9saWEgZGVwbG95bWVudFxuICAgIGlmICghYWRkci5zdGFydHNXaXRoKCcweCcpIHx8IGFkZHIubGVuZ3RoICE9PSA0Mikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgQVNTT0NJQVRJT05TX1NUT1JFX1BST1hZOiAke2FkZHJ9YCk7XG4gICAgfVxuICAgIC8vIEFjY2VwdCBub24tY2hlY2tzdW1tZWQgbWl4ZWQtY2FzZSBlbnYgdmFsdWVzIGJ5IG5vcm1hbGl6aW5nLlxuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBldGhlcnMuZ2V0QWRkcmVzcyhhZGRyKTtcbiAgICB9XG4gICAgY2F0Y2gge1xuICAgICAgICByZXR1cm4gZXRoZXJzLmdldEFkZHJlc3MoYWRkci50b0xvd2VyQ2FzZSgpKTtcbiAgICB9XG59XG5jbGFzcyBBc3NvY2lhdGlvbkRvbWFpbkNsaWVudCBleHRlbmRzIERvbWFpbkNsaWVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCdhc3NvY2lhdGlvbicpO1xuICAgIH1cbiAgICBhc3luYyBidWlsZENsaWVudCh0YXJnZXRDaGFpbklkLCBpbml0QXJnKSB7XG4gICAgICAgIC8vIEdldCBhc3NvY2lhdGlvbnMgcHJveHkgYWRkcmVzcyAoZGVmYXVsdHMgdG8gU2Vwb2xpYSBkZXBsb3ltZW50KVxuICAgICAgICBjb25zdCBhc3NvY2lhdGlvbnNQcm94eUFkZHJlc3MgPSBnZXRBc3NvY2lhdGlvbnNQcm94eUFkZHJlc3MoKTtcbiAgICAgICAgY29uc3QgcnBjVXJsID0gcmVxdWlyZUNoYWluRW52VmFyKCdBR0VOVElDX1RSVVNUX1JQQ19VUkwnLCB0YXJnZXRDaGFpbklkKTtcbiAgICAgICAgLy8gQ3JlYXRlIEFjY291bnRQcm92aWRlciBmb3IgYXNzb2NpYXRpb25zIChzaW1pbGFyIHRvIHZhbGlkYXRpb24pXG4gICAgICAgIGNvbnN0IGluaXQgPSAoaW5pdEFyZyB8fCB7fSk7XG4gICAgICAgIGNvbnN0IHVzZXJBcHBzID0gaW5pdC51c2VyQXBwcyA/PyAoYXdhaXQgcmVzb2x2ZURvbWFpblVzZXJBcHBzKCkpO1xuICAgICAgICBjb25zdCBhY2NvdW50UHJvdmlkZXIgPSBhd2FpdCByZXNvbHZlVmFsaWRhdGlvbkFjY291bnRQcm92aWRlcih0YXJnZXRDaGFpbklkLCBycGNVcmwsIHVzZXJBcHBzKTtcbiAgICAgICAgY29uc3QgYXNzb2NpYXRpb25DbGllbnQgPSBhd2FpdCBBSUFnZW50QXNzb2NpYXRpb25DbGllbnQuY3JlYXRlKGFjY291bnRQcm92aWRlciwgYXNzb2NpYXRpb25zUHJveHlBZGRyZXNzKTtcbiAgICAgICAgcmV0dXJuIGFzc29jaWF0aW9uQ2xpZW50O1xuICAgIH1cbn1cbmNvbnN0IGFzc29jaWF0aW9uRG9tYWluQ2xpZW50ID0gbmV3IEFzc29jaWF0aW9uRG9tYWluQ2xpZW50KCk7XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0QXNzb2NpYXRpb25zQ2xpZW50KGNoYWluSWQpIHtcbiAgICBjb25zdCB0YXJnZXRDaGFpbklkID0gY2hhaW5JZCB8fCBERUZBVUxUX0NIQUlOX0lEO1xuICAgIHJldHVybiBhc3NvY2lhdGlvbkRvbWFpbkNsaWVudC5nZXQodGFyZ2V0Q2hhaW5JZCk7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNBc3NvY2lhdGlvbnNDbGllbnRJbml0aWFsaXplZChjaGFpbklkKSB7XG4gICAgY29uc3QgdGFyZ2V0Q2hhaW5JZCA9IGNoYWluSWQgfHwgREVGQVVMVF9DSEFJTl9JRDtcbiAgICByZXR1cm4gYXNzb2NpYXRpb25Eb21haW5DbGllbnQuaXNJbml0aWFsaXplZCh0YXJnZXRDaGFpbklkKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiByZXNldEFzc29jaWF0aW9uc0NsaWVudChjaGFpbklkKSB7XG4gICAgY29uc3QgdGFyZ2V0Q2hhaW5JZCA9IGNoYWluSWQgfHwgREVGQVVMVF9DSEFJTl9JRDtcbiAgICBhc3NvY2lhdGlvbkRvbWFpbkNsaWVudC5yZXNldCh0YXJnZXRDaGFpbklkKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFzc29jaWF0aW9uQ2xpZW50LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@agentic-trust/core/dist/server/singletons/associationClient.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@agentic-trust/core/dist/server/singletons/discoveryClient.js":
/*!****************************************************************************************!*\
  !*** ../../node_modules/@agentic-trust/core/dist/server/singletons/discoveryClient.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getDiscoveryClient: () => (/* binding */ getDiscoveryClient),\n/* harmony export */   isDiscoveryClientInitialized: () => (/* binding */ isDiscoveryClientInitialized),\n/* harmony export */   resetDiscoveryClient: () => (/* binding */ resetDiscoveryClient)\n/* harmony export */ });\n/* harmony import */ var _agentic_trust_8004_ext_sdk__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @agentic-trust/8004-ext-sdk */ \"(rsc)/../../node_modules/@agentic-trust/8004-ext-sdk/dist/index.js\");\n/* harmony import */ var _domainClient__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./domainClient */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/singletons/domainClient.js\");\n/**\n * Discovery Client Singleton\n *\n * Manages a singleton instance of AIAgentDiscoveryClient\n * Initialized from environment variables or AgenticTrustClient config\n */\n\n\nclass DiscoveryDomainClient extends _domainClient__WEBPACK_IMPORTED_MODULE_1__.DomainClient {\n    constructor() {\n        super('discovery');\n    }\n    // initArg is an optional Partial<AIAgentDiscoveryClientConfig> override\n    async buildClient(_key, initArg) {\n        const overrideConfig = (initArg || {});\n        // Get configuration from environment variables or provided config\n        // Note: endpoint should be the full discovery GraphQL URL (e.g., https://api.example.com/graphql)\n        let discoveryUrl = overrideConfig.endpoint;\n        if (!discoveryUrl) {\n            // Try environment variable\n            discoveryUrl = process.env.AGENTIC_TRUST_DISCOVERY_URL;\n            // If it doesn't end with /graphql, append it\n            if (discoveryUrl && !discoveryUrl.endsWith('/graphql')) {\n                discoveryUrl = `${discoveryUrl.replace(/\\/$/, '')}/graphql`;\n            }\n        }\n        const apiKey = overrideConfig.apiKey ??\n            process.env.AGENTIC_TRUST_DISCOVERY_API_KEY;\n        if (!discoveryUrl) {\n            throw new Error('Missing required configuration: Discovery endpoint. Set AGENTIC_TRUST_DISCOVERY_URL or provide config.endpoint');\n        }\n        // Build full config\n        const clientConfig = {\n            endpoint: discoveryUrl,\n            apiKey,\n            timeout: overrideConfig.timeout,\n            headers: overrideConfig.headers,\n        };\n        return new _agentic_trust_8004_ext_sdk__WEBPACK_IMPORTED_MODULE_0__.AIAgentDiscoveryClient(clientConfig);\n    }\n}\nconst discoveryDomainClient = new DiscoveryDomainClient();\n/**\n * Get or create the AIAgentDiscoveryClient singleton\n * Initializes from environment variables or provided config\n */\nasync function getDiscoveryClient(config) {\n    const key = 'global';\n    // If a config override is provided, reset and reinitialize with that config\n    if (config) {\n        discoveryDomainClient.reset(key);\n        return discoveryDomainClient.get(key, config);\n    }\n    return discoveryDomainClient.get(key);\n}\n/**\n * Check if discovery client is initialized\n */\nfunction isDiscoveryClientInitialized() {\n    return discoveryDomainClient.isInitialized('global');\n}\n/**\n * Reset the singleton (useful for testing)\n */\nfunction resetDiscoveryClient() {\n    discoveryDomainClient.reset();\n}\n//# sourceMappingURL=discoveryClient.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BhZ2VudGljLXRydXN0L2NvcmUvZGlzdC9zZXJ2ZXIvc2luZ2xldG9ucy9kaXNjb3ZlcnlDbGllbnQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDc0U7QUFDeEI7QUFDOUMsb0NBQW9DLHVEQUFZO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxnQ0FBZ0M7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwrRUFBc0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvYmFyYi9hYS9Bc3NvY2lhdGVkQWNjb3VudHMvbm9kZV9tb2R1bGVzL0BhZ2VudGljLXRydXN0L2NvcmUvZGlzdC9zZXJ2ZXIvc2luZ2xldG9ucy9kaXNjb3ZlcnlDbGllbnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBEaXNjb3ZlcnkgQ2xpZW50IFNpbmdsZXRvblxuICpcbiAqIE1hbmFnZXMgYSBzaW5nbGV0b24gaW5zdGFuY2Ugb2YgQUlBZ2VudERpc2NvdmVyeUNsaWVudFxuICogSW5pdGlhbGl6ZWQgZnJvbSBlbnZpcm9ubWVudCB2YXJpYWJsZXMgb3IgQWdlbnRpY1RydXN0Q2xpZW50IGNvbmZpZ1xuICovXG5pbXBvcnQgeyBBSUFnZW50RGlzY292ZXJ5Q2xpZW50LCB9IGZyb20gJ0BhZ2VudGljLXRydXN0LzgwMDQtZXh0LXNkayc7XG5pbXBvcnQgeyBEb21haW5DbGllbnQgfSBmcm9tICcuL2RvbWFpbkNsaWVudCc7XG5jbGFzcyBEaXNjb3ZlcnlEb21haW5DbGllbnQgZXh0ZW5kcyBEb21haW5DbGllbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcignZGlzY292ZXJ5Jyk7XG4gICAgfVxuICAgIC8vIGluaXRBcmcgaXMgYW4gb3B0aW9uYWwgUGFydGlhbDxBSUFnZW50RGlzY292ZXJ5Q2xpZW50Q29uZmlnPiBvdmVycmlkZVxuICAgIGFzeW5jIGJ1aWxkQ2xpZW50KF9rZXksIGluaXRBcmcpIHtcbiAgICAgICAgY29uc3Qgb3ZlcnJpZGVDb25maWcgPSAoaW5pdEFyZyB8fCB7fSk7XG4gICAgICAgIC8vIEdldCBjb25maWd1cmF0aW9uIGZyb20gZW52aXJvbm1lbnQgdmFyaWFibGVzIG9yIHByb3ZpZGVkIGNvbmZpZ1xuICAgICAgICAvLyBOb3RlOiBlbmRwb2ludCBzaG91bGQgYmUgdGhlIGZ1bGwgZGlzY292ZXJ5IEdyYXBoUUwgVVJMIChlLmcuLCBodHRwczovL2FwaS5leGFtcGxlLmNvbS9ncmFwaHFsKVxuICAgICAgICBsZXQgZGlzY292ZXJ5VXJsID0gb3ZlcnJpZGVDb25maWcuZW5kcG9pbnQ7XG4gICAgICAgIGlmICghZGlzY292ZXJ5VXJsKSB7XG4gICAgICAgICAgICAvLyBUcnkgZW52aXJvbm1lbnQgdmFyaWFibGVcbiAgICAgICAgICAgIGRpc2NvdmVyeVVybCA9IHByb2Nlc3MuZW52LkFHRU5USUNfVFJVU1RfRElTQ09WRVJZX1VSTDtcbiAgICAgICAgICAgIC8vIElmIGl0IGRvZXNuJ3QgZW5kIHdpdGggL2dyYXBocWwsIGFwcGVuZCBpdFxuICAgICAgICAgICAgaWYgKGRpc2NvdmVyeVVybCAmJiAhZGlzY292ZXJ5VXJsLmVuZHNXaXRoKCcvZ3JhcGhxbCcpKSB7XG4gICAgICAgICAgICAgICAgZGlzY292ZXJ5VXJsID0gYCR7ZGlzY292ZXJ5VXJsLnJlcGxhY2UoL1xcLyQvLCAnJyl9L2dyYXBocWxgO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFwaUtleSA9IG92ZXJyaWRlQ29uZmlnLmFwaUtleSA/P1xuICAgICAgICAgICAgcHJvY2Vzcy5lbnYuQUdFTlRJQ19UUlVTVF9ESVNDT1ZFUllfQVBJX0tFWTtcbiAgICAgICAgaWYgKCFkaXNjb3ZlcnlVcmwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyByZXF1aXJlZCBjb25maWd1cmF0aW9uOiBEaXNjb3ZlcnkgZW5kcG9pbnQuIFNldCBBR0VOVElDX1RSVVNUX0RJU0NPVkVSWV9VUkwgb3IgcHJvdmlkZSBjb25maWcuZW5kcG9pbnQnKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBCdWlsZCBmdWxsIGNvbmZpZ1xuICAgICAgICBjb25zdCBjbGllbnRDb25maWcgPSB7XG4gICAgICAgICAgICBlbmRwb2ludDogZGlzY292ZXJ5VXJsLFxuICAgICAgICAgICAgYXBpS2V5LFxuICAgICAgICAgICAgdGltZW91dDogb3ZlcnJpZGVDb25maWcudGltZW91dCxcbiAgICAgICAgICAgIGhlYWRlcnM6IG92ZXJyaWRlQ29uZmlnLmhlYWRlcnMsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBuZXcgQUlBZ2VudERpc2NvdmVyeUNsaWVudChjbGllbnRDb25maWcpO1xuICAgIH1cbn1cbmNvbnN0IGRpc2NvdmVyeURvbWFpbkNsaWVudCA9IG5ldyBEaXNjb3ZlcnlEb21haW5DbGllbnQoKTtcbi8qKlxuICogR2V0IG9yIGNyZWF0ZSB0aGUgQUlBZ2VudERpc2NvdmVyeUNsaWVudCBzaW5nbGV0b25cbiAqIEluaXRpYWxpemVzIGZyb20gZW52aXJvbm1lbnQgdmFyaWFibGVzIG9yIHByb3ZpZGVkIGNvbmZpZ1xuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0RGlzY292ZXJ5Q2xpZW50KGNvbmZpZykge1xuICAgIGNvbnN0IGtleSA9ICdnbG9iYWwnO1xuICAgIC8vIElmIGEgY29uZmlnIG92ZXJyaWRlIGlzIHByb3ZpZGVkLCByZXNldCBhbmQgcmXigJFpbml0aWFsaXplIHdpdGggdGhhdCBjb25maWdcbiAgICBpZiAoY29uZmlnKSB7XG4gICAgICAgIGRpc2NvdmVyeURvbWFpbkNsaWVudC5yZXNldChrZXkpO1xuICAgICAgICByZXR1cm4gZGlzY292ZXJ5RG9tYWluQ2xpZW50LmdldChrZXksIGNvbmZpZyk7XG4gICAgfVxuICAgIHJldHVybiBkaXNjb3ZlcnlEb21haW5DbGllbnQuZ2V0KGtleSk7XG59XG4vKipcbiAqIENoZWNrIGlmIGRpc2NvdmVyeSBjbGllbnQgaXMgaW5pdGlhbGl6ZWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzRGlzY292ZXJ5Q2xpZW50SW5pdGlhbGl6ZWQoKSB7XG4gICAgcmV0dXJuIGRpc2NvdmVyeURvbWFpbkNsaWVudC5pc0luaXRpYWxpemVkKCdnbG9iYWwnKTtcbn1cbi8qKlxuICogUmVzZXQgdGhlIHNpbmdsZXRvbiAodXNlZnVsIGZvciB0ZXN0aW5nKVxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVzZXREaXNjb3ZlcnlDbGllbnQoKSB7XG4gICAgZGlzY292ZXJ5RG9tYWluQ2xpZW50LnJlc2V0KCk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kaXNjb3ZlcnlDbGllbnQuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@agentic-trust/core/dist/server/singletons/discoveryClient.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@agentic-trust/core/dist/server/singletons/domainAccountProviders.js":
/*!***********************************************************************************************!*\
  !*** ../../node_modules/@agentic-trust/core/dist/server/singletons/domainAccountProviders.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   resolveDomainUserApps: () => (/* binding */ resolveDomainUserApps),\n/* harmony export */   resolveENSAccountProvider: () => (/* binding */ resolveENSAccountProvider),\n/* harmony export */   resolveReputationAccountProvider: () => (/* binding */ resolveReputationAccountProvider),\n/* harmony export */   resolveValidationAccountProvider: () => (/* binding */ resolveValidationAccountProvider)\n/* harmony export */ });\n/* harmony import */ var _agentic_trust_8004_sdk__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @agentic-trust/8004-sdk */ \"(rsc)/../../node_modules/@agentic-trust/8004-sdk/dist/index.js\");\n/* harmony import */ var _userApps_adminApp__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../userApps/adminApp */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/userApps/adminApp.js\");\n/* harmony import */ var _userApps_clientApp__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../userApps/clientApp */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/userApps/clientApp.js\");\n/* harmony import */ var _userApps_providerApp__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../userApps/providerApp */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/userApps/providerApp.js\");\n/* harmony import */ var _userApps_validatorApp__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../userApps/validatorApp */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/userApps/validatorApp.js\");\n/* harmony import */ var _userApps_userApp__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../userApps/userApp */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/userApps/userApp.js\");\n/**\n * Shared helpers to resolve AccountProviders for domain clients\n * (reputation, ENS, etc.) from user apps and environment.\n */\n\n\n\n\n\n\n/**\n * Resolve which user apps are active in this process based on roles.\n * This can be called once and passed into domain client initializers.\n */\nasync function resolveDomainUserApps() {\n    const ctx = {};\n    if ((0,_userApps_userApp__WEBPACK_IMPORTED_MODULE_5__.isUserAppEnabled)('admin')) {\n        try {\n            ctx.adminApp = await (0,_userApps_adminApp__WEBPACK_IMPORTED_MODULE_1__.getAdminApp)();\n        }\n        catch (error) {\n            const message = error instanceof Error ? error.message : String(error);\n            console.warn('AdminApp not available while resolving domain user apps (non-fatal):', message);\n        }\n    }\n    if ((0,_userApps_userApp__WEBPACK_IMPORTED_MODULE_5__.isUserAppEnabled)('provider')) {\n        try {\n            ctx.providerApp = await (0,_userApps_providerApp__WEBPACK_IMPORTED_MODULE_3__.getProviderApp)();\n            // If undefined, session package may be loaded from database instead - this is expected\n            // Only log if there was an actual error (not just missing env var)\n        }\n        catch (error) {\n            // Only log actual errors, not missing env var (which is expected when using database-loaded packages)\n            const errorMessage = error instanceof Error ? error.message : String(error);\n            if (!errorMessage.includes('AGENTIC_TRUST_SESSION_PACKAGE_PATH')) {\n                console.warn('ProviderApp not available while resolving domain user apps:', error);\n            }\n        }\n    }\n    if ((0,_userApps_userApp__WEBPACK_IMPORTED_MODULE_5__.isUserAppEnabled)('client')) {\n        try {\n            ctx.clientApp = await (0,_userApps_clientApp__WEBPACK_IMPORTED_MODULE_2__.getClientApp)();\n        }\n        catch (error) {\n            console.warn('ClientApp not available while resolving domain user apps:', error);\n        }\n    }\n    if ((0,_userApps_userApp__WEBPACK_IMPORTED_MODULE_5__.isUserAppEnabled)('validator')) {\n        try {\n            ctx.validatorApp = await (0,_userApps_validatorApp__WEBPACK_IMPORTED_MODULE_4__.getValidatorApp)();\n        }\n        catch (error) {\n            console.warn('ValidatorApp not available while resolving domain user apps:', error);\n        }\n    }\n    return ctx;\n}\n/**\n * Resolve an AccountProvider suitable for reputation operations\n * for the given chain. Prefers:\n *   1. AdminApp\n *   2. ProviderApp (optionally upgraded by ClientApp)\n *   3. ClientApp\n *\n * Falls back to a read-only provider derived from the provider's\n * session key (if available).\n */\nasync function resolveReputationAccountProvider(chainId, rpcUrl, userApps) {\n    const ctx = userApps ?? (await resolveDomainUserApps());\n    if (ctx.adminApp?.accountProvider) {\n        return ctx.adminApp.accountProvider;\n    }\n    if (ctx.providerApp?.accountProvider) {\n        let provider = ctx.providerApp.accountProvider;\n        // If a ClientApp is also available, prefer its AccountProvider\n        if (ctx.clientApp?.accountProvider) {\n            provider = ctx.clientApp.accountProvider;\n        }\n        else {\n            // Fallback: derive a read-only client provider from the session key\n            const sessionKeyAddress = ctx.providerApp.sessionPackage.sessionKey.address;\n            const { createPublicClient, http } = await Promise.all(/*! import() */[__webpack_require__.e(\"vendor-chunks/viem\"), __webpack_require__.e(\"vendor-chunks/abitype\")]).then(__webpack_require__.bind(__webpack_require__, /*! viem */ \"(rsc)/../../node_modules/viem/_esm/index.js\"));\n            const { sepolia } = await __webpack_require__.e(/*! import() */ \"vendor-chunks/viem\").then(__webpack_require__.bind(__webpack_require__, /*! viem/chains */ \"(rsc)/../../node_modules/viem/_esm/chains/index.js\"));\n            const clientPublicClient = createPublicClient({\n                chain: sepolia,\n                transport: http(rpcUrl),\n            });\n            provider = new _agentic_trust_8004_sdk__WEBPACK_IMPORTED_MODULE_0__.ViemAccountProvider({\n                publicClient: clientPublicClient,\n                walletClient: null,\n                account: sessionKeyAddress,\n                chainConfig: {\n                    id: sepolia.id,\n                    rpcUrl,\n                    name: sepolia.name,\n                    chain: sepolia,\n                },\n            });\n        }\n        return provider;\n    }\n    if (ctx.clientApp?.accountProvider) {\n        return ctx.clientApp.accountProvider;\n    }\n    // Fallback: read-only public client using the provided RPC URL.\n    // This is sufficient for read-only operations such as reputation/validation summaries.\n    const { createPublicClient, http } = await Promise.all(/*! import() */[__webpack_require__.e(\"vendor-chunks/viem\"), __webpack_require__.e(\"vendor-chunks/abitype\")]).then(__webpack_require__.bind(__webpack_require__, /*! viem */ \"(rsc)/../../node_modules/viem/_esm/index.js\"));\n    const { sepolia } = await __webpack_require__.e(/*! import() */ \"vendor-chunks/viem\").then(__webpack_require__.bind(__webpack_require__, /*! viem/chains */ \"(rsc)/../../node_modules/viem/_esm/chains/index.js\"));\n    const publicClient = createPublicClient({\n        chain: sepolia,\n        transport: http(rpcUrl),\n    });\n    return new _agentic_trust_8004_sdk__WEBPACK_IMPORTED_MODULE_0__.ViemAccountProvider({\n        publicClient: publicClient,\n        walletClient: null,\n        account: undefined,\n        chainConfig: {\n            id: sepolia.id,\n            rpcUrl,\n            name: sepolia.name,\n            chain: sepolia,\n        },\n    });\n}\n/**\n * Resolve an AccountProvider suitable for ENS operations for the given chain.\n * Prefers:\n *   1. AdminApp\n *   2. ClientApp\n *   3. ProviderApp\n *\n * Falls back to a read-only provider if none are available.\n */\nasync function resolveENSAccountProvider(chainId, rpcUrl, userApps) {\n    const ctx = userApps ?? (await resolveDomainUserApps());\n    if (ctx.adminApp?.accountProvider) {\n        return ctx.adminApp.accountProvider;\n    }\n    if (ctx.clientApp?.accountProvider) {\n        return ctx.clientApp.accountProvider;\n    }\n    if (ctx.providerApp?.accountProvider) {\n        return ctx.providerApp.accountProvider;\n    }\n    // Fallback: read-only public client\n    const { createPublicClient, http } = await Promise.all(/*! import() */[__webpack_require__.e(\"vendor-chunks/viem\"), __webpack_require__.e(\"vendor-chunks/abitype\")]).then(__webpack_require__.bind(__webpack_require__, /*! viem */ \"(rsc)/../../node_modules/viem/_esm/index.js\"));\n    const { sepolia } = await __webpack_require__.e(/*! import() */ \"vendor-chunks/viem\").then(__webpack_require__.bind(__webpack_require__, /*! viem/chains */ \"(rsc)/../../node_modules/viem/_esm/chains/index.js\"));\n    const publicClient = createPublicClient({\n        chain: sepolia,\n        transport: http(rpcUrl),\n    });\n    return new _agentic_trust_8004_sdk__WEBPACK_IMPORTED_MODULE_0__.ViemAccountProvider({\n        publicClient,\n        walletClient: null,\n        account: undefined,\n        chainConfig: {\n            id: sepolia.id,\n            rpcUrl,\n            name: sepolia.name,\n            chain: sepolia,\n        },\n    });\n}\n/**\n * Resolve an AccountProvider suitable for validation operations for the given chain.\n * Prefers:\n *   1. ValidatorApp (for validation responses)\n *   2. AdminApp\n *   3. ProviderApp\n *   4. ClientApp\n *\n * Falls back to a read-only provider if none are available.\n */\nasync function resolveValidationAccountProvider(chainId, rpcUrl, userApps) {\n    const ctx = userApps ?? (await resolveDomainUserApps());\n    // ValidatorApp is preferred for validation operations\n    if (ctx.validatorApp?.accountProvider) {\n        return ctx.validatorApp.accountProvider;\n    }\n    if (ctx.adminApp?.accountProvider) {\n        return ctx.adminApp.accountProvider;\n    }\n    if (ctx.providerApp?.accountProvider) {\n        return ctx.providerApp.accountProvider;\n    }\n    if (ctx.clientApp?.accountProvider) {\n        return ctx.clientApp.accountProvider;\n    }\n    // Fallback: read-only public client\n    const { createPublicClient, http } = await Promise.all(/*! import() */[__webpack_require__.e(\"vendor-chunks/viem\"), __webpack_require__.e(\"vendor-chunks/abitype\")]).then(__webpack_require__.bind(__webpack_require__, /*! viem */ \"(rsc)/../../node_modules/viem/_esm/index.js\"));\n    const { sepolia } = await __webpack_require__.e(/*! import() */ \"vendor-chunks/viem\").then(__webpack_require__.bind(__webpack_require__, /*! viem/chains */ \"(rsc)/../../node_modules/viem/_esm/chains/index.js\"));\n    const publicClient = createPublicClient({\n        chain: sepolia,\n        transport: http(rpcUrl),\n    });\n    return new _agentic_trust_8004_sdk__WEBPACK_IMPORTED_MODULE_0__.ViemAccountProvider({\n        publicClient,\n        walletClient: null,\n        account: undefined,\n        chainConfig: {\n            id: sepolia.id,\n            rpcUrl,\n            name: sepolia.name,\n            chain: sepolia,\n        },\n    });\n}\n//# sourceMappingURL=domainAccountProviders.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BhZ2VudGljLXRydXN0L2NvcmUvZGlzdC9zZXJ2ZXIvc2luZ2xldG9ucy9kb21haW5BY2NvdW50UHJvdmlkZXJzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUM4RDtBQUNYO0FBQ0U7QUFDSTtBQUNFO0FBQ0o7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsUUFBUSxtRUFBZ0I7QUFDeEI7QUFDQSxpQ0FBaUMsK0RBQVc7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxtRUFBZ0I7QUFDeEI7QUFDQSxvQ0FBb0MscUVBQWM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsbUVBQWdCO0FBQ3hCO0FBQ0Esa0NBQWtDLGlFQUFZO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLG1FQUFnQjtBQUN4QjtBQUNBLHFDQUFxQyx1RUFBZTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwyQkFBMkIsUUFBUSx3T0FBYztBQUNyRSxvQkFBb0IsVUFBVSxRQUFRLHdMQUFxQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsMkJBQTJCLHdFQUFtQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwyQkFBMkIsUUFBUSx3T0FBYztBQUM3RCxZQUFZLFVBQVUsUUFBUSx3TEFBcUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGVBQWUsd0VBQW1CO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwyQkFBMkIsUUFBUSx3T0FBYztBQUM3RCxZQUFZLFVBQVUsUUFBUSx3TEFBcUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGVBQWUsd0VBQW1CO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksMkJBQTJCLFFBQVEsd09BQWM7QUFDN0QsWUFBWSxVQUFVLFFBQVEsd0xBQXFCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxlQUFlLHdFQUFtQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9iYXJiL2FhL0Fzc29jaWF0ZWRBY2NvdW50cy9ub2RlX21vZHVsZXMvQGFnZW50aWMtdHJ1c3QvY29yZS9kaXN0L3NlcnZlci9zaW5nbGV0b25zL2RvbWFpbkFjY291bnRQcm92aWRlcnMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBTaGFyZWQgaGVscGVycyB0byByZXNvbHZlIEFjY291bnRQcm92aWRlcnMgZm9yIGRvbWFpbiBjbGllbnRzXG4gKiAocmVwdXRhdGlvbiwgRU5TLCBldGMuKSBmcm9tIHVzZXIgYXBwcyBhbmQgZW52aXJvbm1lbnQuXG4gKi9cbmltcG9ydCB7IFZpZW1BY2NvdW50UHJvdmlkZXIgfSBmcm9tICdAYWdlbnRpYy10cnVzdC84MDA0LXNkayc7XG5pbXBvcnQgeyBnZXRBZG1pbkFwcCB9IGZyb20gJy4uL3VzZXJBcHBzL2FkbWluQXBwJztcbmltcG9ydCB7IGdldENsaWVudEFwcCB9IGZyb20gJy4uL3VzZXJBcHBzL2NsaWVudEFwcCc7XG5pbXBvcnQgeyBnZXRQcm92aWRlckFwcCB9IGZyb20gJy4uL3VzZXJBcHBzL3Byb3ZpZGVyQXBwJztcbmltcG9ydCB7IGdldFZhbGlkYXRvckFwcCB9IGZyb20gJy4uL3VzZXJBcHBzL3ZhbGlkYXRvckFwcCc7XG5pbXBvcnQgeyBpc1VzZXJBcHBFbmFibGVkIH0gZnJvbSAnLi4vdXNlckFwcHMvdXNlckFwcCc7XG4vKipcbiAqIFJlc29sdmUgd2hpY2ggdXNlciBhcHBzIGFyZSBhY3RpdmUgaW4gdGhpcyBwcm9jZXNzIGJhc2VkIG9uIHJvbGVzLlxuICogVGhpcyBjYW4gYmUgY2FsbGVkIG9uY2UgYW5kIHBhc3NlZCBpbnRvIGRvbWFpbiBjbGllbnQgaW5pdGlhbGl6ZXJzLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVzb2x2ZURvbWFpblVzZXJBcHBzKCkge1xuICAgIGNvbnN0IGN0eCA9IHt9O1xuICAgIGlmIChpc1VzZXJBcHBFbmFibGVkKCdhZG1pbicpKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjdHguYWRtaW5BcHAgPSBhd2FpdCBnZXRBZG1pbkFwcCgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKTtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignQWRtaW5BcHAgbm90IGF2YWlsYWJsZSB3aGlsZSByZXNvbHZpbmcgZG9tYWluIHVzZXIgYXBwcyAobm9uLWZhdGFsKTonLCBtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNVc2VyQXBwRW5hYmxlZCgncHJvdmlkZXInKSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY3R4LnByb3ZpZGVyQXBwID0gYXdhaXQgZ2V0UHJvdmlkZXJBcHAoKTtcbiAgICAgICAgICAgIC8vIElmIHVuZGVmaW5lZCwgc2Vzc2lvbiBwYWNrYWdlIG1heSBiZSBsb2FkZWQgZnJvbSBkYXRhYmFzZSBpbnN0ZWFkIC0gdGhpcyBpcyBleHBlY3RlZFxuICAgICAgICAgICAgLy8gT25seSBsb2cgaWYgdGhlcmUgd2FzIGFuIGFjdHVhbCBlcnJvciAobm90IGp1c3QgbWlzc2luZyBlbnYgdmFyKVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgLy8gT25seSBsb2cgYWN0dWFsIGVycm9ycywgbm90IG1pc3NpbmcgZW52IHZhciAod2hpY2ggaXMgZXhwZWN0ZWQgd2hlbiB1c2luZyBkYXRhYmFzZS1sb2FkZWQgcGFja2FnZXMpXG4gICAgICAgICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvcik7XG4gICAgICAgICAgICBpZiAoIWVycm9yTWVzc2FnZS5pbmNsdWRlcygnQUdFTlRJQ19UUlVTVF9TRVNTSU9OX1BBQ0tBR0VfUEFUSCcpKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdQcm92aWRlckFwcCBub3QgYXZhaWxhYmxlIHdoaWxlIHJlc29sdmluZyBkb21haW4gdXNlciBhcHBzOicsIGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNVc2VyQXBwRW5hYmxlZCgnY2xpZW50JykpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGN0eC5jbGllbnRBcHAgPSBhd2FpdCBnZXRDbGllbnRBcHAoKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignQ2xpZW50QXBwIG5vdCBhdmFpbGFibGUgd2hpbGUgcmVzb2x2aW5nIGRvbWFpbiB1c2VyIGFwcHM6JywgZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChpc1VzZXJBcHBFbmFibGVkKCd2YWxpZGF0b3InKSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY3R4LnZhbGlkYXRvckFwcCA9IGF3YWl0IGdldFZhbGlkYXRvckFwcCgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdWYWxpZGF0b3JBcHAgbm90IGF2YWlsYWJsZSB3aGlsZSByZXNvbHZpbmcgZG9tYWluIHVzZXIgYXBwczonLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGN0eDtcbn1cbi8qKlxuICogUmVzb2x2ZSBhbiBBY2NvdW50UHJvdmlkZXIgc3VpdGFibGUgZm9yIHJlcHV0YXRpb24gb3BlcmF0aW9uc1xuICogZm9yIHRoZSBnaXZlbiBjaGFpbi4gUHJlZmVyczpcbiAqICAgMS4gQWRtaW5BcHBcbiAqICAgMi4gUHJvdmlkZXJBcHAgKG9wdGlvbmFsbHkgdXBncmFkZWQgYnkgQ2xpZW50QXBwKVxuICogICAzLiBDbGllbnRBcHBcbiAqXG4gKiBGYWxscyBiYWNrIHRvIGEgcmVhZC1vbmx5IHByb3ZpZGVyIGRlcml2ZWQgZnJvbSB0aGUgcHJvdmlkZXInc1xuICogc2Vzc2lvbiBrZXkgKGlmIGF2YWlsYWJsZSkuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZXNvbHZlUmVwdXRhdGlvbkFjY291bnRQcm92aWRlcihjaGFpbklkLCBycGNVcmwsIHVzZXJBcHBzKSB7XG4gICAgY29uc3QgY3R4ID0gdXNlckFwcHMgPz8gKGF3YWl0IHJlc29sdmVEb21haW5Vc2VyQXBwcygpKTtcbiAgICBpZiAoY3R4LmFkbWluQXBwPy5hY2NvdW50UHJvdmlkZXIpIHtcbiAgICAgICAgcmV0dXJuIGN0eC5hZG1pbkFwcC5hY2NvdW50UHJvdmlkZXI7XG4gICAgfVxuICAgIGlmIChjdHgucHJvdmlkZXJBcHA/LmFjY291bnRQcm92aWRlcikge1xuICAgICAgICBsZXQgcHJvdmlkZXIgPSBjdHgucHJvdmlkZXJBcHAuYWNjb3VudFByb3ZpZGVyO1xuICAgICAgICAvLyBJZiBhIENsaWVudEFwcCBpcyBhbHNvIGF2YWlsYWJsZSwgcHJlZmVyIGl0cyBBY2NvdW50UHJvdmlkZXJcbiAgICAgICAgaWYgKGN0eC5jbGllbnRBcHA/LmFjY291bnRQcm92aWRlcikge1xuICAgICAgICAgICAgcHJvdmlkZXIgPSBjdHguY2xpZW50QXBwLmFjY291bnRQcm92aWRlcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIEZhbGxiYWNrOiBkZXJpdmUgYSByZWFkLW9ubHkgY2xpZW50IHByb3ZpZGVyIGZyb20gdGhlIHNlc3Npb24ga2V5XG4gICAgICAgICAgICBjb25zdCBzZXNzaW9uS2V5QWRkcmVzcyA9IGN0eC5wcm92aWRlckFwcC5zZXNzaW9uUGFja2FnZS5zZXNzaW9uS2V5LmFkZHJlc3M7XG4gICAgICAgICAgICBjb25zdCB7IGNyZWF0ZVB1YmxpY0NsaWVudCwgaHR0cCB9ID0gYXdhaXQgaW1wb3J0KCd2aWVtJyk7XG4gICAgICAgICAgICBjb25zdCB7IHNlcG9saWEgfSA9IGF3YWl0IGltcG9ydCgndmllbS9jaGFpbnMnKTtcbiAgICAgICAgICAgIGNvbnN0IGNsaWVudFB1YmxpY0NsaWVudCA9IGNyZWF0ZVB1YmxpY0NsaWVudCh7XG4gICAgICAgICAgICAgICAgY2hhaW46IHNlcG9saWEsXG4gICAgICAgICAgICAgICAgdHJhbnNwb3J0OiBodHRwKHJwY1VybCksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHByb3ZpZGVyID0gbmV3IFZpZW1BY2NvdW50UHJvdmlkZXIoe1xuICAgICAgICAgICAgICAgIHB1YmxpY0NsaWVudDogY2xpZW50UHVibGljQ2xpZW50LFxuICAgICAgICAgICAgICAgIHdhbGxldENsaWVudDogbnVsbCxcbiAgICAgICAgICAgICAgICBhY2NvdW50OiBzZXNzaW9uS2V5QWRkcmVzcyxcbiAgICAgICAgICAgICAgICBjaGFpbkNvbmZpZzoge1xuICAgICAgICAgICAgICAgICAgICBpZDogc2Vwb2xpYS5pZCxcbiAgICAgICAgICAgICAgICAgICAgcnBjVXJsLFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiBzZXBvbGlhLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGNoYWluOiBzZXBvbGlhLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJvdmlkZXI7XG4gICAgfVxuICAgIGlmIChjdHguY2xpZW50QXBwPy5hY2NvdW50UHJvdmlkZXIpIHtcbiAgICAgICAgcmV0dXJuIGN0eC5jbGllbnRBcHAuYWNjb3VudFByb3ZpZGVyO1xuICAgIH1cbiAgICAvLyBGYWxsYmFjazogcmVhZC1vbmx5IHB1YmxpYyBjbGllbnQgdXNpbmcgdGhlIHByb3ZpZGVkIFJQQyBVUkwuXG4gICAgLy8gVGhpcyBpcyBzdWZmaWNpZW50IGZvciByZWFkLW9ubHkgb3BlcmF0aW9ucyBzdWNoIGFzIHJlcHV0YXRpb24vdmFsaWRhdGlvbiBzdW1tYXJpZXMuXG4gICAgY29uc3QgeyBjcmVhdGVQdWJsaWNDbGllbnQsIGh0dHAgfSA9IGF3YWl0IGltcG9ydCgndmllbScpO1xuICAgIGNvbnN0IHsgc2Vwb2xpYSB9ID0gYXdhaXQgaW1wb3J0KCd2aWVtL2NoYWlucycpO1xuICAgIGNvbnN0IHB1YmxpY0NsaWVudCA9IGNyZWF0ZVB1YmxpY0NsaWVudCh7XG4gICAgICAgIGNoYWluOiBzZXBvbGlhLFxuICAgICAgICB0cmFuc3BvcnQ6IGh0dHAocnBjVXJsKSxcbiAgICB9KTtcbiAgICByZXR1cm4gbmV3IFZpZW1BY2NvdW50UHJvdmlkZXIoe1xuICAgICAgICBwdWJsaWNDbGllbnQ6IHB1YmxpY0NsaWVudCxcbiAgICAgICAgd2FsbGV0Q2xpZW50OiBudWxsLFxuICAgICAgICBhY2NvdW50OiB1bmRlZmluZWQsXG4gICAgICAgIGNoYWluQ29uZmlnOiB7XG4gICAgICAgICAgICBpZDogc2Vwb2xpYS5pZCxcbiAgICAgICAgICAgIHJwY1VybCxcbiAgICAgICAgICAgIG5hbWU6IHNlcG9saWEubmFtZSxcbiAgICAgICAgICAgIGNoYWluOiBzZXBvbGlhLFxuICAgICAgICB9LFxuICAgIH0pO1xufVxuLyoqXG4gKiBSZXNvbHZlIGFuIEFjY291bnRQcm92aWRlciBzdWl0YWJsZSBmb3IgRU5TIG9wZXJhdGlvbnMgZm9yIHRoZSBnaXZlbiBjaGFpbi5cbiAqIFByZWZlcnM6XG4gKiAgIDEuIEFkbWluQXBwXG4gKiAgIDIuIENsaWVudEFwcFxuICogICAzLiBQcm92aWRlckFwcFxuICpcbiAqIEZhbGxzIGJhY2sgdG8gYSByZWFkLW9ubHkgcHJvdmlkZXIgaWYgbm9uZSBhcmUgYXZhaWxhYmxlLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVzb2x2ZUVOU0FjY291bnRQcm92aWRlcihjaGFpbklkLCBycGNVcmwsIHVzZXJBcHBzKSB7XG4gICAgY29uc3QgY3R4ID0gdXNlckFwcHMgPz8gKGF3YWl0IHJlc29sdmVEb21haW5Vc2VyQXBwcygpKTtcbiAgICBpZiAoY3R4LmFkbWluQXBwPy5hY2NvdW50UHJvdmlkZXIpIHtcbiAgICAgICAgcmV0dXJuIGN0eC5hZG1pbkFwcC5hY2NvdW50UHJvdmlkZXI7XG4gICAgfVxuICAgIGlmIChjdHguY2xpZW50QXBwPy5hY2NvdW50UHJvdmlkZXIpIHtcbiAgICAgICAgcmV0dXJuIGN0eC5jbGllbnRBcHAuYWNjb3VudFByb3ZpZGVyO1xuICAgIH1cbiAgICBpZiAoY3R4LnByb3ZpZGVyQXBwPy5hY2NvdW50UHJvdmlkZXIpIHtcbiAgICAgICAgcmV0dXJuIGN0eC5wcm92aWRlckFwcC5hY2NvdW50UHJvdmlkZXI7XG4gICAgfVxuICAgIC8vIEZhbGxiYWNrOiByZWFkLW9ubHkgcHVibGljIGNsaWVudFxuICAgIGNvbnN0IHsgY3JlYXRlUHVibGljQ2xpZW50LCBodHRwIH0gPSBhd2FpdCBpbXBvcnQoJ3ZpZW0nKTtcbiAgICBjb25zdCB7IHNlcG9saWEgfSA9IGF3YWl0IGltcG9ydCgndmllbS9jaGFpbnMnKTtcbiAgICBjb25zdCBwdWJsaWNDbGllbnQgPSBjcmVhdGVQdWJsaWNDbGllbnQoe1xuICAgICAgICBjaGFpbjogc2Vwb2xpYSxcbiAgICAgICAgdHJhbnNwb3J0OiBodHRwKHJwY1VybCksXG4gICAgfSk7XG4gICAgcmV0dXJuIG5ldyBWaWVtQWNjb3VudFByb3ZpZGVyKHtcbiAgICAgICAgcHVibGljQ2xpZW50LFxuICAgICAgICB3YWxsZXRDbGllbnQ6IG51bGwsXG4gICAgICAgIGFjY291bnQ6IHVuZGVmaW5lZCxcbiAgICAgICAgY2hhaW5Db25maWc6IHtcbiAgICAgICAgICAgIGlkOiBzZXBvbGlhLmlkLFxuICAgICAgICAgICAgcnBjVXJsLFxuICAgICAgICAgICAgbmFtZTogc2Vwb2xpYS5uYW1lLFxuICAgICAgICAgICAgY2hhaW46IHNlcG9saWEsXG4gICAgICAgIH0sXG4gICAgfSk7XG59XG4vKipcbiAqIFJlc29sdmUgYW4gQWNjb3VudFByb3ZpZGVyIHN1aXRhYmxlIGZvciB2YWxpZGF0aW9uIG9wZXJhdGlvbnMgZm9yIHRoZSBnaXZlbiBjaGFpbi5cbiAqIFByZWZlcnM6XG4gKiAgIDEuIFZhbGlkYXRvckFwcCAoZm9yIHZhbGlkYXRpb24gcmVzcG9uc2VzKVxuICogICAyLiBBZG1pbkFwcFxuICogICAzLiBQcm92aWRlckFwcFxuICogICA0LiBDbGllbnRBcHBcbiAqXG4gKiBGYWxscyBiYWNrIHRvIGEgcmVhZC1vbmx5IHByb3ZpZGVyIGlmIG5vbmUgYXJlIGF2YWlsYWJsZS5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJlc29sdmVWYWxpZGF0aW9uQWNjb3VudFByb3ZpZGVyKGNoYWluSWQsIHJwY1VybCwgdXNlckFwcHMpIHtcbiAgICBjb25zdCBjdHggPSB1c2VyQXBwcyA/PyAoYXdhaXQgcmVzb2x2ZURvbWFpblVzZXJBcHBzKCkpO1xuICAgIC8vIFZhbGlkYXRvckFwcCBpcyBwcmVmZXJyZWQgZm9yIHZhbGlkYXRpb24gb3BlcmF0aW9uc1xuICAgIGlmIChjdHgudmFsaWRhdG9yQXBwPy5hY2NvdW50UHJvdmlkZXIpIHtcbiAgICAgICAgcmV0dXJuIGN0eC52YWxpZGF0b3JBcHAuYWNjb3VudFByb3ZpZGVyO1xuICAgIH1cbiAgICBpZiAoY3R4LmFkbWluQXBwPy5hY2NvdW50UHJvdmlkZXIpIHtcbiAgICAgICAgcmV0dXJuIGN0eC5hZG1pbkFwcC5hY2NvdW50UHJvdmlkZXI7XG4gICAgfVxuICAgIGlmIChjdHgucHJvdmlkZXJBcHA/LmFjY291bnRQcm92aWRlcikge1xuICAgICAgICByZXR1cm4gY3R4LnByb3ZpZGVyQXBwLmFjY291bnRQcm92aWRlcjtcbiAgICB9XG4gICAgaWYgKGN0eC5jbGllbnRBcHA/LmFjY291bnRQcm92aWRlcikge1xuICAgICAgICByZXR1cm4gY3R4LmNsaWVudEFwcC5hY2NvdW50UHJvdmlkZXI7XG4gICAgfVxuICAgIC8vIEZhbGxiYWNrOiByZWFkLW9ubHkgcHVibGljIGNsaWVudFxuICAgIGNvbnN0IHsgY3JlYXRlUHVibGljQ2xpZW50LCBodHRwIH0gPSBhd2FpdCBpbXBvcnQoJ3ZpZW0nKTtcbiAgICBjb25zdCB7IHNlcG9saWEgfSA9IGF3YWl0IGltcG9ydCgndmllbS9jaGFpbnMnKTtcbiAgICBjb25zdCBwdWJsaWNDbGllbnQgPSBjcmVhdGVQdWJsaWNDbGllbnQoe1xuICAgICAgICBjaGFpbjogc2Vwb2xpYSxcbiAgICAgICAgdHJhbnNwb3J0OiBodHRwKHJwY1VybCksXG4gICAgfSk7XG4gICAgcmV0dXJuIG5ldyBWaWVtQWNjb3VudFByb3ZpZGVyKHtcbiAgICAgICAgcHVibGljQ2xpZW50LFxuICAgICAgICB3YWxsZXRDbGllbnQ6IG51bGwsXG4gICAgICAgIGFjY291bnQ6IHVuZGVmaW5lZCxcbiAgICAgICAgY2hhaW5Db25maWc6IHtcbiAgICAgICAgICAgIGlkOiBzZXBvbGlhLmlkLFxuICAgICAgICAgICAgcnBjVXJsLFxuICAgICAgICAgICAgbmFtZTogc2Vwb2xpYS5uYW1lLFxuICAgICAgICAgICAgY2hhaW46IHNlcG9saWEsXG4gICAgICAgIH0sXG4gICAgfSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kb21haW5BY2NvdW50UHJvdmlkZXJzLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@agentic-trust/core/dist/server/singletons/domainAccountProviders.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@agentic-trust/core/dist/server/singletons/domainClient.js":
/*!*************************************************************************************!*\
  !*** ../../node_modules/@agentic-trust/core/dist/server/singletons/domainClient.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DomainClient: () => (/* binding */ DomainClient)\n/* harmony export */ });\n/**\n * Base abstractions for chain-aware domain clients\n * (discovery, identity, ENS, reputation).\n *\n * Each concrete singleton wraps an instance of this base class.\n */\n/**\n * Generic base class for domain-specific clients.\n *\n * - TClient: the underlying client type (e.g. AIAgentDiscoveryClient)\n * - TKey:    key type used to distinguish instances (e.g. chainId or 'global')\n */\nclass DomainClient {\n    type;\n    instances = new Map();\n    initPromises = new Map();\n    constructor(type) {\n        this.type = type;\n    }\n    /**\n     * Get or create a client for a given key.\n     * Handles memoization and inflight initialization tracking.\n     */\n    async get(key, initArg) {\n        if (this.instances.has(key)) {\n            return this.instances.get(key);\n        }\n        if (this.initPromises.has(key)) {\n            return this.initPromises.get(key);\n        }\n        const promise = this.buildClient(key, initArg)\n            .then((client) => {\n            this.instances.set(key, client);\n            this.initPromises.delete(key);\n            return client;\n        })\n            .catch((error) => {\n            this.initPromises.delete(key);\n            throw error;\n        });\n        this.initPromises.set(key, promise);\n        return promise;\n    }\n    isInitialized(key) {\n        return this.instances.has(key);\n    }\n    /**\n     * Reset one or all instances (useful for testing).\n     */\n    reset(key) {\n        if (typeof key === 'undefined') {\n            this.instances.clear();\n            this.initPromises.clear();\n        }\n        else {\n            this.instances.delete(key);\n            this.initPromises.delete(key);\n        }\n    }\n}\n//# sourceMappingURL=domainClient.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BhZ2VudGljLXRydXN0L2NvcmUvZGlzdC9zZXJ2ZXIvc2luZ2xldG9ucy9kb21haW5DbGllbnQuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvYmFyYi9hYS9Bc3NvY2lhdGVkQWNjb3VudHMvbm9kZV9tb2R1bGVzL0BhZ2VudGljLXRydXN0L2NvcmUvZGlzdC9zZXJ2ZXIvc2luZ2xldG9ucy9kb21haW5DbGllbnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBCYXNlIGFic3RyYWN0aW9ucyBmb3IgY2hhaW4tYXdhcmUgZG9tYWluIGNsaWVudHNcbiAqIChkaXNjb3ZlcnksIGlkZW50aXR5LCBFTlMsIHJlcHV0YXRpb24pLlxuICpcbiAqIEVhY2ggY29uY3JldGUgc2luZ2xldG9uIHdyYXBzIGFuIGluc3RhbmNlIG9mIHRoaXMgYmFzZSBjbGFzcy5cbiAqL1xuLyoqXG4gKiBHZW5lcmljIGJhc2UgY2xhc3MgZm9yIGRvbWFpbi1zcGVjaWZpYyBjbGllbnRzLlxuICpcbiAqIC0gVENsaWVudDogdGhlIHVuZGVybHlpbmcgY2xpZW50IHR5cGUgKGUuZy4gQUlBZ2VudERpc2NvdmVyeUNsaWVudClcbiAqIC0gVEtleTogICAga2V5IHR5cGUgdXNlZCB0byBkaXN0aW5ndWlzaCBpbnN0YW5jZXMgKGUuZy4gY2hhaW5JZCBvciAnZ2xvYmFsJylcbiAqL1xuZXhwb3J0IGNsYXNzIERvbWFpbkNsaWVudCB7XG4gICAgdHlwZTtcbiAgICBpbnN0YW5jZXMgPSBuZXcgTWFwKCk7XG4gICAgaW5pdFByb21pc2VzID0gbmV3IE1hcCgpO1xuICAgIGNvbnN0cnVjdG9yKHR5cGUpIHtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IG9yIGNyZWF0ZSBhIGNsaWVudCBmb3IgYSBnaXZlbiBrZXkuXG4gICAgICogSGFuZGxlcyBtZW1vaXphdGlvbiBhbmQgaW7igJFmbGlnaHQgaW5pdGlhbGl6YXRpb24gdHJhY2tpbmcuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0KGtleSwgaW5pdEFyZykge1xuICAgICAgICBpZiAodGhpcy5pbnN0YW5jZXMuaGFzKGtleSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmluc3RhbmNlcy5nZXQoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pbml0UHJvbWlzZXMuaGFzKGtleSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmluaXRQcm9taXNlcy5nZXQoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcm9taXNlID0gdGhpcy5idWlsZENsaWVudChrZXksIGluaXRBcmcpXG4gICAgICAgICAgICAudGhlbigoY2xpZW50KSA9PiB7XG4gICAgICAgICAgICB0aGlzLmluc3RhbmNlcy5zZXQoa2V5LCBjbGllbnQpO1xuICAgICAgICAgICAgdGhpcy5pbml0UHJvbWlzZXMuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICByZXR1cm4gY2xpZW50O1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICAgICAgdGhpcy5pbml0UHJvbWlzZXMuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuaW5pdFByb21pc2VzLnNldChrZXksIHByb21pc2UpO1xuICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9XG4gICAgaXNJbml0aWFsaXplZChrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5zdGFuY2VzLmhhcyhrZXkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXNldCBvbmUgb3IgYWxsIGluc3RhbmNlcyAodXNlZnVsIGZvciB0ZXN0aW5nKS5cbiAgICAgKi9cbiAgICByZXNldChrZXkpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aGlzLmluc3RhbmNlcy5jbGVhcigpO1xuICAgICAgICAgICAgdGhpcy5pbml0UHJvbWlzZXMuY2xlYXIoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaW5zdGFuY2VzLmRlbGV0ZShrZXkpO1xuICAgICAgICAgICAgdGhpcy5pbml0UHJvbWlzZXMuZGVsZXRlKGtleSk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kb21haW5DbGllbnQuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@agentic-trust/core/dist/server/singletons/domainClient.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@agentic-trust/core/dist/server/singletons/ensClient.js":
/*!**********************************************************************************!*\
  !*** ../../node_modules/@agentic-trust/core/dist/server/singletons/ensClient.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addAgentNameToL1Org: () => (/* binding */ addAgentNameToL1Org),\n/* harmony export */   addAgentNameToL2Org: () => (/* binding */ addAgentNameToL2Org),\n/* harmony export */   getENSClient: () => (/* binding */ getENSClient),\n/* harmony export */   getENSInfo: () => (/* binding */ getENSInfo),\n/* harmony export */   isENSAvailable: () => (/* binding */ isENSAvailable),\n/* harmony export */   isENSClientInitialized: () => (/* binding */ isENSClientInitialized),\n/* harmony export */   isENSNameAvailable: () => (/* binding */ isENSNameAvailable),\n/* harmony export */   prepareL1AgentNameInfoCalls: () => (/* binding */ prepareL1AgentNameInfoCalls),\n/* harmony export */   prepareL2AgentNameInfoCalls: () => (/* binding */ prepareL2AgentNameInfoCalls),\n/* harmony export */   resetENSClient: () => (/* binding */ resetENSClient),\n/* harmony export */   sendSponsoredUserOperation: () => (/* binding */ sendSponsoredUserOperation)\n/* harmony export */ });\n/* harmony import */ var _agentic_trust_8004_ext_sdk__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @agentic-trust/8004-ext-sdk */ \"(rsc)/../../node_modules/@agentic-trust/8004-ext-sdk/dist/index.js\");\n/* harmony import */ var _lib_chainConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/chainConfig */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/lib/chainConfig.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! viem */ \"(rsc)/../../node_modules/viem/_esm/clients/transports/http.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! viem */ \"(rsc)/../../node_modules/viem/_esm/clients/createPublicClient.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! viem */ \"(rsc)/../../node_modules/viem/_esm/clients/createWalletClient.js\");\n/* harmony import */ var viem_account_abstraction__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! viem/account-abstraction */ \"(rsc)/../../node_modules/viem/_esm/account-abstraction/clients/createBundlerClient.js\");\n/* harmony import */ var permissionless_clients_pimlico__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! permissionless/clients/pimlico */ \"(rsc)/../../node_modules/permissionless/_esm/clients/pimlico.js\");\n/* harmony import */ var viem_accounts__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! viem/accounts */ \"(rsc)/../../node_modules/viem/_esm/accounts/privateKeyToAccount.js\");\n/* harmony import */ var _metamask_smart_accounts_kit__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @metamask/smart-accounts-kit */ \"(rsc)/../../node_modules/@metamask/smart-accounts-kit/dist/index.mjs\");\n/* harmony import */ var _metamask_smart_accounts_kit__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @metamask/smart-accounts-kit */ \"(rsc)/../../node_modules/@metamask/smart-accounts-kit/dist/chunk-7MRTROLV.mjs\");\n/* harmony import */ var _domainClient__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./domainClient */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/singletons/domainClient.js\");\n/* harmony import */ var _domainAccountProviders__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./domainAccountProviders */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/singletons/domainAccountProviders.js\");\n/**\n * ENS Client Singleton\n *\n * Manages a singleton instance of AIAgentENSClient\n * Initialized from environment variables using AccountProvider\n */\n\n\n\n\n\n\n\n\n\n\nfunction hydrateAgenticTrustEnv() {\n    // Some environments (Workers/bundlers) polyfill `process` but not `process.env`.\n    if (typeof process !== 'undefined') {\n        process.env = process.env || {};\n    }\n    // Allow host apps (like Cloudflare Workers) to stash env vars on globalThis,\n    // then hydrate into process.env on-demand before ENS client operations.\n    const globalEnv = globalThis.__agenticTrustEnv;\n    if (!globalEnv || typeof globalEnv !== 'object')\n        return;\n    if (typeof process === 'undefined' || !process.env)\n        return;\n    for (const [key, value] of Object.entries(globalEnv)) {\n        if (!key.startsWith('AGENTIC_TRUST_'))\n            continue;\n        if (typeof value !== 'string')\n            continue;\n        if (!process.env[key]) {\n            process.env[key] = value;\n        }\n    }\n}\nclass ENSDomainClient extends _domainClient__WEBPACK_IMPORTED_MODULE_2__.DomainClient {\n    constructor() {\n        super('ens');\n    }\n    async buildClient(targetChainId, initArg) {\n        hydrateAgenticTrustEnv();\n        // Get RPC URL from environment\n        const rpcUrl = (0,_lib_chainConfig__WEBPACK_IMPORTED_MODULE_1__.requireChainEnvVar)('AGENTIC_TRUST_RPC_URL', targetChainId);\n        // Get ENS registry addresses from environment\n        // Default to standard ENS registry on Sepolia if not provided\n        const defaultEnsRegistry = targetChainId === 11155111\n            ? '0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e' // Standard ENS registry on Sepolia\n            : '';\n        const ensRegistryRaw = (0,_lib_chainConfig__WEBPACK_IMPORTED_MODULE_1__.getChainEnvVar)('AGENTIC_TRUST_ENS_REGISTRY', targetChainId) || defaultEnsRegistry;\n        if (!ensRegistryRaw || ensRegistryRaw === '') {\n            const chainSuffix = targetChainId === 11155111 ? 'SEPOLIA' : targetChainId === 84532 ? 'BASE_SEPOLIA' : targetChainId === 11155420 ? 'OPTIMISM_SEPOLIA' : String(targetChainId);\n            throw new Error(`Missing required environment variable: AGENTIC_TRUST_ENS_REGISTRY_${chainSuffix}. ` +\n                `This is required for the ENS client to resolve ENS names on chain ${targetChainId}.`);\n        }\n        const ensRegistry = ensRegistryRaw;\n        const ensResolver = ((0,_lib_chainConfig__WEBPACK_IMPORTED_MODULE_1__.getChainEnvVar)('AGENTIC_TRUST_ENS_RESOLVER', targetChainId) || '');\n        const identityRegistry = ((0,_lib_chainConfig__WEBPACK_IMPORTED_MODULE_1__.getChainEnvVar)('AGENTIC_TRUST_IDENTITY_REGISTRY', targetChainId) ||\n            '0x0000000000000000000000000000000000000000');\n        const init = (initArg || {});\n        const userApps = init.userApps ?? (await (0,_domainAccountProviders__WEBPACK_IMPORTED_MODULE_3__.resolveDomainUserApps)());\n        const accountProvider = await (0,_domainAccountProviders__WEBPACK_IMPORTED_MODULE_3__.resolveENSAccountProvider)(targetChainId, rpcUrl, userApps);\n        // Select chain object\n        const chain = targetChainId === 11155111\n            ? _lib_chainConfig__WEBPACK_IMPORTED_MODULE_1__.sepolia\n            : targetChainId === 84532\n                ? _lib_chainConfig__WEBPACK_IMPORTED_MODULE_1__.baseSepolia\n                : targetChainId === 11155420\n                    ? _lib_chainConfig__WEBPACK_IMPORTED_MODULE_1__.optimismSepolia\n                    : _lib_chainConfig__WEBPACK_IMPORTED_MODULE_1__.sepolia;\n        // Choose L1 vs L2 ENS client implementation\n        const isL2 = targetChainId === 84532 || targetChainId === 11155420;\n        const ClientCtor = isL2 ? _agentic_trust_8004_ext_sdk__WEBPACK_IMPORTED_MODULE_0__.AIAgentL2ENSDurenClient : _agentic_trust_8004_ext_sdk__WEBPACK_IMPORTED_MODULE_0__.AIAgentENSClient;\n        return new ClientCtor(chain, rpcUrl, accountProvider, ensRegistry, ensResolver, identityRegistry);\n    }\n}\nconst ensDomainClient = new ENSDomainClient();\n/**\n * Get or create the AIAgentENSClient singleton\n * Initializes from environment variables using AccountProvider from AdminApp, ClientApp, or ProviderApp\n */\nasync function getENSClient(chainId) {\n    hydrateAgenticTrustEnv();\n    // Default to Sepolia if no chainId provided\n    const targetChainId = chainId || 11155111;\n    return ensDomainClient.get(targetChainId);\n}\n/**\n * Check if ENS client is initialized for a specific chain\n */\nfunction isENSClientInitialized(chainId) {\n    const targetChainId = chainId || 11155111;\n    return ensDomainClient.isInitialized(targetChainId);\n}\n/**\n * Reset the ENS client instance for a specific chain (useful for testing)\n */\nfunction resetENSClient(chainId) {\n    const targetChainId = chainId || 11155111;\n    ensDomainClient.reset(targetChainId);\n}\n/**\n * Check if an ENS name is available\n *\n * @param agentName - The agent name (e.g., \"my-agent\")\n * @param orgName - The organization name (e.g., \"8004-agent\" or \"8004-agent.eth\")\n * @returns true if the ENS name is available, false if it's taken, null if check failed\n */\n/**\n * Check if an ENS name is available (general purpose)\n *\n * @param ensName - Full ENS name (e.g., \"agentname.orgname.eth\" or \"orgname.eth\")\n * @param chainId - Chain ID where the ENS name should be checked\n * @returns true if the ENS name is available, false if it's taken, null if check failed\n */\nasync function isENSNameAvailable(ensName, chainId) {\n    try {\n        const ensClient = await getENSClient(chainId);\n        // Normalize the ENS name (ensure it ends with .eth if not already)\n        const normalizedName = ensName.trim().toLowerCase();\n        const fullName = normalizedName.endsWith('.eth') ? normalizedName : `${normalizedName}.eth`;\n        // Check if ENS name is available\n        console.log('*********** zzz isENSNameAvailable fullName', fullName);\n        const existingAccount = await ensClient.getAgentAccountByName(fullName);\n        const isAvailable = !existingAccount || existingAccount === '0x0000000000000000000000000000000000000000';\n        return isAvailable;\n    }\n    catch (error) {\n        console.error('Error checking ENS availability:', error);\n        return null;\n    }\n}\n/**\n * Check if an ENS name is available (legacy method for backward compatibility)\n *\n * @param orgName - The organization name (e.g., \"8004-agent\" or \"8004-agent.eth\")\n * @param agentName - The agent name (e.g., \"my-agent\")\n * @param chainId - Chain ID where the ENS name should be checked\n * @returns true if the ENS name is available, false if it's taken, null if check failed\n */\nasync function isENSAvailable(orgName, agentName, chainId) {\n    try {\n        // Format: agentName.orgName.eth\n        const agentNameLabel = agentName.toLowerCase().replace(/\\s+/g, '-');\n        const orgNameClean = orgName.toLowerCase().replace(/\\.eth$/, '');\n        const fullName = `${agentNameLabel}.${orgNameClean}.eth`;\n        return await isENSNameAvailable(fullName, chainId);\n    }\n    catch (error) {\n        console.error('Error checking ENS availability:', error);\n        return null;\n    }\n}\n/**\n * Get comprehensive ENS name info in one call.\n * Returns account/address, image/avatar, url, description, and availability.\n */\nasync function getENSInfo(ensName, chainId) {\n    const normalized = (ensName || '').trim().toLowerCase();\n    const fullName = normalized.endsWith('.eth') ? normalized : `${normalized}.eth`;\n    const [available, client] = await Promise.all([\n        isENSNameAvailable(fullName, chainId),\n        getENSClient(chainId),\n    ]);\n    console.log('*********** zzz isENSNameAvailable:', available);\n    console.log('*********** zzz getENSInfo 0 fullName', fullName);\n    const [account, image, url, description] = await Promise.all([\n        client.getAgentAccountByName(fullName).catch(() => null),\n        client.getAgentImageByName(fullName).catch(() => null),\n        client.getAgentUrlByName(fullName).catch(() => null),\n        client.getAgentDescriptionByName(fullName).catch(() => null),\n    ]);\n    console.log('*********** zzz getENSInfo 1 fullName', fullName, account, image, url, description);\n    return {\n        name: fullName,\n        chainId,\n        available,\n        account: account ?? null,\n        image: image ?? null,\n        url: url ?? null,\n        description: description ?? null,\n    };\n}\nasync function sendSponsoredUserOperation(params) {\n    const { bundlerUrl, chain, accountClient, calls } = params;\n    const pimlicoClient = (0,permissionless_clients_pimlico__WEBPACK_IMPORTED_MODULE_4__.createPimlicoClient)({ transport: (0,viem__WEBPACK_IMPORTED_MODULE_5__.http)(bundlerUrl) });\n    const bundlerClient = (0,viem_account_abstraction__WEBPACK_IMPORTED_MODULE_6__.createBundlerClient)({\n        transport: (0,viem__WEBPACK_IMPORTED_MODULE_5__.http)(bundlerUrl),\n        paymaster: true,\n        chain: chain,\n        paymasterContext: { mode: 'SPONSORED' }\n    });\n    const { fast: fee } = await pimlicoClient.getUserOperationGasPrice();\n    const userOpHash = await bundlerClient.sendUserOperation({\n        account: accountClient,\n        calls,\n        ...fee\n    });\n    return userOpHash;\n}\nasync function addAgentNameToL1Org(params) {\n    const { agentAddress, orgName, agentName, agentUrl } = params;\n    console.log(\"addAgentNameToL1Org: \", agentAddress, orgName, agentName, agentUrl);\n    if (!agentName || !orgName || !agentAddress) {\n        throw new Error('agentName, orgName, and agentAddress are required to add an agent name to an org');\n    }\n    console.log(\"ensClient get ens for chain: \", params.chainId);\n    const targetChainId = params.chainId || 11155111;\n    const ensClient = await getENSClient(targetChainId);\n    const agentNameLabel = agentName.toLowerCase().replace(/\\s+/g, '-');\n    const orgNameClean = orgName.toLowerCase().replace(/\\.eth$/, '');\n    const orgAddress = (0,_lib_chainConfig__WEBPACK_IMPORTED_MODULE_1__.getEnsOrgAddress)(targetChainId);\n    // optional TTL (defaults to 0)\n    console.log('********************* prepareAddAgentNameToOrgCalls: orgName: ', orgName, agentName, agentAddress, agentUrl);\n    const { calls: orgCalls } = await ensClient.prepareAddAgentNameToOrgCalls({\n        agentAddress,\n        orgName: orgNameClean,\n        agentName: agentNameLabel,\n        agentUrl: agentUrl || '',\n    });\n    if (ensClient.isL1()) {\n        // Optionally submit server-side if configured (no breaking change: still returns calls)\n        try {\n            const bundlerUrl = (0,_lib_chainConfig__WEBPACK_IMPORTED_MODULE_1__.getChainEnvVar)('AGENTIC_TRUST_BUNDLER_URL', params.chainId || 11155111);\n            const rpcUrl = (0,_lib_chainConfig__WEBPACK_IMPORTED_MODULE_1__.getChainEnvVar)('AGENTIC_TRUST_RPC_URL', params.chainId || 11155111);\n            let ensPrivKey;\n            try {\n                ensPrivKey = (0,_lib_chainConfig__WEBPACK_IMPORTED_MODULE_1__.getEnsPrivateKey)(targetChainId);\n            }\n            catch {\n                ensPrivKey = undefined;\n            }\n            if (ensPrivKey && bundlerUrl && rpcUrl) {\n                const publicClient = (0,viem__WEBPACK_IMPORTED_MODULE_7__.createPublicClient)({ chain: _lib_chainConfig__WEBPACK_IMPORTED_MODULE_1__.sepolia, transport: (0,viem__WEBPACK_IMPORTED_MODULE_5__.http)(rpcUrl) });\n                const orgEOA = (0,viem_accounts__WEBPACK_IMPORTED_MODULE_8__.privateKeyToAccount)(ensPrivKey);\n                const walletClient = (0,viem__WEBPACK_IMPORTED_MODULE_9__.createWalletClient)({\n                    account: orgEOA,\n                    chain: _lib_chainConfig__WEBPACK_IMPORTED_MODULE_1__.sepolia,\n                    transport: (0,viem__WEBPACK_IMPORTED_MODULE_5__.http)(rpcUrl),\n                });\n                const orgAccountClient = await (0,_metamask_smart_accounts_kit__WEBPACK_IMPORTED_MODULE_10__.toMetaMaskSmartAccount)({\n                    address: orgAddress,\n                    client: publicClient,\n                    implementation: _metamask_smart_accounts_kit__WEBPACK_IMPORTED_MODULE_11__.Implementation.Hybrid,\n                    signer: { walletClient: walletClient },\n                });\n                const pimlicoClient = (0,permissionless_clients_pimlico__WEBPACK_IMPORTED_MODULE_4__.createPimlicoClient)({ transport: (0,viem__WEBPACK_IMPORTED_MODULE_5__.http)(bundlerUrl) });\n                const bundlerClient = (0,viem_account_abstraction__WEBPACK_IMPORTED_MODULE_6__.createBundlerClient)({\n                    transport: (0,viem__WEBPACK_IMPORTED_MODULE_5__.http)(bundlerUrl),\n                    paymaster: true,\n                    chain: _lib_chainConfig__WEBPACK_IMPORTED_MODULE_1__.sepolia,\n                    paymasterContext: { mode: 'SPONSORED' },\n                });\n                const { fast: fee } = await pimlicoClient.getUserOperationGasPrice();\n                const userOpHash = await bundlerClient.sendUserOperation({\n                    account: orgAccountClient,\n                    calls: orgCalls,\n                    ...fee,\n                });\n                await bundlerClient.waitForUserOperationReceipt({ hash: userOpHash });\n            }\n        }\n        catch (error) {\n            // If server-side submission fails, just return prepared calls\n            console.error('Error adding agent name to org:', error);\n            throw new Error(`Failed to add agent name to org: ${error instanceof Error ? error.message : 'Unknown error'}`);\n        }\n    }\n    return \"success\";\n}\nasync function prepareL1AgentNameInfoCalls(params) {\n    const { agentAddress, orgName, agentName, agentUrl, agentDescription } = params;\n    if (!agentName || !orgName || !agentAddress) {\n        throw new Error('agentName, orgName, and agentAddress are required to prepare ENS agent info calls');\n    }\n    const targetChainId = params.chainId || 11155111;\n    const ensClient = await getENSClient(targetChainId);\n    const orgNameClean = orgName.replace(/\\.eth$/i, '').toLowerCase();\n    const orgNamePattern = orgNameClean.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n    const agentNameTrimmed = agentName\n        .replace(new RegExp(`^${orgNamePattern}\\\\.`, 'i'), '')\n        .replace(/\\.eth$/i, '')\n        .trim();\n    const agentNameLabel = agentNameTrimmed.toLowerCase().replace(/\\s+/g, '-');\n    const { calls } = await ensClient.prepareSetAgentNameInfoCalls({\n        orgName: orgNameClean,\n        agentName: agentNameLabel,\n        agentAddress,\n        agentUrl: agentUrl || '',\n        agentDescription: agentDescription || '',\n    });\n    return {\n        calls,\n    };\n}\nasync function addAgentNameToL2Org(params) {\n    const { agentAddress, orgName, agentName, agentUrl, agentDescription, agentImage } = params;\n    if (!agentName || !orgName || !agentAddress) {\n        throw new Error('agentName, orgName, and agentAddress are required to prepare L2 ENS calls');\n    }\n    console.info(\"inside addAgentNameToL2Org: \", params);\n    const targetChainId = params.chainId || 11155111;\n    const ensClient = await getENSClient(targetChainId);\n    const orgNameClean = orgName.replace(/\\.eth$/i, '').toLowerCase();\n    const orgNamePattern = orgNameClean.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n    const agentNameTrimmed = agentName\n        .replace(new RegExp(`^${orgNamePattern}\\\\.`, 'i'), '')\n        .replace(/\\.eth$/i, '')\n        .trim();\n    const agentNameLabel = agentNameTrimmed.toLowerCase().replace(/\\s+/g, '-');\n    const calls = [];\n    // Create subdomain if missing\n    console.info(\"see if agent name is available: \", orgNameClean, agentNameLabel);\n    const hasOwner = await ensClient.hasAgentNameOwner(orgNameClean, agentNameLabel);\n    console.info(\"hasOwner: \", hasOwner);\n    if (!hasOwner) {\n        console.info(\"agent name is not available, prepare add agent name to org calls\");\n        const { calls: orgCalls } = await ensClient.prepareAddAgentNameToOrgCalls({\n            orgName: orgNameClean,\n            agentName: agentNameLabel,\n            agentAddress,\n            agentUrl: agentUrl || '',\n        });\n        calls.push(...orgCalls);\n    }\n    /*\n    // Metadata (text records)\n    console.info(\"prepare set agent name info calls\");\n    const { calls: infoCalls } = await ensClient.prepareSetAgentNameInfoCalls({\n      orgName: orgNameClean,\n      agentName: agentNameLabel,\n      agentAddress,\n      agentUrl: agentUrl || '',\n      agentDescription: agentDescription || '',\n    });\n    calls.push(...infoCalls);\n  \n    // Optional avatar/image\n    console.info(\"prepare set name image calls\");\n    if (agentImage && agentImage.trim() !== '') {\n      const fullSubname = `${agentNameLabel}.${orgNameClean}.eth`;\n      const { calls: imageCalls } = await (ensClient as any).prepareSetNameImageCalls(fullSubname, agentImage.trim());\n      calls.push(...imageCalls);\n    }\n    */\n    console.info(\"addAgentNameToL2Org: calls\", calls);\n    return { calls };\n}\nasync function prepareL2AgentNameInfoCalls(params) {\n    const { agentAddress, orgName, agentName, agentUrl, agentDescription } = params;\n    console.info(\"inside addAgentNameToL2Org: \", params);\n    const targetChainId = params.chainId || 11155111;\n    const ensClient = await getENSClient(targetChainId);\n    const orgNameClean = orgName.replace(/\\.eth$/i, '').toLowerCase();\n    const orgNamePattern = orgNameClean.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n    const agentNameTrimmed = agentName\n        .replace(new RegExp(`^${orgNamePattern}\\\\.`, 'i'), '')\n        .replace(/\\.eth$/i, '')\n        .trim();\n    const agentNameLabel = agentNameTrimmed.toLowerCase().replace(/\\s+/g, '-');\n    const calls = [];\n    // Metadata (text records)\n    console.info(\"prepare set agent name info calls\");\n    const { calls: infoCalls } = await ensClient.prepareSetAgentNameInfoCalls({\n        orgName: orgNameClean,\n        agentName: agentNameLabel,\n        agentAddress,\n        agentUrl: agentUrl || '',\n        agentDescription: agentDescription || '',\n    });\n    calls.push(...infoCalls);\n    // Optional avatar/image\n    console.info(\"prepare set name image calls\");\n    if (params.agentImage && params.agentImage.trim() !== '') {\n        const fullSubname = `${agentNameLabel}.${orgNameClean}.eth`;\n        const { calls: imageCalls } = await ensClient.prepareSetNameImageCalls(fullSubname, params.agentImage.trim());\n        calls.push(...imageCalls);\n    }\n    return { calls };\n}\n//# sourceMappingURL=ensClient.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BhZ2VudGljLXRydXN0L2NvcmUvZGlzdC9zZXJ2ZXIvc2luZ2xldG9ucy9lbnNDbGllbnQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDd0Y7QUFDYjtBQUNQO0FBQ0w7QUFDTTtBQUNqQjtBQUN3RDtBQUN0QjtBQUN4QztBQUM4QztBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qix1REFBWTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsb0VBQWtCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsZ0VBQWM7QUFDN0M7QUFDQTtBQUNBLGlHQUFpRyxZQUFZO0FBQzdHLHFGQUFxRixjQUFjO0FBQ25HO0FBQ0E7QUFDQSw2QkFBNkIsZ0VBQWM7QUFDM0Msa0NBQWtDLGdFQUFjO0FBQ2hEO0FBQ0EsbUNBQW1DO0FBQ25DLGlEQUFpRCw4RUFBcUI7QUFDdEUsc0NBQXNDLGtGQUF5QjtBQUMvRDtBQUNBO0FBQ0EsY0FBYyxxREFBTztBQUNyQjtBQUNBLGtCQUFrQix5REFBVztBQUM3QjtBQUNBLHNCQUFzQiw2REFBZTtBQUNyQyxzQkFBc0IscURBQU87QUFDN0I7QUFDQTtBQUNBLGtDQUFrQyxnRkFBdUIsR0FBRyx5RUFBZ0I7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRSxlQUFlO0FBQzlGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixlQUFlLEdBQUcsYUFBYTtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLG1FQUFtRSxXQUFXO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLFlBQVksMENBQTBDO0FBQ3RELDBCQUEwQixtRkFBbUIsR0FBRyxXQUFXLDBDQUFJLGNBQWM7QUFDN0UsMEJBQTBCLDZFQUFtQjtBQUM3QyxtQkFBbUIsMENBQUk7QUFDdkI7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QixLQUFLO0FBQ0wsWUFBWSxZQUFZO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDTztBQUNQLFlBQVksNkNBQTZDO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixrRUFBZ0I7QUFDdkM7QUFDQTtBQUNBLFlBQVksa0JBQWtCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixnRUFBYztBQUM3QywyQkFBMkIsZ0VBQWM7QUFDekM7QUFDQTtBQUNBLDZCQUE2QixrRUFBZ0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyx3REFBa0IsR0FBRyxPQUFPLHFEQUFPLGFBQWEsMENBQUksVUFBVTtBQUNuRywrQkFBK0Isa0VBQW1CO0FBQ2xELHFDQUFxQyx3REFBa0I7QUFDdkQ7QUFDQSwyQkFBMkIscURBQU87QUFDbEMsK0JBQStCLDBDQUFJO0FBQ25DLGlCQUFpQjtBQUNqQiwrQ0FBK0MscUZBQXNCO0FBQ3JFO0FBQ0E7QUFDQSxvQ0FBb0MseUVBQWM7QUFDbEQsOEJBQThCLDRCQUE0QjtBQUMxRCxpQkFBaUI7QUFDakIsc0NBQXNDLG1GQUFtQixHQUFHLFdBQVcsMENBQUksY0FBYztBQUN6RixzQ0FBc0MsNkVBQW1CO0FBQ3pELCtCQUErQiwwQ0FBSTtBQUNuQztBQUNBLDJCQUEyQixxREFBTztBQUNsQyx3Q0FBd0MsbUJBQW1CO0FBQzNELGlCQUFpQjtBQUNqQix3QkFBd0IsWUFBWTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixrRUFBa0Usa0JBQWtCO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0UseURBQXlEO0FBQ3pIO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxZQUFZLCtEQUErRDtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQSxnQ0FBZ0MsZUFBZTtBQUMvQztBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsWUFBWSwyRUFBMkU7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQSxnQ0FBZ0MsZUFBZTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixrQkFBa0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksbUJBQW1CO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixlQUFlLEdBQUcsYUFBYTtBQUM1RCxjQUFjLG9CQUFvQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNPO0FBQ1AsWUFBWSwrREFBK0Q7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQSxnQ0FBZ0MsZUFBZTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG1CQUFtQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGVBQWUsR0FBRyxhQUFhO0FBQzlELGdCQUFnQixvQkFBb0I7QUFDcEM7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9iYXJiL2FhL0Fzc29jaWF0ZWRBY2NvdW50cy9ub2RlX21vZHVsZXMvQGFnZW50aWMtdHJ1c3QvY29yZS9kaXN0L3NlcnZlci9zaW5nbGV0b25zL2Vuc0NsaWVudC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEVOUyBDbGllbnQgU2luZ2xldG9uXG4gKlxuICogTWFuYWdlcyBhIHNpbmdsZXRvbiBpbnN0YW5jZSBvZiBBSUFnZW50RU5TQ2xpZW50XG4gKiBJbml0aWFsaXplZCBmcm9tIGVudmlyb25tZW50IHZhcmlhYmxlcyB1c2luZyBBY2NvdW50UHJvdmlkZXJcbiAqL1xuaW1wb3J0IHsgQUlBZ2VudEVOU0NsaWVudCwgQUlBZ2VudEwyRU5TRHVyZW5DbGllbnQgfSBmcm9tICdAYWdlbnRpYy10cnVzdC84MDA0LWV4dC1zZGsnO1xuaW1wb3J0IHsgc2Vwb2xpYSwgYmFzZVNlcG9saWEsIG9wdGltaXNtU2Vwb2xpYSB9IGZyb20gJy4uL2xpYi9jaGFpbkNvbmZpZyc7XG5pbXBvcnQgeyBjcmVhdGVQdWJsaWNDbGllbnQsIGNyZWF0ZVdhbGxldENsaWVudCwgaHR0cCB9IGZyb20gJ3ZpZW0nO1xuaW1wb3J0IHsgY3JlYXRlQnVuZGxlckNsaWVudCB9IGZyb20gJ3ZpZW0vYWNjb3VudC1hYnN0cmFjdGlvbic7XG5pbXBvcnQgeyBjcmVhdGVQaW1saWNvQ2xpZW50IH0gZnJvbSAncGVybWlzc2lvbmxlc3MvY2xpZW50cy9waW1saWNvJztcbmltcG9ydCB7IHByaXZhdGVLZXlUb0FjY291bnQgfSBmcm9tICd2aWVtL2FjY291bnRzJztcbmltcG9ydCB7IGdldENoYWluRW52VmFyLCByZXF1aXJlQ2hhaW5FbnZWYXIsIGdldEVuc09yZ0FkZHJlc3MsIGdldEVuc1ByaXZhdGVLZXkgfSBmcm9tICcuLi9saWIvY2hhaW5Db25maWcnO1xuaW1wb3J0IHsgdG9NZXRhTWFza1NtYXJ0QWNjb3VudCwgSW1wbGVtZW50YXRpb24gfSBmcm9tICdAbWV0YW1hc2svc21hcnQtYWNjb3VudHMta2l0JztcbmltcG9ydCB7IERvbWFpbkNsaWVudCB9IGZyb20gJy4vZG9tYWluQ2xpZW50JztcbmltcG9ydCB7IHJlc29sdmVEb21haW5Vc2VyQXBwcywgcmVzb2x2ZUVOU0FjY291bnRQcm92aWRlciB9IGZyb20gJy4vZG9tYWluQWNjb3VudFByb3ZpZGVycyc7XG5mdW5jdGlvbiBoeWRyYXRlQWdlbnRpY1RydXN0RW52KCkge1xuICAgIC8vIFNvbWUgZW52aXJvbm1lbnRzIChXb3JrZXJzL2J1bmRsZXJzKSBwb2x5ZmlsbCBgcHJvY2Vzc2AgYnV0IG5vdCBgcHJvY2Vzcy5lbnZgLlxuICAgIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYgPSBwcm9jZXNzLmVudiB8fCB7fTtcbiAgICB9XG4gICAgLy8gQWxsb3cgaG9zdCBhcHBzIChsaWtlIENsb3VkZmxhcmUgV29ya2VycykgdG8gc3Rhc2ggZW52IHZhcnMgb24gZ2xvYmFsVGhpcyxcbiAgICAvLyB0aGVuIGh5ZHJhdGUgaW50byBwcm9jZXNzLmVudiBvbi1kZW1hbmQgYmVmb3JlIEVOUyBjbGllbnQgb3BlcmF0aW9ucy5cbiAgICBjb25zdCBnbG9iYWxFbnYgPSBnbG9iYWxUaGlzLl9fYWdlbnRpY1RydXN0RW52O1xuICAgIGlmICghZ2xvYmFsRW52IHx8IHR5cGVvZiBnbG9iYWxFbnYgIT09ICdvYmplY3QnKVxuICAgICAgICByZXR1cm47XG4gICAgaWYgKHR5cGVvZiBwcm9jZXNzID09PSAndW5kZWZpbmVkJyB8fCAhcHJvY2Vzcy5lbnYpXG4gICAgICAgIHJldHVybjtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhnbG9iYWxFbnYpKSB7XG4gICAgICAgIGlmICgha2V5LnN0YXJ0c1dpdGgoJ0FHRU5USUNfVFJVU1RfJykpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgaWYgKCFwcm9jZXNzLmVudltrZXldKSB7XG4gICAgICAgICAgICBwcm9jZXNzLmVudltrZXldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG59XG5jbGFzcyBFTlNEb21haW5DbGllbnQgZXh0ZW5kcyBEb21haW5DbGllbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcignZW5zJyk7XG4gICAgfVxuICAgIGFzeW5jIGJ1aWxkQ2xpZW50KHRhcmdldENoYWluSWQsIGluaXRBcmcpIHtcbiAgICAgICAgaHlkcmF0ZUFnZW50aWNUcnVzdEVudigpO1xuICAgICAgICAvLyBHZXQgUlBDIFVSTCBmcm9tIGVudmlyb25tZW50XG4gICAgICAgIGNvbnN0IHJwY1VybCA9IHJlcXVpcmVDaGFpbkVudlZhcignQUdFTlRJQ19UUlVTVF9SUENfVVJMJywgdGFyZ2V0Q2hhaW5JZCk7XG4gICAgICAgIC8vIEdldCBFTlMgcmVnaXN0cnkgYWRkcmVzc2VzIGZyb20gZW52aXJvbm1lbnRcbiAgICAgICAgLy8gRGVmYXVsdCB0byBzdGFuZGFyZCBFTlMgcmVnaXN0cnkgb24gU2Vwb2xpYSBpZiBub3QgcHJvdmlkZWRcbiAgICAgICAgY29uc3QgZGVmYXVsdEVuc1JlZ2lzdHJ5ID0gdGFyZ2V0Q2hhaW5JZCA9PT0gMTExNTUxMTFcbiAgICAgICAgICAgID8gJzB4MDAwMDAwMDAwMDBDMkUwNzRlQzY5QTBkRmIyOTk3QkE2QzdkMmUxZScgLy8gU3RhbmRhcmQgRU5TIHJlZ2lzdHJ5IG9uIFNlcG9saWFcbiAgICAgICAgICAgIDogJyc7XG4gICAgICAgIGNvbnN0IGVuc1JlZ2lzdHJ5UmF3ID0gZ2V0Q2hhaW5FbnZWYXIoJ0FHRU5USUNfVFJVU1RfRU5TX1JFR0lTVFJZJywgdGFyZ2V0Q2hhaW5JZCkgfHwgZGVmYXVsdEVuc1JlZ2lzdHJ5O1xuICAgICAgICBpZiAoIWVuc1JlZ2lzdHJ5UmF3IHx8IGVuc1JlZ2lzdHJ5UmF3ID09PSAnJykge1xuICAgICAgICAgICAgY29uc3QgY2hhaW5TdWZmaXggPSB0YXJnZXRDaGFpbklkID09PSAxMTE1NTExMSA/ICdTRVBPTElBJyA6IHRhcmdldENoYWluSWQgPT09IDg0NTMyID8gJ0JBU0VfU0VQT0xJQScgOiB0YXJnZXRDaGFpbklkID09PSAxMTE1NTQyMCA/ICdPUFRJTUlTTV9TRVBPTElBJyA6IFN0cmluZyh0YXJnZXRDaGFpbklkKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTWlzc2luZyByZXF1aXJlZCBlbnZpcm9ubWVudCB2YXJpYWJsZTogQUdFTlRJQ19UUlVTVF9FTlNfUkVHSVNUUllfJHtjaGFpblN1ZmZpeH0uIGAgK1xuICAgICAgICAgICAgICAgIGBUaGlzIGlzIHJlcXVpcmVkIGZvciB0aGUgRU5TIGNsaWVudCB0byByZXNvbHZlIEVOUyBuYW1lcyBvbiBjaGFpbiAke3RhcmdldENoYWluSWR9LmApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVuc1JlZ2lzdHJ5ID0gZW5zUmVnaXN0cnlSYXc7XG4gICAgICAgIGNvbnN0IGVuc1Jlc29sdmVyID0gKGdldENoYWluRW52VmFyKCdBR0VOVElDX1RSVVNUX0VOU19SRVNPTFZFUicsIHRhcmdldENoYWluSWQpIHx8ICcnKTtcbiAgICAgICAgY29uc3QgaWRlbnRpdHlSZWdpc3RyeSA9IChnZXRDaGFpbkVudlZhcignQUdFTlRJQ19UUlVTVF9JREVOVElUWV9SRUdJU1RSWScsIHRhcmdldENoYWluSWQpIHx8XG4gICAgICAgICAgICAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyk7XG4gICAgICAgIGNvbnN0IGluaXQgPSAoaW5pdEFyZyB8fCB7fSk7XG4gICAgICAgIGNvbnN0IHVzZXJBcHBzID0gaW5pdC51c2VyQXBwcyA/PyAoYXdhaXQgcmVzb2x2ZURvbWFpblVzZXJBcHBzKCkpO1xuICAgICAgICBjb25zdCBhY2NvdW50UHJvdmlkZXIgPSBhd2FpdCByZXNvbHZlRU5TQWNjb3VudFByb3ZpZGVyKHRhcmdldENoYWluSWQsIHJwY1VybCwgdXNlckFwcHMpO1xuICAgICAgICAvLyBTZWxlY3QgY2hhaW4gb2JqZWN0XG4gICAgICAgIGNvbnN0IGNoYWluID0gdGFyZ2V0Q2hhaW5JZCA9PT0gMTExNTUxMTFcbiAgICAgICAgICAgID8gc2Vwb2xpYVxuICAgICAgICAgICAgOiB0YXJnZXRDaGFpbklkID09PSA4NDUzMlxuICAgICAgICAgICAgICAgID8gYmFzZVNlcG9saWFcbiAgICAgICAgICAgICAgICA6IHRhcmdldENoYWluSWQgPT09IDExMTU1NDIwXG4gICAgICAgICAgICAgICAgICAgID8gb3B0aW1pc21TZXBvbGlhXG4gICAgICAgICAgICAgICAgICAgIDogc2Vwb2xpYTtcbiAgICAgICAgLy8gQ2hvb3NlIEwxIHZzIEwyIEVOUyBjbGllbnQgaW1wbGVtZW50YXRpb25cbiAgICAgICAgY29uc3QgaXNMMiA9IHRhcmdldENoYWluSWQgPT09IDg0NTMyIHx8IHRhcmdldENoYWluSWQgPT09IDExMTU1NDIwO1xuICAgICAgICBjb25zdCBDbGllbnRDdG9yID0gaXNMMiA/IEFJQWdlbnRMMkVOU0R1cmVuQ2xpZW50IDogQUlBZ2VudEVOU0NsaWVudDtcbiAgICAgICAgcmV0dXJuIG5ldyBDbGllbnRDdG9yKGNoYWluLCBycGNVcmwsIGFjY291bnRQcm92aWRlciwgZW5zUmVnaXN0cnksIGVuc1Jlc29sdmVyLCBpZGVudGl0eVJlZ2lzdHJ5KTtcbiAgICB9XG59XG5jb25zdCBlbnNEb21haW5DbGllbnQgPSBuZXcgRU5TRG9tYWluQ2xpZW50KCk7XG4vKipcbiAqIEdldCBvciBjcmVhdGUgdGhlIEFJQWdlbnRFTlNDbGllbnQgc2luZ2xldG9uXG4gKiBJbml0aWFsaXplcyBmcm9tIGVudmlyb25tZW50IHZhcmlhYmxlcyB1c2luZyBBY2NvdW50UHJvdmlkZXIgZnJvbSBBZG1pbkFwcCwgQ2xpZW50QXBwLCBvciBQcm92aWRlckFwcFxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0RU5TQ2xpZW50KGNoYWluSWQpIHtcbiAgICBoeWRyYXRlQWdlbnRpY1RydXN0RW52KCk7XG4gICAgLy8gRGVmYXVsdCB0byBTZXBvbGlhIGlmIG5vIGNoYWluSWQgcHJvdmlkZWRcbiAgICBjb25zdCB0YXJnZXRDaGFpbklkID0gY2hhaW5JZCB8fCAxMTE1NTExMTtcbiAgICByZXR1cm4gZW5zRG9tYWluQ2xpZW50LmdldCh0YXJnZXRDaGFpbklkKTtcbn1cbi8qKlxuICogQ2hlY2sgaWYgRU5TIGNsaWVudCBpcyBpbml0aWFsaXplZCBmb3IgYSBzcGVjaWZpYyBjaGFpblxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNFTlNDbGllbnRJbml0aWFsaXplZChjaGFpbklkKSB7XG4gICAgY29uc3QgdGFyZ2V0Q2hhaW5JZCA9IGNoYWluSWQgfHwgMTExNTUxMTE7XG4gICAgcmV0dXJuIGVuc0RvbWFpbkNsaWVudC5pc0luaXRpYWxpemVkKHRhcmdldENoYWluSWQpO1xufVxuLyoqXG4gKiBSZXNldCB0aGUgRU5TIGNsaWVudCBpbnN0YW5jZSBmb3IgYSBzcGVjaWZpYyBjaGFpbiAodXNlZnVsIGZvciB0ZXN0aW5nKVxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVzZXRFTlNDbGllbnQoY2hhaW5JZCkge1xuICAgIGNvbnN0IHRhcmdldENoYWluSWQgPSBjaGFpbklkIHx8IDExMTU1MTExO1xuICAgIGVuc0RvbWFpbkNsaWVudC5yZXNldCh0YXJnZXRDaGFpbklkKTtcbn1cbi8qKlxuICogQ2hlY2sgaWYgYW4gRU5TIG5hbWUgaXMgYXZhaWxhYmxlXG4gKlxuICogQHBhcmFtIGFnZW50TmFtZSAtIFRoZSBhZ2VudCBuYW1lIChlLmcuLCBcIm15LWFnZW50XCIpXG4gKiBAcGFyYW0gb3JnTmFtZSAtIFRoZSBvcmdhbml6YXRpb24gbmFtZSAoZS5nLiwgXCI4MDA0LWFnZW50XCIgb3IgXCI4MDA0LWFnZW50LmV0aFwiKVxuICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgRU5TIG5hbWUgaXMgYXZhaWxhYmxlLCBmYWxzZSBpZiBpdCdzIHRha2VuLCBudWxsIGlmIGNoZWNrIGZhaWxlZFxuICovXG4vKipcbiAqIENoZWNrIGlmIGFuIEVOUyBuYW1lIGlzIGF2YWlsYWJsZSAoZ2VuZXJhbCBwdXJwb3NlKVxuICpcbiAqIEBwYXJhbSBlbnNOYW1lIC0gRnVsbCBFTlMgbmFtZSAoZS5nLiwgXCJhZ2VudG5hbWUub3JnbmFtZS5ldGhcIiBvciBcIm9yZ25hbWUuZXRoXCIpXG4gKiBAcGFyYW0gY2hhaW5JZCAtIENoYWluIElEIHdoZXJlIHRoZSBFTlMgbmFtZSBzaG91bGQgYmUgY2hlY2tlZFxuICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgRU5TIG5hbWUgaXMgYXZhaWxhYmxlLCBmYWxzZSBpZiBpdCdzIHRha2VuLCBudWxsIGlmIGNoZWNrIGZhaWxlZFxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gaXNFTlNOYW1lQXZhaWxhYmxlKGVuc05hbWUsIGNoYWluSWQpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBlbnNDbGllbnQgPSBhd2FpdCBnZXRFTlNDbGllbnQoY2hhaW5JZCk7XG4gICAgICAgIC8vIE5vcm1hbGl6ZSB0aGUgRU5TIG5hbWUgKGVuc3VyZSBpdCBlbmRzIHdpdGggLmV0aCBpZiBub3QgYWxyZWFkeSlcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZE5hbWUgPSBlbnNOYW1lLnRyaW0oKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBjb25zdCBmdWxsTmFtZSA9IG5vcm1hbGl6ZWROYW1lLmVuZHNXaXRoKCcuZXRoJykgPyBub3JtYWxpemVkTmFtZSA6IGAke25vcm1hbGl6ZWROYW1lfS5ldGhgO1xuICAgICAgICAvLyBDaGVjayBpZiBFTlMgbmFtZSBpcyBhdmFpbGFibGVcbiAgICAgICAgY29uc29sZS5sb2coJyoqKioqKioqKioqIHp6eiBpc0VOU05hbWVBdmFpbGFibGUgZnVsbE5hbWUnLCBmdWxsTmFtZSk7XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nQWNjb3VudCA9IGF3YWl0IGVuc0NsaWVudC5nZXRBZ2VudEFjY291bnRCeU5hbWUoZnVsbE5hbWUpO1xuICAgICAgICBjb25zdCBpc0F2YWlsYWJsZSA9ICFleGlzdGluZ0FjY291bnQgfHwgZXhpc3RpbmdBY2NvdW50ID09PSAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJztcbiAgICAgICAgcmV0dXJuIGlzQXZhaWxhYmxlO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgY2hlY2tpbmcgRU5TIGF2YWlsYWJpbGl0eTonLCBlcnJvcik7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cbi8qKlxuICogQ2hlY2sgaWYgYW4gRU5TIG5hbWUgaXMgYXZhaWxhYmxlIChsZWdhY3kgbWV0aG9kIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5KVxuICpcbiAqIEBwYXJhbSBvcmdOYW1lIC0gVGhlIG9yZ2FuaXphdGlvbiBuYW1lIChlLmcuLCBcIjgwMDQtYWdlbnRcIiBvciBcIjgwMDQtYWdlbnQuZXRoXCIpXG4gKiBAcGFyYW0gYWdlbnROYW1lIC0gVGhlIGFnZW50IG5hbWUgKGUuZy4sIFwibXktYWdlbnRcIilcbiAqIEBwYXJhbSBjaGFpbklkIC0gQ2hhaW4gSUQgd2hlcmUgdGhlIEVOUyBuYW1lIHNob3VsZCBiZSBjaGVja2VkXG4gKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBFTlMgbmFtZSBpcyBhdmFpbGFibGUsIGZhbHNlIGlmIGl0J3MgdGFrZW4sIG51bGwgaWYgY2hlY2sgZmFpbGVkXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBpc0VOU0F2YWlsYWJsZShvcmdOYW1lLCBhZ2VudE5hbWUsIGNoYWluSWQpIHtcbiAgICB0cnkge1xuICAgICAgICAvLyBGb3JtYXQ6IGFnZW50TmFtZS5vcmdOYW1lLmV0aFxuICAgICAgICBjb25zdCBhZ2VudE5hbWVMYWJlbCA9IGFnZW50TmFtZS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL1xccysvZywgJy0nKTtcbiAgICAgICAgY29uc3Qgb3JnTmFtZUNsZWFuID0gb3JnTmFtZS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL1xcLmV0aCQvLCAnJyk7XG4gICAgICAgIGNvbnN0IGZ1bGxOYW1lID0gYCR7YWdlbnROYW1lTGFiZWx9LiR7b3JnTmFtZUNsZWFufS5ldGhgO1xuICAgICAgICByZXR1cm4gYXdhaXQgaXNFTlNOYW1lQXZhaWxhYmxlKGZ1bGxOYW1lLCBjaGFpbklkKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNoZWNraW5nIEVOUyBhdmFpbGFiaWxpdHk6JywgZXJyb3IpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG4vKipcbiAqIEdldCBjb21wcmVoZW5zaXZlIEVOUyBuYW1lIGluZm8gaW4gb25lIGNhbGwuXG4gKiBSZXR1cm5zIGFjY291bnQvYWRkcmVzcywgaW1hZ2UvYXZhdGFyLCB1cmwsIGRlc2NyaXB0aW9uLCBhbmQgYXZhaWxhYmlsaXR5LlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0RU5TSW5mbyhlbnNOYW1lLCBjaGFpbklkKSB7XG4gICAgY29uc3Qgbm9ybWFsaXplZCA9IChlbnNOYW1lIHx8ICcnKS50cmltKCkudG9Mb3dlckNhc2UoKTtcbiAgICBjb25zdCBmdWxsTmFtZSA9IG5vcm1hbGl6ZWQuZW5kc1dpdGgoJy5ldGgnKSA/IG5vcm1hbGl6ZWQgOiBgJHtub3JtYWxpemVkfS5ldGhgO1xuICAgIGNvbnN0IFthdmFpbGFibGUsIGNsaWVudF0gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgIGlzRU5TTmFtZUF2YWlsYWJsZShmdWxsTmFtZSwgY2hhaW5JZCksXG4gICAgICAgIGdldEVOU0NsaWVudChjaGFpbklkKSxcbiAgICBdKTtcbiAgICBjb25zb2xlLmxvZygnKioqKioqKioqKiogenp6IGlzRU5TTmFtZUF2YWlsYWJsZTonLCBhdmFpbGFibGUpO1xuICAgIGNvbnNvbGUubG9nKCcqKioqKioqKioqKiB6enogZ2V0RU5TSW5mbyAwIGZ1bGxOYW1lJywgZnVsbE5hbWUpO1xuICAgIGNvbnN0IFthY2NvdW50LCBpbWFnZSwgdXJsLCBkZXNjcmlwdGlvbl0gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgIGNsaWVudC5nZXRBZ2VudEFjY291bnRCeU5hbWUoZnVsbE5hbWUpLmNhdGNoKCgpID0+IG51bGwpLFxuICAgICAgICBjbGllbnQuZ2V0QWdlbnRJbWFnZUJ5TmFtZShmdWxsTmFtZSkuY2F0Y2goKCkgPT4gbnVsbCksXG4gICAgICAgIGNsaWVudC5nZXRBZ2VudFVybEJ5TmFtZShmdWxsTmFtZSkuY2F0Y2goKCkgPT4gbnVsbCksXG4gICAgICAgIGNsaWVudC5nZXRBZ2VudERlc2NyaXB0aW9uQnlOYW1lKGZ1bGxOYW1lKS5jYXRjaCgoKSA9PiBudWxsKSxcbiAgICBdKTtcbiAgICBjb25zb2xlLmxvZygnKioqKioqKioqKiogenp6IGdldEVOU0luZm8gMSBmdWxsTmFtZScsIGZ1bGxOYW1lLCBhY2NvdW50LCBpbWFnZSwgdXJsLCBkZXNjcmlwdGlvbik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogZnVsbE5hbWUsXG4gICAgICAgIGNoYWluSWQsXG4gICAgICAgIGF2YWlsYWJsZSxcbiAgICAgICAgYWNjb3VudDogYWNjb3VudCA/PyBudWxsLFxuICAgICAgICBpbWFnZTogaW1hZ2UgPz8gbnVsbCxcbiAgICAgICAgdXJsOiB1cmwgPz8gbnVsbCxcbiAgICAgICAgZGVzY3JpcHRpb246IGRlc2NyaXB0aW9uID8/IG51bGwsXG4gICAgfTtcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzZW5kU3BvbnNvcmVkVXNlck9wZXJhdGlvbihwYXJhbXMpIHtcbiAgICBjb25zdCB7IGJ1bmRsZXJVcmwsIGNoYWluLCBhY2NvdW50Q2xpZW50LCBjYWxscyB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IHBpbWxpY29DbGllbnQgPSBjcmVhdGVQaW1saWNvQ2xpZW50KHsgdHJhbnNwb3J0OiBodHRwKGJ1bmRsZXJVcmwpIH0pO1xuICAgIGNvbnN0IGJ1bmRsZXJDbGllbnQgPSBjcmVhdGVCdW5kbGVyQ2xpZW50KHtcbiAgICAgICAgdHJhbnNwb3J0OiBodHRwKGJ1bmRsZXJVcmwpLFxuICAgICAgICBwYXltYXN0ZXI6IHRydWUsXG4gICAgICAgIGNoYWluOiBjaGFpbixcbiAgICAgICAgcGF5bWFzdGVyQ29udGV4dDogeyBtb2RlOiAnU1BPTlNPUkVEJyB9XG4gICAgfSk7XG4gICAgY29uc3QgeyBmYXN0OiBmZWUgfSA9IGF3YWl0IHBpbWxpY29DbGllbnQuZ2V0VXNlck9wZXJhdGlvbkdhc1ByaWNlKCk7XG4gICAgY29uc3QgdXNlck9wSGFzaCA9IGF3YWl0IGJ1bmRsZXJDbGllbnQuc2VuZFVzZXJPcGVyYXRpb24oe1xuICAgICAgICBhY2NvdW50OiBhY2NvdW50Q2xpZW50LFxuICAgICAgICBjYWxscyxcbiAgICAgICAgLi4uZmVlXG4gICAgfSk7XG4gICAgcmV0dXJuIHVzZXJPcEhhc2g7XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gYWRkQWdlbnROYW1lVG9MMU9yZyhwYXJhbXMpIHtcbiAgICBjb25zdCB7IGFnZW50QWRkcmVzcywgb3JnTmFtZSwgYWdlbnROYW1lLCBhZ2VudFVybCB9ID0gcGFyYW1zO1xuICAgIGNvbnNvbGUubG9nKFwiYWRkQWdlbnROYW1lVG9MMU9yZzogXCIsIGFnZW50QWRkcmVzcywgb3JnTmFtZSwgYWdlbnROYW1lLCBhZ2VudFVybCk7XG4gICAgaWYgKCFhZ2VudE5hbWUgfHwgIW9yZ05hbWUgfHwgIWFnZW50QWRkcmVzcykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FnZW50TmFtZSwgb3JnTmFtZSwgYW5kIGFnZW50QWRkcmVzcyBhcmUgcmVxdWlyZWQgdG8gYWRkIGFuIGFnZW50IG5hbWUgdG8gYW4gb3JnJyk7XG4gICAgfVxuICAgIGNvbnNvbGUubG9nKFwiZW5zQ2xpZW50IGdldCBlbnMgZm9yIGNoYWluOiBcIiwgcGFyYW1zLmNoYWluSWQpO1xuICAgIGNvbnN0IHRhcmdldENoYWluSWQgPSBwYXJhbXMuY2hhaW5JZCB8fCAxMTE1NTExMTtcbiAgICBjb25zdCBlbnNDbGllbnQgPSBhd2FpdCBnZXRFTlNDbGllbnQodGFyZ2V0Q2hhaW5JZCk7XG4gICAgY29uc3QgYWdlbnROYW1lTGFiZWwgPSBhZ2VudE5hbWUudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9cXHMrL2csICctJyk7XG4gICAgY29uc3Qgb3JnTmFtZUNsZWFuID0gb3JnTmFtZS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL1xcLmV0aCQvLCAnJyk7XG4gICAgY29uc3Qgb3JnQWRkcmVzcyA9IGdldEVuc09yZ0FkZHJlc3ModGFyZ2V0Q2hhaW5JZCk7XG4gICAgLy8gb3B0aW9uYWwgVFRMIChkZWZhdWx0cyB0byAwKVxuICAgIGNvbnNvbGUubG9nKCcqKioqKioqKioqKioqKioqKioqKiogcHJlcGFyZUFkZEFnZW50TmFtZVRvT3JnQ2FsbHM6IG9yZ05hbWU6ICcsIG9yZ05hbWUsIGFnZW50TmFtZSwgYWdlbnRBZGRyZXNzLCBhZ2VudFVybCk7XG4gICAgY29uc3QgeyBjYWxsczogb3JnQ2FsbHMgfSA9IGF3YWl0IGVuc0NsaWVudC5wcmVwYXJlQWRkQWdlbnROYW1lVG9PcmdDYWxscyh7XG4gICAgICAgIGFnZW50QWRkcmVzcyxcbiAgICAgICAgb3JnTmFtZTogb3JnTmFtZUNsZWFuLFxuICAgICAgICBhZ2VudE5hbWU6IGFnZW50TmFtZUxhYmVsLFxuICAgICAgICBhZ2VudFVybDogYWdlbnRVcmwgfHwgJycsXG4gICAgfSk7XG4gICAgaWYgKGVuc0NsaWVudC5pc0wxKCkpIHtcbiAgICAgICAgLy8gT3B0aW9uYWxseSBzdWJtaXQgc2VydmVyLXNpZGUgaWYgY29uZmlndXJlZCAobm8gYnJlYWtpbmcgY2hhbmdlOiBzdGlsbCByZXR1cm5zIGNhbGxzKVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgYnVuZGxlclVybCA9IGdldENoYWluRW52VmFyKCdBR0VOVElDX1RSVVNUX0JVTkRMRVJfVVJMJywgcGFyYW1zLmNoYWluSWQgfHwgMTExNTUxMTEpO1xuICAgICAgICAgICAgY29uc3QgcnBjVXJsID0gZ2V0Q2hhaW5FbnZWYXIoJ0FHRU5USUNfVFJVU1RfUlBDX1VSTCcsIHBhcmFtcy5jaGFpbklkIHx8IDExMTU1MTExKTtcbiAgICAgICAgICAgIGxldCBlbnNQcml2S2V5O1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBlbnNQcml2S2V5ID0gZ2V0RW5zUHJpdmF0ZUtleSh0YXJnZXRDaGFpbklkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIHtcbiAgICAgICAgICAgICAgICBlbnNQcml2S2V5ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVuc1ByaXZLZXkgJiYgYnVuZGxlclVybCAmJiBycGNVcmwpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwdWJsaWNDbGllbnQgPSBjcmVhdGVQdWJsaWNDbGllbnQoeyBjaGFpbjogc2Vwb2xpYSwgdHJhbnNwb3J0OiBodHRwKHJwY1VybCkgfSk7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3JnRU9BID0gcHJpdmF0ZUtleVRvQWNjb3VudChlbnNQcml2S2V5KTtcbiAgICAgICAgICAgICAgICBjb25zdCB3YWxsZXRDbGllbnQgPSBjcmVhdGVXYWxsZXRDbGllbnQoe1xuICAgICAgICAgICAgICAgICAgICBhY2NvdW50OiBvcmdFT0EsXG4gICAgICAgICAgICAgICAgICAgIGNoYWluOiBzZXBvbGlhLFxuICAgICAgICAgICAgICAgICAgICB0cmFuc3BvcnQ6IGh0dHAocnBjVXJsKSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCBvcmdBY2NvdW50Q2xpZW50ID0gYXdhaXQgdG9NZXRhTWFza1NtYXJ0QWNjb3VudCh7XG4gICAgICAgICAgICAgICAgICAgIGFkZHJlc3M6IG9yZ0FkZHJlc3MsXG4gICAgICAgICAgICAgICAgICAgIGNsaWVudDogcHVibGljQ2xpZW50LFxuICAgICAgICAgICAgICAgICAgICBpbXBsZW1lbnRhdGlvbjogSW1wbGVtZW50YXRpb24uSHlicmlkLFxuICAgICAgICAgICAgICAgICAgICBzaWduZXI6IHsgd2FsbGV0Q2xpZW50OiB3YWxsZXRDbGllbnQgfSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCBwaW1saWNvQ2xpZW50ID0gY3JlYXRlUGltbGljb0NsaWVudCh7IHRyYW5zcG9ydDogaHR0cChidW5kbGVyVXJsKSB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCBidW5kbGVyQ2xpZW50ID0gY3JlYXRlQnVuZGxlckNsaWVudCh7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zcG9ydDogaHR0cChidW5kbGVyVXJsKSxcbiAgICAgICAgICAgICAgICAgICAgcGF5bWFzdGVyOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBjaGFpbjogc2Vwb2xpYSxcbiAgICAgICAgICAgICAgICAgICAgcGF5bWFzdGVyQ29udGV4dDogeyBtb2RlOiAnU1BPTlNPUkVEJyB9LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZmFzdDogZmVlIH0gPSBhd2FpdCBwaW1saWNvQ2xpZW50LmdldFVzZXJPcGVyYXRpb25HYXNQcmljZSgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHVzZXJPcEhhc2ggPSBhd2FpdCBidW5kbGVyQ2xpZW50LnNlbmRVc2VyT3BlcmF0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgYWNjb3VudDogb3JnQWNjb3VudENsaWVudCxcbiAgICAgICAgICAgICAgICAgICAgY2FsbHM6IG9yZ0NhbGxzLFxuICAgICAgICAgICAgICAgICAgICAuLi5mZWUsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYXdhaXQgYnVuZGxlckNsaWVudC53YWl0Rm9yVXNlck9wZXJhdGlvblJlY2VpcHQoeyBoYXNoOiB1c2VyT3BIYXNoIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgLy8gSWYgc2VydmVyLXNpZGUgc3VibWlzc2lvbiBmYWlscywganVzdCByZXR1cm4gcHJlcGFyZWQgY2FsbHNcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGFkZGluZyBhZ2VudCBuYW1lIHRvIG9yZzonLCBlcnJvcik7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBhZGQgYWdlbnQgbmFtZSB0byBvcmc6ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvcid9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFwic3VjY2Vzc1wiO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHByZXBhcmVMMUFnZW50TmFtZUluZm9DYWxscyhwYXJhbXMpIHtcbiAgICBjb25zdCB7IGFnZW50QWRkcmVzcywgb3JnTmFtZSwgYWdlbnROYW1lLCBhZ2VudFVybCwgYWdlbnREZXNjcmlwdGlvbiB9ID0gcGFyYW1zO1xuICAgIGlmICghYWdlbnROYW1lIHx8ICFvcmdOYW1lIHx8ICFhZ2VudEFkZHJlc3MpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhZ2VudE5hbWUsIG9yZ05hbWUsIGFuZCBhZ2VudEFkZHJlc3MgYXJlIHJlcXVpcmVkIHRvIHByZXBhcmUgRU5TIGFnZW50IGluZm8gY2FsbHMnKTtcbiAgICB9XG4gICAgY29uc3QgdGFyZ2V0Q2hhaW5JZCA9IHBhcmFtcy5jaGFpbklkIHx8IDExMTU1MTExO1xuICAgIGNvbnN0IGVuc0NsaWVudCA9IGF3YWl0IGdldEVOU0NsaWVudCh0YXJnZXRDaGFpbklkKTtcbiAgICBjb25zdCBvcmdOYW1lQ2xlYW4gPSBvcmdOYW1lLnJlcGxhY2UoL1xcLmV0aCQvaSwgJycpLnRvTG93ZXJDYXNlKCk7XG4gICAgY29uc3Qgb3JnTmFtZVBhdHRlcm4gPSBvcmdOYW1lQ2xlYW4ucmVwbGFjZSgvWy4qKz9eJHt9KCl8W1xcXVxcXFxdL2csICdcXFxcJCYnKTtcbiAgICBjb25zdCBhZ2VudE5hbWVUcmltbWVkID0gYWdlbnROYW1lXG4gICAgICAgIC5yZXBsYWNlKG5ldyBSZWdFeHAoYF4ke29yZ05hbWVQYXR0ZXJufVxcXFwuYCwgJ2knKSwgJycpXG4gICAgICAgIC5yZXBsYWNlKC9cXC5ldGgkL2ksICcnKVxuICAgICAgICAudHJpbSgpO1xuICAgIGNvbnN0IGFnZW50TmFtZUxhYmVsID0gYWdlbnROYW1lVHJpbW1lZC50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL1xccysvZywgJy0nKTtcbiAgICBjb25zdCB7IGNhbGxzIH0gPSBhd2FpdCBlbnNDbGllbnQucHJlcGFyZVNldEFnZW50TmFtZUluZm9DYWxscyh7XG4gICAgICAgIG9yZ05hbWU6IG9yZ05hbWVDbGVhbixcbiAgICAgICAgYWdlbnROYW1lOiBhZ2VudE5hbWVMYWJlbCxcbiAgICAgICAgYWdlbnRBZGRyZXNzLFxuICAgICAgICBhZ2VudFVybDogYWdlbnRVcmwgfHwgJycsXG4gICAgICAgIGFnZW50RGVzY3JpcHRpb246IGFnZW50RGVzY3JpcHRpb24gfHwgJycsXG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY2FsbHMsXG4gICAgfTtcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBhZGRBZ2VudE5hbWVUb0wyT3JnKHBhcmFtcykge1xuICAgIGNvbnN0IHsgYWdlbnRBZGRyZXNzLCBvcmdOYW1lLCBhZ2VudE5hbWUsIGFnZW50VXJsLCBhZ2VudERlc2NyaXB0aW9uLCBhZ2VudEltYWdlIH0gPSBwYXJhbXM7XG4gICAgaWYgKCFhZ2VudE5hbWUgfHwgIW9yZ05hbWUgfHwgIWFnZW50QWRkcmVzcykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FnZW50TmFtZSwgb3JnTmFtZSwgYW5kIGFnZW50QWRkcmVzcyBhcmUgcmVxdWlyZWQgdG8gcHJlcGFyZSBMMiBFTlMgY2FsbHMnKTtcbiAgICB9XG4gICAgY29uc29sZS5pbmZvKFwiaW5zaWRlIGFkZEFnZW50TmFtZVRvTDJPcmc6IFwiLCBwYXJhbXMpO1xuICAgIGNvbnN0IHRhcmdldENoYWluSWQgPSBwYXJhbXMuY2hhaW5JZCB8fCAxMTE1NTExMTtcbiAgICBjb25zdCBlbnNDbGllbnQgPSBhd2FpdCBnZXRFTlNDbGllbnQodGFyZ2V0Q2hhaW5JZCk7XG4gICAgY29uc3Qgb3JnTmFtZUNsZWFuID0gb3JnTmFtZS5yZXBsYWNlKC9cXC5ldGgkL2ksICcnKS50b0xvd2VyQ2FzZSgpO1xuICAgIGNvbnN0IG9yZ05hbWVQYXR0ZXJuID0gb3JnTmFtZUNsZWFuLnJlcGxhY2UoL1suKis/XiR7fSgpfFtcXF1cXFxcXS9nLCAnXFxcXCQmJyk7XG4gICAgY29uc3QgYWdlbnROYW1lVHJpbW1lZCA9IGFnZW50TmFtZVxuICAgICAgICAucmVwbGFjZShuZXcgUmVnRXhwKGBeJHtvcmdOYW1lUGF0dGVybn1cXFxcLmAsICdpJyksICcnKVxuICAgICAgICAucmVwbGFjZSgvXFwuZXRoJC9pLCAnJylcbiAgICAgICAgLnRyaW0oKTtcbiAgICBjb25zdCBhZ2VudE5hbWVMYWJlbCA9IGFnZW50TmFtZVRyaW1tZWQudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9cXHMrL2csICctJyk7XG4gICAgY29uc3QgY2FsbHMgPSBbXTtcbiAgICAvLyBDcmVhdGUgc3ViZG9tYWluIGlmIG1pc3NpbmdcbiAgICBjb25zb2xlLmluZm8oXCJzZWUgaWYgYWdlbnQgbmFtZSBpcyBhdmFpbGFibGU6IFwiLCBvcmdOYW1lQ2xlYW4sIGFnZW50TmFtZUxhYmVsKTtcbiAgICBjb25zdCBoYXNPd25lciA9IGF3YWl0IGVuc0NsaWVudC5oYXNBZ2VudE5hbWVPd25lcihvcmdOYW1lQ2xlYW4sIGFnZW50TmFtZUxhYmVsKTtcbiAgICBjb25zb2xlLmluZm8oXCJoYXNPd25lcjogXCIsIGhhc093bmVyKTtcbiAgICBpZiAoIWhhc093bmVyKSB7XG4gICAgICAgIGNvbnNvbGUuaW5mbyhcImFnZW50IG5hbWUgaXMgbm90IGF2YWlsYWJsZSwgcHJlcGFyZSBhZGQgYWdlbnQgbmFtZSB0byBvcmcgY2FsbHNcIik7XG4gICAgICAgIGNvbnN0IHsgY2FsbHM6IG9yZ0NhbGxzIH0gPSBhd2FpdCBlbnNDbGllbnQucHJlcGFyZUFkZEFnZW50TmFtZVRvT3JnQ2FsbHMoe1xuICAgICAgICAgICAgb3JnTmFtZTogb3JnTmFtZUNsZWFuLFxuICAgICAgICAgICAgYWdlbnROYW1lOiBhZ2VudE5hbWVMYWJlbCxcbiAgICAgICAgICAgIGFnZW50QWRkcmVzcyxcbiAgICAgICAgICAgIGFnZW50VXJsOiBhZ2VudFVybCB8fCAnJyxcbiAgICAgICAgfSk7XG4gICAgICAgIGNhbGxzLnB1c2goLi4ub3JnQ2FsbHMpO1xuICAgIH1cbiAgICAvKlxuICAgIC8vIE1ldGFkYXRhICh0ZXh0IHJlY29yZHMpXG4gICAgY29uc29sZS5pbmZvKFwicHJlcGFyZSBzZXQgYWdlbnQgbmFtZSBpbmZvIGNhbGxzXCIpO1xuICAgIGNvbnN0IHsgY2FsbHM6IGluZm9DYWxscyB9ID0gYXdhaXQgZW5zQ2xpZW50LnByZXBhcmVTZXRBZ2VudE5hbWVJbmZvQ2FsbHMoe1xuICAgICAgb3JnTmFtZTogb3JnTmFtZUNsZWFuLFxuICAgICAgYWdlbnROYW1lOiBhZ2VudE5hbWVMYWJlbCxcbiAgICAgIGFnZW50QWRkcmVzcyxcbiAgICAgIGFnZW50VXJsOiBhZ2VudFVybCB8fCAnJyxcbiAgICAgIGFnZW50RGVzY3JpcHRpb246IGFnZW50RGVzY3JpcHRpb24gfHwgJycsXG4gICAgfSk7XG4gICAgY2FsbHMucHVzaCguLi5pbmZvQ2FsbHMpO1xuICBcbiAgICAvLyBPcHRpb25hbCBhdmF0YXIvaW1hZ2VcbiAgICBjb25zb2xlLmluZm8oXCJwcmVwYXJlIHNldCBuYW1lIGltYWdlIGNhbGxzXCIpO1xuICAgIGlmIChhZ2VudEltYWdlICYmIGFnZW50SW1hZ2UudHJpbSgpICE9PSAnJykge1xuICAgICAgY29uc3QgZnVsbFN1Ym5hbWUgPSBgJHthZ2VudE5hbWVMYWJlbH0uJHtvcmdOYW1lQ2xlYW59LmV0aGA7XG4gICAgICBjb25zdCB7IGNhbGxzOiBpbWFnZUNhbGxzIH0gPSBhd2FpdCAoZW5zQ2xpZW50IGFzIGFueSkucHJlcGFyZVNldE5hbWVJbWFnZUNhbGxzKGZ1bGxTdWJuYW1lLCBhZ2VudEltYWdlLnRyaW0oKSk7XG4gICAgICBjYWxscy5wdXNoKC4uLmltYWdlQ2FsbHMpO1xuICAgIH1cbiAgICAqL1xuICAgIGNvbnNvbGUuaW5mbyhcImFkZEFnZW50TmFtZVRvTDJPcmc6IGNhbGxzXCIsIGNhbGxzKTtcbiAgICByZXR1cm4geyBjYWxscyB9O1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHByZXBhcmVMMkFnZW50TmFtZUluZm9DYWxscyhwYXJhbXMpIHtcbiAgICBjb25zdCB7IGFnZW50QWRkcmVzcywgb3JnTmFtZSwgYWdlbnROYW1lLCBhZ2VudFVybCwgYWdlbnREZXNjcmlwdGlvbiB9ID0gcGFyYW1zO1xuICAgIGNvbnNvbGUuaW5mbyhcImluc2lkZSBhZGRBZ2VudE5hbWVUb0wyT3JnOiBcIiwgcGFyYW1zKTtcbiAgICBjb25zdCB0YXJnZXRDaGFpbklkID0gcGFyYW1zLmNoYWluSWQgfHwgMTExNTUxMTE7XG4gICAgY29uc3QgZW5zQ2xpZW50ID0gYXdhaXQgZ2V0RU5TQ2xpZW50KHRhcmdldENoYWluSWQpO1xuICAgIGNvbnN0IG9yZ05hbWVDbGVhbiA9IG9yZ05hbWUucmVwbGFjZSgvXFwuZXRoJC9pLCAnJykudG9Mb3dlckNhc2UoKTtcbiAgICBjb25zdCBvcmdOYW1lUGF0dGVybiA9IG9yZ05hbWVDbGVhbi5yZXBsYWNlKC9bLiorP14ke30oKXxbXFxdXFxcXF0vZywgJ1xcXFwkJicpO1xuICAgIGNvbnN0IGFnZW50TmFtZVRyaW1tZWQgPSBhZ2VudE5hbWVcbiAgICAgICAgLnJlcGxhY2UobmV3IFJlZ0V4cChgXiR7b3JnTmFtZVBhdHRlcm59XFxcXC5gLCAnaScpLCAnJylcbiAgICAgICAgLnJlcGxhY2UoL1xcLmV0aCQvaSwgJycpXG4gICAgICAgIC50cmltKCk7XG4gICAgY29uc3QgYWdlbnROYW1lTGFiZWwgPSBhZ2VudE5hbWVUcmltbWVkLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvXFxzKy9nLCAnLScpO1xuICAgIGNvbnN0IGNhbGxzID0gW107XG4gICAgLy8gTWV0YWRhdGEgKHRleHQgcmVjb3JkcylcbiAgICBjb25zb2xlLmluZm8oXCJwcmVwYXJlIHNldCBhZ2VudCBuYW1lIGluZm8gY2FsbHNcIik7XG4gICAgY29uc3QgeyBjYWxsczogaW5mb0NhbGxzIH0gPSBhd2FpdCBlbnNDbGllbnQucHJlcGFyZVNldEFnZW50TmFtZUluZm9DYWxscyh7XG4gICAgICAgIG9yZ05hbWU6IG9yZ05hbWVDbGVhbixcbiAgICAgICAgYWdlbnROYW1lOiBhZ2VudE5hbWVMYWJlbCxcbiAgICAgICAgYWdlbnRBZGRyZXNzLFxuICAgICAgICBhZ2VudFVybDogYWdlbnRVcmwgfHwgJycsXG4gICAgICAgIGFnZW50RGVzY3JpcHRpb246IGFnZW50RGVzY3JpcHRpb24gfHwgJycsXG4gICAgfSk7XG4gICAgY2FsbHMucHVzaCguLi5pbmZvQ2FsbHMpO1xuICAgIC8vIE9wdGlvbmFsIGF2YXRhci9pbWFnZVxuICAgIGNvbnNvbGUuaW5mbyhcInByZXBhcmUgc2V0IG5hbWUgaW1hZ2UgY2FsbHNcIik7XG4gICAgaWYgKHBhcmFtcy5hZ2VudEltYWdlICYmIHBhcmFtcy5hZ2VudEltYWdlLnRyaW0oKSAhPT0gJycpIHtcbiAgICAgICAgY29uc3QgZnVsbFN1Ym5hbWUgPSBgJHthZ2VudE5hbWVMYWJlbH0uJHtvcmdOYW1lQ2xlYW59LmV0aGA7XG4gICAgICAgIGNvbnN0IHsgY2FsbHM6IGltYWdlQ2FsbHMgfSA9IGF3YWl0IGVuc0NsaWVudC5wcmVwYXJlU2V0TmFtZUltYWdlQ2FsbHMoZnVsbFN1Ym5hbWUsIHBhcmFtcy5hZ2VudEltYWdlLnRyaW0oKSk7XG4gICAgICAgIGNhbGxzLnB1c2goLi4uaW1hZ2VDYWxscyk7XG4gICAgfVxuICAgIHJldHVybiB7IGNhbGxzIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lbnNDbGllbnQuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@agentic-trust/core/dist/server/singletons/ensClient.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@agentic-trust/core/dist/server/singletons/identityClient.js":
/*!***************************************************************************************!*\
  !*** ../../node_modules/@agentic-trust/core/dist/server/singletons/identityClient.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getIdentityRegistryClient: () => (/* binding */ getIdentityRegistryClient),\n/* harmony export */   isIdentityClientInitialized: () => (/* binding */ isIdentityClientInitialized),\n/* harmony export */   resetIdentityClient: () => (/* binding */ resetIdentityClient)\n/* harmony export */ });\n/* harmony import */ var _agentic_trust_8004_ext_sdk__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @agentic-trust/8004-ext-sdk */ \"(rsc)/../../node_modules/@agentic-trust/8004-ext-sdk/dist/index.js\");\n/* harmony import */ var _agentic_trust_8004_sdk__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @agentic-trust/8004-sdk */ \"(rsc)/../../node_modules/@agentic-trust/8004-sdk/dist/index.js\");\n/* harmony import */ var _lib_chainConfig__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/chainConfig */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/lib/chainConfig.js\");\n/* harmony import */ var _domainClient__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./domainClient */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/singletons/domainClient.js\");\n/**\n * Identity Client Singleton\n *\n * Manages a singleton instance of AIAgentIdentityClient\n * Initialized from environment variables using AccountProvider\n */\n\n\n\n\nclass IdentityDomainClient extends _domainClient__WEBPACK_IMPORTED_MODULE_3__.DomainClient {\n    constructor() {\n        super('identity');\n    }\n    async buildClient(targetChainId) {\n        const identityRegistry = (0,_lib_chainConfig__WEBPACK_IMPORTED_MODULE_2__.requireChainEnvVar)('AGENTIC_TRUST_IDENTITY_REGISTRY', targetChainId);\n        const rpcUrl = (0,_lib_chainConfig__WEBPACK_IMPORTED_MODULE_2__.requireChainEnvVar)('AGENTIC_TRUST_RPC_URL', targetChainId);\n        // Create AccountProvider using ViemAccountProvider (read-only, no wallet)\n        const { createPublicClient, http } = await Promise.all(/*! import() */[__webpack_require__.e(\"vendor-chunks/viem\"), __webpack_require__.e(\"vendor-chunks/abitype\")]).then(__webpack_require__.bind(__webpack_require__, /*! viem */ \"(rsc)/../../node_modules/viem/_esm/index.js\"));\n        const { sepolia, baseSepolia, optimismSepolia } = await __webpack_require__.e(/*! import() */ \"vendor-chunks/viem\").then(__webpack_require__.bind(__webpack_require__, /*! viem/chains */ \"(rsc)/../../node_modules/viem/_esm/chains/index.js\"));\n        // Get chain by ID\n        let chain = sepolia;\n        if (targetChainId === 84532) {\n            chain = baseSepolia;\n        }\n        else if (targetChainId === 11155420) {\n            chain = optimismSepolia;\n        }\n        const publicClient = createPublicClient({\n            chain: chain,\n            transport: http(rpcUrl),\n        });\n        const accountProvider = new _agentic_trust_8004_sdk__WEBPACK_IMPORTED_MODULE_1__.ViemAccountProvider({\n            publicClient: publicClient,\n            walletClient: null, // Read-only, no wallet\n            chainConfig: {\n                id: targetChainId,\n                rpcUrl,\n                name: chain.name,\n                chain: chain,\n            },\n        });\n        // Create identity client using AccountProvider\n        const identityClient = new _agentic_trust_8004_ext_sdk__WEBPACK_IMPORTED_MODULE_0__.AIAgentIdentityClient({\n            accountProvider,\n            identityRegistryAddress: identityRegistry,\n        });\n        return identityClient;\n    }\n}\nconst identityDomainClient = new IdentityDomainClient();\n/**\n * Get or create the AIAgentIdentityClient singleton\n * Initializes from environment variables using AccountProvider\n */\nasync function getIdentityRegistryClient(chainId) {\n    // Default to configured chain if no chainId provided\n    const targetChainId = chainId || _lib_chainConfig__WEBPACK_IMPORTED_MODULE_2__.DEFAULT_CHAIN_ID;\n    return identityDomainClient.get(targetChainId);\n}\n/**\n * Check if identity client is initialized for a specific chain\n */\nfunction isIdentityClientInitialized(chainId) {\n    const targetChainId = chainId || _lib_chainConfig__WEBPACK_IMPORTED_MODULE_2__.DEFAULT_CHAIN_ID;\n    return identityDomainClient.isInitialized(targetChainId);\n}\n/**\n * Reset the identity client instance for a specific chain (useful for testing)\n */\nfunction resetIdentityClient(chainId) {\n    const targetChainId = chainId || _lib_chainConfig__WEBPACK_IMPORTED_MODULE_2__.DEFAULT_CHAIN_ID;\n    identityDomainClient.reset(targetChainId);\n}\n//# sourceMappingURL=identityClient.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BhZ2VudGljLXRydXN0L2NvcmUvZGlzdC9zZXJ2ZXIvc2luZ2xldG9ucy9pZGVudGl0eUNsaWVudC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ29FO0FBQ047QUFDWTtBQUM1QjtBQUM5QyxtQ0FBbUMsdURBQVk7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsb0VBQWtCO0FBQ25ELHVCQUF1QixvRUFBa0I7QUFDekM7QUFDQSxnQkFBZ0IsMkJBQTJCLFFBQVEsd09BQWM7QUFDakUsZ0JBQWdCLHdDQUF3QyxRQUFRLHdMQUFxQjtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULG9DQUFvQyx3RUFBbUI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0EsbUNBQW1DLDhFQUFxQjtBQUN4RDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EscUNBQXFDLDhEQUFnQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxxQ0FBcUMsOERBQWdCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLHFDQUFxQyw4REFBZ0I7QUFDckQ7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9iYXJiL2FhL0Fzc29jaWF0ZWRBY2NvdW50cy9ub2RlX21vZHVsZXMvQGFnZW50aWMtdHJ1c3QvY29yZS9kaXN0L3NlcnZlci9zaW5nbGV0b25zL2lkZW50aXR5Q2xpZW50LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogSWRlbnRpdHkgQ2xpZW50IFNpbmdsZXRvblxuICpcbiAqIE1hbmFnZXMgYSBzaW5nbGV0b24gaW5zdGFuY2Ugb2YgQUlBZ2VudElkZW50aXR5Q2xpZW50XG4gKiBJbml0aWFsaXplZCBmcm9tIGVudmlyb25tZW50IHZhcmlhYmxlcyB1c2luZyBBY2NvdW50UHJvdmlkZXJcbiAqL1xuaW1wb3J0IHsgQUlBZ2VudElkZW50aXR5Q2xpZW50IH0gZnJvbSAnQGFnZW50aWMtdHJ1c3QvODAwNC1leHQtc2RrJztcbmltcG9ydCB7IFZpZW1BY2NvdW50UHJvdmlkZXIgfSBmcm9tICdAYWdlbnRpYy10cnVzdC84MDA0LXNkayc7XG5pbXBvcnQgeyByZXF1aXJlQ2hhaW5FbnZWYXIsIERFRkFVTFRfQ0hBSU5fSUQgfSBmcm9tICcuLi9saWIvY2hhaW5Db25maWcnO1xuaW1wb3J0IHsgRG9tYWluQ2xpZW50IH0gZnJvbSAnLi9kb21haW5DbGllbnQnO1xuY2xhc3MgSWRlbnRpdHlEb21haW5DbGllbnQgZXh0ZW5kcyBEb21haW5DbGllbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcignaWRlbnRpdHknKTtcbiAgICB9XG4gICAgYXN5bmMgYnVpbGRDbGllbnQodGFyZ2V0Q2hhaW5JZCkge1xuICAgICAgICBjb25zdCBpZGVudGl0eVJlZ2lzdHJ5ID0gcmVxdWlyZUNoYWluRW52VmFyKCdBR0VOVElDX1RSVVNUX0lERU5USVRZX1JFR0lTVFJZJywgdGFyZ2V0Q2hhaW5JZCk7XG4gICAgICAgIGNvbnN0IHJwY1VybCA9IHJlcXVpcmVDaGFpbkVudlZhcignQUdFTlRJQ19UUlVTVF9SUENfVVJMJywgdGFyZ2V0Q2hhaW5JZCk7XG4gICAgICAgIC8vIENyZWF0ZSBBY2NvdW50UHJvdmlkZXIgdXNpbmcgVmllbUFjY291bnRQcm92aWRlciAocmVhZC1vbmx5LCBubyB3YWxsZXQpXG4gICAgICAgIGNvbnN0IHsgY3JlYXRlUHVibGljQ2xpZW50LCBodHRwIH0gPSBhd2FpdCBpbXBvcnQoJ3ZpZW0nKTtcbiAgICAgICAgY29uc3QgeyBzZXBvbGlhLCBiYXNlU2Vwb2xpYSwgb3B0aW1pc21TZXBvbGlhIH0gPSBhd2FpdCBpbXBvcnQoJ3ZpZW0vY2hhaW5zJyk7XG4gICAgICAgIC8vIEdldCBjaGFpbiBieSBJRFxuICAgICAgICBsZXQgY2hhaW4gPSBzZXBvbGlhO1xuICAgICAgICBpZiAodGFyZ2V0Q2hhaW5JZCA9PT0gODQ1MzIpIHtcbiAgICAgICAgICAgIGNoYWluID0gYmFzZVNlcG9saWE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGFyZ2V0Q2hhaW5JZCA9PT0gMTExNTU0MjApIHtcbiAgICAgICAgICAgIGNoYWluID0gb3B0aW1pc21TZXBvbGlhO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHB1YmxpY0NsaWVudCA9IGNyZWF0ZVB1YmxpY0NsaWVudCh7XG4gICAgICAgICAgICBjaGFpbjogY2hhaW4sXG4gICAgICAgICAgICB0cmFuc3BvcnQ6IGh0dHAocnBjVXJsKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGFjY291bnRQcm92aWRlciA9IG5ldyBWaWVtQWNjb3VudFByb3ZpZGVyKHtcbiAgICAgICAgICAgIHB1YmxpY0NsaWVudDogcHVibGljQ2xpZW50LFxuICAgICAgICAgICAgd2FsbGV0Q2xpZW50OiBudWxsLCAvLyBSZWFkLW9ubHksIG5vIHdhbGxldFxuICAgICAgICAgICAgY2hhaW5Db25maWc6IHtcbiAgICAgICAgICAgICAgICBpZDogdGFyZ2V0Q2hhaW5JZCxcbiAgICAgICAgICAgICAgICBycGNVcmwsXG4gICAgICAgICAgICAgICAgbmFtZTogY2hhaW4ubmFtZSxcbiAgICAgICAgICAgICAgICBjaGFpbjogY2hhaW4sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gQ3JlYXRlIGlkZW50aXR5IGNsaWVudCB1c2luZyBBY2NvdW50UHJvdmlkZXJcbiAgICAgICAgY29uc3QgaWRlbnRpdHlDbGllbnQgPSBuZXcgQUlBZ2VudElkZW50aXR5Q2xpZW50KHtcbiAgICAgICAgICAgIGFjY291bnRQcm92aWRlcixcbiAgICAgICAgICAgIGlkZW50aXR5UmVnaXN0cnlBZGRyZXNzOiBpZGVudGl0eVJlZ2lzdHJ5LFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGlkZW50aXR5Q2xpZW50O1xuICAgIH1cbn1cbmNvbnN0IGlkZW50aXR5RG9tYWluQ2xpZW50ID0gbmV3IElkZW50aXR5RG9tYWluQ2xpZW50KCk7XG4vKipcbiAqIEdldCBvciBjcmVhdGUgdGhlIEFJQWdlbnRJZGVudGl0eUNsaWVudCBzaW5nbGV0b25cbiAqIEluaXRpYWxpemVzIGZyb20gZW52aXJvbm1lbnQgdmFyaWFibGVzIHVzaW5nIEFjY291bnRQcm92aWRlclxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0SWRlbnRpdHlSZWdpc3RyeUNsaWVudChjaGFpbklkKSB7XG4gICAgLy8gRGVmYXVsdCB0byBjb25maWd1cmVkIGNoYWluIGlmIG5vIGNoYWluSWQgcHJvdmlkZWRcbiAgICBjb25zdCB0YXJnZXRDaGFpbklkID0gY2hhaW5JZCB8fCBERUZBVUxUX0NIQUlOX0lEO1xuICAgIHJldHVybiBpZGVudGl0eURvbWFpbkNsaWVudC5nZXQodGFyZ2V0Q2hhaW5JZCk7XG59XG4vKipcbiAqIENoZWNrIGlmIGlkZW50aXR5IGNsaWVudCBpcyBpbml0aWFsaXplZCBmb3IgYSBzcGVjaWZpYyBjaGFpblxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNJZGVudGl0eUNsaWVudEluaXRpYWxpemVkKGNoYWluSWQpIHtcbiAgICBjb25zdCB0YXJnZXRDaGFpbklkID0gY2hhaW5JZCB8fCBERUZBVUxUX0NIQUlOX0lEO1xuICAgIHJldHVybiBpZGVudGl0eURvbWFpbkNsaWVudC5pc0luaXRpYWxpemVkKHRhcmdldENoYWluSWQpO1xufVxuLyoqXG4gKiBSZXNldCB0aGUgaWRlbnRpdHkgY2xpZW50IGluc3RhbmNlIGZvciBhIHNwZWNpZmljIGNoYWluICh1c2VmdWwgZm9yIHRlc3RpbmcpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXNldElkZW50aXR5Q2xpZW50KGNoYWluSWQpIHtcbiAgICBjb25zdCB0YXJnZXRDaGFpbklkID0gY2hhaW5JZCB8fCBERUZBVUxUX0NIQUlOX0lEO1xuICAgIGlkZW50aXR5RG9tYWluQ2xpZW50LnJlc2V0KHRhcmdldENoYWluSWQpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aWRlbnRpdHlDbGllbnQuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@agentic-trust/core/dist/server/singletons/identityClient.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@agentic-trust/core/dist/server/singletons/reputationClient.js":
/*!*****************************************************************************************!*\
  !*** ../../node_modules/@agentic-trust/core/dist/server/singletons/reputationClient.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getReputationRegistryClient: () => (/* binding */ getReputationRegistryClient),\n/* harmony export */   isReputationClientInitialized: () => (/* binding */ isReputationClientInitialized),\n/* harmony export */   resetReputationClient: () => (/* binding */ resetReputationClient)\n/* harmony export */ });\n/* harmony import */ var _agentic_trust_8004_ext_sdk__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @agentic-trust/8004-ext-sdk */ \"(rsc)/../../node_modules/@agentic-trust/8004-ext-sdk/dist/index.js\");\n/* harmony import */ var _lib_chainConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/chainConfig */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/lib/chainConfig.js\");\n/* harmony import */ var _domainClient__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./domainClient */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/singletons/domainClient.js\");\n/* harmony import */ var _domainAccountProviders__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./domainAccountProviders */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/singletons/domainAccountProviders.js\");\n/**\n * Reputation Client Singleton\n *\n * Manages a singleton instance of AIAgentReputationClient\n * Initialized from session package or environment variables\n */\n\n\n\n\nclass ReputationDomainClient extends _domainClient__WEBPACK_IMPORTED_MODULE_2__.DomainClient {\n    constructor() {\n        super('reputation');\n    }\n    async buildClient(targetChainId, initArg) {\n        const identityRegistry = (0,_lib_chainConfig__WEBPACK_IMPORTED_MODULE_1__.requireChainEnvVar)('AGENTIC_TRUST_IDENTITY_REGISTRY', targetChainId);\n        const reputationRegistry = (0,_lib_chainConfig__WEBPACK_IMPORTED_MODULE_1__.requireChainEnvVar)('AGENTIC_TRUST_REPUTATION_REGISTRY', targetChainId);\n        const ensRegistry = (0,_lib_chainConfig__WEBPACK_IMPORTED_MODULE_1__.getChainEnvVar)('AGENTIC_TRUST_ENS_REGISTRY', targetChainId);\n        const rpcUrl = (0,_lib_chainConfig__WEBPACK_IMPORTED_MODULE_1__.requireChainEnvVar)('AGENTIC_TRUST_RPC_URL', targetChainId);\n        const init = (initArg || {});\n        const userApps = init.userApps ?? (await (0,_domainAccountProviders__WEBPACK_IMPORTED_MODULE_3__.resolveDomainUserApps)());\n        const accountProvider = await (0,_domainAccountProviders__WEBPACK_IMPORTED_MODULE_3__.resolveReputationAccountProvider)(targetChainId, rpcUrl, userApps);\n        const reputationClient = await _agentic_trust_8004_ext_sdk__WEBPACK_IMPORTED_MODULE_0__.AIAgentReputationClient.create(accountProvider, identityRegistry, reputationRegistry, (ensRegistry || '0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e'));\n        return reputationClient;\n    }\n}\nconst reputationDomainClient = new ReputationDomainClient();\n/**\n * Get or create the AIAgentReputationClient singleton\n * Initializes from session package if available, otherwise uses environment variables\n */\nasync function getReputationRegistryClient(chainId) {\n    // Default to configured chain if no chainId provided\n    const targetChainId = chainId || _lib_chainConfig__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_CHAIN_ID;\n    return reputationDomainClient.get(targetChainId);\n}\n/**\n * Check if reputation client is initialized for a specific chain\n */\nfunction isReputationClientInitialized(chainId) {\n    const targetChainId = chainId || _lib_chainConfig__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_CHAIN_ID;\n    return reputationDomainClient.isInitialized(targetChainId);\n}\n/**\n * Reset the reputation client instance for a specific chain (useful for testing)\n */\nfunction resetReputationClient(chainId) {\n    const targetChainId = chainId || _lib_chainConfig__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_CHAIN_ID;\n    reputationDomainClient.reset(targetChainId);\n}\n//# sourceMappingURL=reputationClient.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BhZ2VudGljLXRydXN0L2NvcmUvZGlzdC9zZXJ2ZXIvc2luZ2xldG9ucy9yZXB1dGF0aW9uQ2xpZW50LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDc0U7QUFDb0I7QUFDNUM7QUFDcUQ7QUFDbkcscUNBQXFDLHVEQUFZO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLG9FQUFrQjtBQUNuRCxtQ0FBbUMsb0VBQWtCO0FBQ3JELDRCQUE0QixnRUFBYztBQUMxQyx1QkFBdUIsb0VBQWtCO0FBQ3pDLG1DQUFtQztBQUNuQyxpREFBaUQsOEVBQXFCO0FBQ3RFLHNDQUFzQyx5RkFBZ0M7QUFDdEUsdUNBQXVDLGdGQUF1QjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLHFDQUFxQyw4REFBZ0I7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AscUNBQXFDLDhEQUFnQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxxQ0FBcUMsOERBQWdCO0FBQ3JEO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvYmFyYi9hYS9Bc3NvY2lhdGVkQWNjb3VudHMvbm9kZV9tb2R1bGVzL0BhZ2VudGljLXRydXN0L2NvcmUvZGlzdC9zZXJ2ZXIvc2luZ2xldG9ucy9yZXB1dGF0aW9uQ2xpZW50LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogUmVwdXRhdGlvbiBDbGllbnQgU2luZ2xldG9uXG4gKlxuICogTWFuYWdlcyBhIHNpbmdsZXRvbiBpbnN0YW5jZSBvZiBBSUFnZW50UmVwdXRhdGlvbkNsaWVudFxuICogSW5pdGlhbGl6ZWQgZnJvbSBzZXNzaW9uIHBhY2thZ2Ugb3IgZW52aXJvbm1lbnQgdmFyaWFibGVzXG4gKi9cbmltcG9ydCB7IEFJQWdlbnRSZXB1dGF0aW9uQ2xpZW50IH0gZnJvbSAnQGFnZW50aWMtdHJ1c3QvODAwNC1leHQtc2RrJztcbmltcG9ydCB7IGdldENoYWluRW52VmFyLCByZXF1aXJlQ2hhaW5FbnZWYXIsIERFRkFVTFRfQ0hBSU5fSUQgfSBmcm9tICcuLi9saWIvY2hhaW5Db25maWcnO1xuaW1wb3J0IHsgRG9tYWluQ2xpZW50IH0gZnJvbSAnLi9kb21haW5DbGllbnQnO1xuaW1wb3J0IHsgcmVzb2x2ZURvbWFpblVzZXJBcHBzLCByZXNvbHZlUmVwdXRhdGlvbkFjY291bnRQcm92aWRlciB9IGZyb20gJy4vZG9tYWluQWNjb3VudFByb3ZpZGVycyc7XG5jbGFzcyBSZXB1dGF0aW9uRG9tYWluQ2xpZW50IGV4dGVuZHMgRG9tYWluQ2xpZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoJ3JlcHV0YXRpb24nKTtcbiAgICB9XG4gICAgYXN5bmMgYnVpbGRDbGllbnQodGFyZ2V0Q2hhaW5JZCwgaW5pdEFyZykge1xuICAgICAgICBjb25zdCBpZGVudGl0eVJlZ2lzdHJ5ID0gcmVxdWlyZUNoYWluRW52VmFyKCdBR0VOVElDX1RSVVNUX0lERU5USVRZX1JFR0lTVFJZJywgdGFyZ2V0Q2hhaW5JZCk7XG4gICAgICAgIGNvbnN0IHJlcHV0YXRpb25SZWdpc3RyeSA9IHJlcXVpcmVDaGFpbkVudlZhcignQUdFTlRJQ19UUlVTVF9SRVBVVEFUSU9OX1JFR0lTVFJZJywgdGFyZ2V0Q2hhaW5JZCk7XG4gICAgICAgIGNvbnN0IGVuc1JlZ2lzdHJ5ID0gZ2V0Q2hhaW5FbnZWYXIoJ0FHRU5USUNfVFJVU1RfRU5TX1JFR0lTVFJZJywgdGFyZ2V0Q2hhaW5JZCk7XG4gICAgICAgIGNvbnN0IHJwY1VybCA9IHJlcXVpcmVDaGFpbkVudlZhcignQUdFTlRJQ19UUlVTVF9SUENfVVJMJywgdGFyZ2V0Q2hhaW5JZCk7XG4gICAgICAgIGNvbnN0IGluaXQgPSAoaW5pdEFyZyB8fCB7fSk7XG4gICAgICAgIGNvbnN0IHVzZXJBcHBzID0gaW5pdC51c2VyQXBwcyA/PyAoYXdhaXQgcmVzb2x2ZURvbWFpblVzZXJBcHBzKCkpO1xuICAgICAgICBjb25zdCBhY2NvdW50UHJvdmlkZXIgPSBhd2FpdCByZXNvbHZlUmVwdXRhdGlvbkFjY291bnRQcm92aWRlcih0YXJnZXRDaGFpbklkLCBycGNVcmwsIHVzZXJBcHBzKTtcbiAgICAgICAgY29uc3QgcmVwdXRhdGlvbkNsaWVudCA9IGF3YWl0IEFJQWdlbnRSZXB1dGF0aW9uQ2xpZW50LmNyZWF0ZShhY2NvdW50UHJvdmlkZXIsIGlkZW50aXR5UmVnaXN0cnksIHJlcHV0YXRpb25SZWdpc3RyeSwgKGVuc1JlZ2lzdHJ5IHx8ICcweDAwMDAwMDAwMDAwQzJFMDc0ZUM2OUEwZEZiMjk5N0JBNkM3ZDJlMWUnKSk7XG4gICAgICAgIHJldHVybiByZXB1dGF0aW9uQ2xpZW50O1xuICAgIH1cbn1cbmNvbnN0IHJlcHV0YXRpb25Eb21haW5DbGllbnQgPSBuZXcgUmVwdXRhdGlvbkRvbWFpbkNsaWVudCgpO1xuLyoqXG4gKiBHZXQgb3IgY3JlYXRlIHRoZSBBSUFnZW50UmVwdXRhdGlvbkNsaWVudCBzaW5nbGV0b25cbiAqIEluaXRpYWxpemVzIGZyb20gc2Vzc2lvbiBwYWNrYWdlIGlmIGF2YWlsYWJsZSwgb3RoZXJ3aXNlIHVzZXMgZW52aXJvbm1lbnQgdmFyaWFibGVzXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRSZXB1dGF0aW9uUmVnaXN0cnlDbGllbnQoY2hhaW5JZCkge1xuICAgIC8vIERlZmF1bHQgdG8gY29uZmlndXJlZCBjaGFpbiBpZiBubyBjaGFpbklkIHByb3ZpZGVkXG4gICAgY29uc3QgdGFyZ2V0Q2hhaW5JZCA9IGNoYWluSWQgfHwgREVGQVVMVF9DSEFJTl9JRDtcbiAgICByZXR1cm4gcmVwdXRhdGlvbkRvbWFpbkNsaWVudC5nZXQodGFyZ2V0Q2hhaW5JZCk7XG59XG4vKipcbiAqIENoZWNrIGlmIHJlcHV0YXRpb24gY2xpZW50IGlzIGluaXRpYWxpemVkIGZvciBhIHNwZWNpZmljIGNoYWluXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1JlcHV0YXRpb25DbGllbnRJbml0aWFsaXplZChjaGFpbklkKSB7XG4gICAgY29uc3QgdGFyZ2V0Q2hhaW5JZCA9IGNoYWluSWQgfHwgREVGQVVMVF9DSEFJTl9JRDtcbiAgICByZXR1cm4gcmVwdXRhdGlvbkRvbWFpbkNsaWVudC5pc0luaXRpYWxpemVkKHRhcmdldENoYWluSWQpO1xufVxuLyoqXG4gKiBSZXNldCB0aGUgcmVwdXRhdGlvbiBjbGllbnQgaW5zdGFuY2UgZm9yIGEgc3BlY2lmaWMgY2hhaW4gKHVzZWZ1bCBmb3IgdGVzdGluZylcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlc2V0UmVwdXRhdGlvbkNsaWVudChjaGFpbklkKSB7XG4gICAgY29uc3QgdGFyZ2V0Q2hhaW5JZCA9IGNoYWluSWQgfHwgREVGQVVMVF9DSEFJTl9JRDtcbiAgICByZXB1dGF0aW9uRG9tYWluQ2xpZW50LnJlc2V0KHRhcmdldENoYWluSWQpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVwdXRhdGlvbkNsaWVudC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@agentic-trust/core/dist/server/singletons/reputationClient.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@agentic-trust/core/dist/server/singletons/validationClient.js":
/*!*****************************************************************************************!*\
  !*** ../../node_modules/@agentic-trust/core/dist/server/singletons/validationClient.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getValidationRegistryClient: () => (/* binding */ getValidationRegistryClient),\n/* harmony export */   isValidationClientInitialized: () => (/* binding */ isValidationClientInitialized),\n/* harmony export */   resetValidationClient: () => (/* binding */ resetValidationClient)\n/* harmony export */ });\n/* harmony import */ var _agentic_trust_8004_ext_sdk__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @agentic-trust/8004-ext-sdk */ \"(rsc)/../../node_modules/@agentic-trust/8004-ext-sdk/dist/index.js\");\n/* harmony import */ var _lib_chainConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/chainConfig */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/lib/chainConfig.js\");\n/* harmony import */ var _domainClient__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./domainClient */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/singletons/domainClient.js\");\n/* harmony import */ var _domainAccountProviders__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./domainAccountProviders */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/singletons/domainAccountProviders.js\");\n/**\n * Validation Client Singleton\n *\n * Manages a singleton instance of AIAgentValidationClient\n * Initialized from environment variables and domain AccountProvider\n */\n\n\n\n\nclass ValidationDomainClient extends _domainClient__WEBPACK_IMPORTED_MODULE_2__.DomainClient {\n    constructor() {\n        super('validation');\n    }\n    async buildClient(targetChainId, initArg) {\n        const validationRegistry = (0,_lib_chainConfig__WEBPACK_IMPORTED_MODULE_1__.requireChainEnvVar)('AGENTIC_TRUST_VALIDATION_REGISTRY', targetChainId);\n        const rpcUrl = (0,_lib_chainConfig__WEBPACK_IMPORTED_MODULE_1__.requireChainEnvVar)('AGENTIC_TRUST_RPC_URL', targetChainId);\n        const init = (initArg || {});\n        const userApps = init.userApps ?? (await (0,_domainAccountProviders__WEBPACK_IMPORTED_MODULE_3__.resolveDomainUserApps)());\n        const accountProvider = await (0,_domainAccountProviders__WEBPACK_IMPORTED_MODULE_3__.resolveValidationAccountProvider)(targetChainId, rpcUrl, userApps);\n        const validationClient = await _agentic_trust_8004_ext_sdk__WEBPACK_IMPORTED_MODULE_0__.AIAgentValidationClient.create(accountProvider, validationRegistry);\n        return validationClient;\n    }\n}\nconst validationDomainClient = new ValidationDomainClient();\nasync function getValidationRegistryClient(chainId) {\n    const targetChainId = chainId || _lib_chainConfig__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_CHAIN_ID;\n    return validationDomainClient.get(targetChainId);\n}\nfunction isValidationClientInitialized(chainId) {\n    const targetChainId = chainId || _lib_chainConfig__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_CHAIN_ID;\n    return validationDomainClient.isInitialized(targetChainId);\n}\nfunction resetValidationClient(chainId) {\n    const targetChainId = chainId || _lib_chainConfig__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_CHAIN_ID;\n    validationDomainClient.reset(targetChainId);\n}\n//# sourceMappingURL=validationClient.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BhZ2VudGljLXRydXN0L2NvcmUvZGlzdC9zZXJ2ZXIvc2luZ2xldG9ucy92YWxpZGF0aW9uQ2xpZW50LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDc0U7QUFDSTtBQUM1QjtBQUNzRDtBQUNwRyxxQ0FBcUMsdURBQVk7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsb0VBQWtCO0FBQ3JELHVCQUF1QixvRUFBa0I7QUFDekMsbUNBQW1DO0FBQ25DLGlEQUFpRCw4RUFBcUI7QUFDdEUsc0NBQXNDLHlGQUFnQztBQUN0RSx1Q0FBdUMsZ0ZBQXVCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxxQ0FBcUMsOERBQWdCO0FBQ3JEO0FBQ0E7QUFDTztBQUNQLHFDQUFxQyw4REFBZ0I7QUFDckQ7QUFDQTtBQUNPO0FBQ1AscUNBQXFDLDhEQUFnQjtBQUNyRDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL2JhcmIvYWEvQXNzb2NpYXRlZEFjY291bnRzL25vZGVfbW9kdWxlcy9AYWdlbnRpYy10cnVzdC9jb3JlL2Rpc3Qvc2VydmVyL3NpbmdsZXRvbnMvdmFsaWRhdGlvbkNsaWVudC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFZhbGlkYXRpb24gQ2xpZW50IFNpbmdsZXRvblxuICpcbiAqIE1hbmFnZXMgYSBzaW5nbGV0b24gaW5zdGFuY2Ugb2YgQUlBZ2VudFZhbGlkYXRpb25DbGllbnRcbiAqIEluaXRpYWxpemVkIGZyb20gZW52aXJvbm1lbnQgdmFyaWFibGVzIGFuZCBkb21haW4gQWNjb3VudFByb3ZpZGVyXG4gKi9cbmltcG9ydCB7IEFJQWdlbnRWYWxpZGF0aW9uQ2xpZW50IH0gZnJvbSAnQGFnZW50aWMtdHJ1c3QvODAwNC1leHQtc2RrJztcbmltcG9ydCB7IHJlcXVpcmVDaGFpbkVudlZhciwgREVGQVVMVF9DSEFJTl9JRCB9IGZyb20gJy4uL2xpYi9jaGFpbkNvbmZpZyc7XG5pbXBvcnQgeyBEb21haW5DbGllbnQgfSBmcm9tICcuL2RvbWFpbkNsaWVudCc7XG5pbXBvcnQgeyByZXNvbHZlRG9tYWluVXNlckFwcHMsIHJlc29sdmVWYWxpZGF0aW9uQWNjb3VudFByb3ZpZGVyLCB9IGZyb20gJy4vZG9tYWluQWNjb3VudFByb3ZpZGVycyc7XG5jbGFzcyBWYWxpZGF0aW9uRG9tYWluQ2xpZW50IGV4dGVuZHMgRG9tYWluQ2xpZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoJ3ZhbGlkYXRpb24nKTtcbiAgICB9XG4gICAgYXN5bmMgYnVpbGRDbGllbnQodGFyZ2V0Q2hhaW5JZCwgaW5pdEFyZykge1xuICAgICAgICBjb25zdCB2YWxpZGF0aW9uUmVnaXN0cnkgPSByZXF1aXJlQ2hhaW5FbnZWYXIoJ0FHRU5USUNfVFJVU1RfVkFMSURBVElPTl9SRUdJU1RSWScsIHRhcmdldENoYWluSWQpO1xuICAgICAgICBjb25zdCBycGNVcmwgPSByZXF1aXJlQ2hhaW5FbnZWYXIoJ0FHRU5USUNfVFJVU1RfUlBDX1VSTCcsIHRhcmdldENoYWluSWQpO1xuICAgICAgICBjb25zdCBpbml0ID0gKGluaXRBcmcgfHwge30pO1xuICAgICAgICBjb25zdCB1c2VyQXBwcyA9IGluaXQudXNlckFwcHMgPz8gKGF3YWl0IHJlc29sdmVEb21haW5Vc2VyQXBwcygpKTtcbiAgICAgICAgY29uc3QgYWNjb3VudFByb3ZpZGVyID0gYXdhaXQgcmVzb2x2ZVZhbGlkYXRpb25BY2NvdW50UHJvdmlkZXIodGFyZ2V0Q2hhaW5JZCwgcnBjVXJsLCB1c2VyQXBwcyk7XG4gICAgICAgIGNvbnN0IHZhbGlkYXRpb25DbGllbnQgPSBhd2FpdCBBSUFnZW50VmFsaWRhdGlvbkNsaWVudC5jcmVhdGUoYWNjb3VudFByb3ZpZGVyLCB2YWxpZGF0aW9uUmVnaXN0cnkpO1xuICAgICAgICByZXR1cm4gdmFsaWRhdGlvbkNsaWVudDtcbiAgICB9XG59XG5jb25zdCB2YWxpZGF0aW9uRG9tYWluQ2xpZW50ID0gbmV3IFZhbGlkYXRpb25Eb21haW5DbGllbnQoKTtcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRWYWxpZGF0aW9uUmVnaXN0cnlDbGllbnQoY2hhaW5JZCkge1xuICAgIGNvbnN0IHRhcmdldENoYWluSWQgPSBjaGFpbklkIHx8IERFRkFVTFRfQ0hBSU5fSUQ7XG4gICAgcmV0dXJuIHZhbGlkYXRpb25Eb21haW5DbGllbnQuZ2V0KHRhcmdldENoYWluSWQpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzVmFsaWRhdGlvbkNsaWVudEluaXRpYWxpemVkKGNoYWluSWQpIHtcbiAgICBjb25zdCB0YXJnZXRDaGFpbklkID0gY2hhaW5JZCB8fCBERUZBVUxUX0NIQUlOX0lEO1xuICAgIHJldHVybiB2YWxpZGF0aW9uRG9tYWluQ2xpZW50LmlzSW5pdGlhbGl6ZWQodGFyZ2V0Q2hhaW5JZCk7XG59XG5leHBvcnQgZnVuY3Rpb24gcmVzZXRWYWxpZGF0aW9uQ2xpZW50KGNoYWluSWQpIHtcbiAgICBjb25zdCB0YXJnZXRDaGFpbklkID0gY2hhaW5JZCB8fCBERUZBVUxUX0NIQUlOX0lEO1xuICAgIHZhbGlkYXRpb25Eb21haW5DbGllbnQucmVzZXQodGFyZ2V0Q2hhaW5JZCk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD12YWxpZGF0aW9uQ2xpZW50LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@agentic-trust/core/dist/server/singletons/validationClient.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@agentic-trust/core/dist/server/userApps/adminApp.js":
/*!*******************************************************************************!*\
  !*** ../../node_modules/@agentic-trust/core/dist/server/userApps/adminApp.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getAdminAddress: () => (/* binding */ getAdminAddress),\n/* harmony export */   getAdminApp: () => (/* binding */ getAdminApp),\n/* harmony export */   hasAdminPrivateKey: () => (/* binding */ hasAdminPrivateKey),\n/* harmony export */   isAdminAppInitialized: () => (/* binding */ isAdminAppInitialized),\n/* harmony export */   resetAdminApp: () => (/* binding */ resetAdminApp)\n/* harmony export */ });\n/* harmony import */ var _agentic_trust_8004_sdk__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @agentic-trust/8004-sdk */ \"(rsc)/../../node_modules/@agentic-trust/8004-sdk/dist/index.js\");\n/* harmony import */ var _lib_chainConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/chainConfig */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/lib/chainConfig.js\");\n/* harmony import */ var _userApp__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./userApp */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/userApps/userApp.js\");\n/**\n * Admin App Singleton\n *\n * Manages a singleton instance for admin-side operations using private key\n * Provides access to admin account, wallet client, and admin adapter for agent administration\n */\n\n\n\n// Singleton instance (per private key)\n// Note: We use a Map to support multiple private keys (different users)\n// The key is the private key hash or address to ensure uniqueness\nconst adminAppInstances = new Map();\nconst initializationPromises = new Map();\n/**\n * Check if the dedicated admin private key is configured in environment.\n *\n * This checks AGENTIC_TRUST_ADMIN_PRIVATE_KEY only. It does not consider\n * session-provided keys or AGENTIC_TRUST_ADMIN_PRIVATE_KEY.\n */\nfunction hasAdminPrivateKey() {\n    const value = process.env.AGENTIC_TRUST_ADMIN_PRIVATE_KEY;\n    return typeof value === 'string' && value.trim().length > 0;\n}\n/**\n * Get or create the AdminApp instance for a specific private key\n * Initializes from private key in cookies (Web3Auth/wallet) or environment variables\n *\n * @param privateKey - Optional private key. If not provided, will try cookies then env vars\n */\nasync function getAdminApp(privateKey, chainId = _lib_chainConfig__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_CHAIN_ID) {\n    // Resolve the private key first\n    let resolvedPrivateKey = privateKey;\n    let walletAddress;\n    if (!resolvedPrivateKey) {\n        // Try to get private key from session first (for Web3Auth/wallet), then fall back to environment variable\n        // Only try Next.js cookies if we're in a Next.js environment\n        try {\n            // Dynamically try to import next/headers (only available in Next.js apps)\n            // This is wrapped in try/catch because core package doesn't have next as a dependency\n            // @ts-ignore - next/headers is not available in core package, only in Next.js apps\n            const nextHeaders = await __webpack_require__.e(/*! import() */ \"vendor-chunks/next\").then(__webpack_require__.bind(__webpack_require__, /*! next/headers */ \"(rsc)/../../node_modules/next/dist/api/headers.js\")).catch(() => null);\n            if (nextHeaders && nextHeaders.cookies) {\n                const cookieStore = await nextHeaders.cookies();\n                resolvedPrivateKey = cookieStore.get('admin_private_key')?.value;\n            }\n        }\n        catch (error) {\n            // If cookies() fails (e.g., not in Next.js context), fall back to environment variable\n            // This is expected in non-Next.js contexts\n        }\n        // Fall back to environment variable if no session key\n        if (!resolvedPrivateKey) {\n            // Check environment variables directly\n            const envPrivateKey = process.env.AGENTIC_TRUST_ADMIN_PRIVATE_KEY;\n            resolvedPrivateKey = envPrivateKey;\n        }\n    }\n    // Check if we have a wallet address from MetaMask (no private key available)\n    if (!resolvedPrivateKey) {\n        // Try to get wallet address from session (for MetaMask)\n        try {\n            // @ts-ignore - next/headers is not available in core package, only in Next.js apps\n            const nextHeaders = await __webpack_require__.e(/*! import() */ \"vendor-chunks/next\").then(__webpack_require__.bind(__webpack_require__, /*! next/headers */ \"(rsc)/../../node_modules/next/dist/api/headers.js\")).catch(() => null);\n            if (nextHeaders && nextHeaders.cookies) {\n                const cookieStore = await nextHeaders.cookies();\n                walletAddress = cookieStore.get('wallet_address')?.value;\n            }\n        }\n        catch (error) {\n            // Ignore errors\n        }\n        // If we have neither private key nor wallet address, throw error\n        if (!walletAddress && !resolvedPrivateKey) {\n            throw new Error('Missing required: Set AGENTIC_TRUST_ADMIN_PRIVATE_KEY environment variable, authenticate via Web3Auth social login (provides private key), or connect via wallet (MetaMask/Web3Auth).\\n\\n' +\n                'Note:\\n' +\n                '  - Web3Auth social login (Google, Facebook, etc.)  provides private key  full server-side operations \\n' +\n                '  - Web3Auth/MetaMask wallet provider  no private key  read-only operations (prepare transactions) \\n' +\n                '  - For wallet providers, implement client-side signing to complete transactions');\n        }\n        // If we have wallet address but no private key, we can still do read-only operations\n        // (prepare transactions, encode calldata, etc.) but not sign/send transactions\n        // This is handled by checking hasPrivateKey before attempting to sign\n    }\n    // Determine instance key - use wallet address if available, otherwise use private key address\n    let instanceKeyBase;\n    let resolvedAddress;\n    if (resolvedPrivateKey) {\n        // Use private key to derive address\n        const { privateKeyToAccount } = await Promise.all(/*! import() */[__webpack_require__.e(\"vendor-chunks/viem\"), __webpack_require__.e(\"vendor-chunks/@noble\")]).then(__webpack_require__.bind(__webpack_require__, /*! viem/accounts */ \"(rsc)/../../node_modules/viem/_esm/accounts/index.js\"));\n        const normalizedKey = resolvedPrivateKey.startsWith('0x') ? resolvedPrivateKey : `0x${resolvedPrivateKey}`;\n        const tempAccount = privateKeyToAccount(normalizedKey);\n        instanceKeyBase = tempAccount.address.toLowerCase();\n        resolvedAddress = tempAccount.address;\n    }\n    else if (walletAddress) {\n        // Use wallet address directly (for read-only operations)\n        instanceKeyBase = walletAddress.toLowerCase();\n        resolvedAddress = walletAddress;\n    }\n    else {\n        throw new Error('Either private key or wallet address is required');\n    }\n    const instanceKey = `${instanceKeyBase}:${chainId}`;\n    // If already initialized for this key, return immediately\n    const existingInstance = adminAppInstances.get(instanceKey);\n    if (existingInstance) {\n        return existingInstance;\n    }\n    // If initialization is in progress for this key, wait for it\n    const existingPromise = initializationPromises.get(instanceKey);\n    if (existingPromise) {\n        return existingPromise;\n    }\n    // Start initialization for this specific private key\n    const initializationPromise = (async () => {\n        try {\n            // Check if this is an admin app (environment flag)\n            if (!(0,_userApp__WEBPACK_IMPORTED_MODULE_2__.isUserAppEnabled)('admin')) {\n                throw new Error('AdminApp is only available when AGENTIC_TRUST_APP_ROLES includes \"admin\"');\n            }\n            (0,_userApp__WEBPACK_IMPORTED_MODULE_2__.logUserAppInitStart)('admin', `chainId=${chainId}`);\n            // Get chain-specific RPC URL and chain config\n            const targetChainId = chainId || _lib_chainConfig__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_CHAIN_ID;\n            const rpcUrl = (0,_lib_chainConfig__WEBPACK_IMPORTED_MODULE_1__.getChainRpcUrl)(targetChainId);\n            if (!rpcUrl) {\n                throw new Error(`Missing required RPC URL. Configure AGENTIC_TRUST_RPC_URL_{CHAIN} for chainId ${targetChainId}`);\n            }\n            const { createPublicClient, createWalletClient, http: httpTransport } = await Promise.all(/*! import() */[__webpack_require__.e(\"vendor-chunks/viem\"), __webpack_require__.e(\"vendor-chunks/abitype\")]).then(__webpack_require__.bind(__webpack_require__, /*! viem */ \"(rsc)/../../node_modules/viem/_esm/index.js\"));\n            const chain = (0,_lib_chainConfig__WEBPACK_IMPORTED_MODULE_1__.getChainById)(targetChainId);\n            // Create public client (always needed)\n            const publicClient = createPublicClient({\n                chain,\n                transport: httpTransport(rpcUrl),\n            });\n            let account;\n            let walletClient;\n            let address;\n            // hasPrivateKey reflects strictly whether the dedicated admin private\n            // key env var is present, not whether a session/cookie key exists.\n            const hasPrivateKey = hasAdminPrivateKey();\n            if (resolvedPrivateKey) {\n                // Create wallet client and account from private key\n                const { privateKeyToAccount } = await Promise.all(/*! import() */[__webpack_require__.e(\"vendor-chunks/viem\"), __webpack_require__.e(\"vendor-chunks/@noble\")]).then(__webpack_require__.bind(__webpack_require__, /*! viem/accounts */ \"(rsc)/../../node_modules/viem/_esm/accounts/index.js\"));\n                const normalizedKey = resolvedPrivateKey.startsWith('0x') ? resolvedPrivateKey : `0x${resolvedPrivateKey}`;\n                account = privateKeyToAccount(normalizedKey);\n                address = account.address;\n                walletClient = createWalletClient({\n                    account,\n                    chain,\n                    transport: httpTransport(rpcUrl),\n                });\n            }\n            else {\n                // Read-only mode - use wallet address\n                address = resolvedAddress;\n            }\n            // Create AccountProvider - walletClient is optional (null for read-only)\n            const accountProvider = new _agentic_trust_8004_sdk__WEBPACK_IMPORTED_MODULE_0__.ViemAccountProvider({\n                publicClient,\n                walletClient: walletClient ?? null,\n                account: account ?? undefined,\n                chainConfig: {\n                    id: chain.id,\n                    rpcUrl,\n                    name: chain.name,\n                    chain,\n                },\n            });\n            const instance = {\n                account,\n                publicClient: publicClient,\n                walletClient: walletClient,\n                accountProvider,\n                address,\n                hasPrivateKey,\n            };\n            // Store instance by address key\n            adminAppInstances.set(instanceKey, instance);\n            initializationPromises.delete(instanceKey); // Remove from pending\n            (0,_userApp__WEBPACK_IMPORTED_MODULE_2__.logUserAppInitSuccess)('admin', address);\n            return instance;\n        }\n        catch (error) {\n            (0,_userApp__WEBPACK_IMPORTED_MODULE_2__.logUserAppInitFailure)('admin', error);\n            initializationPromises.delete(instanceKey); // Remove from pending on error\n            throw error;\n        }\n    })();\n    // Store promise for this key\n    initializationPromises.set(instanceKey, initializationPromise);\n    return initializationPromise;\n}\n/**\n * Get the admin address (convenience method)\n */\nasync function getAdminAddress() {\n    const adminApp = await getAdminApp(undefined, _lib_chainConfig__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_CHAIN_ID);\n    return adminApp?.address ?? '0x';\n}\n/**\n * Check if admin app is initialized for a specific address\n */\nfunction isAdminAppInitialized(address) {\n    if (address) {\n        const keyPrefix = `${address.toLowerCase()}:`;\n        for (const key of adminAppInstances.keys()) {\n            if (key.startsWith(keyPrefix)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    return adminAppInstances.size > 0;\n}\n/**\n * Reset admin app instances (useful for testing)\n * @param address - Optional address to reset specific instance, or all if not provided\n */\nfunction resetAdminApp(address) {\n    if (address) {\n        const keyPrefix = `${address.toLowerCase()}:`;\n        for (const key of Array.from(adminAppInstances.keys())) {\n            if (key.startsWith(keyPrefix)) {\n                adminAppInstances.delete(key);\n                initializationPromises.delete(key);\n            }\n        }\n    }\n    else {\n        adminAppInstances.clear();\n        initializationPromises.clear();\n    }\n}\n//# sourceMappingURL=adminApp.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BhZ2VudGljLXRydXN0L2NvcmUvZGlzdC9zZXJ2ZXIvdXNlckFwcHMvYWRtaW5BcHAuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDOEQ7QUFDc0I7QUFDNEI7QUFDaEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08saURBQWlELDhEQUFnQjtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyx3TEFBc0I7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLHdMQUFzQjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixzQkFBc0IsUUFBUSx5UEFBdUI7QUFDckUsOEZBQThGLG1CQUFtQjtBQUNqSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsZ0JBQWdCLEdBQUcsUUFBUTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDBEQUFnQjtBQUNqQztBQUNBO0FBQ0EsWUFBWSw2REFBbUIscUJBQXFCLFFBQVE7QUFDNUQ7QUFDQSw2Q0FBNkMsOERBQWdCO0FBQzdELDJCQUEyQixnRUFBYztBQUN6QztBQUNBLDRGQUE0RixPQUFPLGNBQWMsY0FBYztBQUMvSDtBQUNBLG9CQUFvQiw4REFBOEQsUUFBUSx3T0FBYztBQUN4RywwQkFBMEIsOERBQVk7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixzQkFBc0IsUUFBUSx5UEFBdUI7QUFDN0Usc0dBQXNHLG1CQUFtQjtBQUN6SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLHdFQUFtQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RCxZQUFZLCtEQUFxQjtBQUNqQztBQUNBO0FBQ0E7QUFDQSxZQUFZLCtEQUFxQjtBQUNqQyx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1Asa0RBQWtELDhEQUFnQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLDZCQUE2QixzQkFBc0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsNkJBQTZCLHNCQUFzQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvYmFyYi9hYS9Bc3NvY2lhdGVkQWNjb3VudHMvbm9kZV9tb2R1bGVzL0BhZ2VudGljLXRydXN0L2NvcmUvZGlzdC9zZXJ2ZXIvdXNlckFwcHMvYWRtaW5BcHAuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBBZG1pbiBBcHAgU2luZ2xldG9uXG4gKlxuICogTWFuYWdlcyBhIHNpbmdsZXRvbiBpbnN0YW5jZSBmb3IgYWRtaW4tc2lkZSBvcGVyYXRpb25zIHVzaW5nIHByaXZhdGUga2V5XG4gKiBQcm92aWRlcyBhY2Nlc3MgdG8gYWRtaW4gYWNjb3VudCwgd2FsbGV0IGNsaWVudCwgYW5kIGFkbWluIGFkYXB0ZXIgZm9yIGFnZW50IGFkbWluaXN0cmF0aW9uXG4gKi9cbmltcG9ydCB7IFZpZW1BY2NvdW50UHJvdmlkZXIgfSBmcm9tICdAYWdlbnRpYy10cnVzdC84MDA0LXNkayc7XG5pbXBvcnQgeyBnZXRDaGFpbkJ5SWQsIGdldENoYWluUnBjVXJsLCBERUZBVUxUX0NIQUlOX0lEIH0gZnJvbSAnLi4vbGliL2NoYWluQ29uZmlnJztcbmltcG9ydCB7IGlzVXNlckFwcEVuYWJsZWQsIGxvZ1VzZXJBcHBJbml0RmFpbHVyZSwgbG9nVXNlckFwcEluaXRTdGFydCwgbG9nVXNlckFwcEluaXRTdWNjZXNzIH0gZnJvbSAnLi91c2VyQXBwJztcbi8vIFNpbmdsZXRvbiBpbnN0YW5jZSAocGVyIHByaXZhdGUga2V5KVxuLy8gTm90ZTogV2UgdXNlIGEgTWFwIHRvIHN1cHBvcnQgbXVsdGlwbGUgcHJpdmF0ZSBrZXlzIChkaWZmZXJlbnQgdXNlcnMpXG4vLyBUaGUga2V5IGlzIHRoZSBwcml2YXRlIGtleSBoYXNoIG9yIGFkZHJlc3MgdG8gZW5zdXJlIHVuaXF1ZW5lc3NcbmNvbnN0IGFkbWluQXBwSW5zdGFuY2VzID0gbmV3IE1hcCgpO1xuY29uc3QgaW5pdGlhbGl6YXRpb25Qcm9taXNlcyA9IG5ldyBNYXAoKTtcbi8qKlxuICogQ2hlY2sgaWYgdGhlIGRlZGljYXRlZCBhZG1pbiBwcml2YXRlIGtleSBpcyBjb25maWd1cmVkIGluIGVudmlyb25tZW50LlxuICpcbiAqIFRoaXMgY2hlY2tzIEFHRU5USUNfVFJVU1RfQURNSU5fUFJJVkFURV9LRVkgb25seS4gSXQgZG9lcyBub3QgY29uc2lkZXJcbiAqIHNlc3Npb24tcHJvdmlkZWQga2V5cyBvciBBR0VOVElDX1RSVVNUX0FETUlOX1BSSVZBVEVfS0VZLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaGFzQWRtaW5Qcml2YXRlS2V5KCkge1xuICAgIGNvbnN0IHZhbHVlID0gcHJvY2Vzcy5lbnYuQUdFTlRJQ19UUlVTVF9BRE1JTl9QUklWQVRFX0tFWTtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiB2YWx1ZS50cmltKCkubGVuZ3RoID4gMDtcbn1cbi8qKlxuICogR2V0IG9yIGNyZWF0ZSB0aGUgQWRtaW5BcHAgaW5zdGFuY2UgZm9yIGEgc3BlY2lmaWMgcHJpdmF0ZSBrZXlcbiAqIEluaXRpYWxpemVzIGZyb20gcHJpdmF0ZSBrZXkgaW4gY29va2llcyAoV2ViM0F1dGgvd2FsbGV0KSBvciBlbnZpcm9ubWVudCB2YXJpYWJsZXNcbiAqXG4gKiBAcGFyYW0gcHJpdmF0ZUtleSAtIE9wdGlvbmFsIHByaXZhdGUga2V5LiBJZiBub3QgcHJvdmlkZWQsIHdpbGwgdHJ5IGNvb2tpZXMgdGhlbiBlbnYgdmFyc1xuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0QWRtaW5BcHAocHJpdmF0ZUtleSwgY2hhaW5JZCA9IERFRkFVTFRfQ0hBSU5fSUQpIHtcbiAgICAvLyBSZXNvbHZlIHRoZSBwcml2YXRlIGtleSBmaXJzdFxuICAgIGxldCByZXNvbHZlZFByaXZhdGVLZXkgPSBwcml2YXRlS2V5O1xuICAgIGxldCB3YWxsZXRBZGRyZXNzO1xuICAgIGlmICghcmVzb2x2ZWRQcml2YXRlS2V5KSB7XG4gICAgICAgIC8vIFRyeSB0byBnZXQgcHJpdmF0ZSBrZXkgZnJvbSBzZXNzaW9uIGZpcnN0IChmb3IgV2ViM0F1dGgvd2FsbGV0KSwgdGhlbiBmYWxsIGJhY2sgdG8gZW52aXJvbm1lbnQgdmFyaWFibGVcbiAgICAgICAgLy8gT25seSB0cnkgTmV4dC5qcyBjb29raWVzIGlmIHdlJ3JlIGluIGEgTmV4dC5qcyBlbnZpcm9ubWVudFxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gRHluYW1pY2FsbHkgdHJ5IHRvIGltcG9ydCBuZXh0L2hlYWRlcnMgKG9ubHkgYXZhaWxhYmxlIGluIE5leHQuanMgYXBwcylcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgd3JhcHBlZCBpbiB0cnkvY2F0Y2ggYmVjYXVzZSBjb3JlIHBhY2thZ2UgZG9lc24ndCBoYXZlIG5leHQgYXMgYSBkZXBlbmRlbmN5XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlIC0gbmV4dC9oZWFkZXJzIGlzIG5vdCBhdmFpbGFibGUgaW4gY29yZSBwYWNrYWdlLCBvbmx5IGluIE5leHQuanMgYXBwc1xuICAgICAgICAgICAgY29uc3QgbmV4dEhlYWRlcnMgPSBhd2FpdCBpbXBvcnQoJ25leHQvaGVhZGVycycpLmNhdGNoKCgpID0+IG51bGwpO1xuICAgICAgICAgICAgaWYgKG5leHRIZWFkZXJzICYmIG5leHRIZWFkZXJzLmNvb2tpZXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb29raWVTdG9yZSA9IGF3YWl0IG5leHRIZWFkZXJzLmNvb2tpZXMoKTtcbiAgICAgICAgICAgICAgICByZXNvbHZlZFByaXZhdGVLZXkgPSBjb29raWVTdG9yZS5nZXQoJ2FkbWluX3ByaXZhdGVfa2V5Jyk/LnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgLy8gSWYgY29va2llcygpIGZhaWxzIChlLmcuLCBub3QgaW4gTmV4dC5qcyBjb250ZXh0KSwgZmFsbCBiYWNrIHRvIGVudmlyb25tZW50IHZhcmlhYmxlXG4gICAgICAgICAgICAvLyBUaGlzIGlzIGV4cGVjdGVkIGluIG5vbi1OZXh0LmpzIGNvbnRleHRzXG4gICAgICAgIH1cbiAgICAgICAgLy8gRmFsbCBiYWNrIHRvIGVudmlyb25tZW50IHZhcmlhYmxlIGlmIG5vIHNlc3Npb24ga2V5XG4gICAgICAgIGlmICghcmVzb2x2ZWRQcml2YXRlS2V5KSB7XG4gICAgICAgICAgICAvLyBDaGVjayBlbnZpcm9ubWVudCB2YXJpYWJsZXMgZGlyZWN0bHlcbiAgICAgICAgICAgIGNvbnN0IGVudlByaXZhdGVLZXkgPSBwcm9jZXNzLmVudi5BR0VOVElDX1RSVVNUX0FETUlOX1BSSVZBVEVfS0VZO1xuICAgICAgICAgICAgcmVzb2x2ZWRQcml2YXRlS2V5ID0gZW52UHJpdmF0ZUtleTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBDaGVjayBpZiB3ZSBoYXZlIGEgd2FsbGV0IGFkZHJlc3MgZnJvbSBNZXRhTWFzayAobm8gcHJpdmF0ZSBrZXkgYXZhaWxhYmxlKVxuICAgIGlmICghcmVzb2x2ZWRQcml2YXRlS2V5KSB7XG4gICAgICAgIC8vIFRyeSB0byBnZXQgd2FsbGV0IGFkZHJlc3MgZnJvbSBzZXNzaW9uIChmb3IgTWV0YU1hc2spXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlIC0gbmV4dC9oZWFkZXJzIGlzIG5vdCBhdmFpbGFibGUgaW4gY29yZSBwYWNrYWdlLCBvbmx5IGluIE5leHQuanMgYXBwc1xuICAgICAgICAgICAgY29uc3QgbmV4dEhlYWRlcnMgPSBhd2FpdCBpbXBvcnQoJ25leHQvaGVhZGVycycpLmNhdGNoKCgpID0+IG51bGwpO1xuICAgICAgICAgICAgaWYgKG5leHRIZWFkZXJzICYmIG5leHRIZWFkZXJzLmNvb2tpZXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb29raWVTdG9yZSA9IGF3YWl0IG5leHRIZWFkZXJzLmNvb2tpZXMoKTtcbiAgICAgICAgICAgICAgICB3YWxsZXRBZGRyZXNzID0gY29va2llU3RvcmUuZ2V0KCd3YWxsZXRfYWRkcmVzcycpPy52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIC8vIElnbm9yZSBlcnJvcnNcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB3ZSBoYXZlIG5laXRoZXIgcHJpdmF0ZSBrZXkgbm9yIHdhbGxldCBhZGRyZXNzLCB0aHJvdyBlcnJvclxuICAgICAgICBpZiAoIXdhbGxldEFkZHJlc3MgJiYgIXJlc29sdmVkUHJpdmF0ZUtleSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIHJlcXVpcmVkOiBTZXQgQUdFTlRJQ19UUlVTVF9BRE1JTl9QUklWQVRFX0tFWSBlbnZpcm9ubWVudCB2YXJpYWJsZSwgYXV0aGVudGljYXRlIHZpYSBXZWIzQXV0aCBzb2NpYWwgbG9naW4gKHByb3ZpZGVzIHByaXZhdGUga2V5KSwgb3IgY29ubmVjdCB2aWEgd2FsbGV0IChNZXRhTWFzay9XZWIzQXV0aCkuXFxuXFxuJyArXG4gICAgICAgICAgICAgICAgJ05vdGU6XFxuJyArXG4gICAgICAgICAgICAgICAgJyAgLSBXZWIzQXV0aCBzb2NpYWwgbG9naW4gKEdvb2dsZSwgRmFjZWJvb2ssIGV0Yy4pIOKGkiBwcm92aWRlcyBwcml2YXRlIGtleSDihpIgZnVsbCBzZXJ2ZXItc2lkZSBvcGVyYXRpb25zIOKchVxcbicgK1xuICAgICAgICAgICAgICAgICcgIC0gV2ViM0F1dGgvTWV0YU1hc2sgd2FsbGV0IHByb3ZpZGVyIOKGkiBubyBwcml2YXRlIGtleSDihpIgcmVhZC1vbmx5IG9wZXJhdGlvbnMgKHByZXBhcmUgdHJhbnNhY3Rpb25zKSDinIVcXG4nICtcbiAgICAgICAgICAgICAgICAnICAtIEZvciB3YWxsZXQgcHJvdmlkZXJzLCBpbXBsZW1lbnQgY2xpZW50LXNpZGUgc2lnbmluZyB0byBjb21wbGV0ZSB0cmFuc2FjdGlvbnMnKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB3ZSBoYXZlIHdhbGxldCBhZGRyZXNzIGJ1dCBubyBwcml2YXRlIGtleSwgd2UgY2FuIHN0aWxsIGRvIHJlYWQtb25seSBvcGVyYXRpb25zXG4gICAgICAgIC8vIChwcmVwYXJlIHRyYW5zYWN0aW9ucywgZW5jb2RlIGNhbGxkYXRhLCBldGMuKSBidXQgbm90IHNpZ24vc2VuZCB0cmFuc2FjdGlvbnNcbiAgICAgICAgLy8gVGhpcyBpcyBoYW5kbGVkIGJ5IGNoZWNraW5nIGhhc1ByaXZhdGVLZXkgYmVmb3JlIGF0dGVtcHRpbmcgdG8gc2lnblxuICAgIH1cbiAgICAvLyBEZXRlcm1pbmUgaW5zdGFuY2Uga2V5IC0gdXNlIHdhbGxldCBhZGRyZXNzIGlmIGF2YWlsYWJsZSwgb3RoZXJ3aXNlIHVzZSBwcml2YXRlIGtleSBhZGRyZXNzXG4gICAgbGV0IGluc3RhbmNlS2V5QmFzZTtcbiAgICBsZXQgcmVzb2x2ZWRBZGRyZXNzO1xuICAgIGlmIChyZXNvbHZlZFByaXZhdGVLZXkpIHtcbiAgICAgICAgLy8gVXNlIHByaXZhdGUga2V5IHRvIGRlcml2ZSBhZGRyZXNzXG4gICAgICAgIGNvbnN0IHsgcHJpdmF0ZUtleVRvQWNjb3VudCB9ID0gYXdhaXQgaW1wb3J0KCd2aWVtL2FjY291bnRzJyk7XG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRLZXkgPSByZXNvbHZlZFByaXZhdGVLZXkuc3RhcnRzV2l0aCgnMHgnKSA/IHJlc29sdmVkUHJpdmF0ZUtleSA6IGAweCR7cmVzb2x2ZWRQcml2YXRlS2V5fWA7XG4gICAgICAgIGNvbnN0IHRlbXBBY2NvdW50ID0gcHJpdmF0ZUtleVRvQWNjb3VudChub3JtYWxpemVkS2V5KTtcbiAgICAgICAgaW5zdGFuY2VLZXlCYXNlID0gdGVtcEFjY291bnQuYWRkcmVzcy50b0xvd2VyQ2FzZSgpO1xuICAgICAgICByZXNvbHZlZEFkZHJlc3MgPSB0ZW1wQWNjb3VudC5hZGRyZXNzO1xuICAgIH1cbiAgICBlbHNlIGlmICh3YWxsZXRBZGRyZXNzKSB7XG4gICAgICAgIC8vIFVzZSB3YWxsZXQgYWRkcmVzcyBkaXJlY3RseSAoZm9yIHJlYWQtb25seSBvcGVyYXRpb25zKVxuICAgICAgICBpbnN0YW5jZUtleUJhc2UgPSB3YWxsZXRBZGRyZXNzLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHJlc29sdmVkQWRkcmVzcyA9IHdhbGxldEFkZHJlc3M7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VpdGhlciBwcml2YXRlIGtleSBvciB3YWxsZXQgYWRkcmVzcyBpcyByZXF1aXJlZCcpO1xuICAgIH1cbiAgICBjb25zdCBpbnN0YW5jZUtleSA9IGAke2luc3RhbmNlS2V5QmFzZX06JHtjaGFpbklkfWA7XG4gICAgLy8gSWYgYWxyZWFkeSBpbml0aWFsaXplZCBmb3IgdGhpcyBrZXksIHJldHVybiBpbW1lZGlhdGVseVxuICAgIGNvbnN0IGV4aXN0aW5nSW5zdGFuY2UgPSBhZG1pbkFwcEluc3RhbmNlcy5nZXQoaW5zdGFuY2VLZXkpO1xuICAgIGlmIChleGlzdGluZ0luc3RhbmNlKSB7XG4gICAgICAgIHJldHVybiBleGlzdGluZ0luc3RhbmNlO1xuICAgIH1cbiAgICAvLyBJZiBpbml0aWFsaXphdGlvbiBpcyBpbiBwcm9ncmVzcyBmb3IgdGhpcyBrZXksIHdhaXQgZm9yIGl0XG4gICAgY29uc3QgZXhpc3RpbmdQcm9taXNlID0gaW5pdGlhbGl6YXRpb25Qcm9taXNlcy5nZXQoaW5zdGFuY2VLZXkpO1xuICAgIGlmIChleGlzdGluZ1Byb21pc2UpIHtcbiAgICAgICAgcmV0dXJuIGV4aXN0aW5nUHJvbWlzZTtcbiAgICB9XG4gICAgLy8gU3RhcnQgaW5pdGlhbGl6YXRpb24gZm9yIHRoaXMgc3BlY2lmaWMgcHJpdmF0ZSBrZXlcbiAgICBjb25zdCBpbml0aWFsaXphdGlvblByb21pc2UgPSAoYXN5bmMgKCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBpcyBhbiBhZG1pbiBhcHAgKGVudmlyb25tZW50IGZsYWcpXG4gICAgICAgICAgICBpZiAoIWlzVXNlckFwcEVuYWJsZWQoJ2FkbWluJykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FkbWluQXBwIGlzIG9ubHkgYXZhaWxhYmxlIHdoZW4gQUdFTlRJQ19UUlVTVF9BUFBfUk9MRVMgaW5jbHVkZXMgXCJhZG1pblwiJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb2dVc2VyQXBwSW5pdFN0YXJ0KCdhZG1pbicsIGBjaGFpbklkPSR7Y2hhaW5JZH1gKTtcbiAgICAgICAgICAgIC8vIEdldCBjaGFpbi1zcGVjaWZpYyBSUEMgVVJMIGFuZCBjaGFpbiBjb25maWdcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldENoYWluSWQgPSBjaGFpbklkIHx8IERFRkFVTFRfQ0hBSU5fSUQ7XG4gICAgICAgICAgICBjb25zdCBycGNVcmwgPSBnZXRDaGFpblJwY1VybCh0YXJnZXRDaGFpbklkKTtcbiAgICAgICAgICAgIGlmICghcnBjVXJsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBNaXNzaW5nIHJlcXVpcmVkIFJQQyBVUkwuIENvbmZpZ3VyZSBBR0VOVElDX1RSVVNUX1JQQ19VUkxfe0NIQUlOfSBmb3IgY2hhaW5JZCAke3RhcmdldENoYWluSWR9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IGNyZWF0ZVB1YmxpY0NsaWVudCwgY3JlYXRlV2FsbGV0Q2xpZW50LCBodHRwOiBodHRwVHJhbnNwb3J0IH0gPSBhd2FpdCBpbXBvcnQoJ3ZpZW0nKTtcbiAgICAgICAgICAgIGNvbnN0IGNoYWluID0gZ2V0Q2hhaW5CeUlkKHRhcmdldENoYWluSWQpO1xuICAgICAgICAgICAgLy8gQ3JlYXRlIHB1YmxpYyBjbGllbnQgKGFsd2F5cyBuZWVkZWQpXG4gICAgICAgICAgICBjb25zdCBwdWJsaWNDbGllbnQgPSBjcmVhdGVQdWJsaWNDbGllbnQoe1xuICAgICAgICAgICAgICAgIGNoYWluLFxuICAgICAgICAgICAgICAgIHRyYW5zcG9ydDogaHR0cFRyYW5zcG9ydChycGNVcmwpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBsZXQgYWNjb3VudDtcbiAgICAgICAgICAgIGxldCB3YWxsZXRDbGllbnQ7XG4gICAgICAgICAgICBsZXQgYWRkcmVzcztcbiAgICAgICAgICAgIC8vIGhhc1ByaXZhdGVLZXkgcmVmbGVjdHMgc3RyaWN0bHkgd2hldGhlciB0aGUgZGVkaWNhdGVkIGFkbWluIHByaXZhdGVcbiAgICAgICAgICAgIC8vIGtleSBlbnYgdmFyIGlzIHByZXNlbnQsIG5vdCB3aGV0aGVyIGEgc2Vzc2lvbi9jb29raWUga2V5IGV4aXN0cy5cbiAgICAgICAgICAgIGNvbnN0IGhhc1ByaXZhdGVLZXkgPSBoYXNBZG1pblByaXZhdGVLZXkoKTtcbiAgICAgICAgICAgIGlmIChyZXNvbHZlZFByaXZhdGVLZXkpIHtcbiAgICAgICAgICAgICAgICAvLyBDcmVhdGUgd2FsbGV0IGNsaWVudCBhbmQgYWNjb3VudCBmcm9tIHByaXZhdGUga2V5XG4gICAgICAgICAgICAgICAgY29uc3QgeyBwcml2YXRlS2V5VG9BY2NvdW50IH0gPSBhd2FpdCBpbXBvcnQoJ3ZpZW0vYWNjb3VudHMnKTtcbiAgICAgICAgICAgICAgICBjb25zdCBub3JtYWxpemVkS2V5ID0gcmVzb2x2ZWRQcml2YXRlS2V5LnN0YXJ0c1dpdGgoJzB4JykgPyByZXNvbHZlZFByaXZhdGVLZXkgOiBgMHgke3Jlc29sdmVkUHJpdmF0ZUtleX1gO1xuICAgICAgICAgICAgICAgIGFjY291bnQgPSBwcml2YXRlS2V5VG9BY2NvdW50KG5vcm1hbGl6ZWRLZXkpO1xuICAgICAgICAgICAgICAgIGFkZHJlc3MgPSBhY2NvdW50LmFkZHJlc3M7XG4gICAgICAgICAgICAgICAgd2FsbGV0Q2xpZW50ID0gY3JlYXRlV2FsbGV0Q2xpZW50KHtcbiAgICAgICAgICAgICAgICAgICAgYWNjb3VudCxcbiAgICAgICAgICAgICAgICAgICAgY2hhaW4sXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zcG9ydDogaHR0cFRyYW5zcG9ydChycGNVcmwpLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gUmVhZC1vbmx5IG1vZGUgLSB1c2Ugd2FsbGV0IGFkZHJlc3NcbiAgICAgICAgICAgICAgICBhZGRyZXNzID0gcmVzb2x2ZWRBZGRyZXNzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ3JlYXRlIEFjY291bnRQcm92aWRlciAtIHdhbGxldENsaWVudCBpcyBvcHRpb25hbCAobnVsbCBmb3IgcmVhZC1vbmx5KVxuICAgICAgICAgICAgY29uc3QgYWNjb3VudFByb3ZpZGVyID0gbmV3IFZpZW1BY2NvdW50UHJvdmlkZXIoe1xuICAgICAgICAgICAgICAgIHB1YmxpY0NsaWVudCxcbiAgICAgICAgICAgICAgICB3YWxsZXRDbGllbnQ6IHdhbGxldENsaWVudCA/PyBudWxsLFxuICAgICAgICAgICAgICAgIGFjY291bnQ6IGFjY291bnQgPz8gdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIGNoYWluQ29uZmlnOiB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBjaGFpbi5pZCxcbiAgICAgICAgICAgICAgICAgICAgcnBjVXJsLFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiBjaGFpbi5uYW1lLFxuICAgICAgICAgICAgICAgICAgICBjaGFpbixcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBpbnN0YW5jZSA9IHtcbiAgICAgICAgICAgICAgICBhY2NvdW50LFxuICAgICAgICAgICAgICAgIHB1YmxpY0NsaWVudDogcHVibGljQ2xpZW50LFxuICAgICAgICAgICAgICAgIHdhbGxldENsaWVudDogd2FsbGV0Q2xpZW50LFxuICAgICAgICAgICAgICAgIGFjY291bnRQcm92aWRlcixcbiAgICAgICAgICAgICAgICBhZGRyZXNzLFxuICAgICAgICAgICAgICAgIGhhc1ByaXZhdGVLZXksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gU3RvcmUgaW5zdGFuY2UgYnkgYWRkcmVzcyBrZXlcbiAgICAgICAgICAgIGFkbWluQXBwSW5zdGFuY2VzLnNldChpbnN0YW5jZUtleSwgaW5zdGFuY2UpO1xuICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25Qcm9taXNlcy5kZWxldGUoaW5zdGFuY2VLZXkpOyAvLyBSZW1vdmUgZnJvbSBwZW5kaW5nXG4gICAgICAgICAgICBsb2dVc2VyQXBwSW5pdFN1Y2Nlc3MoJ2FkbWluJywgYWRkcmVzcyk7XG4gICAgICAgICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBsb2dVc2VyQXBwSW5pdEZhaWx1cmUoJ2FkbWluJywgZXJyb3IpO1xuICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25Qcm9taXNlcy5kZWxldGUoaW5zdGFuY2VLZXkpOyAvLyBSZW1vdmUgZnJvbSBwZW5kaW5nIG9uIGVycm9yXG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH0pKCk7XG4gICAgLy8gU3RvcmUgcHJvbWlzZSBmb3IgdGhpcyBrZXlcbiAgICBpbml0aWFsaXphdGlvblByb21pc2VzLnNldChpbnN0YW5jZUtleSwgaW5pdGlhbGl6YXRpb25Qcm9taXNlKTtcbiAgICByZXR1cm4gaW5pdGlhbGl6YXRpb25Qcm9taXNlO1xufVxuLyoqXG4gKiBHZXQgdGhlIGFkbWluIGFkZHJlc3MgKGNvbnZlbmllbmNlIG1ldGhvZClcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEFkbWluQWRkcmVzcygpIHtcbiAgICBjb25zdCBhZG1pbkFwcCA9IGF3YWl0IGdldEFkbWluQXBwKHVuZGVmaW5lZCwgREVGQVVMVF9DSEFJTl9JRCk7XG4gICAgcmV0dXJuIGFkbWluQXBwPy5hZGRyZXNzID8/ICcweCc7XG59XG4vKipcbiAqIENoZWNrIGlmIGFkbWluIGFwcCBpcyBpbml0aWFsaXplZCBmb3IgYSBzcGVjaWZpYyBhZGRyZXNzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0FkbWluQXBwSW5pdGlhbGl6ZWQoYWRkcmVzcykge1xuICAgIGlmIChhZGRyZXNzKSB7XG4gICAgICAgIGNvbnN0IGtleVByZWZpeCA9IGAke2FkZHJlc3MudG9Mb3dlckNhc2UoKX06YDtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgYWRtaW5BcHBJbnN0YW5jZXMua2V5cygpKSB7XG4gICAgICAgICAgICBpZiAoa2V5LnN0YXJ0c1dpdGgoa2V5UHJlZml4KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIGFkbWluQXBwSW5zdGFuY2VzLnNpemUgPiAwO1xufVxuLyoqXG4gKiBSZXNldCBhZG1pbiBhcHAgaW5zdGFuY2VzICh1c2VmdWwgZm9yIHRlc3RpbmcpXG4gKiBAcGFyYW0gYWRkcmVzcyAtIE9wdGlvbmFsIGFkZHJlc3MgdG8gcmVzZXQgc3BlY2lmaWMgaW5zdGFuY2UsIG9yIGFsbCBpZiBub3QgcHJvdmlkZWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlc2V0QWRtaW5BcHAoYWRkcmVzcykge1xuICAgIGlmIChhZGRyZXNzKSB7XG4gICAgICAgIGNvbnN0IGtleVByZWZpeCA9IGAke2FkZHJlc3MudG9Mb3dlckNhc2UoKX06YDtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgQXJyYXkuZnJvbShhZG1pbkFwcEluc3RhbmNlcy5rZXlzKCkpKSB7XG4gICAgICAgICAgICBpZiAoa2V5LnN0YXJ0c1dpdGgoa2V5UHJlZml4KSkge1xuICAgICAgICAgICAgICAgIGFkbWluQXBwSW5zdGFuY2VzLmRlbGV0ZShrZXkpO1xuICAgICAgICAgICAgICAgIGluaXRpYWxpemF0aW9uUHJvbWlzZXMuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGFkbWluQXBwSW5zdGFuY2VzLmNsZWFyKCk7XG4gICAgICAgIGluaXRpYWxpemF0aW9uUHJvbWlzZXMuY2xlYXIoKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hZG1pbkFwcC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@agentic-trust/core/dist/server/userApps/adminApp.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@agentic-trust/core/dist/server/userApps/clientApp.js":
/*!********************************************************************************!*\
  !*** ../../node_modules/@agentic-trust/core/dist/server/userApps/clientApp.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getClientAddress: () => (/* binding */ getClientAddress),\n/* harmony export */   getClientApp: () => (/* binding */ getClientApp),\n/* harmony export */   getClientAppAccount: () => (/* binding */ getClientAppAccount),\n/* harmony export */   isClientAppInitialized: () => (/* binding */ isClientAppInitialized),\n/* harmony export */   resetClientApp: () => (/* binding */ resetClientApp)\n/* harmony export */ });\n/* harmony import */ var _agentic_trust_8004_sdk__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @agentic-trust/8004-sdk */ \"(rsc)/../../node_modules/@agentic-trust/8004-sdk/dist/index.js\");\n/* harmony import */ var _userApp__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./userApp */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/userApps/userApp.js\");\n/**\n * Client App Singleton\n *\n * Manages a singleton instance for client-side operations using private key\n * Provides access to client account, wallet client, and client address\n */\n\n\n// Singleton instance\nlet clientAppInstance = null;\nlet initializationPromise = null;\n/**\n * Get or create the ClientApp singleton\n * Initializes from private key in environment variables\n */\nasync function getClientApp() {\n    // Check if this process is configured to act as a client app\n    // If not, do nothing and return undefined (no side effects)\n    const isClientApp = (0,_userApp__WEBPACK_IMPORTED_MODULE_1__.isUserAppEnabled)('client');\n    if (!isClientApp) {\n        return undefined;\n    }\n    // If already initialized, return immediately\n    if (clientAppInstance) {\n        return clientAppInstance;\n    }\n    // If initialization is in progress, wait for it\n    if (initializationPromise) {\n        return initializationPromise;\n    }\n    initializationPromise = (async () => {\n        try {\n            const { getChainRpcUrl, DEFAULT_CHAIN_ID } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ../lib/chainConfig */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/lib/chainConfig.js\"));\n            const privateKey = process.env.AGENTIC_TRUST_ADMIN_PRIVATE_KEY;\n            const rpcUrl = getChainRpcUrl(DEFAULT_CHAIN_ID);\n            if (!privateKey) {\n                console.warn('ClientApp role is enabled but AGENTIC_TRUST_ADMIN_PRIVATE_KEY is not set; skipping ClientApp initialization for this process.');\n                clientAppInstance = null;\n                initializationPromise = null;\n                return undefined;\n            }\n            if (!rpcUrl) {\n                console.warn('ClientApp role is enabled but no RPC URL is configured; set AGENTIC_TRUST_RPC_URL_* env vars. Skipping ClientApp initialization.');\n                clientAppInstance = null;\n                initializationPromise = null;\n                return undefined;\n            }\n            // Start initialization (only when we have the minimum env to proceed)\n            (0,_userApp__WEBPACK_IMPORTED_MODULE_1__.logUserAppInitStart)('client', `NODE_ENV=${\"development\"}`);\n            const { privateKeyToAccount } = await Promise.all(/*! import() */[__webpack_require__.e(\"vendor-chunks/viem\"), __webpack_require__.e(\"vendor-chunks/@noble\")]).then(__webpack_require__.bind(__webpack_require__, /*! viem/accounts */ \"(rsc)/../../node_modules/viem/_esm/accounts/index.js\"));\n            const { createPublicClient, createWalletClient, http: httpTransport } = await Promise.all(/*! import() */[__webpack_require__.e(\"vendor-chunks/viem\"), __webpack_require__.e(\"vendor-chunks/abitype\")]).then(__webpack_require__.bind(__webpack_require__, /*! viem */ \"(rsc)/../../node_modules/viem/_esm/index.js\"));\n            const { sepolia } = await __webpack_require__.e(/*! import() */ \"vendor-chunks/viem\").then(__webpack_require__.bind(__webpack_require__, /*! viem/chains */ \"(rsc)/../../node_modules/viem/_esm/chains/index.js\"));\n            // Normalize private key\n            const normalizedKey = privateKey.startsWith('0x') ? privateKey : `0x${privateKey}`;\n            const account = privateKeyToAccount(normalizedKey);\n            const address = account.address;\n            // Create public and wallet clients\n            const publicClient = createPublicClient({\n                chain: sepolia,\n                transport: httpTransport(rpcUrl),\n            });\n            const walletClient = createWalletClient({\n                account,\n                chain: sepolia,\n                transport: httpTransport(rpcUrl),\n            });\n            // Create AccountProvider\n            const accountProvider = new _agentic_trust_8004_sdk__WEBPACK_IMPORTED_MODULE_0__.ViemAccountProvider({\n                publicClient,\n                walletClient,\n                account,\n                chainConfig: {\n                    id: sepolia.id,\n                    rpcUrl,\n                    name: sepolia.name,\n                    chain: sepolia,\n                },\n            });\n            clientAppInstance = {\n                account,\n                publicClient: publicClient,\n                walletClient: walletClient,\n                accountProvider,\n                address,\n            };\n            (0,_userApp__WEBPACK_IMPORTED_MODULE_1__.logUserAppInitSuccess)('client', address);\n            return clientAppInstance;\n        }\n        catch (error) {\n            (0,_userApp__WEBPACK_IMPORTED_MODULE_1__.logUserAppInitFailure)('client', error);\n            initializationPromise = null; // Reset on error so it can be retried\n            throw error;\n        }\n    })();\n    return initializationPromise;\n}\n/**\n * Backwards-compatible helper to get the client address as a string.\n * Prefer using getClientApp() or getClientAppAccount() in new code.\n */\nasync function getClientAddress() {\n    const clientApp = await getClientApp();\n    return clientApp?.address;\n}\n/**\n * Get the full viem Account for the ClientApp (convenience method).\n * Returns undefined if the ClientApp is not enabled/initialized.\n */\nasync function getClientAppAccount() {\n    const clientApp = await getClientApp();\n    return clientApp?.account;\n}\n/**\n * Check if client app is initialized\n */\nfunction isClientAppInitialized() {\n    return clientAppInstance !== null;\n}\n/**\n * Reset the singleton (useful for testing)\n */\nfunction resetClientApp() {\n    clientAppInstance = null;\n    initializationPromise = null;\n}\n//# sourceMappingURL=clientApp.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BhZ2VudGljLXRydXN0L2NvcmUvZGlzdC9zZXJ2ZXIvdXNlckFwcHMvY2xpZW50QXBwLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDOEQ7QUFDa0Q7QUFDaEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSx3QkFBd0IsMERBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1DQUFtQyxRQUFRLDZMQUE0QjtBQUMzRjtBQUNBO0FBQ0E7QUFDQSx3R0FBd0c7QUFDeEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNGQUFzRjtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSw2REFBbUIsdUJBQXVCLGFBQW9CLENBQUM7QUFDM0Usb0JBQW9CLHNCQUFzQixRQUFRLHlQQUF1QjtBQUN6RSxvQkFBb0IsOERBQThELFFBQVEsd09BQWM7QUFDeEcsb0JBQW9CLFVBQVUsUUFBUSx3TEFBcUI7QUFDM0Q7QUFDQSxrRkFBa0YsV0FBVztBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSx3Q0FBd0Msd0VBQW1CO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwrREFBcUI7QUFDakM7QUFDQTtBQUNBO0FBQ0EsWUFBWSwrREFBcUI7QUFDakMsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvYmFyYi9hYS9Bc3NvY2lhdGVkQWNjb3VudHMvbm9kZV9tb2R1bGVzL0BhZ2VudGljLXRydXN0L2NvcmUvZGlzdC9zZXJ2ZXIvdXNlckFwcHMvY2xpZW50QXBwLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ2xpZW50IEFwcCBTaW5nbGV0b25cbiAqXG4gKiBNYW5hZ2VzIGEgc2luZ2xldG9uIGluc3RhbmNlIGZvciBjbGllbnQtc2lkZSBvcGVyYXRpb25zIHVzaW5nIHByaXZhdGUga2V5XG4gKiBQcm92aWRlcyBhY2Nlc3MgdG8gY2xpZW50IGFjY291bnQsIHdhbGxldCBjbGllbnQsIGFuZCBjbGllbnQgYWRkcmVzc1xuICovXG5pbXBvcnQgeyBWaWVtQWNjb3VudFByb3ZpZGVyIH0gZnJvbSAnQGFnZW50aWMtdHJ1c3QvODAwNC1zZGsnO1xuaW1wb3J0IHsgaXNVc2VyQXBwRW5hYmxlZCwgbG9nVXNlckFwcEluaXRTdGFydCwgbG9nVXNlckFwcEluaXRGYWlsdXJlLCBsb2dVc2VyQXBwSW5pdFN1Y2Nlc3MgfSBmcm9tICcuL3VzZXJBcHAnO1xuLy8gU2luZ2xldG9uIGluc3RhbmNlXG5sZXQgY2xpZW50QXBwSW5zdGFuY2UgPSBudWxsO1xubGV0IGluaXRpYWxpemF0aW9uUHJvbWlzZSA9IG51bGw7XG4vKipcbiAqIEdldCBvciBjcmVhdGUgdGhlIENsaWVudEFwcCBzaW5nbGV0b25cbiAqIEluaXRpYWxpemVzIGZyb20gcHJpdmF0ZSBrZXkgaW4gZW52aXJvbm1lbnQgdmFyaWFibGVzXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRDbGllbnRBcHAoKSB7XG4gICAgLy8gQ2hlY2sgaWYgdGhpcyBwcm9jZXNzIGlzIGNvbmZpZ3VyZWQgdG8gYWN0IGFzIGEgY2xpZW50IGFwcFxuICAgIC8vIElmIG5vdCwgZG8gbm90aGluZyBhbmQgcmV0dXJuIHVuZGVmaW5lZCAobm8gc2lkZSBlZmZlY3RzKVxuICAgIGNvbnN0IGlzQ2xpZW50QXBwID0gaXNVc2VyQXBwRW5hYmxlZCgnY2xpZW50Jyk7XG4gICAgaWYgKCFpc0NsaWVudEFwcCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvLyBJZiBhbHJlYWR5IGluaXRpYWxpemVkLCByZXR1cm4gaW1tZWRpYXRlbHlcbiAgICBpZiAoY2xpZW50QXBwSW5zdGFuY2UpIHtcbiAgICAgICAgcmV0dXJuIGNsaWVudEFwcEluc3RhbmNlO1xuICAgIH1cbiAgICAvLyBJZiBpbml0aWFsaXphdGlvbiBpcyBpbiBwcm9ncmVzcywgd2FpdCBmb3IgaXRcbiAgICBpZiAoaW5pdGlhbGl6YXRpb25Qcm9taXNlKSB7XG4gICAgICAgIHJldHVybiBpbml0aWFsaXphdGlvblByb21pc2U7XG4gICAgfVxuICAgIGluaXRpYWxpemF0aW9uUHJvbWlzZSA9IChhc3luYyAoKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB7IGdldENoYWluUnBjVXJsLCBERUZBVUxUX0NIQUlOX0lEIH0gPSBhd2FpdCBpbXBvcnQoJy4uL2xpYi9jaGFpbkNvbmZpZycpO1xuICAgICAgICAgICAgY29uc3QgcHJpdmF0ZUtleSA9IHByb2Nlc3MuZW52LkFHRU5USUNfVFJVU1RfQURNSU5fUFJJVkFURV9LRVk7XG4gICAgICAgICAgICBjb25zdCBycGNVcmwgPSBnZXRDaGFpblJwY1VybChERUZBVUxUX0NIQUlOX0lEKTtcbiAgICAgICAgICAgIGlmICghcHJpdmF0ZUtleSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignQ2xpZW50QXBwIHJvbGUgaXMgZW5hYmxlZCBidXQgQUdFTlRJQ19UUlVTVF9BRE1JTl9QUklWQVRFX0tFWSBpcyBub3Qgc2V0OyBza2lwcGluZyBDbGllbnRBcHAgaW5pdGlhbGl6YXRpb24gZm9yIHRoaXMgcHJvY2Vzcy4nKTtcbiAgICAgICAgICAgICAgICBjbGllbnRBcHBJbnN0YW5jZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25Qcm9taXNlID0gbnVsbDtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFycGNVcmwpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ0NsaWVudEFwcCByb2xlIGlzIGVuYWJsZWQgYnV0IG5vIFJQQyBVUkwgaXMgY29uZmlndXJlZDsgc2V0IEFHRU5USUNfVFJVU1RfUlBDX1VSTF8qIGVudiB2YXJzLiBTa2lwcGluZyBDbGllbnRBcHAgaW5pdGlhbGl6YXRpb24uJyk7XG4gICAgICAgICAgICAgICAgY2xpZW50QXBwSW5zdGFuY2UgPSBudWxsO1xuICAgICAgICAgICAgICAgIGluaXRpYWxpemF0aW9uUHJvbWlzZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFN0YXJ0IGluaXRpYWxpemF0aW9uIChvbmx5IHdoZW4gd2UgaGF2ZSB0aGUgbWluaW11bSBlbnYgdG8gcHJvY2VlZClcbiAgICAgICAgICAgIGxvZ1VzZXJBcHBJbml0U3RhcnQoJ2NsaWVudCcsIGBOT0RFX0VOVj0ke3Byb2Nlc3MuZW52Lk5PREVfRU5WfWApO1xuICAgICAgICAgICAgY29uc3QgeyBwcml2YXRlS2V5VG9BY2NvdW50IH0gPSBhd2FpdCBpbXBvcnQoJ3ZpZW0vYWNjb3VudHMnKTtcbiAgICAgICAgICAgIGNvbnN0IHsgY3JlYXRlUHVibGljQ2xpZW50LCBjcmVhdGVXYWxsZXRDbGllbnQsIGh0dHA6IGh0dHBUcmFuc3BvcnQgfSA9IGF3YWl0IGltcG9ydCgndmllbScpO1xuICAgICAgICAgICAgY29uc3QgeyBzZXBvbGlhIH0gPSBhd2FpdCBpbXBvcnQoJ3ZpZW0vY2hhaW5zJyk7XG4gICAgICAgICAgICAvLyBOb3JtYWxpemUgcHJpdmF0ZSBrZXlcbiAgICAgICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRLZXkgPSBwcml2YXRlS2V5LnN0YXJ0c1dpdGgoJzB4JykgPyBwcml2YXRlS2V5IDogYDB4JHtwcml2YXRlS2V5fWA7XG4gICAgICAgICAgICBjb25zdCBhY2NvdW50ID0gcHJpdmF0ZUtleVRvQWNjb3VudChub3JtYWxpemVkS2V5KTtcbiAgICAgICAgICAgIGNvbnN0IGFkZHJlc3MgPSBhY2NvdW50LmFkZHJlc3M7XG4gICAgICAgICAgICAvLyBDcmVhdGUgcHVibGljIGFuZCB3YWxsZXQgY2xpZW50c1xuICAgICAgICAgICAgY29uc3QgcHVibGljQ2xpZW50ID0gY3JlYXRlUHVibGljQ2xpZW50KHtcbiAgICAgICAgICAgICAgICBjaGFpbjogc2Vwb2xpYSxcbiAgICAgICAgICAgICAgICB0cmFuc3BvcnQ6IGh0dHBUcmFuc3BvcnQocnBjVXJsKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3Qgd2FsbGV0Q2xpZW50ID0gY3JlYXRlV2FsbGV0Q2xpZW50KHtcbiAgICAgICAgICAgICAgICBhY2NvdW50LFxuICAgICAgICAgICAgICAgIGNoYWluOiBzZXBvbGlhLFxuICAgICAgICAgICAgICAgIHRyYW5zcG9ydDogaHR0cFRyYW5zcG9ydChycGNVcmwpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBDcmVhdGUgQWNjb3VudFByb3ZpZGVyXG4gICAgICAgICAgICBjb25zdCBhY2NvdW50UHJvdmlkZXIgPSBuZXcgVmllbUFjY291bnRQcm92aWRlcih7XG4gICAgICAgICAgICAgICAgcHVibGljQ2xpZW50LFxuICAgICAgICAgICAgICAgIHdhbGxldENsaWVudCxcbiAgICAgICAgICAgICAgICBhY2NvdW50LFxuICAgICAgICAgICAgICAgIGNoYWluQ29uZmlnOiB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBzZXBvbGlhLmlkLFxuICAgICAgICAgICAgICAgICAgICBycGNVcmwsXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IHNlcG9saWEubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgY2hhaW46IHNlcG9saWEsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2xpZW50QXBwSW5zdGFuY2UgPSB7XG4gICAgICAgICAgICAgICAgYWNjb3VudCxcbiAgICAgICAgICAgICAgICBwdWJsaWNDbGllbnQ6IHB1YmxpY0NsaWVudCxcbiAgICAgICAgICAgICAgICB3YWxsZXRDbGllbnQ6IHdhbGxldENsaWVudCxcbiAgICAgICAgICAgICAgICBhY2NvdW50UHJvdmlkZXIsXG4gICAgICAgICAgICAgICAgYWRkcmVzcyxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBsb2dVc2VyQXBwSW5pdFN1Y2Nlc3MoJ2NsaWVudCcsIGFkZHJlc3MpO1xuICAgICAgICAgICAgcmV0dXJuIGNsaWVudEFwcEluc3RhbmNlO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgbG9nVXNlckFwcEluaXRGYWlsdXJlKCdjbGllbnQnLCBlcnJvcik7XG4gICAgICAgICAgICBpbml0aWFsaXphdGlvblByb21pc2UgPSBudWxsOyAvLyBSZXNldCBvbiBlcnJvciBzbyBpdCBjYW4gYmUgcmV0cmllZFxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9KSgpO1xuICAgIHJldHVybiBpbml0aWFsaXphdGlvblByb21pc2U7XG59XG4vKipcbiAqIEJhY2t3YXJkcy1jb21wYXRpYmxlIGhlbHBlciB0byBnZXQgdGhlIGNsaWVudCBhZGRyZXNzIGFzIGEgc3RyaW5nLlxuICogUHJlZmVyIHVzaW5nIGdldENsaWVudEFwcCgpIG9yIGdldENsaWVudEFwcEFjY291bnQoKSBpbiBuZXcgY29kZS5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldENsaWVudEFkZHJlc3MoKSB7XG4gICAgY29uc3QgY2xpZW50QXBwID0gYXdhaXQgZ2V0Q2xpZW50QXBwKCk7XG4gICAgcmV0dXJuIGNsaWVudEFwcD8uYWRkcmVzcztcbn1cbi8qKlxuICogR2V0IHRoZSBmdWxsIHZpZW0gQWNjb3VudCBmb3IgdGhlIENsaWVudEFwcCAoY29udmVuaWVuY2UgbWV0aG9kKS5cbiAqIFJldHVybnMgdW5kZWZpbmVkIGlmIHRoZSBDbGllbnRBcHAgaXMgbm90IGVuYWJsZWQvaW5pdGlhbGl6ZWQuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRDbGllbnRBcHBBY2NvdW50KCkge1xuICAgIGNvbnN0IGNsaWVudEFwcCA9IGF3YWl0IGdldENsaWVudEFwcCgpO1xuICAgIHJldHVybiBjbGllbnRBcHA/LmFjY291bnQ7XG59XG4vKipcbiAqIENoZWNrIGlmIGNsaWVudCBhcHAgaXMgaW5pdGlhbGl6ZWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzQ2xpZW50QXBwSW5pdGlhbGl6ZWQoKSB7XG4gICAgcmV0dXJuIGNsaWVudEFwcEluc3RhbmNlICE9PSBudWxsO1xufVxuLyoqXG4gKiBSZXNldCB0aGUgc2luZ2xldG9uICh1c2VmdWwgZm9yIHRlc3RpbmcpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXNldENsaWVudEFwcCgpIHtcbiAgICBjbGllbnRBcHBJbnN0YW5jZSA9IG51bGw7XG4gICAgaW5pdGlhbGl6YXRpb25Qcm9taXNlID0gbnVsbDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNsaWVudEFwcC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@agentic-trust/core/dist/server/userApps/clientApp.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@agentic-trust/core/dist/server/userApps/providerApp.js":
/*!**********************************************************************************!*\
  !*** ../../node_modules/@agentic-trust/core/dist/server/userApps/providerApp.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getProviderAgentId: () => (/* binding */ getProviderAgentId),\n/* harmony export */   getProviderApp: () => (/* binding */ getProviderApp),\n/* harmony export */   isProviderAppInitialized: () => (/* binding */ isProviderAppInitialized),\n/* harmony export */   resetProviderApp: () => (/* binding */ resetProviderApp)\n/* harmony export */ });\n/* harmony import */ var _agentic_trust_8004_sdk__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @agentic-trust/8004-sdk */ \"(rsc)/../../node_modules/@agentic-trust/8004-sdk/dist/index.js\");\n/* harmony import */ var _userApp__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./userApp */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/userApps/userApp.js\");\n/**\n * Provider App Singleton\n *\n * Manages a singleton instance for provider-side operations using session package\n * Provides access to agent account, delegation setup, and wallet client for agent operations\n */\n\n\n// Singleton instance\nlet providerAppInstance = null;\nlet initializationPromise = null;\n/**\n * Get or create the ProviderApp singleton\n * Initializes from session package in environment variables\n */\nasync function getProviderApp() {\n    // If already initialized, return immediately\n    if (providerAppInstance) {\n        return providerAppInstance;\n    }\n    // If initialization is in progress, wait for it\n    if (initializationPromise) {\n        return initializationPromise;\n    }\n    // Check if this is a provider app (environment variable flag)\n    if (!(0,_userApp__WEBPACK_IMPORTED_MODULE_1__.isUserAppEnabled)('provider')) {\n        return undefined;\n    }\n    const sessionPackagePath = process.env.AGENTIC_TRUST_SESSION_PACKAGE_PATH;\n    if (!sessionPackagePath) {\n        // Session package may be loaded from database instead of env var\n        // Silently return undefined - no error logging as this is expected behavior\n        return undefined;\n    }\n    // Start initialization\n    (0,_userApp__WEBPACK_IMPORTED_MODULE_1__.logUserAppInitStart)('provider');\n    initializationPromise = (async () => {\n        try {\n            // Load session package and build delegation setup\n            const { loadSessionPackage, buildDelegationSetup, buildAgentAccountFromSession } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ../lib/sessionPackage */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/lib/sessionPackage.js\"));\n            const sessionPackage = loadSessionPackage(sessionPackagePath);\n            const delegationSetup = buildDelegationSetup(sessionPackage);\n            // Get agent account from session package\n            const agentAccount = await buildAgentAccountFromSession(sessionPackage);\n            // Create wallet client for agent\n            const { createWalletClient, http: httpTransport } = await Promise.all(/*! import() */[__webpack_require__.e(\"vendor-chunks/viem\"), __webpack_require__.e(\"vendor-chunks/abitype\")]).then(__webpack_require__.bind(__webpack_require__, /*! viem */ \"(rsc)/../../node_modules/viem/_esm/index.js\"));\n            const walletClient = createWalletClient({\n                account: agentAccount,\n                chain: delegationSetup.chain,\n                transport: httpTransport(delegationSetup.rpcUrl),\n            });\n            // Create AccountProvider\n            const accountProvider = new _agentic_trust_8004_sdk__WEBPACK_IMPORTED_MODULE_0__.ViemAccountProvider({\n                publicClient: delegationSetup.publicClient,\n                walletClient: walletClient,\n                account: agentAccount,\n                chainConfig: {\n                    id: delegationSetup.chain.id,\n                    rpcUrl: delegationSetup.rpcUrl,\n                    name: delegationSetup.chain.name,\n                    chain: delegationSetup.chain,\n                },\n            });\n            providerAppInstance = {\n                sessionPackage,\n                delegationSetup,\n                agentAccount,\n                publicClient: delegationSetup.publicClient,\n                walletClient: walletClient,\n                accountProvider,\n                agentId: BigInt(sessionPackage.agentId),\n            };\n            (0,_userApp__WEBPACK_IMPORTED_MODULE_1__.logUserAppInitSuccess)('provider', sessionPackage.agentId?.toString());\n            return providerAppInstance;\n        }\n        catch (error) {\n            (0,_userApp__WEBPACK_IMPORTED_MODULE_1__.logUserAppInitFailure)('provider', error);\n            initializationPromise = null; // Reset on error so it can be retried\n            // Return undefined instead of throwing to allow graceful fallback\n            // (session package may be loaded from database instead)\n            return undefined;\n        }\n    })();\n    return initializationPromise;\n}\n/**\n * Get the agent ID (convenience method)\n */\nasync function getProviderAgentId() {\n    const providerApp = await getProviderApp();\n    return providerApp?.agentId ?? BigInt(0);\n}\n/**\n * Check if provider app is initialized\n */\nfunction isProviderAppInitialized() {\n    return providerAppInstance !== null;\n}\n/**\n * Reset the singleton (useful for testing)\n */\nfunction resetProviderApp() {\n    providerAppInstance = null;\n    initializationPromise = null;\n}\n//# sourceMappingURL=providerApp.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BhZ2VudGljLXRydXN0L2NvcmUvZGlzdC9zZXJ2ZXIvdXNlckFwcHMvcHJvdmlkZXJBcHAuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQzhEO0FBQ2tEO0FBQ2hIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLDBEQUFnQjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLDZEQUFtQjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IseUVBQXlFLFFBQVEsbU1BQStCO0FBQ3BJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMENBQTBDLFFBQVEsd09BQWM7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSx3Q0FBd0Msd0VBQW1CO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksK0RBQXFCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLFlBQVksK0RBQXFCO0FBQ2pDLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9iYXJiL2FhL0Fzc29jaWF0ZWRBY2NvdW50cy9ub2RlX21vZHVsZXMvQGFnZW50aWMtdHJ1c3QvY29yZS9kaXN0L3NlcnZlci91c2VyQXBwcy9wcm92aWRlckFwcC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFByb3ZpZGVyIEFwcCBTaW5nbGV0b25cbiAqXG4gKiBNYW5hZ2VzIGEgc2luZ2xldG9uIGluc3RhbmNlIGZvciBwcm92aWRlci1zaWRlIG9wZXJhdGlvbnMgdXNpbmcgc2Vzc2lvbiBwYWNrYWdlXG4gKiBQcm92aWRlcyBhY2Nlc3MgdG8gYWdlbnQgYWNjb3VudCwgZGVsZWdhdGlvbiBzZXR1cCwgYW5kIHdhbGxldCBjbGllbnQgZm9yIGFnZW50IG9wZXJhdGlvbnNcbiAqL1xuaW1wb3J0IHsgVmllbUFjY291bnRQcm92aWRlciB9IGZyb20gJ0BhZ2VudGljLXRydXN0LzgwMDQtc2RrJztcbmltcG9ydCB7IGlzVXNlckFwcEVuYWJsZWQsIGxvZ1VzZXJBcHBJbml0U3RhcnQsIGxvZ1VzZXJBcHBJbml0RmFpbHVyZSwgbG9nVXNlckFwcEluaXRTdWNjZXNzIH0gZnJvbSAnLi91c2VyQXBwJztcbi8vIFNpbmdsZXRvbiBpbnN0YW5jZVxubGV0IHByb3ZpZGVyQXBwSW5zdGFuY2UgPSBudWxsO1xubGV0IGluaXRpYWxpemF0aW9uUHJvbWlzZSA9IG51bGw7XG4vKipcbiAqIEdldCBvciBjcmVhdGUgdGhlIFByb3ZpZGVyQXBwIHNpbmdsZXRvblxuICogSW5pdGlhbGl6ZXMgZnJvbSBzZXNzaW9uIHBhY2thZ2UgaW4gZW52aXJvbm1lbnQgdmFyaWFibGVzXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRQcm92aWRlckFwcCgpIHtcbiAgICAvLyBJZiBhbHJlYWR5IGluaXRpYWxpemVkLCByZXR1cm4gaW1tZWRpYXRlbHlcbiAgICBpZiAocHJvdmlkZXJBcHBJbnN0YW5jZSkge1xuICAgICAgICByZXR1cm4gcHJvdmlkZXJBcHBJbnN0YW5jZTtcbiAgICB9XG4gICAgLy8gSWYgaW5pdGlhbGl6YXRpb24gaXMgaW4gcHJvZ3Jlc3MsIHdhaXQgZm9yIGl0XG4gICAgaWYgKGluaXRpYWxpemF0aW9uUHJvbWlzZSkge1xuICAgICAgICByZXR1cm4gaW5pdGlhbGl6YXRpb25Qcm9taXNlO1xuICAgIH1cbiAgICAvLyBDaGVjayBpZiB0aGlzIGlzIGEgcHJvdmlkZXIgYXBwIChlbnZpcm9ubWVudCB2YXJpYWJsZSBmbGFnKVxuICAgIGlmICghaXNVc2VyQXBwRW5hYmxlZCgncHJvdmlkZXInKSkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBjb25zdCBzZXNzaW9uUGFja2FnZVBhdGggPSBwcm9jZXNzLmVudi5BR0VOVElDX1RSVVNUX1NFU1NJT05fUEFDS0FHRV9QQVRIO1xuICAgIGlmICghc2Vzc2lvblBhY2thZ2VQYXRoKSB7XG4gICAgICAgIC8vIFNlc3Npb24gcGFja2FnZSBtYXkgYmUgbG9hZGVkIGZyb20gZGF0YWJhc2UgaW5zdGVhZCBvZiBlbnYgdmFyXG4gICAgICAgIC8vIFNpbGVudGx5IHJldHVybiB1bmRlZmluZWQgLSBubyBlcnJvciBsb2dnaW5nIGFzIHRoaXMgaXMgZXhwZWN0ZWQgYmVoYXZpb3JcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLy8gU3RhcnQgaW5pdGlhbGl6YXRpb25cbiAgICBsb2dVc2VyQXBwSW5pdFN0YXJ0KCdwcm92aWRlcicpO1xuICAgIGluaXRpYWxpemF0aW9uUHJvbWlzZSA9IChhc3luYyAoKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBMb2FkIHNlc3Npb24gcGFja2FnZSBhbmQgYnVpbGQgZGVsZWdhdGlvbiBzZXR1cFxuICAgICAgICAgICAgY29uc3QgeyBsb2FkU2Vzc2lvblBhY2thZ2UsIGJ1aWxkRGVsZWdhdGlvblNldHVwLCBidWlsZEFnZW50QWNjb3VudEZyb21TZXNzaW9uIH0gPSBhd2FpdCBpbXBvcnQoJy4uL2xpYi9zZXNzaW9uUGFja2FnZScpO1xuICAgICAgICAgICAgY29uc3Qgc2Vzc2lvblBhY2thZ2UgPSBsb2FkU2Vzc2lvblBhY2thZ2Uoc2Vzc2lvblBhY2thZ2VQYXRoKTtcbiAgICAgICAgICAgIGNvbnN0IGRlbGVnYXRpb25TZXR1cCA9IGJ1aWxkRGVsZWdhdGlvblNldHVwKHNlc3Npb25QYWNrYWdlKTtcbiAgICAgICAgICAgIC8vIEdldCBhZ2VudCBhY2NvdW50IGZyb20gc2Vzc2lvbiBwYWNrYWdlXG4gICAgICAgICAgICBjb25zdCBhZ2VudEFjY291bnQgPSBhd2FpdCBidWlsZEFnZW50QWNjb3VudEZyb21TZXNzaW9uKHNlc3Npb25QYWNrYWdlKTtcbiAgICAgICAgICAgIC8vIENyZWF0ZSB3YWxsZXQgY2xpZW50IGZvciBhZ2VudFxuICAgICAgICAgICAgY29uc3QgeyBjcmVhdGVXYWxsZXRDbGllbnQsIGh0dHA6IGh0dHBUcmFuc3BvcnQgfSA9IGF3YWl0IGltcG9ydCgndmllbScpO1xuICAgICAgICAgICAgY29uc3Qgd2FsbGV0Q2xpZW50ID0gY3JlYXRlV2FsbGV0Q2xpZW50KHtcbiAgICAgICAgICAgICAgICBhY2NvdW50OiBhZ2VudEFjY291bnQsXG4gICAgICAgICAgICAgICAgY2hhaW46IGRlbGVnYXRpb25TZXR1cC5jaGFpbixcbiAgICAgICAgICAgICAgICB0cmFuc3BvcnQ6IGh0dHBUcmFuc3BvcnQoZGVsZWdhdGlvblNldHVwLnJwY1VybCksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBBY2NvdW50UHJvdmlkZXJcbiAgICAgICAgICAgIGNvbnN0IGFjY291bnRQcm92aWRlciA9IG5ldyBWaWVtQWNjb3VudFByb3ZpZGVyKHtcbiAgICAgICAgICAgICAgICBwdWJsaWNDbGllbnQ6IGRlbGVnYXRpb25TZXR1cC5wdWJsaWNDbGllbnQsXG4gICAgICAgICAgICAgICAgd2FsbGV0Q2xpZW50OiB3YWxsZXRDbGllbnQsXG4gICAgICAgICAgICAgICAgYWNjb3VudDogYWdlbnRBY2NvdW50LFxuICAgICAgICAgICAgICAgIGNoYWluQ29uZmlnOiB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBkZWxlZ2F0aW9uU2V0dXAuY2hhaW4uaWQsXG4gICAgICAgICAgICAgICAgICAgIHJwY1VybDogZGVsZWdhdGlvblNldHVwLnJwY1VybCxcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogZGVsZWdhdGlvblNldHVwLmNoYWluLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGNoYWluOiBkZWxlZ2F0aW9uU2V0dXAuY2hhaW4sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcHJvdmlkZXJBcHBJbnN0YW5jZSA9IHtcbiAgICAgICAgICAgICAgICBzZXNzaW9uUGFja2FnZSxcbiAgICAgICAgICAgICAgICBkZWxlZ2F0aW9uU2V0dXAsXG4gICAgICAgICAgICAgICAgYWdlbnRBY2NvdW50LFxuICAgICAgICAgICAgICAgIHB1YmxpY0NsaWVudDogZGVsZWdhdGlvblNldHVwLnB1YmxpY0NsaWVudCxcbiAgICAgICAgICAgICAgICB3YWxsZXRDbGllbnQ6IHdhbGxldENsaWVudCxcbiAgICAgICAgICAgICAgICBhY2NvdW50UHJvdmlkZXIsXG4gICAgICAgICAgICAgICAgYWdlbnRJZDogQmlnSW50KHNlc3Npb25QYWNrYWdlLmFnZW50SWQpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGxvZ1VzZXJBcHBJbml0U3VjY2VzcygncHJvdmlkZXInLCBzZXNzaW9uUGFja2FnZS5hZ2VudElkPy50b1N0cmluZygpKTtcbiAgICAgICAgICAgIHJldHVybiBwcm92aWRlckFwcEluc3RhbmNlO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgbG9nVXNlckFwcEluaXRGYWlsdXJlKCdwcm92aWRlcicsIGVycm9yKTtcbiAgICAgICAgICAgIGluaXRpYWxpemF0aW9uUHJvbWlzZSA9IG51bGw7IC8vIFJlc2V0IG9uIGVycm9yIHNvIGl0IGNhbiBiZSByZXRyaWVkXG4gICAgICAgICAgICAvLyBSZXR1cm4gdW5kZWZpbmVkIGluc3RlYWQgb2YgdGhyb3dpbmcgdG8gYWxsb3cgZ3JhY2VmdWwgZmFsbGJhY2tcbiAgICAgICAgICAgIC8vIChzZXNzaW9uIHBhY2thZ2UgbWF5IGJlIGxvYWRlZCBmcm9tIGRhdGFiYXNlIGluc3RlYWQpXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfSkoKTtcbiAgICByZXR1cm4gaW5pdGlhbGl6YXRpb25Qcm9taXNlO1xufVxuLyoqXG4gKiBHZXQgdGhlIGFnZW50IElEIChjb252ZW5pZW5jZSBtZXRob2QpXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRQcm92aWRlckFnZW50SWQoKSB7XG4gICAgY29uc3QgcHJvdmlkZXJBcHAgPSBhd2FpdCBnZXRQcm92aWRlckFwcCgpO1xuICAgIHJldHVybiBwcm92aWRlckFwcD8uYWdlbnRJZCA/PyBCaWdJbnQoMCk7XG59XG4vKipcbiAqIENoZWNrIGlmIHByb3ZpZGVyIGFwcCBpcyBpbml0aWFsaXplZFxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNQcm92aWRlckFwcEluaXRpYWxpemVkKCkge1xuICAgIHJldHVybiBwcm92aWRlckFwcEluc3RhbmNlICE9PSBudWxsO1xufVxuLyoqXG4gKiBSZXNldCB0aGUgc2luZ2xldG9uICh1c2VmdWwgZm9yIHRlc3RpbmcpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXNldFByb3ZpZGVyQXBwKCkge1xuICAgIHByb3ZpZGVyQXBwSW5zdGFuY2UgPSBudWxsO1xuICAgIGluaXRpYWxpemF0aW9uUHJvbWlzZSA9IG51bGw7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcm92aWRlckFwcC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@agentic-trust/core/dist/server/userApps/providerApp.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@agentic-trust/core/dist/server/userApps/userApp.js":
/*!******************************************************************************!*\
  !*** ../../node_modules/@agentic-trust/core/dist/server/userApps/userApp.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isUserAppEnabled: () => (/* binding */ isUserAppEnabled),\n/* harmony export */   logUserAppInitFailure: () => (/* binding */ logUserAppInitFailure),\n/* harmony export */   logUserAppInitStart: () => (/* binding */ logUserAppInitStart),\n/* harmony export */   logUserAppInitSuccess: () => (/* binding */ logUserAppInitSuccess)\n/* harmony export */ });\n/**\n * Base types and helpers for server-side user app singletons\n * (AdminApp, ClientApp, ProviderApp).\n *\n * Centralizes common env-flag handling and logging so individual\n * user apps can \"inherit\" shared behavior.\n */\n/**\n * Optional multi-role env flag.\n * Example: AGENTIC_TRUST_APP_ROLES=\"provider|client\"\n */\nconst ROLE_LIST_ENV_VAR = 'AGENTIC_TRUST_APP_ROLES';\n/**\n * Check if a given user app role is enabled based on its environment flag.\n *\n * Legacy (still supported for backwards-compatibility):\n * - admin     AGENTIC_TRUST_IS_ADMIN_APP\n * - client    AGENTIC_TRUST_IS_CLIENT_APP\n * - provider  AGENTIC_TRUST_IS_PROVIDER_APP\n *\n * Preferred: use AGENTIC_TRUST_APP_ROLES with a '|'separated list\n * of roles (e.g. \"provider|client\"). Falls back to legacy flags.\n */\nfunction isUserAppEnabled(role) {\n    // New style: AGENTIC_TRUST_APP_ROLES=\"provider|client\"\n    const rolesRaw = process.env[ROLE_LIST_ENV_VAR];\n    if (rolesRaw && rolesRaw.trim().length > 0) {\n        const roles = rolesRaw\n            .split('|')\n            .map((r) => r.trim().toLowerCase())\n            .filter(Boolean);\n        const roleName = role.toLowerCase();\n        if (roles.includes(roleName)) {\n            return true;\n        }\n    }\n    // Backwards-compatible: legacy boolean-ish flags per role\n    const legacyEnvVarName = role === 'admin'\n        ? 'AGENTIC_TRUST_IS_ADMIN_APP'\n        : role === 'client'\n            ? 'AGENTIC_TRUST_IS_CLIENT_APP'\n            : role === 'provider'\n                ? 'AGENTIC_TRUST_IS_PROVIDER_APP'\n                : 'AGENTIC_TRUST_IS_VALIDATOR_APP';\n    const raw = process.env[legacyEnvVarName];\n    if (!raw)\n        return false;\n    const value = raw.trim().toLowerCase();\n    return value === 'true' || value === '1';\n}\nfunction roleLabel(role) {\n    switch (role) {\n        case 'admin':\n            return 'AdminApp';\n        case 'client':\n            return 'ClientApp';\n        case 'provider':\n            return 'ProviderApp';\n        case 'validator':\n            return 'ValidatorApp';\n        default:\n            return 'UserApp';\n    }\n}\nfunction logUserAppInitStart(role, extra) {\n    const label = roleLabel(role);\n    if (extra) {\n        console.log(` ${label}: starting initialization...`, extra);\n    }\n    else {\n        console.log(` ${label}: starting initialization...`);\n    }\n}\nfunction logUserAppInitSuccess(role, detail) {\n    const label = roleLabel(role);\n    if (detail) {\n        console.log(` ${label} initialized:`, detail);\n    }\n    else {\n        console.log(` ${label} initialized`);\n    }\n}\nfunction logUserAppInitFailure(role, error) {\n    const label = roleLabel(role);\n    console.error(` Failed to initialize ${label}:`, error);\n}\n//# sourceMappingURL=userApp.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BhZ2VudGljLXRydXN0L2NvcmUvZGlzdC9zZXJ2ZXIvdXNlckFwcHMvdXNlckFwcC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSwwQkFBMEIsTUFBTTtBQUNoQztBQUNBO0FBQ0EsMEJBQTBCLE1BQU07QUFDaEM7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLHlCQUF5QixPQUFPO0FBQ2hDO0FBQ0E7QUFDQSx5QkFBeUIsT0FBTztBQUNoQztBQUNBO0FBQ087QUFDUDtBQUNBLDRDQUE0QyxNQUFNO0FBQ2xEO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL2JhcmIvYWEvQXNzb2NpYXRlZEFjY291bnRzL25vZGVfbW9kdWxlcy9AYWdlbnRpYy10cnVzdC9jb3JlL2Rpc3Qvc2VydmVyL3VzZXJBcHBzL3VzZXJBcHAuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBCYXNlIHR5cGVzIGFuZCBoZWxwZXJzIGZvciBzZXJ2ZXItc2lkZSB1c2VyIGFwcCBzaW5nbGV0b25zXG4gKiAoQWRtaW5BcHAsIENsaWVudEFwcCwgUHJvdmlkZXJBcHApLlxuICpcbiAqIENlbnRyYWxpemVzIGNvbW1vbiBlbnYtZmxhZyBoYW5kbGluZyBhbmQgbG9nZ2luZyBzbyBpbmRpdmlkdWFsXG4gKiB1c2VyIGFwcHMgY2FuIFwiaW5oZXJpdFwiIHNoYXJlZCBiZWhhdmlvci5cbiAqL1xuLyoqXG4gKiBPcHRpb25hbCBtdWx0aS1yb2xlIGVudiBmbGFnLlxuICogRXhhbXBsZTogQUdFTlRJQ19UUlVTVF9BUFBfUk9MRVM9XCJwcm92aWRlcnxjbGllbnRcIlxuICovXG5jb25zdCBST0xFX0xJU1RfRU5WX1ZBUiA9ICdBR0VOVElDX1RSVVNUX0FQUF9ST0xFUyc7XG4vKipcbiAqIENoZWNrIGlmIGEgZ2l2ZW4gdXNlciBhcHAgcm9sZSBpcyBlbmFibGVkIGJhc2VkIG9uIGl0cyBlbnZpcm9ubWVudCBmbGFnLlxuICpcbiAqIExlZ2FjeSAoc3RpbGwgc3VwcG9ydGVkIGZvciBiYWNrd2FyZHMtY29tcGF0aWJpbGl0eSk6XG4gKiAtIGFkbWluICAgIOKGkiBBR0VOVElDX1RSVVNUX0lTX0FETUlOX0FQUFxuICogLSBjbGllbnQgICDihpIgQUdFTlRJQ19UUlVTVF9JU19DTElFTlRfQVBQXG4gKiAtIHByb3ZpZGVyIOKGkiBBR0VOVElDX1RSVVNUX0lTX1BST1ZJREVSX0FQUFxuICpcbiAqIFByZWZlcnJlZDogdXNlIEFHRU5USUNfVFJVU1RfQVBQX1JPTEVTIHdpdGggYSAnfCfigJFzZXBhcmF0ZWQgbGlzdFxuICogb2Ygcm9sZXMgKGUuZy4gXCJwcm92aWRlcnxjbGllbnRcIikuIEZhbGxzIGJhY2sgdG8gbGVnYWN5IGZsYWdzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNVc2VyQXBwRW5hYmxlZChyb2xlKSB7XG4gICAgLy8gTmV3IHN0eWxlOiBBR0VOVElDX1RSVVNUX0FQUF9ST0xFUz1cInByb3ZpZGVyfGNsaWVudFwiXG4gICAgY29uc3Qgcm9sZXNSYXcgPSBwcm9jZXNzLmVudltST0xFX0xJU1RfRU5WX1ZBUl07XG4gICAgaWYgKHJvbGVzUmF3ICYmIHJvbGVzUmF3LnRyaW0oKS5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IHJvbGVzID0gcm9sZXNSYXdcbiAgICAgICAgICAgIC5zcGxpdCgnfCcpXG4gICAgICAgICAgICAubWFwKChyKSA9PiByLnRyaW0oKS50b0xvd2VyQ2FzZSgpKVxuICAgICAgICAgICAgLmZpbHRlcihCb29sZWFuKTtcbiAgICAgICAgY29uc3Qgcm9sZU5hbWUgPSByb2xlLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmIChyb2xlcy5pbmNsdWRlcyhyb2xlTmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEJhY2t3YXJkcy1jb21wYXRpYmxlOiBsZWdhY3kgYm9vbGVhbi1pc2ggZmxhZ3MgcGVyIHJvbGVcbiAgICBjb25zdCBsZWdhY3lFbnZWYXJOYW1lID0gcm9sZSA9PT0gJ2FkbWluJ1xuICAgICAgICA/ICdBR0VOVElDX1RSVVNUX0lTX0FETUlOX0FQUCdcbiAgICAgICAgOiByb2xlID09PSAnY2xpZW50J1xuICAgICAgICAgICAgPyAnQUdFTlRJQ19UUlVTVF9JU19DTElFTlRfQVBQJ1xuICAgICAgICAgICAgOiByb2xlID09PSAncHJvdmlkZXInXG4gICAgICAgICAgICAgICAgPyAnQUdFTlRJQ19UUlVTVF9JU19QUk9WSURFUl9BUFAnXG4gICAgICAgICAgICAgICAgOiAnQUdFTlRJQ19UUlVTVF9JU19WQUxJREFUT1JfQVBQJztcbiAgICBjb25zdCByYXcgPSBwcm9jZXNzLmVudltsZWdhY3lFbnZWYXJOYW1lXTtcbiAgICBpZiAoIXJhdylcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IHZhbHVlID0gcmF3LnRyaW0oKS50b0xvd2VyQ2FzZSgpO1xuICAgIHJldHVybiB2YWx1ZSA9PT0gJ3RydWUnIHx8IHZhbHVlID09PSAnMSc7XG59XG5mdW5jdGlvbiByb2xlTGFiZWwocm9sZSkge1xuICAgIHN3aXRjaCAocm9sZSkge1xuICAgICAgICBjYXNlICdhZG1pbic6XG4gICAgICAgICAgICByZXR1cm4gJ0FkbWluQXBwJztcbiAgICAgICAgY2FzZSAnY2xpZW50JzpcbiAgICAgICAgICAgIHJldHVybiAnQ2xpZW50QXBwJztcbiAgICAgICAgY2FzZSAncHJvdmlkZXInOlxuICAgICAgICAgICAgcmV0dXJuICdQcm92aWRlckFwcCc7XG4gICAgICAgIGNhc2UgJ3ZhbGlkYXRvcic6XG4gICAgICAgICAgICByZXR1cm4gJ1ZhbGlkYXRvckFwcCc7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gJ1VzZXJBcHAnO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBsb2dVc2VyQXBwSW5pdFN0YXJ0KHJvbGUsIGV4dHJhKSB7XG4gICAgY29uc3QgbGFiZWwgPSByb2xlTGFiZWwocm9sZSk7XG4gICAgaWYgKGV4dHJhKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGDwn5SnICR7bGFiZWx9OiBzdGFydGluZyBpbml0aWFsaXphdGlvbi4uLmAsIGV4dHJhKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGDwn5SnICR7bGFiZWx9OiBzdGFydGluZyBpbml0aWFsaXphdGlvbi4uLmApO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBsb2dVc2VyQXBwSW5pdFN1Y2Nlc3Mocm9sZSwgZGV0YWlsKSB7XG4gICAgY29uc3QgbGFiZWwgPSByb2xlTGFiZWwocm9sZSk7XG4gICAgaWYgKGRldGFpbCkge1xuICAgICAgICBjb25zb2xlLmxvZyhg4pyFICR7bGFiZWx9IGluaXRpYWxpemVkOmAsIGRldGFpbCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zb2xlLmxvZyhg4pyFICR7bGFiZWx9IGluaXRpYWxpemVkYCk7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGxvZ1VzZXJBcHBJbml0RmFpbHVyZShyb2xlLCBlcnJvcikge1xuICAgIGNvbnN0IGxhYmVsID0gcm9sZUxhYmVsKHJvbGUpO1xuICAgIGNvbnNvbGUuZXJyb3IoYOKdjCBGYWlsZWQgdG8gaW5pdGlhbGl6ZSAke2xhYmVsfTpgLCBlcnJvcik7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD11c2VyQXBwLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@agentic-trust/core/dist/server/userApps/userApp.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@agentic-trust/core/dist/server/userApps/validatorApp.js":
/*!***********************************************************************************!*\
  !*** ../../node_modules/@agentic-trust/core/dist/server/userApps/validatorApp.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getValidatorAddress: () => (/* binding */ getValidatorAddress),\n/* harmony export */   getValidatorApp: () => (/* binding */ getValidatorApp),\n/* harmony export */   hasValidatorPrivateKey: () => (/* binding */ hasValidatorPrivateKey),\n/* harmony export */   isValidatorAppInitialized: () => (/* binding */ isValidatorAppInitialized),\n/* harmony export */   resetValidatorApp: () => (/* binding */ resetValidatorApp)\n/* harmony export */ });\n/* harmony import */ var _agentic_trust_8004_sdk__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @agentic-trust/8004-sdk */ \"(rsc)/../../node_modules/@agentic-trust/8004-sdk/dist/index.js\");\n/* harmony import */ var _lib_chainConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/chainConfig */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/lib/chainConfig.js\");\n/* harmony import */ var _userApp__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./userApp */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/userApps/userApp.js\");\n/**\n * Validator App Singleton\n *\n * Manages a singleton instance for validator-side operations using private key\n * Provides access to validator account, wallet client, and validator address\n * Used for processing ENS validation requests\n */\n\n\n\n// Singleton instance (per chain)\nconst validatorAppInstances = new Map();\nconst initializationPromises = new Map();\n/**\n * Check if the validator private key is configured in environment.\n */\nfunction hasValidatorPrivateKey() {\n    const value = process.env.AGENTIC_TRUST_VALIDATOR_PRIVATE_KEY;\n    return typeof value === 'string' && value.trim().length > 0;\n}\n/**\n * Get or create the ValidatorApp instance\n * Initializes from private key in environment variables\n *\n * @param chainId - Chain ID (defaults to DEFAULT_CHAIN_ID)\n */\nasync function getValidatorApp(chainId = _lib_chainConfig__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_CHAIN_ID) {\n    const instanceKey = `validator:${chainId}`;\n    // If already initialized for this chain, return immediately\n    const existingInstance = validatorAppInstances.get(instanceKey);\n    if (existingInstance) {\n        return existingInstance;\n    }\n    // If initialization is in progress for this chain, wait for it\n    const existingPromise = initializationPromises.get(instanceKey);\n    if (existingPromise) {\n        return existingPromise;\n    }\n    // Start initialization for this chain\n    const initializationPromise = (async () => {\n        try {\n            // Check if this is a validator app (environment flag)\n            if (!(0,_userApp__WEBPACK_IMPORTED_MODULE_2__.isUserAppEnabled)('validator')) {\n                throw new Error('ValidatorApp is only available when AGENTIC_TRUST_APP_ROLES includes \"validator\"');\n            }\n            (0,_userApp__WEBPACK_IMPORTED_MODULE_2__.logUserAppInitStart)('validator', `chainId=${chainId}`);\n            // Try to get validator private key from sessionPackage first, then fall back to environment variable\n            let privateKey;\n            // Try sessionPackage first (same as feedbackAuth uses)\n            try {\n                const sessionPackagePath = process.env.AGENTIC_TRUST_SESSION_PACKAGE_PATH;\n                if (sessionPackagePath) {\n                    const { loadSessionPackage } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ../lib/sessionPackage */ \"(rsc)/../../node_modules/@agentic-trust/core/dist/server/lib/sessionPackage.js\"));\n                    const sessionPackage = loadSessionPackage(sessionPackagePath);\n                    if (sessionPackage?.sessionKey?.privateKey) {\n                        privateKey = sessionPackage.sessionKey.privateKey;\n                        console.log('[ValidatorApp] Using private key from sessionPackage');\n                    }\n                }\n            }\n            catch (sessionError) {\n                // If sessionPackage loading fails, fall through to environment variable\n                console.warn('[ValidatorApp] Failed to load sessionPackage, falling back to environment variable:', sessionError);\n            }\n            // Fall back to environment variable if sessionPackage didn't provide a key\n            if (!privateKey) {\n                privateKey = process.env.AGENTIC_TRUST_VALIDATOR_PRIVATE_KEY;\n                if (privateKey) {\n                    console.log('[ValidatorApp] Using private key from AGENTIC_TRUST_VALIDATOR_PRIVATE_KEY environment variable');\n                }\n            }\n            if (!privateKey) {\n                console.warn('ValidatorApp role is enabled but no private key found. ' +\n                    'Set either AGENTIC_TRUST_SESSION_PACKAGE_PATH (with sessionKey.privateKey) or AGENTIC_TRUST_VALIDATOR_PRIVATE_KEY. ' +\n                    'Skipping ValidatorApp initialization for this process.');\n                validatorAppInstances.delete(instanceKey);\n                initializationPromises.delete(instanceKey);\n                return undefined;\n            }\n            // Get chain-specific RPC URL and chain config\n            const targetChainId = chainId || _lib_chainConfig__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_CHAIN_ID;\n            const rpcUrl = (0,_lib_chainConfig__WEBPACK_IMPORTED_MODULE_1__.getChainRpcUrl)(targetChainId);\n            if (!rpcUrl) {\n                throw new Error(`Missing required RPC URL. Configure AGENTIC_TRUST_RPC_URL_{CHAIN} for chainId ${targetChainId}`);\n            }\n            const { createPublicClient, createWalletClient, http: httpTransport } = await Promise.all(/*! import() */[__webpack_require__.e(\"vendor-chunks/viem\"), __webpack_require__.e(\"vendor-chunks/abitype\")]).then(__webpack_require__.bind(__webpack_require__, /*! viem */ \"(rsc)/../../node_modules/viem/_esm/index.js\"));\n            const chain = (0,_lib_chainConfig__WEBPACK_IMPORTED_MODULE_1__.getChainById)(targetChainId);\n            // Create public client (always needed)\n            const publicClient = createPublicClient({\n                chain,\n                transport: httpTransport(rpcUrl),\n            });\n            // Create wallet client and account from private key\n            const { privateKeyToAccount } = await Promise.all(/*! import() */[__webpack_require__.e(\"vendor-chunks/viem\"), __webpack_require__.e(\"vendor-chunks/@noble\")]).then(__webpack_require__.bind(__webpack_require__, /*! viem/accounts */ \"(rsc)/../../node_modules/viem/_esm/accounts/index.js\"));\n            const normalizedKey = privateKey.startsWith('0x') ? privateKey : `0x${privateKey}`;\n            const account = privateKeyToAccount(normalizedKey);\n            const address = account.address;\n            const walletClient = createWalletClient({\n                account,\n                chain,\n                transport: httpTransport(rpcUrl),\n            });\n            // Create AccountProvider\n            const accountProvider = new _agentic_trust_8004_sdk__WEBPACK_IMPORTED_MODULE_0__.ViemAccountProvider({\n                publicClient,\n                walletClient: walletClient,\n                account,\n                chainConfig: {\n                    id: chain.id,\n                    rpcUrl,\n                    name: chain.name,\n                    chain,\n                },\n            });\n            const instance = {\n                account,\n                publicClient: publicClient,\n                walletClient: walletClient,\n                accountProvider,\n                address,\n                hasPrivateKey: true,\n            };\n            // Store instance by chain key\n            validatorAppInstances.set(instanceKey, instance);\n            initializationPromises.delete(instanceKey); // Remove from pending\n            (0,_userApp__WEBPACK_IMPORTED_MODULE_2__.logUserAppInitSuccess)('validator', address);\n            return instance;\n        }\n        catch (error) {\n            (0,_userApp__WEBPACK_IMPORTED_MODULE_2__.logUserAppInitFailure)('validator', error);\n            initializationPromises.delete(instanceKey); // Remove from pending on error\n            throw error;\n        }\n    })();\n    // Store promise for this chain\n    initializationPromises.set(instanceKey, initializationPromise);\n    return initializationPromise;\n}\n/**\n * Get the validator address (convenience method)\n */\nasync function getValidatorAddress(chainId = _lib_chainConfig__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_CHAIN_ID) {\n    const validatorApp = await getValidatorApp(chainId);\n    return validatorApp?.address;\n}\n/**\n * Check if validator app is initialized for a specific chain\n */\nfunction isValidatorAppInitialized(chainId) {\n    if (chainId !== undefined) {\n        const instanceKey = `validator:${chainId}`;\n        return validatorAppInstances.has(instanceKey);\n    }\n    return validatorAppInstances.size > 0;\n}\n/**\n * Reset validator app instances (useful for testing)\n * @param chainId - Optional chain ID to reset specific instance, or all if not provided\n */\nfunction resetValidatorApp(chainId) {\n    if (chainId !== undefined) {\n        const instanceKey = `validator:${chainId}`;\n        validatorAppInstances.delete(instanceKey);\n        initializationPromises.delete(instanceKey);\n    }\n    else {\n        validatorAppInstances.clear();\n        initializationPromises.clear();\n    }\n}\n//# sourceMappingURL=validatorApp.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BhZ2VudGljLXRydXN0L2NvcmUvZGlzdC9zZXJ2ZXIvdXNlckFwcHMvdmFsaWRhdG9yQXBwLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDOEQ7QUFDc0I7QUFDNEI7QUFDaEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyx5Q0FBeUMsOERBQWdCO0FBQ2hFLHFDQUFxQyxRQUFRO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsMERBQWdCO0FBQ2pDO0FBQ0E7QUFDQSxZQUFZLDZEQUFtQix5QkFBeUIsUUFBUTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIscUJBQXFCLFFBQVEsbU1BQStCO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2Qyw4REFBZ0I7QUFDN0QsMkJBQTJCLGdFQUFjO0FBQ3pDO0FBQ0EsNEZBQTRGLE9BQU8sY0FBYyxjQUFjO0FBQy9IO0FBQ0Esb0JBQW9CLDhEQUE4RCxRQUFRLHdPQUFjO0FBQ3hHLDBCQUEwQiw4REFBWTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLG9CQUFvQixzQkFBc0IsUUFBUSx5UEFBdUI7QUFDekUsa0ZBQWtGLFdBQVc7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0Esd0NBQXdDLHdFQUFtQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RCxZQUFZLCtEQUFxQjtBQUNqQztBQUNBO0FBQ0E7QUFDQSxZQUFZLCtEQUFxQjtBQUNqQyx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLDZDQUE2Qyw4REFBZ0I7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLHlDQUF5QyxRQUFRO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EseUNBQXlDLFFBQVE7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9iYXJiL2FhL0Fzc29jaWF0ZWRBY2NvdW50cy9ub2RlX21vZHVsZXMvQGFnZW50aWMtdHJ1c3QvY29yZS9kaXN0L3NlcnZlci91c2VyQXBwcy92YWxpZGF0b3JBcHAuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBWYWxpZGF0b3IgQXBwIFNpbmdsZXRvblxuICpcbiAqIE1hbmFnZXMgYSBzaW5nbGV0b24gaW5zdGFuY2UgZm9yIHZhbGlkYXRvci1zaWRlIG9wZXJhdGlvbnMgdXNpbmcgcHJpdmF0ZSBrZXlcbiAqIFByb3ZpZGVzIGFjY2VzcyB0byB2YWxpZGF0b3IgYWNjb3VudCwgd2FsbGV0IGNsaWVudCwgYW5kIHZhbGlkYXRvciBhZGRyZXNzXG4gKiBVc2VkIGZvciBwcm9jZXNzaW5nIEVOUyB2YWxpZGF0aW9uIHJlcXVlc3RzXG4gKi9cbmltcG9ydCB7IFZpZW1BY2NvdW50UHJvdmlkZXIgfSBmcm9tICdAYWdlbnRpYy10cnVzdC84MDA0LXNkayc7XG5pbXBvcnQgeyBnZXRDaGFpbkJ5SWQsIGdldENoYWluUnBjVXJsLCBERUZBVUxUX0NIQUlOX0lEIH0gZnJvbSAnLi4vbGliL2NoYWluQ29uZmlnJztcbmltcG9ydCB7IGlzVXNlckFwcEVuYWJsZWQsIGxvZ1VzZXJBcHBJbml0RmFpbHVyZSwgbG9nVXNlckFwcEluaXRTdGFydCwgbG9nVXNlckFwcEluaXRTdWNjZXNzIH0gZnJvbSAnLi91c2VyQXBwJztcbi8vIFNpbmdsZXRvbiBpbnN0YW5jZSAocGVyIGNoYWluKVxuY29uc3QgdmFsaWRhdG9yQXBwSW5zdGFuY2VzID0gbmV3IE1hcCgpO1xuY29uc3QgaW5pdGlhbGl6YXRpb25Qcm9taXNlcyA9IG5ldyBNYXAoKTtcbi8qKlxuICogQ2hlY2sgaWYgdGhlIHZhbGlkYXRvciBwcml2YXRlIGtleSBpcyBjb25maWd1cmVkIGluIGVudmlyb25tZW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gaGFzVmFsaWRhdG9yUHJpdmF0ZUtleSgpIHtcbiAgICBjb25zdCB2YWx1ZSA9IHByb2Nlc3MuZW52LkFHRU5USUNfVFJVU1RfVkFMSURBVE9SX1BSSVZBVEVfS0VZO1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIHZhbHVlLnRyaW0oKS5sZW5ndGggPiAwO1xufVxuLyoqXG4gKiBHZXQgb3IgY3JlYXRlIHRoZSBWYWxpZGF0b3JBcHAgaW5zdGFuY2VcbiAqIEluaXRpYWxpemVzIGZyb20gcHJpdmF0ZSBrZXkgaW4gZW52aXJvbm1lbnQgdmFyaWFibGVzXG4gKlxuICogQHBhcmFtIGNoYWluSWQgLSBDaGFpbiBJRCAoZGVmYXVsdHMgdG8gREVGQVVMVF9DSEFJTl9JRClcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFZhbGlkYXRvckFwcChjaGFpbklkID0gREVGQVVMVF9DSEFJTl9JRCkge1xuICAgIGNvbnN0IGluc3RhbmNlS2V5ID0gYHZhbGlkYXRvcjoke2NoYWluSWR9YDtcbiAgICAvLyBJZiBhbHJlYWR5IGluaXRpYWxpemVkIGZvciB0aGlzIGNoYWluLCByZXR1cm4gaW1tZWRpYXRlbHlcbiAgICBjb25zdCBleGlzdGluZ0luc3RhbmNlID0gdmFsaWRhdG9yQXBwSW5zdGFuY2VzLmdldChpbnN0YW5jZUtleSk7XG4gICAgaWYgKGV4aXN0aW5nSW5zdGFuY2UpIHtcbiAgICAgICAgcmV0dXJuIGV4aXN0aW5nSW5zdGFuY2U7XG4gICAgfVxuICAgIC8vIElmIGluaXRpYWxpemF0aW9uIGlzIGluIHByb2dyZXNzIGZvciB0aGlzIGNoYWluLCB3YWl0IGZvciBpdFxuICAgIGNvbnN0IGV4aXN0aW5nUHJvbWlzZSA9IGluaXRpYWxpemF0aW9uUHJvbWlzZXMuZ2V0KGluc3RhbmNlS2V5KTtcbiAgICBpZiAoZXhpc3RpbmdQcm9taXNlKSB7XG4gICAgICAgIHJldHVybiBleGlzdGluZ1Byb21pc2U7XG4gICAgfVxuICAgIC8vIFN0YXJ0IGluaXRpYWxpemF0aW9uIGZvciB0aGlzIGNoYWluXG4gICAgY29uc3QgaW5pdGlhbGl6YXRpb25Qcm9taXNlID0gKGFzeW5jICgpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoaXMgaXMgYSB2YWxpZGF0b3IgYXBwIChlbnZpcm9ubWVudCBmbGFnKVxuICAgICAgICAgICAgaWYgKCFpc1VzZXJBcHBFbmFibGVkKCd2YWxpZGF0b3InKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVmFsaWRhdG9yQXBwIGlzIG9ubHkgYXZhaWxhYmxlIHdoZW4gQUdFTlRJQ19UUlVTVF9BUFBfUk9MRVMgaW5jbHVkZXMgXCJ2YWxpZGF0b3JcIicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9nVXNlckFwcEluaXRTdGFydCgndmFsaWRhdG9yJywgYGNoYWluSWQ9JHtjaGFpbklkfWApO1xuICAgICAgICAgICAgLy8gVHJ5IHRvIGdldCB2YWxpZGF0b3IgcHJpdmF0ZSBrZXkgZnJvbSBzZXNzaW9uUGFja2FnZSBmaXJzdCwgdGhlbiBmYWxsIGJhY2sgdG8gZW52aXJvbm1lbnQgdmFyaWFibGVcbiAgICAgICAgICAgIGxldCBwcml2YXRlS2V5O1xuICAgICAgICAgICAgLy8gVHJ5IHNlc3Npb25QYWNrYWdlIGZpcnN0IChzYW1lIGFzIGZlZWRiYWNrQXV0aCB1c2VzKVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzZXNzaW9uUGFja2FnZVBhdGggPSBwcm9jZXNzLmVudi5BR0VOVElDX1RSVVNUX1NFU1NJT05fUEFDS0FHRV9QQVRIO1xuICAgICAgICAgICAgICAgIGlmIChzZXNzaW9uUGFja2FnZVBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBsb2FkU2Vzc2lvblBhY2thZ2UgfSA9IGF3YWl0IGltcG9ydCgnLi4vbGliL3Nlc3Npb25QYWNrYWdlJyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlc3Npb25QYWNrYWdlID0gbG9hZFNlc3Npb25QYWNrYWdlKHNlc3Npb25QYWNrYWdlUGF0aCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZXNzaW9uUGFja2FnZT8uc2Vzc2lvbktleT8ucHJpdmF0ZUtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJpdmF0ZUtleSA9IHNlc3Npb25QYWNrYWdlLnNlc3Npb25LZXkucHJpdmF0ZUtleTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdbVmFsaWRhdG9yQXBwXSBVc2luZyBwcml2YXRlIGtleSBmcm9tIHNlc3Npb25QYWNrYWdlJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoc2Vzc2lvbkVycm9yKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgc2Vzc2lvblBhY2thZ2UgbG9hZGluZyBmYWlscywgZmFsbCB0aHJvdWdoIHRvIGVudmlyb25tZW50IHZhcmlhYmxlXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdbVmFsaWRhdG9yQXBwXSBGYWlsZWQgdG8gbG9hZCBzZXNzaW9uUGFja2FnZSwgZmFsbGluZyBiYWNrIHRvIGVudmlyb25tZW50IHZhcmlhYmxlOicsIHNlc3Npb25FcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBGYWxsIGJhY2sgdG8gZW52aXJvbm1lbnQgdmFyaWFibGUgaWYgc2Vzc2lvblBhY2thZ2UgZGlkbid0IHByb3ZpZGUgYSBrZXlcbiAgICAgICAgICAgIGlmICghcHJpdmF0ZUtleSkge1xuICAgICAgICAgICAgICAgIHByaXZhdGVLZXkgPSBwcm9jZXNzLmVudi5BR0VOVElDX1RSVVNUX1ZBTElEQVRPUl9QUklWQVRFX0tFWTtcbiAgICAgICAgICAgICAgICBpZiAocHJpdmF0ZUtleSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnW1ZhbGlkYXRvckFwcF0gVXNpbmcgcHJpdmF0ZSBrZXkgZnJvbSBBR0VOVElDX1RSVVNUX1ZBTElEQVRPUl9QUklWQVRFX0tFWSBlbnZpcm9ubWVudCB2YXJpYWJsZScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcHJpdmF0ZUtleSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignVmFsaWRhdG9yQXBwIHJvbGUgaXMgZW5hYmxlZCBidXQgbm8gcHJpdmF0ZSBrZXkgZm91bmQuICcgK1xuICAgICAgICAgICAgICAgICAgICAnU2V0IGVpdGhlciBBR0VOVElDX1RSVVNUX1NFU1NJT05fUEFDS0FHRV9QQVRIICh3aXRoIHNlc3Npb25LZXkucHJpdmF0ZUtleSkgb3IgQUdFTlRJQ19UUlVTVF9WQUxJREFUT1JfUFJJVkFURV9LRVkuICcgK1xuICAgICAgICAgICAgICAgICAgICAnU2tpcHBpbmcgVmFsaWRhdG9yQXBwIGluaXRpYWxpemF0aW9uIGZvciB0aGlzIHByb2Nlc3MuJyk7XG4gICAgICAgICAgICAgICAgdmFsaWRhdG9yQXBwSW5zdGFuY2VzLmRlbGV0ZShpbnN0YW5jZUtleSk7XG4gICAgICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25Qcm9taXNlcy5kZWxldGUoaW5zdGFuY2VLZXkpO1xuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBHZXQgY2hhaW4tc3BlY2lmaWMgUlBDIFVSTCBhbmQgY2hhaW4gY29uZmlnXG4gICAgICAgICAgICBjb25zdCB0YXJnZXRDaGFpbklkID0gY2hhaW5JZCB8fCBERUZBVUxUX0NIQUlOX0lEO1xuICAgICAgICAgICAgY29uc3QgcnBjVXJsID0gZ2V0Q2hhaW5ScGNVcmwodGFyZ2V0Q2hhaW5JZCk7XG4gICAgICAgICAgICBpZiAoIXJwY1VybCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTWlzc2luZyByZXF1aXJlZCBSUEMgVVJMLiBDb25maWd1cmUgQUdFTlRJQ19UUlVTVF9SUENfVVJMX3tDSEFJTn0gZm9yIGNoYWluSWQgJHt0YXJnZXRDaGFpbklkfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyBjcmVhdGVQdWJsaWNDbGllbnQsIGNyZWF0ZVdhbGxldENsaWVudCwgaHR0cDogaHR0cFRyYW5zcG9ydCB9ID0gYXdhaXQgaW1wb3J0KCd2aWVtJyk7XG4gICAgICAgICAgICBjb25zdCBjaGFpbiA9IGdldENoYWluQnlJZCh0YXJnZXRDaGFpbklkKTtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBwdWJsaWMgY2xpZW50IChhbHdheXMgbmVlZGVkKVxuICAgICAgICAgICAgY29uc3QgcHVibGljQ2xpZW50ID0gY3JlYXRlUHVibGljQ2xpZW50KHtcbiAgICAgICAgICAgICAgICBjaGFpbixcbiAgICAgICAgICAgICAgICB0cmFuc3BvcnQ6IGh0dHBUcmFuc3BvcnQocnBjVXJsKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gQ3JlYXRlIHdhbGxldCBjbGllbnQgYW5kIGFjY291bnQgZnJvbSBwcml2YXRlIGtleVxuICAgICAgICAgICAgY29uc3QgeyBwcml2YXRlS2V5VG9BY2NvdW50IH0gPSBhd2FpdCBpbXBvcnQoJ3ZpZW0vYWNjb3VudHMnKTtcbiAgICAgICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRLZXkgPSBwcml2YXRlS2V5LnN0YXJ0c1dpdGgoJzB4JykgPyBwcml2YXRlS2V5IDogYDB4JHtwcml2YXRlS2V5fWA7XG4gICAgICAgICAgICBjb25zdCBhY2NvdW50ID0gcHJpdmF0ZUtleVRvQWNjb3VudChub3JtYWxpemVkS2V5KTtcbiAgICAgICAgICAgIGNvbnN0IGFkZHJlc3MgPSBhY2NvdW50LmFkZHJlc3M7XG4gICAgICAgICAgICBjb25zdCB3YWxsZXRDbGllbnQgPSBjcmVhdGVXYWxsZXRDbGllbnQoe1xuICAgICAgICAgICAgICAgIGFjY291bnQsXG4gICAgICAgICAgICAgICAgY2hhaW4sXG4gICAgICAgICAgICAgICAgdHJhbnNwb3J0OiBodHRwVHJhbnNwb3J0KHJwY1VybCksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBBY2NvdW50UHJvdmlkZXJcbiAgICAgICAgICAgIGNvbnN0IGFjY291bnRQcm92aWRlciA9IG5ldyBWaWVtQWNjb3VudFByb3ZpZGVyKHtcbiAgICAgICAgICAgICAgICBwdWJsaWNDbGllbnQsXG4gICAgICAgICAgICAgICAgd2FsbGV0Q2xpZW50OiB3YWxsZXRDbGllbnQsXG4gICAgICAgICAgICAgICAgYWNjb3VudCxcbiAgICAgICAgICAgICAgICBjaGFpbkNvbmZpZzoge1xuICAgICAgICAgICAgICAgICAgICBpZDogY2hhaW4uaWQsXG4gICAgICAgICAgICAgICAgICAgIHJwY1VybCxcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogY2hhaW4ubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgY2hhaW4sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgaW5zdGFuY2UgPSB7XG4gICAgICAgICAgICAgICAgYWNjb3VudCxcbiAgICAgICAgICAgICAgICBwdWJsaWNDbGllbnQ6IHB1YmxpY0NsaWVudCxcbiAgICAgICAgICAgICAgICB3YWxsZXRDbGllbnQ6IHdhbGxldENsaWVudCxcbiAgICAgICAgICAgICAgICBhY2NvdW50UHJvdmlkZXIsXG4gICAgICAgICAgICAgICAgYWRkcmVzcyxcbiAgICAgICAgICAgICAgICBoYXNQcml2YXRlS2V5OiB0cnVlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIFN0b3JlIGluc3RhbmNlIGJ5IGNoYWluIGtleVxuICAgICAgICAgICAgdmFsaWRhdG9yQXBwSW5zdGFuY2VzLnNldChpbnN0YW5jZUtleSwgaW5zdGFuY2UpO1xuICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25Qcm9taXNlcy5kZWxldGUoaW5zdGFuY2VLZXkpOyAvLyBSZW1vdmUgZnJvbSBwZW5kaW5nXG4gICAgICAgICAgICBsb2dVc2VyQXBwSW5pdFN1Y2Nlc3MoJ3ZhbGlkYXRvcicsIGFkZHJlc3MpO1xuICAgICAgICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgbG9nVXNlckFwcEluaXRGYWlsdXJlKCd2YWxpZGF0b3InLCBlcnJvcik7XG4gICAgICAgICAgICBpbml0aWFsaXphdGlvblByb21pc2VzLmRlbGV0ZShpbnN0YW5jZUtleSk7IC8vIFJlbW92ZSBmcm9tIHBlbmRpbmcgb24gZXJyb3JcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfSkoKTtcbiAgICAvLyBTdG9yZSBwcm9taXNlIGZvciB0aGlzIGNoYWluXG4gICAgaW5pdGlhbGl6YXRpb25Qcm9taXNlcy5zZXQoaW5zdGFuY2VLZXksIGluaXRpYWxpemF0aW9uUHJvbWlzZSk7XG4gICAgcmV0dXJuIGluaXRpYWxpemF0aW9uUHJvbWlzZTtcbn1cbi8qKlxuICogR2V0IHRoZSB2YWxpZGF0b3IgYWRkcmVzcyAoY29udmVuaWVuY2UgbWV0aG9kKVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0VmFsaWRhdG9yQWRkcmVzcyhjaGFpbklkID0gREVGQVVMVF9DSEFJTl9JRCkge1xuICAgIGNvbnN0IHZhbGlkYXRvckFwcCA9IGF3YWl0IGdldFZhbGlkYXRvckFwcChjaGFpbklkKTtcbiAgICByZXR1cm4gdmFsaWRhdG9yQXBwPy5hZGRyZXNzO1xufVxuLyoqXG4gKiBDaGVjayBpZiB2YWxpZGF0b3IgYXBwIGlzIGluaXRpYWxpemVkIGZvciBhIHNwZWNpZmljIGNoYWluXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1ZhbGlkYXRvckFwcEluaXRpYWxpemVkKGNoYWluSWQpIHtcbiAgICBpZiAoY2hhaW5JZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IGluc3RhbmNlS2V5ID0gYHZhbGlkYXRvcjoke2NoYWluSWR9YDtcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRvckFwcEluc3RhbmNlcy5oYXMoaW5zdGFuY2VLZXkpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsaWRhdG9yQXBwSW5zdGFuY2VzLnNpemUgPiAwO1xufVxuLyoqXG4gKiBSZXNldCB2YWxpZGF0b3IgYXBwIGluc3RhbmNlcyAodXNlZnVsIGZvciB0ZXN0aW5nKVxuICogQHBhcmFtIGNoYWluSWQgLSBPcHRpb25hbCBjaGFpbiBJRCB0byByZXNldCBzcGVjaWZpYyBpbnN0YW5jZSwgb3IgYWxsIGlmIG5vdCBwcm92aWRlZFxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVzZXRWYWxpZGF0b3JBcHAoY2hhaW5JZCkge1xuICAgIGlmIChjaGFpbklkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgaW5zdGFuY2VLZXkgPSBgdmFsaWRhdG9yOiR7Y2hhaW5JZH1gO1xuICAgICAgICB2YWxpZGF0b3JBcHBJbnN0YW5jZXMuZGVsZXRlKGluc3RhbmNlS2V5KTtcbiAgICAgICAgaW5pdGlhbGl6YXRpb25Qcm9taXNlcy5kZWxldGUoaW5zdGFuY2VLZXkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFsaWRhdG9yQXBwSW5zdGFuY2VzLmNsZWFyKCk7XG4gICAgICAgIGluaXRpYWxpemF0aW9uUHJvbWlzZXMuY2xlYXIoKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD12YWxpZGF0b3JBcHAuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@agentic-trust/core/dist/server/userApps/validatorApp.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@agentic-trust/core/dist/shared/did8004.js":
/*!*********************************************************************!*\
  !*** ../../node_modules/@agentic-trust/core/dist/shared/did8004.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   buildDid8004: () => (/* reexport safe */ _agentic_trust_8004_ext_sdk__WEBPACK_IMPORTED_MODULE_0__.buildDid8004),\n/* harmony export */   normalizeDid8004: () => (/* binding */ normalizeDid8004),\n/* harmony export */   parseDid8004: () => (/* binding */ parseDid8004),\n/* harmony export */   resolveDid8004: () => (/* reexport safe */ _agentic_trust_8004_ext_sdk__WEBPACK_IMPORTED_MODULE_0__.resolveDid8004)\n/* harmony export */ });\n/* harmony import */ var _agentic_trust_8004_ext_sdk__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @agentic-trust/8004-ext-sdk */ \"(rsc)/../../node_modules/@agentic-trust/8004-ext-sdk/dist/index.js\");\n\nfunction normalizeDidInput(value) {\n    if (!value) {\n        return value;\n    }\n    let normalized = value.trim();\n    if (normalized.includes('%')) {\n        try {\n            normalized = decodeURIComponent(normalized);\n        }\n        catch {\n            // ignore decode errors, fall back to original\n        }\n    }\n    // Some filesystems encode \":\" as U+F03A (private-use)\n    normalized = normalized.replace(/\\uF03A/g, ':');\n    return normalized;\n}\nfunction parseDid8004(value) {\n    return (0,_agentic_trust_8004_ext_sdk__WEBPACK_IMPORTED_MODULE_0__.parseDid8004)(normalizeDidInput(value));\n}\n\nconst normalizeDid8004 = normalizeDidInput;\n//# sourceMappingURL=did8004.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BhZ2VudGljLXRydXN0L2NvcmUvZGlzdC9zaGFyZWQvZGlkODAwNC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUE4RztBQUM5RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxXQUFXLHlFQUFnQjtBQUMzQjtBQUN3QztBQUNqQztBQUNQIiwic291cmNlcyI6WyIvaG9tZS9iYXJiL2FhL0Fzc29jaWF0ZWRBY2NvdW50cy9ub2RlX21vZHVsZXMvQGFnZW50aWMtdHJ1c3QvY29yZS9kaXN0L3NoYXJlZC9kaWQ4MDA0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGJ1aWxkRGlkODAwNCwgcGFyc2VEaWQ4MDA0IGFzIGJhc2VQYXJzZURpZDgwMDQsIHJlc29sdmVEaWQ4MDA0LCB9IGZyb20gJ0BhZ2VudGljLXRydXN0LzgwMDQtZXh0LXNkayc7XG5mdW5jdGlvbiBub3JtYWxpemVEaWRJbnB1dCh2YWx1ZSkge1xuICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBsZXQgbm9ybWFsaXplZCA9IHZhbHVlLnRyaW0oKTtcbiAgICBpZiAobm9ybWFsaXplZC5pbmNsdWRlcygnJScpKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBub3JtYWxpemVkID0gZGVjb2RlVVJJQ29tcG9uZW50KG5vcm1hbGl6ZWQpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIHtcbiAgICAgICAgICAgIC8vIGlnbm9yZSBkZWNvZGUgZXJyb3JzLCBmYWxsIGJhY2sgdG8gb3JpZ2luYWxcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBTb21lIGZpbGVzeXN0ZW1zIGVuY29kZSBcIjpcIiBhcyBVK0YwM0EgKHByaXZhdGUtdXNlKVxuICAgIG5vcm1hbGl6ZWQgPSBub3JtYWxpemVkLnJlcGxhY2UoL1xcdUYwM0EvZywgJzonKTtcbiAgICByZXR1cm4gbm9ybWFsaXplZDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZURpZDgwMDQodmFsdWUpIHtcbiAgICByZXR1cm4gYmFzZVBhcnNlRGlkODAwNChub3JtYWxpemVEaWRJbnB1dCh2YWx1ZSkpO1xufVxuZXhwb3J0IHsgYnVpbGREaWQ4MDA0LCByZXNvbHZlRGlkODAwNCB9O1xuZXhwb3J0IGNvbnN0IG5vcm1hbGl6ZURpZDgwMDQgPSBub3JtYWxpemVEaWRJbnB1dDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRpZDgwMDQuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@agentic-trust/core/dist/shared/did8004.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@agentic-trust/core/dist/shared/didEns.js":
/*!********************************************************************!*\
  !*** ../../node_modules/@agentic-trust/core/dist/shared/didEns.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   buildDidEns: () => (/* reexport safe */ _agentic_trust_8004_ext_sdk__WEBPACK_IMPORTED_MODULE_0__.buildEnsDid),\n/* harmony export */   buildDidEnsFromAgentAndOrg: () => (/* reexport safe */ _agentic_trust_8004_ext_sdk__WEBPACK_IMPORTED_MODULE_0__.buildEnsDidFromAgentAndOrg),\n/* harmony export */   buildEnsDid: () => (/* reexport safe */ _agentic_trust_8004_ext_sdk__WEBPACK_IMPORTED_MODULE_0__.buildEnsDid),\n/* harmony export */   buildEnsDidFromAgentAndOrg: () => (/* reexport safe */ _agentic_trust_8004_ext_sdk__WEBPACK_IMPORTED_MODULE_0__.buildEnsDidFromAgentAndOrg),\n/* harmony export */   parseDidEns: () => (/* reexport safe */ _agentic_trust_8004_ext_sdk__WEBPACK_IMPORTED_MODULE_0__.parseEnsDid),\n/* harmony export */   parseEnsDid: () => (/* reexport safe */ _agentic_trust_8004_ext_sdk__WEBPACK_IMPORTED_MODULE_0__.parseEnsDid)\n/* harmony export */ });\n/* harmony import */ var _agentic_trust_8004_ext_sdk__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @agentic-trust/8004-ext-sdk */ \"(rsc)/../../node_modules/@agentic-trust/8004-ext-sdk/dist/index.js\");\n\n// Preferred Did-then-method aliases\n\n//# sourceMappingURL=didEns.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BhZ2VudGljLXRydXN0L2NvcmUvZGlzdC9zaGFyZWQvZGlkRW5zLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBb0c7QUFDcEc7QUFDZ0s7QUFDaEsiLCJzb3VyY2VzIjpbIi9ob21lL2JhcmIvYWEvQXNzb2NpYXRlZEFjY291bnRzL25vZGVfbW9kdWxlcy9AYWdlbnRpYy10cnVzdC9jb3JlL2Rpc3Qvc2hhcmVkL2RpZEVucy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgeyBidWlsZEVuc0RpZCwgYnVpbGRFbnNEaWRGcm9tQWdlbnRBbmRPcmcsIHBhcnNlRW5zRGlkLCB9IGZyb20gJ0BhZ2VudGljLXRydXN0LzgwMDQtZXh0LXNkayc7XG4vLyBQcmVmZXJyZWQgRGlkLXRoZW4tbWV0aG9kIGFsaWFzZXNcbmV4cG9ydCB7IGJ1aWxkRW5zRGlkIGFzIGJ1aWxkRGlkRW5zLCBidWlsZEVuc0RpZEZyb21BZ2VudEFuZE9yZyBhcyBidWlsZERpZEVuc0Zyb21BZ2VudEFuZE9yZywgcGFyc2VFbnNEaWQgYXMgcGFyc2VEaWRFbnMsIH0gZnJvbSAnQGFnZW50aWMtdHJ1c3QvODAwNC1leHQtc2RrJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRpZEVucy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@agentic-trust/core/dist/shared/didEns.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@agentic-trust/core/dist/shared/didEthr.js":
/*!*********************************************************************!*\
  !*** ../../node_modules/@agentic-trust/core/dist/shared/didEthr.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   buildDidEthr: () => (/* reexport safe */ _agentic_trust_8004_ext_sdk__WEBPACK_IMPORTED_MODULE_0__.buildEthrDid),\n/* harmony export */   buildEthrDid: () => (/* reexport safe */ _agentic_trust_8004_ext_sdk__WEBPACK_IMPORTED_MODULE_0__.buildEthrDid),\n/* harmony export */   parseDidEthr: () => (/* reexport safe */ _agentic_trust_8004_ext_sdk__WEBPACK_IMPORTED_MODULE_0__.parseEthrDid),\n/* harmony export */   parseEthrDid: () => (/* reexport safe */ _agentic_trust_8004_ext_sdk__WEBPACK_IMPORTED_MODULE_0__.parseEthrDid)\n/* harmony export */ });\n/* harmony import */ var _agentic_trust_8004_ext_sdk__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @agentic-trust/8004-ext-sdk */ \"(rsc)/../../node_modules/@agentic-trust/8004-ext-sdk/dist/index.js\");\n\n// Preferred Did-then-method aliases\n\n//# sourceMappingURL=didEthr.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BhZ2VudGljLXRydXN0L2NvcmUvZGlzdC9zaGFyZWQvZGlkRXRoci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUEwRTtBQUMxRTtBQUMwRztBQUMxRyIsInNvdXJjZXMiOlsiL2hvbWUvYmFyYi9hYS9Bc3NvY2lhdGVkQWNjb3VudHMvbm9kZV9tb2R1bGVzL0BhZ2VudGljLXRydXN0L2NvcmUvZGlzdC9zaGFyZWQvZGlkRXRoci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgeyBidWlsZEV0aHJEaWQsIHBhcnNlRXRockRpZCwgfSBmcm9tICdAYWdlbnRpYy10cnVzdC84MDA0LWV4dC1zZGsnO1xuLy8gUHJlZmVycmVkIERpZC10aGVuLW1ldGhvZCBhbGlhc2VzXG5leHBvcnQgeyBidWlsZEV0aHJEaWQgYXMgYnVpbGREaWRFdGhyLCBwYXJzZUV0aHJEaWQgYXMgcGFyc2VEaWRFdGhyLCB9IGZyb20gJ0BhZ2VudGljLXRydXN0LzgwMDQtZXh0LXNkayc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kaWRFdGhyLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@agentic-trust/core/dist/shared/didEthr.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@agentic-trust/veramo-agent-extension/dist/index.js":
/*!******************************************************************************!*\
  !*** ../../node_modules/@agentic-trust/veramo-agent-extension/dist/index.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AACredentialIssuerEIP1271: () => (/* reexport safe */ _utils_AACredentialIssuerEIP1271_js__WEBPACK_IMPORTED_MODULE_1__.AACredentialIssuerEIP1271),\n/* harmony export */   AADidProvider: () => (/* reexport safe */ _utils_AADidProvider_js__WEBPACK_IMPORTED_MODULE_6__.AADidProvider),\n/* harmony export */   AAKeyManagementSystem: () => (/* reexport safe */ _utils_AAKeyManagementSystem_js__WEBPACK_IMPORTED_MODULE_5__.AAKeyManagementSystem),\n/* harmony export */   AAKmsSigner: () => (/* reexport safe */ _utils_AAKmsSigner_js__WEBPACK_IMPORTED_MODULE_4__.AAKmsSigner),\n/* harmony export */   AgentCredentialIssuerEIP1271: () => (/* reexport safe */ _utils_AgentCredentialIssuerEIP1271_js__WEBPACK_IMPORTED_MODULE_2__.AgentCredentialIssuerEIP1271),\n/* harmony export */   AgentDidProvider: () => (/* reexport safe */ _utils_AgentDidProvider_js__WEBPACK_IMPORTED_MODULE_11__.AgentDidProvider),\n/* harmony export */   AgentKeyManagementSystem: () => (/* reexport safe */ _utils_AgentKeyManagementSystem_js__WEBPACK_IMPORTED_MODULE_10__.AgentKeyManagementSystem),\n/* harmony export */   AgentKmsSigner: () => (/* reexport safe */ _utils_AgentKmsSigner_js__WEBPACK_IMPORTED_MODULE_9__.AgentKmsSigner),\n/* harmony export */   compareAgentId: () => (/* reexport safe */ _utils_AgentKeyManagementSystem_js__WEBPACK_IMPORTED_MODULE_10__.compareAgentId),\n/* harmony export */   compareBlockchainAccountId: () => (/* reexport safe */ _utils_AAKeyManagementSystem_js__WEBPACK_IMPORTED_MODULE_5__.compareBlockchainAccountId),\n/* harmony export */   compressAAIdentifierSecp256k1Keys: () => (/* reexport safe */ _utils_AAKeyManagementSystem_js__WEBPACK_IMPORTED_MODULE_5__.compressAAIdentifierSecp256k1Keys),\n/* harmony export */   compressAgentIdentifierSecp256k1Keys: () => (/* reexport safe */ _utils_AgentKeyManagementSystem_js__WEBPACK_IMPORTED_MODULE_10__.compressAgentIdentifierSecp256k1Keys),\n/* harmony export */   convertAAIdentifierEncryptionKeys: () => (/* reexport safe */ _utils_AAKeyManagementSystem_js__WEBPACK_IMPORTED_MODULE_5__.convertAAIdentifierEncryptionKeys),\n/* harmony export */   convertAgentIdentifierEncryptionKeys: () => (/* reexport safe */ _utils_AgentKeyManagementSystem_js__WEBPACK_IMPORTED_MODULE_10__.convertAgentIdentifierEncryptionKeys),\n/* harmony export */   getAAEthereumAddress: () => (/* reexport safe */ _utils_AAKeyManagementSystem_js__WEBPACK_IMPORTED_MODULE_5__.getAAEthereumAddress),\n/* harmony export */   getAAResolver: () => (/* reexport safe */ _utils_AAResolver_js__WEBPACK_IMPORTED_MODULE_7__.getAAResolver),\n/* harmony export */   getAgentEthereumAddress: () => (/* reexport safe */ _utils_AgentKeyManagementSystem_js__WEBPACK_IMPORTED_MODULE_10__.getAgentEthereumAddress),\n/* harmony export */   getAgentResolver: () => (/* reexport safe */ _utils_AgentResolver_js__WEBPACK_IMPORTED_MODULE_12__.getAgentResolver),\n/* harmony export */   getPublicClient: () => (/* reexport safe */ _utils_IdentityRegistry_js__WEBPACK_IMPORTED_MODULE_13__.getPublicClient),\n/* harmony export */   getRegistryAgent: () => (/* reexport safe */ _utils_IdentityRegistry_js__WEBPACK_IMPORTED_MODULE_13__.getRegistryAgent),\n/* harmony export */   identityRegistryAbi: () => (/* reexport safe */ _utils_IdentityRegistry_js__WEBPACK_IMPORTED_MODULE_13__.identityRegistryAbi),\n/* harmony export */   mapAAIdentifierKeysToDoc: () => (/* reexport safe */ _utils_AAKeyManagementSystem_js__WEBPACK_IMPORTED_MODULE_5__.mapAAIdentifierKeysToDoc),\n/* harmony export */   mapAgentIdentifierKeysToDoc: () => (/* reexport safe */ _utils_AgentKeyManagementSystem_js__WEBPACK_IMPORTED_MODULE_10__.mapAgentIdentifierKeysToDoc)\n/* harmony export */ });\n/* harmony import */ var _utils_ICredentialEIP1271_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/ICredentialEIP1271.js */ \"(rsc)/../../node_modules/@agentic-trust/veramo-agent-extension/dist/utils/ICredentialEIP1271.js\");\n/* harmony import */ var _utils_AACredentialIssuerEIP1271_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/AACredentialIssuerEIP1271.js */ \"(rsc)/../../node_modules/@agentic-trust/veramo-agent-extension/dist/utils/AACredentialIssuerEIP1271.js\");\n/* harmony import */ var _utils_AgentCredentialIssuerEIP1271_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/AgentCredentialIssuerEIP1271.js */ \"(rsc)/../../node_modules/@agentic-trust/veramo-agent-extension/dist/utils/AgentCredentialIssuerEIP1271.js\");\n/* harmony import */ var _utils_AATypes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/AATypes.js */ \"(rsc)/../../node_modules/@agentic-trust/veramo-agent-extension/dist/utils/AATypes.js\");\n/* harmony import */ var _utils_AAKmsSigner_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils/AAKmsSigner.js */ \"(rsc)/../../node_modules/@agentic-trust/veramo-agent-extension/dist/utils/AAKmsSigner.js\");\n/* harmony import */ var _utils_AAKeyManagementSystem_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utils/AAKeyManagementSystem.js */ \"(rsc)/../../node_modules/@agentic-trust/veramo-agent-extension/dist/utils/AAKeyManagementSystem.js\");\n/* harmony import */ var _utils_AADidProvider_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utils/AADidProvider.js */ \"(rsc)/../../node_modules/@agentic-trust/veramo-agent-extension/dist/utils/AADidProvider.js\");\n/* harmony import */ var _utils_AAResolver_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./utils/AAResolver.js */ \"(rsc)/../../node_modules/@agentic-trust/veramo-agent-extension/dist/utils/AAResolver.js\");\n/* harmony import */ var _utils_AgentTypes_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./utils/AgentTypes.js */ \"(rsc)/../../node_modules/@agentic-trust/veramo-agent-extension/dist/utils/AgentTypes.js\");\n/* harmony import */ var _utils_AgentKmsSigner_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./utils/AgentKmsSigner.js */ \"(rsc)/../../node_modules/@agentic-trust/veramo-agent-extension/dist/utils/AgentKmsSigner.js\");\n/* harmony import */ var _utils_AgentKeyManagementSystem_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./utils/AgentKeyManagementSystem.js */ \"(rsc)/../../node_modules/@agentic-trust/veramo-agent-extension/dist/utils/AgentKeyManagementSystem.js\");\n/* harmony import */ var _utils_AgentDidProvider_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./utils/AgentDidProvider.js */ \"(rsc)/../../node_modules/@agentic-trust/veramo-agent-extension/dist/utils/AgentDidProvider.js\");\n/* harmony import */ var _utils_AgentResolver_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./utils/AgentResolver.js */ \"(rsc)/../../node_modules/@agentic-trust/veramo-agent-extension/dist/utils/AgentResolver.js\");\n/* harmony import */ var _utils_IdentityRegistry_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./utils/IdentityRegistry.js */ \"(rsc)/../../node_modules/@agentic-trust/veramo-agent-extension/dist/utils/IdentityRegistry.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BhZ2VudGljLXRydXN0L3ZlcmFtby1hZ2VudC1leHRlbnNpb24vZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQThDO0FBQ087QUFDRztBQUNyQjtBQUNJO0FBQ1U7QUFDUjtBQUNIO0FBQ0E7QUFDSTtBQUNVO0FBQ1I7QUFDSDtBQUNHO0FBQzVDIiwic291cmNlcyI6WyIvaG9tZS9iYXJiL2FhL0Fzc29jaWF0ZWRBY2NvdW50cy9ub2RlX21vZHVsZXMvQGFnZW50aWMtdHJ1c3QvdmVyYW1vLWFnZW50LWV4dGVuc2lvbi9kaXN0L2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCAqIGZyb20gJy4vdXRpbHMvSUNyZWRlbnRpYWxFSVAxMjcxLmpzJztcbmV4cG9ydCAqIGZyb20gJy4vdXRpbHMvQUFDcmVkZW50aWFsSXNzdWVyRUlQMTI3MS5qcyc7XG5leHBvcnQgKiBmcm9tICcuL3V0aWxzL0FnZW50Q3JlZGVudGlhbElzc3VlckVJUDEyNzEuanMnO1xuZXhwb3J0ICogZnJvbSAnLi91dGlscy9BQVR5cGVzLmpzJztcbmV4cG9ydCAqIGZyb20gJy4vdXRpbHMvQUFLbXNTaWduZXIuanMnO1xuZXhwb3J0ICogZnJvbSAnLi91dGlscy9BQUtleU1hbmFnZW1lbnRTeXN0ZW0uanMnO1xuZXhwb3J0ICogZnJvbSAnLi91dGlscy9BQURpZFByb3ZpZGVyLmpzJztcbmV4cG9ydCAqIGZyb20gJy4vdXRpbHMvQUFSZXNvbHZlci5qcyc7XG5leHBvcnQgKiBmcm9tICcuL3V0aWxzL0FnZW50VHlwZXMuanMnO1xuZXhwb3J0ICogZnJvbSAnLi91dGlscy9BZ2VudEttc1NpZ25lci5qcyc7XG5leHBvcnQgKiBmcm9tICcuL3V0aWxzL0FnZW50S2V5TWFuYWdlbWVudFN5c3RlbS5qcyc7XG5leHBvcnQgKiBmcm9tICcuL3V0aWxzL0FnZW50RGlkUHJvdmlkZXIuanMnO1xuZXhwb3J0ICogZnJvbSAnLi91dGlscy9BZ2VudFJlc29sdmVyLmpzJztcbmV4cG9ydCAqIGZyb20gJy4vdXRpbHMvSWRlbnRpdHlSZWdpc3RyeS5qcyc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@agentic-trust/veramo-agent-extension/dist/index.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@agentic-trust/veramo-agent-extension/dist/utils/AACredentialIssuerEIP1271.js":
/*!********************************************************************************************************!*\
  !*** ../../node_modules/@agentic-trust/veramo-agent-extension/dist/utils/AACredentialIssuerEIP1271.js ***!
  \********************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AACredentialIssuerEIP1271: () => (/* binding */ AACredentialIssuerEIP1271)\n/* harmony export */ });\n/* harmony import */ var _veramo_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @veramo/utils */ \"(rsc)/../../node_modules/@veramo/utils/build/index.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ethers */ \"(rsc)/../../node_modules/ethers/lib.esm/hash/typed-data.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! viem */ \"(rsc)/../../node_modules/viem/_esm/utils/abi/encodeFunctionData.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! viem */ \"(rsc)/../../node_modules/viem/_esm/clients/createPublicClient.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! viem */ \"(rsc)/../../node_modules/viem/_esm/clients/transports/http.js\");\n/* harmony import */ var viem_chains__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! viem/chains */ \"(rsc)/../../node_modules/viem/_esm/chains/definitions/sepolia.js\");\n/* harmony import */ var eip_712_types_generation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! eip-712-types-generation */ \"(rsc)/../../node_modules/eip-712-types-generation/dist/index.js\");\n\n\n\n\nconst chain = viem_chains__WEBPACK_IMPORTED_MODULE_1__.sepolia;\n\nclass AACredentialIssuerEIP1271 {\n    methods;\n    constructor() {\n        this.methods = {\n            createVerifiableCredentialEIP1271: this.createVerifiableCredentialEIP1271.bind(this),\n            createVerifiablePresentationEIP1271: this.createVerifiablePresentationEIP1271.bind(this),\n            verifyCredentialEIP1271: this.verifyCredentialEIP1271.bind(this),\n            verifyPresentationEIP1271: this.verifyPresentationEIP1271.bind(this),\n        };\n    }\n    parseAADid(didUrl) {\n        const [baseDid, fragment] = didUrl.split(\"#\");\n        if (!baseDid) {\n            throw new Error(`Invalid DID format: ${didUrl}`);\n        }\n        const parts = baseDid.split(\":\");\n        if (parts.length !== 5 || parts[0] !== \"did\" || parts[1] !== \"aa\") {\n            throw new Error(`Invalid did:8004 format 2: ${didUrl}`);\n        }\n        const [, method, namespace, chainId, address] = parts;\n        if (!method || !namespace || !chainId || !address) {\n            throw new Error(`Invalid DID parts: ${didUrl}`);\n        }\n        return {\n            did: baseDid,\n            method,\n            namespace,\n            chainId,\n            address,\n            fragment,\n        };\n    }\n    async createVerifiableCredentialEIP1271(args, context) {\n        const credentialContext = (0,_veramo_utils__WEBPACK_IMPORTED_MODULE_0__.processEntryToArray)(args?.credential?.['@context'], _veramo_utils__WEBPACK_IMPORTED_MODULE_0__.MANDATORY_CREDENTIAL_CONTEXT);\n        const credentialType = (0,_veramo_utils__WEBPACK_IMPORTED_MODULE_0__.processEntryToArray)(args?.credential?.type, 'VerifiableCredential');\n        let issuanceDate = args?.credential?.issuanceDate || new Date().toISOString();\n        if (issuanceDate instanceof Date) {\n            issuanceDate = issuanceDate.toISOString();\n        }\n        const issuer = args.credential.issuer;\n        if (!issuer || typeof issuer === 'string') {\n            throw new Error('Issuer must be an object with an \"id\" and \"did\" signer');\n        }\n        console.info(\"Creating Verifiable Credential EIP1271 with issuer:\", issuer);\n        const identifier = await context.agent.didManagerGet({ did: issuer.id });\n        const aaDidParts = this.parseAADid(identifier.did);\n        let chainId;\n        try {\n            chainId = aaDidParts.chainId;\n        }\n        catch (e) {\n            chainId = 11155111;\n        }\n        // point to a DID controller that supports smart contract-based signature verification\n        const credential = {\n            ...args?.credential,\n            '@context': credentialContext,\n            type: credentialType,\n            issuanceDate,\n            proof: {\n                verificationMethod: identifier.did + \"#ethereumAddress\",\n                created: issuanceDate,\n                proofPurpose: 'assertionMethod',\n                type: 'EthereumEip712Signature2021',\n            },\n        };\n        const message = credential;\n        const domain = {\n            chainId,\n            name: 'VerifiableCredential',\n            version: '1',\n        };\n        const primaryType = 'VerifiableCredential';\n        const allTypes = (0,eip_712_types_generation__WEBPACK_IMPORTED_MODULE_2__.getEthTypesFromInputDoc)(credential, primaryType);\n        const types = { ...allTypes };\n        const signature = await args?.signer?.signTypedData(domain, types, message);\n        credential['proof']['proofValue'] = signature;\n        credential['proof']['eip712'] = {\n            domain,\n            types: allTypes,\n            primaryType,\n        };\n        return credential;\n    }\n    async createVerifiablePresentationEIP1271(args, context) {\n        console.info(\"Creating Verifiable Presentation EIP1271 with args:\", args);\n        const presentationContext = (0,_veramo_utils__WEBPACK_IMPORTED_MODULE_0__.processEntryToArray)(args?.presentation?.['@context'], _veramo_utils__WEBPACK_IMPORTED_MODULE_0__.MANDATORY_CREDENTIAL_CONTEXT);\n        const presentationType = (0,_veramo_utils__WEBPACK_IMPORTED_MODULE_0__.processEntryToArray)(args?.presentation?.type, 'VerifiablePresentation');\n        let issuanceDate = args?.presentation?.issuanceDate || new Date().toISOString();\n        if (issuanceDate instanceof Date) {\n            issuanceDate = issuanceDate.toISOString();\n        }\n        const presentation = {\n            ...args?.presentation,\n            '@context': presentationContext,\n            type: presentationType,\n            issuanceDate,\n        };\n        if (!(0,_veramo_utils__WEBPACK_IMPORTED_MODULE_0__.isDefined)(args.presentation.holder)) {\n            throw new Error('invalid_argument: presentation.holder must not be empty');\n        }\n        if (args.presentation.verifiableCredential) {\n            presentation.verifiableCredential = args.presentation.verifiableCredential.map((cred) => {\n                // map JWT credentials to their canonical form\n                if (typeof cred === 'string') {\n                    return cred;\n                }\n                else if (cred.proof.jwt) {\n                    return cred.proof.jwt;\n                }\n                else {\n                    return JSON.stringify(cred);\n                }\n            });\n        }\n        const holder = (0,_veramo_utils__WEBPACK_IMPORTED_MODULE_0__.removeDIDParameters)(presentation.holder);\n        let identifier;\n        try {\n            identifier = await context.agent.didManagerGet({ did: holder });\n        }\n        catch (e) {\n            throw new Error('invalid_argument: presentation.holder must be a DID managed by this agent');\n        }\n        console.info(\"identifier: \", identifier);\n        const aaDidParts = this.parseAADid(identifier.did);\n        let chainId;\n        try {\n            chainId = aaDidParts.chainId;\n        }\n        catch (e) {\n            chainId = 11155111;\n        }\n        presentation['proof'] = {\n            verificationMethod: aaDidParts.address + \"#ethereumAddress\",\n            created: issuanceDate,\n            proofPurpose: 'assertionMethod',\n            type: 'EthereumEip712Signature2021',\n        };\n        const message = presentation;\n        const domain = {\n            chainId,\n            name: 'VerifiablePresentation',\n            version: '1',\n        };\n        const primaryType = 'VerifiablePresentation';\n        const allTypes = (0,eip_712_types_generation__WEBPACK_IMPORTED_MODULE_2__.getEthTypesFromInputDoc)(presentation, primaryType);\n        const types = { ...allTypes };\n        const signature = await args?.signer?.signTypedData(domain, types, message);\n        presentation.proof.proofValue = signature;\n        presentation.proof.eip712 = {\n            domain,\n            types: allTypes,\n            primaryType,\n        };\n        return presentation;\n    }\n    async verifyCredentialEIP1271(args, context) {\n        console.info(\"verifyCredentialEIP1271 called with args: \", args);\n        // check that proof exists\n        const { credential } = args;\n        if (!credential.proof || !credential.proof.proofValue)\n            throw new Error('invalid_argument: proof is undefined');\n        const { proof, ...signingInput } = credential;\n        const { proofValue, eip712, ...verifyInputProof } = proof;\n        const verificationMessage = {\n            ...signingInput,\n            proof: verifyInputProof,\n        };\n        const compat = {\n            ...eip712,\n        };\n        compat.types = compat.types || compat.messageSchema;\n        if (!compat.primaryType || !compat.types || !compat.domain) {\n            throw new Error('invalid_argument: proof is missing expected properties');\n        }\n        const filteredTypes = { ...compat.types };\n        delete filteredTypes.EIP712Domain;\n        const digest = ethers__WEBPACK_IMPORTED_MODULE_3__.TypedDataEncoder.hash(compat.domain, filteredTypes, verificationMessage);\n        const signature = proofValue;\n        console.info(\"............... signature: \", signature);\n        console.info(\"............... digest: \", digest);\n        const isValidSignatureData = (0,viem__WEBPACK_IMPORTED_MODULE_4__.encodeFunctionData)({\n            abi: [\n                {\n                    name: \"isValidSignature\",\n                    type: \"function\",\n                    inputs: [\n                        { name: \"_hash\", type: \"bytes32\" },\n                        { name: \"_signature\", type: \"bytes\" },\n                    ],\n                    outputs: [{ type: \"bytes4\" }],\n                    stateMutability: \"view\",\n                },\n            ],\n            functionName: \"isValidSignature\",\n            args: [digest, signature],\n        });\n        const publicClient = (0,viem__WEBPACK_IMPORTED_MODULE_5__.createPublicClient)({\n            chain: chain,\n            transport: (0,viem__WEBPACK_IMPORTED_MODULE_6__.http)(),\n        });\n        const did = credential.issuer.id;\n        console.info(\">>>>>>>>>>>> credential issuer did: \", did);\n        const address = this.parseAADid(did).address;\n        console.info(\"address used to validate signature: \", address);\n        // validate signature using contract EIP-1271\n        const { data: isValidSignature } = await publicClient.call({\n            account: address,\n            data: isValidSignatureData,\n            to: address,\n        });\n        console.info(\"isValidSignature: \", isValidSignature);\n        if (!isValidSignature?.startsWith('0x1626ba7e')) {\n            console.info(\"********** Verifiable Credential Signature is not valid according to EIP-1271\");\n            return false;\n        }\n        console.info(\"signature is valid according to EIP-1271\");\n        // verify the issuer did\n        const issuer = (0,_veramo_utils__WEBPACK_IMPORTED_MODULE_0__.extractIssuer)(credential);\n        if (!issuer || typeof issuer === 'undefined') {\n            throw new Error('invalid_argument: credential.issuer must not be empty');\n        }\n        const aa = await context.agent.resolveDid({ didUrl: issuer, options: args.resolutionOptions });\n        const didDocument = await (0,_veramo_utils__WEBPACK_IMPORTED_MODULE_0__.resolveDidOrThrow)(issuer, context, args.resolutionOptions);\n        if (didDocument.verificationMethod && address) {\n            for (const verificationMethod of didDocument.verificationMethod) {\n                const ethAddress = (0,_veramo_utils__WEBPACK_IMPORTED_MODULE_0__.getEthereumAddress)(verificationMethod)?.toLowerCase();\n                if (ethAddress === address.toLowerCase()) {\n                    return true;\n                }\n            }\n        }\n        else {\n            throw new Error('resolver_error: issuer DIDDocument does not contain any verificationMethods');\n        }\n        return false;\n    }\n    async verifyPresentationEIP1271(args, context) {\n        // check that proof exists\n        const { presentation } = args;\n        if (!presentation.proof || !presentation.proof.proofValue)\n            throw new Error('invalid_argument: proof is undefined');\n        const { proof, ...signingInput } = presentation;\n        const { proofValue, eip712, ...verifyInputProof } = proof;\n        const verificationMessage = {\n            ...signingInput,\n            proof: verifyInputProof,\n        };\n        const compat = {\n            ...eip712,\n        };\n        compat.types = compat.types || compat.messageSchema;\n        if (!compat.primaryType || !compat.types || !compat.domain)\n            throw new Error('invalid_argument: proof is missing expected properties');\n        const filteredTypes = { ...compat.types };\n        delete filteredTypes.EIP712Domain;\n        const digest = ethers__WEBPACK_IMPORTED_MODULE_3__.TypedDataEncoder.hash(compat.domain, filteredTypes, verificationMessage);\n        const signature = proofValue;\n        const isValidSignatureData = (0,viem__WEBPACK_IMPORTED_MODULE_4__.encodeFunctionData)({\n            abi: [\n                {\n                    name: \"isValidSignature\",\n                    type: \"function\",\n                    inputs: [\n                        { name: \"_hash\", type: \"bytes32\" },\n                        { name: \"_signature\", type: \"bytes\" },\n                    ],\n                    outputs: [{ type: \"bytes4\" }],\n                    stateMutability: \"view\",\n                },\n            ],\n            functionName: \"isValidSignature\",\n            args: [digest, signature],\n        });\n        const publicClient = (0,viem__WEBPACK_IMPORTED_MODULE_5__.createPublicClient)({\n            chain: chain,\n            transport: (0,viem__WEBPACK_IMPORTED_MODULE_6__.http)(),\n        });\n        const clientAddress = this.parseAADid(presentation.holder).address;\n        // validate signature using contract EIP-1271\n        const { data: isValidSignature } = await publicClient.call({\n            account: clientAddress,\n            data: isValidSignatureData,\n            to: clientAddress,\n        });\n        if (!isValidSignature?.startsWith('0x1626ba7e')) {\n            console.info(\"*********** Verifiable Presentation Signature is not valid according to EIP-1271\");\n            console.info(\"isValidSignature: \", isValidSignature);\n            return false;\n        }\n        // verify the client did\n        const clientDid = (0,_veramo_utils__WEBPACK_IMPORTED_MODULE_0__.extractIssuer)(presentation);\n        if (!clientDid || typeof clientDid === 'undefined') {\n            throw new Error('invalid_argument: presentation.holder must not be empty');\n        }\n        console.info(\"gator client Agent Did: \", clientDid);\n        const clientDidDocument = await (0,_veramo_utils__WEBPACK_IMPORTED_MODULE_0__.resolveDidOrThrow)(clientDid, context, args.resolutionOptions);\n        if (clientDidDocument.verificationMethod && clientAddress) {\n            console.info(\"gator client didDocument.verificationMethod: \", clientDidDocument.verificationMethod);\n            for (const verificationMethod of clientDidDocument.verificationMethod) {\n                console.info(\"verificationMethod: \", verificationMethod);\n                const ethAddress = (0,_veramo_utils__WEBPACK_IMPORTED_MODULE_0__.getEthereumAddress)(verificationMethod)?.toLowerCase();\n                console.info(\"ethAddress: \", ethAddress);\n                if ((0,_veramo_utils__WEBPACK_IMPORTED_MODULE_0__.getEthereumAddress)(verificationMethod)?.toLowerCase() === clientAddress.toLowerCase()) {\n                    return true;\n                }\n            }\n        }\n        else {\n            throw new Error('resolver_error: holder DIDDocument does not contain any verificationMethods');\n        }\n        return false;\n    }\n}\n//# sourceMappingURL=AACredentialIssuerEIP1271.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BhZ2VudGljLXRydXN0L3ZlcmFtby1hZ2VudC1leHRlbnNpb24vZGlzdC91dGlscy9BQUNyZWRlbnRpYWxJc3N1ZXJFSVAxMjcxLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBR29GO0FBQ3pDO0FBQzBCO0FBQy9CO0FBQ3RDLGNBQWMsZ0RBQU87QUFDOEM7QUFDNUQ7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsT0FBTztBQUMxRDtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsT0FBTztBQUNqRTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsT0FBTztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGtFQUFtQixpQ0FBaUMsdUVBQTRCO0FBQ2xILCtCQUErQixrRUFBbUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELGdCQUFnQjtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGlGQUF1QjtBQUNoRCx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxrRUFBbUIsbUNBQW1DLHVFQUE0QjtBQUN0SCxpQ0FBaUMsa0VBQW1CO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSx3REFBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsdUJBQXVCLGtFQUFtQjtBQUMxQztBQUNBO0FBQ0EsNkRBQTZELGFBQWE7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixpRkFBdUI7QUFDaEQsd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixhQUFhO0FBQzdCO0FBQ0E7QUFDQSxnQkFBZ0IseUJBQXlCO0FBQ3pDLGdCQUFnQiwwQ0FBMEM7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBLHVCQUF1QixvREFBZ0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLHdEQUFrQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGdDQUFnQztBQUMxRCwwQkFBMEIsbUNBQW1DO0FBQzdEO0FBQ0EsZ0NBQWdDLGdCQUFnQjtBQUNoRDtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsNkJBQTZCLHdEQUFrQjtBQUMvQztBQUNBLHVCQUF1QiwwQ0FBSTtBQUMzQixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix5QkFBeUI7QUFDekM7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDREQUFhO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxpREFBaUQ7QUFDckcsa0NBQWtDLGdFQUFpQjtBQUNuRDtBQUNBO0FBQ0EsbUNBQW1DLGlFQUFrQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZUFBZTtBQUMvQjtBQUNBO0FBQ0EsZ0JBQWdCLHlCQUF5QjtBQUN6QyxnQkFBZ0IsMENBQTBDO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0EsdUJBQXVCLG9EQUFnQjtBQUN2QztBQUNBLHFDQUFxQyx3REFBa0I7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixnQ0FBZ0M7QUFDMUQsMEJBQTBCLG1DQUFtQztBQUM3RDtBQUNBLGdDQUFnQyxnQkFBZ0I7QUFDaEQ7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULDZCQUE2Qix3REFBa0I7QUFDL0M7QUFDQSx1QkFBdUIsMENBQUk7QUFDM0IsU0FBUztBQUNUO0FBQ0E7QUFDQSxnQkFBZ0IseUJBQXlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsNERBQWE7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsZ0VBQWlCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGlFQUFrQjtBQUNyRDtBQUNBLG9CQUFvQixpRUFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvYmFyYi9hYS9Bc3NvY2lhdGVkQWNjb3VudHMvbm9kZV9tb2R1bGVzL0BhZ2VudGljLXRydXN0L3ZlcmFtby1hZ2VudC1leHRlbnNpb24vZGlzdC91dGlscy9BQUNyZWRlbnRpYWxJc3N1ZXJFSVAxMjcxLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGV4dHJhY3RJc3N1ZXIsIGdldEV0aGVyZXVtQWRkcmVzcywgaXNEZWZpbmVkLCBNQU5EQVRPUllfQ1JFREVOVElBTF9DT05URVhULCBcbi8vbWFwQUFJZGVudGlmaWVyS2V5c1RvRG9jLFxuLy9tYXBBZ2VudElkZW50aWZpZXJLZXlzVG9Eb2MsXG5wcm9jZXNzRW50cnlUb0FycmF5LCByZW1vdmVESURQYXJhbWV0ZXJzLCByZXNvbHZlRGlkT3JUaHJvdywgfSBmcm9tICdAdmVyYW1vL3V0aWxzJztcbmltcG9ydCB7IFR5cGVkRGF0YUVuY29kZXIsIH0gZnJvbSAnZXRoZXJzJztcbmltcG9ydCB7IGNyZWF0ZVB1YmxpY0NsaWVudCwgaHR0cCwgZW5jb2RlRnVuY3Rpb25EYXRhLCB9IGZyb20gXCJ2aWVtXCI7XG5pbXBvcnQgeyBzZXBvbGlhIH0gZnJvbSBcInZpZW0vY2hhaW5zXCI7XG5jb25zdCBjaGFpbiA9IHNlcG9saWE7XG5pbXBvcnQgeyBnZXRFdGhUeXBlc0Zyb21JbnB1dERvYyB9IGZyb20gJ2VpcC03MTItdHlwZXMtZ2VuZXJhdGlvbic7XG5leHBvcnQgY2xhc3MgQUFDcmVkZW50aWFsSXNzdWVyRUlQMTI3MSB7XG4gICAgbWV0aG9kcztcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5tZXRob2RzID0ge1xuICAgICAgICAgICAgY3JlYXRlVmVyaWZpYWJsZUNyZWRlbnRpYWxFSVAxMjcxOiB0aGlzLmNyZWF0ZVZlcmlmaWFibGVDcmVkZW50aWFsRUlQMTI3MS5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgY3JlYXRlVmVyaWZpYWJsZVByZXNlbnRhdGlvbkVJUDEyNzE6IHRoaXMuY3JlYXRlVmVyaWZpYWJsZVByZXNlbnRhdGlvbkVJUDEyNzEuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIHZlcmlmeUNyZWRlbnRpYWxFSVAxMjcxOiB0aGlzLnZlcmlmeUNyZWRlbnRpYWxFSVAxMjcxLmJpbmQodGhpcyksXG4gICAgICAgICAgICB2ZXJpZnlQcmVzZW50YXRpb25FSVAxMjcxOiB0aGlzLnZlcmlmeVByZXNlbnRhdGlvbkVJUDEyNzEuYmluZCh0aGlzKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcGFyc2VBQURpZChkaWRVcmwpIHtcbiAgICAgICAgY29uc3QgW2Jhc2VEaWQsIGZyYWdtZW50XSA9IGRpZFVybC5zcGxpdChcIiNcIik7XG4gICAgICAgIGlmICghYmFzZURpZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIERJRCBmb3JtYXQ6ICR7ZGlkVXJsfWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcnRzID0gYmFzZURpZC5zcGxpdChcIjpcIik7XG4gICAgICAgIGlmIChwYXJ0cy5sZW5ndGggIT09IDUgfHwgcGFydHNbMF0gIT09IFwiZGlkXCIgfHwgcGFydHNbMV0gIT09IFwiYWFcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGRpZDo4MDA0IGZvcm1hdCAyOiAke2RpZFVybH1gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBbLCBtZXRob2QsIG5hbWVzcGFjZSwgY2hhaW5JZCwgYWRkcmVzc10gPSBwYXJ0cztcbiAgICAgICAgaWYgKCFtZXRob2QgfHwgIW5hbWVzcGFjZSB8fCAhY2hhaW5JZCB8fCAhYWRkcmVzcykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIERJRCBwYXJ0czogJHtkaWRVcmx9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRpZDogYmFzZURpZCxcbiAgICAgICAgICAgIG1ldGhvZCxcbiAgICAgICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgICAgIGNoYWluSWQsXG4gICAgICAgICAgICBhZGRyZXNzLFxuICAgICAgICAgICAgZnJhZ21lbnQsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGFzeW5jIGNyZWF0ZVZlcmlmaWFibGVDcmVkZW50aWFsRUlQMTI3MShhcmdzLCBjb250ZXh0KSB7XG4gICAgICAgIGNvbnN0IGNyZWRlbnRpYWxDb250ZXh0ID0gcHJvY2Vzc0VudHJ5VG9BcnJheShhcmdzPy5jcmVkZW50aWFsPy5bJ0Bjb250ZXh0J10sIE1BTkRBVE9SWV9DUkVERU5USUFMX0NPTlRFWFQpO1xuICAgICAgICBjb25zdCBjcmVkZW50aWFsVHlwZSA9IHByb2Nlc3NFbnRyeVRvQXJyYXkoYXJncz8uY3JlZGVudGlhbD8udHlwZSwgJ1ZlcmlmaWFibGVDcmVkZW50aWFsJyk7XG4gICAgICAgIGxldCBpc3N1YW5jZURhdGUgPSBhcmdzPy5jcmVkZW50aWFsPy5pc3N1YW5jZURhdGUgfHwgbmV3IERhdGUoKS50b0lTT1N0cmluZygpO1xuICAgICAgICBpZiAoaXNzdWFuY2VEYXRlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICAgICAgaXNzdWFuY2VEYXRlID0gaXNzdWFuY2VEYXRlLnRvSVNPU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaXNzdWVyID0gYXJncy5jcmVkZW50aWFsLmlzc3VlcjtcbiAgICAgICAgaWYgKCFpc3N1ZXIgfHwgdHlwZW9mIGlzc3VlciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSXNzdWVyIG11c3QgYmUgYW4gb2JqZWN0IHdpdGggYW4gXCJpZFwiIGFuZCBcImRpZFwiIHNpZ25lcicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnNvbGUuaW5mbyhcIkNyZWF0aW5nIFZlcmlmaWFibGUgQ3JlZGVudGlhbCBFSVAxMjcxIHdpdGggaXNzdWVyOlwiLCBpc3N1ZXIpO1xuICAgICAgICBjb25zdCBpZGVudGlmaWVyID0gYXdhaXQgY29udGV4dC5hZ2VudC5kaWRNYW5hZ2VyR2V0KHsgZGlkOiBpc3N1ZXIuaWQgfSk7XG4gICAgICAgIGNvbnN0IGFhRGlkUGFydHMgPSB0aGlzLnBhcnNlQUFEaWQoaWRlbnRpZmllci5kaWQpO1xuICAgICAgICBsZXQgY2hhaW5JZDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNoYWluSWQgPSBhYURpZFBhcnRzLmNoYWluSWQ7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNoYWluSWQgPSAxMTE1NTExMTtcbiAgICAgICAgfVxuICAgICAgICAvLyBwb2ludCB0byBhIERJRCBjb250cm9sbGVyIHRoYXQgc3VwcG9ydHMgc21hcnQgY29udHJhY3QtYmFzZWQgc2lnbmF0dXJlIHZlcmlmaWNhdGlvblxuICAgICAgICBjb25zdCBjcmVkZW50aWFsID0ge1xuICAgICAgICAgICAgLi4uYXJncz8uY3JlZGVudGlhbCxcbiAgICAgICAgICAgICdAY29udGV4dCc6IGNyZWRlbnRpYWxDb250ZXh0LFxuICAgICAgICAgICAgdHlwZTogY3JlZGVudGlhbFR5cGUsXG4gICAgICAgICAgICBpc3N1YW5jZURhdGUsXG4gICAgICAgICAgICBwcm9vZjoge1xuICAgICAgICAgICAgICAgIHZlcmlmaWNhdGlvbk1ldGhvZDogaWRlbnRpZmllci5kaWQgKyBcIiNldGhlcmV1bUFkZHJlc3NcIixcbiAgICAgICAgICAgICAgICBjcmVhdGVkOiBpc3N1YW5jZURhdGUsXG4gICAgICAgICAgICAgICAgcHJvb2ZQdXJwb3NlOiAnYXNzZXJ0aW9uTWV0aG9kJyxcbiAgICAgICAgICAgICAgICB0eXBlOiAnRXRoZXJldW1FaXA3MTJTaWduYXR1cmUyMDIxJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVkZW50aWFsO1xuICAgICAgICBjb25zdCBkb21haW4gPSB7XG4gICAgICAgICAgICBjaGFpbklkLFxuICAgICAgICAgICAgbmFtZTogJ1ZlcmlmaWFibGVDcmVkZW50aWFsJyxcbiAgICAgICAgICAgIHZlcnNpb246ICcxJyxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcHJpbWFyeVR5cGUgPSAnVmVyaWZpYWJsZUNyZWRlbnRpYWwnO1xuICAgICAgICBjb25zdCBhbGxUeXBlcyA9IGdldEV0aFR5cGVzRnJvbUlucHV0RG9jKGNyZWRlbnRpYWwsIHByaW1hcnlUeXBlKTtcbiAgICAgICAgY29uc3QgdHlwZXMgPSB7IC4uLmFsbFR5cGVzIH07XG4gICAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IGF3YWl0IGFyZ3M/LnNpZ25lcj8uc2lnblR5cGVkRGF0YShkb21haW4sIHR5cGVzLCBtZXNzYWdlKTtcbiAgICAgICAgY3JlZGVudGlhbFsncHJvb2YnXVsncHJvb2ZWYWx1ZSddID0gc2lnbmF0dXJlO1xuICAgICAgICBjcmVkZW50aWFsWydwcm9vZiddWydlaXA3MTInXSA9IHtcbiAgICAgICAgICAgIGRvbWFpbixcbiAgICAgICAgICAgIHR5cGVzOiBhbGxUeXBlcyxcbiAgICAgICAgICAgIHByaW1hcnlUeXBlLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gY3JlZGVudGlhbDtcbiAgICB9XG4gICAgYXN5bmMgY3JlYXRlVmVyaWZpYWJsZVByZXNlbnRhdGlvbkVJUDEyNzEoYXJncywgY29udGV4dCkge1xuICAgICAgICBjb25zb2xlLmluZm8oXCJDcmVhdGluZyBWZXJpZmlhYmxlIFByZXNlbnRhdGlvbiBFSVAxMjcxIHdpdGggYXJnczpcIiwgYXJncyk7XG4gICAgICAgIGNvbnN0IHByZXNlbnRhdGlvbkNvbnRleHQgPSBwcm9jZXNzRW50cnlUb0FycmF5KGFyZ3M/LnByZXNlbnRhdGlvbj8uWydAY29udGV4dCddLCBNQU5EQVRPUllfQ1JFREVOVElBTF9DT05URVhUKTtcbiAgICAgICAgY29uc3QgcHJlc2VudGF0aW9uVHlwZSA9IHByb2Nlc3NFbnRyeVRvQXJyYXkoYXJncz8ucHJlc2VudGF0aW9uPy50eXBlLCAnVmVyaWZpYWJsZVByZXNlbnRhdGlvbicpO1xuICAgICAgICBsZXQgaXNzdWFuY2VEYXRlID0gYXJncz8ucHJlc2VudGF0aW9uPy5pc3N1YW5jZURhdGUgfHwgbmV3IERhdGUoKS50b0lTT1N0cmluZygpO1xuICAgICAgICBpZiAoaXNzdWFuY2VEYXRlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICAgICAgaXNzdWFuY2VEYXRlID0gaXNzdWFuY2VEYXRlLnRvSVNPU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJlc2VudGF0aW9uID0ge1xuICAgICAgICAgICAgLi4uYXJncz8ucHJlc2VudGF0aW9uLFxuICAgICAgICAgICAgJ0Bjb250ZXh0JzogcHJlc2VudGF0aW9uQ29udGV4dCxcbiAgICAgICAgICAgIHR5cGU6IHByZXNlbnRhdGlvblR5cGUsXG4gICAgICAgICAgICBpc3N1YW5jZURhdGUsXG4gICAgICAgIH07XG4gICAgICAgIGlmICghaXNEZWZpbmVkKGFyZ3MucHJlc2VudGF0aW9uLmhvbGRlcikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZF9hcmd1bWVudDogcHJlc2VudGF0aW9uLmhvbGRlciBtdXN0IG5vdCBiZSBlbXB0eScpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhcmdzLnByZXNlbnRhdGlvbi52ZXJpZmlhYmxlQ3JlZGVudGlhbCkge1xuICAgICAgICAgICAgcHJlc2VudGF0aW9uLnZlcmlmaWFibGVDcmVkZW50aWFsID0gYXJncy5wcmVzZW50YXRpb24udmVyaWZpYWJsZUNyZWRlbnRpYWwubWFwKChjcmVkKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gbWFwIEpXVCBjcmVkZW50aWFscyB0byB0aGVpciBjYW5vbmljYWwgZm9ybVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY3JlZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNyZWQucHJvb2Yuand0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVkLnByb29mLmp3dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShjcmVkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBob2xkZXIgPSByZW1vdmVESURQYXJhbWV0ZXJzKHByZXNlbnRhdGlvbi5ob2xkZXIpO1xuICAgICAgICBsZXQgaWRlbnRpZmllcjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlkZW50aWZpZXIgPSBhd2FpdCBjb250ZXh0LmFnZW50LmRpZE1hbmFnZXJHZXQoeyBkaWQ6IGhvbGRlciB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkX2FyZ3VtZW50OiBwcmVzZW50YXRpb24uaG9sZGVyIG11c3QgYmUgYSBESUQgbWFuYWdlZCBieSB0aGlzIGFnZW50Jyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc29sZS5pbmZvKFwiaWRlbnRpZmllcjogXCIsIGlkZW50aWZpZXIpO1xuICAgICAgICBjb25zdCBhYURpZFBhcnRzID0gdGhpcy5wYXJzZUFBRGlkKGlkZW50aWZpZXIuZGlkKTtcbiAgICAgICAgbGV0IGNoYWluSWQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjaGFpbklkID0gYWFEaWRQYXJ0cy5jaGFpbklkO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjaGFpbklkID0gMTExNTUxMTE7XG4gICAgICAgIH1cbiAgICAgICAgcHJlc2VudGF0aW9uWydwcm9vZiddID0ge1xuICAgICAgICAgICAgdmVyaWZpY2F0aW9uTWV0aG9kOiBhYURpZFBhcnRzLmFkZHJlc3MgKyBcIiNldGhlcmV1bUFkZHJlc3NcIixcbiAgICAgICAgICAgIGNyZWF0ZWQ6IGlzc3VhbmNlRGF0ZSxcbiAgICAgICAgICAgIHByb29mUHVycG9zZTogJ2Fzc2VydGlvbk1ldGhvZCcsXG4gICAgICAgICAgICB0eXBlOiAnRXRoZXJldW1FaXA3MTJTaWduYXR1cmUyMDIxJyxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IHByZXNlbnRhdGlvbjtcbiAgICAgICAgY29uc3QgZG9tYWluID0ge1xuICAgICAgICAgICAgY2hhaW5JZCxcbiAgICAgICAgICAgIG5hbWU6ICdWZXJpZmlhYmxlUHJlc2VudGF0aW9uJyxcbiAgICAgICAgICAgIHZlcnNpb246ICcxJyxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcHJpbWFyeVR5cGUgPSAnVmVyaWZpYWJsZVByZXNlbnRhdGlvbic7XG4gICAgICAgIGNvbnN0IGFsbFR5cGVzID0gZ2V0RXRoVHlwZXNGcm9tSW5wdXREb2MocHJlc2VudGF0aW9uLCBwcmltYXJ5VHlwZSk7XG4gICAgICAgIGNvbnN0IHR5cGVzID0geyAuLi5hbGxUeXBlcyB9O1xuICAgICAgICBjb25zdCBzaWduYXR1cmUgPSBhd2FpdCBhcmdzPy5zaWduZXI/LnNpZ25UeXBlZERhdGEoZG9tYWluLCB0eXBlcywgbWVzc2FnZSk7XG4gICAgICAgIHByZXNlbnRhdGlvbi5wcm9vZi5wcm9vZlZhbHVlID0gc2lnbmF0dXJlO1xuICAgICAgICBwcmVzZW50YXRpb24ucHJvb2YuZWlwNzEyID0ge1xuICAgICAgICAgICAgZG9tYWluLFxuICAgICAgICAgICAgdHlwZXM6IGFsbFR5cGVzLFxuICAgICAgICAgICAgcHJpbWFyeVR5cGUsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBwcmVzZW50YXRpb247XG4gICAgfVxuICAgIGFzeW5jIHZlcmlmeUNyZWRlbnRpYWxFSVAxMjcxKGFyZ3MsIGNvbnRleHQpIHtcbiAgICAgICAgY29uc29sZS5pbmZvKFwidmVyaWZ5Q3JlZGVudGlhbEVJUDEyNzEgY2FsbGVkIHdpdGggYXJnczogXCIsIGFyZ3MpO1xuICAgICAgICAvLyBjaGVjayB0aGF0IHByb29mIGV4aXN0c1xuICAgICAgICBjb25zdCB7IGNyZWRlbnRpYWwgfSA9IGFyZ3M7XG4gICAgICAgIGlmICghY3JlZGVudGlhbC5wcm9vZiB8fCAhY3JlZGVudGlhbC5wcm9vZi5wcm9vZlZhbHVlKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkX2FyZ3VtZW50OiBwcm9vZiBpcyB1bmRlZmluZWQnKTtcbiAgICAgICAgY29uc3QgeyBwcm9vZiwgLi4uc2lnbmluZ0lucHV0IH0gPSBjcmVkZW50aWFsO1xuICAgICAgICBjb25zdCB7IHByb29mVmFsdWUsIGVpcDcxMiwgLi4udmVyaWZ5SW5wdXRQcm9vZiB9ID0gcHJvb2Y7XG4gICAgICAgIGNvbnN0IHZlcmlmaWNhdGlvbk1lc3NhZ2UgPSB7XG4gICAgICAgICAgICAuLi5zaWduaW5nSW5wdXQsXG4gICAgICAgICAgICBwcm9vZjogdmVyaWZ5SW5wdXRQcm9vZixcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgY29tcGF0ID0ge1xuICAgICAgICAgICAgLi4uZWlwNzEyLFxuICAgICAgICB9O1xuICAgICAgICBjb21wYXQudHlwZXMgPSBjb21wYXQudHlwZXMgfHwgY29tcGF0Lm1lc3NhZ2VTY2hlbWE7XG4gICAgICAgIGlmICghY29tcGF0LnByaW1hcnlUeXBlIHx8ICFjb21wYXQudHlwZXMgfHwgIWNvbXBhdC5kb21haW4pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZF9hcmd1bWVudDogcHJvb2YgaXMgbWlzc2luZyBleHBlY3RlZCBwcm9wZXJ0aWVzJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZmlsdGVyZWRUeXBlcyA9IHsgLi4uY29tcGF0LnR5cGVzIH07XG4gICAgICAgIGRlbGV0ZSBmaWx0ZXJlZFR5cGVzLkVJUDcxMkRvbWFpbjtcbiAgICAgICAgY29uc3QgZGlnZXN0ID0gVHlwZWREYXRhRW5jb2Rlci5oYXNoKGNvbXBhdC5kb21haW4sIGZpbHRlcmVkVHlwZXMsIHZlcmlmaWNhdGlvbk1lc3NhZ2UpO1xuICAgICAgICBjb25zdCBzaWduYXR1cmUgPSBwcm9vZlZhbHVlO1xuICAgICAgICBjb25zb2xlLmluZm8oXCIuLi4uLi4uLi4uLi4uLi4gc2lnbmF0dXJlOiBcIiwgc2lnbmF0dXJlKTtcbiAgICAgICAgY29uc29sZS5pbmZvKFwiLi4uLi4uLi4uLi4uLi4uIGRpZ2VzdDogXCIsIGRpZ2VzdCk7XG4gICAgICAgIGNvbnN0IGlzVmFsaWRTaWduYXR1cmVEYXRhID0gZW5jb2RlRnVuY3Rpb25EYXRhKHtcbiAgICAgICAgICAgIGFiaTogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJpc1ZhbGlkU2lnbmF0dXJlXCIsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICAgICAgICAgICAgICAgICAgaW5wdXRzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWU6IFwiX2hhc2hcIiwgdHlwZTogXCJieXRlczMyXCIgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogXCJfc2lnbmF0dXJlXCIsIHR5cGU6IFwiYnl0ZXNcIiB9LFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICBvdXRwdXRzOiBbeyB0eXBlOiBcImJ5dGVzNFwiIH1dLFxuICAgICAgICAgICAgICAgICAgICBzdGF0ZU11dGFiaWxpdHk6IFwidmlld1wiLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgZnVuY3Rpb25OYW1lOiBcImlzVmFsaWRTaWduYXR1cmVcIixcbiAgICAgICAgICAgIGFyZ3M6IFtkaWdlc3QsIHNpZ25hdHVyZV0sXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBwdWJsaWNDbGllbnQgPSBjcmVhdGVQdWJsaWNDbGllbnQoe1xuICAgICAgICAgICAgY2hhaW46IGNoYWluLFxuICAgICAgICAgICAgdHJhbnNwb3J0OiBodHRwKCksXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBkaWQgPSBjcmVkZW50aWFsLmlzc3Vlci5pZDtcbiAgICAgICAgY29uc29sZS5pbmZvKFwiPj4+Pj4+Pj4+Pj4+IGNyZWRlbnRpYWwgaXNzdWVyIGRpZDogXCIsIGRpZCk7XG4gICAgICAgIGNvbnN0IGFkZHJlc3MgPSB0aGlzLnBhcnNlQUFEaWQoZGlkKS5hZGRyZXNzO1xuICAgICAgICBjb25zb2xlLmluZm8oXCJhZGRyZXNzIHVzZWQgdG8gdmFsaWRhdGUgc2lnbmF0dXJlOiBcIiwgYWRkcmVzcyk7XG4gICAgICAgIC8vIHZhbGlkYXRlIHNpZ25hdHVyZSB1c2luZyBjb250cmFjdCBFSVAtMTI3MVxuICAgICAgICBjb25zdCB7IGRhdGE6IGlzVmFsaWRTaWduYXR1cmUgfSA9IGF3YWl0IHB1YmxpY0NsaWVudC5jYWxsKHtcbiAgICAgICAgICAgIGFjY291bnQ6IGFkZHJlc3MsXG4gICAgICAgICAgICBkYXRhOiBpc1ZhbGlkU2lnbmF0dXJlRGF0YSxcbiAgICAgICAgICAgIHRvOiBhZGRyZXNzLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc29sZS5pbmZvKFwiaXNWYWxpZFNpZ25hdHVyZTogXCIsIGlzVmFsaWRTaWduYXR1cmUpO1xuICAgICAgICBpZiAoIWlzVmFsaWRTaWduYXR1cmU/LnN0YXJ0c1dpdGgoJzB4MTYyNmJhN2UnKSkge1xuICAgICAgICAgICAgY29uc29sZS5pbmZvKFwiKioqKioqKioqKiBWZXJpZmlhYmxlIENyZWRlbnRpYWwgU2lnbmF0dXJlIGlzIG5vdCB2YWxpZCBhY2NvcmRpbmcgdG8gRUlQLTEyNzFcIik7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc29sZS5pbmZvKFwic2lnbmF0dXJlIGlzIHZhbGlkIGFjY29yZGluZyB0byBFSVAtMTI3MVwiKTtcbiAgICAgICAgLy8gdmVyaWZ5IHRoZSBpc3N1ZXIgZGlkXG4gICAgICAgIGNvbnN0IGlzc3VlciA9IGV4dHJhY3RJc3N1ZXIoY3JlZGVudGlhbCk7XG4gICAgICAgIGlmICghaXNzdWVyIHx8IHR5cGVvZiBpc3N1ZXIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWRfYXJndW1lbnQ6IGNyZWRlbnRpYWwuaXNzdWVyIG11c3Qgbm90IGJlIGVtcHR5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYWEgPSBhd2FpdCBjb250ZXh0LmFnZW50LnJlc29sdmVEaWQoeyBkaWRVcmw6IGlzc3Vlciwgb3B0aW9uczogYXJncy5yZXNvbHV0aW9uT3B0aW9ucyB9KTtcbiAgICAgICAgY29uc3QgZGlkRG9jdW1lbnQgPSBhd2FpdCByZXNvbHZlRGlkT3JUaHJvdyhpc3N1ZXIsIGNvbnRleHQsIGFyZ3MucmVzb2x1dGlvbk9wdGlvbnMpO1xuICAgICAgICBpZiAoZGlkRG9jdW1lbnQudmVyaWZpY2F0aW9uTWV0aG9kICYmIGFkZHJlc3MpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgdmVyaWZpY2F0aW9uTWV0aG9kIG9mIGRpZERvY3VtZW50LnZlcmlmaWNhdGlvbk1ldGhvZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGV0aEFkZHJlc3MgPSBnZXRFdGhlcmV1bUFkZHJlc3ModmVyaWZpY2F0aW9uTWV0aG9kKT8udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICBpZiAoZXRoQWRkcmVzcyA9PT0gYWRkcmVzcy50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncmVzb2x2ZXJfZXJyb3I6IGlzc3VlciBESUREb2N1bWVudCBkb2VzIG5vdCBjb250YWluIGFueSB2ZXJpZmljYXRpb25NZXRob2RzJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBhc3luYyB2ZXJpZnlQcmVzZW50YXRpb25FSVAxMjcxKGFyZ3MsIGNvbnRleHQpIHtcbiAgICAgICAgLy8gY2hlY2sgdGhhdCBwcm9vZiBleGlzdHNcbiAgICAgICAgY29uc3QgeyBwcmVzZW50YXRpb24gfSA9IGFyZ3M7XG4gICAgICAgIGlmICghcHJlc2VudGF0aW9uLnByb29mIHx8ICFwcmVzZW50YXRpb24ucHJvb2YucHJvb2ZWYWx1ZSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZF9hcmd1bWVudDogcHJvb2YgaXMgdW5kZWZpbmVkJyk7XG4gICAgICAgIGNvbnN0IHsgcHJvb2YsIC4uLnNpZ25pbmdJbnB1dCB9ID0gcHJlc2VudGF0aW9uO1xuICAgICAgICBjb25zdCB7IHByb29mVmFsdWUsIGVpcDcxMiwgLi4udmVyaWZ5SW5wdXRQcm9vZiB9ID0gcHJvb2Y7XG4gICAgICAgIGNvbnN0IHZlcmlmaWNhdGlvbk1lc3NhZ2UgPSB7XG4gICAgICAgICAgICAuLi5zaWduaW5nSW5wdXQsXG4gICAgICAgICAgICBwcm9vZjogdmVyaWZ5SW5wdXRQcm9vZixcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgY29tcGF0ID0ge1xuICAgICAgICAgICAgLi4uZWlwNzEyLFxuICAgICAgICB9O1xuICAgICAgICBjb21wYXQudHlwZXMgPSBjb21wYXQudHlwZXMgfHwgY29tcGF0Lm1lc3NhZ2VTY2hlbWE7XG4gICAgICAgIGlmICghY29tcGF0LnByaW1hcnlUeXBlIHx8ICFjb21wYXQudHlwZXMgfHwgIWNvbXBhdC5kb21haW4pXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWRfYXJndW1lbnQ6IHByb29mIGlzIG1pc3NpbmcgZXhwZWN0ZWQgcHJvcGVydGllcycpO1xuICAgICAgICBjb25zdCBmaWx0ZXJlZFR5cGVzID0geyAuLi5jb21wYXQudHlwZXMgfTtcbiAgICAgICAgZGVsZXRlIGZpbHRlcmVkVHlwZXMuRUlQNzEyRG9tYWluO1xuICAgICAgICBjb25zdCBkaWdlc3QgPSBUeXBlZERhdGFFbmNvZGVyLmhhc2goY29tcGF0LmRvbWFpbiwgZmlsdGVyZWRUeXBlcywgdmVyaWZpY2F0aW9uTWVzc2FnZSk7XG4gICAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IHByb29mVmFsdWU7XG4gICAgICAgIGNvbnN0IGlzVmFsaWRTaWduYXR1cmVEYXRhID0gZW5jb2RlRnVuY3Rpb25EYXRhKHtcbiAgICAgICAgICAgIGFiaTogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJpc1ZhbGlkU2lnbmF0dXJlXCIsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICAgICAgICAgICAgICAgICAgaW5wdXRzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWU6IFwiX2hhc2hcIiwgdHlwZTogXCJieXRlczMyXCIgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogXCJfc2lnbmF0dXJlXCIsIHR5cGU6IFwiYnl0ZXNcIiB9LFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICBvdXRwdXRzOiBbeyB0eXBlOiBcImJ5dGVzNFwiIH1dLFxuICAgICAgICAgICAgICAgICAgICBzdGF0ZU11dGFiaWxpdHk6IFwidmlld1wiLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgZnVuY3Rpb25OYW1lOiBcImlzVmFsaWRTaWduYXR1cmVcIixcbiAgICAgICAgICAgIGFyZ3M6IFtkaWdlc3QsIHNpZ25hdHVyZV0sXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBwdWJsaWNDbGllbnQgPSBjcmVhdGVQdWJsaWNDbGllbnQoe1xuICAgICAgICAgICAgY2hhaW46IGNoYWluLFxuICAgICAgICAgICAgdHJhbnNwb3J0OiBodHRwKCksXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBjbGllbnRBZGRyZXNzID0gdGhpcy5wYXJzZUFBRGlkKHByZXNlbnRhdGlvbi5ob2xkZXIpLmFkZHJlc3M7XG4gICAgICAgIC8vIHZhbGlkYXRlIHNpZ25hdHVyZSB1c2luZyBjb250cmFjdCBFSVAtMTI3MVxuICAgICAgICBjb25zdCB7IGRhdGE6IGlzVmFsaWRTaWduYXR1cmUgfSA9IGF3YWl0IHB1YmxpY0NsaWVudC5jYWxsKHtcbiAgICAgICAgICAgIGFjY291bnQ6IGNsaWVudEFkZHJlc3MsXG4gICAgICAgICAgICBkYXRhOiBpc1ZhbGlkU2lnbmF0dXJlRGF0YSxcbiAgICAgICAgICAgIHRvOiBjbGllbnRBZGRyZXNzLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFpc1ZhbGlkU2lnbmF0dXJlPy5zdGFydHNXaXRoKCcweDE2MjZiYTdlJykpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhcIioqKioqKioqKioqIFZlcmlmaWFibGUgUHJlc2VudGF0aW9uIFNpZ25hdHVyZSBpcyBub3QgdmFsaWQgYWNjb3JkaW5nIHRvIEVJUC0xMjcxXCIpO1xuICAgICAgICAgICAgY29uc29sZS5pbmZvKFwiaXNWYWxpZFNpZ25hdHVyZTogXCIsIGlzVmFsaWRTaWduYXR1cmUpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIHZlcmlmeSB0aGUgY2xpZW50IGRpZFxuICAgICAgICBjb25zdCBjbGllbnREaWQgPSBleHRyYWN0SXNzdWVyKHByZXNlbnRhdGlvbik7XG4gICAgICAgIGlmICghY2xpZW50RGlkIHx8IHR5cGVvZiBjbGllbnREaWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWRfYXJndW1lbnQ6IHByZXNlbnRhdGlvbi5ob2xkZXIgbXVzdCBub3QgYmUgZW1wdHknKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zb2xlLmluZm8oXCJnYXRvciBjbGllbnQgQWdlbnQgRGlkOiBcIiwgY2xpZW50RGlkKTtcbiAgICAgICAgY29uc3QgY2xpZW50RGlkRG9jdW1lbnQgPSBhd2FpdCByZXNvbHZlRGlkT3JUaHJvdyhjbGllbnREaWQsIGNvbnRleHQsIGFyZ3MucmVzb2x1dGlvbk9wdGlvbnMpO1xuICAgICAgICBpZiAoY2xpZW50RGlkRG9jdW1lbnQudmVyaWZpY2F0aW9uTWV0aG9kICYmIGNsaWVudEFkZHJlc3MpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhcImdhdG9yIGNsaWVudCBkaWREb2N1bWVudC52ZXJpZmljYXRpb25NZXRob2Q6IFwiLCBjbGllbnREaWREb2N1bWVudC52ZXJpZmljYXRpb25NZXRob2QpO1xuICAgICAgICAgICAgZm9yIChjb25zdCB2ZXJpZmljYXRpb25NZXRob2Qgb2YgY2xpZW50RGlkRG9jdW1lbnQudmVyaWZpY2F0aW9uTWV0aG9kKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5pbmZvKFwidmVyaWZpY2F0aW9uTWV0aG9kOiBcIiwgdmVyaWZpY2F0aW9uTWV0aG9kKTtcbiAgICAgICAgICAgICAgICBjb25zdCBldGhBZGRyZXNzID0gZ2V0RXRoZXJldW1BZGRyZXNzKHZlcmlmaWNhdGlvbk1ldGhvZCk/LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgY29uc29sZS5pbmZvKFwiZXRoQWRkcmVzczogXCIsIGV0aEFkZHJlc3MpO1xuICAgICAgICAgICAgICAgIGlmIChnZXRFdGhlcmV1bUFkZHJlc3ModmVyaWZpY2F0aW9uTWV0aG9kKT8udG9Mb3dlckNhc2UoKSA9PT0gY2xpZW50QWRkcmVzcy50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncmVzb2x2ZXJfZXJyb3I6IGhvbGRlciBESUREb2N1bWVudCBkb2VzIG5vdCBjb250YWluIGFueSB2ZXJpZmljYXRpb25NZXRob2RzJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFBQ3JlZGVudGlhbElzc3VlckVJUDEyNzEuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@agentic-trust/veramo-agent-extension/dist/utils/AACredentialIssuerEIP1271.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@agentic-trust/veramo-agent-extension/dist/utils/AADidProvider.js":
/*!********************************************************************************************!*\
  !*** ../../node_modules/@agentic-trust/veramo-agent-extension/dist/utils/AADidProvider.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AADidProvider: () => (/* binding */ AADidProvider)\n/* harmony export */ });\n/* harmony import */ var _veramo_did_manager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @veramo/did-manager */ \"(rsc)/../../node_modules/@veramo/did-manager/build/index.js\");\n\nclass AADidProvider extends _veramo_did_manager__WEBPACK_IMPORTED_MODULE_0__.AbstractIdentifierProvider {\n    async addKey(args, context) {\n        // In a real implementation, you would add the key to the identifier's key list and persist it.\n        // Here, we simulate this by returning a success response.\n        return { success: true, key: args.key };\n    }\n    defaultKms;\n    chainId;\n    address;\n    providerName;\n    constructor(options) {\n        super();\n        this.defaultKms = options.defaultKms;\n        this.chainId = options.chainId;\n        this.address = options.address;\n        this.providerName = `aa:${this.address}`;\n    }\n    // Returns the DID method name\n    getSupportedMethods() {\n        return [`aa:${this.address}`];\n    }\n    getAccount() {\n        return this.address;\n    }\n    async createIdentifier({ kms, alias, options }, context) {\n        //console.info(`Resolving DID 111: ${did}`)\n        // provider and did are a one to one relationship\n        const address = this.address;\n        const chainId = this.chainId;\n        const did = `did:aa:eip155:${chainId}:${address}`;\n        const identifier = {\n            did,\n            alias,\n            provider: this.providerName,\n            controllerKeyId: address, // assumes no local private key; signing done externally or on-chain\n            keys: [],\n            services: [],\n        };\n        console.info(\"&&&&&&&&&&&& Creating identifier:\", identifier);\n        return identifier;\n    }\n    async resolveDid(did) {\n        console.info(`Resolving DID 222: ${did}`);\n        const parts = did.split(':').slice(1);\n        const [method, networkId, address] = parts;\n        if (method !== 'contract') {\n            throw new Error(`Unsupported DID method: ${method}`);\n        }\n        if (!address) {\n            throw new Error(`Missing address in DID: ${did}`);\n        }\n        const controllerAddress = address.toLowerCase();\n        return {\n            '@context': ['https://www.w3.org/ns/did/v1'],\n            id: did,\n            verificationMethod: [\n                {\n                    id: `${did}#controller`,\n                    type: 'EcdsaSecp256k1RecoveryMethod2020',\n                    controller: did,\n                    blockchainAccountId: `${controllerAddress}@eip155:${networkId}`,\n                },\n            ],\n            authentication: [`${did}#controller`],\n        };\n    }\n    async updateIdentifier(args, context) {\n        throw new Error('WebDIDProvider updateIdentifier not supported yet.');\n    }\n    async deleteIdentifier(identifier, context) {\n        for (const { kid } of identifier.keys) {\n            await context.agent.keyManagerDelete({ kid });\n        }\n        return true;\n    }\n    async addService({ identifier, service, options }, context) {\n        return { success: true };\n    }\n    async removeKey(args, context) {\n        return { success: true };\n    }\n    async removeService(args, context) {\n        return { success: true };\n    }\n}\n//# sourceMappingURL=AADidProvider.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BhZ2VudGljLXRydXN0L3ZlcmFtby1hZ2VudC1leHRlbnNpb24vZGlzdC91dGlscy9BQURpZFByb3ZpZGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQWlFO0FBQzFELDRCQUE0QiwyRUFBMEI7QUFDN0Q7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGFBQWE7QUFDL0M7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGFBQWE7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIscUJBQXFCO0FBQ2xELDZDQUE2QyxJQUFJO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxRQUFRLEdBQUcsUUFBUTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RTtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxJQUFJO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxPQUFPO0FBQzlEO0FBQ0E7QUFDQSx1REFBdUQsSUFBSTtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixJQUFJO0FBQy9CO0FBQ0E7QUFDQSw0Q0FBNEMsa0JBQWtCLFVBQVUsVUFBVTtBQUNsRixpQkFBaUI7QUFDakI7QUFDQSxnQ0FBZ0MsSUFBSTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsTUFBTTtBQUMzQixtREFBbUQsS0FBSztBQUN4RDtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsOEJBQThCO0FBQ3JELGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9iYXJiL2FhL0Fzc29jaWF0ZWRBY2NvdW50cy9ub2RlX21vZHVsZXMvQGFnZW50aWMtdHJ1c3QvdmVyYW1vLWFnZW50LWV4dGVuc2lvbi9kaXN0L3V0aWxzL0FBRGlkUHJvdmlkZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQWJzdHJhY3RJZGVudGlmaWVyUHJvdmlkZXIgfSBmcm9tICdAdmVyYW1vL2RpZC1tYW5hZ2VyJztcbmV4cG9ydCBjbGFzcyBBQURpZFByb3ZpZGVyIGV4dGVuZHMgQWJzdHJhY3RJZGVudGlmaWVyUHJvdmlkZXIge1xuICAgIGFzeW5jIGFkZEtleShhcmdzLCBjb250ZXh0KSB7XG4gICAgICAgIC8vIEluIGEgcmVhbCBpbXBsZW1lbnRhdGlvbiwgeW91IHdvdWxkIGFkZCB0aGUga2V5IHRvIHRoZSBpZGVudGlmaWVyJ3Mga2V5IGxpc3QgYW5kIHBlcnNpc3QgaXQuXG4gICAgICAgIC8vIEhlcmUsIHdlIHNpbXVsYXRlIHRoaXMgYnkgcmV0dXJuaW5nIGEgc3VjY2VzcyByZXNwb25zZS5cbiAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSwga2V5OiBhcmdzLmtleSB9O1xuICAgIH1cbiAgICBkZWZhdWx0S21zO1xuICAgIGNoYWluSWQ7XG4gICAgYWRkcmVzcztcbiAgICBwcm92aWRlck5hbWU7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmRlZmF1bHRLbXMgPSBvcHRpb25zLmRlZmF1bHRLbXM7XG4gICAgICAgIHRoaXMuY2hhaW5JZCA9IG9wdGlvbnMuY2hhaW5JZDtcbiAgICAgICAgdGhpcy5hZGRyZXNzID0gb3B0aW9ucy5hZGRyZXNzO1xuICAgICAgICB0aGlzLnByb3ZpZGVyTmFtZSA9IGBhYToke3RoaXMuYWRkcmVzc31gO1xuICAgIH1cbiAgICAvLyBSZXR1cm5zIHRoZSBESUQgbWV0aG9kIG5hbWVcbiAgICBnZXRTdXBwb3J0ZWRNZXRob2RzKCkge1xuICAgICAgICByZXR1cm4gW2BhYToke3RoaXMuYWRkcmVzc31gXTtcbiAgICB9XG4gICAgZ2V0QWNjb3VudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkcmVzcztcbiAgICB9XG4gICAgYXN5bmMgY3JlYXRlSWRlbnRpZmllcih7IGttcywgYWxpYXMsIG9wdGlvbnMgfSwgY29udGV4dCkge1xuICAgICAgICAvL2NvbnNvbGUuaW5mbyhgUmVzb2x2aW5nIERJRCAxMTE6ICR7ZGlkfWApXG4gICAgICAgIC8vIHByb3ZpZGVyIGFuZCBkaWQgYXJlIGEgb25lIHRvIG9uZSByZWxhdGlvbnNoaXBcbiAgICAgICAgY29uc3QgYWRkcmVzcyA9IHRoaXMuYWRkcmVzcztcbiAgICAgICAgY29uc3QgY2hhaW5JZCA9IHRoaXMuY2hhaW5JZDtcbiAgICAgICAgY29uc3QgZGlkID0gYGRpZDphYTplaXAxNTU6JHtjaGFpbklkfToke2FkZHJlc3N9YDtcbiAgICAgICAgY29uc3QgaWRlbnRpZmllciA9IHtcbiAgICAgICAgICAgIGRpZCxcbiAgICAgICAgICAgIGFsaWFzLFxuICAgICAgICAgICAgcHJvdmlkZXI6IHRoaXMucHJvdmlkZXJOYW1lLFxuICAgICAgICAgICAgY29udHJvbGxlcktleUlkOiBhZGRyZXNzLCAvLyBhc3N1bWVzIG5vIGxvY2FsIHByaXZhdGUga2V5OyBzaWduaW5nIGRvbmUgZXh0ZXJuYWxseSBvciBvbi1jaGFpblxuICAgICAgICAgICAga2V5czogW10sXG4gICAgICAgICAgICBzZXJ2aWNlczogW10sXG4gICAgICAgIH07XG4gICAgICAgIGNvbnNvbGUuaW5mbyhcIiYmJiYmJiYmJiYmJiBDcmVhdGluZyBpZGVudGlmaWVyOlwiLCBpZGVudGlmaWVyKTtcbiAgICAgICAgcmV0dXJuIGlkZW50aWZpZXI7XG4gICAgfVxuICAgIGFzeW5jIHJlc29sdmVEaWQoZGlkKSB7XG4gICAgICAgIGNvbnNvbGUuaW5mbyhgUmVzb2x2aW5nIERJRCAyMjI6ICR7ZGlkfWApO1xuICAgICAgICBjb25zdCBwYXJ0cyA9IGRpZC5zcGxpdCgnOicpLnNsaWNlKDEpO1xuICAgICAgICBjb25zdCBbbWV0aG9kLCBuZXR3b3JrSWQsIGFkZHJlc3NdID0gcGFydHM7XG4gICAgICAgIGlmIChtZXRob2QgIT09ICdjb250cmFjdCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgRElEIG1ldGhvZDogJHttZXRob2R9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFhZGRyZXNzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE1pc3NpbmcgYWRkcmVzcyBpbiBESUQ6ICR7ZGlkfWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbnRyb2xsZXJBZGRyZXNzID0gYWRkcmVzcy50b0xvd2VyQ2FzZSgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ0Bjb250ZXh0JzogWydodHRwczovL3d3dy53My5vcmcvbnMvZGlkL3YxJ10sXG4gICAgICAgICAgICBpZDogZGlkLFxuICAgICAgICAgICAgdmVyaWZpY2F0aW9uTWV0aG9kOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBpZDogYCR7ZGlkfSNjb250cm9sbGVyYCxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ0VjZHNhU2VjcDI1NmsxUmVjb3ZlcnlNZXRob2QyMDIwJyxcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlcjogZGlkLFxuICAgICAgICAgICAgICAgICAgICBibG9ja2NoYWluQWNjb3VudElkOiBgJHtjb250cm9sbGVyQWRkcmVzc31AZWlwMTU1OiR7bmV0d29ya0lkfWAsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBhdXRoZW50aWNhdGlvbjogW2Ake2RpZH0jY29udHJvbGxlcmBdLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBhc3luYyB1cGRhdGVJZGVudGlmaWVyKGFyZ3MsIGNvbnRleHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXZWJESURQcm92aWRlciB1cGRhdGVJZGVudGlmaWVyIG5vdCBzdXBwb3J0ZWQgeWV0LicpO1xuICAgIH1cbiAgICBhc3luYyBkZWxldGVJZGVudGlmaWVyKGlkZW50aWZpZXIsIGNvbnRleHQpIHtcbiAgICAgICAgZm9yIChjb25zdCB7IGtpZCB9IG9mIGlkZW50aWZpZXIua2V5cykge1xuICAgICAgICAgICAgYXdhaXQgY29udGV4dC5hZ2VudC5rZXlNYW5hZ2VyRGVsZXRlKHsga2lkIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBhc3luYyBhZGRTZXJ2aWNlKHsgaWRlbnRpZmllciwgc2VydmljZSwgb3B0aW9ucyB9LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUgfTtcbiAgICB9XG4gICAgYXN5bmMgcmVtb3ZlS2V5KGFyZ3MsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSB9O1xuICAgIH1cbiAgICBhc3luYyByZW1vdmVTZXJ2aWNlKGFyZ3MsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSB9O1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFBRGlkUHJvdmlkZXIuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@agentic-trust/veramo-agent-extension/dist/utils/AADidProvider.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@agentic-trust/veramo-agent-extension/dist/utils/AAKeyManagementSystem.js":
/*!****************************************************************************************************!*\
  !*** ../../node_modules/@agentic-trust/veramo-agent-extension/dist/utils/AAKeyManagementSystem.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AAKeyManagementSystem: () => (/* binding */ AAKeyManagementSystem),\n/* harmony export */   compareBlockchainAccountId: () => (/* binding */ compareBlockchainAccountId),\n/* harmony export */   compressAAIdentifierSecp256k1Keys: () => (/* binding */ compressAAIdentifierSecp256k1Keys),\n/* harmony export */   convertAAIdentifierEncryptionKeys: () => (/* binding */ convertAAIdentifierEncryptionKeys),\n/* harmony export */   getAAEthereumAddress: () => (/* binding */ getAAEthereumAddress),\n/* harmony export */   mapAAIdentifierKeysToDoc: () => (/* binding */ mapAAIdentifierKeysToDoc)\n/* harmony export */ });\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ethers */ \"(rsc)/../../node_modules/ethers/lib.esm/crypto/signing-key.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ethers */ \"(rsc)/../../node_modules/ethers/lib.esm/transaction/address.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ethers */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/utf8.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! viem */ \"(rsc)/../../node_modules/viem/_esm/utils/encoding/toBytes.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! viem */ \"(rsc)/../../node_modules/viem/_esm/utils/encoding/toHex.js\");\n/* harmony import */ var _veramo_key_manager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @veramo/key-manager */ \"(rsc)/../../node_modules/@veramo/key-manager/build/index.js\");\n/* harmony import */ var _veramo_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @veramo/utils */ \"(rsc)/../../node_modules/@veramo/utils/build/index.js\");\n/* harmony import */ var did_jwt__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! did-jwt */ \"(rsc)/../../node_modules/did-jwt/lib/index.module.js\");\n\n\n\n\n\nfunction compressAAIdentifierSecp256k1Keys(identifier) {\n    return identifier.keys\n        .map((key) => {\n        if (key.type === 'Secp256k1') {\n            if (key.publicKeyHex) {\n                const publicBytes = (0,viem__WEBPACK_IMPORTED_MODULE_3__.hexToBytes)(key.publicKeyHex);\n                key.publicKeyHex = ethers__WEBPACK_IMPORTED_MODULE_4__.SigningKey.computePublicKey(publicBytes, true).substring(2);\n                key.meta = { ...key.meta };\n                key.meta.ethereumAddress = (0,ethers__WEBPACK_IMPORTED_MODULE_5__.computeAddress)('0x' + key.publicKeyHex);\n            }\n        }\n        return key;\n    })\n        .filter(_veramo_utils__WEBPACK_IMPORTED_MODULE_1__.isDefined);\n}\nfunction convertAAIdentifierEncryptionKeys(identifier) {\n    return identifier.keys\n        .map((key) => {\n        if (key.type === 'Ed25519') {\n            const publicBytes = (0,viem__WEBPACK_IMPORTED_MODULE_3__.hexToBytes)(key.publicKeyHex);\n            key.publicKeyHex = (0,viem__WEBPACK_IMPORTED_MODULE_6__.bytesToHex)((0,_veramo_utils__WEBPACK_IMPORTED_MODULE_1__.convertEd25519PublicKeyToX25519)(publicBytes));\n            if (key.privateKeyHex) {\n                const privateBytes = (0,viem__WEBPACK_IMPORTED_MODULE_3__.hexToBytes)(key.privateKeyHex);\n                key.privateKeyHex = (0,viem__WEBPACK_IMPORTED_MODULE_6__.bytesToHex)((0,_veramo_utils__WEBPACK_IMPORTED_MODULE_1__.convertEd25519PrivateKeyToX25519)(privateBytes));\n            }\n            key.type = 'X25519';\n        }\n        else if (key.type !== 'X25519') {\n            console.info(`key of type ${key.type} is not supported for [de]encryption`);\n            return null;\n        }\n        return key;\n    })\n        .filter(_veramo_utils__WEBPACK_IMPORTED_MODULE_1__.isDefined);\n}\nfunction getAAEthereumAddress(verificationMethod) {\n    let vmEthAddr = verificationMethod.ethereumAddress?.toLowerCase();\n    if (!vmEthAddr) {\n        const blockchainAccountId = verificationMethod.blockchainAccountId;\n        if (blockchainAccountId?.includes('@eip155')) {\n            vmEthAddr = blockchainAccountId.split('@eip155')[0]?.toLowerCase();\n        }\n        else if (verificationMethod.blockchainAccountId?.startsWith('eip155')) {\n            vmEthAddr = verificationMethod.blockchainAccountId.split(':')[2]?.toLowerCase();\n        }\n        else {\n            const { keyBytes, keyType } = (0,did_jwt__WEBPACK_IMPORTED_MODULE_2__.extractPublicKeyBytes)(verificationMethod);\n            if (keyType !== 'Secp256k1') {\n                return undefined;\n            }\n            const pbHex = ethers__WEBPACK_IMPORTED_MODULE_4__.SigningKey.computePublicKey(keyBytes, false);\n            vmEthAddr = (0,ethers__WEBPACK_IMPORTED_MODULE_5__.computeAddress)(pbHex).toLowerCase();\n        }\n    }\n    return vmEthAddr;\n}\nfunction compareBlockchainAccountId(localKey, verificationMethod) {\n    //if (localKey.type !== 'Secp256k1') {\n    //  return false\n    //}\n    let vmEthAddr = getAAEthereumAddress(verificationMethod);\n    const localAccount = localKey.meta?.account ?? localKey.meta?.ethereumAddress;\n    if (localKey.meta?.account) {\n        console.info(\"localKey.meta.account: \", localKey.meta.account);\n        console.info(\"vmEthAddr: \", vmEthAddr);\n        return vmEthAddr === localAccount.toLowerCase();\n    }\n    console.info(\"localKey.publicKeyHex: \", localKey.publicKeyHex);\n    const computedAddr = (0,ethers__WEBPACK_IMPORTED_MODULE_5__.computeAddress)('0x' + localKey.publicKeyHex).toLowerCase();\n    console.info(\"computedAddr: \", computedAddr);\n    console.info(\"vmEthAddr: \", vmEthAddr);\n    return computedAddr === vmEthAddr;\n}\nasync function mapAAIdentifierKeysToDoc(identifier, section = 'keyAgreement', context, resolutionOptions) {\n    const didDocument = await (0,_veramo_utils__WEBPACK_IMPORTED_MODULE_1__.resolveDidOrThrow)(identifier.did, context, resolutionOptions);\n    console.info(\".............. didDocument: \", didDocument);\n    // dereference all key agreement keys from DID document and normalize\n    const documentKeys = await (0,_veramo_utils__WEBPACK_IMPORTED_MODULE_1__.dereferenceDidKeys)(didDocument, section, context);\n    console.info(\".............. documentKeys: \", documentKeys);\n    let localKeys = identifier.keys.filter(_veramo_utils__WEBPACK_IMPORTED_MODULE_1__.isDefined);\n    console.info(\"--- identifier keys: \", localKeys);\n    if (section === 'keyAgreement') {\n        localKeys = convertAAIdentifierEncryptionKeys(identifier);\n    }\n    else {\n        localKeys = compressAAIdentifierSecp256k1Keys(identifier);\n    }\n    console.info(\"--- identifier keys2: \", localKeys);\n    // finally map the didDocument keys to the identifier keys by comparing `publicKeyHex`\n    const extendedKeys = documentKeys\n        .map((verificationMethod) => {\n        console.info(\"localKey: \", localKeys);\n        console.info(\"verificationMethod: \", verificationMethod);\n        const localKey = localKeys.find((localKey) => localKey.publicKeyHex === verificationMethod.publicKeyHex ||\n            compareBlockchainAccountId(localKey, verificationMethod));\n        console.info(\"localKey: \", localKey);\n        if (localKey) {\n            const { meta, ...localProps } = localKey;\n            return { ...localProps, meta: { ...meta, verificationMethod } };\n        }\n        else {\n            return null;\n        }\n    })\n        .filter(_veramo_utils__WEBPACK_IMPORTED_MODULE_1__.isDefined);\n    return extendedKeys;\n}\nclass AAKeyManagementSystem extends _veramo_key_manager__WEBPACK_IMPORTED_MODULE_0__.AbstractKeyManagementSystem {\n    providers;\n    constructor(providers) {\n        super();\n        this.providers = providers;\n    }\n    async createKey({ type }) {\n        throw Error('not_supported: AAKeyManagementSystem cannot create new keys');\n    }\n    async importKey(args) {\n        return args;\n    }\n    async listKeys() {\n        console.info(\"********************** listKeys **********************\");\n        const keys = [];\n        for (const provider in this.providers) {\n            const providerInstance = this.providers[provider];\n            if (!providerInstance) {\n                continue;\n            }\n            const account = await providerInstance.getAccount();\n            const key = {\n                kid: `${provider}-${account}`,\n                type: 'Secp256k1',\n                publicKeyHex: '',\n                kms: '',\n                meta: {\n                    account,\n                    provider,\n                    algorithms: ['eth_signMessage', 'eth_signTypedData'],\n                },\n            };\n            keys.push(key);\n        }\n        return keys;\n    }\n    async sharedSecret(args) {\n        console.info(\"********************** sharedSecret **********************\");\n        throw Error('not_implemented: Web3KeyManagementSystem sharedSecret');\n    }\n    async deleteKey(args) {\n        console.info(\"********************** deleteKey **********************\");\n        // this kms doesn't need to delete keys\n        return true;\n    }\n    async sign({ keyRef, algorithm, data, }) {\n        console.info(\"********************** sign **********************\");\n        if (algorithm) {\n            if (algorithm === 'eth_signMessage') {\n                return await this.eth_signMessage(keyRef, data);\n            }\n            else if (['eth_signTypedData', 'EthereumEip712Signature2021'].includes(algorithm)) {\n                return await this.eth_signTypedData(keyRef, data);\n            }\n        }\n        throw Error(`not_supported: Cannot sign ${algorithm} `);\n    }\n    /**\n     * @returns a `0x` prefixed hex string representing the signed EIP712 data\n     */\n    async eth_signTypedData(keyRef, data) {\n        console.info(\"********************** eth_signTypedData **********************\");\n        let msg, msgDomain, msgTypes, msgPrimaryType;\n        const serializedData = (0,ethers__WEBPACK_IMPORTED_MODULE_7__.toUtf8String)(data);\n        try {\n            const jsonData = JSON.parse(serializedData);\n            if (typeof jsonData.domain === 'object' && typeof jsonData.types === 'object') {\n                const { domain, types, message, primaryType } = jsonData;\n                msg = message;\n                msgDomain = domain;\n                msgTypes = types;\n                msgPrimaryType = primaryType;\n            }\n            else {\n                // next check will throw since the data couldn't be parsed\n            }\n        }\n        catch (e) {\n            // next check will throw since the data couldn't be parsed\n        }\n        if (typeof msgDomain !== 'object' || typeof msgTypes !== 'object' || typeof msg !== 'object') {\n            throw Error(`invalid_arguments: Cannot sign typed data. 'domain', 'types', and 'message' must be provided`);\n        }\n        delete msgTypes.EIP712Domain;\n        //const signature = await signer.signTypedData(msgDomain, msgTypes, msg)\n        const signature = \"0xabc\";\n        return signature;\n    }\n    /**\n     * @returns a `0x` prefixed hex string representing the signed message\n     */\n    async eth_signMessage(keyRef, rawMessageBytes) {\n        console.info(\"********************** eth_signMessage **********************\");\n        //const signature = await signer.signMessage(rawMessageBytes)\n        const signature = \"0xabc\";\n        // HEX encoded string, 0x prefixed\n        return signature;\n    }\n}\n//# sourceMappingURL=AAKeyManagementSystem.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BhZ2VudGljLXRydXN0L3ZlcmFtby1hZ2VudC1leHRlbnNpb24vZGlzdC91dGlscy9BQUtleU1hbmFnZW1lbnRTeXN0ZW0uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBa0U7QUFDcEI7QUFDb0I7QUFDa0Y7QUFDcEc7QUFDekM7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxnREFBVTtBQUM5QyxtQ0FBbUMsOENBQVU7QUFDN0MsNkJBQTZCO0FBQzdCLDJDQUEyQyxzREFBYztBQUN6RDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsZ0JBQWdCLG9EQUFTO0FBQ3pCO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsZ0RBQVU7QUFDMUMsK0JBQStCLGdEQUFVLENBQUMsOEVBQStCO0FBQ3pFO0FBQ0EscUNBQXFDLGdEQUFVO0FBQy9DLG9DQUFvQyxnREFBVSxDQUFDLCtFQUFnQztBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxVQUFVO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxnQkFBZ0Isb0RBQVM7QUFDekI7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9CQUFvQixFQUFFLDhEQUFxQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsOENBQVU7QUFDcEMsd0JBQXdCLHNEQUFjO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHNEQUFjO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCw4QkFBOEIsZ0VBQWlCO0FBQy9DO0FBQ0E7QUFDQSwrQkFBK0IsaUVBQWtCO0FBQ2pEO0FBQ0EsMkNBQTJDLG9EQUFTO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc0JBQXNCO0FBQzFDLHFCQUFxQix1QkFBdUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsZ0JBQWdCLG9EQUFTO0FBQ3pCO0FBQ0E7QUFDTyxvQ0FBb0MsNEVBQTJCO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsTUFBTTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsU0FBUyxHQUFHLFFBQVE7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiwwQkFBMEI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELFdBQVc7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0Isb0RBQVk7QUFDM0M7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHNDQUFzQztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9iYXJiL2FhL0Fzc29jaWF0ZWRBY2NvdW50cy9ub2RlX21vZHVsZXMvQGFnZW50aWMtdHJ1c3QvdmVyYW1vLWFnZW50LWV4dGVuc2lvbi9kaXN0L3V0aWxzL0FBS2V5TWFuYWdlbWVudFN5c3RlbS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB0b1V0ZjhTdHJpbmcsIFNpZ25pbmdLZXksIGNvbXB1dGVBZGRyZXNzIH0gZnJvbSAnZXRoZXJzJztcbmltcG9ydCB7IGhleFRvQnl0ZXMsIGJ5dGVzVG9IZXggfSBmcm9tIFwidmllbVwiO1xuaW1wb3J0IHsgQWJzdHJhY3RLZXlNYW5hZ2VtZW50U3lzdGVtIH0gZnJvbSAnQHZlcmFtby9rZXktbWFuYWdlcic7XG5pbXBvcnQgeyBpc0RlZmluZWQsIHJlc29sdmVEaWRPclRocm93LCBkZXJlZmVyZW5jZURpZEtleXMsIGNvbnZlcnRFZDI1NTE5UHVibGljS2V5VG9YMjU1MTksIGNvbnZlcnRFZDI1NTE5UHJpdmF0ZUtleVRvWDI1NTE5IH0gZnJvbSAnQHZlcmFtby91dGlscyc7XG5pbXBvcnQgeyBleHRyYWN0UHVibGljS2V5Qnl0ZXMgfSBmcm9tICdkaWQtand0JztcbmV4cG9ydCBmdW5jdGlvbiBjb21wcmVzc0FBSWRlbnRpZmllclNlY3AyNTZrMUtleXMoaWRlbnRpZmllcikge1xuICAgIHJldHVybiBpZGVudGlmaWVyLmtleXNcbiAgICAgICAgLm1hcCgoa2V5KSA9PiB7XG4gICAgICAgIGlmIChrZXkudHlwZSA9PT0gJ1NlY3AyNTZrMScpIHtcbiAgICAgICAgICAgIGlmIChrZXkucHVibGljS2V5SGV4KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHVibGljQnl0ZXMgPSBoZXhUb0J5dGVzKGtleS5wdWJsaWNLZXlIZXgpO1xuICAgICAgICAgICAgICAgIGtleS5wdWJsaWNLZXlIZXggPSBTaWduaW5nS2V5LmNvbXB1dGVQdWJsaWNLZXkocHVibGljQnl0ZXMsIHRydWUpLnN1YnN0cmluZygyKTtcbiAgICAgICAgICAgICAgICBrZXkubWV0YSA9IHsgLi4ua2V5Lm1ldGEgfTtcbiAgICAgICAgICAgICAgICBrZXkubWV0YS5ldGhlcmV1bUFkZHJlc3MgPSBjb21wdXRlQWRkcmVzcygnMHgnICsga2V5LnB1YmxpY0tleUhleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGtleTtcbiAgICB9KVxuICAgICAgICAuZmlsdGVyKGlzRGVmaW5lZCk7XG59XG5leHBvcnQgZnVuY3Rpb24gY29udmVydEFBSWRlbnRpZmllckVuY3J5cHRpb25LZXlzKGlkZW50aWZpZXIpIHtcbiAgICByZXR1cm4gaWRlbnRpZmllci5rZXlzXG4gICAgICAgIC5tYXAoKGtleSkgPT4ge1xuICAgICAgICBpZiAoa2V5LnR5cGUgPT09ICdFZDI1NTE5Jykge1xuICAgICAgICAgICAgY29uc3QgcHVibGljQnl0ZXMgPSBoZXhUb0J5dGVzKGtleS5wdWJsaWNLZXlIZXgpO1xuICAgICAgICAgICAga2V5LnB1YmxpY0tleUhleCA9IGJ5dGVzVG9IZXgoY29udmVydEVkMjU1MTlQdWJsaWNLZXlUb1gyNTUxOShwdWJsaWNCeXRlcykpO1xuICAgICAgICAgICAgaWYgKGtleS5wcml2YXRlS2V5SGV4KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJpdmF0ZUJ5dGVzID0gaGV4VG9CeXRlcyhrZXkucHJpdmF0ZUtleUhleCk7XG4gICAgICAgICAgICAgICAga2V5LnByaXZhdGVLZXlIZXggPSBieXRlc1RvSGV4KGNvbnZlcnRFZDI1NTE5UHJpdmF0ZUtleVRvWDI1NTE5KHByaXZhdGVCeXRlcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAga2V5LnR5cGUgPSAnWDI1NTE5JztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChrZXkudHlwZSAhPT0gJ1gyNTUxOScpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhga2V5IG9mIHR5cGUgJHtrZXkudHlwZX0gaXMgbm90IHN1cHBvcnRlZCBmb3IgW2RlXWVuY3J5cHRpb25gKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBrZXk7XG4gICAgfSlcbiAgICAgICAgLmZpbHRlcihpc0RlZmluZWQpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldEFBRXRoZXJldW1BZGRyZXNzKHZlcmlmaWNhdGlvbk1ldGhvZCkge1xuICAgIGxldCB2bUV0aEFkZHIgPSB2ZXJpZmljYXRpb25NZXRob2QuZXRoZXJldW1BZGRyZXNzPy50b0xvd2VyQ2FzZSgpO1xuICAgIGlmICghdm1FdGhBZGRyKSB7XG4gICAgICAgIGNvbnN0IGJsb2NrY2hhaW5BY2NvdW50SWQgPSB2ZXJpZmljYXRpb25NZXRob2QuYmxvY2tjaGFpbkFjY291bnRJZDtcbiAgICAgICAgaWYgKGJsb2NrY2hhaW5BY2NvdW50SWQ/LmluY2x1ZGVzKCdAZWlwMTU1JykpIHtcbiAgICAgICAgICAgIHZtRXRoQWRkciA9IGJsb2NrY2hhaW5BY2NvdW50SWQuc3BsaXQoJ0BlaXAxNTUnKVswXT8udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2ZXJpZmljYXRpb25NZXRob2QuYmxvY2tjaGFpbkFjY291bnRJZD8uc3RhcnRzV2l0aCgnZWlwMTU1JykpIHtcbiAgICAgICAgICAgIHZtRXRoQWRkciA9IHZlcmlmaWNhdGlvbk1ldGhvZC5ibG9ja2NoYWluQWNjb3VudElkLnNwbGl0KCc6JylbMl0/LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCB7IGtleUJ5dGVzLCBrZXlUeXBlIH0gPSBleHRyYWN0UHVibGljS2V5Qnl0ZXModmVyaWZpY2F0aW9uTWV0aG9kKTtcbiAgICAgICAgICAgIGlmIChrZXlUeXBlICE9PSAnU2VjcDI1NmsxJykge1xuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwYkhleCA9IFNpZ25pbmdLZXkuY29tcHV0ZVB1YmxpY0tleShrZXlCeXRlcywgZmFsc2UpO1xuICAgICAgICAgICAgdm1FdGhBZGRyID0gY29tcHV0ZUFkZHJlc3MocGJIZXgpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZtRXRoQWRkcjtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjb21wYXJlQmxvY2tjaGFpbkFjY291bnRJZChsb2NhbEtleSwgdmVyaWZpY2F0aW9uTWV0aG9kKSB7XG4gICAgLy9pZiAobG9jYWxLZXkudHlwZSAhPT0gJ1NlY3AyNTZrMScpIHtcbiAgICAvLyAgcmV0dXJuIGZhbHNlXG4gICAgLy99XG4gICAgbGV0IHZtRXRoQWRkciA9IGdldEFBRXRoZXJldW1BZGRyZXNzKHZlcmlmaWNhdGlvbk1ldGhvZCk7XG4gICAgY29uc3QgbG9jYWxBY2NvdW50ID0gbG9jYWxLZXkubWV0YT8uYWNjb3VudCA/PyBsb2NhbEtleS5tZXRhPy5ldGhlcmV1bUFkZHJlc3M7XG4gICAgaWYgKGxvY2FsS2V5Lm1ldGE/LmFjY291bnQpIHtcbiAgICAgICAgY29uc29sZS5pbmZvKFwibG9jYWxLZXkubWV0YS5hY2NvdW50OiBcIiwgbG9jYWxLZXkubWV0YS5hY2NvdW50KTtcbiAgICAgICAgY29uc29sZS5pbmZvKFwidm1FdGhBZGRyOiBcIiwgdm1FdGhBZGRyKTtcbiAgICAgICAgcmV0dXJuIHZtRXRoQWRkciA9PT0gbG9jYWxBY2NvdW50LnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuICAgIGNvbnNvbGUuaW5mbyhcImxvY2FsS2V5LnB1YmxpY0tleUhleDogXCIsIGxvY2FsS2V5LnB1YmxpY0tleUhleCk7XG4gICAgY29uc3QgY29tcHV0ZWRBZGRyID0gY29tcHV0ZUFkZHJlc3MoJzB4JyArIGxvY2FsS2V5LnB1YmxpY0tleUhleCkudG9Mb3dlckNhc2UoKTtcbiAgICBjb25zb2xlLmluZm8oXCJjb21wdXRlZEFkZHI6IFwiLCBjb21wdXRlZEFkZHIpO1xuICAgIGNvbnNvbGUuaW5mbyhcInZtRXRoQWRkcjogXCIsIHZtRXRoQWRkcik7XG4gICAgcmV0dXJuIGNvbXB1dGVkQWRkciA9PT0gdm1FdGhBZGRyO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIG1hcEFBSWRlbnRpZmllcktleXNUb0RvYyhpZGVudGlmaWVyLCBzZWN0aW9uID0gJ2tleUFncmVlbWVudCcsIGNvbnRleHQsIHJlc29sdXRpb25PcHRpb25zKSB7XG4gICAgY29uc3QgZGlkRG9jdW1lbnQgPSBhd2FpdCByZXNvbHZlRGlkT3JUaHJvdyhpZGVudGlmaWVyLmRpZCwgY29udGV4dCwgcmVzb2x1dGlvbk9wdGlvbnMpO1xuICAgIGNvbnNvbGUuaW5mbyhcIi4uLi4uLi4uLi4uLi4uIGRpZERvY3VtZW50OiBcIiwgZGlkRG9jdW1lbnQpO1xuICAgIC8vIGRlcmVmZXJlbmNlIGFsbCBrZXkgYWdyZWVtZW50IGtleXMgZnJvbSBESUQgZG9jdW1lbnQgYW5kIG5vcm1hbGl6ZVxuICAgIGNvbnN0IGRvY3VtZW50S2V5cyA9IGF3YWl0IGRlcmVmZXJlbmNlRGlkS2V5cyhkaWREb2N1bWVudCwgc2VjdGlvbiwgY29udGV4dCk7XG4gICAgY29uc29sZS5pbmZvKFwiLi4uLi4uLi4uLi4uLi4gZG9jdW1lbnRLZXlzOiBcIiwgZG9jdW1lbnRLZXlzKTtcbiAgICBsZXQgbG9jYWxLZXlzID0gaWRlbnRpZmllci5rZXlzLmZpbHRlcihpc0RlZmluZWQpO1xuICAgIGNvbnNvbGUuaW5mbyhcIi0tLSBpZGVudGlmaWVyIGtleXM6IFwiLCBsb2NhbEtleXMpO1xuICAgIGlmIChzZWN0aW9uID09PSAna2V5QWdyZWVtZW50Jykge1xuICAgICAgICBsb2NhbEtleXMgPSBjb252ZXJ0QUFJZGVudGlmaWVyRW5jcnlwdGlvbktleXMoaWRlbnRpZmllcik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBsb2NhbEtleXMgPSBjb21wcmVzc0FBSWRlbnRpZmllclNlY3AyNTZrMUtleXMoaWRlbnRpZmllcik7XG4gICAgfVxuICAgIGNvbnNvbGUuaW5mbyhcIi0tLSBpZGVudGlmaWVyIGtleXMyOiBcIiwgbG9jYWxLZXlzKTtcbiAgICAvLyBmaW5hbGx5IG1hcCB0aGUgZGlkRG9jdW1lbnQga2V5cyB0byB0aGUgaWRlbnRpZmllciBrZXlzIGJ5IGNvbXBhcmluZyBgcHVibGljS2V5SGV4YFxuICAgIGNvbnN0IGV4dGVuZGVkS2V5cyA9IGRvY3VtZW50S2V5c1xuICAgICAgICAubWFwKCh2ZXJpZmljYXRpb25NZXRob2QpID0+IHtcbiAgICAgICAgY29uc29sZS5pbmZvKFwibG9jYWxLZXk6IFwiLCBsb2NhbEtleXMpO1xuICAgICAgICBjb25zb2xlLmluZm8oXCJ2ZXJpZmljYXRpb25NZXRob2Q6IFwiLCB2ZXJpZmljYXRpb25NZXRob2QpO1xuICAgICAgICBjb25zdCBsb2NhbEtleSA9IGxvY2FsS2V5cy5maW5kKChsb2NhbEtleSkgPT4gbG9jYWxLZXkucHVibGljS2V5SGV4ID09PSB2ZXJpZmljYXRpb25NZXRob2QucHVibGljS2V5SGV4IHx8XG4gICAgICAgICAgICBjb21wYXJlQmxvY2tjaGFpbkFjY291bnRJZChsb2NhbEtleSwgdmVyaWZpY2F0aW9uTWV0aG9kKSk7XG4gICAgICAgIGNvbnNvbGUuaW5mbyhcImxvY2FsS2V5OiBcIiwgbG9jYWxLZXkpO1xuICAgICAgICBpZiAobG9jYWxLZXkpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgbWV0YSwgLi4ubG9jYWxQcm9wcyB9ID0gbG9jYWxLZXk7XG4gICAgICAgICAgICByZXR1cm4geyAuLi5sb2NhbFByb3BzLCBtZXRhOiB7IC4uLm1ldGEsIHZlcmlmaWNhdGlvbk1ldGhvZCB9IH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH0pXG4gICAgICAgIC5maWx0ZXIoaXNEZWZpbmVkKTtcbiAgICByZXR1cm4gZXh0ZW5kZWRLZXlzO1xufVxuZXhwb3J0IGNsYXNzIEFBS2V5TWFuYWdlbWVudFN5c3RlbSBleHRlbmRzIEFic3RyYWN0S2V5TWFuYWdlbWVudFN5c3RlbSB7XG4gICAgcHJvdmlkZXJzO1xuICAgIGNvbnN0cnVjdG9yKHByb3ZpZGVycykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnByb3ZpZGVycyA9IHByb3ZpZGVycztcbiAgICB9XG4gICAgYXN5bmMgY3JlYXRlS2V5KHsgdHlwZSB9KSB7XG4gICAgICAgIHRocm93IEVycm9yKCdub3Rfc3VwcG9ydGVkOiBBQUtleU1hbmFnZW1lbnRTeXN0ZW0gY2Fubm90IGNyZWF0ZSBuZXcga2V5cycpO1xuICAgIH1cbiAgICBhc3luYyBpbXBvcnRLZXkoYXJncykge1xuICAgICAgICByZXR1cm4gYXJncztcbiAgICB9XG4gICAgYXN5bmMgbGlzdEtleXMoKSB7XG4gICAgICAgIGNvbnNvbGUuaW5mbyhcIioqKioqKioqKioqKioqKioqKioqKiogbGlzdEtleXMgKioqKioqKioqKioqKioqKioqKioqKlwiKTtcbiAgICAgICAgY29uc3Qga2V5cyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHByb3ZpZGVyIGluIHRoaXMucHJvdmlkZXJzKSB7XG4gICAgICAgICAgICBjb25zdCBwcm92aWRlckluc3RhbmNlID0gdGhpcy5wcm92aWRlcnNbcHJvdmlkZXJdO1xuICAgICAgICAgICAgaWYgKCFwcm92aWRlckluc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhY2NvdW50ID0gYXdhaXQgcHJvdmlkZXJJbnN0YW5jZS5nZXRBY2NvdW50KCk7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSB7XG4gICAgICAgICAgICAgICAga2lkOiBgJHtwcm92aWRlcn0tJHthY2NvdW50fWAsXG4gICAgICAgICAgICAgICAgdHlwZTogJ1NlY3AyNTZrMScsXG4gICAgICAgICAgICAgICAgcHVibGljS2V5SGV4OiAnJyxcbiAgICAgICAgICAgICAgICBrbXM6ICcnLFxuICAgICAgICAgICAgICAgIG1ldGE6IHtcbiAgICAgICAgICAgICAgICAgICAgYWNjb3VudCxcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXIsXG4gICAgICAgICAgICAgICAgICAgIGFsZ29yaXRobXM6IFsnZXRoX3NpZ25NZXNzYWdlJywgJ2V0aF9zaWduVHlwZWREYXRhJ10sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ga2V5cztcbiAgICB9XG4gICAgYXN5bmMgc2hhcmVkU2VjcmV0KGFyZ3MpIHtcbiAgICAgICAgY29uc29sZS5pbmZvKFwiKioqKioqKioqKioqKioqKioqKioqKiBzaGFyZWRTZWNyZXQgKioqKioqKioqKioqKioqKioqKioqKlwiKTtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ25vdF9pbXBsZW1lbnRlZDogV2ViM0tleU1hbmFnZW1lbnRTeXN0ZW0gc2hhcmVkU2VjcmV0Jyk7XG4gICAgfVxuICAgIGFzeW5jIGRlbGV0ZUtleShhcmdzKSB7XG4gICAgICAgIGNvbnNvbGUuaW5mbyhcIioqKioqKioqKioqKioqKioqKioqKiogZGVsZXRlS2V5ICoqKioqKioqKioqKioqKioqKioqKipcIik7XG4gICAgICAgIC8vIHRoaXMga21zIGRvZXNuJ3QgbmVlZCB0byBkZWxldGUga2V5c1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgYXN5bmMgc2lnbih7IGtleVJlZiwgYWxnb3JpdGhtLCBkYXRhLCB9KSB7XG4gICAgICAgIGNvbnNvbGUuaW5mbyhcIioqKioqKioqKioqKioqKioqKioqKiogc2lnbiAqKioqKioqKioqKioqKioqKioqKioqXCIpO1xuICAgICAgICBpZiAoYWxnb3JpdGhtKSB7XG4gICAgICAgICAgICBpZiAoYWxnb3JpdGhtID09PSAnZXRoX3NpZ25NZXNzYWdlJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmV0aF9zaWduTWVzc2FnZShrZXlSZWYsIGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoWydldGhfc2lnblR5cGVkRGF0YScsICdFdGhlcmV1bUVpcDcxMlNpZ25hdHVyZTIwMjEnXS5pbmNsdWRlcyhhbGdvcml0aG0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZXRoX3NpZ25UeXBlZERhdGEoa2V5UmVmLCBkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBFcnJvcihgbm90X3N1cHBvcnRlZDogQ2Fubm90IHNpZ24gJHthbGdvcml0aG19IGApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBhIGAweGAgcHJlZml4ZWQgaGV4IHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHNpZ25lZCBFSVA3MTIgZGF0YVxuICAgICAqL1xuICAgIGFzeW5jIGV0aF9zaWduVHlwZWREYXRhKGtleVJlZiwgZGF0YSkge1xuICAgICAgICBjb25zb2xlLmluZm8oXCIqKioqKioqKioqKioqKioqKioqKioqIGV0aF9zaWduVHlwZWREYXRhICoqKioqKioqKioqKioqKioqKioqKipcIik7XG4gICAgICAgIGxldCBtc2csIG1zZ0RvbWFpbiwgbXNnVHlwZXMsIG1zZ1ByaW1hcnlUeXBlO1xuICAgICAgICBjb25zdCBzZXJpYWxpemVkRGF0YSA9IHRvVXRmOFN0cmluZyhkYXRhKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGpzb25EYXRhID0gSlNPTi5wYXJzZShzZXJpYWxpemVkRGF0YSk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGpzb25EYXRhLmRvbWFpbiA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIGpzb25EYXRhLnR5cGVzID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZG9tYWluLCB0eXBlcywgbWVzc2FnZSwgcHJpbWFyeVR5cGUgfSA9IGpzb25EYXRhO1xuICAgICAgICAgICAgICAgIG1zZyA9IG1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgbXNnRG9tYWluID0gZG9tYWluO1xuICAgICAgICAgICAgICAgIG1zZ1R5cGVzID0gdHlwZXM7XG4gICAgICAgICAgICAgICAgbXNnUHJpbWFyeVR5cGUgPSBwcmltYXJ5VHlwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIG5leHQgY2hlY2sgd2lsbCB0aHJvdyBzaW5jZSB0aGUgZGF0YSBjb3VsZG4ndCBiZSBwYXJzZWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy8gbmV4dCBjaGVjayB3aWxsIHRocm93IHNpbmNlIHRoZSBkYXRhIGNvdWxkbid0IGJlIHBhcnNlZFxuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgbXNnRG9tYWluICE9PSAnb2JqZWN0JyB8fCB0eXBlb2YgbXNnVHlwZXMgIT09ICdvYmplY3QnIHx8IHR5cGVvZiBtc2cgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihgaW52YWxpZF9hcmd1bWVudHM6IENhbm5vdCBzaWduIHR5cGVkIGRhdGEuICdkb21haW4nLCAndHlwZXMnLCBhbmQgJ21lc3NhZ2UnIG11c3QgYmUgcHJvdmlkZWRgKTtcbiAgICAgICAgfVxuICAgICAgICBkZWxldGUgbXNnVHlwZXMuRUlQNzEyRG9tYWluO1xuICAgICAgICAvL2NvbnN0IHNpZ25hdHVyZSA9IGF3YWl0IHNpZ25lci5zaWduVHlwZWREYXRhKG1zZ0RvbWFpbiwgbXNnVHlwZXMsIG1zZylcbiAgICAgICAgY29uc3Qgc2lnbmF0dXJlID0gXCIweGFiY1wiO1xuICAgICAgICByZXR1cm4gc2lnbmF0dXJlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBhIGAweGAgcHJlZml4ZWQgaGV4IHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHNpZ25lZCBtZXNzYWdlXG4gICAgICovXG4gICAgYXN5bmMgZXRoX3NpZ25NZXNzYWdlKGtleVJlZiwgcmF3TWVzc2FnZUJ5dGVzKSB7XG4gICAgICAgIGNvbnNvbGUuaW5mbyhcIioqKioqKioqKioqKioqKioqKioqKiogZXRoX3NpZ25NZXNzYWdlICoqKioqKioqKioqKioqKioqKioqKipcIik7XG4gICAgICAgIC8vY29uc3Qgc2lnbmF0dXJlID0gYXdhaXQgc2lnbmVyLnNpZ25NZXNzYWdlKHJhd01lc3NhZ2VCeXRlcylcbiAgICAgICAgY29uc3Qgc2lnbmF0dXJlID0gXCIweGFiY1wiO1xuICAgICAgICAvLyBIRVggZW5jb2RlZCBzdHJpbmcsIDB4IHByZWZpeGVkXG4gICAgICAgIHJldHVybiBzaWduYXR1cmU7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QUFLZXlNYW5hZ2VtZW50U3lzdGVtLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@agentic-trust/veramo-agent-extension/dist/utils/AAKeyManagementSystem.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@agentic-trust/veramo-agent-extension/dist/utils/AAKmsSigner.js":
/*!******************************************************************************************!*\
  !*** ../../node_modules/@agentic-trust/veramo-agent-extension/dist/utils/AAKmsSigner.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AAKmsSigner: () => (/* binding */ AAKmsSigner)\n/* harmony export */ });\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ethers */ \"(rsc)/../../node_modules/ethers/lib.esm/providers/abstract-signer.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ethers */ \"(rsc)/../../node_modules/ethers/lib.esm/transaction/address.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ethers */ \"(rsc)/../../node_modules/ethers/lib.esm/address/address.js\");\n\n/**\n * Creates an `ethers` - `signer` implementation by wrapping\n * a veramo agent with a key-manager that should be capable of `eth_signTransaction`\n *\n * @internal This is exported for convenience, not meant to be supported as part of the public API\n */\nclass AAKmsSigner extends ethers__WEBPACK_IMPORTED_MODULE_0__.AbstractSigner {\n    context;\n    controllerKey;\n    provider;\n    constructor(controllerKey, context, provider) {\n        super(provider);\n        this.controllerKey = controllerKey;\n        this.context = context;\n        this.provider = provider || null;\n    }\n    async getAddress() {\n        // publicKeyHex is not available when using web3provider\n        if (this.controllerKey.meta?.account) {\n            return this.controllerKey.meta?.account;\n        }\n        return (0,ethers__WEBPACK_IMPORTED_MODULE_1__.computeAddress)('0x' + this.controllerKey.publicKeyHex);\n    }\n    async signTransaction(transaction) {\n        if (transaction.from != null) {\n            const thisAddress = await this.getAddress();\n            if ((0,ethers__WEBPACK_IMPORTED_MODULE_2__.getAddress)(transaction.from) !== thisAddress) {\n                throw new Error(`transaction from address mismatch ${transaction.from} != ${thisAddress}`);\n            }\n        }\n        console.info(\"********** call aa signTransaction **********\");\n        const signature = \"create signature\";\n        /*\n        const signature = await this.context.agent.keyManagerSign({\n          keyRef: this.controllerKey.kid,\n          data: transaction.unsignedSerialized,\n          algorithm: 'eth_signTransaction',\n          encoding: 'base16',\n        })\n        */\n        return signature;\n    }\n    async signTypedData(domain, types, value) {\n        console.info(\"********** call aa signTransaction **********\");\n        const signature = \"create signature\";\n        return signature;\n        /*\n        return this.context.agent.keyManagerSign({\n          keyRef: this.controllerKey.kid,\n          algorithm: 'eth_signTypedData',\n          data: data,\n        });\n        */\n    }\n    signMessage(message) {\n        throw new Error('not_implemented: signMessage() Method not implemented by AAKmsSigner.');\n    }\n    connect(provider) {\n        if (!provider) {\n            throw new Error('provider must not be null');\n        }\n        return new AAKmsSigner(this.controllerKey, this.context, provider);\n    }\n}\n//# sourceMappingURL=AAKmsSigner.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BhZ2VudGljLXRydXN0L3ZlcmFtby1hZ2VudC1leHRlbnNpb24vZGlzdC91dGlscy9BQUttc1NpZ25lci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQXFFO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLDBCQUEwQixrREFBYztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxzREFBYztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixrREFBVTtBQUMxQixxRUFBcUUsa0JBQWtCLEtBQUssWUFBWTtBQUN4RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL2JhcmIvYWEvQXNzb2NpYXRlZEFjY291bnRzL25vZGVfbW9kdWxlcy9AYWdlbnRpYy10cnVzdC92ZXJhbW8tYWdlbnQtZXh0ZW5zaW9uL2Rpc3QvdXRpbHMvQUFLbXNTaWduZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZ2V0QWRkcmVzcywgY29tcHV0ZUFkZHJlc3MsIEFic3RyYWN0U2lnbmVyLCB9IGZyb20gJ2V0aGVycyc7XG4vKipcbiAqIENyZWF0ZXMgYW4gYGV0aGVyc2AgLSBgc2lnbmVyYCBpbXBsZW1lbnRhdGlvbiBieSB3cmFwcGluZ1xuICogYSB2ZXJhbW8gYWdlbnQgd2l0aCBhIGtleS1tYW5hZ2VyIHRoYXQgc2hvdWxkIGJlIGNhcGFibGUgb2YgYGV0aF9zaWduVHJhbnNhY3Rpb25gXG4gKlxuICogQGludGVybmFsIFRoaXMgaXMgZXhwb3J0ZWQgZm9yIGNvbnZlbmllbmNlLCBub3QgbWVhbnQgdG8gYmUgc3VwcG9ydGVkIGFzIHBhcnQgb2YgdGhlIHB1YmxpYyBBUElcbiAqL1xuZXhwb3J0IGNsYXNzIEFBS21zU2lnbmVyIGV4dGVuZHMgQWJzdHJhY3RTaWduZXIge1xuICAgIGNvbnRleHQ7XG4gICAgY29udHJvbGxlcktleTtcbiAgICBwcm92aWRlcjtcbiAgICBjb25zdHJ1Y3Rvcihjb250cm9sbGVyS2V5LCBjb250ZXh0LCBwcm92aWRlcikge1xuICAgICAgICBzdXBlcihwcm92aWRlcik7XG4gICAgICAgIHRoaXMuY29udHJvbGxlcktleSA9IGNvbnRyb2xsZXJLZXk7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgIHRoaXMucHJvdmlkZXIgPSBwcm92aWRlciB8fCBudWxsO1xuICAgIH1cbiAgICBhc3luYyBnZXRBZGRyZXNzKCkge1xuICAgICAgICAvLyBwdWJsaWNLZXlIZXggaXMgbm90IGF2YWlsYWJsZSB3aGVuIHVzaW5nIHdlYjNwcm92aWRlclxuICAgICAgICBpZiAodGhpcy5jb250cm9sbGVyS2V5Lm1ldGE/LmFjY291bnQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnRyb2xsZXJLZXkubWV0YT8uYWNjb3VudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29tcHV0ZUFkZHJlc3MoJzB4JyArIHRoaXMuY29udHJvbGxlcktleS5wdWJsaWNLZXlIZXgpO1xuICAgIH1cbiAgICBhc3luYyBzaWduVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pIHtcbiAgICAgICAgaWYgKHRyYW5zYWN0aW9uLmZyb20gIT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgdGhpc0FkZHJlc3MgPSBhd2FpdCB0aGlzLmdldEFkZHJlc3MoKTtcbiAgICAgICAgICAgIGlmIChnZXRBZGRyZXNzKHRyYW5zYWN0aW9uLmZyb20pICE9PSB0aGlzQWRkcmVzcykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgdHJhbnNhY3Rpb24gZnJvbSBhZGRyZXNzIG1pc21hdGNoICR7dHJhbnNhY3Rpb24uZnJvbX0gIT0gJHt0aGlzQWRkcmVzc31gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zb2xlLmluZm8oXCIqKioqKioqKioqIGNhbGwgYWEgc2lnblRyYW5zYWN0aW9uICoqKioqKioqKipcIik7XG4gICAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IFwiY3JlYXRlIHNpZ25hdHVyZVwiO1xuICAgICAgICAvKlxuICAgICAgICBjb25zdCBzaWduYXR1cmUgPSBhd2FpdCB0aGlzLmNvbnRleHQuYWdlbnQua2V5TWFuYWdlclNpZ24oe1xuICAgICAgICAgIGtleVJlZjogdGhpcy5jb250cm9sbGVyS2V5LmtpZCxcbiAgICAgICAgICBkYXRhOiB0cmFuc2FjdGlvbi51bnNpZ25lZFNlcmlhbGl6ZWQsXG4gICAgICAgICAgYWxnb3JpdGhtOiAnZXRoX3NpZ25UcmFuc2FjdGlvbicsXG4gICAgICAgICAgZW5jb2Rpbmc6ICdiYXNlMTYnLFxuICAgICAgICB9KVxuICAgICAgICAqL1xuICAgICAgICByZXR1cm4gc2lnbmF0dXJlO1xuICAgIH1cbiAgICBhc3luYyBzaWduVHlwZWREYXRhKGRvbWFpbiwgdHlwZXMsIHZhbHVlKSB7XG4gICAgICAgIGNvbnNvbGUuaW5mbyhcIioqKioqKioqKiogY2FsbCBhYSBzaWduVHJhbnNhY3Rpb24gKioqKioqKioqKlwiKTtcbiAgICAgICAgY29uc3Qgc2lnbmF0dXJlID0gXCJjcmVhdGUgc2lnbmF0dXJlXCI7XG4gICAgICAgIHJldHVybiBzaWduYXR1cmU7XG4gICAgICAgIC8qXG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRleHQuYWdlbnQua2V5TWFuYWdlclNpZ24oe1xuICAgICAgICAgIGtleVJlZjogdGhpcy5jb250cm9sbGVyS2V5LmtpZCxcbiAgICAgICAgICBhbGdvcml0aG06ICdldGhfc2lnblR5cGVkRGF0YScsXG4gICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgfSk7XG4gICAgICAgICovXG4gICAgfVxuICAgIHNpZ25NZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdub3RfaW1wbGVtZW50ZWQ6IHNpZ25NZXNzYWdlKCkgTWV0aG9kIG5vdCBpbXBsZW1lbnRlZCBieSBBQUttc1NpZ25lci4nKTtcbiAgICB9XG4gICAgY29ubmVjdChwcm92aWRlcikge1xuICAgICAgICBpZiAoIXByb3ZpZGVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb3ZpZGVyIG11c3Qgbm90IGJlIG51bGwnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEFBS21zU2lnbmVyKHRoaXMuY29udHJvbGxlcktleSwgdGhpcy5jb250ZXh0LCBwcm92aWRlcik7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QUFLbXNTaWduZXIuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@agentic-trust/veramo-agent-extension/dist/utils/AAKmsSigner.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@agentic-trust/veramo-agent-extension/dist/utils/AAResolver.js":
/*!*****************************************************************************************!*\
  !*** ../../node_modules/@agentic-trust/veramo-agent-extension/dist/utils/AAResolver.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getAAResolver: () => (/* binding */ getAAResolver)\n/* harmony export */ });\n/* harmony import */ var caip__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! caip */ \"(rsc)/../../node_modules/caip/dist/index.mjs\");\n\nconst DID_LD_JSON = 'application/did+ld+json';\nconst DID_JSON = 'application/did+json';\nfunction toDidDoc(did, blockchainAccountId) {\n    const { namespace } = caip__WEBPACK_IMPORTED_MODULE_0__.AccountId.parse(blockchainAccountId)\n        .chainId;\n    const vmId = did + '#blockchainAccountId';\n    const doc = {\n        '@context': [\n            'https://www.w3.org/ns/did/v1',\n            {\n                blockchainAccountId: 'https://w3id.org/security#blockchainAccountId',\n                EcdsaSecp256k1RecoveryMethod2020: 'https://identity.foundation/EcdsaSecp256k1RecoverySignature2020#EcdsaSecp256k1RecoveryMethod2020',\n            },\n        ],\n        id: did,\n        verificationMethod: [\n            {\n                id: vmId,\n                type: 'EcdsaSecp256k1RecoveryMethod2020',\n                controller: did,\n                blockchainAccountId,\n            },\n        ],\n        authentication: [vmId],\n        assertionMethod: [vmId],\n    };\n    return doc;\n}\nfunction getAAResolver() {\n    return {\n        aa: async (did, parsed, r, options) => {\n            console.info(\">>>>>>>> inside aa resolver: did: \", did);\n            const contentType = options.accept || DID_JSON;\n            const response = {\n                didResolutionMetadata: { contentType },\n                didDocument: null,\n                didDocumentMetadata: {},\n            };\n            try {\n                const doc = toDidDoc(did, parsed.id);\n                if (contentType === DID_LD_JSON) {\n                    response.didDocument = doc;\n                }\n                else if (contentType === DID_JSON) {\n                    delete doc['@context'];\n                    response.didDocument = doc;\n                }\n                else {\n                    delete response.didResolutionMetadata.contentType;\n                    response.didResolutionMetadata.error = 'representationNotSupported';\n                }\n            }\n            catch (e) {\n                response.didResolutionMetadata.error = 'invalidDid';\n                response.didResolutionMetadata.message = e.message;\n            }\n            console.info(\">>>>>>>> inside aa resolver: response: \", JSON.stringify(response));\n            return response;\n        },\n    };\n}\n//# sourceMappingURL=AAResolver.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BhZ2VudGljLXRydXN0L3ZlcmFtby1hZ2VudC1leHRlbnNpb24vZGlzdC91dGlscy9BQVJlc29sdmVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLFlBQVksWUFBWSxFQUFFLDJDQUFTO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsYUFBYTtBQUN0RDtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9iYXJiL2FhL0Fzc29jaWF0ZWRBY2NvdW50cy9ub2RlX21vZHVsZXMvQGFnZW50aWMtdHJ1c3QvdmVyYW1vLWFnZW50LWV4dGVuc2lvbi9kaXN0L3V0aWxzL0FBUmVzb2x2ZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQWNjb3VudElkIH0gZnJvbSAnY2FpcCc7XG5jb25zdCBESURfTERfSlNPTiA9ICdhcHBsaWNhdGlvbi9kaWQrbGQranNvbic7XG5jb25zdCBESURfSlNPTiA9ICdhcHBsaWNhdGlvbi9kaWQranNvbic7XG5mdW5jdGlvbiB0b0RpZERvYyhkaWQsIGJsb2NrY2hhaW5BY2NvdW50SWQpIHtcbiAgICBjb25zdCB7IG5hbWVzcGFjZSB9ID0gQWNjb3VudElkLnBhcnNlKGJsb2NrY2hhaW5BY2NvdW50SWQpXG4gICAgICAgIC5jaGFpbklkO1xuICAgIGNvbnN0IHZtSWQgPSBkaWQgKyAnI2Jsb2NrY2hhaW5BY2NvdW50SWQnO1xuICAgIGNvbnN0IGRvYyA9IHtcbiAgICAgICAgJ0Bjb250ZXh0JzogW1xuICAgICAgICAgICAgJ2h0dHBzOi8vd3d3LnczLm9yZy9ucy9kaWQvdjEnLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGJsb2NrY2hhaW5BY2NvdW50SWQ6ICdodHRwczovL3czaWQub3JnL3NlY3VyaXR5I2Jsb2NrY2hhaW5BY2NvdW50SWQnLFxuICAgICAgICAgICAgICAgIEVjZHNhU2VjcDI1NmsxUmVjb3ZlcnlNZXRob2QyMDIwOiAnaHR0cHM6Ly9pZGVudGl0eS5mb3VuZGF0aW9uL0VjZHNhU2VjcDI1NmsxUmVjb3ZlcnlTaWduYXR1cmUyMDIwI0VjZHNhU2VjcDI1NmsxUmVjb3ZlcnlNZXRob2QyMDIwJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgICAgIGlkOiBkaWQsXG4gICAgICAgIHZlcmlmaWNhdGlvbk1ldGhvZDogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlkOiB2bUlkLFxuICAgICAgICAgICAgICAgIHR5cGU6ICdFY2RzYVNlY3AyNTZrMVJlY292ZXJ5TWV0aG9kMjAyMCcsXG4gICAgICAgICAgICAgICAgY29udHJvbGxlcjogZGlkLFxuICAgICAgICAgICAgICAgIGJsb2NrY2hhaW5BY2NvdW50SWQsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgICAgICBhdXRoZW50aWNhdGlvbjogW3ZtSWRdLFxuICAgICAgICBhc3NlcnRpb25NZXRob2Q6IFt2bUlkXSxcbiAgICB9O1xuICAgIHJldHVybiBkb2M7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0QUFSZXNvbHZlcigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBhYTogYXN5bmMgKGRpZCwgcGFyc2VkLCByLCBvcHRpb25zKSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmluZm8oXCI+Pj4+Pj4+PiBpbnNpZGUgYWEgcmVzb2x2ZXI6IGRpZDogXCIsIGRpZCk7XG4gICAgICAgICAgICBjb25zdCBjb250ZW50VHlwZSA9IG9wdGlvbnMuYWNjZXB0IHx8IERJRF9KU09OO1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgICAgZGlkUmVzb2x1dGlvbk1ldGFkYXRhOiB7IGNvbnRlbnRUeXBlIH0sXG4gICAgICAgICAgICAgICAgZGlkRG9jdW1lbnQ6IG51bGwsXG4gICAgICAgICAgICAgICAgZGlkRG9jdW1lbnRNZXRhZGF0YToge30sXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBkb2MgPSB0b0RpZERvYyhkaWQsIHBhcnNlZC5pZCk7XG4gICAgICAgICAgICAgICAgaWYgKGNvbnRlbnRUeXBlID09PSBESURfTERfSlNPTikge1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5kaWREb2N1bWVudCA9IGRvYztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY29udGVudFR5cGUgPT09IERJRF9KU09OKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBkb2NbJ0Bjb250ZXh0J107XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLmRpZERvY3VtZW50ID0gZG9jO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHJlc3BvbnNlLmRpZFJlc29sdXRpb25NZXRhZGF0YS5jb250ZW50VHlwZTtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UuZGlkUmVzb2x1dGlvbk1ldGFkYXRhLmVycm9yID0gJ3JlcHJlc2VudGF0aW9uTm90U3VwcG9ydGVkJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlLmRpZFJlc29sdXRpb25NZXRhZGF0YS5lcnJvciA9ICdpbnZhbGlkRGlkJztcbiAgICAgICAgICAgICAgICByZXNwb25zZS5kaWRSZXNvbHV0aW9uTWV0YWRhdGEubWVzc2FnZSA9IGUubWVzc2FnZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhcIj4+Pj4+Pj4+IGluc2lkZSBhYSByZXNvbHZlcjogcmVzcG9uc2U6IFwiLCBKU09OLnN0cmluZ2lmeShyZXNwb25zZSkpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICB9LFxuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1BQVJlc29sdmVyLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@agentic-trust/veramo-agent-extension/dist/utils/AAResolver.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@agentic-trust/veramo-agent-extension/dist/utils/AATypes.js":
/*!**************************************************************************************!*\
  !*** ../../node_modules/@agentic-trust/veramo-agent-extension/dist/utils/AATypes.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n\n//# sourceMappingURL=AATypes.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BhZ2VudGljLXRydXN0L3ZlcmFtby1hZ2VudC1leHRlbnNpb24vZGlzdC91dGlscy9BQVR5cGVzLmpzIiwibWFwcGluZ3MiOiI7QUFBVTtBQUNWIiwic291cmNlcyI6WyIvaG9tZS9iYXJiL2FhL0Fzc29jaWF0ZWRBY2NvdW50cy9ub2RlX21vZHVsZXMvQGFnZW50aWMtdHJ1c3QvdmVyYW1vLWFnZW50LWV4dGVuc2lvbi9kaXN0L3V0aWxzL0FBVHlwZXMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHt9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QUFUeXBlcy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@agentic-trust/veramo-agent-extension/dist/utils/AATypes.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@agentic-trust/veramo-agent-extension/dist/utils/AgentCredentialIssuerEIP1271.js":
/*!***********************************************************************************************************!*\
  !*** ../../node_modules/@agentic-trust/veramo-agent-extension/dist/utils/AgentCredentialIssuerEIP1271.js ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AgentCredentialIssuerEIP1271: () => (/* binding */ AgentCredentialIssuerEIP1271)\n/* harmony export */ });\n/* harmony import */ var _veramo_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @veramo/utils */ \"(rsc)/../../node_modules/@veramo/utils/build/index.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ethers */ \"(rsc)/../../node_modules/ethers/lib.esm/hash/typed-data.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! viem */ \"(rsc)/../../node_modules/viem/_esm/utils/abi/encodeFunctionData.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! viem */ \"(rsc)/../../node_modules/viem/_esm/clients/createPublicClient.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! viem */ \"(rsc)/../../node_modules/viem/_esm/clients/transports/http.js\");\n/* harmony import */ var viem_chains__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! viem/chains */ \"(rsc)/../../node_modules/viem/_esm/chains/definitions/sepolia.js\");\n/* harmony import */ var eip_712_types_generation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! eip-712-types-generation */ \"(rsc)/../../node_modules/eip-712-types-generation/dist/index.js\");\n/* harmony import */ var _IdentityRegistry_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./IdentityRegistry.js */ \"(rsc)/../../node_modules/@agentic-trust/veramo-agent-extension/dist/utils/IdentityRegistry.js\");\n/* harmony import */ var _agentic_trust_8004_ext_sdk__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @agentic-trust/8004-ext-sdk */ \"(rsc)/../../node_modules/@agentic-trust/8004-ext-sdk/dist/index.js\");\n\n\n\n\nconst chain = viem_chains__WEBPACK_IMPORTED_MODULE_1__.sepolia;\n\n\n\n// Extracts the numeric agentId from a verificationMethod object.\n// Accepts fields like:\n// - agentId: 'eip155:11155111:13'\n// - controller: 'did:8004:eip155:11155111:13'\n// - id: 'did:8004:eip155:11155111:13#agentId'\nfunction getVerMethodAgentId(verificationMethod) {\n    try {\n        const vm = verificationMethod || {};\n        if (typeof vm.agentId === 'string' && vm.agentId.length > 0) {\n            const base = vm.agentId.split('#')[0];\n            const parts = base.split(':');\n            return parts[parts.length - 1];\n        }\n        const from = (typeof vm.controller === 'string' && vm.controller) ||\n            (typeof vm.id === 'string' && vm.id) ||\n            undefined;\n        if (from) {\n            const base = from.split('#')[0];\n            if (!base) {\n                return undefined;\n            }\n            const parts = base.split(':');\n            if (parts.length >= 5 && parts[0] === 'did' && parts[1] === '8004') {\n                return parts[parts.length - 1];\n            }\n        }\n    }\n    catch { }\n    return undefined;\n}\nclass AgentCredentialIssuerEIP1271 {\n    methods;\n    constructor() {\n        this.methods = {\n            createVerifiableCredentialEIP1271: this.createVerifiableCredentialEIP1271.bind(this),\n            createVerifiablePresentationEIP1271: this.createVerifiablePresentationEIP1271.bind(this),\n            verifyCredentialEIP1271: this.verifyCredentialEIP1271.bind(this),\n            verifyPresentationEIP1271: this.verifyPresentationEIP1271.bind(this),\n        };\n    }\n    async createVerifiableCredentialEIP1271(args, context) {\n        const credentialContext = (0,_veramo_utils__WEBPACK_IMPORTED_MODULE_0__.processEntryToArray)(args?.credential?.['@context'], _veramo_utils__WEBPACK_IMPORTED_MODULE_0__.MANDATORY_CREDENTIAL_CONTEXT);\n        const credentialType = (0,_veramo_utils__WEBPACK_IMPORTED_MODULE_0__.processEntryToArray)(args?.credential?.type, 'VerifiableCredential');\n        let issuanceDate = args?.credential?.issuanceDate || new Date().toISOString();\n        if (issuanceDate instanceof Date) {\n            issuanceDate = issuanceDate.toISOString();\n        }\n        const issuer = args.credential.issuer;\n        if (!issuer || typeof issuer === 'string') {\n            throw new Error('Issuer must be an object with an \"id\" and \"did\" signer');\n        }\n        console.info(\"Creating Verifiable Credential EIP1271 with issuer:\", issuer);\n        const identifier = await context.agent.didManagerGet({ did: issuer.id });\n        const did8004 = (0,_agentic_trust_8004_ext_sdk__WEBPACK_IMPORTED_MODULE_4__.parseDid8004)(identifier.did);\n        let chainId;\n        try {\n            chainId = did8004.chainId;\n        }\n        catch (e) {\n            chainId = 11155111;\n        }\n        // point to a DID controller that supports smart contract-based signature verification\n        const credential = {\n            ...args?.credential,\n            '@context': credentialContext,\n            type: credentialType,\n            issuanceDate,\n            proof: {\n                verificationMethod: identifier.did + \"#ethereumAddress\",\n                created: issuanceDate,\n                proofPurpose: 'assertionMethod',\n                type: 'EthereumEip712Signature2021',\n            },\n        };\n        const message = credential;\n        const domain = {\n            chainId,\n            name: 'VerifiableCredential',\n            version: '1',\n        };\n        const primaryType = 'VerifiableCredential';\n        const allTypes = (0,eip_712_types_generation__WEBPACK_IMPORTED_MODULE_2__.getEthTypesFromInputDoc)(credential, primaryType);\n        const types = { ...allTypes };\n        const signature = await args?.signer?.signTypedData(domain, types, message);\n        credential['proof']['proofValue'] = signature;\n        credential['proof']['eip712'] = {\n            domain,\n            types: allTypes,\n            primaryType,\n        };\n        return credential;\n    }\n    async createVerifiablePresentationEIP1271(args, context) {\n        console.info(\"Creating Verifiable Presentation EIP1271 with args:\", args);\n        const presentationContext = (0,_veramo_utils__WEBPACK_IMPORTED_MODULE_0__.processEntryToArray)(args?.presentation?.['@context'], _veramo_utils__WEBPACK_IMPORTED_MODULE_0__.MANDATORY_CREDENTIAL_CONTEXT);\n        const presentationType = (0,_veramo_utils__WEBPACK_IMPORTED_MODULE_0__.processEntryToArray)(args?.presentation?.type, 'VerifiablePresentation');\n        let issuanceDate = args?.presentation?.issuanceDate || new Date().toISOString();\n        if (issuanceDate instanceof Date) {\n            issuanceDate = issuanceDate.toISOString();\n        }\n        const presentation = {\n            ...args?.presentation,\n            '@context': presentationContext,\n            type: presentationType,\n            issuanceDate,\n        };\n        if (!(0,_veramo_utils__WEBPACK_IMPORTED_MODULE_0__.isDefined)(args.presentation.holder)) {\n            throw new Error('invalid_argument: presentation.holder must not be empty');\n        }\n        if (args.presentation.verifiableCredential) {\n            presentation.verifiableCredential = args.presentation.verifiableCredential.map((cred) => {\n                // map JWT credentials to their canonical form\n                if (typeof cred === 'string') {\n                    return cred;\n                }\n                else if (cred.proof.jwt) {\n                    return cred.proof.jwt;\n                }\n                else {\n                    return JSON.stringify(cred);\n                }\n            });\n        }\n        const holder = (0,_veramo_utils__WEBPACK_IMPORTED_MODULE_0__.removeDIDParameters)(presentation.holder);\n        let identifier;\n        try {\n            identifier = await context.agent.didManagerGet({ did: holder });\n        }\n        catch (e) {\n            throw new Error('invalid_argument: presentation.holder must be a DID managed by this agent');\n        }\n        console.info(\"identifier: \", identifier);\n        const did8004 = (0,_agentic_trust_8004_ext_sdk__WEBPACK_IMPORTED_MODULE_4__.parseDid8004)(identifier.did);\n        let chainId;\n        try {\n            chainId = did8004.chainId;\n        }\n        catch (e) {\n            chainId = 11155111;\n        }\n        presentation['proof'] = {\n            verificationMethod: did8004.agentId + \"#agentId\",\n            created: issuanceDate,\n            proofPurpose: 'assertionMethod',\n            type: 'EthereumEip712Signature2021',\n        };\n        const message = presentation;\n        const domain = {\n            chainId,\n            name: 'VerifiablePresentation',\n            version: '1',\n        };\n        const primaryType = 'VerifiablePresentation';\n        const allTypes = (0,eip_712_types_generation__WEBPACK_IMPORTED_MODULE_2__.getEthTypesFromInputDoc)(presentation, primaryType);\n        const types = { ...allTypes };\n        const signature = await args?.signer?.signTypedData(domain, types, message);\n        presentation.proof.proofValue = signature;\n        presentation.proof.eip712 = {\n            domain,\n            types: allTypes,\n            primaryType,\n        };\n        return presentation;\n    }\n    async verifyCredentialEIP1271(args, context) {\n        console.info(\"verifyCredentialEIP1271 called with args: \", args);\n        // check that proof exists\n        const { credential } = args;\n        if (!credential.proof || !credential.proof.proofValue)\n            throw new Error('invalid_argument: proof is undefined');\n        const { proof, ...signingInput } = credential;\n        const { proofValue, eip712, ...verifyInputProof } = proof;\n        const verificationMessage = {\n            ...signingInput,\n            proof: verifyInputProof,\n        };\n        const compat = {\n            ...eip712,\n        };\n        compat.types = compat.types || compat.messageSchema;\n        if (!compat.primaryType || !compat.types || !compat.domain) {\n            throw new Error('invalid_argument: proof is missing expected properties');\n        }\n        const filteredTypes = { ...compat.types };\n        delete filteredTypes.EIP712Domain;\n        const digest = ethers__WEBPACK_IMPORTED_MODULE_5__.TypedDataEncoder.hash(compat.domain, filteredTypes, verificationMessage);\n        const signature = proofValue;\n        console.info(\"............... signature: \", signature);\n        console.info(\"............... digest: \", digest);\n        const isValidSignatureData = (0,viem__WEBPACK_IMPORTED_MODULE_6__.encodeFunctionData)({\n            abi: [\n                {\n                    name: \"isValidSignature\",\n                    type: \"function\",\n                    inputs: [\n                        { name: \"_hash\", type: \"bytes32\" },\n                        { name: \"_signature\", type: \"bytes\" },\n                    ],\n                    outputs: [{ type: \"bytes4\" }],\n                    stateMutability: \"view\",\n                },\n            ],\n            functionName: \"isValidSignature\",\n            args: [digest, signature],\n        });\n        const publicClient = (0,viem__WEBPACK_IMPORTED_MODULE_7__.createPublicClient)({\n            chain: chain,\n            transport: (0,viem__WEBPACK_IMPORTED_MODULE_8__.http)(),\n        });\n        const did = credential.issuer.id;\n        console.info(\">>>>>>>>>>>> credential issuer did: \", did);\n        const agentId = (0,_agentic_trust_8004_ext_sdk__WEBPACK_IMPORTED_MODULE_4__.parseDid8004)(did).agentId;\n        console.info(\"agentId used to validate signature: \", agentId);\n        // Resolve smart account address from ERC-8004 Identity Registry using agentId\n        const registryAddress = \"0xD3Ef59f3Bbc1d766E3Ba463Be134B5eB29e907A0\";\n        const agentInfo = await (0,_IdentityRegistry_js__WEBPACK_IMPORTED_MODULE_3__.getRegistryAgent)(registryAddress, BigInt(String(agentId)));\n        const address = agentInfo.agentAddress;\n        // validate signature using contract EIP-1271\n        const { data: isValidSignature } = await publicClient.call({\n            account: address,\n            data: isValidSignatureData,\n            to: address,\n        });\n        console.info(\"isValidSignature: \", isValidSignature);\n        if (!isValidSignature?.startsWith('0x1626ba7e')) {\n            console.info(\"********** Verifiable Credential Signature is not valid according to EIP-1271\");\n            return false;\n        }\n        console.info(\"signature is valid according to EIP-1271\");\n        // verify the issuer did\n        const issuer = (0,_veramo_utils__WEBPACK_IMPORTED_MODULE_0__.extractIssuer)(credential);\n        if (!issuer || typeof issuer === 'undefined') {\n            throw new Error('invalid_argument: credential.issuer must not be empty');\n        }\n        const agent = await context.agent.resolveDid({ didUrl: issuer, options: args.resolutionOptions });\n        const didDocument = await (0,_veramo_utils__WEBPACK_IMPORTED_MODULE_0__.resolveDidOrThrow)(issuer, context, args.resolutionOptions);\n        if (didDocument.verificationMethod && agentId) {\n            for (const verificationMethod of didDocument.verificationMethod) {\n                const verAgentId = getVerMethodAgentId(verificationMethod);\n                console.info(\"XXXXXXXXXXXXXXXXXXXXXX  verAgentId: \", verAgentId, 'agentId: ', agentId);\n                if (verAgentId === agentId) {\n                    return true;\n                }\n            }\n        }\n        else {\n            throw new Error('resolver_error: issuer DIDDocument does not contain any verificationMethods');\n        }\n        return false;\n    }\n    async verifyPresentationEIP1271(args, context) {\n        // check that proof exists\n        const { presentation } = args;\n        if (!presentation.proof || !presentation.proof.proofValue)\n            throw new Error('invalid_argument: proof is undefined');\n        const { proof, ...signingInput } = presentation;\n        const { proofValue, eip712, ...verifyInputProof } = proof;\n        const verificationMessage = {\n            ...signingInput,\n            proof: verifyInputProof,\n        };\n        const compat = {\n            ...eip712,\n        };\n        compat.types = compat.types || compat.messageSchema;\n        if (!compat.primaryType || !compat.types || !compat.domain)\n            throw new Error('invalid_argument: proof is missing expected properties');\n        const filteredTypes = { ...compat.types };\n        delete filteredTypes.EIP712Domain;\n        const digest = ethers__WEBPACK_IMPORTED_MODULE_5__.TypedDataEncoder.hash(compat.domain, filteredTypes, verificationMessage);\n        const signature = proofValue;\n        const isValidSignatureData = (0,viem__WEBPACK_IMPORTED_MODULE_6__.encodeFunctionData)({\n            abi: [\n                {\n                    name: \"isValidSignature\",\n                    type: \"function\",\n                    inputs: [\n                        { name: \"_hash\", type: \"bytes32\" },\n                        { name: \"_signature\", type: \"bytes\" },\n                    ],\n                    outputs: [{ type: \"bytes4\" }],\n                    stateMutability: \"view\",\n                },\n            ],\n            functionName: \"isValidSignature\",\n            args: [digest, signature],\n        });\n        const publicClient = (0,viem__WEBPACK_IMPORTED_MODULE_7__.createPublicClient)({\n            chain: chain,\n            transport: (0,viem__WEBPACK_IMPORTED_MODULE_8__.http)(),\n        });\n        const agentId = (0,_agentic_trust_8004_ext_sdk__WEBPACK_IMPORTED_MODULE_4__.parseDid8004)(presentation.holder).agentId;\n        // Resolve smart account address from ERC-8004 Identity Registry using agentId\n        const registryAddress = \"0xD3Ef59f3Bbc1d766E3Ba463Be134B5eB29e907A0\";\n        const agentInfo = await (0,_IdentityRegistry_js__WEBPACK_IMPORTED_MODULE_3__.getRegistryAgent)(registryAddress, BigInt(String(agentId)));\n        const address = agentInfo.agentAddress;\n        // validate signature using contract EIP-1271\n        const { data: isValidSignature } = await publicClient.call({\n            account: address,\n            data: isValidSignatureData,\n            to: address,\n        });\n        if (!isValidSignature?.startsWith('0x1626ba7e')) {\n            console.info(\"*********** Verifiable Presentation Signature is not valid according to EIP-1271\");\n            console.info(\"isValidSignature: \", isValidSignature);\n            return false;\n        }\n        // verify the client did\n        const clientDid = (0,_veramo_utils__WEBPACK_IMPORTED_MODULE_0__.extractIssuer)(presentation);\n        if (!clientDid || typeof clientDid === 'undefined') {\n            throw new Error('invalid_argument: presentation.holder must not be empty');\n        }\n        console.info(\"gator client Agent Did: \", clientDid);\n        const clientDidDocument = await (0,_veramo_utils__WEBPACK_IMPORTED_MODULE_0__.resolveDidOrThrow)(clientDid, context, args.resolutionOptions);\n        if (clientDidDocument.verificationMethod && agentId) {\n            console.info(\"gator client didDocument.verificationMethod: \", clientDidDocument.verificationMethod);\n            for (const verificationMethod of clientDidDocument.verificationMethod) {\n                const verAgentId = getVerMethodAgentId(verificationMethod);\n                console.info(\"XXXXXXXXXXXXXXXXXXXXXX  verAgentId: \", verAgentId, 'agentId: ', agentId);\n                if (verAgentId === agentId) {\n                    return true;\n                }\n            }\n        }\n        else {\n            throw new Error('resolver_error: holder DIDDocument does not contain any verificationMethods');\n        }\n        return false;\n    }\n}\n//# sourceMappingURL=AgentCredentialIssuerEIP1271.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BhZ2VudGljLXRydXN0L3ZlcmFtby1hZ2VudC1leHRlbnNpb24vZGlzdC91dGlscy9BZ2VudENyZWRlbnRpYWxJc3N1ZXJFSVAxMjcxLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFFb0Y7QUFDekM7QUFDMEI7QUFDL0I7QUFDdEMsY0FBYyxnREFBTztBQUM4QztBQUNWO0FBQ0U7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxrRUFBbUIsaUNBQWlDLHVFQUE0QjtBQUNsSCwrQkFBK0Isa0VBQW1CO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCxnQkFBZ0I7QUFDL0Usd0JBQXdCLHlFQUFZO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGlGQUF1QjtBQUNoRCx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxrRUFBbUIsbUNBQW1DLHVFQUE0QjtBQUN0SCxpQ0FBaUMsa0VBQW1CO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSx3REFBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsdUJBQXVCLGtFQUFtQjtBQUMxQztBQUNBO0FBQ0EsNkRBQTZELGFBQWE7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix5RUFBWTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGlGQUF1QjtBQUNoRCx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGFBQWE7QUFDN0I7QUFDQTtBQUNBLGdCQUFnQix5QkFBeUI7QUFDekMsZ0JBQWdCLDBDQUEwQztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0EsdUJBQXVCLG9EQUFnQjtBQUN2QztBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsd0RBQWtCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsZ0NBQWdDO0FBQzFELDBCQUEwQixtQ0FBbUM7QUFDN0Q7QUFDQSxnQ0FBZ0MsZ0JBQWdCO0FBQ2hEO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCw2QkFBNkIsd0RBQWtCO0FBQy9DO0FBQ0EsdUJBQXVCLDBDQUFJO0FBQzNCLFNBQVM7QUFDVDtBQUNBO0FBQ0Esd0JBQXdCLHlFQUFZO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxzRUFBZ0I7QUFDaEQ7QUFDQTtBQUNBLGdCQUFnQix5QkFBeUI7QUFDekM7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDREQUFhO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxpREFBaUQ7QUFDeEcsa0NBQWtDLGdFQUFpQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixlQUFlO0FBQy9CO0FBQ0E7QUFDQSxnQkFBZ0IseUJBQXlCO0FBQ3pDLGdCQUFnQiwwQ0FBMEM7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQSx1QkFBdUIsb0RBQWdCO0FBQ3ZDO0FBQ0EscUNBQXFDLHdEQUFrQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGdDQUFnQztBQUMxRCwwQkFBMEIsbUNBQW1DO0FBQzdEO0FBQ0EsZ0NBQWdDLGdCQUFnQjtBQUNoRDtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsNkJBQTZCLHdEQUFrQjtBQUMvQztBQUNBLHVCQUF1QiwwQ0FBSTtBQUMzQixTQUFTO0FBQ1Qsd0JBQXdCLHlFQUFZO0FBQ3BDO0FBQ0E7QUFDQSxnQ0FBZ0Msc0VBQWdCO0FBQ2hEO0FBQ0E7QUFDQSxnQkFBZ0IseUJBQXlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsNERBQWE7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsZ0VBQWlCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL2JhcmIvYWEvQXNzb2NpYXRlZEFjY291bnRzL25vZGVfbW9kdWxlcy9AYWdlbnRpYy10cnVzdC92ZXJhbW8tYWdlbnQtZXh0ZW5zaW9uL2Rpc3QvdXRpbHMvQWdlbnRDcmVkZW50aWFsSXNzdWVyRUlQMTI3MS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBleHRyYWN0SXNzdWVyLCBpc0RlZmluZWQsIE1BTkRBVE9SWV9DUkVERU5USUFMX0NPTlRFWFQsIFxuLy9tYXBBZ2VudElkZW50aWZpZXJLZXlzVG9Eb2MsXG5wcm9jZXNzRW50cnlUb0FycmF5LCByZW1vdmVESURQYXJhbWV0ZXJzLCByZXNvbHZlRGlkT3JUaHJvdywgfSBmcm9tICdAdmVyYW1vL3V0aWxzJztcbmltcG9ydCB7IFR5cGVkRGF0YUVuY29kZXIsIH0gZnJvbSAnZXRoZXJzJztcbmltcG9ydCB7IGNyZWF0ZVB1YmxpY0NsaWVudCwgaHR0cCwgZW5jb2RlRnVuY3Rpb25EYXRhLCB9IGZyb20gXCJ2aWVtXCI7XG5pbXBvcnQgeyBzZXBvbGlhIH0gZnJvbSBcInZpZW0vY2hhaW5zXCI7XG5jb25zdCBjaGFpbiA9IHNlcG9saWE7XG5pbXBvcnQgeyBnZXRFdGhUeXBlc0Zyb21JbnB1dERvYyB9IGZyb20gJ2VpcC03MTItdHlwZXMtZ2VuZXJhdGlvbic7XG5pbXBvcnQgeyBnZXRSZWdpc3RyeUFnZW50IH0gZnJvbSAnLi9JZGVudGl0eVJlZ2lzdHJ5LmpzJztcbmltcG9ydCB7IHBhcnNlRGlkODAwNCB9IGZyb20gJ0BhZ2VudGljLXRydXN0LzgwMDQtZXh0LXNkayc7XG4vLyBFeHRyYWN0cyB0aGUgbnVtZXJpYyBhZ2VudElkIGZyb20gYSB2ZXJpZmljYXRpb25NZXRob2Qgb2JqZWN0LlxuLy8gQWNjZXB0cyBmaWVsZHMgbGlrZTpcbi8vIC0gYWdlbnRJZDogJ2VpcDE1NToxMTE1NTExMToxMydcbi8vIC0gY29udHJvbGxlcjogJ2RpZDo4MDA0OmVpcDE1NToxMTE1NTExMToxMydcbi8vIC0gaWQ6ICdkaWQ6ODAwNDplaXAxNTU6MTExNTUxMTE6MTMjYWdlbnRJZCdcbmZ1bmN0aW9uIGdldFZlck1ldGhvZEFnZW50SWQodmVyaWZpY2F0aW9uTWV0aG9kKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3Qgdm0gPSB2ZXJpZmljYXRpb25NZXRob2QgfHwge307XG4gICAgICAgIGlmICh0eXBlb2Ygdm0uYWdlbnRJZCA9PT0gJ3N0cmluZycgJiYgdm0uYWdlbnRJZC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBiYXNlID0gdm0uYWdlbnRJZC5zcGxpdCgnIycpWzBdO1xuICAgICAgICAgICAgY29uc3QgcGFydHMgPSBiYXNlLnNwbGl0KCc6Jyk7XG4gICAgICAgICAgICByZXR1cm4gcGFydHNbcGFydHMubGVuZ3RoIC0gMV07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZnJvbSA9ICh0eXBlb2Ygdm0uY29udHJvbGxlciA9PT0gJ3N0cmluZycgJiYgdm0uY29udHJvbGxlcikgfHxcbiAgICAgICAgICAgICh0eXBlb2Ygdm0uaWQgPT09ICdzdHJpbmcnICYmIHZtLmlkKSB8fFxuICAgICAgICAgICAgdW5kZWZpbmVkO1xuICAgICAgICBpZiAoZnJvbSkge1xuICAgICAgICAgICAgY29uc3QgYmFzZSA9IGZyb20uc3BsaXQoJyMnKVswXTtcbiAgICAgICAgICAgIGlmICghYmFzZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwYXJ0cyA9IGJhc2Uuc3BsaXQoJzonKTtcbiAgICAgICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPj0gNSAmJiBwYXJ0c1swXSA9PT0gJ2RpZCcgJiYgcGFydHNbMV0gPT09ICc4MDA0Jykge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJ0c1twYXJ0cy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCB7IH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuZXhwb3J0IGNsYXNzIEFnZW50Q3JlZGVudGlhbElzc3VlckVJUDEyNzEge1xuICAgIG1ldGhvZHM7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMubWV0aG9kcyA9IHtcbiAgICAgICAgICAgIGNyZWF0ZVZlcmlmaWFibGVDcmVkZW50aWFsRUlQMTI3MTogdGhpcy5jcmVhdGVWZXJpZmlhYmxlQ3JlZGVudGlhbEVJUDEyNzEuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIGNyZWF0ZVZlcmlmaWFibGVQcmVzZW50YXRpb25FSVAxMjcxOiB0aGlzLmNyZWF0ZVZlcmlmaWFibGVQcmVzZW50YXRpb25FSVAxMjcxLmJpbmQodGhpcyksXG4gICAgICAgICAgICB2ZXJpZnlDcmVkZW50aWFsRUlQMTI3MTogdGhpcy52ZXJpZnlDcmVkZW50aWFsRUlQMTI3MS5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgdmVyaWZ5UHJlc2VudGF0aW9uRUlQMTI3MTogdGhpcy52ZXJpZnlQcmVzZW50YXRpb25FSVAxMjcxLmJpbmQodGhpcyksXG4gICAgICAgIH07XG4gICAgfVxuICAgIGFzeW5jIGNyZWF0ZVZlcmlmaWFibGVDcmVkZW50aWFsRUlQMTI3MShhcmdzLCBjb250ZXh0KSB7XG4gICAgICAgIGNvbnN0IGNyZWRlbnRpYWxDb250ZXh0ID0gcHJvY2Vzc0VudHJ5VG9BcnJheShhcmdzPy5jcmVkZW50aWFsPy5bJ0Bjb250ZXh0J10sIE1BTkRBVE9SWV9DUkVERU5USUFMX0NPTlRFWFQpO1xuICAgICAgICBjb25zdCBjcmVkZW50aWFsVHlwZSA9IHByb2Nlc3NFbnRyeVRvQXJyYXkoYXJncz8uY3JlZGVudGlhbD8udHlwZSwgJ1ZlcmlmaWFibGVDcmVkZW50aWFsJyk7XG4gICAgICAgIGxldCBpc3N1YW5jZURhdGUgPSBhcmdzPy5jcmVkZW50aWFsPy5pc3N1YW5jZURhdGUgfHwgbmV3IERhdGUoKS50b0lTT1N0cmluZygpO1xuICAgICAgICBpZiAoaXNzdWFuY2VEYXRlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICAgICAgaXNzdWFuY2VEYXRlID0gaXNzdWFuY2VEYXRlLnRvSVNPU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaXNzdWVyID0gYXJncy5jcmVkZW50aWFsLmlzc3VlcjtcbiAgICAgICAgaWYgKCFpc3N1ZXIgfHwgdHlwZW9mIGlzc3VlciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSXNzdWVyIG11c3QgYmUgYW4gb2JqZWN0IHdpdGggYW4gXCJpZFwiIGFuZCBcImRpZFwiIHNpZ25lcicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnNvbGUuaW5mbyhcIkNyZWF0aW5nIFZlcmlmaWFibGUgQ3JlZGVudGlhbCBFSVAxMjcxIHdpdGggaXNzdWVyOlwiLCBpc3N1ZXIpO1xuICAgICAgICBjb25zdCBpZGVudGlmaWVyID0gYXdhaXQgY29udGV4dC5hZ2VudC5kaWRNYW5hZ2VyR2V0KHsgZGlkOiBpc3N1ZXIuaWQgfSk7XG4gICAgICAgIGNvbnN0IGRpZDgwMDQgPSBwYXJzZURpZDgwMDQoaWRlbnRpZmllci5kaWQpO1xuICAgICAgICBsZXQgY2hhaW5JZDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNoYWluSWQgPSBkaWQ4MDA0LmNoYWluSWQ7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNoYWluSWQgPSAxMTE1NTExMTtcbiAgICAgICAgfVxuICAgICAgICAvLyBwb2ludCB0byBhIERJRCBjb250cm9sbGVyIHRoYXQgc3VwcG9ydHMgc21hcnQgY29udHJhY3QtYmFzZWQgc2lnbmF0dXJlIHZlcmlmaWNhdGlvblxuICAgICAgICBjb25zdCBjcmVkZW50aWFsID0ge1xuICAgICAgICAgICAgLi4uYXJncz8uY3JlZGVudGlhbCxcbiAgICAgICAgICAgICdAY29udGV4dCc6IGNyZWRlbnRpYWxDb250ZXh0LFxuICAgICAgICAgICAgdHlwZTogY3JlZGVudGlhbFR5cGUsXG4gICAgICAgICAgICBpc3N1YW5jZURhdGUsXG4gICAgICAgICAgICBwcm9vZjoge1xuICAgICAgICAgICAgICAgIHZlcmlmaWNhdGlvbk1ldGhvZDogaWRlbnRpZmllci5kaWQgKyBcIiNldGhlcmV1bUFkZHJlc3NcIixcbiAgICAgICAgICAgICAgICBjcmVhdGVkOiBpc3N1YW5jZURhdGUsXG4gICAgICAgICAgICAgICAgcHJvb2ZQdXJwb3NlOiAnYXNzZXJ0aW9uTWV0aG9kJyxcbiAgICAgICAgICAgICAgICB0eXBlOiAnRXRoZXJldW1FaXA3MTJTaWduYXR1cmUyMDIxJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVkZW50aWFsO1xuICAgICAgICBjb25zdCBkb21haW4gPSB7XG4gICAgICAgICAgICBjaGFpbklkLFxuICAgICAgICAgICAgbmFtZTogJ1ZlcmlmaWFibGVDcmVkZW50aWFsJyxcbiAgICAgICAgICAgIHZlcnNpb246ICcxJyxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcHJpbWFyeVR5cGUgPSAnVmVyaWZpYWJsZUNyZWRlbnRpYWwnO1xuICAgICAgICBjb25zdCBhbGxUeXBlcyA9IGdldEV0aFR5cGVzRnJvbUlucHV0RG9jKGNyZWRlbnRpYWwsIHByaW1hcnlUeXBlKTtcbiAgICAgICAgY29uc3QgdHlwZXMgPSB7IC4uLmFsbFR5cGVzIH07XG4gICAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IGF3YWl0IGFyZ3M/LnNpZ25lcj8uc2lnblR5cGVkRGF0YShkb21haW4sIHR5cGVzLCBtZXNzYWdlKTtcbiAgICAgICAgY3JlZGVudGlhbFsncHJvb2YnXVsncHJvb2ZWYWx1ZSddID0gc2lnbmF0dXJlO1xuICAgICAgICBjcmVkZW50aWFsWydwcm9vZiddWydlaXA3MTInXSA9IHtcbiAgICAgICAgICAgIGRvbWFpbixcbiAgICAgICAgICAgIHR5cGVzOiBhbGxUeXBlcyxcbiAgICAgICAgICAgIHByaW1hcnlUeXBlLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gY3JlZGVudGlhbDtcbiAgICB9XG4gICAgYXN5bmMgY3JlYXRlVmVyaWZpYWJsZVByZXNlbnRhdGlvbkVJUDEyNzEoYXJncywgY29udGV4dCkge1xuICAgICAgICBjb25zb2xlLmluZm8oXCJDcmVhdGluZyBWZXJpZmlhYmxlIFByZXNlbnRhdGlvbiBFSVAxMjcxIHdpdGggYXJnczpcIiwgYXJncyk7XG4gICAgICAgIGNvbnN0IHByZXNlbnRhdGlvbkNvbnRleHQgPSBwcm9jZXNzRW50cnlUb0FycmF5KGFyZ3M/LnByZXNlbnRhdGlvbj8uWydAY29udGV4dCddLCBNQU5EQVRPUllfQ1JFREVOVElBTF9DT05URVhUKTtcbiAgICAgICAgY29uc3QgcHJlc2VudGF0aW9uVHlwZSA9IHByb2Nlc3NFbnRyeVRvQXJyYXkoYXJncz8ucHJlc2VudGF0aW9uPy50eXBlLCAnVmVyaWZpYWJsZVByZXNlbnRhdGlvbicpO1xuICAgICAgICBsZXQgaXNzdWFuY2VEYXRlID0gYXJncz8ucHJlc2VudGF0aW9uPy5pc3N1YW5jZURhdGUgfHwgbmV3IERhdGUoKS50b0lTT1N0cmluZygpO1xuICAgICAgICBpZiAoaXNzdWFuY2VEYXRlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICAgICAgaXNzdWFuY2VEYXRlID0gaXNzdWFuY2VEYXRlLnRvSVNPU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJlc2VudGF0aW9uID0ge1xuICAgICAgICAgICAgLi4uYXJncz8ucHJlc2VudGF0aW9uLFxuICAgICAgICAgICAgJ0Bjb250ZXh0JzogcHJlc2VudGF0aW9uQ29udGV4dCxcbiAgICAgICAgICAgIHR5cGU6IHByZXNlbnRhdGlvblR5cGUsXG4gICAgICAgICAgICBpc3N1YW5jZURhdGUsXG4gICAgICAgIH07XG4gICAgICAgIGlmICghaXNEZWZpbmVkKGFyZ3MucHJlc2VudGF0aW9uLmhvbGRlcikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZF9hcmd1bWVudDogcHJlc2VudGF0aW9uLmhvbGRlciBtdXN0IG5vdCBiZSBlbXB0eScpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhcmdzLnByZXNlbnRhdGlvbi52ZXJpZmlhYmxlQ3JlZGVudGlhbCkge1xuICAgICAgICAgICAgcHJlc2VudGF0aW9uLnZlcmlmaWFibGVDcmVkZW50aWFsID0gYXJncy5wcmVzZW50YXRpb24udmVyaWZpYWJsZUNyZWRlbnRpYWwubWFwKChjcmVkKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gbWFwIEpXVCBjcmVkZW50aWFscyB0byB0aGVpciBjYW5vbmljYWwgZm9ybVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY3JlZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNyZWQucHJvb2Yuand0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVkLnByb29mLmp3dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShjcmVkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBob2xkZXIgPSByZW1vdmVESURQYXJhbWV0ZXJzKHByZXNlbnRhdGlvbi5ob2xkZXIpO1xuICAgICAgICBsZXQgaWRlbnRpZmllcjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlkZW50aWZpZXIgPSBhd2FpdCBjb250ZXh0LmFnZW50LmRpZE1hbmFnZXJHZXQoeyBkaWQ6IGhvbGRlciB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkX2FyZ3VtZW50OiBwcmVzZW50YXRpb24uaG9sZGVyIG11c3QgYmUgYSBESUQgbWFuYWdlZCBieSB0aGlzIGFnZW50Jyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc29sZS5pbmZvKFwiaWRlbnRpZmllcjogXCIsIGlkZW50aWZpZXIpO1xuICAgICAgICBjb25zdCBkaWQ4MDA0ID0gcGFyc2VEaWQ4MDA0KGlkZW50aWZpZXIuZGlkKTtcbiAgICAgICAgbGV0IGNoYWluSWQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjaGFpbklkID0gZGlkODAwNC5jaGFpbklkO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjaGFpbklkID0gMTExNTUxMTE7XG4gICAgICAgIH1cbiAgICAgICAgcHJlc2VudGF0aW9uWydwcm9vZiddID0ge1xuICAgICAgICAgICAgdmVyaWZpY2F0aW9uTWV0aG9kOiBkaWQ4MDA0LmFnZW50SWQgKyBcIiNhZ2VudElkXCIsXG4gICAgICAgICAgICBjcmVhdGVkOiBpc3N1YW5jZURhdGUsXG4gICAgICAgICAgICBwcm9vZlB1cnBvc2U6ICdhc3NlcnRpb25NZXRob2QnLFxuICAgICAgICAgICAgdHlwZTogJ0V0aGVyZXVtRWlwNzEyU2lnbmF0dXJlMjAyMScsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBwcmVzZW50YXRpb247XG4gICAgICAgIGNvbnN0IGRvbWFpbiA9IHtcbiAgICAgICAgICAgIGNoYWluSWQsXG4gICAgICAgICAgICBuYW1lOiAnVmVyaWZpYWJsZVByZXNlbnRhdGlvbicsXG4gICAgICAgICAgICB2ZXJzaW9uOiAnMScsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHByaW1hcnlUeXBlID0gJ1ZlcmlmaWFibGVQcmVzZW50YXRpb24nO1xuICAgICAgICBjb25zdCBhbGxUeXBlcyA9IGdldEV0aFR5cGVzRnJvbUlucHV0RG9jKHByZXNlbnRhdGlvbiwgcHJpbWFyeVR5cGUpO1xuICAgICAgICBjb25zdCB0eXBlcyA9IHsgLi4uYWxsVHlwZXMgfTtcbiAgICAgICAgY29uc3Qgc2lnbmF0dXJlID0gYXdhaXQgYXJncz8uc2lnbmVyPy5zaWduVHlwZWREYXRhKGRvbWFpbiwgdHlwZXMsIG1lc3NhZ2UpO1xuICAgICAgICBwcmVzZW50YXRpb24ucHJvb2YucHJvb2ZWYWx1ZSA9IHNpZ25hdHVyZTtcbiAgICAgICAgcHJlc2VudGF0aW9uLnByb29mLmVpcDcxMiA9IHtcbiAgICAgICAgICAgIGRvbWFpbixcbiAgICAgICAgICAgIHR5cGVzOiBhbGxUeXBlcyxcbiAgICAgICAgICAgIHByaW1hcnlUeXBlLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcHJlc2VudGF0aW9uO1xuICAgIH1cbiAgICBhc3luYyB2ZXJpZnlDcmVkZW50aWFsRUlQMTI3MShhcmdzLCBjb250ZXh0KSB7XG4gICAgICAgIGNvbnNvbGUuaW5mbyhcInZlcmlmeUNyZWRlbnRpYWxFSVAxMjcxIGNhbGxlZCB3aXRoIGFyZ3M6IFwiLCBhcmdzKTtcbiAgICAgICAgLy8gY2hlY2sgdGhhdCBwcm9vZiBleGlzdHNcbiAgICAgICAgY29uc3QgeyBjcmVkZW50aWFsIH0gPSBhcmdzO1xuICAgICAgICBpZiAoIWNyZWRlbnRpYWwucHJvb2YgfHwgIWNyZWRlbnRpYWwucHJvb2YucHJvb2ZWYWx1ZSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZF9hcmd1bWVudDogcHJvb2YgaXMgdW5kZWZpbmVkJyk7XG4gICAgICAgIGNvbnN0IHsgcHJvb2YsIC4uLnNpZ25pbmdJbnB1dCB9ID0gY3JlZGVudGlhbDtcbiAgICAgICAgY29uc3QgeyBwcm9vZlZhbHVlLCBlaXA3MTIsIC4uLnZlcmlmeUlucHV0UHJvb2YgfSA9IHByb29mO1xuICAgICAgICBjb25zdCB2ZXJpZmljYXRpb25NZXNzYWdlID0ge1xuICAgICAgICAgICAgLi4uc2lnbmluZ0lucHV0LFxuICAgICAgICAgICAgcHJvb2Y6IHZlcmlmeUlucHV0UHJvb2YsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGNvbXBhdCA9IHtcbiAgICAgICAgICAgIC4uLmVpcDcxMixcbiAgICAgICAgfTtcbiAgICAgICAgY29tcGF0LnR5cGVzID0gY29tcGF0LnR5cGVzIHx8IGNvbXBhdC5tZXNzYWdlU2NoZW1hO1xuICAgICAgICBpZiAoIWNvbXBhdC5wcmltYXJ5VHlwZSB8fCAhY29tcGF0LnR5cGVzIHx8ICFjb21wYXQuZG9tYWluKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWRfYXJndW1lbnQ6IHByb29mIGlzIG1pc3NpbmcgZXhwZWN0ZWQgcHJvcGVydGllcycpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZpbHRlcmVkVHlwZXMgPSB7IC4uLmNvbXBhdC50eXBlcyB9O1xuICAgICAgICBkZWxldGUgZmlsdGVyZWRUeXBlcy5FSVA3MTJEb21haW47XG4gICAgICAgIGNvbnN0IGRpZ2VzdCA9IFR5cGVkRGF0YUVuY29kZXIuaGFzaChjb21wYXQuZG9tYWluLCBmaWx0ZXJlZFR5cGVzLCB2ZXJpZmljYXRpb25NZXNzYWdlKTtcbiAgICAgICAgY29uc3Qgc2lnbmF0dXJlID0gcHJvb2ZWYWx1ZTtcbiAgICAgICAgY29uc29sZS5pbmZvKFwiLi4uLi4uLi4uLi4uLi4uIHNpZ25hdHVyZTogXCIsIHNpZ25hdHVyZSk7XG4gICAgICAgIGNvbnNvbGUuaW5mbyhcIi4uLi4uLi4uLi4uLi4uLiBkaWdlc3Q6IFwiLCBkaWdlc3QpO1xuICAgICAgICBjb25zdCBpc1ZhbGlkU2lnbmF0dXJlRGF0YSA9IGVuY29kZUZ1bmN0aW9uRGF0YSh7XG4gICAgICAgICAgICBhYmk6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiaXNWYWxpZFNpZ25hdHVyZVwiLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgICAgICAgICAgICAgICAgIGlucHV0czogW1xuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiBcIl9oYXNoXCIsIHR5cGU6IFwiYnl0ZXMzMlwiIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWU6IFwiX3NpZ25hdHVyZVwiLCB0eXBlOiBcImJ5dGVzXCIgfSxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0czogW3sgdHlwZTogXCJieXRlczRcIiB9XSxcbiAgICAgICAgICAgICAgICAgICAgc3RhdGVNdXRhYmlsaXR5OiBcInZpZXdcIixcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIGZ1bmN0aW9uTmFtZTogXCJpc1ZhbGlkU2lnbmF0dXJlXCIsXG4gICAgICAgICAgICBhcmdzOiBbZGlnZXN0LCBzaWduYXR1cmVdLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcHVibGljQ2xpZW50ID0gY3JlYXRlUHVibGljQ2xpZW50KHtcbiAgICAgICAgICAgIGNoYWluOiBjaGFpbixcbiAgICAgICAgICAgIHRyYW5zcG9ydDogaHR0cCgpLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgZGlkID0gY3JlZGVudGlhbC5pc3N1ZXIuaWQ7XG4gICAgICAgIGNvbnNvbGUuaW5mbyhcIj4+Pj4+Pj4+Pj4+PiBjcmVkZW50aWFsIGlzc3VlciBkaWQ6IFwiLCBkaWQpO1xuICAgICAgICBjb25zdCBhZ2VudElkID0gcGFyc2VEaWQ4MDA0KGRpZCkuYWdlbnRJZDtcbiAgICAgICAgY29uc29sZS5pbmZvKFwiYWdlbnRJZCB1c2VkIHRvIHZhbGlkYXRlIHNpZ25hdHVyZTogXCIsIGFnZW50SWQpO1xuICAgICAgICAvLyBSZXNvbHZlIHNtYXJ0IGFjY291bnQgYWRkcmVzcyBmcm9tIEVSQy04MDA0IElkZW50aXR5IFJlZ2lzdHJ5IHVzaW5nIGFnZW50SWRcbiAgICAgICAgY29uc3QgcmVnaXN0cnlBZGRyZXNzID0gXCIweEQzRWY1OWYzQmJjMWQ3NjZFM0JhNDYzQmUxMzRCNWVCMjllOTA3QTBcIjtcbiAgICAgICAgY29uc3QgYWdlbnRJbmZvID0gYXdhaXQgZ2V0UmVnaXN0cnlBZ2VudChyZWdpc3RyeUFkZHJlc3MsIEJpZ0ludChTdHJpbmcoYWdlbnRJZCkpKTtcbiAgICAgICAgY29uc3QgYWRkcmVzcyA9IGFnZW50SW5mby5hZ2VudEFkZHJlc3M7XG4gICAgICAgIC8vIHZhbGlkYXRlIHNpZ25hdHVyZSB1c2luZyBjb250cmFjdCBFSVAtMTI3MVxuICAgICAgICBjb25zdCB7IGRhdGE6IGlzVmFsaWRTaWduYXR1cmUgfSA9IGF3YWl0IHB1YmxpY0NsaWVudC5jYWxsKHtcbiAgICAgICAgICAgIGFjY291bnQ6IGFkZHJlc3MsXG4gICAgICAgICAgICBkYXRhOiBpc1ZhbGlkU2lnbmF0dXJlRGF0YSxcbiAgICAgICAgICAgIHRvOiBhZGRyZXNzLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc29sZS5pbmZvKFwiaXNWYWxpZFNpZ25hdHVyZTogXCIsIGlzVmFsaWRTaWduYXR1cmUpO1xuICAgICAgICBpZiAoIWlzVmFsaWRTaWduYXR1cmU/LnN0YXJ0c1dpdGgoJzB4MTYyNmJhN2UnKSkge1xuICAgICAgICAgICAgY29uc29sZS5pbmZvKFwiKioqKioqKioqKiBWZXJpZmlhYmxlIENyZWRlbnRpYWwgU2lnbmF0dXJlIGlzIG5vdCB2YWxpZCBhY2NvcmRpbmcgdG8gRUlQLTEyNzFcIik7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc29sZS5pbmZvKFwic2lnbmF0dXJlIGlzIHZhbGlkIGFjY29yZGluZyB0byBFSVAtMTI3MVwiKTtcbiAgICAgICAgLy8gdmVyaWZ5IHRoZSBpc3N1ZXIgZGlkXG4gICAgICAgIGNvbnN0IGlzc3VlciA9IGV4dHJhY3RJc3N1ZXIoY3JlZGVudGlhbCk7XG4gICAgICAgIGlmICghaXNzdWVyIHx8IHR5cGVvZiBpc3N1ZXIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWRfYXJndW1lbnQ6IGNyZWRlbnRpYWwuaXNzdWVyIG11c3Qgbm90IGJlIGVtcHR5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYWdlbnQgPSBhd2FpdCBjb250ZXh0LmFnZW50LnJlc29sdmVEaWQoeyBkaWRVcmw6IGlzc3Vlciwgb3B0aW9uczogYXJncy5yZXNvbHV0aW9uT3B0aW9ucyB9KTtcbiAgICAgICAgY29uc3QgZGlkRG9jdW1lbnQgPSBhd2FpdCByZXNvbHZlRGlkT3JUaHJvdyhpc3N1ZXIsIGNvbnRleHQsIGFyZ3MucmVzb2x1dGlvbk9wdGlvbnMpO1xuICAgICAgICBpZiAoZGlkRG9jdW1lbnQudmVyaWZpY2F0aW9uTWV0aG9kICYmIGFnZW50SWQpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgdmVyaWZpY2F0aW9uTWV0aG9kIG9mIGRpZERvY3VtZW50LnZlcmlmaWNhdGlvbk1ldGhvZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZlckFnZW50SWQgPSBnZXRWZXJNZXRob2RBZ2VudElkKHZlcmlmaWNhdGlvbk1ldGhvZCk7XG4gICAgICAgICAgICAgICAgY29uc29sZS5pbmZvKFwiWFhYWFhYWFhYWFhYWFhYWFhYWFhYWCAgdmVyQWdlbnRJZDogXCIsIHZlckFnZW50SWQsICdhZ2VudElkOiAnLCBhZ2VudElkKTtcbiAgICAgICAgICAgICAgICBpZiAodmVyQWdlbnRJZCA9PT0gYWdlbnRJZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Jlc29sdmVyX2Vycm9yOiBpc3N1ZXIgRElERG9jdW1lbnQgZG9lcyBub3QgY29udGFpbiBhbnkgdmVyaWZpY2F0aW9uTWV0aG9kcycpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgYXN5bmMgdmVyaWZ5UHJlc2VudGF0aW9uRUlQMTI3MShhcmdzLCBjb250ZXh0KSB7XG4gICAgICAgIC8vIGNoZWNrIHRoYXQgcHJvb2YgZXhpc3RzXG4gICAgICAgIGNvbnN0IHsgcHJlc2VudGF0aW9uIH0gPSBhcmdzO1xuICAgICAgICBpZiAoIXByZXNlbnRhdGlvbi5wcm9vZiB8fCAhcHJlc2VudGF0aW9uLnByb29mLnByb29mVmFsdWUpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWRfYXJndW1lbnQ6IHByb29mIGlzIHVuZGVmaW5lZCcpO1xuICAgICAgICBjb25zdCB7IHByb29mLCAuLi5zaWduaW5nSW5wdXQgfSA9IHByZXNlbnRhdGlvbjtcbiAgICAgICAgY29uc3QgeyBwcm9vZlZhbHVlLCBlaXA3MTIsIC4uLnZlcmlmeUlucHV0UHJvb2YgfSA9IHByb29mO1xuICAgICAgICBjb25zdCB2ZXJpZmljYXRpb25NZXNzYWdlID0ge1xuICAgICAgICAgICAgLi4uc2lnbmluZ0lucHV0LFxuICAgICAgICAgICAgcHJvb2Y6IHZlcmlmeUlucHV0UHJvb2YsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGNvbXBhdCA9IHtcbiAgICAgICAgICAgIC4uLmVpcDcxMixcbiAgICAgICAgfTtcbiAgICAgICAgY29tcGF0LnR5cGVzID0gY29tcGF0LnR5cGVzIHx8IGNvbXBhdC5tZXNzYWdlU2NoZW1hO1xuICAgICAgICBpZiAoIWNvbXBhdC5wcmltYXJ5VHlwZSB8fCAhY29tcGF0LnR5cGVzIHx8ICFjb21wYXQuZG9tYWluKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkX2FyZ3VtZW50OiBwcm9vZiBpcyBtaXNzaW5nIGV4cGVjdGVkIHByb3BlcnRpZXMnKTtcbiAgICAgICAgY29uc3QgZmlsdGVyZWRUeXBlcyA9IHsgLi4uY29tcGF0LnR5cGVzIH07XG4gICAgICAgIGRlbGV0ZSBmaWx0ZXJlZFR5cGVzLkVJUDcxMkRvbWFpbjtcbiAgICAgICAgY29uc3QgZGlnZXN0ID0gVHlwZWREYXRhRW5jb2Rlci5oYXNoKGNvbXBhdC5kb21haW4sIGZpbHRlcmVkVHlwZXMsIHZlcmlmaWNhdGlvbk1lc3NhZ2UpO1xuICAgICAgICBjb25zdCBzaWduYXR1cmUgPSBwcm9vZlZhbHVlO1xuICAgICAgICBjb25zdCBpc1ZhbGlkU2lnbmF0dXJlRGF0YSA9IGVuY29kZUZ1bmN0aW9uRGF0YSh7XG4gICAgICAgICAgICBhYmk6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiaXNWYWxpZFNpZ25hdHVyZVwiLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgICAgICAgICAgICAgICAgIGlucHV0czogW1xuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiBcIl9oYXNoXCIsIHR5cGU6IFwiYnl0ZXMzMlwiIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWU6IFwiX3NpZ25hdHVyZVwiLCB0eXBlOiBcImJ5dGVzXCIgfSxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0czogW3sgdHlwZTogXCJieXRlczRcIiB9XSxcbiAgICAgICAgICAgICAgICAgICAgc3RhdGVNdXRhYmlsaXR5OiBcInZpZXdcIixcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIGZ1bmN0aW9uTmFtZTogXCJpc1ZhbGlkU2lnbmF0dXJlXCIsXG4gICAgICAgICAgICBhcmdzOiBbZGlnZXN0LCBzaWduYXR1cmVdLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcHVibGljQ2xpZW50ID0gY3JlYXRlUHVibGljQ2xpZW50KHtcbiAgICAgICAgICAgIGNoYWluOiBjaGFpbixcbiAgICAgICAgICAgIHRyYW5zcG9ydDogaHR0cCgpLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgYWdlbnRJZCA9IHBhcnNlRGlkODAwNChwcmVzZW50YXRpb24uaG9sZGVyKS5hZ2VudElkO1xuICAgICAgICAvLyBSZXNvbHZlIHNtYXJ0IGFjY291bnQgYWRkcmVzcyBmcm9tIEVSQy04MDA0IElkZW50aXR5IFJlZ2lzdHJ5IHVzaW5nIGFnZW50SWRcbiAgICAgICAgY29uc3QgcmVnaXN0cnlBZGRyZXNzID0gXCIweEQzRWY1OWYzQmJjMWQ3NjZFM0JhNDYzQmUxMzRCNWVCMjllOTA3QTBcIjtcbiAgICAgICAgY29uc3QgYWdlbnRJbmZvID0gYXdhaXQgZ2V0UmVnaXN0cnlBZ2VudChyZWdpc3RyeUFkZHJlc3MsIEJpZ0ludChTdHJpbmcoYWdlbnRJZCkpKTtcbiAgICAgICAgY29uc3QgYWRkcmVzcyA9IGFnZW50SW5mby5hZ2VudEFkZHJlc3M7XG4gICAgICAgIC8vIHZhbGlkYXRlIHNpZ25hdHVyZSB1c2luZyBjb250cmFjdCBFSVAtMTI3MVxuICAgICAgICBjb25zdCB7IGRhdGE6IGlzVmFsaWRTaWduYXR1cmUgfSA9IGF3YWl0IHB1YmxpY0NsaWVudC5jYWxsKHtcbiAgICAgICAgICAgIGFjY291bnQ6IGFkZHJlc3MsXG4gICAgICAgICAgICBkYXRhOiBpc1ZhbGlkU2lnbmF0dXJlRGF0YSxcbiAgICAgICAgICAgIHRvOiBhZGRyZXNzLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFpc1ZhbGlkU2lnbmF0dXJlPy5zdGFydHNXaXRoKCcweDE2MjZiYTdlJykpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhcIioqKioqKioqKioqIFZlcmlmaWFibGUgUHJlc2VudGF0aW9uIFNpZ25hdHVyZSBpcyBub3QgdmFsaWQgYWNjb3JkaW5nIHRvIEVJUC0xMjcxXCIpO1xuICAgICAgICAgICAgY29uc29sZS5pbmZvKFwiaXNWYWxpZFNpZ25hdHVyZTogXCIsIGlzVmFsaWRTaWduYXR1cmUpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIHZlcmlmeSB0aGUgY2xpZW50IGRpZFxuICAgICAgICBjb25zdCBjbGllbnREaWQgPSBleHRyYWN0SXNzdWVyKHByZXNlbnRhdGlvbik7XG4gICAgICAgIGlmICghY2xpZW50RGlkIHx8IHR5cGVvZiBjbGllbnREaWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWRfYXJndW1lbnQ6IHByZXNlbnRhdGlvbi5ob2xkZXIgbXVzdCBub3QgYmUgZW1wdHknKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zb2xlLmluZm8oXCJnYXRvciBjbGllbnQgQWdlbnQgRGlkOiBcIiwgY2xpZW50RGlkKTtcbiAgICAgICAgY29uc3QgY2xpZW50RGlkRG9jdW1lbnQgPSBhd2FpdCByZXNvbHZlRGlkT3JUaHJvdyhjbGllbnREaWQsIGNvbnRleHQsIGFyZ3MucmVzb2x1dGlvbk9wdGlvbnMpO1xuICAgICAgICBpZiAoY2xpZW50RGlkRG9jdW1lbnQudmVyaWZpY2F0aW9uTWV0aG9kICYmIGFnZW50SWQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhcImdhdG9yIGNsaWVudCBkaWREb2N1bWVudC52ZXJpZmljYXRpb25NZXRob2Q6IFwiLCBjbGllbnREaWREb2N1bWVudC52ZXJpZmljYXRpb25NZXRob2QpO1xuICAgICAgICAgICAgZm9yIChjb25zdCB2ZXJpZmljYXRpb25NZXRob2Qgb2YgY2xpZW50RGlkRG9jdW1lbnQudmVyaWZpY2F0aW9uTWV0aG9kKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmVyQWdlbnRJZCA9IGdldFZlck1ldGhvZEFnZW50SWQodmVyaWZpY2F0aW9uTWV0aG9kKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmluZm8oXCJYWFhYWFhYWFhYWFhYWFhYWFhYWFhYICB2ZXJBZ2VudElkOiBcIiwgdmVyQWdlbnRJZCwgJ2FnZW50SWQ6ICcsIGFnZW50SWQpO1xuICAgICAgICAgICAgICAgIGlmICh2ZXJBZ2VudElkID09PSBhZ2VudElkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncmVzb2x2ZXJfZXJyb3I6IGhvbGRlciBESUREb2N1bWVudCBkb2VzIG5vdCBjb250YWluIGFueSB2ZXJpZmljYXRpb25NZXRob2RzJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFnZW50Q3JlZGVudGlhbElzc3VlckVJUDEyNzEuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@agentic-trust/veramo-agent-extension/dist/utils/AgentCredentialIssuerEIP1271.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@agentic-trust/veramo-agent-extension/dist/utils/AgentDidProvider.js":
/*!***********************************************************************************************!*\
  !*** ../../node_modules/@agentic-trust/veramo-agent-extension/dist/utils/AgentDidProvider.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AgentDidProvider: () => (/* binding */ AgentDidProvider)\n/* harmony export */ });\n/* harmony import */ var _veramo_did_manager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @veramo/did-manager */ \"(rsc)/../../node_modules/@veramo/did-manager/build/index.js\");\n\nclass AgentDidProvider extends _veramo_did_manager__WEBPACK_IMPORTED_MODULE_0__.AbstractIdentifierProvider {\n    async addKey(args, context) {\n        // In a real implementation, you would add the key to the identifier's key list and persist it.\n        // Here, we simulate this by returning a success response.\n        return { success: true, key: args.key };\n    }\n    defaultKms;\n    chainId;\n    agentId;\n    providerName;\n    constructor(options) {\n        super();\n        this.defaultKms = options.defaultKms;\n        this.chainId = options.chainId;\n        this.agentId = options.agentId;\n        this.providerName = `agent:${this.agentId}`;\n    }\n    // Returns the DID method name\n    getSupportedMethods() {\n        return [`agent:${this.agentId}`];\n    }\n    getAccount() {\n        return this.agentId;\n    }\n    async createIdentifier({ kms, alias, options }, context) {\n        //console.info(`Resolving DID 111: ${did}`)\n        // provider and did are a one to one relationship\n        const agentId = this.agentId;\n        const chainId = this.chainId;\n        const did = `did:8004:eip155:${chainId}:${agentId}`;\n        const identifier = {\n            did,\n            alias,\n            provider: this.providerName,\n            controllerKeyId: agentId, // assumes no local private key; signing done externally or on-chain\n            keys: [],\n            services: [],\n        };\n        console.info(\"&&&&&&&&&&&& Creating identifier:\", identifier);\n        return identifier;\n    }\n    async resolveDid(did) {\n        console.info(`Resolving DID 222: ${did}`);\n        const parts = did.split(':').slice(1);\n        const [method, networkId, agentId] = parts;\n        if (method !== 'contract') {\n            throw new Error(`Unsupported DID method: ${method}`);\n        }\n        if (!agentId) {\n            throw new Error(`Missing agentId in DID: ${did}`);\n        }\n        const controllerAddress = agentId.toLowerCase();\n        return {\n            '@context': ['https://www.w3.org/ns/did/v1'],\n            id: did,\n            verificationMethod: [\n                {\n                    id: `${did}#controller`,\n                    type: 'EcdsaSecp256k1RecoveryMethod2020',\n                    controller: did,\n                    agentId: `${controllerAddress}@eip155:${networkId}`,\n                },\n            ],\n            authentication: [`${did}#controller`],\n        };\n    }\n    async updateIdentifier(args, context) {\n        throw new Error('WebDIDProvider updateIdentifier not supported yet.');\n    }\n    async deleteIdentifier(identifier, context) {\n        for (const { kid } of identifier.keys) {\n            await context.agent.keyManagerDelete({ kid });\n        }\n        return true;\n    }\n    async addService({ identifier, service, options }, context) {\n        return { success: true };\n    }\n    async removeKey(args, context) {\n        return { success: true };\n    }\n    async removeService(args, context) {\n        return { success: true };\n    }\n}\n//# sourceMappingURL=AgentDidProvider.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BhZ2VudGljLXRydXN0L3ZlcmFtby1hZ2VudC1leHRlbnNpb24vZGlzdC91dGlscy9BZ2VudERpZFByb3ZpZGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQWlFO0FBQzFELCtCQUErQiwyRUFBMEI7QUFDaEU7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLGFBQWE7QUFDbEQ7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGFBQWE7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIscUJBQXFCO0FBQ2xELDZDQUE2QyxJQUFJO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxRQUFRLEdBQUcsUUFBUTtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RTtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxJQUFJO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxPQUFPO0FBQzlEO0FBQ0E7QUFDQSx1REFBdUQsSUFBSTtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixJQUFJO0FBQy9CO0FBQ0E7QUFDQSxnQ0FBZ0Msa0JBQWtCLFVBQVUsVUFBVTtBQUN0RSxpQkFBaUI7QUFDakI7QUFDQSxnQ0FBZ0MsSUFBSTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsTUFBTTtBQUMzQixtREFBbUQsS0FBSztBQUN4RDtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsOEJBQThCO0FBQ3JELGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9iYXJiL2FhL0Fzc29jaWF0ZWRBY2NvdW50cy9ub2RlX21vZHVsZXMvQGFnZW50aWMtdHJ1c3QvdmVyYW1vLWFnZW50LWV4dGVuc2lvbi9kaXN0L3V0aWxzL0FnZW50RGlkUHJvdmlkZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQWJzdHJhY3RJZGVudGlmaWVyUHJvdmlkZXIgfSBmcm9tICdAdmVyYW1vL2RpZC1tYW5hZ2VyJztcbmV4cG9ydCBjbGFzcyBBZ2VudERpZFByb3ZpZGVyIGV4dGVuZHMgQWJzdHJhY3RJZGVudGlmaWVyUHJvdmlkZXIge1xuICAgIGFzeW5jIGFkZEtleShhcmdzLCBjb250ZXh0KSB7XG4gICAgICAgIC8vIEluIGEgcmVhbCBpbXBsZW1lbnRhdGlvbiwgeW91IHdvdWxkIGFkZCB0aGUga2V5IHRvIHRoZSBpZGVudGlmaWVyJ3Mga2V5IGxpc3QgYW5kIHBlcnNpc3QgaXQuXG4gICAgICAgIC8vIEhlcmUsIHdlIHNpbXVsYXRlIHRoaXMgYnkgcmV0dXJuaW5nIGEgc3VjY2VzcyByZXNwb25zZS5cbiAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSwga2V5OiBhcmdzLmtleSB9O1xuICAgIH1cbiAgICBkZWZhdWx0S21zO1xuICAgIGNoYWluSWQ7XG4gICAgYWdlbnRJZDtcbiAgICBwcm92aWRlck5hbWU7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmRlZmF1bHRLbXMgPSBvcHRpb25zLmRlZmF1bHRLbXM7XG4gICAgICAgIHRoaXMuY2hhaW5JZCA9IG9wdGlvbnMuY2hhaW5JZDtcbiAgICAgICAgdGhpcy5hZ2VudElkID0gb3B0aW9ucy5hZ2VudElkO1xuICAgICAgICB0aGlzLnByb3ZpZGVyTmFtZSA9IGBhZ2VudDoke3RoaXMuYWdlbnRJZH1gO1xuICAgIH1cbiAgICAvLyBSZXR1cm5zIHRoZSBESUQgbWV0aG9kIG5hbWVcbiAgICBnZXRTdXBwb3J0ZWRNZXRob2RzKCkge1xuICAgICAgICByZXR1cm4gW2BhZ2VudDoke3RoaXMuYWdlbnRJZH1gXTtcbiAgICB9XG4gICAgZ2V0QWNjb3VudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWdlbnRJZDtcbiAgICB9XG4gICAgYXN5bmMgY3JlYXRlSWRlbnRpZmllcih7IGttcywgYWxpYXMsIG9wdGlvbnMgfSwgY29udGV4dCkge1xuICAgICAgICAvL2NvbnNvbGUuaW5mbyhgUmVzb2x2aW5nIERJRCAxMTE6ICR7ZGlkfWApXG4gICAgICAgIC8vIHByb3ZpZGVyIGFuZCBkaWQgYXJlIGEgb25lIHRvIG9uZSByZWxhdGlvbnNoaXBcbiAgICAgICAgY29uc3QgYWdlbnRJZCA9IHRoaXMuYWdlbnRJZDtcbiAgICAgICAgY29uc3QgY2hhaW5JZCA9IHRoaXMuY2hhaW5JZDtcbiAgICAgICAgY29uc3QgZGlkID0gYGRpZDo4MDA0OmVpcDE1NToke2NoYWluSWR9OiR7YWdlbnRJZH1gO1xuICAgICAgICBjb25zdCBpZGVudGlmaWVyID0ge1xuICAgICAgICAgICAgZGlkLFxuICAgICAgICAgICAgYWxpYXMsXG4gICAgICAgICAgICBwcm92aWRlcjogdGhpcy5wcm92aWRlck5hbWUsXG4gICAgICAgICAgICBjb250cm9sbGVyS2V5SWQ6IGFnZW50SWQsIC8vIGFzc3VtZXMgbm8gbG9jYWwgcHJpdmF0ZSBrZXk7IHNpZ25pbmcgZG9uZSBleHRlcm5hbGx5IG9yIG9uLWNoYWluXG4gICAgICAgICAgICBrZXlzOiBbXSxcbiAgICAgICAgICAgIHNlcnZpY2VzOiBbXSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc29sZS5pbmZvKFwiJiYmJiYmJiYmJiYmIENyZWF0aW5nIGlkZW50aWZpZXI6XCIsIGlkZW50aWZpZXIpO1xuICAgICAgICByZXR1cm4gaWRlbnRpZmllcjtcbiAgICB9XG4gICAgYXN5bmMgcmVzb2x2ZURpZChkaWQpIHtcbiAgICAgICAgY29uc29sZS5pbmZvKGBSZXNvbHZpbmcgRElEIDIyMjogJHtkaWR9YCk7XG4gICAgICAgIGNvbnN0IHBhcnRzID0gZGlkLnNwbGl0KCc6Jykuc2xpY2UoMSk7XG4gICAgICAgIGNvbnN0IFttZXRob2QsIG5ldHdvcmtJZCwgYWdlbnRJZF0gPSBwYXJ0cztcbiAgICAgICAgaWYgKG1ldGhvZCAhPT0gJ2NvbnRyYWN0Jykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBESUQgbWV0aG9kOiAke21ldGhvZH1gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWFnZW50SWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTWlzc2luZyBhZ2VudElkIGluIERJRDogJHtkaWR9YCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29udHJvbGxlckFkZHJlc3MgPSBhZ2VudElkLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnQGNvbnRleHQnOiBbJ2h0dHBzOi8vd3d3LnczLm9yZy9ucy9kaWQvdjEnXSxcbiAgICAgICAgICAgIGlkOiBkaWQsXG4gICAgICAgICAgICB2ZXJpZmljYXRpb25NZXRob2Q6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBgJHtkaWR9I2NvbnRyb2xsZXJgLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnRWNkc2FTZWNwMjU2azFSZWNvdmVyeU1ldGhvZDIwMjAnLFxuICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyOiBkaWQsXG4gICAgICAgICAgICAgICAgICAgIGFnZW50SWQ6IGAke2NvbnRyb2xsZXJBZGRyZXNzfUBlaXAxNTU6JHtuZXR3b3JrSWR9YCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIGF1dGhlbnRpY2F0aW9uOiBbYCR7ZGlkfSNjb250cm9sbGVyYF0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIGFzeW5jIHVwZGF0ZUlkZW50aWZpZXIoYXJncywgY29udGV4dCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dlYkRJRFByb3ZpZGVyIHVwZGF0ZUlkZW50aWZpZXIgbm90IHN1cHBvcnRlZCB5ZXQuJyk7XG4gICAgfVxuICAgIGFzeW5jIGRlbGV0ZUlkZW50aWZpZXIoaWRlbnRpZmllciwgY29udGV4dCkge1xuICAgICAgICBmb3IgKGNvbnN0IHsga2lkIH0gb2YgaWRlbnRpZmllci5rZXlzKSB7XG4gICAgICAgICAgICBhd2FpdCBjb250ZXh0LmFnZW50LmtleU1hbmFnZXJEZWxldGUoeyBraWQgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGFzeW5jIGFkZFNlcnZpY2UoeyBpZGVudGlmaWVyLCBzZXJ2aWNlLCBvcHRpb25zIH0sIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSB9O1xuICAgIH1cbiAgICBhc3luYyByZW1vdmVLZXkoYXJncywgY29udGV4dCkge1xuICAgICAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlIH07XG4gICAgfVxuICAgIGFzeW5jIHJlbW92ZVNlcnZpY2UoYXJncywgY29udGV4dCkge1xuICAgICAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlIH07XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QWdlbnREaWRQcm92aWRlci5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@agentic-trust/veramo-agent-extension/dist/utils/AgentDidProvider.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@agentic-trust/veramo-agent-extension/dist/utils/AgentKeyManagementSystem.js":
/*!*******************************************************************************************************!*\
  !*** ../../node_modules/@agentic-trust/veramo-agent-extension/dist/utils/AgentKeyManagementSystem.js ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AgentKeyManagementSystem: () => (/* binding */ AgentKeyManagementSystem),\n/* harmony export */   compareAgentId: () => (/* binding */ compareAgentId),\n/* harmony export */   compressAgentIdentifierSecp256k1Keys: () => (/* binding */ compressAgentIdentifierSecp256k1Keys),\n/* harmony export */   convertAgentIdentifierEncryptionKeys: () => (/* binding */ convertAgentIdentifierEncryptionKeys),\n/* harmony export */   getAgentEthereumAddress: () => (/* binding */ getAgentEthereumAddress),\n/* harmony export */   mapAgentIdentifierKeysToDoc: () => (/* binding */ mapAgentIdentifierKeysToDoc)\n/* harmony export */ });\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ethers */ \"(rsc)/../../node_modules/ethers/lib.esm/crypto/signing-key.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ethers */ \"(rsc)/../../node_modules/ethers/lib.esm/transaction/address.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ethers */ \"(rsc)/../../node_modules/ethers/lib.esm/utils/utf8.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! viem */ \"(rsc)/../../node_modules/viem/_esm/utils/encoding/toBytes.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! viem */ \"(rsc)/../../node_modules/viem/_esm/utils/encoding/toHex.js\");\n/* harmony import */ var _veramo_key_manager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @veramo/key-manager */ \"(rsc)/../../node_modules/@veramo/key-manager/build/index.js\");\n/* harmony import */ var _veramo_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @veramo/utils */ \"(rsc)/../../node_modules/@veramo/utils/build/index.js\");\n/* harmony import */ var did_jwt__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! did-jwt */ \"(rsc)/../../node_modules/did-jwt/lib/index.module.js\");\n\n\n\n\n\nfunction compressAgentIdentifierSecp256k1Keys(identifier) {\n    return identifier.keys\n        .map((key) => {\n        if (key.type === 'Secp256k1') {\n            if (key.publicKeyHex) {\n                const publicBytes = (0,viem__WEBPACK_IMPORTED_MODULE_3__.hexToBytes)(key.publicKeyHex);\n                key.publicKeyHex = ethers__WEBPACK_IMPORTED_MODULE_4__.SigningKey.computePublicKey(publicBytes, true).substring(2);\n                key.meta = { ...key.meta };\n                key.meta.ethereumAddress = (0,ethers__WEBPACK_IMPORTED_MODULE_5__.computeAddress)('0x' + key.publicKeyHex);\n            }\n        }\n        return key;\n    })\n        .filter(_veramo_utils__WEBPACK_IMPORTED_MODULE_1__.isDefined);\n}\nfunction convertAgentIdentifierEncryptionKeys(identifier) {\n    return identifier.keys\n        .map((key) => {\n        if (key.type === 'Ed25519') {\n            const publicBytes = (0,viem__WEBPACK_IMPORTED_MODULE_3__.hexToBytes)(key.publicKeyHex);\n            key.publicKeyHex = (0,viem__WEBPACK_IMPORTED_MODULE_6__.bytesToHex)((0,_veramo_utils__WEBPACK_IMPORTED_MODULE_1__.convertEd25519PublicKeyToX25519)(publicBytes));\n            if (key.privateKeyHex) {\n                const privateBytes = (0,viem__WEBPACK_IMPORTED_MODULE_3__.hexToBytes)(key.privateKeyHex);\n                key.privateKeyHex = (0,viem__WEBPACK_IMPORTED_MODULE_6__.bytesToHex)((0,_veramo_utils__WEBPACK_IMPORTED_MODULE_1__.convertEd25519PrivateKeyToX25519)(privateBytes));\n            }\n            key.type = 'X25519';\n        }\n        else if (key.type !== 'X25519') {\n            console.info(`key of type ${key.type} is not supported for [de]encryption`);\n            return null;\n        }\n        return key;\n    })\n        .filter(_veramo_utils__WEBPACK_IMPORTED_MODULE_1__.isDefined);\n}\nfunction getAgentEthereumAddress(verificationMethod) {\n    let vmEthAddr = verificationMethod.ethereumAddress?.toLowerCase();\n    if (!vmEthAddr) {\n        const blockchainAccountId = verificationMethod.blockchainAccountId;\n        if (blockchainAccountId?.includes('@eip155')) {\n            vmEthAddr = blockchainAccountId.split('@eip155')[0]?.toLowerCase();\n        }\n        else if (verificationMethod.blockchainAccountId?.startsWith('eip155')) {\n            vmEthAddr = verificationMethod.blockchainAccountId.split(':')[2]?.toLowerCase();\n        }\n        else {\n            const { keyBytes, keyType } = (0,did_jwt__WEBPACK_IMPORTED_MODULE_2__.extractPublicKeyBytes)(verificationMethod);\n            if (keyType !== 'Secp256k1') {\n                return undefined;\n            }\n            const pbHex = ethers__WEBPACK_IMPORTED_MODULE_4__.SigningKey.computePublicKey(keyBytes, false);\n            vmEthAddr = (0,ethers__WEBPACK_IMPORTED_MODULE_5__.computeAddress)(pbHex).toLowerCase();\n        }\n    }\n    return vmEthAddr;\n}\nfunction compareAgentId(localKey, verificationMethod) {\n    //if (localKey.type !== 'Secp256k1') {\n    //  return false\n    //}\n    let vmEthAddr = getAgentEthereumAddress(verificationMethod);\n    const localAccount = localKey.meta?.account ?? localKey.meta?.ethereumAddress;\n    if (localKey.meta?.account) {\n        console.info(\"localKey.meta.account: \", localKey.meta.account);\n        console.info(\"vmEthAddr: \", vmEthAddr);\n        return vmEthAddr === localAccount.toLowerCase();\n    }\n    console.info(\"localKey.publicKeyHex: \", localKey.publicKeyHex);\n    const computedAddr = (0,ethers__WEBPACK_IMPORTED_MODULE_5__.computeAddress)('0x' + localKey.publicKeyHex).toLowerCase();\n    console.info(\"computedAddr: \", computedAddr);\n    console.info(\"vmEthAddr: \", vmEthAddr);\n    return computedAddr === vmEthAddr;\n}\nasync function mapAgentIdentifierKeysToDoc(identifier, section = 'keyAgreement', context, resolutionOptions) {\n    const didDocument = await (0,_veramo_utils__WEBPACK_IMPORTED_MODULE_1__.resolveDidOrThrow)(identifier.did, context, resolutionOptions);\n    console.info(\".............. didDocument: \", didDocument);\n    // dereference all key agreement keys from DID document and normalize\n    const documentKeys = await (0,_veramo_utils__WEBPACK_IMPORTED_MODULE_1__.dereferenceDidKeys)(didDocument, section, context);\n    console.info(\".............. documentKeys: \", documentKeys);\n    let localKeys = identifier.keys.filter(_veramo_utils__WEBPACK_IMPORTED_MODULE_1__.isDefined);\n    console.info(\"--- identifier keys: \", localKeys);\n    if (section === 'keyAgreement') {\n        localKeys = convertAgentIdentifierEncryptionKeys(identifier);\n    }\n    else {\n        localKeys = compressAgentIdentifierSecp256k1Keys(identifier);\n    }\n    console.info(\"--- identifier keys2: \", localKeys);\n    // finally map the didDocument keys to the identifier keys by comparing `publicKeyHex`\n    const extendedKeys = documentKeys\n        .map((verificationMethod) => {\n        console.info(\"localKey: \", localKeys);\n        console.info(\"verificationMethod: \", verificationMethod);\n        const localKey = localKeys.find((localKey) => localKey.publicKeyHex === verificationMethod.publicKeyHex ||\n            compareAgentId(localKey, verificationMethod));\n        console.info(\"localKey: \", localKey);\n        if (localKey) {\n            const { meta, ...localProps } = localKey;\n            return { ...localProps, meta: { ...meta, verificationMethod } };\n        }\n        else {\n            return null;\n        }\n    })\n        .filter(_veramo_utils__WEBPACK_IMPORTED_MODULE_1__.isDefined);\n    return extendedKeys;\n}\nclass AgentKeyManagementSystem extends _veramo_key_manager__WEBPACK_IMPORTED_MODULE_0__.AbstractKeyManagementSystem {\n    providers;\n    constructor(providers) {\n        super();\n        this.providers = providers;\n    }\n    async createKey({ type }) {\n        throw Error('not_supported: AgentKeyManagementSystem cannot create new keys');\n    }\n    async importKey(args) {\n        return args;\n    }\n    async listKeys() {\n        console.info(\"********************** listKeys **********************\");\n        const keys = [];\n        for (const provider in this.providers) {\n            const providerInstance = this.providers[provider];\n            if (!providerInstance) {\n                continue;\n            }\n            const account = await providerInstance.getAccount();\n            const key = {\n                kid: `${provider}-${account}`,\n                type: 'Secp256k1',\n                publicKeyHex: '',\n                kms: '',\n                meta: {\n                    account,\n                    provider,\n                    algorithms: ['eth_signMessage', 'eth_signTypedData'],\n                },\n            };\n            keys.push(key);\n        }\n        return keys;\n    }\n    async sharedSecret(args) {\n        console.info(\"********************** sharedSecret **********************\");\n        throw Error('not_implemented: Web3KeyManagementSystem sharedSecret');\n    }\n    async deleteKey(args) {\n        console.info(\"********************** deleteKey **********************\");\n        // this kms doesn't need to delete keys\n        return true;\n    }\n    async sign({ keyRef, algorithm, data, }) {\n        console.info(\"********************** sign **********************\");\n        if (algorithm) {\n            if (algorithm === 'eth_signMessage') {\n                return await this.eth_signMessage(keyRef, data);\n            }\n            else if (['eth_signTypedData', 'EthereumEip712Signature2021'].includes(algorithm)) {\n                return await this.eth_signTypedData(keyRef, data);\n            }\n        }\n        throw Error(`not_supported: Cannot sign ${algorithm} `);\n    }\n    /**\n     * @returns a `0x` prefixed hex string representing the signed EIP712 data\n     */\n    async eth_signTypedData(keyRef, data) {\n        console.info(\"********************** eth_signTypedData **********************\");\n        let msg, msgDomain, msgTypes, msgPrimaryType;\n        const serializedData = (0,ethers__WEBPACK_IMPORTED_MODULE_7__.toUtf8String)(data);\n        try {\n            const jsonData = JSON.parse(serializedData);\n            if (typeof jsonData.domain === 'object' && typeof jsonData.types === 'object') {\n                const { domain, types, message, primaryType } = jsonData;\n                msg = message;\n                msgDomain = domain;\n                msgTypes = types;\n                msgPrimaryType = primaryType;\n            }\n            else {\n                // next check will throw since the data couldn't be parsed\n            }\n        }\n        catch (e) {\n            // next check will throw since the data couldn't be parsed\n        }\n        if (typeof msgDomain !== 'object' || typeof msgTypes !== 'object' || typeof msg !== 'object') {\n            throw Error(`invalid_arguments: Cannot sign typed data. 'domain', 'types', and 'message' must be provided`);\n        }\n        delete msgTypes.EIP712Domain;\n        //const signature = await signer.signTypedData(msgDomain, msgTypes, msg)\n        const signature = \"0xabc\";\n        return signature;\n    }\n    /**\n     * @returns a `0x` prefixed hex string representing the signed message\n     */\n    async eth_signMessage(keyRef, rawMessageBytes) {\n        console.info(\"********************** eth_signMessage **********************\");\n        //const signature = await signer.signMessage(rawMessageBytes)\n        const signature = \"0xabc\";\n        // HEX encoded string, 0x prefixed\n        return signature;\n    }\n}\n//# sourceMappingURL=AgentKeyManagementSystem.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BhZ2VudGljLXRydXN0L3ZlcmFtby1hZ2VudC1leHRlbnNpb24vZGlzdC91dGlscy9BZ2VudEtleU1hbmFnZW1lbnRTeXN0ZW0uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBa0U7QUFDcEI7QUFDb0I7QUFDa0Y7QUFDcEc7QUFDekM7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxnREFBVTtBQUM5QyxtQ0FBbUMsOENBQVU7QUFDN0MsNkJBQTZCO0FBQzdCLDJDQUEyQyxzREFBYztBQUN6RDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsZ0JBQWdCLG9EQUFTO0FBQ3pCO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsZ0RBQVU7QUFDMUMsK0JBQStCLGdEQUFVLENBQUMsOEVBQStCO0FBQ3pFO0FBQ0EscUNBQXFDLGdEQUFVO0FBQy9DLG9DQUFvQyxnREFBVSxDQUFDLCtFQUFnQztBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxVQUFVO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxnQkFBZ0Isb0RBQVM7QUFDekI7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9CQUFvQixFQUFFLDhEQUFxQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsOENBQVU7QUFDcEMsd0JBQXdCLHNEQUFjO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHNEQUFjO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCw4QkFBOEIsZ0VBQWlCO0FBQy9DO0FBQ0E7QUFDQSwrQkFBK0IsaUVBQWtCO0FBQ2pEO0FBQ0EsMkNBQTJDLG9EQUFTO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc0JBQXNCO0FBQzFDLHFCQUFxQix1QkFBdUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsZ0JBQWdCLG9EQUFTO0FBQ3pCO0FBQ0E7QUFDTyx1Q0FBdUMsNEVBQTJCO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsTUFBTTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsU0FBUyxHQUFHLFFBQVE7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiwwQkFBMEI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELFdBQVc7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0Isb0RBQVk7QUFDM0M7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHNDQUFzQztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9iYXJiL2FhL0Fzc29jaWF0ZWRBY2NvdW50cy9ub2RlX21vZHVsZXMvQGFnZW50aWMtdHJ1c3QvdmVyYW1vLWFnZW50LWV4dGVuc2lvbi9kaXN0L3V0aWxzL0FnZW50S2V5TWFuYWdlbWVudFN5c3RlbS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB0b1V0ZjhTdHJpbmcsIFNpZ25pbmdLZXksIGNvbXB1dGVBZGRyZXNzIH0gZnJvbSAnZXRoZXJzJztcbmltcG9ydCB7IGhleFRvQnl0ZXMsIGJ5dGVzVG9IZXggfSBmcm9tIFwidmllbVwiO1xuaW1wb3J0IHsgQWJzdHJhY3RLZXlNYW5hZ2VtZW50U3lzdGVtIH0gZnJvbSAnQHZlcmFtby9rZXktbWFuYWdlcic7XG5pbXBvcnQgeyBpc0RlZmluZWQsIHJlc29sdmVEaWRPclRocm93LCBkZXJlZmVyZW5jZURpZEtleXMsIGNvbnZlcnRFZDI1NTE5UHVibGljS2V5VG9YMjU1MTksIGNvbnZlcnRFZDI1NTE5UHJpdmF0ZUtleVRvWDI1NTE5IH0gZnJvbSAnQHZlcmFtby91dGlscyc7XG5pbXBvcnQgeyBleHRyYWN0UHVibGljS2V5Qnl0ZXMgfSBmcm9tICdkaWQtand0JztcbmV4cG9ydCBmdW5jdGlvbiBjb21wcmVzc0FnZW50SWRlbnRpZmllclNlY3AyNTZrMUtleXMoaWRlbnRpZmllcikge1xuICAgIHJldHVybiBpZGVudGlmaWVyLmtleXNcbiAgICAgICAgLm1hcCgoa2V5KSA9PiB7XG4gICAgICAgIGlmIChrZXkudHlwZSA9PT0gJ1NlY3AyNTZrMScpIHtcbiAgICAgICAgICAgIGlmIChrZXkucHVibGljS2V5SGV4KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHVibGljQnl0ZXMgPSBoZXhUb0J5dGVzKGtleS5wdWJsaWNLZXlIZXgpO1xuICAgICAgICAgICAgICAgIGtleS5wdWJsaWNLZXlIZXggPSBTaWduaW5nS2V5LmNvbXB1dGVQdWJsaWNLZXkocHVibGljQnl0ZXMsIHRydWUpLnN1YnN0cmluZygyKTtcbiAgICAgICAgICAgICAgICBrZXkubWV0YSA9IHsgLi4ua2V5Lm1ldGEgfTtcbiAgICAgICAgICAgICAgICBrZXkubWV0YS5ldGhlcmV1bUFkZHJlc3MgPSBjb21wdXRlQWRkcmVzcygnMHgnICsga2V5LnB1YmxpY0tleUhleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGtleTtcbiAgICB9KVxuICAgICAgICAuZmlsdGVyKGlzRGVmaW5lZCk7XG59XG5leHBvcnQgZnVuY3Rpb24gY29udmVydEFnZW50SWRlbnRpZmllckVuY3J5cHRpb25LZXlzKGlkZW50aWZpZXIpIHtcbiAgICByZXR1cm4gaWRlbnRpZmllci5rZXlzXG4gICAgICAgIC5tYXAoKGtleSkgPT4ge1xuICAgICAgICBpZiAoa2V5LnR5cGUgPT09ICdFZDI1NTE5Jykge1xuICAgICAgICAgICAgY29uc3QgcHVibGljQnl0ZXMgPSBoZXhUb0J5dGVzKGtleS5wdWJsaWNLZXlIZXgpO1xuICAgICAgICAgICAga2V5LnB1YmxpY0tleUhleCA9IGJ5dGVzVG9IZXgoY29udmVydEVkMjU1MTlQdWJsaWNLZXlUb1gyNTUxOShwdWJsaWNCeXRlcykpO1xuICAgICAgICAgICAgaWYgKGtleS5wcml2YXRlS2V5SGV4KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJpdmF0ZUJ5dGVzID0gaGV4VG9CeXRlcyhrZXkucHJpdmF0ZUtleUhleCk7XG4gICAgICAgICAgICAgICAga2V5LnByaXZhdGVLZXlIZXggPSBieXRlc1RvSGV4KGNvbnZlcnRFZDI1NTE5UHJpdmF0ZUtleVRvWDI1NTE5KHByaXZhdGVCeXRlcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAga2V5LnR5cGUgPSAnWDI1NTE5JztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChrZXkudHlwZSAhPT0gJ1gyNTUxOScpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhga2V5IG9mIHR5cGUgJHtrZXkudHlwZX0gaXMgbm90IHN1cHBvcnRlZCBmb3IgW2RlXWVuY3J5cHRpb25gKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBrZXk7XG4gICAgfSlcbiAgICAgICAgLmZpbHRlcihpc0RlZmluZWQpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldEFnZW50RXRoZXJldW1BZGRyZXNzKHZlcmlmaWNhdGlvbk1ldGhvZCkge1xuICAgIGxldCB2bUV0aEFkZHIgPSB2ZXJpZmljYXRpb25NZXRob2QuZXRoZXJldW1BZGRyZXNzPy50b0xvd2VyQ2FzZSgpO1xuICAgIGlmICghdm1FdGhBZGRyKSB7XG4gICAgICAgIGNvbnN0IGJsb2NrY2hhaW5BY2NvdW50SWQgPSB2ZXJpZmljYXRpb25NZXRob2QuYmxvY2tjaGFpbkFjY291bnRJZDtcbiAgICAgICAgaWYgKGJsb2NrY2hhaW5BY2NvdW50SWQ/LmluY2x1ZGVzKCdAZWlwMTU1JykpIHtcbiAgICAgICAgICAgIHZtRXRoQWRkciA9IGJsb2NrY2hhaW5BY2NvdW50SWQuc3BsaXQoJ0BlaXAxNTUnKVswXT8udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2ZXJpZmljYXRpb25NZXRob2QuYmxvY2tjaGFpbkFjY291bnRJZD8uc3RhcnRzV2l0aCgnZWlwMTU1JykpIHtcbiAgICAgICAgICAgIHZtRXRoQWRkciA9IHZlcmlmaWNhdGlvbk1ldGhvZC5ibG9ja2NoYWluQWNjb3VudElkLnNwbGl0KCc6JylbMl0/LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCB7IGtleUJ5dGVzLCBrZXlUeXBlIH0gPSBleHRyYWN0UHVibGljS2V5Qnl0ZXModmVyaWZpY2F0aW9uTWV0aG9kKTtcbiAgICAgICAgICAgIGlmIChrZXlUeXBlICE9PSAnU2VjcDI1NmsxJykge1xuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwYkhleCA9IFNpZ25pbmdLZXkuY29tcHV0ZVB1YmxpY0tleShrZXlCeXRlcywgZmFsc2UpO1xuICAgICAgICAgICAgdm1FdGhBZGRyID0gY29tcHV0ZUFkZHJlc3MocGJIZXgpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZtRXRoQWRkcjtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjb21wYXJlQWdlbnRJZChsb2NhbEtleSwgdmVyaWZpY2F0aW9uTWV0aG9kKSB7XG4gICAgLy9pZiAobG9jYWxLZXkudHlwZSAhPT0gJ1NlY3AyNTZrMScpIHtcbiAgICAvLyAgcmV0dXJuIGZhbHNlXG4gICAgLy99XG4gICAgbGV0IHZtRXRoQWRkciA9IGdldEFnZW50RXRoZXJldW1BZGRyZXNzKHZlcmlmaWNhdGlvbk1ldGhvZCk7XG4gICAgY29uc3QgbG9jYWxBY2NvdW50ID0gbG9jYWxLZXkubWV0YT8uYWNjb3VudCA/PyBsb2NhbEtleS5tZXRhPy5ldGhlcmV1bUFkZHJlc3M7XG4gICAgaWYgKGxvY2FsS2V5Lm1ldGE/LmFjY291bnQpIHtcbiAgICAgICAgY29uc29sZS5pbmZvKFwibG9jYWxLZXkubWV0YS5hY2NvdW50OiBcIiwgbG9jYWxLZXkubWV0YS5hY2NvdW50KTtcbiAgICAgICAgY29uc29sZS5pbmZvKFwidm1FdGhBZGRyOiBcIiwgdm1FdGhBZGRyKTtcbiAgICAgICAgcmV0dXJuIHZtRXRoQWRkciA9PT0gbG9jYWxBY2NvdW50LnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuICAgIGNvbnNvbGUuaW5mbyhcImxvY2FsS2V5LnB1YmxpY0tleUhleDogXCIsIGxvY2FsS2V5LnB1YmxpY0tleUhleCk7XG4gICAgY29uc3QgY29tcHV0ZWRBZGRyID0gY29tcHV0ZUFkZHJlc3MoJzB4JyArIGxvY2FsS2V5LnB1YmxpY0tleUhleCkudG9Mb3dlckNhc2UoKTtcbiAgICBjb25zb2xlLmluZm8oXCJjb21wdXRlZEFkZHI6IFwiLCBjb21wdXRlZEFkZHIpO1xuICAgIGNvbnNvbGUuaW5mbyhcInZtRXRoQWRkcjogXCIsIHZtRXRoQWRkcik7XG4gICAgcmV0dXJuIGNvbXB1dGVkQWRkciA9PT0gdm1FdGhBZGRyO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIG1hcEFnZW50SWRlbnRpZmllcktleXNUb0RvYyhpZGVudGlmaWVyLCBzZWN0aW9uID0gJ2tleUFncmVlbWVudCcsIGNvbnRleHQsIHJlc29sdXRpb25PcHRpb25zKSB7XG4gICAgY29uc3QgZGlkRG9jdW1lbnQgPSBhd2FpdCByZXNvbHZlRGlkT3JUaHJvdyhpZGVudGlmaWVyLmRpZCwgY29udGV4dCwgcmVzb2x1dGlvbk9wdGlvbnMpO1xuICAgIGNvbnNvbGUuaW5mbyhcIi4uLi4uLi4uLi4uLi4uIGRpZERvY3VtZW50OiBcIiwgZGlkRG9jdW1lbnQpO1xuICAgIC8vIGRlcmVmZXJlbmNlIGFsbCBrZXkgYWdyZWVtZW50IGtleXMgZnJvbSBESUQgZG9jdW1lbnQgYW5kIG5vcm1hbGl6ZVxuICAgIGNvbnN0IGRvY3VtZW50S2V5cyA9IGF3YWl0IGRlcmVmZXJlbmNlRGlkS2V5cyhkaWREb2N1bWVudCwgc2VjdGlvbiwgY29udGV4dCk7XG4gICAgY29uc29sZS5pbmZvKFwiLi4uLi4uLi4uLi4uLi4gZG9jdW1lbnRLZXlzOiBcIiwgZG9jdW1lbnRLZXlzKTtcbiAgICBsZXQgbG9jYWxLZXlzID0gaWRlbnRpZmllci5rZXlzLmZpbHRlcihpc0RlZmluZWQpO1xuICAgIGNvbnNvbGUuaW5mbyhcIi0tLSBpZGVudGlmaWVyIGtleXM6IFwiLCBsb2NhbEtleXMpO1xuICAgIGlmIChzZWN0aW9uID09PSAna2V5QWdyZWVtZW50Jykge1xuICAgICAgICBsb2NhbEtleXMgPSBjb252ZXJ0QWdlbnRJZGVudGlmaWVyRW5jcnlwdGlvbktleXMoaWRlbnRpZmllcik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBsb2NhbEtleXMgPSBjb21wcmVzc0FnZW50SWRlbnRpZmllclNlY3AyNTZrMUtleXMoaWRlbnRpZmllcik7XG4gICAgfVxuICAgIGNvbnNvbGUuaW5mbyhcIi0tLSBpZGVudGlmaWVyIGtleXMyOiBcIiwgbG9jYWxLZXlzKTtcbiAgICAvLyBmaW5hbGx5IG1hcCB0aGUgZGlkRG9jdW1lbnQga2V5cyB0byB0aGUgaWRlbnRpZmllciBrZXlzIGJ5IGNvbXBhcmluZyBgcHVibGljS2V5SGV4YFxuICAgIGNvbnN0IGV4dGVuZGVkS2V5cyA9IGRvY3VtZW50S2V5c1xuICAgICAgICAubWFwKCh2ZXJpZmljYXRpb25NZXRob2QpID0+IHtcbiAgICAgICAgY29uc29sZS5pbmZvKFwibG9jYWxLZXk6IFwiLCBsb2NhbEtleXMpO1xuICAgICAgICBjb25zb2xlLmluZm8oXCJ2ZXJpZmljYXRpb25NZXRob2Q6IFwiLCB2ZXJpZmljYXRpb25NZXRob2QpO1xuICAgICAgICBjb25zdCBsb2NhbEtleSA9IGxvY2FsS2V5cy5maW5kKChsb2NhbEtleSkgPT4gbG9jYWxLZXkucHVibGljS2V5SGV4ID09PSB2ZXJpZmljYXRpb25NZXRob2QucHVibGljS2V5SGV4IHx8XG4gICAgICAgICAgICBjb21wYXJlQWdlbnRJZChsb2NhbEtleSwgdmVyaWZpY2F0aW9uTWV0aG9kKSk7XG4gICAgICAgIGNvbnNvbGUuaW5mbyhcImxvY2FsS2V5OiBcIiwgbG9jYWxLZXkpO1xuICAgICAgICBpZiAobG9jYWxLZXkpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgbWV0YSwgLi4ubG9jYWxQcm9wcyB9ID0gbG9jYWxLZXk7XG4gICAgICAgICAgICByZXR1cm4geyAuLi5sb2NhbFByb3BzLCBtZXRhOiB7IC4uLm1ldGEsIHZlcmlmaWNhdGlvbk1ldGhvZCB9IH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH0pXG4gICAgICAgIC5maWx0ZXIoaXNEZWZpbmVkKTtcbiAgICByZXR1cm4gZXh0ZW5kZWRLZXlzO1xufVxuZXhwb3J0IGNsYXNzIEFnZW50S2V5TWFuYWdlbWVudFN5c3RlbSBleHRlbmRzIEFic3RyYWN0S2V5TWFuYWdlbWVudFN5c3RlbSB7XG4gICAgcHJvdmlkZXJzO1xuICAgIGNvbnN0cnVjdG9yKHByb3ZpZGVycykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnByb3ZpZGVycyA9IHByb3ZpZGVycztcbiAgICB9XG4gICAgYXN5bmMgY3JlYXRlS2V5KHsgdHlwZSB9KSB7XG4gICAgICAgIHRocm93IEVycm9yKCdub3Rfc3VwcG9ydGVkOiBBZ2VudEtleU1hbmFnZW1lbnRTeXN0ZW0gY2Fubm90IGNyZWF0ZSBuZXcga2V5cycpO1xuICAgIH1cbiAgICBhc3luYyBpbXBvcnRLZXkoYXJncykge1xuICAgICAgICByZXR1cm4gYXJncztcbiAgICB9XG4gICAgYXN5bmMgbGlzdEtleXMoKSB7XG4gICAgICAgIGNvbnNvbGUuaW5mbyhcIioqKioqKioqKioqKioqKioqKioqKiogbGlzdEtleXMgKioqKioqKioqKioqKioqKioqKioqKlwiKTtcbiAgICAgICAgY29uc3Qga2V5cyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHByb3ZpZGVyIGluIHRoaXMucHJvdmlkZXJzKSB7XG4gICAgICAgICAgICBjb25zdCBwcm92aWRlckluc3RhbmNlID0gdGhpcy5wcm92aWRlcnNbcHJvdmlkZXJdO1xuICAgICAgICAgICAgaWYgKCFwcm92aWRlckluc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhY2NvdW50ID0gYXdhaXQgcHJvdmlkZXJJbnN0YW5jZS5nZXRBY2NvdW50KCk7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSB7XG4gICAgICAgICAgICAgICAga2lkOiBgJHtwcm92aWRlcn0tJHthY2NvdW50fWAsXG4gICAgICAgICAgICAgICAgdHlwZTogJ1NlY3AyNTZrMScsXG4gICAgICAgICAgICAgICAgcHVibGljS2V5SGV4OiAnJyxcbiAgICAgICAgICAgICAgICBrbXM6ICcnLFxuICAgICAgICAgICAgICAgIG1ldGE6IHtcbiAgICAgICAgICAgICAgICAgICAgYWNjb3VudCxcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXIsXG4gICAgICAgICAgICAgICAgICAgIGFsZ29yaXRobXM6IFsnZXRoX3NpZ25NZXNzYWdlJywgJ2V0aF9zaWduVHlwZWREYXRhJ10sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ga2V5cztcbiAgICB9XG4gICAgYXN5bmMgc2hhcmVkU2VjcmV0KGFyZ3MpIHtcbiAgICAgICAgY29uc29sZS5pbmZvKFwiKioqKioqKioqKioqKioqKioqKioqKiBzaGFyZWRTZWNyZXQgKioqKioqKioqKioqKioqKioqKioqKlwiKTtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ25vdF9pbXBsZW1lbnRlZDogV2ViM0tleU1hbmFnZW1lbnRTeXN0ZW0gc2hhcmVkU2VjcmV0Jyk7XG4gICAgfVxuICAgIGFzeW5jIGRlbGV0ZUtleShhcmdzKSB7XG4gICAgICAgIGNvbnNvbGUuaW5mbyhcIioqKioqKioqKioqKioqKioqKioqKiogZGVsZXRlS2V5ICoqKioqKioqKioqKioqKioqKioqKipcIik7XG4gICAgICAgIC8vIHRoaXMga21zIGRvZXNuJ3QgbmVlZCB0byBkZWxldGUga2V5c1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgYXN5bmMgc2lnbih7IGtleVJlZiwgYWxnb3JpdGhtLCBkYXRhLCB9KSB7XG4gICAgICAgIGNvbnNvbGUuaW5mbyhcIioqKioqKioqKioqKioqKioqKioqKiogc2lnbiAqKioqKioqKioqKioqKioqKioqKioqXCIpO1xuICAgICAgICBpZiAoYWxnb3JpdGhtKSB7XG4gICAgICAgICAgICBpZiAoYWxnb3JpdGhtID09PSAnZXRoX3NpZ25NZXNzYWdlJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmV0aF9zaWduTWVzc2FnZShrZXlSZWYsIGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoWydldGhfc2lnblR5cGVkRGF0YScsICdFdGhlcmV1bUVpcDcxMlNpZ25hdHVyZTIwMjEnXS5pbmNsdWRlcyhhbGdvcml0aG0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZXRoX3NpZ25UeXBlZERhdGEoa2V5UmVmLCBkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBFcnJvcihgbm90X3N1cHBvcnRlZDogQ2Fubm90IHNpZ24gJHthbGdvcml0aG19IGApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBhIGAweGAgcHJlZml4ZWQgaGV4IHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHNpZ25lZCBFSVA3MTIgZGF0YVxuICAgICAqL1xuICAgIGFzeW5jIGV0aF9zaWduVHlwZWREYXRhKGtleVJlZiwgZGF0YSkge1xuICAgICAgICBjb25zb2xlLmluZm8oXCIqKioqKioqKioqKioqKioqKioqKioqIGV0aF9zaWduVHlwZWREYXRhICoqKioqKioqKioqKioqKioqKioqKipcIik7XG4gICAgICAgIGxldCBtc2csIG1zZ0RvbWFpbiwgbXNnVHlwZXMsIG1zZ1ByaW1hcnlUeXBlO1xuICAgICAgICBjb25zdCBzZXJpYWxpemVkRGF0YSA9IHRvVXRmOFN0cmluZyhkYXRhKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGpzb25EYXRhID0gSlNPTi5wYXJzZShzZXJpYWxpemVkRGF0YSk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGpzb25EYXRhLmRvbWFpbiA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIGpzb25EYXRhLnR5cGVzID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZG9tYWluLCB0eXBlcywgbWVzc2FnZSwgcHJpbWFyeVR5cGUgfSA9IGpzb25EYXRhO1xuICAgICAgICAgICAgICAgIG1zZyA9IG1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgbXNnRG9tYWluID0gZG9tYWluO1xuICAgICAgICAgICAgICAgIG1zZ1R5cGVzID0gdHlwZXM7XG4gICAgICAgICAgICAgICAgbXNnUHJpbWFyeVR5cGUgPSBwcmltYXJ5VHlwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIG5leHQgY2hlY2sgd2lsbCB0aHJvdyBzaW5jZSB0aGUgZGF0YSBjb3VsZG4ndCBiZSBwYXJzZWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy8gbmV4dCBjaGVjayB3aWxsIHRocm93IHNpbmNlIHRoZSBkYXRhIGNvdWxkbid0IGJlIHBhcnNlZFxuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgbXNnRG9tYWluICE9PSAnb2JqZWN0JyB8fCB0eXBlb2YgbXNnVHlwZXMgIT09ICdvYmplY3QnIHx8IHR5cGVvZiBtc2cgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihgaW52YWxpZF9hcmd1bWVudHM6IENhbm5vdCBzaWduIHR5cGVkIGRhdGEuICdkb21haW4nLCAndHlwZXMnLCBhbmQgJ21lc3NhZ2UnIG11c3QgYmUgcHJvdmlkZWRgKTtcbiAgICAgICAgfVxuICAgICAgICBkZWxldGUgbXNnVHlwZXMuRUlQNzEyRG9tYWluO1xuICAgICAgICAvL2NvbnN0IHNpZ25hdHVyZSA9IGF3YWl0IHNpZ25lci5zaWduVHlwZWREYXRhKG1zZ0RvbWFpbiwgbXNnVHlwZXMsIG1zZylcbiAgICAgICAgY29uc3Qgc2lnbmF0dXJlID0gXCIweGFiY1wiO1xuICAgICAgICByZXR1cm4gc2lnbmF0dXJlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBhIGAweGAgcHJlZml4ZWQgaGV4IHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHNpZ25lZCBtZXNzYWdlXG4gICAgICovXG4gICAgYXN5bmMgZXRoX3NpZ25NZXNzYWdlKGtleVJlZiwgcmF3TWVzc2FnZUJ5dGVzKSB7XG4gICAgICAgIGNvbnNvbGUuaW5mbyhcIioqKioqKioqKioqKioqKioqKioqKiogZXRoX3NpZ25NZXNzYWdlICoqKioqKioqKioqKioqKioqKioqKipcIik7XG4gICAgICAgIC8vY29uc3Qgc2lnbmF0dXJlID0gYXdhaXQgc2lnbmVyLnNpZ25NZXNzYWdlKHJhd01lc3NhZ2VCeXRlcylcbiAgICAgICAgY29uc3Qgc2lnbmF0dXJlID0gXCIweGFiY1wiO1xuICAgICAgICAvLyBIRVggZW5jb2RlZCBzdHJpbmcsIDB4IHByZWZpeGVkXG4gICAgICAgIHJldHVybiBzaWduYXR1cmU7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QWdlbnRLZXlNYW5hZ2VtZW50U3lzdGVtLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@agentic-trust/veramo-agent-extension/dist/utils/AgentKeyManagementSystem.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@agentic-trust/veramo-agent-extension/dist/utils/AgentKmsSigner.js":
/*!*********************************************************************************************!*\
  !*** ../../node_modules/@agentic-trust/veramo-agent-extension/dist/utils/AgentKmsSigner.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AgentKmsSigner: () => (/* binding */ AgentKmsSigner)\n/* harmony export */ });\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ethers */ \"(rsc)/../../node_modules/ethers/lib.esm/providers/abstract-signer.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ethers */ \"(rsc)/../../node_modules/ethers/lib.esm/transaction/address.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ethers */ \"(rsc)/../../node_modules/ethers/lib.esm/address/address.js\");\n\n/**\n * Creates an `ethers` - `signer` implementation by wrapping\n * a veramo agent with a key-manager that should be capable of `eth_signTransaction`\n *\n * @internal This is exported for convenience, not meant to be supported as part of the public API\n */\nclass AgentKmsSigner extends ethers__WEBPACK_IMPORTED_MODULE_0__.AbstractSigner {\n    context;\n    controllerKey;\n    provider;\n    constructor(controllerKey, context, provider) {\n        super(provider);\n        this.controllerKey = controllerKey;\n        this.context = context;\n        this.provider = provider || null;\n    }\n    async getAddress() {\n        // publicKeyHex is not available when using web3provider\n        if (this.controllerKey.meta?.account) {\n            return this.controllerKey.meta?.account;\n        }\n        return (0,ethers__WEBPACK_IMPORTED_MODULE_1__.computeAddress)('0x' + this.controllerKey.publicKeyHex);\n    }\n    async signTransaction(transaction) {\n        if (transaction.from != null) {\n            const thisAddress = await this.getAddress();\n            if ((0,ethers__WEBPACK_IMPORTED_MODULE_2__.getAddress)(transaction.from) !== thisAddress) {\n                throw new Error(`transaction from address mismatch ${transaction.from} != ${thisAddress}`);\n            }\n        }\n        console.info(\"********** call agent signTransaction **********\");\n        const signature = \"create signature\";\n        /*\n        const signature = await this.context.agent.keyManagerSign({\n          keyRef: this.controllerKey.kid,\n          data: transaction.unsignedSerialized,\n          algorithm: 'eth_signTransaction',\n          encoding: 'base16',\n        })\n        */\n        return signature;\n    }\n    async signTypedData(domain, types, value) {\n        console.info(\"********** call agent signTransaction **********\");\n        const signature = \"create signature\";\n        return signature;\n        /*\n        return this.context.agent.keyManagerSign({\n          keyRef: this.controllerKey.kid,\n          algorithm: 'eth_signTypedData',\n          data: data,\n        });\n        */\n    }\n    signMessage(message) {\n        throw new Error('not_implemented: signMessage() Method not implemented by AgentKmsSigner.');\n    }\n    connect(provider) {\n        if (!provider) {\n            throw new Error('provider must not be null');\n        }\n        return new AgentKmsSigner(this.controllerKey, this.context, provider);\n    }\n}\n//# sourceMappingURL=AgentKmsSigner.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BhZ2VudGljLXRydXN0L3ZlcmFtby1hZ2VudC1leHRlbnNpb24vZGlzdC91dGlscy9BZ2VudEttc1NpZ25lci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQXFFO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLDZCQUE2QixrREFBYztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxzREFBYztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixrREFBVTtBQUMxQixxRUFBcUUsa0JBQWtCLEtBQUssWUFBWTtBQUN4RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL2JhcmIvYWEvQXNzb2NpYXRlZEFjY291bnRzL25vZGVfbW9kdWxlcy9AYWdlbnRpYy10cnVzdC92ZXJhbW8tYWdlbnQtZXh0ZW5zaW9uL2Rpc3QvdXRpbHMvQWdlbnRLbXNTaWduZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZ2V0QWRkcmVzcywgY29tcHV0ZUFkZHJlc3MsIEFic3RyYWN0U2lnbmVyLCB9IGZyb20gJ2V0aGVycyc7XG4vKipcbiAqIENyZWF0ZXMgYW4gYGV0aGVyc2AgLSBgc2lnbmVyYCBpbXBsZW1lbnRhdGlvbiBieSB3cmFwcGluZ1xuICogYSB2ZXJhbW8gYWdlbnQgd2l0aCBhIGtleS1tYW5hZ2VyIHRoYXQgc2hvdWxkIGJlIGNhcGFibGUgb2YgYGV0aF9zaWduVHJhbnNhY3Rpb25gXG4gKlxuICogQGludGVybmFsIFRoaXMgaXMgZXhwb3J0ZWQgZm9yIGNvbnZlbmllbmNlLCBub3QgbWVhbnQgdG8gYmUgc3VwcG9ydGVkIGFzIHBhcnQgb2YgdGhlIHB1YmxpYyBBUElcbiAqL1xuZXhwb3J0IGNsYXNzIEFnZW50S21zU2lnbmVyIGV4dGVuZHMgQWJzdHJhY3RTaWduZXIge1xuICAgIGNvbnRleHQ7XG4gICAgY29udHJvbGxlcktleTtcbiAgICBwcm92aWRlcjtcbiAgICBjb25zdHJ1Y3Rvcihjb250cm9sbGVyS2V5LCBjb250ZXh0LCBwcm92aWRlcikge1xuICAgICAgICBzdXBlcihwcm92aWRlcik7XG4gICAgICAgIHRoaXMuY29udHJvbGxlcktleSA9IGNvbnRyb2xsZXJLZXk7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgIHRoaXMucHJvdmlkZXIgPSBwcm92aWRlciB8fCBudWxsO1xuICAgIH1cbiAgICBhc3luYyBnZXRBZGRyZXNzKCkge1xuICAgICAgICAvLyBwdWJsaWNLZXlIZXggaXMgbm90IGF2YWlsYWJsZSB3aGVuIHVzaW5nIHdlYjNwcm92aWRlclxuICAgICAgICBpZiAodGhpcy5jb250cm9sbGVyS2V5Lm1ldGE/LmFjY291bnQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnRyb2xsZXJLZXkubWV0YT8uYWNjb3VudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29tcHV0ZUFkZHJlc3MoJzB4JyArIHRoaXMuY29udHJvbGxlcktleS5wdWJsaWNLZXlIZXgpO1xuICAgIH1cbiAgICBhc3luYyBzaWduVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pIHtcbiAgICAgICAgaWYgKHRyYW5zYWN0aW9uLmZyb20gIT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgdGhpc0FkZHJlc3MgPSBhd2FpdCB0aGlzLmdldEFkZHJlc3MoKTtcbiAgICAgICAgICAgIGlmIChnZXRBZGRyZXNzKHRyYW5zYWN0aW9uLmZyb20pICE9PSB0aGlzQWRkcmVzcykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgdHJhbnNhY3Rpb24gZnJvbSBhZGRyZXNzIG1pc21hdGNoICR7dHJhbnNhY3Rpb24uZnJvbX0gIT0gJHt0aGlzQWRkcmVzc31gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zb2xlLmluZm8oXCIqKioqKioqKioqIGNhbGwgYWdlbnQgc2lnblRyYW5zYWN0aW9uICoqKioqKioqKipcIik7XG4gICAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IFwiY3JlYXRlIHNpZ25hdHVyZVwiO1xuICAgICAgICAvKlxuICAgICAgICBjb25zdCBzaWduYXR1cmUgPSBhd2FpdCB0aGlzLmNvbnRleHQuYWdlbnQua2V5TWFuYWdlclNpZ24oe1xuICAgICAgICAgIGtleVJlZjogdGhpcy5jb250cm9sbGVyS2V5LmtpZCxcbiAgICAgICAgICBkYXRhOiB0cmFuc2FjdGlvbi51bnNpZ25lZFNlcmlhbGl6ZWQsXG4gICAgICAgICAgYWxnb3JpdGhtOiAnZXRoX3NpZ25UcmFuc2FjdGlvbicsXG4gICAgICAgICAgZW5jb2Rpbmc6ICdiYXNlMTYnLFxuICAgICAgICB9KVxuICAgICAgICAqL1xuICAgICAgICByZXR1cm4gc2lnbmF0dXJlO1xuICAgIH1cbiAgICBhc3luYyBzaWduVHlwZWREYXRhKGRvbWFpbiwgdHlwZXMsIHZhbHVlKSB7XG4gICAgICAgIGNvbnNvbGUuaW5mbyhcIioqKioqKioqKiogY2FsbCBhZ2VudCBzaWduVHJhbnNhY3Rpb24gKioqKioqKioqKlwiKTtcbiAgICAgICAgY29uc3Qgc2lnbmF0dXJlID0gXCJjcmVhdGUgc2lnbmF0dXJlXCI7XG4gICAgICAgIHJldHVybiBzaWduYXR1cmU7XG4gICAgICAgIC8qXG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRleHQuYWdlbnQua2V5TWFuYWdlclNpZ24oe1xuICAgICAgICAgIGtleVJlZjogdGhpcy5jb250cm9sbGVyS2V5LmtpZCxcbiAgICAgICAgICBhbGdvcml0aG06ICdldGhfc2lnblR5cGVkRGF0YScsXG4gICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgfSk7XG4gICAgICAgICovXG4gICAgfVxuICAgIHNpZ25NZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdub3RfaW1wbGVtZW50ZWQ6IHNpZ25NZXNzYWdlKCkgTWV0aG9kIG5vdCBpbXBsZW1lbnRlZCBieSBBZ2VudEttc1NpZ25lci4nKTtcbiAgICB9XG4gICAgY29ubmVjdChwcm92aWRlcikge1xuICAgICAgICBpZiAoIXByb3ZpZGVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb3ZpZGVyIG11c3Qgbm90IGJlIG51bGwnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEFnZW50S21zU2lnbmVyKHRoaXMuY29udHJvbGxlcktleSwgdGhpcy5jb250ZXh0LCBwcm92aWRlcik7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QWdlbnRLbXNTaWduZXIuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@agentic-trust/veramo-agent-extension/dist/utils/AgentKmsSigner.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@agentic-trust/veramo-agent-extension/dist/utils/AgentResolver.js":
/*!********************************************************************************************!*\
  !*** ../../node_modules/@agentic-trust/veramo-agent-extension/dist/utils/AgentResolver.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getAgentResolver: () => (/* binding */ getAgentResolver)\n/* harmony export */ });\n/* harmony import */ var _IdentityRegistry_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./IdentityRegistry.js */ \"(rsc)/../../node_modules/@agentic-trust/veramo-agent-extension/dist/utils/IdentityRegistry.js\");\n\nconst DID_LD_JSON = 'application/did+ld+json';\nconst DID_JSON = 'application/did+json';\nfunction buildAgentDidDoc(did, agentId, agentDomain, agentAddress, chainId, registry) {\n    const controller = did;\n    const vmId = `${did}#aa-eth`;\n    const httpsOrigin = `https://${agentDomain}`;\n    const wssOrigin = `wss://${agentDomain}`;\n    return {\n        '@context': [\n            'https://www.w3.org/ns/did/v1',\n            'https://w3id.org/security/multikey/v1',\n        ],\n        id: did,\n        alsoKnownAs: [httpsOrigin],\n        verificationMethod: [\n            {\n                id: vmId,\n                type: 'EcdsaSecp256k1RecoveryMethod2020',\n                controller: did,\n                blockchainAccountId: `eip155:${chainId}:${agentAddress}`,\n                ethereumAddress: agentAddress,\n                accept: ['EIP-1271', 'EIP-712'],\n                erc8004: {\n                    agentId,\n                    registry,\n                    chainId,\n                },\n            },\n        ],\n        authentication: [vmId],\n        assertionMethod: [vmId],\n        capabilityInvocation: [vmId],\n        capabilityDelegation: [vmId],\n        service: [\n            {\n                id: '#mcp-ws',\n                type: 'MCP',\n                serviceEndpoint: {\n                    uri: `${wssOrigin}/.well-known/mcp`,\n                    protocol: 'model-context-protocol',\n                    version: '0.1',\n                    transport: 'websocket',\n                    accept: ['application/json'],\n                    auth: ['did-jws', 'eip-1271'],\n                },\n            },\n            {\n                id: '#ens',\n                type: 'ENSService',\n                serviceEndpoint: {\n                    // name can be set via reverse ENS lookup of agentAddress if available\n                    records: {\n                        addr: agentAddress,\n                        url: httpsOrigin,\n                        'org.did': did,\n                    },\n                    auth: ['eip-1271', 'eip-712'],\n                },\n            },\n            {\n                id: '#linked-domains',\n                type: 'LinkedDomains',\n                serviceEndpoint: {\n                    origins: [httpsOrigin],\n                },\n            },\n            {\n                id: '#agent-card',\n                type: 'AgentCard',\n                serviceEndpoint: `${httpsOrigin}/.well-known/agent-card.json`,\n            },\n            {\n                id: '#agent-interface',\n                type: 'AgentInterface',\n                serviceEndpoint: `${httpsOrigin}/.well-known/a2a`,\n            },\n            {\n                id: '#reputation',\n                type: 'ReputationRegistry',\n                serviceEndpoint: {\n                    chainId,\n                    contract: '0xREPUT4TI0NADDRE55',\n                    methods: ['acceptFeedback'],\n                },\n            },\n        ],\n        agent: {\n            standard: 'ERC-8004',\n            domain: agentDomain,\n            address: agentAddress,\n        },\n    };\n}\nfunction toDidDoc(did, agentId) {\n    return buildAgentDidDoc(did, agentId, 'unknown-domain', '0x0000000000000000000000000000000000000000', 0, '0x0000000000000000000000000000000000000000');\n}\nfunction getAgentResolver() {\n    return {\n        agent: async (did, parsed, r, options) => {\n            console.info(\">>>>>>>> inside agent resolver: did: \", did);\n            const contentType = options.accept || DID_JSON;\n            const response = {\n                didResolutionMetadata: { contentType },\n                didDocument: null,\n                didDocumentMetadata: {},\n            };\n            try {\n                // Lookup agent info from ERC-8004 Identity Registry\n                const REGISTRY_ADDRESS = '0xD3Ef59f3Bbc1d766E3Ba463Be134B5eB29e907A0';\n                const agentId = parsed.id;\n                const info = await (0,_IdentityRegistry_js__WEBPACK_IMPORTED_MODULE_0__.getRegistryAgent)(REGISTRY_ADDRESS, BigInt(agentId));\n                const agentDomain = info.agentDomain;\n                const agentAddress = info.agentAddress;\n                // Default to Sepolia if your registry is on Sepolia; adapt as needed\n                const chainId = 11155111;\n                const doc = buildAgentDidDoc(did, agentId, agentDomain, agentAddress, chainId, REGISTRY_ADDRESS);\n                if (contentType === DID_LD_JSON) {\n                    response.didDocument = doc;\n                }\n                else if (contentType === DID_JSON) {\n                    const { ['@context']: _ctx, ...jsonDoc } = doc;\n                    response.didDocument = jsonDoc;\n                }\n                else {\n                    delete response.didResolutionMetadata.contentType;\n                    response.didResolutionMetadata.error = 'representationNotSupported';\n                }\n            }\n            catch (e) {\n                response.didResolutionMetadata.error = 'invalidDid';\n                response.didResolutionMetadata.message = e.message;\n            }\n            console.info(\">>>>>>>> inside agent resolver: response: \", JSON.stringify(response));\n            return response;\n        },\n    };\n}\n//# sourceMappingURL=AgentResolver.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BhZ2VudGljLXRydXN0L3ZlcmFtby1hZ2VudC1leHRlbnNpb24vZGlzdC91dGlscy9BZ2VudFJlc29sdmVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLElBQUk7QUFDeEIsbUNBQW1DLFlBQVk7QUFDL0MsK0JBQStCLFlBQVk7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLFFBQVEsR0FBRyxhQUFhO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsVUFBVTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxZQUFZO0FBQ2hELGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsWUFBWTtBQUNoRCxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxhQUFhO0FBQ3REO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsc0VBQWdCO0FBQ25EO0FBQ0E7QUFDQSxzRUFBc0U7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGlDQUFpQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL2JhcmIvYWEvQXNzb2NpYXRlZEFjY291bnRzL25vZGVfbW9kdWxlcy9AYWdlbnRpYy10cnVzdC92ZXJhbW8tYWdlbnQtZXh0ZW5zaW9uL2Rpc3QvdXRpbHMvQWdlbnRSZXNvbHZlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBnZXRSZWdpc3RyeUFnZW50IH0gZnJvbSAnLi9JZGVudGl0eVJlZ2lzdHJ5LmpzJztcbmNvbnN0IERJRF9MRF9KU09OID0gJ2FwcGxpY2F0aW9uL2RpZCtsZCtqc29uJztcbmNvbnN0IERJRF9KU09OID0gJ2FwcGxpY2F0aW9uL2RpZCtqc29uJztcbmZ1bmN0aW9uIGJ1aWxkQWdlbnREaWREb2MoZGlkLCBhZ2VudElkLCBhZ2VudERvbWFpbiwgYWdlbnRBZGRyZXNzLCBjaGFpbklkLCByZWdpc3RyeSkge1xuICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBkaWQ7XG4gICAgY29uc3Qgdm1JZCA9IGAke2RpZH0jYWEtZXRoYDtcbiAgICBjb25zdCBodHRwc09yaWdpbiA9IGBodHRwczovLyR7YWdlbnREb21haW59YDtcbiAgICBjb25zdCB3c3NPcmlnaW4gPSBgd3NzOi8vJHthZ2VudERvbWFpbn1gO1xuICAgIHJldHVybiB7XG4gICAgICAgICdAY29udGV4dCc6IFtcbiAgICAgICAgICAgICdodHRwczovL3d3dy53My5vcmcvbnMvZGlkL3YxJyxcbiAgICAgICAgICAgICdodHRwczovL3czaWQub3JnL3NlY3VyaXR5L211bHRpa2V5L3YxJyxcbiAgICAgICAgXSxcbiAgICAgICAgaWQ6IGRpZCxcbiAgICAgICAgYWxzb0tub3duQXM6IFtodHRwc09yaWdpbl0sXG4gICAgICAgIHZlcmlmaWNhdGlvbk1ldGhvZDogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlkOiB2bUlkLFxuICAgICAgICAgICAgICAgIHR5cGU6ICdFY2RzYVNlY3AyNTZrMVJlY292ZXJ5TWV0aG9kMjAyMCcsXG4gICAgICAgICAgICAgICAgY29udHJvbGxlcjogZGlkLFxuICAgICAgICAgICAgICAgIGJsb2NrY2hhaW5BY2NvdW50SWQ6IGBlaXAxNTU6JHtjaGFpbklkfToke2FnZW50QWRkcmVzc31gLFxuICAgICAgICAgICAgICAgIGV0aGVyZXVtQWRkcmVzczogYWdlbnRBZGRyZXNzLFxuICAgICAgICAgICAgICAgIGFjY2VwdDogWydFSVAtMTI3MScsICdFSVAtNzEyJ10sXG4gICAgICAgICAgICAgICAgZXJjODAwNDoge1xuICAgICAgICAgICAgICAgICAgICBhZ2VudElkLFxuICAgICAgICAgICAgICAgICAgICByZWdpc3RyeSxcbiAgICAgICAgICAgICAgICAgICAgY2hhaW5JZCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgICAgYXV0aGVudGljYXRpb246IFt2bUlkXSxcbiAgICAgICAgYXNzZXJ0aW9uTWV0aG9kOiBbdm1JZF0sXG4gICAgICAgIGNhcGFiaWxpdHlJbnZvY2F0aW9uOiBbdm1JZF0sXG4gICAgICAgIGNhcGFiaWxpdHlEZWxlZ2F0aW9uOiBbdm1JZF0sXG4gICAgICAgIHNlcnZpY2U6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZDogJyNtY3Atd3MnLFxuICAgICAgICAgICAgICAgIHR5cGU6ICdNQ1AnLFxuICAgICAgICAgICAgICAgIHNlcnZpY2VFbmRwb2ludDoge1xuICAgICAgICAgICAgICAgICAgICB1cmk6IGAke3dzc09yaWdpbn0vLndlbGwta25vd24vbWNwYCxcbiAgICAgICAgICAgICAgICAgICAgcHJvdG9jb2w6ICdtb2RlbC1jb250ZXh0LXByb3RvY29sJyxcbiAgICAgICAgICAgICAgICAgICAgdmVyc2lvbjogJzAuMScsXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zcG9ydDogJ3dlYnNvY2tldCcsXG4gICAgICAgICAgICAgICAgICAgIGFjY2VwdDogWydhcHBsaWNhdGlvbi9qc29uJ10sXG4gICAgICAgICAgICAgICAgICAgIGF1dGg6IFsnZGlkLWp3cycsICdlaXAtMTI3MSddLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlkOiAnI2VucycsXG4gICAgICAgICAgICAgICAgdHlwZTogJ0VOU1NlcnZpY2UnLFxuICAgICAgICAgICAgICAgIHNlcnZpY2VFbmRwb2ludDoge1xuICAgICAgICAgICAgICAgICAgICAvLyBuYW1lIGNhbiBiZSBzZXQgdmlhIHJldmVyc2UgRU5TIGxvb2t1cCBvZiBhZ2VudEFkZHJlc3MgaWYgYXZhaWxhYmxlXG4gICAgICAgICAgICAgICAgICAgIHJlY29yZHM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZHI6IGFnZW50QWRkcmVzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybDogaHR0cHNPcmlnaW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAnb3JnLmRpZCc6IGRpZCxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgYXV0aDogWydlaXAtMTI3MScsICdlaXAtNzEyJ10sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWQ6ICcjbGlua2VkLWRvbWFpbnMnLFxuICAgICAgICAgICAgICAgIHR5cGU6ICdMaW5rZWREb21haW5zJyxcbiAgICAgICAgICAgICAgICBzZXJ2aWNlRW5kcG9pbnQ6IHtcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luczogW2h0dHBzT3JpZ2luXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZDogJyNhZ2VudC1jYXJkJyxcbiAgICAgICAgICAgICAgICB0eXBlOiAnQWdlbnRDYXJkJyxcbiAgICAgICAgICAgICAgICBzZXJ2aWNlRW5kcG9pbnQ6IGAke2h0dHBzT3JpZ2lufS8ud2VsbC1rbm93bi9hZ2VudC1jYXJkLmpzb25gLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZDogJyNhZ2VudC1pbnRlcmZhY2UnLFxuICAgICAgICAgICAgICAgIHR5cGU6ICdBZ2VudEludGVyZmFjZScsXG4gICAgICAgICAgICAgICAgc2VydmljZUVuZHBvaW50OiBgJHtodHRwc09yaWdpbn0vLndlbGwta25vd24vYTJhYCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWQ6ICcjcmVwdXRhdGlvbicsXG4gICAgICAgICAgICAgICAgdHlwZTogJ1JlcHV0YXRpb25SZWdpc3RyeScsXG4gICAgICAgICAgICAgICAgc2VydmljZUVuZHBvaW50OiB7XG4gICAgICAgICAgICAgICAgICAgIGNoYWluSWQsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRyYWN0OiAnMHhSRVBVVDRUSTBOQUREUkU1NScsXG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZHM6IFsnYWNjZXB0RmVlZGJhY2snXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgICAgYWdlbnQ6IHtcbiAgICAgICAgICAgIHN0YW5kYXJkOiAnRVJDLTgwMDQnLFxuICAgICAgICAgICAgZG9tYWluOiBhZ2VudERvbWFpbixcbiAgICAgICAgICAgIGFkZHJlc3M6IGFnZW50QWRkcmVzcyxcbiAgICAgICAgfSxcbiAgICB9O1xufVxuZnVuY3Rpb24gdG9EaWREb2MoZGlkLCBhZ2VudElkKSB7XG4gICAgcmV0dXJuIGJ1aWxkQWdlbnREaWREb2MoZGlkLCBhZ2VudElkLCAndW5rbm93bi1kb21haW4nLCAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJywgMCwgJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldEFnZW50UmVzb2x2ZXIoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYWdlbnQ6IGFzeW5jIChkaWQsIHBhcnNlZCwgciwgb3B0aW9ucykgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5pbmZvKFwiPj4+Pj4+Pj4gaW5zaWRlIGFnZW50IHJlc29sdmVyOiBkaWQ6IFwiLCBkaWQpO1xuICAgICAgICAgICAgY29uc3QgY29udGVudFR5cGUgPSBvcHRpb25zLmFjY2VwdCB8fCBESURfSlNPTjtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgIGRpZFJlc29sdXRpb25NZXRhZGF0YTogeyBjb250ZW50VHlwZSB9LFxuICAgICAgICAgICAgICAgIGRpZERvY3VtZW50OiBudWxsLFxuICAgICAgICAgICAgICAgIGRpZERvY3VtZW50TWV0YWRhdGE6IHt9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgLy8gTG9va3VwIGFnZW50IGluZm8gZnJvbSBFUkMtODAwNCBJZGVudGl0eSBSZWdpc3RyeVxuICAgICAgICAgICAgICAgIGNvbnN0IFJFR0lTVFJZX0FERFJFU1MgPSAnMHhEM0VmNTlmM0JiYzFkNzY2RTNCYTQ2M0JlMTM0QjVlQjI5ZTkwN0EwJztcbiAgICAgICAgICAgICAgICBjb25zdCBhZ2VudElkID0gcGFyc2VkLmlkO1xuICAgICAgICAgICAgICAgIGNvbnN0IGluZm8gPSBhd2FpdCBnZXRSZWdpc3RyeUFnZW50KFJFR0lTVFJZX0FERFJFU1MsIEJpZ0ludChhZ2VudElkKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgYWdlbnREb21haW4gPSBpbmZvLmFnZW50RG9tYWluO1xuICAgICAgICAgICAgICAgIGNvbnN0IGFnZW50QWRkcmVzcyA9IGluZm8uYWdlbnRBZGRyZXNzO1xuICAgICAgICAgICAgICAgIC8vIERlZmF1bHQgdG8gU2Vwb2xpYSBpZiB5b3VyIHJlZ2lzdHJ5IGlzIG9uIFNlcG9saWE7IGFkYXB0IGFzIG5lZWRlZFxuICAgICAgICAgICAgICAgIGNvbnN0IGNoYWluSWQgPSAxMTE1NTExMTtcbiAgICAgICAgICAgICAgICBjb25zdCBkb2MgPSBidWlsZEFnZW50RGlkRG9jKGRpZCwgYWdlbnRJZCwgYWdlbnREb21haW4sIGFnZW50QWRkcmVzcywgY2hhaW5JZCwgUkVHSVNUUllfQUREUkVTUyk7XG4gICAgICAgICAgICAgICAgaWYgKGNvbnRlbnRUeXBlID09PSBESURfTERfSlNPTikge1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5kaWREb2N1bWVudCA9IGRvYztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY29udGVudFR5cGUgPT09IERJRF9KU09OKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgWydAY29udGV4dCddOiBfY3R4LCAuLi5qc29uRG9jIH0gPSBkb2M7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLmRpZERvY3VtZW50ID0ganNvbkRvYztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSByZXNwb25zZS5kaWRSZXNvbHV0aW9uTWV0YWRhdGEuY29udGVudFR5cGU7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLmRpZFJlc29sdXRpb25NZXRhZGF0YS5lcnJvciA9ICdyZXByZXNlbnRhdGlvbk5vdFN1cHBvcnRlZCc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICByZXNwb25zZS5kaWRSZXNvbHV0aW9uTWV0YWRhdGEuZXJyb3IgPSAnaW52YWxpZERpZCc7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2UuZGlkUmVzb2x1dGlvbk1ldGFkYXRhLm1lc3NhZ2UgPSBlLm1lc3NhZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zb2xlLmluZm8oXCI+Pj4+Pj4+PiBpbnNpZGUgYWdlbnQgcmVzb2x2ZXI6IHJlc3BvbnNlOiBcIiwgSlNPTi5zdHJpbmdpZnkocmVzcG9uc2UpKTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QWdlbnRSZXNvbHZlci5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@agentic-trust/veramo-agent-extension/dist/utils/AgentResolver.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@agentic-trust/veramo-agent-extension/dist/utils/AgentTypes.js":
/*!*****************************************************************************************!*\
  !*** ../../node_modules/@agentic-trust/veramo-agent-extension/dist/utils/AgentTypes.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n\n//# sourceMappingURL=AgentTypes.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BhZ2VudGljLXRydXN0L3ZlcmFtby1hZ2VudC1leHRlbnNpb24vZGlzdC91dGlscy9BZ2VudFR5cGVzLmpzIiwibWFwcGluZ3MiOiI7QUFBVTtBQUNWIiwic291cmNlcyI6WyIvaG9tZS9iYXJiL2FhL0Fzc29jaWF0ZWRBY2NvdW50cy9ub2RlX21vZHVsZXMvQGFnZW50aWMtdHJ1c3QvdmVyYW1vLWFnZW50LWV4dGVuc2lvbi9kaXN0L3V0aWxzL0FnZW50VHlwZXMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHt9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QWdlbnRUeXBlcy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@agentic-trust/veramo-agent-extension/dist/utils/AgentTypes.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@agentic-trust/veramo-agent-extension/dist/utils/ICredentialEIP1271.js":
/*!*************************************************************************************************!*\
  !*** ../../node_modules/@agentic-trust/veramo-agent-extension/dist/utils/ICredentialEIP1271.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n\n//# sourceMappingURL=ICredentialEIP1271.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BhZ2VudGljLXRydXN0L3ZlcmFtby1hZ2VudC1leHRlbnNpb24vZGlzdC91dGlscy9JQ3JlZGVudGlhbEVJUDEyNzEuanMiLCJtYXBwaW5ncyI6IjtBQUFVO0FBQ1YiLCJzb3VyY2VzIjpbIi9ob21lL2JhcmIvYWEvQXNzb2NpYXRlZEFjY291bnRzL25vZGVfbW9kdWxlcy9AYWdlbnRpYy10cnVzdC92ZXJhbW8tYWdlbnQtZXh0ZW5zaW9uL2Rpc3QvdXRpbHMvSUNyZWRlbnRpYWxFSVAxMjcxLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB7fTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUlDcmVkZW50aWFsRUlQMTI3MS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@agentic-trust/veramo-agent-extension/dist/utils/ICredentialEIP1271.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@agentic-trust/veramo-agent-extension/dist/utils/IdentityRegistry.js":
/*!***********************************************************************************************!*\
  !*** ../../node_modules/@agentic-trust/veramo-agent-extension/dist/utils/IdentityRegistry.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getPublicClient: () => (/* binding */ getPublicClient),\n/* harmony export */   getRegistryAgent: () => (/* binding */ getRegistryAgent),\n/* harmony export */   identityRegistryAbi: () => (/* binding */ identityRegistryAbi)\n/* harmony export */ });\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! viem */ \"(rsc)/../../node_modules/viem/_esm/clients/createPublicClient.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! viem */ \"(rsc)/../../node_modules/viem/_esm/clients/transports/http.js\");\n/* harmony import */ var viem_chains__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! viem/chains */ \"(rsc)/../../node_modules/viem/_esm/chains/definitions/sepolia.js\");\n\n\nconst identityRegistryAbi = [\n    {\n        type: 'function',\n        name: 'getAgent',\n        stateMutability: 'view',\n        inputs: [{ name: 'agentId', type: 'uint256' }],\n        outputs: [\n            {\n                name: 'agentInfo',\n                type: 'tuple',\n                components: [\n                    { name: 'agentId', type: 'uint256' },\n                    { name: 'agentDomain', type: 'string' },\n                    { name: 'agentAddress', type: 'address' },\n                ],\n            },\n        ],\n    },\n];\nfunction getPublicClient() {\n    return (0,viem__WEBPACK_IMPORTED_MODULE_0__.createPublicClient)({\n        chain: viem_chains__WEBPACK_IMPORTED_MODULE_1__.sepolia,\n        transport: (0,viem__WEBPACK_IMPORTED_MODULE_2__.http)(),\n    });\n}\nasync function getRegistryAgent(registryAddress, agentId) {\n    const publicClient = getPublicClient();\n    const res = await publicClient.readContract({\n        address: registryAddress,\n        abi: identityRegistryAbi,\n        functionName: 'getAgent',\n        args: [agentId],\n    });\n    return {\n        agentId: BigInt(res.agentId ?? agentId),\n        agentDomain: res.agentDomain,\n        agentAddress: res.agentAddress,\n    };\n}\n//# sourceMappingURL=IdentityRegistry.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BhZ2VudGljLXRydXN0L3ZlcmFtby1hZ2VudC1leHRlbnNpb24vZGlzdC91dGlscy9JZGVudGl0eVJlZ2lzdHJ5LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFnRDtBQUNWO0FBQy9CO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsa0NBQWtDO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isa0NBQWtDO0FBQ3hELHNCQUFzQixxQ0FBcUM7QUFDM0Qsc0JBQXNCLHVDQUF1QztBQUM3RDtBQUNBLGFBQWE7QUFDYjtBQUNBLEtBQUs7QUFDTDtBQUNPO0FBQ1AsV0FBVyx3REFBa0I7QUFDN0IsZUFBZSxnREFBTztBQUN0QixtQkFBbUIsMENBQUk7QUFDdkIsS0FBSztBQUNMO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL2JhcmIvYWEvQXNzb2NpYXRlZEFjY291bnRzL25vZGVfbW9kdWxlcy9AYWdlbnRpYy10cnVzdC92ZXJhbW8tYWdlbnQtZXh0ZW5zaW9uL2Rpc3QvdXRpbHMvSWRlbnRpdHlSZWdpc3RyeS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjcmVhdGVQdWJsaWNDbGllbnQsIGh0dHAgfSBmcm9tICd2aWVtJztcbmltcG9ydCB7IHNlcG9saWEgfSBmcm9tICd2aWVtL2NoYWlucyc7XG5leHBvcnQgY29uc3QgaWRlbnRpdHlSZWdpc3RyeUFiaSA9IFtcbiAgICB7XG4gICAgICAgIHR5cGU6ICdmdW5jdGlvbicsXG4gICAgICAgIG5hbWU6ICdnZXRBZ2VudCcsXG4gICAgICAgIHN0YXRlTXV0YWJpbGl0eTogJ3ZpZXcnLFxuICAgICAgICBpbnB1dHM6IFt7IG5hbWU6ICdhZ2VudElkJywgdHlwZTogJ3VpbnQyNTYnIH1dLFxuICAgICAgICBvdXRwdXRzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTogJ2FnZW50SW5mbycsXG4gICAgICAgICAgICAgICAgdHlwZTogJ3R1cGxlJyxcbiAgICAgICAgICAgICAgICBjb21wb25lbnRzOiBbXG4gICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ2FnZW50SWQnLCB0eXBlOiAndWludDI1NicgfSxcbiAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAnYWdlbnREb21haW4nLCB0eXBlOiAnc3RyaW5nJyB9LFxuICAgICAgICAgICAgICAgICAgICB7IG5hbWU6ICdhZ2VudEFkZHJlc3MnLCB0eXBlOiAnYWRkcmVzcycgfSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICB9LFxuXTtcbmV4cG9ydCBmdW5jdGlvbiBnZXRQdWJsaWNDbGllbnQoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZVB1YmxpY0NsaWVudCh7XG4gICAgICAgIGNoYWluOiBzZXBvbGlhLFxuICAgICAgICB0cmFuc3BvcnQ6IGh0dHAoKSxcbiAgICB9KTtcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRSZWdpc3RyeUFnZW50KHJlZ2lzdHJ5QWRkcmVzcywgYWdlbnRJZCkge1xuICAgIGNvbnN0IHB1YmxpY0NsaWVudCA9IGdldFB1YmxpY0NsaWVudCgpO1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHB1YmxpY0NsaWVudC5yZWFkQ29udHJhY3Qoe1xuICAgICAgICBhZGRyZXNzOiByZWdpc3RyeUFkZHJlc3MsXG4gICAgICAgIGFiaTogaWRlbnRpdHlSZWdpc3RyeUFiaSxcbiAgICAgICAgZnVuY3Rpb25OYW1lOiAnZ2V0QWdlbnQnLFxuICAgICAgICBhcmdzOiBbYWdlbnRJZF0sXG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYWdlbnRJZDogQmlnSW50KHJlcy5hZ2VudElkID8/IGFnZW50SWQpLFxuICAgICAgICBhZ2VudERvbWFpbjogcmVzLmFnZW50RG9tYWluLFxuICAgICAgICBhZ2VudEFkZHJlc3M6IHJlcy5hZ2VudEFkZHJlc3MsXG4gICAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUlkZW50aXR5UmVnaXN0cnkuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@agentic-trust/veramo-agent-extension/dist/utils/IdentityRegistry.js\n");

/***/ })

};
;