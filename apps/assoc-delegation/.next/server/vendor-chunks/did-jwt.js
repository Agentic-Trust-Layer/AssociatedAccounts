"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/did-jwt";
exports.ids = ["vendor-chunks/did-jwt"];
exports.modules = {

/***/ "(rsc)/../../node_modules/did-jwt/lib/index.module.js":
/*!******************************************************!*\
  !*** ../../node_modules/did-jwt/lib/index.module.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ES256KSigner: () => (/* binding */ ES256KSigner),\n/* harmony export */   ES256Signer: () => (/* binding */ ES256Signer),\n/* harmony export */   EdDSASigner: () => (/* binding */ EdDSASigner),\n/* harmony export */   EllipticSigner: () => (/* binding */ EllipticSigner),\n/* harmony export */   JWT_ERROR: () => (/* binding */ JWT_ERROR),\n/* harmony export */   NaclSigner: () => (/* binding */ NaclSigner),\n/* harmony export */   SimpleSigner: () => (/* binding */ SimpleSigner),\n/* harmony export */   base58ToBytes: () => (/* binding */ base58ToBytes),\n/* harmony export */   base64ToBytes: () => (/* binding */ base64ToBytes),\n/* harmony export */   bytesToBase58: () => (/* binding */ bytesToBase58),\n/* harmony export */   bytesToBase64url: () => (/* binding */ bytesToBase64url),\n/* harmony export */   bytesToHex: () => (/* binding */ bytesToHex),\n/* harmony export */   bytesToMultibase: () => (/* binding */ bytesToMultibase),\n/* harmony export */   computeX25519Ecdh1PUv3Kek: () => (/* binding */ computeX25519Ecdh1PUv3Kek),\n/* harmony export */   computeX25519EcdhEsKek: () => (/* binding */ computeX25519EcdhEsKek),\n/* harmony export */   concatKDF: () => (/* binding */ concatKDF),\n/* harmony export */   createAnonDecrypter: () => (/* binding */ createAnonDecrypter),\n/* harmony export */   createAnonEncrypter: () => (/* binding */ createAnonEncrypter),\n/* harmony export */   createAuthDecrypter: () => (/* binding */ createAuthDecrypter),\n/* harmony export */   createAuthEncrypter: () => (/* binding */ createAuthEncrypter),\n/* harmony export */   createFullEncrypter: () => (/* binding */ createFullEncrypter),\n/* harmony export */   createJWE: () => (/* binding */ createJWE),\n/* harmony export */   createJWS: () => (/* binding */ createJWS),\n/* harmony export */   createJWT: () => (/* binding */ createJWT),\n/* harmony export */   createMultisignatureJWT: () => (/* binding */ createMultisignatureJWT),\n/* harmony export */   createX25519ECDH: () => (/* binding */ createX25519ECDH),\n/* harmony export */   createX25519Ecdh1PUv3Kek: () => (/* binding */ createX25519Ecdh1PUv3Kek),\n/* harmony export */   createX25519EcdhEsKek: () => (/* binding */ createX25519EcdhEsKek),\n/* harmony export */   decodeJWT: () => (/* binding */ decodeJWT),\n/* harmony export */   decryptJWE: () => (/* binding */ decryptJWE),\n/* harmony export */   extractPublicKeyBytes: () => (/* binding */ extractPublicKeyBytes),\n/* harmony export */   genX25519EphemeralKeyPair: () => (/* binding */ genX25519EphemeralKeyPair),\n/* harmony export */   hexToBytes: () => (/* binding */ hexToBytes),\n/* harmony export */   multibaseToBytes: () => (/* binding */ multibaseToBytes),\n/* harmony export */   resolveX25519Encrypters: () => (/* binding */ resolveX25519Encrypters),\n/* harmony export */   supportedCodecs: () => (/* binding */ supportedCodecs),\n/* harmony export */   toEthereumAddress: () => (/* binding */ toEthereumAddress),\n/* harmony export */   verifyJWS: () => (/* binding */ verifyJWS),\n/* harmony export */   verifyJWT: () => (/* binding */ verifyJWT),\n/* harmony export */   x25519Decrypter: () => (/* binding */ x25519Decrypter),\n/* harmony export */   x25519Encrypter: () => (/* binding */ x25519Encrypter),\n/* harmony export */   xc20pAuthDecrypterEcdh1PuV3x25519WithXc20PkwV2: () => (/* binding */ xc20pAuthDecrypterEcdh1PuV3x25519WithXc20PkwV2),\n/* harmony export */   xc20pAuthEncrypterEcdh1PuV3x25519WithXc20PkwV2: () => (/* binding */ xc20pAuthEncrypterEcdh1PuV3x25519WithXc20PkwV2),\n/* harmony export */   xc20pDirDecrypter: () => (/* binding */ xc20pDirDecrypter),\n/* harmony export */   xc20pDirEncrypter: () => (/* binding */ xc20pDirEncrypter)\n/* harmony export */ });\n/* harmony import */ var uint8arrays__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! uint8arrays */ \"(rsc)/../../node_modules/did-jwt/node_modules/uint8arrays/esm/src/index.js\");\n/* harmony import */ var _noble_curves_ed25519__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @noble/curves/ed25519 */ \"(rsc)/../../node_modules/@noble/curves/esm/ed25519.js\");\n/* harmony import */ var multiformats__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! multiformats */ \"(rsc)/../../node_modules/did-jwt/node_modules/multiformats/esm/src/index.js\");\n/* harmony import */ var multibase__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! multibase */ \"(rsc)/../../node_modules/multibase/src/index.js\");\n/* harmony import */ var _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @noble/curves/secp256k1 */ \"(rsc)/../../node_modules/@noble/curves/esm/secp256k1.js\");\n/* harmony import */ var _noble_curves_p256__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @noble/curves/p256 */ \"(rsc)/../../node_modules/@noble/curves/esm/p256.js\");\n/* harmony import */ var _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @noble/hashes/sha256 */ \"(rsc)/../../node_modules/@noble/hashes/esm/sha256.js\");\n/* harmony import */ var _noble_hashes_ripemd160__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @noble/hashes/ripemd160 */ \"(rsc)/../../node_modules/@noble/hashes/esm/ripemd160.js\");\n/* harmony import */ var _noble_hashes_sha3__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @noble/hashes/sha3 */ \"(rsc)/../../node_modules/@noble/hashes/esm/sha3.js\");\n/* harmony import */ var canonicalize__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! canonicalize */ \"(rsc)/../../node_modules/canonicalize/lib/canonicalize.js\");\n/* harmony import */ var did_resolver__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! did-resolver */ \"(rsc)/../../node_modules/did-resolver/lib/resolver.module.js\");\n/* harmony import */ var _scure_base__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @scure/base */ \"(rsc)/../../node_modules/did-jwt/node_modules/@scure/base/index.js\");\n/* harmony import */ var _noble_ciphers_chacha__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @noble/ciphers/chacha */ \"(rsc)/../../node_modules/@noble/ciphers/esm/chacha.js\");\n/* harmony import */ var _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @noble/hashes/utils */ \"(rsc)/../../node_modules/@noble/hashes/esm/utils.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst u8a = {\n  toString: uint8arrays__WEBPACK_IMPORTED_MODULE_0__.toString,\n  fromString: uint8arrays__WEBPACK_IMPORTED_MODULE_0__.fromString,\n  concat: uint8arrays__WEBPACK_IMPORTED_MODULE_0__.concat\n};\nfunction bytesToBase64url(b) {\n  return u8a.toString(b, 'base64url');\n}\nfunction base64ToBytes(s) {\n  const inputBase64Url = s.replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=/g, '');\n  return u8a.fromString(inputBase64Url, 'base64url');\n}\nfunction base58ToBytes(s) {\n  return u8a.fromString(s, 'base58btc');\n}\nfunction bytesToBase58(b) {\n  return u8a.toString(b, 'base58btc');\n}\nconst SUPPORTED_PUBLIC_KEY_TYPES = {\n  ES256: ['JsonWebKey2020', 'Multikey', 'EcdsaSecp256r1VerificationKey2019'],\n  ES256K: ['EcdsaSecp256k1VerificationKey2019',\n  /**\n   * Equivalent to EcdsaSecp256k1VerificationKey2019 when key is an ethereumAddress\n   */\n  'EcdsaSecp256k1RecoveryMethod2020',\n  /**\n   * @deprecated, supported for backward compatibility. Equivalent to EcdsaSecp256k1VerificationKey2019 when key is\n   *   not an ethereumAddress\n   */\n  'Secp256k1VerificationKey2018',\n  /**\n   * @deprecated, supported for backward compatibility. Equivalent to EcdsaSecp256k1VerificationKey2019 when key is\n   *   not an ethereumAddress\n   */\n  'Secp256k1SignatureVerificationKey2018',\n  /**\n   * @deprecated, supported for backward compatibility. Equivalent to EcdsaSecp256k1VerificationKey2019 when key is\n   *   not an ethereumAddress\n   */\n  'EcdsaPublicKeySecp256k1',\n  /**\n   *  TODO - support R1 key as well\n   *   'ConditionalProof2022',\n   */\n  'JsonWebKey2020', 'Multikey'],\n  'ES256K-R': ['EcdsaSecp256k1VerificationKey2019',\n  /**\n   * Equivalent to EcdsaSecp256k1VerificationKey2019 when key is an ethereumAddress\n   */\n  'EcdsaSecp256k1RecoveryMethod2020',\n  /**\n   * @deprecated, supported for backward compatibility. Equivalent to EcdsaSecp256k1VerificationKey2019 when key is\n   *   not an ethereumAddress\n   */\n  'Secp256k1VerificationKey2018',\n  /**\n   * @deprecated, supported for backward compatibility. Equivalent to EcdsaSecp256k1VerificationKey2019 when key is\n   *   not an ethereumAddress\n   */\n  'Secp256k1SignatureVerificationKey2018',\n  /**\n   * @deprecated, supported for backward compatibility. Equivalent to EcdsaSecp256k1VerificationKey2019 when key is\n   *   not an ethereumAddress\n   */\n  'EcdsaPublicKeySecp256k1', 'ConditionalProof2022', 'JsonWebKey2020', 'Multikey'],\n  Ed25519: ['ED25519SignatureVerification', 'Ed25519VerificationKey2018', 'Ed25519VerificationKey2020', 'JsonWebKey2020', 'Multikey'],\n  EdDSA: ['ED25519SignatureVerification', 'Ed25519VerificationKey2018', 'Ed25519VerificationKey2020', 'JsonWebKey2020', 'Multikey']\n};\nconst VM_TO_KEY_TYPE = {\n  Secp256k1SignatureVerificationKey2018: 'Secp256k1',\n  Secp256k1VerificationKey2018: 'Secp256k1',\n  EcdsaSecp256k1VerificationKey2019: 'Secp256k1',\n  EcdsaPublicKeySecp256k1: 'Secp256k1',\n  EcdsaSecp256k1RecoveryMethod2020: 'Secp256k1',\n  EcdsaSecp256r1VerificationKey2019: 'P-256',\n  Ed25519VerificationKey2018: 'Ed25519',\n  Ed25519VerificationKey2020: 'Ed25519',\n  ED25519SignatureVerification: 'Ed25519',\n  X25519KeyAgreementKey2019: 'X25519',\n  X25519KeyAgreementKey2020: 'X25519',\n  ConditionalProof2022: undefined,\n  JsonWebKey2020: undefined,\n  // key type must be specified in the JWK\n  Multikey: undefined // key type must be extracted from the multicodec\n\n}; // this is from the multicodec table https://github.com/multiformats/multicodec/blob/master/table.csv\n\nconst supportedCodecs = {\n  'ed25519-pub': 0xed,\n  'x25519-pub': 0xec,\n  'secp256k1-pub': 0xe7,\n  'bls12_381-g1-pub': 0xea,\n  'bls12_381-g2-pub': 0xeb,\n  'p256-pub': 0x1200\n};\nconst CODEC_TO_KEY_TYPE = {\n  'bls12_381-g1-pub': 'Bls12381G1',\n  'bls12_381-g2-pub': 'Bls12381G2',\n  'ed25519-pub': 'Ed25519',\n  'p256-pub': 'P-256',\n  'secp256k1-pub': 'Secp256k1',\n  'x25519-pub': 'X25519'\n};\n/**\n * Extracts the raw byte representation of a public key from a VerificationMethod along with an inferred key type\n * @param pk a VerificationMethod entry from a DIDDocument\n * @return an object containing the `keyBytes` of the public key and an inferred `keyType`\n */\n\nfunction extractPublicKeyBytes(pk) {\n  if (pk.publicKeyBase58) {\n    return {\n      keyBytes: base58ToBytes(pk.publicKeyBase58),\n      keyType: VM_TO_KEY_TYPE[pk.type]\n    };\n  } else if (pk.publicKeyBase64) {\n    return {\n      keyBytes: base64ToBytes(pk.publicKeyBase64),\n      keyType: VM_TO_KEY_TYPE[pk.type]\n    };\n  } else if (pk.publicKeyHex) {\n    return {\n      keyBytes: hexToBytes(pk.publicKeyHex),\n      keyType: VM_TO_KEY_TYPE[pk.type]\n    };\n  } else if (pk.publicKeyJwk && pk.publicKeyJwk.crv === 'secp256k1' && pk.publicKeyJwk.x && pk.publicKeyJwk.y) {\n    return {\n      keyBytes: _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_4__.secp256k1.ProjectivePoint.fromAffine({\n        x: bytesToBigInt(base64ToBytes(pk.publicKeyJwk.x)),\n        y: bytesToBigInt(base64ToBytes(pk.publicKeyJwk.y))\n      }).toRawBytes(false),\n      keyType: 'Secp256k1'\n    };\n  } else if (pk.publicKeyJwk && pk.publicKeyJwk.crv === 'P-256' && pk.publicKeyJwk.x && pk.publicKeyJwk.y) {\n    return {\n      keyBytes: _noble_curves_p256__WEBPACK_IMPORTED_MODULE_5__.p256.ProjectivePoint.fromAffine({\n        x: bytesToBigInt(base64ToBytes(pk.publicKeyJwk.x)),\n        y: bytesToBigInt(base64ToBytes(pk.publicKeyJwk.y))\n      }).toRawBytes(false),\n      keyType: 'P-256'\n    };\n  } else if (pk.publicKeyJwk && pk.publicKeyJwk.kty === 'OKP' && ['Ed25519', 'X25519'].includes(pk.publicKeyJwk.crv ?? '') && pk.publicKeyJwk.x) {\n    return {\n      keyBytes: base64ToBytes(pk.publicKeyJwk.x),\n      keyType: pk.publicKeyJwk.crv\n    };\n  } else if (pk.publicKeyMultibase) {\n    const {\n      keyBytes,\n      keyType\n    } = multibaseToBytes(pk.publicKeyMultibase);\n    return {\n      keyBytes,\n      keyType: keyType ?? VM_TO_KEY_TYPE[pk.type]\n    };\n  }\n\n  return {\n    keyBytes: new Uint8Array()\n  };\n}\n/**\n * Encodes the given byte array to a multibase string (defaulting to base58btc).\n * If a codec is provided, the corresponding multicodec prefix will be added.\n *\n * @param b - the Uint8Array to be encoded\n * @param base - the base to use for encoding (defaults to base58btc)\n * @param codec - the codec to use for encoding (defaults to no codec)\n *\n * @returns the multibase encoded string\n *\n * @public\n */\n\nfunction bytesToMultibase(b, base = 'base58btc', codec) {\n  if (!codec) {\n    return u8a.toString((0,multibase__WEBPACK_IMPORTED_MODULE_2__.encode)(base, b), 'utf-8');\n  } else {\n    const codecCode = typeof codec === 'string' ? supportedCodecs[codec] : codec;\n    const prefixLength = multiformats__WEBPACK_IMPORTED_MODULE_1__.varint.encodingLength(codecCode);\n    const multicodecEncoding = new Uint8Array(prefixLength + b.length);\n    multiformats__WEBPACK_IMPORTED_MODULE_1__.varint.encodeTo(codecCode, multicodecEncoding); // set prefix\n\n    multicodecEncoding.set(b, prefixLength); // add the original bytes\n\n    return u8a.toString((0,multibase__WEBPACK_IMPORTED_MODULE_2__.encode)(base, multicodecEncoding), 'utf-8');\n  }\n}\n/**\n * Converts a multibase string to the Uint8Array it represents.\n * This method will assume the byte array that is multibase encoded is a multicodec and will attempt to decode it.\n *\n * @param s - the string to be converted\n *\n * @throws if the string is not formatted correctly.\n *\n * @public\n */\n\nfunction multibaseToBytes(s) {\n  const bytes = (0,multibase__WEBPACK_IMPORTED_MODULE_2__.decode)(s); // look for known key lengths first\n  // Ed25519/X25519, secp256k1/P256 compressed or not, BLS12-381 G1/G2 compressed\n\n  if ([32, 33, 48, 64, 65, 96].includes(bytes.length)) {\n    return {\n      keyBytes: bytes\n    };\n  } // then assume multicodec, otherwise return the bytes\n\n\n  try {\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    const [codec, length] = multiformats__WEBPACK_IMPORTED_MODULE_1__.varint.decode(bytes);\n    const possibleCodec = Object.entries(supportedCodecs).filter(([, code]) => code === codec)?.[0][0] ?? '';\n    return {\n      keyBytes: bytes.slice(length),\n      keyType: CODEC_TO_KEY_TYPE[possibleCodec]\n    };\n  } catch (e) {\n    // not a multicodec, return the bytes\n    return {\n      keyBytes: bytes\n    };\n  }\n}\nfunction hexToBytes(s, minLength) {\n  let input = s.startsWith('0x') ? s.substring(2) : s;\n\n  if (input.length % 2 !== 0) {\n    input = `0${input}`;\n  }\n\n  if (minLength) {\n    const paddedLength = Math.max(input.length, minLength * 2);\n    input = input.padStart(paddedLength, '00');\n  }\n\n  return u8a.fromString(input.toLowerCase(), 'base16');\n}\nfunction encodeBase64url(s) {\n  return bytesToBase64url(u8a.fromString(s));\n}\nfunction decodeBase64url(s) {\n  return u8a.toString(base64ToBytes(s));\n}\nfunction bytesToHex(b) {\n  return u8a.toString(b, 'base16');\n}\nfunction bytesToBigInt(b) {\n  return BigInt(`0x` + u8a.toString(b, 'base16'));\n}\nfunction stringToBytes(s) {\n  return u8a.fromString(s, 'utf-8');\n}\nfunction toJose({\n  r,\n  s,\n  recoveryParam\n}, recoverable) {\n  const jose = new Uint8Array(recoverable ? 65 : 64);\n  jose.set(u8a.fromString(r, 'base16'), 0);\n  jose.set(u8a.fromString(s, 'base16'), 32);\n\n  if (recoverable) {\n    if (typeof recoveryParam === 'undefined') {\n      throw new Error('Signer did not return a recoveryParam');\n    }\n\n    jose[64] = recoveryParam;\n  }\n\n  return bytesToBase64url(jose);\n}\nfunction fromJose(signature) {\n  const signatureBytes = base64ToBytes(signature);\n\n  if (signatureBytes.length < 64 || signatureBytes.length > 65) {\n    throw new TypeError(`Wrong size for signature. Expected 64 or 65 bytes, but got ${signatureBytes.length}`);\n  }\n\n  const r = bytesToHex(signatureBytes.slice(0, 32));\n  const s = bytesToHex(signatureBytes.slice(32, 64));\n  const recoveryParam = signatureBytes.length === 65 ? signatureBytes[64] : undefined;\n  return {\n    r,\n    s,\n    recoveryParam\n  };\n}\nfunction toSealed(ciphertext, tag) {\n  return u8a.concat([base64ToBytes(ciphertext), tag ? base64ToBytes(tag) : new Uint8Array(0)]);\n}\nfunction leftpad(data, size = 64) {\n  if (data.length === size) return data;\n  return '0'.repeat(size - data.length) + data;\n}\n/**\n * Generate random x25519 key pair.\n */\n\nfunction generateKeyPair() {\n  const secretKey = _noble_curves_ed25519__WEBPACK_IMPORTED_MODULE_6__.x25519.utils.randomPrivateKey();\n  const publicKey = _noble_curves_ed25519__WEBPACK_IMPORTED_MODULE_6__.x25519.getPublicKey(secretKey);\n  return {\n    secretKey: secretKey,\n    publicKey: publicKey\n  };\n}\n/**\n * Generate private-public x25519 key pair from `seed`.\n */\n\nfunction generateKeyPairFromSeed(seed) {\n  if (seed.length !== 32) {\n    throw new Error(`x25519: seed must be ${32} bytes`);\n  }\n\n  return {\n    publicKey: _noble_curves_ed25519__WEBPACK_IMPORTED_MODULE_6__.x25519.getPublicKey(seed),\n    secretKey: seed\n  };\n}\nfunction genX25519EphemeralKeyPair() {\n  const epk = generateKeyPair();\n  return {\n    publicKeyJWK: {\n      kty: 'OKP',\n      crv: 'X25519',\n      x: bytesToBase64url(epk.publicKey)\n    },\n    secretKey: epk.secretKey\n  };\n}\n/**\n * Checks if a variable is defined and not null.\n * After this check, typescript sees the variable as defined.\n *\n * @param arg - The input to be verified\n *\n * @returns true if the input variable is defined.\n */\n\nfunction isDefined(arg) {\n  return arg !== null && typeof arg !== 'undefined';\n}\n\nfunction sha256(payload) {\n  const data = typeof payload === 'string' ? (0,uint8arrays__WEBPACK_IMPORTED_MODULE_0__.fromString)(payload) : payload;\n  return (0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_7__.sha256)(data);\n}\nconst keccak = _noble_hashes_sha3__WEBPACK_IMPORTED_MODULE_8__.keccak_256;\nfunction toEthereumAddress(hexPublicKey) {\n  const hashInput = (0,uint8arrays__WEBPACK_IMPORTED_MODULE_0__.fromString)(hexPublicKey.slice(2), 'base16');\n  return `0x${(0,uint8arrays__WEBPACK_IMPORTED_MODULE_0__.toString)(keccak(hashInput).slice(-20), 'base16')}`;\n}\n\nfunction writeUint32BE(value, array = new Uint8Array(4)) {\n  const encoded = (0,uint8arrays__WEBPACK_IMPORTED_MODULE_0__.fromString)(value.toString(), 'base10');\n  array.set(encoded, 4 - encoded.length);\n  return array;\n}\n\nconst lengthAndInput = input => (0,uint8arrays__WEBPACK_IMPORTED_MODULE_0__.concat)([writeUint32BE(input.length), input]); // This implementation of concatKDF was inspired by these two implementations:\n// https://github.com/digitalbazaar/minimal-cipher/blob/master/algorithms/ecdhkdf.js\n// https://github.com/panva/jose/blob/master/lib/jwa/ecdh/derive.js\n\n\nfunction concatKDF(secret, keyLen, alg, producerInfo, consumerInfo) {\n  if (keyLen !== 256) throw new Error(`Unsupported key length: ${keyLen}`);\n  const value = (0,uint8arrays__WEBPACK_IMPORTED_MODULE_0__.concat)([lengthAndInput((0,uint8arrays__WEBPACK_IMPORTED_MODULE_0__.fromString)(alg)), lengthAndInput(typeof producerInfo === 'undefined' ? new Uint8Array(0) : producerInfo), // apu\n  lengthAndInput(typeof consumerInfo === 'undefined' ? new Uint8Array(0) : consumerInfo), // apv\n  writeUint32BE(keyLen)]); // since our key lenght is 256 we only have to do one round\n\n  const roundNumber = 1;\n  return sha256((0,uint8arrays__WEBPACK_IMPORTED_MODULE_0__.concat)([writeUint32BE(roundNumber), secret, value]));\n}\n\n/**\n *  Creates a configured signer function for signing data using the ES256K (secp256k1 + sha256) algorithm.\n *\n *  The signing function itself takes the data as a `Uint8Array` or `string` and returns a `base64Url`-encoded signature\n *\n *  @example\n *  ```typescript\n *  const sign: Signer = ES256KSigner(process.env.PRIVATE_KEY)\n *  const signature: string = await sign(data)\n *  ```\n *\n *  @param    {String}    privateKey   a private key as `Uint8Array`\n *  @param    {Boolean}   recoverable  an optional flag to add the recovery param to the generated signatures\n *  @return   {Function}               a configured signer function `(data: string | Uint8Array): Promise<string>`\n */\n\nfunction ES256KSigner(privateKey, recoverable = false) {\n  const privateKeyBytes = privateKey;\n\n  if (privateKeyBytes.length !== 32) {\n    throw new Error(`bad_key: Invalid private key format. Expecting 32 bytes, but got ${privateKeyBytes.length}`);\n  }\n\n  return function (data) {\n    try {\n      const signature = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_4__.secp256k1.sign(sha256(data), privateKeyBytes);\n      return Promise.resolve(toJose({\n        r: leftpad(signature.r.toString(16)),\n        s: leftpad(signature.s.toString(16)),\n        recoveryParam: signature.recovery\n      }, recoverable));\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n}\n\n/**\n * @deprecated Please use ES256KSigner\n *  The SimpleSigner returns a configured function for signing data.\n *\n *  @example\n *  const signer = SimpleSigner(process.env.PRIVATE_KEY)\n *  signer(data, (err, signature) => {\n *    ...\n *  })\n *\n *  @param    {String}         hexPrivateKey    a hex encoded private key\n *  @return   {Function}                     a configured signer function\n */\n\nfunction SimpleSigner(hexPrivateKey) {\n  const signer = ES256KSigner(hexToBytes(hexPrivateKey), true);\n  return function (data) {\n    try {\n      return Promise.resolve(signer(data)).then(fromJose);\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n}\n\n/**\n * @deprecated Please use ES256KSigner\n *  The EllipticSigner returns a configured function for signing data.\n *\n *  @example\n *  ```typescript\n *  const signer = EllipticSigner(process.env.PRIVATE_KEY)\n *  signer(data).then( (signature: string) => {\n *    ...\n *  })\n *  ```\n *\n *  @param    {String}         hexPrivateKey    a hex encoded private key\n *  @return   {Function}                        a configured signer function\n */\n\nfunction EllipticSigner(hexPrivateKey) {\n  return ES256KSigner(hexToBytes(hexPrivateKey));\n}\n\n/**\n *  Creates a configured signer function for signing data using the EdDSA (Ed25519) algorithm.\n *\n *  The private key is expected to be a `Uint8Array` of 32 bytes, but for compatibility 64 bytes are also acceptable.\n * Users of `@stablelib/ed25519` or `tweetnacl` will be able to use the 64 byte secret keys that library generates.\n * These libraries precompute the public key and append it as the last 32 bytes of the secretKey, to speed up later\n * signing operations.\n *\n *  The signing function itself takes the data as a `Uint8Array` or utf8 `string` and returns a `base64Url`-encoded\n * signature\n *\n *  @example\n *  ```typescript\n *  const sign: Signer = EdDSASigner(process.env.PRIVATE_KEY)\n *  const signature: string = await sign(data)\n *  ```\n *\n *  @param    {String}    secretKey   a 32 or 64 byte secret key as `Uint8Array`\n *  @return   {Function}              a configured signer function `(data: string | Uint8Array): Promise<string>`\n */\n\nfunction EdDSASigner(secretKey) {\n  const privateKeyBytes = secretKey;\n\n  if (![32, 64].includes(privateKeyBytes.length)) {\n    throw new Error(`bad_key: Invalid private key format. Expecting 32 or 64 bytes, but got ${privateKeyBytes.length}`);\n  }\n\n  return function (data) {\n    try {\n      const dataBytes = typeof data === 'string' ? stringToBytes(data) : data;\n      const signature = _noble_curves_ed25519__WEBPACK_IMPORTED_MODULE_6__.ed25519.sign(dataBytes, privateKeyBytes.slice(0, 32));\n      return Promise.resolve(bytesToBase64url(signature));\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n}\n\n/**\n * @deprecated Please use EdDSASigner\n *\n *  The NaclSigner returns a configured function for signing data using the Ed25519 algorithm.\n *\n *  The signing function itself takes the data as a `string` or `Uint8Array` parameter and returns a\n *   `base64Url`-encoded signature.\n *\n *  @example\n *  const signer = NaclSigner(process.env.PRIVATE_KEY)\n *  const data: string = '...'\n *  signer(data).then( (signature: string) => {\n *    ...\n *  })\n *\n *  @param    {String}   base64PrivateKey    a 64 byte base64 encoded private key\n *  @return   {Function}                     a configured signer function\n */\n\nfunction NaclSigner(base64PrivateKey) {\n  return EdDSASigner(base64ToBytes(base64PrivateKey));\n}\n\n/**\n *  Creates a configured signer function for signing data using the ES256 (secp256r1 + sha256) algorithm.\n *\n *  The signing function itself takes the data as a `Uint8Array` or `string` and returns a `base64Url`-encoded signature\n *\n *  @example\n *  ```typescript\n *  const sign: Signer = ES256Signer(process.env.PRIVATE_KEY)\n *  const signature: string = await sign(data)\n *  ```\n *\n *  @param    {String}    privateKey   a private key as `Uint8Array`\n *  @return   {Function}               a configured signer function `(data: string | Uint8Array): Promise<string>`\n */\n\nfunction ES256Signer(privateKey) {\n  if (privateKey.length !== 32) {\n    throw new Error(`bad_key: Invalid private key format. Expecting 32 bytes, but got ${privateKey.length}`);\n  }\n\n  return function (data) {\n    try {\n      const signature = _noble_curves_p256__WEBPACK_IMPORTED_MODULE_5__.p256.sign(sha256(data), privateKey);\n      return Promise.resolve(toJose({\n        r: leftpad(signature.r.toString(16)),\n        s: leftpad(signature.s.toString(16))\n      }));\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n}\n\nfunction instanceOfEcdsaSignature(object) {\n  return typeof object === 'object' && 'r' in object && 's' in object;\n}\n\nfunction ES256SignerAlg() {\n  return function sign(payload, signer) {\n    try {\n      return Promise.resolve(signer(payload)).then(function (signature) {\n        if (instanceOfEcdsaSignature(signature)) {\n          return toJose(signature);\n        } else {\n          return signature;\n        }\n      });\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n}\nfunction ES256KSignerAlg(recoverable) {\n  return function sign(payload, signer) {\n    try {\n      return Promise.resolve(signer(payload)).then(function (signature) {\n        if (instanceOfEcdsaSignature(signature)) {\n          return toJose(signature, recoverable);\n        } else {\n          if (recoverable && typeof fromJose(signature).recoveryParam === 'undefined') {\n            throw new Error(`not_supported: ES256K-R not supported when signer doesn't provide a recovery param`);\n          }\n\n          return signature;\n        }\n      });\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n}\nfunction Ed25519SignerAlg() {\n  return function sign(payload, signer) {\n    try {\n      return Promise.resolve(signer(payload)).then(function (signature) {\n        if (!instanceOfEcdsaSignature(signature)) {\n          return signature;\n        } else {\n          throw new Error('invalid_config: expected a signer function that returns a string instead of signature object');\n        }\n      });\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n}\nconst algorithms$1 = {\n  ES256: ES256SignerAlg(),\n  ES256K: ES256KSignerAlg(),\n  // This is a non-standard algorithm but retained for backwards compatibility\n  // see https://github.com/decentralized-identity/did-jwt/issues/146\n  'ES256K-R': ES256KSignerAlg(true),\n  // This is actually incorrect but retained for backwards compatibility\n  // see https://github.com/decentralized-identity/did-jwt/issues/130\n  Ed25519: Ed25519SignerAlg(),\n  EdDSA: Ed25519SignerAlg()\n};\n\nfunction SignerAlg(alg) {\n  const impl = algorithms$1[alg];\n  if (!impl) throw new Error(`not_supported: Unsupported algorithm ${alg}`);\n  return impl;\n}\n\nfunction publicKeyToAddress$1(publicKey, otherAddress) {\n  // Use the same version/prefix byte as the given address.\n  const version = bytesToHex(base58ToBytes(otherAddress).slice(0, 1));\n  const publicKeyBuffer = hexToBytes(publicKey);\n  const publicKeyHash = (0,_noble_hashes_ripemd160__WEBPACK_IMPORTED_MODULE_9__.ripemd160)(sha256(publicKeyBuffer));\n  const step1 = version + bytesToHex(publicKeyHash);\n  const step2 = sha256(hexToBytes(step1));\n  const step3 = sha256(step2);\n  const checksum = bytesToHex(step3).substring(0, 8);\n  const step4 = step1 + checksum;\n  return bytesToBase58(hexToBytes(step4));\n}\n\nfunction publicKeyToAddress(publicKey, prefix) {\n  const publicKeyBuffer = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_4__.secp256k1.ProjectivePoint.fromHex(publicKey).toRawBytes();\n  const hash = (0,_noble_hashes_ripemd160__WEBPACK_IMPORTED_MODULE_9__.ripemd160)(sha256(publicKeyBuffer));\n  const words = _scure_base__WEBPACK_IMPORTED_MODULE_10__.bech32.toWords(hash);\n  return _scure_base__WEBPACK_IMPORTED_MODULE_10__.bech32.encode(prefix, words).replace(prefix, '');\n}\n\nfunction verifyBlockchainAccountId(publicKey, blockchainAccountId) {\n  if (blockchainAccountId) {\n    const chain = blockchainAccountId.split(':');\n\n    switch (chain[0]) {\n      case 'bip122':\n        chain[chain.length - 1] = publicKeyToAddress$1(publicKey, chain[chain.length - 1]);\n        break;\n\n      case 'cosmos':\n        chain[chain.length - 1] = publicKeyToAddress(publicKey, chain[1]);\n        break;\n\n      case 'eip155':\n        chain[chain.length - 1] = toEthereumAddress(publicKey);\n        break;\n\n      default:\n        return false;\n    }\n\n    return chain.join(':').toLowerCase() === blockchainAccountId.toLowerCase();\n  }\n\n  return false;\n}\n\nfunction toSignatureObject(signature, recoverable = false) {\n  const rawSig = base64ToBytes(signature);\n\n  if (rawSig.length !== (recoverable ? 65 : 64)) {\n    throw new Error('wrong signature length');\n  }\n\n  const r = bytesToHex(rawSig.slice(0, 32));\n  const s = bytesToHex(rawSig.slice(32, 64));\n  const sigObj = {\n    r,\n    s\n  };\n\n  if (recoverable) {\n    sigObj.recoveryParam = rawSig[64];\n  }\n\n  return sigObj;\n}\nfunction toSignatureObject2(signature, recoverable = false) {\n  const bytes = base64ToBytes(signature);\n\n  if (bytes.length !== (recoverable ? 65 : 64)) {\n    throw new Error('wrong signature length');\n  }\n\n  return {\n    compact: bytes.slice(0, 64),\n    recovery: bytes[64]\n  };\n}\nfunction verifyES256(data, signature, authenticators) {\n  const hash = sha256(data);\n  const sig = _noble_curves_p256__WEBPACK_IMPORTED_MODULE_5__.p256.Signature.fromCompact(toSignatureObject2(signature).compact);\n  const fullPublicKeys = authenticators.filter(a => !a.ethereumAddress && !a.blockchainAccountId);\n  const signer = fullPublicKeys.find(pk => {\n    try {\n      const {\n        keyBytes\n      } = extractPublicKeyBytes(pk);\n      return _noble_curves_p256__WEBPACK_IMPORTED_MODULE_5__.p256.verify(sig, hash, keyBytes);\n    } catch (err) {\n      return false;\n    }\n  });\n  if (!signer) throw new Error('invalid_signature: Signature invalid for JWT');\n  return signer;\n}\nfunction verifyES256K(data, signature, authenticators) {\n  const hash = sha256(data);\n  const signatureNormalized = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_4__.secp256k1.Signature.fromCompact(base64ToBytes(signature)).normalizeS();\n  const fullPublicKeys = authenticators.filter(a => {\n    return !a.ethereumAddress && !a.blockchainAccountId;\n  });\n  const blockchainAddressKeys = authenticators.filter(a => {\n    return a.ethereumAddress || a.blockchainAccountId;\n  });\n  let signer = fullPublicKeys.find(pk => {\n    try {\n      const {\n        keyBytes\n      } = extractPublicKeyBytes(pk);\n      return _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_4__.secp256k1.verify(signatureNormalized, hash, keyBytes);\n    } catch (err) {\n      return false;\n    }\n  });\n\n  if (!signer && blockchainAddressKeys.length > 0) {\n    signer = verifyRecoverableES256K(data, signature, blockchainAddressKeys);\n  }\n\n  if (!signer) throw new Error('invalid_signature: Signature invalid for JWT');\n  return signer;\n}\nfunction verifyRecoverableES256K(data, signature, authenticators) {\n  const signatures = [];\n\n  if (signature.length > 86) {\n    signatures.push(toSignatureObject2(signature, true));\n  } else {\n    const so = toSignatureObject2(signature, false);\n    signatures.push({ ...so,\n      recovery: 0\n    });\n    signatures.push({ ...so,\n      recovery: 1\n    });\n  }\n\n  const hash = sha256(data);\n\n  const checkSignatureAgainstSigner = sigObj => {\n    const signature = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_4__.secp256k1.Signature.fromCompact(sigObj.compact).addRecoveryBit(sigObj.recovery || 0);\n    const recoveredPublicKey = signature.recoverPublicKey(hash);\n    const recoveredAddress = toEthereumAddress(recoveredPublicKey.toHex(false)).toLowerCase();\n    const recoveredPublicKeyHex = recoveredPublicKey.toHex(false);\n    const recoveredCompressedPublicKeyHex = recoveredPublicKey.toHex(true);\n    return authenticators.find(a => {\n      const {\n        keyBytes\n      } = extractPublicKeyBytes(a);\n      const keyHex = bytesToHex(keyBytes);\n      return keyHex === recoveredPublicKeyHex || keyHex === recoveredCompressedPublicKeyHex || a.ethereumAddress?.toLowerCase() === recoveredAddress || a.blockchainAccountId?.split('@eip155')?.[0].toLowerCase() === recoveredAddress || // CAIP-2\n      verifyBlockchainAccountId(recoveredPublicKeyHex, a.blockchainAccountId) // CAIP-10\n      ;\n    });\n  }; // Find first verification method\n\n\n  for (const signature of signatures) {\n    const verificationMethod = checkSignatureAgainstSigner(signature);\n    if (verificationMethod) return verificationMethod;\n  } // If no one found matching\n\n\n  throw new Error('invalid_signature: Signature invalid for JWT');\n}\nfunction verifyEd25519(data, signature, authenticators) {\n  const clear = stringToBytes(data);\n  const signatureBytes = base64ToBytes(signature);\n  const signer = authenticators.find(a => {\n    const {\n      keyBytes,\n      keyType\n    } = extractPublicKeyBytes(a);\n\n    if (keyType === 'Ed25519') {\n      return _noble_curves_ed25519__WEBPACK_IMPORTED_MODULE_6__.ed25519.verify(signatureBytes, clear, keyBytes);\n    } else {\n      return false;\n    }\n  });\n  if (!signer) throw new Error('invalid_signature: Signature invalid for JWT');\n  return signer;\n}\nconst algorithms = {\n  ES256: verifyES256,\n  ES256K: verifyES256K,\n  // This is a non-standard algorithm but retained for backwards compatibility\n  // see https://github.com/decentralized-identity/did-jwt/issues/146\n  'ES256K-R': verifyRecoverableES256K,\n  // This is actually incorrect but retained for backwards compatibility\n  // see https://github.com/decentralized-identity/did-jwt/issues/130\n  Ed25519: verifyEd25519,\n  EdDSA: verifyEd25519\n};\n\nfunction VerifierAlgorithm(alg) {\n  const impl = algorithms[alg];\n  if (!impl) throw new Error(`not_supported: Unsupported algorithm ${alg}`);\n  return impl;\n}\n\nVerifierAlgorithm.toSignatureObject = toSignatureObject;\n\n/**\n * Error prefixes used for known verification failure cases.\n *\n * For compatibility, these error prefixes match the existing error messages, but will be adjusted in a future major\n * version update to match the scenarios better.\n *\n * @beta\n */\nconst JWT_ERROR = {\n  /**\n   * Thrown when a JWT payload schema is unexpected or when validity period does not match\n   */\n  INVALID_JWT: 'invalid_jwt',\n\n  /**\n   * Thrown when the verifier audience does not match the one set in the JWT payload\n   */\n  INVALID_AUDIENCE: 'invalid_config',\n\n  /**\n   * Thrown when none of the public keys of the issuer match the signature of the JWT.\n   *\n   * This is equivalent to `NO_SUITABLE_KEYS` when the `proofPurpose` is NOT specified.\n   */\n  INVALID_SIGNATURE: 'invalid_signature',\n\n  /**\n   * Thrown when the DID document of the issuer does not have any keys that match the signature for the given\n   * `proofPurpose`.\n   *\n   * This is equivalent to `invalid_signature`, when a `proofPurpose` is specified.\n   */\n  NO_SUITABLE_KEYS: 'no_suitable_keys',\n\n  /**\n   * Thrown when the `alg` of the JWT or the encoding of the key is not supported\n   */\n  NOT_SUPPORTED: 'not_supported',\n\n  /**\n   * Thrown when the DID resolver is unable to resolve the issuer DID.\n   */\n  RESOLVER_ERROR: 'resolver_error'\n};\n\nfunction _catch$1(body, recover) {\n  try {\n    var result = body();\n  } catch (e) {\n    return recover(e);\n  }\n\n  if (result && result.then) {\n    return result.then(void 0, recover);\n  }\n\n  return result;\n}\n\nconst verifyConditionDelegated = function (jwt, {\n  header,\n  payload,\n  data,\n  signature\n}, authenticator, options) {\n  try {\n    if (!authenticator.conditionDelegated) {\n      throw new Error('Expected conditionDelegated');\n    }\n\n    if (!options.resolver) {\n      throw new Error('Expected resolver');\n    }\n\n    let foundSigner;\n    const issuer = authenticator.conditionDelegated;\n    return Promise.resolve(resolveAuthenticator(options.resolver, header.alg, issuer, options.proofPurpose)).then(function (didAuthenticator) {\n      let _exit2;\n\n      function _temp6(_result4) {\n        if (_exit2) ;\n\n        if (foundSigner) {\n          return authenticator;\n        }\n\n        throw new Error(`${JWT_ERROR.INVALID_SIGNATURE}: condition for authenticator ${authenticator.id} is not met.`);\n      }\n\n      const didResolutionResult = didAuthenticator.didResolutionResult;\n\n      if (!didResolutionResult?.didDocument) {\n        throw new Error(`${JWT_ERROR.RESOLVER_ERROR}: Could not resolve delegated DID ${issuer}.`);\n      }\n\n      const delegatedAuthenticator = didAuthenticator.authenticators.find(authenticator => authenticator.id === issuer);\n\n      if (!delegatedAuthenticator) {\n        throw new Error(`${JWT_ERROR.NO_SUITABLE_KEYS}: Could not find delegated authenticator ${issuer} in it's DID Document`);\n      }\n\n      const _temp5 = function () {\n        if (delegatedAuthenticator.type === CONDITIONAL_PROOF_2022) {\n          return Promise.resolve(verifyJWT(jwt, { ...options,\n            ...{\n              didAuthenticator: {\n                didResolutionResult,\n                authenticators: [delegatedAuthenticator],\n                issuer: delegatedAuthenticator.id\n              }\n            }\n          })).then(function ({\n            verified\n          }) {\n            if (verified) {\n              foundSigner = delegatedAuthenticator;\n            }\n          });\n        } else {\n          try {\n            foundSigner = verifyJWTDecoded({\n              header,\n              payload,\n              data,\n              signature\n            }, delegatedAuthenticator);\n          } catch (e) {\n            if (!e.message.startsWith('invalid_signature:')) throw e;\n          }\n        }\n      }();\n\n      return _temp5 && _temp5.then ? _temp5.then(_temp6) : _temp6(_temp5);\n    });\n  } catch (e) {\n    return Promise.reject(e);\n  }\n};\n\nconst _iteratorSymbol$1 = typeof Symbol !== \"undefined\" ? Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\")) : \"@@iterator\";\n\nfunction _settle$2(pact, state, value) {\n  if (!pact.s) {\n    if (value instanceof _Pact$2) {\n      if (value.s) {\n        if (state & 1) {\n          state = value.s;\n        }\n\n        value = value.v;\n      } else {\n        value.o = _settle$2.bind(null, pact, state);\n        return;\n      }\n    }\n\n    if (value && value.then) {\n      value.then(_settle$2.bind(null, pact, state), _settle$2.bind(null, pact, 2));\n      return;\n    }\n\n    pact.s = state;\n    pact.v = value;\n    const observer = pact.o;\n\n    if (observer) {\n      observer(pact);\n    }\n  }\n}\n\nconst _Pact$2 = /*#__PURE__*/function () {\n  function _Pact() {}\n\n  _Pact.prototype.then = function (onFulfilled, onRejected) {\n    const result = new _Pact();\n    const state = this.s;\n\n    if (state) {\n      const callback = state & 1 ? onFulfilled : onRejected;\n\n      if (callback) {\n        try {\n          _settle$2(result, 1, callback(this.v));\n        } catch (e) {\n          _settle$2(result, 2, e);\n        }\n\n        return result;\n      } else {\n        return this;\n      }\n    }\n\n    this.o = function (_this) {\n      try {\n        const value = _this.v;\n\n        if (_this.s & 1) {\n          _settle$2(result, 1, onFulfilled ? onFulfilled(value) : value);\n        } else if (onRejected) {\n          _settle$2(result, 1, onRejected(value));\n        } else {\n          _settle$2(result, 2, value);\n        }\n      } catch (e) {\n        _settle$2(result, 2, e);\n      }\n    };\n\n    return result;\n  };\n\n  return _Pact;\n}();\n\nfunction _isSettledPact$2(thenable) {\n  return thenable instanceof _Pact$2 && thenable.s & 1;\n}\n\nfunction _forTo$2(array, body, check) {\n  var i = -1,\n      pact,\n      reject;\n\n  function _cycle(result) {\n    try {\n      while (++i < array.length && (!check || !check())) {\n        result = body(i);\n\n        if (result && result.then) {\n          if (_isSettledPact$2(result)) {\n            result = result.v;\n          } else {\n            result.then(_cycle, reject || (reject = _settle$2.bind(null, pact = new _Pact$2(), 2)));\n            return;\n          }\n        }\n      }\n\n      if (pact) {\n        _settle$2(pact, 1, result);\n      } else {\n        pact = result;\n      }\n    } catch (e) {\n      _settle$2(pact || (pact = new _Pact$2()), 2, e);\n    }\n  }\n\n  _cycle();\n\n  return pact;\n}\n\nconst verifyConditionWeightedThreshold = function (jwt, {\n  header,\n  payload,\n  data,\n  signature\n}, authenticator, options) {\n  try {\n    let _exit;\n\n    function _temp4(_result3) {\n      if (_exit) return _result3;\n      throw new Error(`${JWT_ERROR.INVALID_SIGNATURE}: condition for authenticator ${authenticator.id} is not met.`);\n    }\n\n    if (!authenticator.conditionWeightedThreshold || !authenticator.threshold) {\n      throw new Error('Expected conditionWeightedThreshold and threshold');\n    }\n\n    const issuers = [];\n    const threshold = authenticator.threshold;\n    let weightCount = 0;\n\n    const _temp3 = _forOf$1(authenticator.conditionWeightedThreshold, function (weightedCondition) {\n      function _temp2(_result2) {\n        if (_exit) return _result2;\n\n        if (foundSigner && !issuers.includes(foundSigner.id)) {\n          issuers.push(foundSigner.id);\n          weightCount += weightedCondition.weight;\n\n          if (weightCount >= threshold) {\n            _exit = 1;\n            return authenticator;\n          }\n        }\n      }\n\n      const currentCondition = weightedCondition.condition;\n      let foundSigner;\n\n      const _temp = _catch$1(function () {\n        if (currentCondition.type === CONDITIONAL_PROOF_2022) {\n          if (!options.didAuthenticator) {\n            throw new Error('Expected didAuthenticator');\n          }\n\n          const newOptions = { ...options,\n            didAuthenticator: {\n              didResolutionResult: options.didAuthenticator?.didResolutionResult,\n              authenticators: [currentCondition],\n              issuer: currentCondition.id\n            }\n          };\n          return Promise.resolve(verifyJWT(jwt, newOptions)).then(function ({\n            verified\n          }) {\n            if (verified) {\n              foundSigner = currentCondition;\n            }\n          });\n        } else {\n          return Promise.resolve(verifyJWTDecoded({\n            header,\n            payload,\n            data,\n            signature\n          }, currentCondition)).then(function (_verifyJWTDecoded) {\n            foundSigner = _verifyJWTDecoded;\n          });\n        }\n      }, function (e) {\n        if (!e.message.startsWith(JWT_ERROR.INVALID_SIGNATURE)) throw e;\n      });\n\n      return _temp && _temp.then ? _temp.then(_temp2) : _temp2(_temp);\n    }, function () {\n      return _exit;\n    });\n\n    return Promise.resolve(_temp3 && _temp3.then ? _temp3.then(_temp4) : _temp4(_temp3));\n  } catch (e) {\n    return Promise.reject(e);\n  }\n};\n\nfunction _forOf$1(target, body, check) {\n  if (typeof target[_iteratorSymbol$1] === \"function\") {\n    var iterator = target[_iteratorSymbol$1](),\n        step,\n        pact,\n        reject;\n\n    function _cycle(result) {\n      try {\n        while (!(step = iterator.next()).done && (!check || !check())) {\n          result = body(step.value);\n\n          if (result && result.then) {\n            if (_isSettledPact$2(result)) {\n              result = result.v;\n            } else {\n              result.then(_cycle, reject || (reject = _settle$2.bind(null, pact = new _Pact$2(), 2)));\n              return;\n            }\n          }\n        }\n\n        if (pact) {\n          _settle$2(pact, 1, result);\n        } else {\n          pact = result;\n        }\n      } catch (e) {\n        _settle$2(pact || (pact = new _Pact$2()), 2, e);\n      }\n    }\n\n    _cycle();\n\n    if (iterator.return) {\n      var _fixup = function (value) {\n        try {\n          if (!step.done) {\n            iterator.return();\n          }\n        } catch (e) {}\n\n        return value;\n      };\n\n      if (pact && pact.then) {\n        return pact.then(_fixup, function (e) {\n          throw _fixup(e);\n        });\n      }\n\n      _fixup();\n    }\n\n    return pact;\n  } // No support for Symbol.iterator\n\n\n  if (!(\"length\" in target)) {\n    throw new TypeError(\"Object is not iterable\");\n  } // Handle live collections properly\n\n\n  var values = [];\n\n  for (var i = 0; i < target.length; i++) {\n    values.push(target[i]);\n  }\n\n  return _forTo$2(values, function (i) {\n    return body(values[i]);\n  }, check);\n}\n\nconst verifyConditionalProof = function (jwt, {\n  header,\n  payload,\n  signature,\n  data\n}, authenticator, options) {\n  try {\n    // Validate the condition according to its condition property\n    if (authenticator.conditionWeightedThreshold) {\n      return verifyConditionWeightedThreshold(jwt, {\n        header,\n        payload,\n        data,\n        signature\n      }, authenticator, options);\n    } else if (authenticator.conditionDelegated) {\n      return verifyConditionDelegated(jwt, {\n        header,\n        payload,\n        data,\n        signature\n      }, authenticator, options);\n    } // TODO other conditions\n\n\n    throw new Error(`${JWT_ERROR.INVALID_JWT}: conditional proof type did not find condition for authenticator ${authenticator.id}.`);\n  } catch (e) {\n    return Promise.reject(e);\n  }\n};\nconst verifyProof = function (jwt, {\n  header,\n  payload,\n  signature,\n  data\n}, authenticator, options) {\n  try {\n    if (authenticator.type === CONDITIONAL_PROOF_2022) {\n      return verifyConditionalProof(jwt, {\n        payload,\n        header,\n        signature,\n        data\n      }, authenticator, options);\n    } else {\n      return Promise.resolve(verifyJWTDecoded({\n        header,\n        payload,\n        data,\n        signature\n      }, [authenticator]));\n    }\n  } catch (e) {\n    return Promise.reject(e);\n  }\n};\nconst CONDITIONAL_PROOF_2022 = 'ConditionalProof2022';\n\n/**\n * Resolves relevant public keys or other authenticating material used to verify signature from the DID document of\n * provided DID\n *\n *  @example\n *  ```ts\n *  resolveAuthenticator(resolver, 'ES256K', 'did:uport:2nQtiQG6Cgm1GYTBaaKAgr76uY7iSexUkqX').then(obj => {\n *      const payload = obj.payload\n *      const profile = obj.profile\n *      const jwt = obj.jwt\n *      // ...\n *  })\n *  ```\n *\n *  @param resolver - {Resolvable} a DID resolver function that can obtain the `DIDDocument` for the `issuer`\n *  @param alg - {String} a JWT algorithm\n *  @param issuer - {String} a Decentralized Identifier (DID) to lookup\n *  @param proofPurpose - {ProofPurposeTypes} *Optional* Use the verificationMethod linked in that section of the\n *   issuer DID document\n *  @return {Promise<DIDAuthenticator>} a promise which resolves with an object containing an array of authenticators\n *   or rejects with an error if none exist\n */\nfunction _settle$1(pact, state, value) {\n  if (!pact.s) {\n    if (value instanceof _Pact$1) {\n      if (value.s) {\n        if (state & 1) {\n          state = value.s;\n        }\n\n        value = value.v;\n      } else {\n        value.o = _settle$1.bind(null, pact, state);\n        return;\n      }\n    }\n\n    if (value && value.then) {\n      value.then(_settle$1.bind(null, pact, state), _settle$1.bind(null, pact, 2));\n      return;\n    }\n\n    pact.s = state;\n    pact.v = value;\n    const observer = pact.o;\n\n    if (observer) {\n      observer(pact);\n    }\n  }\n}\n\nconst _Pact$1 = /*#__PURE__*/function () {\n  function _Pact() {}\n\n  _Pact.prototype.then = function (onFulfilled, onRejected) {\n    const result = new _Pact();\n    const state = this.s;\n\n    if (state) {\n      const callback = state & 1 ? onFulfilled : onRejected;\n\n      if (callback) {\n        try {\n          _settle$1(result, 1, callback(this.v));\n        } catch (e) {\n          _settle$1(result, 2, e);\n        }\n\n        return result;\n      } else {\n        return this;\n      }\n    }\n\n    this.o = function (_this) {\n      try {\n        const value = _this.v;\n\n        if (_this.s & 1) {\n          _settle$1(result, 1, onFulfilled ? onFulfilled(value) : value);\n        } else if (onRejected) {\n          _settle$1(result, 1, onRejected(value));\n        } else {\n          _settle$1(result, 2, value);\n        }\n      } catch (e) {\n        _settle$1(result, 2, e);\n      }\n    };\n\n    return result;\n  };\n\n  return _Pact;\n}();\n\nfunction _isSettledPact$1(thenable) {\n  return thenable instanceof _Pact$1 && thenable.s & 1;\n}\n\nfunction _forTo$1(array, body, check) {\n  var i = -1,\n      pact,\n      reject;\n\n  function _cycle(result) {\n    try {\n      while (++i < array.length && (!check || !check())) {\n        result = body(i);\n\n        if (result && result.then) {\n          if (_isSettledPact$1(result)) {\n            result = result.v;\n          } else {\n            result.then(_cycle, reject || (reject = _settle$1.bind(null, pact = new _Pact$1(), 2)));\n            return;\n          }\n        }\n      }\n\n      if (pact) {\n        _settle$1(pact, 1, result);\n      } else {\n        pact = result;\n      }\n    } catch (e) {\n      _settle$1(pact || (pact = new _Pact$1()), 2, e);\n    }\n  }\n\n  _cycle();\n\n  return pact;\n}\n\nfunction _catch(body, recover) {\n  try {\n    var result = body();\n  } catch (e) {\n    return recover(e);\n  }\n\n  if (result && result.then) {\n    return result.then(void 0, recover);\n  }\n\n  return result;\n}\n\nfunction _for$1(test, update, body) {\n  var stage;\n\n  for (;;) {\n    var shouldContinue = test();\n\n    if (_isSettledPact$1(shouldContinue)) {\n      shouldContinue = shouldContinue.v;\n    }\n\n    if (!shouldContinue) {\n      return result;\n    }\n\n    if (shouldContinue.then) {\n      stage = 0;\n      break;\n    }\n\n    var result = body();\n\n    if (result && result.then) {\n      if (_isSettledPact$1(result)) {\n        result = result.s;\n      } else {\n        stage = 1;\n        break;\n      }\n    }\n\n    if (update) {\n      var updateValue = update();\n\n      if (updateValue && updateValue.then && !_isSettledPact$1(updateValue)) {\n        stage = 2;\n        break;\n      }\n    }\n  }\n\n  var pact = new _Pact$1();\n\n  var reject = _settle$1.bind(null, pact, 2);\n\n  (stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n  return pact;\n\n  function _resumeAfterBody(value) {\n    result = value;\n\n    do {\n      if (update) {\n        updateValue = update();\n\n        if (updateValue && updateValue.then && !_isSettledPact$1(updateValue)) {\n          updateValue.then(_resumeAfterUpdate).then(void 0, reject);\n          return;\n        }\n      }\n\n      shouldContinue = test();\n\n      if (!shouldContinue || _isSettledPact$1(shouldContinue) && !shouldContinue.v) {\n        _settle$1(pact, 1, result);\n\n        return;\n      }\n\n      if (shouldContinue.then) {\n        shouldContinue.then(_resumeAfterTest).then(void 0, reject);\n        return;\n      }\n\n      result = body();\n\n      if (_isSettledPact$1(result)) {\n        result = result.v;\n      }\n    } while (!result || !result.then);\n\n    result.then(_resumeAfterBody).then(void 0, reject);\n  }\n\n  function _resumeAfterTest(shouldContinue) {\n    if (shouldContinue) {\n      result = body();\n\n      if (result && result.then) {\n        result.then(_resumeAfterBody).then(void 0, reject);\n      } else {\n        _resumeAfterBody(result);\n      }\n    } else {\n      _settle$1(pact, 1, result);\n    }\n  }\n\n  function _resumeAfterUpdate() {\n    if (shouldContinue = test()) {\n      if (shouldContinue.then) {\n        shouldContinue.then(_resumeAfterTest).then(void 0, reject);\n      } else {\n        _resumeAfterTest(shouldContinue);\n      }\n    } else {\n      _settle$1(pact, 1, result);\n    }\n  }\n}\n\nconst resolveAuthenticator = function (resolver, alg, issuer, proofPurpose) {\n  try {\n    const types = SUPPORTED_PUBLIC_KEY_TYPES[alg];\n\n    if (!types || types.length === 0) {\n      throw new Error(`${JWT_ERROR.NOT_SUPPORTED}: No supported signature types for algorithm ${alg}`);\n    }\n\n    let didResult;\n    return Promise.resolve(resolver.resolve(issuer, {\n      accept: DID_JSON\n    })).then(function (result) {\n      // support legacy resolvers that do not produce DIDResolutionResult\n      if (Object.getOwnPropertyNames(result).indexOf('didDocument') === -1) {\n        didResult = {\n          didDocument: result,\n          didDocumentMetadata: {},\n          didResolutionMetadata: {\n            contentType: DID_JSON\n          }\n        };\n      } else {\n        didResult = result;\n      }\n\n      if (didResult.didResolutionMetadata?.error || didResult.didDocument == null) {\n        const {\n          error,\n          message\n        } = didResult.didResolutionMetadata;\n        throw new Error(`${JWT_ERROR.RESOLVER_ERROR}: Unable to resolve DID document for ${issuer}: ${error}, ${message || ''}`);\n      }\n\n      const getPublicKeyById = (verificationMethods, pubid) => {\n        const filtered = verificationMethods.filter(({\n          id\n        }) => pubid === id);\n        return filtered.length > 0 ? filtered[0] : null;\n      };\n\n      let publicKeysToCheck = [...(didResult?.didDocument?.verificationMethod || []), ...(didResult?.didDocument?.publicKey || [])];\n\n      if (typeof proofPurpose === 'string') {\n        // support legacy DID Documents that do not list assertionMethod\n        if (proofPurpose.startsWith('assertion') && !Object.getOwnPropertyNames(didResult?.didDocument).includes('assertionMethod')) {\n          didResult.didDocument = { ...didResult.didDocument\n          };\n          didResult.didDocument.assertionMethod = [...publicKeysToCheck.map(pk => pk.id)];\n        }\n\n        publicKeysToCheck = (didResult.didDocument[proofPurpose] || []).map(verificationMethod => {\n          if (typeof verificationMethod === 'string') {\n            return getPublicKeyById(publicKeysToCheck, verificationMethod);\n          } else if (typeof verificationMethod.publicKey === 'string') {\n            // this is a legacy format\n            return getPublicKeyById(publicKeysToCheck, verificationMethod.publicKey);\n          } else {\n            return verificationMethod;\n          }\n        }).filter(key => key != null);\n      }\n\n      const authenticators = publicKeysToCheck.filter(({\n        type\n      }) => types.find(supported => supported === type));\n\n      if (typeof proofPurpose === 'string' && (!authenticators || authenticators.length === 0)) {\n        throw new Error(`${JWT_ERROR.NO_SUITABLE_KEYS}: DID document for ${issuer} does not have public keys suitable for ${alg} with ${proofPurpose} purpose`);\n      }\n\n      if (!authenticators || authenticators.length === 0) {\n        throw new Error(`${JWT_ERROR.NO_SUITABLE_KEYS}: DID document for ${issuer} does not have public keys for ${alg}`);\n      }\n\n      return {\n        authenticators,\n        issuer,\n        didResolutionResult: didResult\n      };\n    });\n  } catch (e) {\n    return Promise.reject(e);\n  }\n};\n\n/**\n *  Verifies given JWT. If the JWT is valid, the promise returns an object including the JWT, the payload of the JWT,\n *  and the DID document of the issuer of the JWT.\n *\n *  @example\n *  ```ts\n *  verifyJWT(\n *      'did:uport:eyJ0eXAiOiJKV1QiLCJhbGciOiJFUzI1NksifQ.eyJyZXF1Z....',\n *      {audience: '5A8bRWU3F7j3REx3vkJ...', callbackUrl: 'https://...'}\n *    ).then(obj => {\n *        const did = obj.did // DID of signer\n *        const payload = obj.payload\n *        const doc = obj.didResolutionResult.didDocument // DID Document of issuer\n *        const jwt = obj.jwt\n *        const signerKeyId = obj.signer.id // ID of key in DID document that signed JWT\n *        ...\n *    })\n *  ```\n *\n *  @param    {String}            jwt                a JSON Web Token to verify\n *  @param    {Object}            [options]           an unsigned credential object\n *  @param    {Boolean}           options.auth        Require signer to be listed in the authentication section of the\n *   DID document (for Authentication purposes)\n *  @param    {String}            options.audience    DID of the recipient of the JWT\n *  @param    {String}            options.callbackUrl callback url in JWT\n *  @return   {Promise<Object, Error>}               a promise which resolves with a response object or rejects with an\n *   error\n */\nconst verifyJWT = function (jwt, options = {\n  resolver: undefined,\n  auth: undefined,\n  audience: undefined,\n  callbackUrl: undefined,\n  skewTime: undefined,\n  proofPurpose: undefined,\n  policies: {},\n  didAuthenticator: undefined\n}) {\n  try {\n    function _temp7() {\n      let _exit;\n\n      function _temp5(_result) {\n        if (_exit) ;\n\n        if (signer) {\n          const now = typeof options.policies?.now === 'number' ? options.policies.now : Math.floor(Date.now() / 1000);\n          const skewTime = typeof options.skewTime !== 'undefined' && options.skewTime >= 0 ? options.skewTime : NBF_SKEW;\n          const nowSkewed = now + skewTime;\n\n          if (options.policies?.nbf !== false && payload.nbf) {\n            if (payload.nbf > nowSkewed) {\n              throw new Error(`${JWT_ERROR.INVALID_JWT}: JWT not valid before nbf: ${payload.nbf}`);\n            }\n          } else if (options.policies?.iat !== false && payload.iat && payload.iat > nowSkewed) {\n            throw new Error(`${JWT_ERROR.INVALID_JWT}: JWT not valid yet (issued in the future) iat: ${payload.iat}`);\n          }\n\n          if (options.policies?.exp !== false && payload.exp && payload.exp <= now - skewTime) {\n            throw new Error(`${JWT_ERROR.INVALID_JWT}: JWT has expired: exp: ${payload.exp} < now: ${now}`);\n          }\n\n          if (options.policies?.aud !== false && payload.aud) {\n            if (!options.audience && !options.callbackUrl) {\n              throw new Error(`${JWT_ERROR.INVALID_AUDIENCE}: JWT audience is required but your app address has not been configured`);\n            }\n\n            const audArray = Array.isArray(payload.aud) ? payload.aud : [payload.aud];\n            const matchedAudience = audArray.find(item => options.audience === item || options.callbackUrl === item);\n\n            if (typeof matchedAudience === 'undefined') {\n              throw new Error(`${JWT_ERROR.INVALID_AUDIENCE}: JWT audience does not match your DID or callback url`);\n            }\n          }\n\n          return {\n            verified: true,\n            payload,\n            didResolutionResult,\n            issuer,\n            signer,\n            jwt,\n            policies: options.policies\n          };\n        }\n\n        throw new Error(`${JWT_ERROR.INVALID_SIGNATURE}: JWT not valid. issuer DID document does not contain a verificationMethod that matches the signature.`);\n      }\n\n      const {\n        did\n      } = (0,did_resolver__WEBPACK_IMPORTED_MODULE_11__.parse)(didUrl);\n      let signer = null;\n\n      const _temp4 = function () {\n        if (did !== didUrl) {\n          const authenticator = authenticators.find(auth => auth.id === didUrl);\n\n          if (!authenticator) {\n            throw new Error(`${JWT_ERROR.INVALID_JWT}: No authenticator found for did URL ${didUrl}`);\n          }\n\n          return Promise.resolve(verifyProof(jwt, {\n            payload,\n            header,\n            signature,\n            data\n          }, authenticator, options)).then(function (_verifyProof) {\n            signer = _verifyProof;\n          });\n        } else {\n          let i = 0;\n          return _for$1(function () {\n            return !_exit && !signer && i < authenticators.length;\n          }, void 0, function () {\n            function _temp3(_result2) {\n              if (_exit) ;\n              i++;\n            }\n\n            const authenticator = authenticators[i];\n\n            const _temp2 = _catch(function () {\n              return Promise.resolve(verifyProof(jwt, {\n                payload,\n                header,\n                signature,\n                data\n              }, authenticator, options)).then(function (_verifyProof2) {\n                signer = _verifyProof2;\n              });\n            }, function (e) {\n              if (!e.message.includes(JWT_ERROR.INVALID_SIGNATURE) || i === authenticators.length - 1) throw e;\n            });\n\n            return _temp2 && _temp2.then ? _temp2.then(_temp3) : _temp3(_temp2);\n          });\n        }\n      }();\n\n      return _temp4 && _temp4.then ? _temp4.then(_temp5) : _temp5(_temp4);\n    }\n\n    if (!options.resolver) throw new Error('missing_resolver: No DID resolver has been configured');\n    const {\n      payload,\n      header,\n      signature,\n      data\n    } = decodeJWT(jwt, false);\n    const proofPurpose = Object.prototype.hasOwnProperty.call(options, 'auth') ? options.auth ? 'authentication' : undefined : options.proofPurpose;\n    let didUrl;\n\n    if (!payload.iss && !payload.client_id) {\n      throw new Error(`${JWT_ERROR.INVALID_JWT}: JWT iss or client_id are required`);\n    }\n\n    if (options.didAuthenticator) {\n      didUrl = options.didAuthenticator.issuer;\n    } else if (payload.iss === SELF_ISSUED_V2 || payload.iss === SELF_ISSUED_V2_VC_INTEROP) {\n      if (!payload.sub) {\n        throw new Error(`${JWT_ERROR.INVALID_JWT}: JWT sub is required`);\n      }\n\n      if (typeof payload.sub_jwk === 'undefined') {\n        didUrl = payload.sub;\n      } else {\n        didUrl = (header.kid || '').split('#')[0];\n      }\n    } else if (payload.iss === SELF_ISSUED_V0_1) {\n      if (!payload.did) {\n        throw new Error(`${JWT_ERROR.INVALID_JWT}: JWT did is required`);\n      }\n\n      didUrl = payload.did;\n    } else if (!payload.iss && payload.scope === 'openid' && payload.redirect_uri) {\n      // SIOP Request payload\n      // https://identity.foundation/jwt-vc-presentation-profile/#self-issued-op-request-object\n      if (!payload.client_id) {\n        throw new Error(`${JWT_ERROR.INVALID_JWT}: JWT client_id is required`);\n      }\n\n      didUrl = payload.client_id;\n    } else {\n      didUrl = payload.iss;\n    }\n\n    if (!didUrl) {\n      throw new Error(`${JWT_ERROR.INVALID_JWT}: No DID has been found in the JWT`);\n    }\n\n    let authenticators;\n    let issuer;\n    let didResolutionResult;\n\n    const _temp6 = function () {\n      if (options.didAuthenticator) {\n        ({\n          didResolutionResult,\n          authenticators,\n          issuer\n        } = options.didAuthenticator);\n      } else {\n        return Promise.resolve(resolveAuthenticator(options.resolver, header.alg, didUrl, proofPurpose)).then(function (_resolveAuthenticator) {\n          ({\n            didResolutionResult,\n            authenticators,\n            issuer\n          } = _resolveAuthenticator);\n          // Add to options object for recursive reference\n          options.didAuthenticator = {\n            didResolutionResult,\n            authenticators,\n            issuer\n          };\n        });\n      }\n    }();\n\n    return Promise.resolve(_temp6 && _temp6.then ? _temp6.then(_temp7) : _temp7(_temp6));\n  } catch (e) {\n    return Promise.reject(e);\n  }\n};\n\n/**\n *  Creates a multi-signature signed JWT given multiple issuers and their corresponding signers, and a payload for\n * which the signature is over.\n *\n *  @example\n *  const signer = ES256KSigner(process.env.PRIVATE_KEY)\n *  createJWT({address: '5A8bRWU3F7j3REx3vkJ...', signer}, {key1: 'value', key2: ..., ... }).then(jwt => {\n *      ...\n *  })\n *\n *  @param    {Object}            payload               payload object\n *  @param    {Object}            [options]             an unsigned credential object\n *  @param    {boolean}           options.expiresIn     optional flag to denote the expiration time\n *  @param    {boolean}           options.canonicalize  optional flag to canonicalize header and payload before signing\n *  @param    {Object[]}          issuers               array of the issuers, their signers and algorithms\n *  @param    {string}            issuers[].issuer      The DID of the issuer (signer) of JWT\n *  @param    {Signer}            issuers[].signer      a `Signer` function, Please see `ES256KSigner` or `EdDSASigner`\n *  @param    {String}            issuers[].alg         [DEPRECATED] The JWT signing algorithm to use. Supports:\n *   [ES256K, ES256K-R, Ed25519, EdDSA], Defaults to: ES256K. Please use `header.alg` to specify the algorithm\n *  @return   {Promise<Object, Error>}                  a promise which resolves with a signed JSON Web Token or\n *   rejects with an error\n */\nconst createMultisignatureJWT = function (payload, {\n  expiresIn,\n  canonicalize\n}, issuers) {\n  try {\n    if (issuers.length === 0) throw new Error('invalid_argument: must provide one or more issuers');\n    let payloadResult = payload;\n    let jwt = '';\n\n    const _temp = _forTo$1(issuers, function (i) {\n      const issuer = issuers[i];\n      const header = {\n        typ: 'JWT',\n        alg: issuer.alg\n      }; // Create nested JWT\n      // See Point 5 of https://www.rfc-editor.org/rfc/rfc7519#section-7.1\n      // After the first JWT is created (the first JWS), the next JWT is created by inputting the previous JWT as the\n      // payload\n\n      if (i !== 0) {\n        header.cty = 'JWT';\n      }\n\n      return Promise.resolve(createJWT(payloadResult, { ...issuer,\n        canonicalize,\n        expiresIn\n      }, header)).then(function (_createJWT) {\n        jwt = _createJWT;\n        payloadResult = {\n          jwt\n        };\n      });\n    });\n\n    return Promise.resolve(_temp && _temp.then ? _temp.then(function () {\n      return jwt;\n    }) : jwt);\n  } catch (e) {\n    return Promise.reject(e);\n  }\n};\n\n/**\n *  Creates a signed JWT given an address which becomes the issuer, a signer, and a payload for which the signature is\n * over.\n *\n *  @example\n *  const signer = ES256KSigner(process.env.PRIVATE_KEY)\n *  createJWT({address: '5A8bRWU3F7j3REx3vkJ...', signer}, {key1: 'value', key2: ..., ... }).then(jwt => {\n *      ...\n *  })\n *\n *  @param    {Object}            payload               payload object\n *  @param    {Object}            [options]             an unsigned credential object\n *  @param    {String}            options.issuer        The DID of the issuer (signer) of JWT\n *  @param    {String}            options.alg           [DEPRECATED] The JWT signing algorithm to use. Supports:\n *   [ES256K, ES256K-R, Ed25519, EdDSA], Defaults to: ES256K. Please use `header.alg` to specify the algorithm\n *  @param    {Signer}            options.signer        a `Signer` function, Please see `ES256KSigner` or `EdDSASigner`\n *  @param    {boolean}           options.canonicalize  optional flag to canonicalize header and payload before signing\n *  @param    {Object}            header                optional object to specify or customize the JWT header\n *  @return   {Promise<Object, Error>}                  a promise which resolves with a signed JSON Web Token or\n *   rejects with an error\n */\nconst createJWT = function (payload, {\n  issuer,\n  signer,\n  alg,\n  expiresIn,\n  canonicalize\n}, header = {}) {\n  try {\n    if (!signer) throw new Error('missing_signer: No Signer functionality has been configured');\n    if (!issuer) throw new Error('missing_issuer: No issuing DID has been configured');\n    if (!header.typ) header.typ = 'JWT';\n    if (!header.alg) header.alg = alg;\n    const timestamps = {\n      iat: Math.floor(Date.now() / 1000),\n      exp: undefined\n    };\n\n    if (expiresIn) {\n      if (typeof expiresIn === 'number') {\n        timestamps.exp = (payload.nbf || timestamps.iat) + Math.floor(expiresIn);\n      } else {\n        throw new Error('invalid_argument: JWT expiresIn is not a number');\n      }\n    }\n\n    const fullPayload = { ...timestamps,\n      ...payload,\n      iss: issuer\n    };\n    return createJWS(fullPayload, signer, header, {\n      canonicalize\n    });\n  } catch (e) {\n    return Promise.reject(e);\n  }\n};\n\n/**\n *  Creates a signed JWS given a payload, a signer, and an optional header.\n *\n *  @example\n *  const signer = ES256KSigner(process.env.PRIVATE_KEY)\n *  const jws = await createJWS({ my: 'payload' }, signer)\n *\n *  @param    {Object}            payload           payload object\n *  @param    {Signer}            signer            a signer, see `ES256KSigner or `EdDSASigner`\n *  @param    {Object}            header            optional object to specify or customize the JWS header\n *  @param    {Object}            options           can be used to trigger automatic canonicalization of header and\n *                                                    payload properties\n *  @return   {Promise<string>}                     a Promise which resolves to a JWS string or rejects with an error\n */\nconst createJWS = function (payload, signer, header = {}, options = {}) {\n  try {\n    if (!header.alg) header.alg = defaultAlg;\n    const encodedPayload = typeof payload === 'string' ? payload : encodeSection(payload, options.canonicalize);\n    const signingInput = [encodeSection(header, options.canonicalize), encodedPayload].join('.');\n    const jwtSigner = SignerAlg(header.alg);\n    return Promise.resolve(jwtSigner(signingInput, signer)).then(function (signature) {\n      // JWS Compact Serialization\n      // https://www.rfc-editor.org/rfc/rfc7515#section-7.1\n      return [signingInput, signature].join('.');\n    });\n  } catch (e) {\n    return Promise.reject(e);\n  }\n};\nconst SELF_ISSUED_V2 = 'https://self-issued.me/v2';\nconst SELF_ISSUED_V2_VC_INTEROP = 'https://self-issued.me/v2/openid-vc'; // https://identity.foundation/jwt-vc-presentation-profile/#id-token-validation\n\nconst SELF_ISSUED_V0_1 = 'https://self-issued.me';\nconst defaultAlg = 'ES256K';\nconst DID_JSON = 'application/did+json'; // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\nfunction encodeSection(data, shouldCanonicalize = false) {\n  if (shouldCanonicalize) {\n    return encodeBase64url(canonicalize__WEBPACK_IMPORTED_MODULE_3__(data));\n  } else {\n    return encodeBase64url(JSON.stringify(data));\n  }\n}\n\nconst NBF_SKEW = 300;\n\nfunction decodeJWS(jws) {\n  const parts = jws.match(/^([a-zA-Z0-9_-]+)\\.([a-zA-Z0-9_-]+)\\.([a-zA-Z0-9_-]+)$/);\n\n  if (parts) {\n    return {\n      header: JSON.parse(decodeBase64url(parts[1])),\n      payload: parts[2],\n      signature: parts[3],\n      data: `${parts[1]}.${parts[2]}`\n    };\n  }\n\n  throw new Error('invalid_argument: Incorrect format JWS');\n}\n/**\n *  Decodes a JWT and returns an object representing the payload\n *\n *  @example\n *  decodeJWT('eyJ0eXAiOiJKV1QiLCJhbGciOiJFUzI1NksifQ.eyJpYXQiOjE1...')\n *\n *  @param    {String}            jwt                a JSON Web Token to verify\n * @param    {Object}            [recurse]          whether to recurse into the payload to decode any nested JWTs\n *  @return   {Object}                               a JS object representing the decoded JWT\n */\n\n\nfunction decodeJWT(jwt, recurse = true) {\n  if (!jwt) throw new Error('invalid_argument: no JWT passed into decodeJWT');\n\n  try {\n    const jws = decodeJWS(jwt);\n    const decodedJwt = Object.assign(jws, {\n      payload: JSON.parse(decodeBase64url(jws.payload))\n    });\n    const iss = decodedJwt.payload.iss;\n\n    if (decodedJwt.header.cty === 'JWT' && recurse) {\n      const innerDecodedJwt = decodeJWT(decodedJwt.payload.jwt);\n      if (innerDecodedJwt.payload.iss !== iss) throw new Error(`${JWT_ERROR.INVALID_JWT}: multiple issuers`);\n      return innerDecodedJwt;\n    }\n\n    return decodedJwt;\n  } catch (e) {\n    throw new Error(`invalid_argument: ${JWT_ERROR.INVALID_JWT}: ${e}`);\n  }\n}\nfunction verifyJWTDecoded({\n  header,\n  payload,\n  data,\n  signature\n}, pubKeys) {\n  if (!Array.isArray(pubKeys)) pubKeys = [pubKeys];\n  const iss = payload.iss;\n  let recurse = true;\n\n  do {\n    if (iss !== payload.iss) throw new Error(`${JWT_ERROR.INVALID_JWT}: multiple issuers`);\n\n    try {\n      const result = VerifierAlgorithm(header.alg)(data, signature, pubKeys);\n      return result;\n    } catch (e) {\n      if (!e.message.startsWith(JWT_ERROR.INVALID_SIGNATURE)) throw e;\n    } // TODO probably best to create copy objects than replace reference objects\n\n\n    if (header.cty !== 'JWT') {\n      recurse = false;\n    } else {\n      ({\n        payload,\n        header,\n        signature,\n        data\n      } = decodeJWT(payload.jwt, false));\n    }\n  } while (recurse);\n\n  throw new Error(`${JWT_ERROR.INVALID_SIGNATURE}: no matching public key found`);\n}\nfunction verifyJWSDecoded({\n  header,\n  data,\n  signature\n}, pubKeys) {\n  if (!Array.isArray(pubKeys)) pubKeys = [pubKeys];\n  const signer = VerifierAlgorithm(header.alg)(data, signature, pubKeys);\n  return signer;\n}\n/**\n *  Verifies given JWS. If the JWS is valid, returns the public key that was\n *  used to sign the JWS, or throws an `Error` if none of the `pubKeys` match.\n *\n *  @example\n *  const pubKey = verifyJWS('eyJ0eXAiOiJKV1QiLCJhbGciOiJFUzI1NksifQ.eyJyZXF1Z....', { publicKeyHex: '0x12341...' })\n *\n *  @param    {String}                          jws         A JWS string to verify\n *  @param    {Array<VerificationMethod> | VerificationMethod}    pubKeys     The public keys used to verify the JWS\n *  @return   {VerificationMethod}                       The public key used to sign the JWS\n */\n\nfunction verifyJWS(jws, pubKeys) {\n  const jwsDecoded = decodeJWS(jws);\n  return verifyJWSDecoded(jwsDecoded, pubKeys);\n}\n\nconst _iteratorSymbol = typeof Symbol !== \"undefined\" ? Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\")) : \"@@iterator\";\n\nfunction _settle(pact, state, value) {\n  if (!pact.s) {\n    if (value instanceof _Pact) {\n      if (value.s) {\n        if (state & 1) {\n          state = value.s;\n        }\n\n        value = value.v;\n      } else {\n        value.o = _settle.bind(null, pact, state);\n        return;\n      }\n    }\n\n    if (value && value.then) {\n      value.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n      return;\n    }\n\n    pact.s = state;\n    pact.v = value;\n    const observer = pact.o;\n\n    if (observer) {\n      observer(pact);\n    }\n  }\n}\n\nconst _Pact = /*#__PURE__*/function () {\n  function _Pact() {}\n\n  _Pact.prototype.then = function (onFulfilled, onRejected) {\n    const result = new _Pact();\n    const state = this.s;\n\n    if (state) {\n      const callback = state & 1 ? onFulfilled : onRejected;\n\n      if (callback) {\n        try {\n          _settle(result, 1, callback(this.v));\n        } catch (e) {\n          _settle(result, 2, e);\n        }\n\n        return result;\n      } else {\n        return this;\n      }\n    }\n\n    this.o = function (_this) {\n      try {\n        const value = _this.v;\n\n        if (_this.s & 1) {\n          _settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n        } else if (onRejected) {\n          _settle(result, 1, onRejected(value));\n        } else {\n          _settle(result, 2, value);\n        }\n      } catch (e) {\n        _settle(result, 2, e);\n      }\n    };\n\n    return result;\n  };\n\n  return _Pact;\n}();\n\nfunction _isSettledPact(thenable) {\n  return thenable instanceof _Pact && thenable.s & 1;\n}\n\nfunction _forTo(array, body, check) {\n  var i = -1,\n      pact,\n      reject;\n\n  function _cycle(result) {\n    try {\n      while (++i < array.length && (!check || !check())) {\n        result = body(i);\n\n        if (result && result.then) {\n          if (_isSettledPact(result)) {\n            result = result.v;\n          } else {\n            result.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n            return;\n          }\n        }\n      }\n\n      if (pact) {\n        _settle(pact, 1, result);\n      } else {\n        pact = result;\n      }\n    } catch (e) {\n      _settle(pact || (pact = new _Pact()), 2, e);\n    }\n  }\n\n  _cycle();\n\n  return pact;\n}\n\nfunction _forOf(target, body, check) {\n  if (typeof target[_iteratorSymbol] === \"function\") {\n    var iterator = target[_iteratorSymbol](),\n        step,\n        pact,\n        reject;\n\n    function _cycle(result) {\n      try {\n        while (!(step = iterator.next()).done && (!check || !check())) {\n          result = body(step.value);\n\n          if (result && result.then) {\n            if (_isSettledPact(result)) {\n              result = result.v;\n            } else {\n              result.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n              return;\n            }\n          }\n        }\n\n        if (pact) {\n          _settle(pact, 1, result);\n        } else {\n          pact = result;\n        }\n      } catch (e) {\n        _settle(pact || (pact = new _Pact()), 2, e);\n      }\n    }\n\n    _cycle();\n\n    if (iterator.return) {\n      var _fixup = function (value) {\n        try {\n          if (!step.done) {\n            iterator.return();\n          }\n        } catch (e) {}\n\n        return value;\n      };\n\n      if (pact && pact.then) {\n        return pact.then(_fixup, function (e) {\n          throw _fixup(e);\n        });\n      }\n\n      _fixup();\n    }\n\n    return pact;\n  } // No support for Symbol.iterator\n\n\n  if (!(\"length\" in target)) {\n    throw new TypeError(\"Object is not iterable\");\n  } // Handle live collections properly\n\n\n  var values = [];\n\n  for (var i = 0; i < target.length; i++) {\n    values.push(target[i]);\n  }\n\n  return _forTo(values, function (i) {\n    return body(values[i]);\n  }, check);\n}\n\nfunction _for(test, update, body) {\n  var stage;\n\n  for (;;) {\n    var shouldContinue = test();\n\n    if (_isSettledPact(shouldContinue)) {\n      shouldContinue = shouldContinue.v;\n    }\n\n    if (!shouldContinue) {\n      return result;\n    }\n\n    if (shouldContinue.then) {\n      stage = 0;\n      break;\n    }\n\n    var result = body();\n\n    if (result && result.then) {\n      if (_isSettledPact(result)) {\n        result = result.s;\n      } else {\n        stage = 1;\n        break;\n      }\n    }\n\n    if (update) {\n      var updateValue = update();\n\n      if (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n        stage = 2;\n        break;\n      }\n    }\n  }\n\n  var pact = new _Pact();\n\n  var reject = _settle.bind(null, pact, 2);\n\n  (stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n  return pact;\n\n  function _resumeAfterBody(value) {\n    result = value;\n\n    do {\n      if (update) {\n        updateValue = update();\n\n        if (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n          updateValue.then(_resumeAfterUpdate).then(void 0, reject);\n          return;\n        }\n      }\n\n      shouldContinue = test();\n\n      if (!shouldContinue || _isSettledPact(shouldContinue) && !shouldContinue.v) {\n        _settle(pact, 1, result);\n\n        return;\n      }\n\n      if (shouldContinue.then) {\n        shouldContinue.then(_resumeAfterTest).then(void 0, reject);\n        return;\n      }\n\n      result = body();\n\n      if (_isSettledPact(result)) {\n        result = result.v;\n      }\n    } while (!result || !result.then);\n\n    result.then(_resumeAfterBody).then(void 0, reject);\n  }\n\n  function _resumeAfterTest(shouldContinue) {\n    if (shouldContinue) {\n      result = body();\n\n      if (result && result.then) {\n        result.then(_resumeAfterBody).then(void 0, reject);\n      } else {\n        _resumeAfterBody(result);\n      }\n    } else {\n      _settle(pact, 1, result);\n    }\n  }\n\n  function _resumeAfterUpdate() {\n    if (shouldContinue = test()) {\n      if (shouldContinue.then) {\n        shouldContinue.then(_resumeAfterTest).then(void 0, reject);\n      } else {\n        _resumeAfterTest(shouldContinue);\n      }\n    } else {\n      _settle(pact, 1, result);\n    }\n  }\n}\n\nfunction validateJWE(jwe) {\n  if (!(jwe.protected && jwe.iv && jwe.ciphertext && jwe.tag)) {\n    throw new Error('bad_jwe: missing properties');\n  }\n\n  if (jwe.recipients) {\n    jwe.recipients.map(rec => {\n      if (!(rec.header && rec.encrypted_key)) {\n        throw new Error('bad_jwe: malformed recipients');\n      }\n    });\n  }\n}\n\nfunction encodeJWE({\n  ciphertext,\n  tag,\n  iv,\n  protectedHeader,\n  recipient\n}, aad) {\n  const jwe = {\n    protected: protectedHeader,\n    iv: bytesToBase64url(iv ?? new Uint8Array(0)),\n    ciphertext: bytesToBase64url(ciphertext),\n    tag: bytesToBase64url(tag ?? new Uint8Array(0))\n  };\n  if (aad) jwe.aad = bytesToBase64url(aad);\n  if (recipient) jwe.recipients = [recipient];\n  return jwe;\n}\n\nconst decryptJWE = function (jwe, decrypter) {\n  try {\n    let _exit;\n\n    function _temp5(_result) {\n      if (_exit) ;\n      if (cleartext === null) throw new Error('failure: Failed to decrypt');\n      return cleartext;\n    }\n\n    validateJWE(jwe);\n    const protHeader = JSON.parse(decodeBase64url(jwe.protected));\n    if (protHeader.enc !== decrypter.enc) throw new Error(`not_supported: Decrypter does not supported: '${protHeader.enc}'`);\n    const sealed = toSealed(jwe.ciphertext, jwe.tag);\n    const aad = stringToBytes(jwe.aad ? `${jwe.protected}.${jwe.aad}` : jwe.protected);\n    let cleartext = null;\n\n    const _temp4 = function () {\n      if (protHeader.alg === 'dir' && decrypter.alg === 'dir') {\n        return Promise.resolve(decrypter.decrypt(sealed, base64ToBytes(jwe.iv), aad)).then(function (_decrypter$decrypt) {\n          cleartext = _decrypter$decrypt;\n        });\n      } else return function () {\n        if (!jwe.recipients || jwe.recipients.length === 0) {\n          throw new Error('bad_jwe: missing recipients');\n        } else {\n          let i = 0;\n          return _for(function () {\n            return !cleartext && i < jwe.recipients.length;\n          }, function () {\n            return i++;\n          }, function () {\n            const recipient = jwe.recipients[i];\n            Object.assign(recipient.header, protHeader);\n\n            const _temp3 = function () {\n              if (recipient.header.alg === decrypter.alg) {\n                return Promise.resolve(decrypter.decrypt(sealed, base64ToBytes(jwe.iv), aad, recipient)).then(function (_decrypter$decrypt2) {\n                  cleartext = _decrypter$decrypt2;\n                });\n              }\n            }();\n\n            if (_temp3 && _temp3.then) return _temp3.then(function () {});\n          });\n        }\n      }();\n    }();\n\n    return Promise.resolve(_temp4 && _temp4.then ? _temp4.then(_temp5) : _temp5(_temp4));\n  } catch (e) {\n    return Promise.reject(e);\n  }\n};\nconst createJWE = function (cleartext, encrypters, protectedHeader = {}, aad, useSingleEphemeralKey = false) {\n  try {\n    if (encrypters[0].alg === 'dir') {\n      if (encrypters.length > 1) throw new Error('not_supported: Can only do \"dir\" encryption to one key.');\n      return Promise.resolve(encrypters[0].encrypt(cleartext, protectedHeader, aad)).then(function (encryptionResult) {\n        return encodeJWE(encryptionResult, aad);\n      });\n    } else {\n      const tmpEnc = encrypters[0].enc;\n\n      if (!encrypters.reduce((acc, encrypter) => acc && encrypter.enc === tmpEnc, true)) {\n        throw new Error('invalid_argument: Incompatible encrypters passed');\n      }\n\n      let cek;\n      let jwe;\n      let epk;\n\n      if (useSingleEphemeralKey) {\n        epk = encrypters[0].genEpk?.();\n        const alg = encrypters[0].alg;\n        protectedHeader = { ...protectedHeader,\n          alg,\n          epk: epk?.publicKeyJWK\n        };\n      }\n\n      const _temp2 = _forOf(encrypters, function (encrypter) {\n        const _temp = function () {\n          if (!cek) {\n            return Promise.resolve(encrypter.encrypt(cleartext, protectedHeader, aad, epk)).then(function (encryptionResult) {\n              cek = encryptionResult.cek;\n              jwe = encodeJWE(encryptionResult, aad);\n            });\n          } else {\n            return Promise.resolve(encrypter.encryptCek?.(cek, epk)).then(function (recipient) {\n              if (recipient) {\n                jwe?.recipients?.push(recipient);\n              }\n            });\n          }\n        }();\n\n        if (_temp && _temp.then) return _temp.then(function () {});\n      });\n\n      return Promise.resolve(_temp2 && _temp2.then ? _temp2.then(function () {\n        return jwe;\n      }) : jwe);\n    }\n  } catch (e) {\n    return Promise.reject(e);\n  }\n};\n\nfunction xc20pEncrypter(key) {\n  return (cleartext, aad) => {\n    const iv = (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_12__.randomBytes)(24);\n    const cipher = (0,_noble_ciphers_chacha__WEBPACK_IMPORTED_MODULE_13__.xchacha20poly1305)(key, iv, aad);\n    const sealed = cipher.encrypt(cleartext);\n    return {\n      ciphertext: sealed.subarray(0, sealed.length - 16),\n      tag: sealed.subarray(sealed.length - 16),\n      iv\n    };\n  };\n}\nfunction xc20pDirEncrypter(key) {\n  const encrypt = function (cleartext, protectedHeader = {}, aad) {\n    try {\n      const protHeader = encodeBase64url(JSON.stringify(Object.assign({\n        alg\n      }, protectedHeader, {\n        enc\n      })));\n      const encodedAad = stringToBytes(aad ? `${protHeader}.${bytesToBase64url(aad)}` : protHeader);\n      return Promise.resolve({ ...xc20pEncrypt(cleartext, encodedAad),\n        protectedHeader: protHeader\n      });\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n\n  const xc20pEncrypt = xc20pEncrypter(key);\n  const enc = 'XC20P';\n  const alg = 'dir';\n  return {\n    alg,\n    enc,\n    encrypt\n  };\n}\nfunction xc20pDirDecrypter(key) {\n  const decrypt = function (sealed, iv, aad) {\n    try {\n      try {\n        return Promise.resolve((0,_noble_ciphers_chacha__WEBPACK_IMPORTED_MODULE_13__.xchacha20poly1305)(key, iv, aad).decrypt(sealed));\n      } catch (error) {\n        return Promise.resolve(null);\n      }\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n\n  return {\n    alg: 'dir',\n    enc: 'XC20P',\n    decrypt\n  };\n}\n\nconst createX25519EcdhEsKek = function (recipientPublicKey, senderSecret, // unused\nalg, apu, // unused\napv, ephemeralKeyPair) {\n  try {\n    const crv = 'X25519';\n    const keyLen = 256;\n    const ephemeral = ephemeralKeyPair ? generateKeyPairFromSeed(ephemeralKeyPair.secretKey) : generateKeyPair();\n    const epk = {\n      kty: 'OKP',\n      crv,\n      x: bytesToBase64url(ephemeral.publicKey)\n    };\n    const sharedSecret = _noble_curves_ed25519__WEBPACK_IMPORTED_MODULE_6__.x25519.getSharedSecret(ephemeral.secretKey, recipientPublicKey); // Key Encryption Key\n\n    const consumerInfo = base64ToBytes(apv ?? '');\n    const kek = concatKDF(sharedSecret, keyLen, alg, undefined, consumerInfo);\n    return Promise.resolve({\n      epk,\n      kek\n    });\n  } catch (e) {\n    return Promise.reject(e);\n  }\n};\nconst computeX25519EcdhEsKek = function (recipient, receiverSecret, alg) {\n  try {\n    function _temp2() {\n      // Key Encryption Key\n      let producerInfo = undefined;\n      let consumerInfo = undefined;\n      if (recipient.header.apu) producerInfo = base64ToBytes(recipient.header.apu);\n      if (recipient.header.apv) consumerInfo = base64ToBytes(recipient.header.apv);\n      return concatKDF(sharedSecret, keyLen, alg, producerInfo, consumerInfo);\n    }\n\n    const crv = 'X25519';\n    const keyLen = 256;\n    const header = recipient.header;\n    if (header.epk?.crv !== crv || typeof header.epk.x == 'undefined') return Promise.resolve(null);\n    const publicKey = base64ToBytes(header.epk.x);\n    let sharedSecret;\n\n    const _temp = function () {\n      if (receiverSecret instanceof Uint8Array) {\n        sharedSecret = _noble_curves_ed25519__WEBPACK_IMPORTED_MODULE_6__.x25519.getSharedSecret(receiverSecret, publicKey);\n      } else {\n        return Promise.resolve(receiverSecret(publicKey)).then(function (_receiverSecret) {\n          sharedSecret = _receiverSecret;\n        });\n      }\n    }();\n\n    return Promise.resolve(_temp && _temp.then ? _temp.then(_temp2) : _temp2(_temp));\n  } catch (e) {\n    return Promise.reject(e);\n  }\n};\n\nconst createX25519Ecdh1PUv3Kek = function (recipientPublicKey, senderSecret, alg, // must be provided as this is the key agreement alg + the key wrapper alg, Example: 'ECDH-ES+A256KW'\napu, apv, ephemeralKeyPair) {\n  try {\n    function _temp4() {\n      const sharedSecret = new Uint8Array(zE.length + zS.length);\n      sharedSecret.set(zE);\n      sharedSecret.set(zS, zE.length);\n      let partyUInfo = new Uint8Array(0);\n      let partyVInfo = new Uint8Array(0);\n      if (apu) partyUInfo = base64ToBytes(apu);\n      if (apv) partyVInfo = base64ToBytes(apv); // Key Encryption Key\n\n      const kek = concatKDF(sharedSecret, keyLen, alg, partyUInfo, partyVInfo);\n      return {\n        epk,\n        kek\n      };\n    }\n\n    const crv = 'X25519';\n    const keyLen = 256;\n    const ephemeral = ephemeralKeyPair ? generateKeyPairFromSeed(ephemeralKeyPair.secretKey) : generateKeyPair();\n    const epk = {\n      kty: 'OKP',\n      crv,\n      x: bytesToBase64url(ephemeral.publicKey)\n    };\n    const zE = _noble_curves_ed25519__WEBPACK_IMPORTED_MODULE_6__.x25519.getSharedSecret(ephemeral.secretKey, recipientPublicKey); // ECDH-1PU requires additional shared secret between\n    // static key of sender and static key of recipient\n\n    let zS;\n\n    const _temp3 = function () {\n      if (senderSecret instanceof Uint8Array) {\n        zS = _noble_curves_ed25519__WEBPACK_IMPORTED_MODULE_6__.x25519.getSharedSecret(senderSecret, recipientPublicKey);\n      } else {\n        return Promise.resolve(senderSecret(recipientPublicKey)).then(function (_senderSecret) {\n          zS = _senderSecret;\n        });\n      }\n    }();\n\n    return Promise.resolve(_temp3 && _temp3.then ? _temp3.then(_temp4) : _temp4(_temp3));\n  } catch (e) {\n    return Promise.reject(e);\n  }\n};\nconst computeX25519Ecdh1PUv3Kek = function (recipient, recipientSecret, senderPublicKey, alg) {\n  try {\n    function _temp2() {\n      const sharedSecret = new Uint8Array(zE.length + zS.length);\n      sharedSecret.set(zE);\n      sharedSecret.set(zS, zE.length); // Key Encryption Key\n\n      let producerInfo;\n      let consumerInfo;\n      if (recipient.header.apu) producerInfo = base64ToBytes(recipient.header.apu);\n      if (recipient.header.apv) consumerInfo = base64ToBytes(recipient.header.apv);\n      return concatKDF(sharedSecret, keyLen, alg, producerInfo, consumerInfo);\n    }\n\n    const crv = 'X25519';\n    const keyLen = 256;\n    const header = recipient.header;\n    if (header.epk?.crv !== crv || typeof header.epk.x == 'undefined') return Promise.resolve(null); // ECDH-1PU requires additional shared secret between\n    // static key of sender and static key of recipient\n\n    const publicKey = base64ToBytes(header.epk.x);\n    let zE;\n    let zS;\n\n    const _temp = function () {\n      if (recipientSecret instanceof Uint8Array) {\n        zE = _noble_curves_ed25519__WEBPACK_IMPORTED_MODULE_6__.x25519.getSharedSecret(recipientSecret, publicKey);\n        zS = _noble_curves_ed25519__WEBPACK_IMPORTED_MODULE_6__.x25519.getSharedSecret(recipientSecret, senderPublicKey);\n      } else {\n        return Promise.resolve(recipientSecret(publicKey)).then(function (_recipientSecret) {\n          zE = _recipientSecret;\n          return Promise.resolve(recipientSecret(senderPublicKey)).then(function (_recipientSecret2) {\n            zS = _recipientSecret2;\n          });\n        });\n      }\n    }();\n\n    return Promise.resolve(_temp && _temp.then ? _temp.then(_temp2) : _temp2(_temp));\n  } catch (e) {\n    return Promise.reject(e);\n  }\n};\n\n/**\n * Wraps an X25519 secret key into an ECDH method that can be used to compute a shared secret with a public key.\n * @param mySecretKey A `Uint8Array` of length 32 representing the bytes of my secret key\n * @returns an `ECDH` method with the signature `(theirPublicKey: Uint8Array) => Promise<Uint8Array>`\n *\n * @throws 'invalid_argument:...' if the secret key size is wrong\n */\n\nfunction createX25519ECDH(mySecretKey) {\n  if (mySecretKey.length !== 32) {\n    throw new Error('invalid_argument: incorrect secret key length for X25519');\n  }\n\n  return function (theirPublicKey) {\n    try {\n      if (theirPublicKey.length !== 32) {\n        throw new Error('invalid_argument: incorrect publicKey key length for X25519');\n      }\n\n      return Promise.resolve(_noble_curves_ed25519__WEBPACK_IMPORTED_MODULE_6__.x25519.getSharedSecret(mySecretKey, theirPublicKey));\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n}\n\nfunction createFullEncrypter(recipientPublicKey, senderSecret, options = {}, kekCreator, keyWrapper, contentEncrypter) {\n  const encrypt = function (cleartext, protectedHeader = {}, aad, ephemeralKeyPair) {\n    try {\n      // we won't want alg to be set to dir from xc20pDirEncrypter\n      Object.assign(protectedHeader, {\n        alg: undefined\n      }); // Content Encryption Key\n\n      const cek = (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_12__.randomBytes)(32);\n      return Promise.resolve(encryptCek(cek, ephemeralKeyPair)).then(function (recipient) {\n        // getting an ephemeral key means the epk is set only once per all recipients\n        if (ephemeralKeyPair) {\n          protectedHeader.alg = `${kekCreator.alg}+${keyWrapper.alg}`;\n          protectedHeader.epk = ephemeralKeyPair.publicKeyJWK;\n        }\n\n        return Promise.resolve(contentEncrypter.from(cek).encrypt(cleartext, protectedHeader, aad)).then(function (_contentEncrypter$fro) {\n          return { ..._contentEncrypter$fro,\n            recipient,\n            cek\n          };\n        });\n      });\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n\n  const encryptCek = function (cek, ephemeralKeyPair) {\n    try {\n      return Promise.resolve(kekCreator.createKek(recipientPublicKey, senderSecret, `${kekCreator.alg}+${keyWrapper.alg}`, options.apu, options.apv, ephemeralKeyPair)).then(function ({\n        epk,\n        kek\n      }) {\n        return Promise.resolve(keyWrapper.from(kek).wrap(cek)).then(function (res) {\n          const recipient = {\n            encrypted_key: bytesToBase64url(res.ciphertext),\n            header: {}\n          };\n          if (res.iv) recipient.header.iv = bytesToBase64url(res.iv);\n          if (res.tag) recipient.header.tag = bytesToBase64url(res.tag);\n          if (options.kid) recipient.header.kid = options.kid;\n          if (options.apu) recipient.header.apu = options.apu;\n          if (options.apv) recipient.header.apv = options.apv;\n\n          if (!ephemeralKeyPair) {\n            recipient.header.alg = `${kekCreator.alg}+${keyWrapper.alg}`;\n            recipient.header.epk = epk;\n          }\n\n          return recipient;\n        });\n      });\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n\n  return {\n    alg: keyWrapper.alg,\n    enc: contentEncrypter.enc,\n    encrypt,\n    encryptCek,\n    genEpk: genX25519EphemeralKeyPair\n  };\n}\n\n/**\n * @deprecated Use\n *   {@link xc20pAuthEncrypterEcdh1PuV3x25519WithXc20PkwV2 | xc20pAuthEncrypterEcdh1PuV3x25519WithXc20PkwV2() } instead\n */\n\nconst resolveX25519Encrypters = function (dids, resolver) {\n  try {\n    const encryptersForDID = function (did, resolved = []) {\n      try {\n        return Promise.resolve(resolver.resolve(did)).then(function ({\n          didResolutionMetadata,\n          didDocument\n        }) {\n          function _temp2() {\n            const agreementKeys = didDocument.keyAgreement?.map(key => {\n              if (typeof key === 'string') {\n                return [...(didDocument.publicKey || []), ...(didDocument.verificationMethod || [])].find(pk => pk.id === key);\n              }\n\n              return key;\n            })?.filter(key => typeof key !== 'undefined');\n            const pks = agreementKeys?.filter(key => ['X25519KeyAgreementKey2019', 'X25519KeyAgreementKey2020', 'JsonWebKey2020', 'Multikey'].includes(key.type)) ?? [];\n            if (!pks.length && !controllerEncrypters.length) throw new Error(`no_suitable_keys: Could not find X25519 key for ${did}`);\n            return pks.map(pk => {\n              const {\n                keyBytes,\n                keyType\n              } = extractPublicKeyBytes(pk);\n\n              if (keyType === 'X25519') {\n                return x25519Encrypter(keyBytes, pk.id);\n              } else {\n                return null;\n              }\n            }).filter(isDefined).concat(...controllerEncrypters);\n          }\n\n          resolved.push(did);\n\n          if (didResolutionMetadata?.error || didDocument == null) {\n            throw new Error(`resolver_error: Could not resolve ${did}: ${didResolutionMetadata.error}, ${didResolutionMetadata.message}`);\n          }\n\n          let controllerEncrypters = [];\n\n          if (!didDocument.controller && !didDocument.keyAgreement) {\n            throw new Error(`no_suitable_keys: Could not find x25519 key for ${did}`);\n          }\n\n          const _temp = function () {\n            if (didDocument.controller) {\n              let controllers = Array.isArray(didDocument.controller) ? didDocument.controller : [didDocument.controller];\n              controllers = controllers.filter(c => !resolved.includes(c));\n              const encrypterPromises = controllers.map(did => encryptersForDID(did, resolved).catch(() => {\n                return [];\n              }));\n              return Promise.resolve(Promise.all(encrypterPromises)).then(function (encrypterArrays) {\n                controllerEncrypters = [].concat(...encrypterArrays);\n              });\n            }\n          }();\n\n          return _temp && _temp.then ? _temp.then(_temp2) : _temp2(_temp);\n        });\n      } catch (e) {\n        return Promise.reject(e);\n      }\n    };\n\n    const encrypterPromises = dids.map(did => encryptersForDID(did));\n    return Promise.resolve(Promise.all(encrypterPromises)).then(function (encrypterArrays) {\n      return [].concat(...encrypterArrays);\n    });\n  } catch (e) {\n    return Promise.reject(e);\n  }\n};\n/**\n * @deprecated Use {@link xc20pAnonDecrypterEcdhESx25519WithXc20PkwV2 | xc20pAnonDecrypterEcdhESx25519WithXc20PkwV2() }\n *   instead\n */\n\nfunction createAuthEncrypter(recipientPublicKey, senderSecret, options = {}) {\n  return xc20pAuthEncrypterEcdh1PuV3x25519WithXc20PkwV2(recipientPublicKey, senderSecret, options);\n}\n/**\n * @deprecated Use {@link xc20pAnonEncrypterEcdhESx25519WithXc20PkwV2 | xc20pAnonEncrypterEcdhESx25519WithXc20PkwV2() }\n *   instead\n */\n\nfunction createAnonEncrypter(publicKey, options = {}) {\n  return xc20pAnonEncrypterEcdhESx25519WithXc20PkwV2(publicKey, options);\n}\n/**\n * @deprecated Use\n *   {@link xc20pAuthDecrypterEcdh1PuV3x25519WithXc20PkwV2 | xc20pAuthDecrypterEcdh1PuV3x25519WithXc20PkwV2() } instead\n */\n\nfunction createAuthDecrypter(recipientSecret, senderPublicKey) {\n  return xc20pAuthDecrypterEcdh1PuV3x25519WithXc20PkwV2(recipientSecret, senderPublicKey);\n}\n/**\n * @deprecated Use {@link xc20pAnonDecrypterEcdhESx25519WithXc20PkwV2 | xc20pAnonDecrypterEcdhESx25519WithXc20PkwV2() }\n *   instead\n */\n\nfunction createAnonDecrypter(recipientSecret) {\n  return xc20pAnonDecrypterEcdhESx25519WithXc20PkwV2(recipientSecret);\n}\nfunction validateHeader(header) {\n  if (!(header && header.epk && header.iv && header.tag)) {\n    throw new Error('bad_jwe: malformed header');\n  }\n\n  return header;\n}\nconst xc20pKeyWrapper = {\n  from: wrappingKey => {\n    const wrap = function (cek) {\n      try {\n        return Promise.resolve(xc20pEncrypter(wrappingKey)(cek));\n      } catch (e) {\n        return Promise.reject(e);\n      }\n    };\n\n    return {\n      wrap\n    };\n  },\n  alg: 'XC20PKW'\n};\n/**\n * @deprecated Use {@link xc20pAnonEncrypterEcdhESx25519WithXc20PkwV2 | xc20pAnonEncrypterEcdhESx25519WithXc20PkwV2() }\n *   instead\n */\n\nfunction x25519Encrypter(publicKey, kid, apv) {\n  return xc20pAnonEncrypterEcdhESx25519WithXc20PkwV2(publicKey, {\n    kid,\n    apv\n  });\n}\n/**\n * Recommended encrypter for anonymous encryption (i.e. no sender authentication).\n * Uses {@link https://tools.ietf.org/html/draft-amringer-jose-chacha-02 | ECDH-ES+XC20PKW v2}.\n *\n * @param recipientPublicKey - the byte array representing the recipient public key\n * @param options - {@link AnonEncryptParams} used to specify the recipient key ID (`kid`)\n *\n * @returns an {@link Encrypter} instance usable with {@link createJWE}\n *\n * NOTE: ECDH-ES+XC20PKW is a proposed draft in IETF and not a standard yet and\n * is subject to change as new revisions or until the official CFRG specification is released.\n */\n\nfunction xc20pAnonEncrypterEcdhESx25519WithXc20PkwV2(recipientPublicKey, options = {}) {\n  return createFullEncrypter(recipientPublicKey, undefined, options, {\n    createKek: createX25519EcdhEsKek,\n    alg: 'ECDH-ES'\n  }, xc20pKeyWrapper, {\n    from: cek => xc20pDirEncrypter(cek),\n    enc: 'XC20P'\n  });\n}\n/**\n *  Recommended encrypter for authenticated encryption (i.e. sender authentication and requires\n *  sender private key to encrypt the data).\n *  Uses {@link https://tools.ietf.org/html/draft-madden-jose-ecdh-1pu-03 | ECDH-1PU v3 } and\n *  {@link https://tools.ietf.org/html/draft-amringer-jose-chacha-02 | XC20PKW v2 }.\n *\n *  @param recipientPublicKey - the byte array representing the recipient public key\n *  @param senderSecret - either a Uint8Array representing the sender secret key or\n *    an ECDH function that wraps the key and can promise a shared secret given a public key\n *  @param options - {@link AuthEncryptParams} used to specify extra header parameters\n *\n *  @returns an {@link Encrypter} instance usable with {@link createJWE}\n *\n *  NOTE: ECDH-1PU and XC20PKW are proposed drafts in IETF and not a standard yet and\n *  are subject to change as new revisions or until the official CFRG specification are released.\n *\n * Implements ECDH-1PU+XC20PKW with XChaCha20Poly1305 based on the following specs:\n *   - {@link https://tools.ietf.org/html/draft-amringer-jose-chacha-02 | XC20PKW}\n *   - {@link https://tools.ietf.org/html/draft-madden-jose-ecdh-1pu-03 | ECDH-1PU}\n */\n\nfunction xc20pAuthEncrypterEcdh1PuV3x25519WithXc20PkwV2(recipientPublicKey, senderSecret, options = {}) {\n  return createFullEncrypter(recipientPublicKey, senderSecret, options, {\n    createKek: createX25519Ecdh1PUv3Kek,\n    alg: 'ECDH-1PU'\n  }, xc20pKeyWrapper, {\n    from: cek => xc20pDirEncrypter(cek),\n    enc: 'XC20P'\n  });\n}\nfunction x25519Decrypter(receiverSecret) {\n  return xc20pAnonDecrypterEcdhESx25519WithXc20PkwV2(receiverSecret);\n}\n/**\n * Recommended decrypter for anonymous encryption (i.e. no sender authentication).\n * Uses {@link https://tools.ietf.org/html/draft-amringer-jose-chacha-02 | ECDH-ES+XC20PKW v2 }.\n *\n * @param recipientSecret - either a Uint8Array representing the recipient secret key or\n *   an ECDH function that wraps the key and can promise a shared secret given a public key\n *\n * @returns a {@link Decrypter} instance usable with {@link decryptJWE}\n *\n * NOTE: ECDH-ES+XC20PKW is a proposed draft in IETF and not a standard yet and\n * is subject to change as new revisions or until the official CFRG specification is released.\n *\n * @beta\n */\n\nfunction xc20pAnonDecrypterEcdhESx25519WithXc20PkwV2(recipientSecret) {\n  const decrypt = function (sealed, iv, aad, recipient) {\n    try {\n      recipient = recipient;\n      const header = validateHeader(recipient.header);\n      return Promise.resolve(computeX25519EcdhEsKek(recipient, recipientSecret, alg)).then(function (kek) {\n        if (!kek) return null; // Content Encryption Key\n\n        const sealedCek = toSealed(recipient.encrypted_key, header.tag);\n        return Promise.resolve(xc20pDirDecrypter(kek).decrypt(sealedCek, base64ToBytes(header.iv))).then(function (cek) {\n          return cek === null ? null : xc20pDirDecrypter(cek).decrypt(sealed, iv, aad);\n        });\n      });\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n\n  const alg = 'ECDH-ES+XC20PKW';\n  const enc = 'XC20P';\n  return {\n    alg,\n    enc,\n    decrypt\n  };\n}\n/**\n * Recommended decrypter for authenticated encryption (i.e. sender authentication and requires\n * sender public key to decrypt the data).\n * Uses {@link https://tools.ietf.org/html/draft-madden-jose-ecdh-1pu-03 | ECDH-1PU v3 } and\n * {@link https://tools.ietf.org/html/draft-amringer-jose-chacha-02 | XC20PKW v2 }.\n *\n * @param recipientSecret - either a Uint8Array representing the recipient secret key or\n *   an ECDH function that wraps the key and can promise a shared secret given a public key\n * @param senderPublicKey - the byte array representing the sender public key\n *\n * @returns a {@link Decrypter} instance usable with {@link decryptJWE}\n *\n * NOTE: ECDH-1PU and XC20PKW are proposed drafts in IETF and not a standard yet and\n * are subject to change as new revisions or until the official CFRG specification are released.\n *\n * @beta\n *\n * Implements ECDH-1PU+XC20PKW with XChaCha20Poly1305 based on the following specs:\n *   - {@link https://tools.ietf.org/html/draft-amringer-jose-chacha-02 | XC20PKW}\n *   - {@link https://tools.ietf.org/html/draft-madden-jose-ecdh-1pu-03 | ECDH-1PU}\n */\n\nfunction xc20pAuthDecrypterEcdh1PuV3x25519WithXc20PkwV2(recipientSecret, senderPublicKey) {\n  const decrypt = function (sealed, iv, aad, recipient) {\n    try {\n      recipient = recipient;\n      const header = validateHeader(recipient.header);\n      return Promise.resolve(computeX25519Ecdh1PUv3Kek(recipient, recipientSecret, senderPublicKey, alg)).then(function (kek) {\n        if (!kek) return null; // Content Encryption Key\n\n        const sealedCek = toSealed(recipient.encrypted_key, header.tag);\n        return Promise.resolve(xc20pDirDecrypter(kek).decrypt(sealedCek, base64ToBytes(header.iv))).then(function (cek) {\n          return cek === null ? null : xc20pDirDecrypter(cek).decrypt(sealed, iv, aad);\n        });\n      });\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n\n  const alg = 'ECDH-1PU+XC20PKW';\n  const enc = 'XC20P';\n  return {\n    alg,\n    enc,\n    decrypt\n  };\n}\n\n\n//# sourceMappingURL=index.module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2RpZC1qd3QvbGliL2luZGV4Lm1vZHVsZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUEyRDtBQUNIO0FBQ2xCO0FBQ0s7QUFDUztBQUNWO0FBQ2dCO0FBQ047QUFDSjtBQUNKO0FBQ1A7QUFDQTtBQUNxQjtBQUNSOztBQUVsRDtBQUNBLFVBQVU7QUFDVixZQUFZO0FBQ1osUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsZ0JBQWdCLDhEQUFT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VjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUJBQXlCLHdCQUF3QiwrQ0FBK0MsSUFBSTtBQUNwRzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxp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QUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTs7QUFFVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBLElBQUk7OztBQUdKOztBQUVBLGtCQUFrQixtQkFBbUI7QUFDckM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUEsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FB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InNvdXJjZXMiOlsiL2hvbWUvYmFyYi9hYS9Bc3NvY2lhdGVkQWNjb3VudHMvbm9kZV9tb2R1bGVzL2RpZC1qd3QvbGliL2luZGV4Lm1vZHVsZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB0b1N0cmluZywgZnJvbVN0cmluZywgY29uY2F0IH0gZnJvbSAndWludDhhcnJheXMnO1xuaW1wb3J0IHsgeDI1NTE5LCBlZDI1NTE5IH0gZnJvbSAnQG5vYmxlL2N1cnZlcy9lZDI1NTE5JztcbmltcG9ydCB7IHZhcmludCB9IGZyb20gJ211bHRpZm9ybWF0cyc7XG5pbXBvcnQgeyBlbmNvZGUsIGRlY29kZSB9IGZyb20gJ211bHRpYmFzZSc7XG5pbXBvcnQgeyBzZWNwMjU2azEgfSBmcm9tICdAbm9ibGUvY3VydmVzL3NlY3AyNTZrMSc7XG5pbXBvcnQgeyBwMjU2IH0gZnJvbSAnQG5vYmxlL2N1cnZlcy9wMjU2JztcbmltcG9ydCB7IHNoYTI1NiBhcyBzaGEyNTYkMSB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvc2hhMjU2JztcbmltcG9ydCB7IHJpcGVtZDE2MCB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvcmlwZW1kMTYwJztcbmltcG9ydCB7IGtlY2Nha18yNTYgfSBmcm9tICdAbm9ibGUvaGFzaGVzL3NoYTMnO1xuaW1wb3J0IGNhbm9uaWNhbGl6ZURhdGEgZnJvbSAnY2Fub25pY2FsaXplJztcbmltcG9ydCB7IHBhcnNlIH0gZnJvbSAnZGlkLXJlc29sdmVyJztcbmltcG9ydCB7IGJlY2gzMiB9IGZyb20gJ0BzY3VyZS9iYXNlJztcbmltcG9ydCB7IHhjaGFjaGEyMHBvbHkxMzA1IH0gZnJvbSAnQG5vYmxlL2NpcGhlcnMvY2hhY2hhJztcbmltcG9ydCB7IHJhbmRvbUJ5dGVzIH0gZnJvbSAnQG5vYmxlL2hhc2hlcy91dGlscyc7XG5cbmNvbnN0IHU4YSA9IHtcbiAgdG9TdHJpbmcsXG4gIGZyb21TdHJpbmcsXG4gIGNvbmNhdFxufTtcbmZ1bmN0aW9uIGJ5dGVzVG9CYXNlNjR1cmwoYikge1xuICByZXR1cm4gdThhLnRvU3RyaW5nKGIsICdiYXNlNjR1cmwnKTtcbn1cbmZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXMocykge1xuICBjb25zdCBpbnB1dEJhc2U2NFVybCA9IHMucmVwbGFjZSgvXFwrL2csICctJykucmVwbGFjZSgvXFwvL2csICdfJykucmVwbGFjZSgvPS9nLCAnJyk7XG4gIHJldHVybiB1OGEuZnJvbVN0cmluZyhpbnB1dEJhc2U2NFVybCwgJ2Jhc2U2NHVybCcpO1xufVxuZnVuY3Rpb24gYmFzZTU4VG9CeXRlcyhzKSB7XG4gIHJldHVybiB1OGEuZnJvbVN0cmluZyhzLCAnYmFzZTU4YnRjJyk7XG59XG5mdW5jdGlvbiBieXRlc1RvQmFzZTU4KGIpIHtcbiAgcmV0dXJuIHU4YS50b1N0cmluZyhiLCAnYmFzZTU4YnRjJyk7XG59XG5jb25zdCBTVVBQT1JURURfUFVCTElDX0tFWV9UWVBFUyA9IHtcbiAgRVMyNTY6IFsnSnNvbldlYktleTIwMjAnLCAnTXVsdGlrZXknLCAnRWNkc2FTZWNwMjU2cjFWZXJpZmljYXRpb25LZXkyMDE5J10sXG4gIEVTMjU2SzogWydFY2RzYVNlY3AyNTZrMVZlcmlmaWNhdGlvbktleTIwMTknLFxuICAvKipcbiAgICogRXF1aXZhbGVudCB0byBFY2RzYVNlY3AyNTZrMVZlcmlmaWNhdGlvbktleTIwMTkgd2hlbiBrZXkgaXMgYW4gZXRoZXJldW1BZGRyZXNzXG4gICAqL1xuICAnRWNkc2FTZWNwMjU2azFSZWNvdmVyeU1ldGhvZDIwMjAnLFxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQsIHN1cHBvcnRlZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eS4gRXF1aXZhbGVudCB0byBFY2RzYVNlY3AyNTZrMVZlcmlmaWNhdGlvbktleTIwMTkgd2hlbiBrZXkgaXNcbiAgICogICBub3QgYW4gZXRoZXJldW1BZGRyZXNzXG4gICAqL1xuICAnU2VjcDI1NmsxVmVyaWZpY2F0aW9uS2V5MjAxOCcsXG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCwgc3VwcG9ydGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LiBFcXVpdmFsZW50IHRvIEVjZHNhU2VjcDI1NmsxVmVyaWZpY2F0aW9uS2V5MjAxOSB3aGVuIGtleSBpc1xuICAgKiAgIG5vdCBhbiBldGhlcmV1bUFkZHJlc3NcbiAgICovXG4gICdTZWNwMjU2azFTaWduYXR1cmVWZXJpZmljYXRpb25LZXkyMDE4JyxcbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkLCBzdXBwb3J0ZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkuIEVxdWl2YWxlbnQgdG8gRWNkc2FTZWNwMjU2azFWZXJpZmljYXRpb25LZXkyMDE5IHdoZW4ga2V5IGlzXG4gICAqICAgbm90IGFuIGV0aGVyZXVtQWRkcmVzc1xuICAgKi9cbiAgJ0VjZHNhUHVibGljS2V5U2VjcDI1NmsxJyxcbiAgLyoqXG4gICAqICBUT0RPIC0gc3VwcG9ydCBSMSBrZXkgYXMgd2VsbFxuICAgKiAgICdDb25kaXRpb25hbFByb29mMjAyMicsXG4gICAqL1xuICAnSnNvbldlYktleTIwMjAnLCAnTXVsdGlrZXknXSxcbiAgJ0VTMjU2Sy1SJzogWydFY2RzYVNlY3AyNTZrMVZlcmlmaWNhdGlvbktleTIwMTknLFxuICAvKipcbiAgICogRXF1aXZhbGVudCB0byBFY2RzYVNlY3AyNTZrMVZlcmlmaWNhdGlvbktleTIwMTkgd2hlbiBrZXkgaXMgYW4gZXRoZXJldW1BZGRyZXNzXG4gICAqL1xuICAnRWNkc2FTZWNwMjU2azFSZWNvdmVyeU1ldGhvZDIwMjAnLFxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQsIHN1cHBvcnRlZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eS4gRXF1aXZhbGVudCB0byBFY2RzYVNlY3AyNTZrMVZlcmlmaWNhdGlvbktleTIwMTkgd2hlbiBrZXkgaXNcbiAgICogICBub3QgYW4gZXRoZXJldW1BZGRyZXNzXG4gICAqL1xuICAnU2VjcDI1NmsxVmVyaWZpY2F0aW9uS2V5MjAxOCcsXG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCwgc3VwcG9ydGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LiBFcXVpdmFsZW50IHRvIEVjZHNhU2VjcDI1NmsxVmVyaWZpY2F0aW9uS2V5MjAxOSB3aGVuIGtleSBpc1xuICAgKiAgIG5vdCBhbiBldGhlcmV1bUFkZHJlc3NcbiAgICovXG4gICdTZWNwMjU2azFTaWduYXR1cmVWZXJpZmljYXRpb25LZXkyMDE4JyxcbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkLCBzdXBwb3J0ZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkuIEVxdWl2YWxlbnQgdG8gRWNkc2FTZWNwMjU2azFWZXJpZmljYXRpb25LZXkyMDE5IHdoZW4ga2V5IGlzXG4gICAqICAgbm90IGFuIGV0aGVyZXVtQWRkcmVzc1xuICAgKi9cbiAgJ0VjZHNhUHVibGljS2V5U2VjcDI1NmsxJywgJ0NvbmRpdGlvbmFsUHJvb2YyMDIyJywgJ0pzb25XZWJLZXkyMDIwJywgJ011bHRpa2V5J10sXG4gIEVkMjU1MTk6IFsnRUQyNTUxOVNpZ25hdHVyZVZlcmlmaWNhdGlvbicsICdFZDI1NTE5VmVyaWZpY2F0aW9uS2V5MjAxOCcsICdFZDI1NTE5VmVyaWZpY2F0aW9uS2V5MjAyMCcsICdKc29uV2ViS2V5MjAyMCcsICdNdWx0aWtleSddLFxuICBFZERTQTogWydFRDI1NTE5U2lnbmF0dXJlVmVyaWZpY2F0aW9uJywgJ0VkMjU1MTlWZXJpZmljYXRpb25LZXkyMDE4JywgJ0VkMjU1MTlWZXJpZmljYXRpb25LZXkyMDIwJywgJ0pzb25XZWJLZXkyMDIwJywgJ011bHRpa2V5J11cbn07XG5jb25zdCBWTV9UT19LRVlfVFlQRSA9IHtcbiAgU2VjcDI1NmsxU2lnbmF0dXJlVmVyaWZpY2F0aW9uS2V5MjAxODogJ1NlY3AyNTZrMScsXG4gIFNlY3AyNTZrMVZlcmlmaWNhdGlvbktleTIwMTg6ICdTZWNwMjU2azEnLFxuICBFY2RzYVNlY3AyNTZrMVZlcmlmaWNhdGlvbktleTIwMTk6ICdTZWNwMjU2azEnLFxuICBFY2RzYVB1YmxpY0tleVNlY3AyNTZrMTogJ1NlY3AyNTZrMScsXG4gIEVjZHNhU2VjcDI1NmsxUmVjb3ZlcnlNZXRob2QyMDIwOiAnU2VjcDI1NmsxJyxcbiAgRWNkc2FTZWNwMjU2cjFWZXJpZmljYXRpb25LZXkyMDE5OiAnUC0yNTYnLFxuICBFZDI1NTE5VmVyaWZpY2F0aW9uS2V5MjAxODogJ0VkMjU1MTknLFxuICBFZDI1NTE5VmVyaWZpY2F0aW9uS2V5MjAyMDogJ0VkMjU1MTknLFxuICBFRDI1NTE5U2lnbmF0dXJlVmVyaWZpY2F0aW9uOiAnRWQyNTUxOScsXG4gIFgyNTUxOUtleUFncmVlbWVudEtleTIwMTk6ICdYMjU1MTknLFxuICBYMjU1MTlLZXlBZ3JlZW1lbnRLZXkyMDIwOiAnWDI1NTE5JyxcbiAgQ29uZGl0aW9uYWxQcm9vZjIwMjI6IHVuZGVmaW5lZCxcbiAgSnNvbldlYktleTIwMjA6IHVuZGVmaW5lZCxcbiAgLy8ga2V5IHR5cGUgbXVzdCBiZSBzcGVjaWZpZWQgaW4gdGhlIEpXS1xuICBNdWx0aWtleTogdW5kZWZpbmVkIC8vIGtleSB0eXBlIG11c3QgYmUgZXh0cmFjdGVkIGZyb20gdGhlIG11bHRpY29kZWNcblxufTsgLy8gdGhpcyBpcyBmcm9tIHRoZSBtdWx0aWNvZGVjIHRhYmxlIGh0dHBzOi8vZ2l0aHViLmNvbS9tdWx0aWZvcm1hdHMvbXVsdGljb2RlYy9ibG9iL21hc3Rlci90YWJsZS5jc3ZcblxuY29uc3Qgc3VwcG9ydGVkQ29kZWNzID0ge1xuICAnZWQyNTUxOS1wdWInOiAweGVkLFxuICAneDI1NTE5LXB1Yic6IDB4ZWMsXG4gICdzZWNwMjU2azEtcHViJzogMHhlNyxcbiAgJ2JsczEyXzM4MS1nMS1wdWInOiAweGVhLFxuICAnYmxzMTJfMzgxLWcyLXB1Yic6IDB4ZWIsXG4gICdwMjU2LXB1Yic6IDB4MTIwMFxufTtcbmNvbnN0IENPREVDX1RPX0tFWV9UWVBFID0ge1xuICAnYmxzMTJfMzgxLWcxLXB1Yic6ICdCbHMxMjM4MUcxJyxcbiAgJ2JsczEyXzM4MS1nMi1wdWInOiAnQmxzMTIzODFHMicsXG4gICdlZDI1NTE5LXB1Yic6ICdFZDI1NTE5JyxcbiAgJ3AyNTYtcHViJzogJ1AtMjU2JyxcbiAgJ3NlY3AyNTZrMS1wdWInOiAnU2VjcDI1NmsxJyxcbiAgJ3gyNTUxOS1wdWInOiAnWDI1NTE5J1xufTtcbi8qKlxuICogRXh0cmFjdHMgdGhlIHJhdyBieXRlIHJlcHJlc2VudGF0aW9uIG9mIGEgcHVibGljIGtleSBmcm9tIGEgVmVyaWZpY2F0aW9uTWV0aG9kIGFsb25nIHdpdGggYW4gaW5mZXJyZWQga2V5IHR5cGVcbiAqIEBwYXJhbSBwayBhIFZlcmlmaWNhdGlvbk1ldGhvZCBlbnRyeSBmcm9tIGEgRElERG9jdW1lbnRcbiAqIEByZXR1cm4gYW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGBrZXlCeXRlc2Agb2YgdGhlIHB1YmxpYyBrZXkgYW5kIGFuIGluZmVycmVkIGBrZXlUeXBlYFxuICovXG5cbmZ1bmN0aW9uIGV4dHJhY3RQdWJsaWNLZXlCeXRlcyhwaykge1xuICBpZiAocGsucHVibGljS2V5QmFzZTU4KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGtleUJ5dGVzOiBiYXNlNThUb0J5dGVzKHBrLnB1YmxpY0tleUJhc2U1OCksXG4gICAgICBrZXlUeXBlOiBWTV9UT19LRVlfVFlQRVtway50eXBlXVxuICAgIH07XG4gIH0gZWxzZSBpZiAocGsucHVibGljS2V5QmFzZTY0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGtleUJ5dGVzOiBiYXNlNjRUb0J5dGVzKHBrLnB1YmxpY0tleUJhc2U2NCksXG4gICAgICBrZXlUeXBlOiBWTV9UT19LRVlfVFlQRVtway50eXBlXVxuICAgIH07XG4gIH0gZWxzZSBpZiAocGsucHVibGljS2V5SGV4KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGtleUJ5dGVzOiBoZXhUb0J5dGVzKHBrLnB1YmxpY0tleUhleCksXG4gICAgICBrZXlUeXBlOiBWTV9UT19LRVlfVFlQRVtway50eXBlXVxuICAgIH07XG4gIH0gZWxzZSBpZiAocGsucHVibGljS2V5SndrICYmIHBrLnB1YmxpY0tleUp3ay5jcnYgPT09ICdzZWNwMjU2azEnICYmIHBrLnB1YmxpY0tleUp3ay54ICYmIHBrLnB1YmxpY0tleUp3ay55KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGtleUJ5dGVzOiBzZWNwMjU2azEuUHJvamVjdGl2ZVBvaW50LmZyb21BZmZpbmUoe1xuICAgICAgICB4OiBieXRlc1RvQmlnSW50KGJhc2U2NFRvQnl0ZXMocGsucHVibGljS2V5SndrLngpKSxcbiAgICAgICAgeTogYnl0ZXNUb0JpZ0ludChiYXNlNjRUb0J5dGVzKHBrLnB1YmxpY0tleUp3ay55KSlcbiAgICAgIH0pLnRvUmF3Qnl0ZXMoZmFsc2UpLFxuICAgICAga2V5VHlwZTogJ1NlY3AyNTZrMSdcbiAgICB9O1xuICB9IGVsc2UgaWYgKHBrLnB1YmxpY0tleUp3ayAmJiBway5wdWJsaWNLZXlKd2suY3J2ID09PSAnUC0yNTYnICYmIHBrLnB1YmxpY0tleUp3ay54ICYmIHBrLnB1YmxpY0tleUp3ay55KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGtleUJ5dGVzOiBwMjU2LlByb2plY3RpdmVQb2ludC5mcm9tQWZmaW5lKHtcbiAgICAgICAgeDogYnl0ZXNUb0JpZ0ludChiYXNlNjRUb0J5dGVzKHBrLnB1YmxpY0tleUp3ay54KSksXG4gICAgICAgIHk6IGJ5dGVzVG9CaWdJbnQoYmFzZTY0VG9CeXRlcyhway5wdWJsaWNLZXlKd2sueSkpXG4gICAgICB9KS50b1Jhd0J5dGVzKGZhbHNlKSxcbiAgICAgIGtleVR5cGU6ICdQLTI1NidcbiAgICB9O1xuICB9IGVsc2UgaWYgKHBrLnB1YmxpY0tleUp3ayAmJiBway5wdWJsaWNLZXlKd2sua3R5ID09PSAnT0tQJyAmJiBbJ0VkMjU1MTknLCAnWDI1NTE5J10uaW5jbHVkZXMocGsucHVibGljS2V5SndrLmNydiA/PyAnJykgJiYgcGsucHVibGljS2V5SndrLngpIHtcbiAgICByZXR1cm4ge1xuICAgICAga2V5Qnl0ZXM6IGJhc2U2NFRvQnl0ZXMocGsucHVibGljS2V5SndrLngpLFxuICAgICAga2V5VHlwZTogcGsucHVibGljS2V5SndrLmNydlxuICAgIH07XG4gIH0gZWxzZSBpZiAocGsucHVibGljS2V5TXVsdGliYXNlKSB7XG4gICAgY29uc3Qge1xuICAgICAga2V5Qnl0ZXMsXG4gICAgICBrZXlUeXBlXG4gICAgfSA9IG11bHRpYmFzZVRvQnl0ZXMocGsucHVibGljS2V5TXVsdGliYXNlKTtcbiAgICByZXR1cm4ge1xuICAgICAga2V5Qnl0ZXMsXG4gICAgICBrZXlUeXBlOiBrZXlUeXBlID8/IFZNX1RPX0tFWV9UWVBFW3BrLnR5cGVdXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAga2V5Qnl0ZXM6IG5ldyBVaW50OEFycmF5KClcbiAgfTtcbn1cbi8qKlxuICogRW5jb2RlcyB0aGUgZ2l2ZW4gYnl0ZSBhcnJheSB0byBhIG11bHRpYmFzZSBzdHJpbmcgKGRlZmF1bHRpbmcgdG8gYmFzZTU4YnRjKS5cbiAqIElmIGEgY29kZWMgaXMgcHJvdmlkZWQsIHRoZSBjb3JyZXNwb25kaW5nIG11bHRpY29kZWMgcHJlZml4IHdpbGwgYmUgYWRkZWQuXG4gKlxuICogQHBhcmFtIGIgLSB0aGUgVWludDhBcnJheSB0byBiZSBlbmNvZGVkXG4gKiBAcGFyYW0gYmFzZSAtIHRoZSBiYXNlIHRvIHVzZSBmb3IgZW5jb2RpbmcgKGRlZmF1bHRzIHRvIGJhc2U1OGJ0YylcbiAqIEBwYXJhbSBjb2RlYyAtIHRoZSBjb2RlYyB0byB1c2UgZm9yIGVuY29kaW5nIChkZWZhdWx0cyB0byBubyBjb2RlYylcbiAqXG4gKiBAcmV0dXJucyB0aGUgbXVsdGliYXNlIGVuY29kZWQgc3RyaW5nXG4gKlxuICogQHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGJ5dGVzVG9NdWx0aWJhc2UoYiwgYmFzZSA9ICdiYXNlNThidGMnLCBjb2RlYykge1xuICBpZiAoIWNvZGVjKSB7XG4gICAgcmV0dXJuIHU4YS50b1N0cmluZyhlbmNvZGUoYmFzZSwgYiksICd1dGYtOCcpO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGNvZGVjQ29kZSA9IHR5cGVvZiBjb2RlYyA9PT0gJ3N0cmluZycgPyBzdXBwb3J0ZWRDb2RlY3NbY29kZWNdIDogY29kZWM7XG4gICAgY29uc3QgcHJlZml4TGVuZ3RoID0gdmFyaW50LmVuY29kaW5nTGVuZ3RoKGNvZGVjQ29kZSk7XG4gICAgY29uc3QgbXVsdGljb2RlY0VuY29kaW5nID0gbmV3IFVpbnQ4QXJyYXkocHJlZml4TGVuZ3RoICsgYi5sZW5ndGgpO1xuICAgIHZhcmludC5lbmNvZGVUbyhjb2RlY0NvZGUsIG11bHRpY29kZWNFbmNvZGluZyk7IC8vIHNldCBwcmVmaXhcblxuICAgIG11bHRpY29kZWNFbmNvZGluZy5zZXQoYiwgcHJlZml4TGVuZ3RoKTsgLy8gYWRkIHRoZSBvcmlnaW5hbCBieXRlc1xuXG4gICAgcmV0dXJuIHU4YS50b1N0cmluZyhlbmNvZGUoYmFzZSwgbXVsdGljb2RlY0VuY29kaW5nKSwgJ3V0Zi04Jyk7XG4gIH1cbn1cbi8qKlxuICogQ29udmVydHMgYSBtdWx0aWJhc2Ugc3RyaW5nIHRvIHRoZSBVaW50OEFycmF5IGl0IHJlcHJlc2VudHMuXG4gKiBUaGlzIG1ldGhvZCB3aWxsIGFzc3VtZSB0aGUgYnl0ZSBhcnJheSB0aGF0IGlzIG11bHRpYmFzZSBlbmNvZGVkIGlzIGEgbXVsdGljb2RlYyBhbmQgd2lsbCBhdHRlbXB0IHRvIGRlY29kZSBpdC5cbiAqXG4gKiBAcGFyYW0gcyAtIHRoZSBzdHJpbmcgdG8gYmUgY29udmVydGVkXG4gKlxuICogQHRocm93cyBpZiB0aGUgc3RyaW5nIGlzIG5vdCBmb3JtYXR0ZWQgY29ycmVjdGx5LlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBtdWx0aWJhc2VUb0J5dGVzKHMpIHtcbiAgY29uc3QgYnl0ZXMgPSBkZWNvZGUocyk7IC8vIGxvb2sgZm9yIGtub3duIGtleSBsZW5ndGhzIGZpcnN0XG4gIC8vIEVkMjU1MTkvWDI1NTE5LCBzZWNwMjU2azEvUDI1NiBjb21wcmVzc2VkIG9yIG5vdCwgQkxTMTItMzgxIEcxL0cyIGNvbXByZXNzZWRcblxuICBpZiAoWzMyLCAzMywgNDgsIDY0LCA2NSwgOTZdLmluY2x1ZGVzKGJ5dGVzLmxlbmd0aCkpIHtcbiAgICByZXR1cm4ge1xuICAgICAga2V5Qnl0ZXM6IGJ5dGVzXG4gICAgfTtcbiAgfSAvLyB0aGVuIGFzc3VtZSBtdWx0aWNvZGVjLCBvdGhlcndpc2UgcmV0dXJuIHRoZSBieXRlc1xuXG5cbiAgdHJ5IHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgY29uc3QgW2NvZGVjLCBsZW5ndGhdID0gdmFyaW50LmRlY29kZShieXRlcyk7XG4gICAgY29uc3QgcG9zc2libGVDb2RlYyA9IE9iamVjdC5lbnRyaWVzKHN1cHBvcnRlZENvZGVjcykuZmlsdGVyKChbLCBjb2RlXSkgPT4gY29kZSA9PT0gY29kZWMpPy5bMF1bMF0gPz8gJyc7XG4gICAgcmV0dXJuIHtcbiAgICAgIGtleUJ5dGVzOiBieXRlcy5zbGljZShsZW5ndGgpLFxuICAgICAga2V5VHlwZTogQ09ERUNfVE9fS0VZX1RZUEVbcG9zc2libGVDb2RlY11cbiAgICB9O1xuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gbm90IGEgbXVsdGljb2RlYywgcmV0dXJuIHRoZSBieXRlc1xuICAgIHJldHVybiB7XG4gICAgICBrZXlCeXRlczogYnl0ZXNcbiAgICB9O1xuICB9XG59XG5mdW5jdGlvbiBoZXhUb0J5dGVzKHMsIG1pbkxlbmd0aCkge1xuICBsZXQgaW5wdXQgPSBzLnN0YXJ0c1dpdGgoJzB4JykgPyBzLnN1YnN0cmluZygyKSA6IHM7XG5cbiAgaWYgKGlucHV0Lmxlbmd0aCAlIDIgIT09IDApIHtcbiAgICBpbnB1dCA9IGAwJHtpbnB1dH1gO1xuICB9XG5cbiAgaWYgKG1pbkxlbmd0aCkge1xuICAgIGNvbnN0IHBhZGRlZExlbmd0aCA9IE1hdGgubWF4KGlucHV0Lmxlbmd0aCwgbWluTGVuZ3RoICogMik7XG4gICAgaW5wdXQgPSBpbnB1dC5wYWRTdGFydChwYWRkZWRMZW5ndGgsICcwMCcpO1xuICB9XG5cbiAgcmV0dXJuIHU4YS5mcm9tU3RyaW5nKGlucHV0LnRvTG93ZXJDYXNlKCksICdiYXNlMTYnKTtcbn1cbmZ1bmN0aW9uIGVuY29kZUJhc2U2NHVybChzKSB7XG4gIHJldHVybiBieXRlc1RvQmFzZTY0dXJsKHU4YS5mcm9tU3RyaW5nKHMpKTtcbn1cbmZ1bmN0aW9uIGRlY29kZUJhc2U2NHVybChzKSB7XG4gIHJldHVybiB1OGEudG9TdHJpbmcoYmFzZTY0VG9CeXRlcyhzKSk7XG59XG5mdW5jdGlvbiBieXRlc1RvSGV4KGIpIHtcbiAgcmV0dXJuIHU4YS50b1N0cmluZyhiLCAnYmFzZTE2Jyk7XG59XG5mdW5jdGlvbiBieXRlc1RvQmlnSW50KGIpIHtcbiAgcmV0dXJuIEJpZ0ludChgMHhgICsgdThhLnRvU3RyaW5nKGIsICdiYXNlMTYnKSk7XG59XG5mdW5jdGlvbiBzdHJpbmdUb0J5dGVzKHMpIHtcbiAgcmV0dXJuIHU4YS5mcm9tU3RyaW5nKHMsICd1dGYtOCcpO1xufVxuZnVuY3Rpb24gdG9Kb3NlKHtcbiAgcixcbiAgcyxcbiAgcmVjb3ZlcnlQYXJhbVxufSwgcmVjb3ZlcmFibGUpIHtcbiAgY29uc3Qgam9zZSA9IG5ldyBVaW50OEFycmF5KHJlY292ZXJhYmxlID8gNjUgOiA2NCk7XG4gIGpvc2Uuc2V0KHU4YS5mcm9tU3RyaW5nKHIsICdiYXNlMTYnKSwgMCk7XG4gIGpvc2Uuc2V0KHU4YS5mcm9tU3RyaW5nKHMsICdiYXNlMTYnKSwgMzIpO1xuXG4gIGlmIChyZWNvdmVyYWJsZSkge1xuICAgIGlmICh0eXBlb2YgcmVjb3ZlcnlQYXJhbSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignU2lnbmVyIGRpZCBub3QgcmV0dXJuIGEgcmVjb3ZlcnlQYXJhbScpO1xuICAgIH1cblxuICAgIGpvc2VbNjRdID0gcmVjb3ZlcnlQYXJhbTtcbiAgfVxuXG4gIHJldHVybiBieXRlc1RvQmFzZTY0dXJsKGpvc2UpO1xufVxuZnVuY3Rpb24gZnJvbUpvc2Uoc2lnbmF0dXJlKSB7XG4gIGNvbnN0IHNpZ25hdHVyZUJ5dGVzID0gYmFzZTY0VG9CeXRlcyhzaWduYXR1cmUpO1xuXG4gIGlmIChzaWduYXR1cmVCeXRlcy5sZW5ndGggPCA2NCB8fCBzaWduYXR1cmVCeXRlcy5sZW5ndGggPiA2NSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFdyb25nIHNpemUgZm9yIHNpZ25hdHVyZS4gRXhwZWN0ZWQgNjQgb3IgNjUgYnl0ZXMsIGJ1dCBnb3QgJHtzaWduYXR1cmVCeXRlcy5sZW5ndGh9YCk7XG4gIH1cblxuICBjb25zdCByID0gYnl0ZXNUb0hleChzaWduYXR1cmVCeXRlcy5zbGljZSgwLCAzMikpO1xuICBjb25zdCBzID0gYnl0ZXNUb0hleChzaWduYXR1cmVCeXRlcy5zbGljZSgzMiwgNjQpKTtcbiAgY29uc3QgcmVjb3ZlcnlQYXJhbSA9IHNpZ25hdHVyZUJ5dGVzLmxlbmd0aCA9PT0gNjUgPyBzaWduYXR1cmVCeXRlc1s2NF0gOiB1bmRlZmluZWQ7XG4gIHJldHVybiB7XG4gICAgcixcbiAgICBzLFxuICAgIHJlY292ZXJ5UGFyYW1cbiAgfTtcbn1cbmZ1bmN0aW9uIHRvU2VhbGVkKGNpcGhlcnRleHQsIHRhZykge1xuICByZXR1cm4gdThhLmNvbmNhdChbYmFzZTY0VG9CeXRlcyhjaXBoZXJ0ZXh0KSwgdGFnID8gYmFzZTY0VG9CeXRlcyh0YWcpIDogbmV3IFVpbnQ4QXJyYXkoMCldKTtcbn1cbmZ1bmN0aW9uIGxlZnRwYWQoZGF0YSwgc2l6ZSA9IDY0KSB7XG4gIGlmIChkYXRhLmxlbmd0aCA9PT0gc2l6ZSkgcmV0dXJuIGRhdGE7XG4gIHJldHVybiAnMCcucmVwZWF0KHNpemUgLSBkYXRhLmxlbmd0aCkgKyBkYXRhO1xufVxuLyoqXG4gKiBHZW5lcmF0ZSByYW5kb20geDI1NTE5IGtleSBwYWlyLlxuICovXG5cbmZ1bmN0aW9uIGdlbmVyYXRlS2V5UGFpcigpIHtcbiAgY29uc3Qgc2VjcmV0S2V5ID0geDI1NTE5LnV0aWxzLnJhbmRvbVByaXZhdGVLZXkoKTtcbiAgY29uc3QgcHVibGljS2V5ID0geDI1NTE5LmdldFB1YmxpY0tleShzZWNyZXRLZXkpO1xuICByZXR1cm4ge1xuICAgIHNlY3JldEtleTogc2VjcmV0S2V5LFxuICAgIHB1YmxpY0tleTogcHVibGljS2V5XG4gIH07XG59XG4vKipcbiAqIEdlbmVyYXRlIHByaXZhdGUtcHVibGljIHgyNTUxOSBrZXkgcGFpciBmcm9tIGBzZWVkYC5cbiAqL1xuXG5mdW5jdGlvbiBnZW5lcmF0ZUtleVBhaXJGcm9tU2VlZChzZWVkKSB7XG4gIGlmIChzZWVkLmxlbmd0aCAhPT0gMzIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYHgyNTUxOTogc2VlZCBtdXN0IGJlICR7MzJ9IGJ5dGVzYCk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHB1YmxpY0tleTogeDI1NTE5LmdldFB1YmxpY0tleShzZWVkKSxcbiAgICBzZWNyZXRLZXk6IHNlZWRcbiAgfTtcbn1cbmZ1bmN0aW9uIGdlblgyNTUxOUVwaGVtZXJhbEtleVBhaXIoKSB7XG4gIGNvbnN0IGVwayA9IGdlbmVyYXRlS2V5UGFpcigpO1xuICByZXR1cm4ge1xuICAgIHB1YmxpY0tleUpXSzoge1xuICAgICAga3R5OiAnT0tQJyxcbiAgICAgIGNydjogJ1gyNTUxOScsXG4gICAgICB4OiBieXRlc1RvQmFzZTY0dXJsKGVway5wdWJsaWNLZXkpXG4gICAgfSxcbiAgICBzZWNyZXRLZXk6IGVway5zZWNyZXRLZXlcbiAgfTtcbn1cbi8qKlxuICogQ2hlY2tzIGlmIGEgdmFyaWFibGUgaXMgZGVmaW5lZCBhbmQgbm90IG51bGwuXG4gKiBBZnRlciB0aGlzIGNoZWNrLCB0eXBlc2NyaXB0IHNlZXMgdGhlIHZhcmlhYmxlIGFzIGRlZmluZWQuXG4gKlxuICogQHBhcmFtIGFyZyAtIFRoZSBpbnB1dCB0byBiZSB2ZXJpZmllZFxuICpcbiAqIEByZXR1cm5zIHRydWUgaWYgdGhlIGlucHV0IHZhcmlhYmxlIGlzIGRlZmluZWQuXG4gKi9cblxuZnVuY3Rpb24gaXNEZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnICE9PSBudWxsICYmIHR5cGVvZiBhcmcgIT09ICd1bmRlZmluZWQnO1xufVxuXG5mdW5jdGlvbiBzaGEyNTYocGF5bG9hZCkge1xuICBjb25zdCBkYXRhID0gdHlwZW9mIHBheWxvYWQgPT09ICdzdHJpbmcnID8gZnJvbVN0cmluZyhwYXlsb2FkKSA6IHBheWxvYWQ7XG4gIHJldHVybiBzaGEyNTYkMShkYXRhKTtcbn1cbmNvbnN0IGtlY2NhayA9IGtlY2Nha18yNTY7XG5mdW5jdGlvbiB0b0V0aGVyZXVtQWRkcmVzcyhoZXhQdWJsaWNLZXkpIHtcbiAgY29uc3QgaGFzaElucHV0ID0gZnJvbVN0cmluZyhoZXhQdWJsaWNLZXkuc2xpY2UoMiksICdiYXNlMTYnKTtcbiAgcmV0dXJuIGAweCR7dG9TdHJpbmcoa2VjY2FrKGhhc2hJbnB1dCkuc2xpY2UoLTIwKSwgJ2Jhc2UxNicpfWA7XG59XG5cbmZ1bmN0aW9uIHdyaXRlVWludDMyQkUodmFsdWUsIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoNCkpIHtcbiAgY29uc3QgZW5jb2RlZCA9IGZyb21TdHJpbmcodmFsdWUudG9TdHJpbmcoKSwgJ2Jhc2UxMCcpO1xuICBhcnJheS5zZXQoZW5jb2RlZCwgNCAtIGVuY29kZWQubGVuZ3RoKTtcbiAgcmV0dXJuIGFycmF5O1xufVxuXG5jb25zdCBsZW5ndGhBbmRJbnB1dCA9IGlucHV0ID0+IGNvbmNhdChbd3JpdGVVaW50MzJCRShpbnB1dC5sZW5ndGgpLCBpbnB1dF0pOyAvLyBUaGlzIGltcGxlbWVudGF0aW9uIG9mIGNvbmNhdEtERiB3YXMgaW5zcGlyZWQgYnkgdGhlc2UgdHdvIGltcGxlbWVudGF0aW9uczpcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9kaWdpdGFsYmF6YWFyL21pbmltYWwtY2lwaGVyL2Jsb2IvbWFzdGVyL2FsZ29yaXRobXMvZWNkaGtkZi5qc1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL3BhbnZhL2pvc2UvYmxvYi9tYXN0ZXIvbGliL2p3YS9lY2RoL2Rlcml2ZS5qc1xuXG5cbmZ1bmN0aW9uIGNvbmNhdEtERihzZWNyZXQsIGtleUxlbiwgYWxnLCBwcm9kdWNlckluZm8sIGNvbnN1bWVySW5mbykge1xuICBpZiAoa2V5TGVuICE9PSAyNTYpIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQga2V5IGxlbmd0aDogJHtrZXlMZW59YCk7XG4gIGNvbnN0IHZhbHVlID0gY29uY2F0KFtsZW5ndGhBbmRJbnB1dChmcm9tU3RyaW5nKGFsZykpLCBsZW5ndGhBbmRJbnB1dCh0eXBlb2YgcHJvZHVjZXJJbmZvID09PSAndW5kZWZpbmVkJyA/IG5ldyBVaW50OEFycmF5KDApIDogcHJvZHVjZXJJbmZvKSwgLy8gYXB1XG4gIGxlbmd0aEFuZElucHV0KHR5cGVvZiBjb25zdW1lckluZm8gPT09ICd1bmRlZmluZWQnID8gbmV3IFVpbnQ4QXJyYXkoMCkgOiBjb25zdW1lckluZm8pLCAvLyBhcHZcbiAgd3JpdGVVaW50MzJCRShrZXlMZW4pXSk7IC8vIHNpbmNlIG91ciBrZXkgbGVuZ2h0IGlzIDI1NiB3ZSBvbmx5IGhhdmUgdG8gZG8gb25lIHJvdW5kXG5cbiAgY29uc3Qgcm91bmROdW1iZXIgPSAxO1xuICByZXR1cm4gc2hhMjU2KGNvbmNhdChbd3JpdGVVaW50MzJCRShyb3VuZE51bWJlciksIHNlY3JldCwgdmFsdWVdKSk7XG59XG5cbi8qKlxuICogIENyZWF0ZXMgYSBjb25maWd1cmVkIHNpZ25lciBmdW5jdGlvbiBmb3Igc2lnbmluZyBkYXRhIHVzaW5nIHRoZSBFUzI1NksgKHNlY3AyNTZrMSArIHNoYTI1NikgYWxnb3JpdGhtLlxuICpcbiAqICBUaGUgc2lnbmluZyBmdW5jdGlvbiBpdHNlbGYgdGFrZXMgdGhlIGRhdGEgYXMgYSBgVWludDhBcnJheWAgb3IgYHN0cmluZ2AgYW5kIHJldHVybnMgYSBgYmFzZTY0VXJsYC1lbmNvZGVkIHNpZ25hdHVyZVxuICpcbiAqICBAZXhhbXBsZVxuICogIGBgYHR5cGVzY3JpcHRcbiAqICBjb25zdCBzaWduOiBTaWduZXIgPSBFUzI1NktTaWduZXIocHJvY2Vzcy5lbnYuUFJJVkFURV9LRVkpXG4gKiAgY29uc3Qgc2lnbmF0dXJlOiBzdHJpbmcgPSBhd2FpdCBzaWduKGRhdGEpXG4gKiAgYGBgXG4gKlxuICogIEBwYXJhbSAgICB7U3RyaW5nfSAgICBwcml2YXRlS2V5ICAgYSBwcml2YXRlIGtleSBhcyBgVWludDhBcnJheWBcbiAqICBAcGFyYW0gICAge0Jvb2xlYW59ICAgcmVjb3ZlcmFibGUgIGFuIG9wdGlvbmFsIGZsYWcgdG8gYWRkIHRoZSByZWNvdmVyeSBwYXJhbSB0byB0aGUgZ2VuZXJhdGVkIHNpZ25hdHVyZXNcbiAqICBAcmV0dXJuICAge0Z1bmN0aW9ufSAgICAgICAgICAgICAgIGEgY29uZmlndXJlZCBzaWduZXIgZnVuY3Rpb24gYChkYXRhOiBzdHJpbmcgfCBVaW50OEFycmF5KTogUHJvbWlzZTxzdHJpbmc+YFxuICovXG5cbmZ1bmN0aW9uIEVTMjU2S1NpZ25lcihwcml2YXRlS2V5LCByZWNvdmVyYWJsZSA9IGZhbHNlKSB7XG4gIGNvbnN0IHByaXZhdGVLZXlCeXRlcyA9IHByaXZhdGVLZXk7XG5cbiAgaWYgKHByaXZhdGVLZXlCeXRlcy5sZW5ndGggIT09IDMyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBiYWRfa2V5OiBJbnZhbGlkIHByaXZhdGUga2V5IGZvcm1hdC4gRXhwZWN0aW5nIDMyIGJ5dGVzLCBidXQgZ290ICR7cHJpdmF0ZUtleUJ5dGVzLmxlbmd0aH1gKTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBzaWduYXR1cmUgPSBzZWNwMjU2azEuc2lnbihzaGEyNTYoZGF0YSksIHByaXZhdGVLZXlCeXRlcyk7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRvSm9zZSh7XG4gICAgICAgIHI6IGxlZnRwYWQoc2lnbmF0dXJlLnIudG9TdHJpbmcoMTYpKSxcbiAgICAgICAgczogbGVmdHBhZChzaWduYXR1cmUucy50b1N0cmluZygxNikpLFxuICAgICAgICByZWNvdmVyeVBhcmFtOiBzaWduYXR1cmUucmVjb3ZlcnlcbiAgICAgIH0sIHJlY292ZXJhYmxlKSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGUpO1xuICAgIH1cbiAgfTtcbn1cblxuLyoqXG4gKiBAZGVwcmVjYXRlZCBQbGVhc2UgdXNlIEVTMjU2S1NpZ25lclxuICogIFRoZSBTaW1wbGVTaWduZXIgcmV0dXJucyBhIGNvbmZpZ3VyZWQgZnVuY3Rpb24gZm9yIHNpZ25pbmcgZGF0YS5cbiAqXG4gKiAgQGV4YW1wbGVcbiAqICBjb25zdCBzaWduZXIgPSBTaW1wbGVTaWduZXIocHJvY2Vzcy5lbnYuUFJJVkFURV9LRVkpXG4gKiAgc2lnbmVyKGRhdGEsIChlcnIsIHNpZ25hdHVyZSkgPT4ge1xuICogICAgLi4uXG4gKiAgfSlcbiAqXG4gKiAgQHBhcmFtICAgIHtTdHJpbmd9ICAgICAgICAgaGV4UHJpdmF0ZUtleSAgICBhIGhleCBlbmNvZGVkIHByaXZhdGUga2V5XG4gKiAgQHJldHVybiAgIHtGdW5jdGlvbn0gICAgICAgICAgICAgICAgICAgICBhIGNvbmZpZ3VyZWQgc2lnbmVyIGZ1bmN0aW9uXG4gKi9cblxuZnVuY3Rpb24gU2ltcGxlU2lnbmVyKGhleFByaXZhdGVLZXkpIHtcbiAgY29uc3Qgc2lnbmVyID0gRVMyNTZLU2lnbmVyKGhleFRvQnl0ZXMoaGV4UHJpdmF0ZUtleSksIHRydWUpO1xuICByZXR1cm4gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShzaWduZXIoZGF0YSkpLnRoZW4oZnJvbUpvc2UpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlKTtcbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogQGRlcHJlY2F0ZWQgUGxlYXNlIHVzZSBFUzI1NktTaWduZXJcbiAqICBUaGUgRWxsaXB0aWNTaWduZXIgcmV0dXJucyBhIGNvbmZpZ3VyZWQgZnVuY3Rpb24gZm9yIHNpZ25pbmcgZGF0YS5cbiAqXG4gKiAgQGV4YW1wbGVcbiAqICBgYGB0eXBlc2NyaXB0XG4gKiAgY29uc3Qgc2lnbmVyID0gRWxsaXB0aWNTaWduZXIocHJvY2Vzcy5lbnYuUFJJVkFURV9LRVkpXG4gKiAgc2lnbmVyKGRhdGEpLnRoZW4oIChzaWduYXR1cmU6IHN0cmluZykgPT4ge1xuICogICAgLi4uXG4gKiAgfSlcbiAqICBgYGBcbiAqXG4gKiAgQHBhcmFtICAgIHtTdHJpbmd9ICAgICAgICAgaGV4UHJpdmF0ZUtleSAgICBhIGhleCBlbmNvZGVkIHByaXZhdGUga2V5XG4gKiAgQHJldHVybiAgIHtGdW5jdGlvbn0gICAgICAgICAgICAgICAgICAgICAgICBhIGNvbmZpZ3VyZWQgc2lnbmVyIGZ1bmN0aW9uXG4gKi9cblxuZnVuY3Rpb24gRWxsaXB0aWNTaWduZXIoaGV4UHJpdmF0ZUtleSkge1xuICByZXR1cm4gRVMyNTZLU2lnbmVyKGhleFRvQnl0ZXMoaGV4UHJpdmF0ZUtleSkpO1xufVxuXG4vKipcbiAqICBDcmVhdGVzIGEgY29uZmlndXJlZCBzaWduZXIgZnVuY3Rpb24gZm9yIHNpZ25pbmcgZGF0YSB1c2luZyB0aGUgRWREU0EgKEVkMjU1MTkpIGFsZ29yaXRobS5cbiAqXG4gKiAgVGhlIHByaXZhdGUga2V5IGlzIGV4cGVjdGVkIHRvIGJlIGEgYFVpbnQ4QXJyYXlgIG9mIDMyIGJ5dGVzLCBidXQgZm9yIGNvbXBhdGliaWxpdHkgNjQgYnl0ZXMgYXJlIGFsc28gYWNjZXB0YWJsZS5cbiAqIFVzZXJzIG9mIGBAc3RhYmxlbGliL2VkMjU1MTlgIG9yIGB0d2VldG5hY2xgIHdpbGwgYmUgYWJsZSB0byB1c2UgdGhlIDY0IGJ5dGUgc2VjcmV0IGtleXMgdGhhdCBsaWJyYXJ5IGdlbmVyYXRlcy5cbiAqIFRoZXNlIGxpYnJhcmllcyBwcmVjb21wdXRlIHRoZSBwdWJsaWMga2V5IGFuZCBhcHBlbmQgaXQgYXMgdGhlIGxhc3QgMzIgYnl0ZXMgb2YgdGhlIHNlY3JldEtleSwgdG8gc3BlZWQgdXAgbGF0ZXJcbiAqIHNpZ25pbmcgb3BlcmF0aW9ucy5cbiAqXG4gKiAgVGhlIHNpZ25pbmcgZnVuY3Rpb24gaXRzZWxmIHRha2VzIHRoZSBkYXRhIGFzIGEgYFVpbnQ4QXJyYXlgIG9yIHV0ZjggYHN0cmluZ2AgYW5kIHJldHVybnMgYSBgYmFzZTY0VXJsYC1lbmNvZGVkXG4gKiBzaWduYXR1cmVcbiAqXG4gKiAgQGV4YW1wbGVcbiAqICBgYGB0eXBlc2NyaXB0XG4gKiAgY29uc3Qgc2lnbjogU2lnbmVyID0gRWREU0FTaWduZXIocHJvY2Vzcy5lbnYuUFJJVkFURV9LRVkpXG4gKiAgY29uc3Qgc2lnbmF0dXJlOiBzdHJpbmcgPSBhd2FpdCBzaWduKGRhdGEpXG4gKiAgYGBgXG4gKlxuICogIEBwYXJhbSAgICB7U3RyaW5nfSAgICBzZWNyZXRLZXkgICBhIDMyIG9yIDY0IGJ5dGUgc2VjcmV0IGtleSBhcyBgVWludDhBcnJheWBcbiAqICBAcmV0dXJuICAge0Z1bmN0aW9ufSAgICAgICAgICAgICAgYSBjb25maWd1cmVkIHNpZ25lciBmdW5jdGlvbiBgKGRhdGE6IHN0cmluZyB8IFVpbnQ4QXJyYXkpOiBQcm9taXNlPHN0cmluZz5gXG4gKi9cblxuZnVuY3Rpb24gRWREU0FTaWduZXIoc2VjcmV0S2V5KSB7XG4gIGNvbnN0IHByaXZhdGVLZXlCeXRlcyA9IHNlY3JldEtleTtcblxuICBpZiAoIVszMiwgNjRdLmluY2x1ZGVzKHByaXZhdGVLZXlCeXRlcy5sZW5ndGgpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBiYWRfa2V5OiBJbnZhbGlkIHByaXZhdGUga2V5IGZvcm1hdC4gRXhwZWN0aW5nIDMyIG9yIDY0IGJ5dGVzLCBidXQgZ290ICR7cHJpdmF0ZUtleUJ5dGVzLmxlbmd0aH1gKTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBkYXRhQnl0ZXMgPSB0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycgPyBzdHJpbmdUb0J5dGVzKGRhdGEpIDogZGF0YTtcbiAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IGVkMjU1MTkuc2lnbihkYXRhQnl0ZXMsIHByaXZhdGVLZXlCeXRlcy5zbGljZSgwLCAzMikpO1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShieXRlc1RvQmFzZTY0dXJsKHNpZ25hdHVyZSkpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlKTtcbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogQGRlcHJlY2F0ZWQgUGxlYXNlIHVzZSBFZERTQVNpZ25lclxuICpcbiAqICBUaGUgTmFjbFNpZ25lciByZXR1cm5zIGEgY29uZmlndXJlZCBmdW5jdGlvbiBmb3Igc2lnbmluZyBkYXRhIHVzaW5nIHRoZSBFZDI1NTE5IGFsZ29yaXRobS5cbiAqXG4gKiAgVGhlIHNpZ25pbmcgZnVuY3Rpb24gaXRzZWxmIHRha2VzIHRoZSBkYXRhIGFzIGEgYHN0cmluZ2Agb3IgYFVpbnQ4QXJyYXlgIHBhcmFtZXRlciBhbmQgcmV0dXJucyBhXG4gKiAgIGBiYXNlNjRVcmxgLWVuY29kZWQgc2lnbmF0dXJlLlxuICpcbiAqICBAZXhhbXBsZVxuICogIGNvbnN0IHNpZ25lciA9IE5hY2xTaWduZXIocHJvY2Vzcy5lbnYuUFJJVkFURV9LRVkpXG4gKiAgY29uc3QgZGF0YTogc3RyaW5nID0gJy4uLidcbiAqICBzaWduZXIoZGF0YSkudGhlbiggKHNpZ25hdHVyZTogc3RyaW5nKSA9PiB7XG4gKiAgICAuLi5cbiAqICB9KVxuICpcbiAqICBAcGFyYW0gICAge1N0cmluZ30gICBiYXNlNjRQcml2YXRlS2V5ICAgIGEgNjQgYnl0ZSBiYXNlNjQgZW5jb2RlZCBwcml2YXRlIGtleVxuICogIEByZXR1cm4gICB7RnVuY3Rpb259ICAgICAgICAgICAgICAgICAgICAgYSBjb25maWd1cmVkIHNpZ25lciBmdW5jdGlvblxuICovXG5cbmZ1bmN0aW9uIE5hY2xTaWduZXIoYmFzZTY0UHJpdmF0ZUtleSkge1xuICByZXR1cm4gRWREU0FTaWduZXIoYmFzZTY0VG9CeXRlcyhiYXNlNjRQcml2YXRlS2V5KSk7XG59XG5cbi8qKlxuICogIENyZWF0ZXMgYSBjb25maWd1cmVkIHNpZ25lciBmdW5jdGlvbiBmb3Igc2lnbmluZyBkYXRhIHVzaW5nIHRoZSBFUzI1NiAoc2VjcDI1NnIxICsgc2hhMjU2KSBhbGdvcml0aG0uXG4gKlxuICogIFRoZSBzaWduaW5nIGZ1bmN0aW9uIGl0c2VsZiB0YWtlcyB0aGUgZGF0YSBhcyBhIGBVaW50OEFycmF5YCBvciBgc3RyaW5nYCBhbmQgcmV0dXJucyBhIGBiYXNlNjRVcmxgLWVuY29kZWQgc2lnbmF0dXJlXG4gKlxuICogIEBleGFtcGxlXG4gKiAgYGBgdHlwZXNjcmlwdFxuICogIGNvbnN0IHNpZ246IFNpZ25lciA9IEVTMjU2U2lnbmVyKHByb2Nlc3MuZW52LlBSSVZBVEVfS0VZKVxuICogIGNvbnN0IHNpZ25hdHVyZTogc3RyaW5nID0gYXdhaXQgc2lnbihkYXRhKVxuICogIGBgYFxuICpcbiAqICBAcGFyYW0gICAge1N0cmluZ30gICAgcHJpdmF0ZUtleSAgIGEgcHJpdmF0ZSBrZXkgYXMgYFVpbnQ4QXJyYXlgXG4gKiAgQHJldHVybiAgIHtGdW5jdGlvbn0gICAgICAgICAgICAgICBhIGNvbmZpZ3VyZWQgc2lnbmVyIGZ1bmN0aW9uIGAoZGF0YTogc3RyaW5nIHwgVWludDhBcnJheSk6IFByb21pc2U8c3RyaW5nPmBcbiAqL1xuXG5mdW5jdGlvbiBFUzI1NlNpZ25lcihwcml2YXRlS2V5KSB7XG4gIGlmIChwcml2YXRlS2V5Lmxlbmd0aCAhPT0gMzIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYGJhZF9rZXk6IEludmFsaWQgcHJpdmF0ZSBrZXkgZm9ybWF0LiBFeHBlY3RpbmcgMzIgYnl0ZXMsIGJ1dCBnb3QgJHtwcml2YXRlS2V5Lmxlbmd0aH1gKTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBzaWduYXR1cmUgPSBwMjU2LnNpZ24oc2hhMjU2KGRhdGEpLCBwcml2YXRlS2V5KTtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodG9Kb3NlKHtcbiAgICAgICAgcjogbGVmdHBhZChzaWduYXR1cmUuci50b1N0cmluZygxNikpLFxuICAgICAgICBzOiBsZWZ0cGFkKHNpZ25hdHVyZS5zLnRvU3RyaW5nKDE2KSlcbiAgICAgIH0pKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZSk7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBpbnN0YW5jZU9mRWNkc2FTaWduYXR1cmUob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiAncicgaW4gb2JqZWN0ICYmICdzJyBpbiBvYmplY3Q7XG59XG5cbmZ1bmN0aW9uIEVTMjU2U2lnbmVyQWxnKCkge1xuICByZXR1cm4gZnVuY3Rpb24gc2lnbihwYXlsb2FkLCBzaWduZXIpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShzaWduZXIocGF5bG9hZCkpLnRoZW4oZnVuY3Rpb24gKHNpZ25hdHVyZSkge1xuICAgICAgICBpZiAoaW5zdGFuY2VPZkVjZHNhU2lnbmF0dXJlKHNpZ25hdHVyZSkpIHtcbiAgICAgICAgICByZXR1cm4gdG9Kb3NlKHNpZ25hdHVyZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHNpZ25hdHVyZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGUpO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIEVTMjU2S1NpZ25lckFsZyhyZWNvdmVyYWJsZSkge1xuICByZXR1cm4gZnVuY3Rpb24gc2lnbihwYXlsb2FkLCBzaWduZXIpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShzaWduZXIocGF5bG9hZCkpLnRoZW4oZnVuY3Rpb24gKHNpZ25hdHVyZSkge1xuICAgICAgICBpZiAoaW5zdGFuY2VPZkVjZHNhU2lnbmF0dXJlKHNpZ25hdHVyZSkpIHtcbiAgICAgICAgICByZXR1cm4gdG9Kb3NlKHNpZ25hdHVyZSwgcmVjb3ZlcmFibGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChyZWNvdmVyYWJsZSAmJiB0eXBlb2YgZnJvbUpvc2Uoc2lnbmF0dXJlKS5yZWNvdmVyeVBhcmFtID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBub3Rfc3VwcG9ydGVkOiBFUzI1NkstUiBub3Qgc3VwcG9ydGVkIHdoZW4gc2lnbmVyIGRvZXNuJ3QgcHJvdmlkZSBhIHJlY292ZXJ5IHBhcmFtYCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHNpZ25hdHVyZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGUpO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIEVkMjU1MTlTaWduZXJBbGcoKSB7XG4gIHJldHVybiBmdW5jdGlvbiBzaWduKHBheWxvYWQsIHNpZ25lcikge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHNpZ25lcihwYXlsb2FkKSkudGhlbihmdW5jdGlvbiAoc2lnbmF0dXJlKSB7XG4gICAgICAgIGlmICghaW5zdGFuY2VPZkVjZHNhU2lnbmF0dXJlKHNpZ25hdHVyZSkpIHtcbiAgICAgICAgICByZXR1cm4gc2lnbmF0dXJlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZF9jb25maWc6IGV4cGVjdGVkIGEgc2lnbmVyIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIHN0cmluZyBpbnN0ZWFkIG9mIHNpZ25hdHVyZSBvYmplY3QnKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGUpO1xuICAgIH1cbiAgfTtcbn1cbmNvbnN0IGFsZ29yaXRobXMkMSA9IHtcbiAgRVMyNTY6IEVTMjU2U2lnbmVyQWxnKCksXG4gIEVTMjU2SzogRVMyNTZLU2lnbmVyQWxnKCksXG4gIC8vIFRoaXMgaXMgYSBub24tc3RhbmRhcmQgYWxnb3JpdGhtIGJ1dCByZXRhaW5lZCBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAgLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9kZWNlbnRyYWxpemVkLWlkZW50aXR5L2RpZC1qd3QvaXNzdWVzLzE0NlxuICAnRVMyNTZLLVInOiBFUzI1NktTaWduZXJBbGcodHJ1ZSksXG4gIC8vIFRoaXMgaXMgYWN0dWFsbHkgaW5jb3JyZWN0IGJ1dCByZXRhaW5lZCBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAgLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9kZWNlbnRyYWxpemVkLWlkZW50aXR5L2RpZC1qd3QvaXNzdWVzLzEzMFxuICBFZDI1NTE5OiBFZDI1NTE5U2lnbmVyQWxnKCksXG4gIEVkRFNBOiBFZDI1NTE5U2lnbmVyQWxnKClcbn07XG5cbmZ1bmN0aW9uIFNpZ25lckFsZyhhbGcpIHtcbiAgY29uc3QgaW1wbCA9IGFsZ29yaXRobXMkMVthbGddO1xuICBpZiAoIWltcGwpIHRocm93IG5ldyBFcnJvcihgbm90X3N1cHBvcnRlZDogVW5zdXBwb3J0ZWQgYWxnb3JpdGhtICR7YWxnfWApO1xuICByZXR1cm4gaW1wbDtcbn1cblxuZnVuY3Rpb24gcHVibGljS2V5VG9BZGRyZXNzJDEocHVibGljS2V5LCBvdGhlckFkZHJlc3MpIHtcbiAgLy8gVXNlIHRoZSBzYW1lIHZlcnNpb24vcHJlZml4IGJ5dGUgYXMgdGhlIGdpdmVuIGFkZHJlc3MuXG4gIGNvbnN0IHZlcnNpb24gPSBieXRlc1RvSGV4KGJhc2U1OFRvQnl0ZXMob3RoZXJBZGRyZXNzKS5zbGljZSgwLCAxKSk7XG4gIGNvbnN0IHB1YmxpY0tleUJ1ZmZlciA9IGhleFRvQnl0ZXMocHVibGljS2V5KTtcbiAgY29uc3QgcHVibGljS2V5SGFzaCA9IHJpcGVtZDE2MChzaGEyNTYocHVibGljS2V5QnVmZmVyKSk7XG4gIGNvbnN0IHN0ZXAxID0gdmVyc2lvbiArIGJ5dGVzVG9IZXgocHVibGljS2V5SGFzaCk7XG4gIGNvbnN0IHN0ZXAyID0gc2hhMjU2KGhleFRvQnl0ZXMoc3RlcDEpKTtcbiAgY29uc3Qgc3RlcDMgPSBzaGEyNTYoc3RlcDIpO1xuICBjb25zdCBjaGVja3N1bSA9IGJ5dGVzVG9IZXgoc3RlcDMpLnN1YnN0cmluZygwLCA4KTtcbiAgY29uc3Qgc3RlcDQgPSBzdGVwMSArIGNoZWNrc3VtO1xuICByZXR1cm4gYnl0ZXNUb0Jhc2U1OChoZXhUb0J5dGVzKHN0ZXA0KSk7XG59XG5cbmZ1bmN0aW9uIHB1YmxpY0tleVRvQWRkcmVzcyhwdWJsaWNLZXksIHByZWZpeCkge1xuICBjb25zdCBwdWJsaWNLZXlCdWZmZXIgPSBzZWNwMjU2azEuUHJvamVjdGl2ZVBvaW50LmZyb21IZXgocHVibGljS2V5KS50b1Jhd0J5dGVzKCk7XG4gIGNvbnN0IGhhc2ggPSByaXBlbWQxNjAoc2hhMjU2KHB1YmxpY0tleUJ1ZmZlcikpO1xuICBjb25zdCB3b3JkcyA9IGJlY2gzMi50b1dvcmRzKGhhc2gpO1xuICByZXR1cm4gYmVjaDMyLmVuY29kZShwcmVmaXgsIHdvcmRzKS5yZXBsYWNlKHByZWZpeCwgJycpO1xufVxuXG5mdW5jdGlvbiB2ZXJpZnlCbG9ja2NoYWluQWNjb3VudElkKHB1YmxpY0tleSwgYmxvY2tjaGFpbkFjY291bnRJZCkge1xuICBpZiAoYmxvY2tjaGFpbkFjY291bnRJZCkge1xuICAgIGNvbnN0IGNoYWluID0gYmxvY2tjaGFpbkFjY291bnRJZC5zcGxpdCgnOicpO1xuXG4gICAgc3dpdGNoIChjaGFpblswXSkge1xuICAgICAgY2FzZSAnYmlwMTIyJzpcbiAgICAgICAgY2hhaW5bY2hhaW4ubGVuZ3RoIC0gMV0gPSBwdWJsaWNLZXlUb0FkZHJlc3MkMShwdWJsaWNLZXksIGNoYWluW2NoYWluLmxlbmd0aCAtIDFdKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ2Nvc21vcyc6XG4gICAgICAgIGNoYWluW2NoYWluLmxlbmd0aCAtIDFdID0gcHVibGljS2V5VG9BZGRyZXNzKHB1YmxpY0tleSwgY2hhaW5bMV0pO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnZWlwMTU1JzpcbiAgICAgICAgY2hhaW5bY2hhaW4ubGVuZ3RoIC0gMV0gPSB0b0V0aGVyZXVtQWRkcmVzcyhwdWJsaWNLZXkpO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiBjaGFpbi5qb2luKCc6JykudG9Mb3dlckNhc2UoKSA9PT0gYmxvY2tjaGFpbkFjY291bnRJZC50b0xvd2VyQ2FzZSgpO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiB0b1NpZ25hdHVyZU9iamVjdChzaWduYXR1cmUsIHJlY292ZXJhYmxlID0gZmFsc2UpIHtcbiAgY29uc3QgcmF3U2lnID0gYmFzZTY0VG9CeXRlcyhzaWduYXR1cmUpO1xuXG4gIGlmIChyYXdTaWcubGVuZ3RoICE9PSAocmVjb3ZlcmFibGUgPyA2NSA6IDY0KSkge1xuICAgIHRocm93IG5ldyBFcnJvcignd3Jvbmcgc2lnbmF0dXJlIGxlbmd0aCcpO1xuICB9XG5cbiAgY29uc3QgciA9IGJ5dGVzVG9IZXgocmF3U2lnLnNsaWNlKDAsIDMyKSk7XG4gIGNvbnN0IHMgPSBieXRlc1RvSGV4KHJhd1NpZy5zbGljZSgzMiwgNjQpKTtcbiAgY29uc3Qgc2lnT2JqID0ge1xuICAgIHIsXG4gICAgc1xuICB9O1xuXG4gIGlmIChyZWNvdmVyYWJsZSkge1xuICAgIHNpZ09iai5yZWNvdmVyeVBhcmFtID0gcmF3U2lnWzY0XTtcbiAgfVxuXG4gIHJldHVybiBzaWdPYmo7XG59XG5mdW5jdGlvbiB0b1NpZ25hdHVyZU9iamVjdDIoc2lnbmF0dXJlLCByZWNvdmVyYWJsZSA9IGZhbHNlKSB7XG4gIGNvbnN0IGJ5dGVzID0gYmFzZTY0VG9CeXRlcyhzaWduYXR1cmUpO1xuXG4gIGlmIChieXRlcy5sZW5ndGggIT09IChyZWNvdmVyYWJsZSA/IDY1IDogNjQpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd3cm9uZyBzaWduYXR1cmUgbGVuZ3RoJyk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGNvbXBhY3Q6IGJ5dGVzLnNsaWNlKDAsIDY0KSxcbiAgICByZWNvdmVyeTogYnl0ZXNbNjRdXG4gIH07XG59XG5mdW5jdGlvbiB2ZXJpZnlFUzI1NihkYXRhLCBzaWduYXR1cmUsIGF1dGhlbnRpY2F0b3JzKSB7XG4gIGNvbnN0IGhhc2ggPSBzaGEyNTYoZGF0YSk7XG4gIGNvbnN0IHNpZyA9IHAyNTYuU2lnbmF0dXJlLmZyb21Db21wYWN0KHRvU2lnbmF0dXJlT2JqZWN0MihzaWduYXR1cmUpLmNvbXBhY3QpO1xuICBjb25zdCBmdWxsUHVibGljS2V5cyA9IGF1dGhlbnRpY2F0b3JzLmZpbHRlcihhID0+ICFhLmV0aGVyZXVtQWRkcmVzcyAmJiAhYS5ibG9ja2NoYWluQWNjb3VudElkKTtcbiAgY29uc3Qgc2lnbmVyID0gZnVsbFB1YmxpY0tleXMuZmluZChwayA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAga2V5Qnl0ZXNcbiAgICAgIH0gPSBleHRyYWN0UHVibGljS2V5Qnl0ZXMocGspO1xuICAgICAgcmV0dXJuIHAyNTYudmVyaWZ5KHNpZywgaGFzaCwga2V5Qnl0ZXMpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSk7XG4gIGlmICghc2lnbmVyKSB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWRfc2lnbmF0dXJlOiBTaWduYXR1cmUgaW52YWxpZCBmb3IgSldUJyk7XG4gIHJldHVybiBzaWduZXI7XG59XG5mdW5jdGlvbiB2ZXJpZnlFUzI1NksoZGF0YSwgc2lnbmF0dXJlLCBhdXRoZW50aWNhdG9ycykge1xuICBjb25zdCBoYXNoID0gc2hhMjU2KGRhdGEpO1xuICBjb25zdCBzaWduYXR1cmVOb3JtYWxpemVkID0gc2VjcDI1NmsxLlNpZ25hdHVyZS5mcm9tQ29tcGFjdChiYXNlNjRUb0J5dGVzKHNpZ25hdHVyZSkpLm5vcm1hbGl6ZVMoKTtcbiAgY29uc3QgZnVsbFB1YmxpY0tleXMgPSBhdXRoZW50aWNhdG9ycy5maWx0ZXIoYSA9PiB7XG4gICAgcmV0dXJuICFhLmV0aGVyZXVtQWRkcmVzcyAmJiAhYS5ibG9ja2NoYWluQWNjb3VudElkO1xuICB9KTtcbiAgY29uc3QgYmxvY2tjaGFpbkFkZHJlc3NLZXlzID0gYXV0aGVudGljYXRvcnMuZmlsdGVyKGEgPT4ge1xuICAgIHJldHVybiBhLmV0aGVyZXVtQWRkcmVzcyB8fCBhLmJsb2NrY2hhaW5BY2NvdW50SWQ7XG4gIH0pO1xuICBsZXQgc2lnbmVyID0gZnVsbFB1YmxpY0tleXMuZmluZChwayA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAga2V5Qnl0ZXNcbiAgICAgIH0gPSBleHRyYWN0UHVibGljS2V5Qnl0ZXMocGspO1xuICAgICAgcmV0dXJuIHNlY3AyNTZrMS52ZXJpZnkoc2lnbmF0dXJlTm9ybWFsaXplZCwgaGFzaCwga2V5Qnl0ZXMpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSk7XG5cbiAgaWYgKCFzaWduZXIgJiYgYmxvY2tjaGFpbkFkZHJlc3NLZXlzLmxlbmd0aCA+IDApIHtcbiAgICBzaWduZXIgPSB2ZXJpZnlSZWNvdmVyYWJsZUVTMjU2SyhkYXRhLCBzaWduYXR1cmUsIGJsb2NrY2hhaW5BZGRyZXNzS2V5cyk7XG4gIH1cblxuICBpZiAoIXNpZ25lcikgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkX3NpZ25hdHVyZTogU2lnbmF0dXJlIGludmFsaWQgZm9yIEpXVCcpO1xuICByZXR1cm4gc2lnbmVyO1xufVxuZnVuY3Rpb24gdmVyaWZ5UmVjb3ZlcmFibGVFUzI1NksoZGF0YSwgc2lnbmF0dXJlLCBhdXRoZW50aWNhdG9ycykge1xuICBjb25zdCBzaWduYXR1cmVzID0gW107XG5cbiAgaWYgKHNpZ25hdHVyZS5sZW5ndGggPiA4Nikge1xuICAgIHNpZ25hdHVyZXMucHVzaCh0b1NpZ25hdHVyZU9iamVjdDIoc2lnbmF0dXJlLCB0cnVlKSk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3Qgc28gPSB0b1NpZ25hdHVyZU9iamVjdDIoc2lnbmF0dXJlLCBmYWxzZSk7XG4gICAgc2lnbmF0dXJlcy5wdXNoKHsgLi4uc28sXG4gICAgICByZWNvdmVyeTogMFxuICAgIH0pO1xuICAgIHNpZ25hdHVyZXMucHVzaCh7IC4uLnNvLFxuICAgICAgcmVjb3Zlcnk6IDFcbiAgICB9KTtcbiAgfVxuXG4gIGNvbnN0IGhhc2ggPSBzaGEyNTYoZGF0YSk7XG5cbiAgY29uc3QgY2hlY2tTaWduYXR1cmVBZ2FpbnN0U2lnbmVyID0gc2lnT2JqID0+IHtcbiAgICBjb25zdCBzaWduYXR1cmUgPSBzZWNwMjU2azEuU2lnbmF0dXJlLmZyb21Db21wYWN0KHNpZ09iai5jb21wYWN0KS5hZGRSZWNvdmVyeUJpdChzaWdPYmoucmVjb3ZlcnkgfHwgMCk7XG4gICAgY29uc3QgcmVjb3ZlcmVkUHVibGljS2V5ID0gc2lnbmF0dXJlLnJlY292ZXJQdWJsaWNLZXkoaGFzaCk7XG4gICAgY29uc3QgcmVjb3ZlcmVkQWRkcmVzcyA9IHRvRXRoZXJldW1BZGRyZXNzKHJlY292ZXJlZFB1YmxpY0tleS50b0hleChmYWxzZSkpLnRvTG93ZXJDYXNlKCk7XG4gICAgY29uc3QgcmVjb3ZlcmVkUHVibGljS2V5SGV4ID0gcmVjb3ZlcmVkUHVibGljS2V5LnRvSGV4KGZhbHNlKTtcbiAgICBjb25zdCByZWNvdmVyZWRDb21wcmVzc2VkUHVibGljS2V5SGV4ID0gcmVjb3ZlcmVkUHVibGljS2V5LnRvSGV4KHRydWUpO1xuICAgIHJldHVybiBhdXRoZW50aWNhdG9ycy5maW5kKGEgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBrZXlCeXRlc1xuICAgICAgfSA9IGV4dHJhY3RQdWJsaWNLZXlCeXRlcyhhKTtcbiAgICAgIGNvbnN0IGtleUhleCA9IGJ5dGVzVG9IZXgoa2V5Qnl0ZXMpO1xuICAgICAgcmV0dXJuIGtleUhleCA9PT0gcmVjb3ZlcmVkUHVibGljS2V5SGV4IHx8IGtleUhleCA9PT0gcmVjb3ZlcmVkQ29tcHJlc3NlZFB1YmxpY0tleUhleCB8fCBhLmV0aGVyZXVtQWRkcmVzcz8udG9Mb3dlckNhc2UoKSA9PT0gcmVjb3ZlcmVkQWRkcmVzcyB8fCBhLmJsb2NrY2hhaW5BY2NvdW50SWQ/LnNwbGl0KCdAZWlwMTU1Jyk/LlswXS50b0xvd2VyQ2FzZSgpID09PSByZWNvdmVyZWRBZGRyZXNzIHx8IC8vIENBSVAtMlxuICAgICAgdmVyaWZ5QmxvY2tjaGFpbkFjY291bnRJZChyZWNvdmVyZWRQdWJsaWNLZXlIZXgsIGEuYmxvY2tjaGFpbkFjY291bnRJZCkgLy8gQ0FJUC0xMFxuICAgICAgO1xuICAgIH0pO1xuICB9OyAvLyBGaW5kIGZpcnN0IHZlcmlmaWNhdGlvbiBtZXRob2RcblxuXG4gIGZvciAoY29uc3Qgc2lnbmF0dXJlIG9mIHNpZ25hdHVyZXMpIHtcbiAgICBjb25zdCB2ZXJpZmljYXRpb25NZXRob2QgPSBjaGVja1NpZ25hdHVyZUFnYWluc3RTaWduZXIoc2lnbmF0dXJlKTtcbiAgICBpZiAodmVyaWZpY2F0aW9uTWV0aG9kKSByZXR1cm4gdmVyaWZpY2F0aW9uTWV0aG9kO1xuICB9IC8vIElmIG5vIG9uZSBmb3VuZCBtYXRjaGluZ1xuXG5cbiAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkX3NpZ25hdHVyZTogU2lnbmF0dXJlIGludmFsaWQgZm9yIEpXVCcpO1xufVxuZnVuY3Rpb24gdmVyaWZ5RWQyNTUxOShkYXRhLCBzaWduYXR1cmUsIGF1dGhlbnRpY2F0b3JzKSB7XG4gIGNvbnN0IGNsZWFyID0gc3RyaW5nVG9CeXRlcyhkYXRhKTtcbiAgY29uc3Qgc2lnbmF0dXJlQnl0ZXMgPSBiYXNlNjRUb0J5dGVzKHNpZ25hdHVyZSk7XG4gIGNvbnN0IHNpZ25lciA9IGF1dGhlbnRpY2F0b3JzLmZpbmQoYSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAga2V5Qnl0ZXMsXG4gICAgICBrZXlUeXBlXG4gICAgfSA9IGV4dHJhY3RQdWJsaWNLZXlCeXRlcyhhKTtcblxuICAgIGlmIChrZXlUeXBlID09PSAnRWQyNTUxOScpIHtcbiAgICAgIHJldHVybiBlZDI1NTE5LnZlcmlmeShzaWduYXR1cmVCeXRlcywgY2xlYXIsIGtleUJ5dGVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSk7XG4gIGlmICghc2lnbmVyKSB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWRfc2lnbmF0dXJlOiBTaWduYXR1cmUgaW52YWxpZCBmb3IgSldUJyk7XG4gIHJldHVybiBzaWduZXI7XG59XG5jb25zdCBhbGdvcml0aG1zID0ge1xuICBFUzI1NjogdmVyaWZ5RVMyNTYsXG4gIEVTMjU2SzogdmVyaWZ5RVMyNTZLLFxuICAvLyBUaGlzIGlzIGEgbm9uLXN0YW5kYXJkIGFsZ29yaXRobSBidXQgcmV0YWluZWQgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vZGVjZW50cmFsaXplZC1pZGVudGl0eS9kaWQtand0L2lzc3Vlcy8xNDZcbiAgJ0VTMjU2Sy1SJzogdmVyaWZ5UmVjb3ZlcmFibGVFUzI1NkssXG4gIC8vIFRoaXMgaXMgYWN0dWFsbHkgaW5jb3JyZWN0IGJ1dCByZXRhaW5lZCBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAgLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9kZWNlbnRyYWxpemVkLWlkZW50aXR5L2RpZC1qd3QvaXNzdWVzLzEzMFxuICBFZDI1NTE5OiB2ZXJpZnlFZDI1NTE5LFxuICBFZERTQTogdmVyaWZ5RWQyNTUxOVxufTtcblxuZnVuY3Rpb24gVmVyaWZpZXJBbGdvcml0aG0oYWxnKSB7XG4gIGNvbnN0IGltcGwgPSBhbGdvcml0aG1zW2FsZ107XG4gIGlmICghaW1wbCkgdGhyb3cgbmV3IEVycm9yKGBub3Rfc3VwcG9ydGVkOiBVbnN1cHBvcnRlZCBhbGdvcml0aG0gJHthbGd9YCk7XG4gIHJldHVybiBpbXBsO1xufVxuXG5WZXJpZmllckFsZ29yaXRobS50b1NpZ25hdHVyZU9iamVjdCA9IHRvU2lnbmF0dXJlT2JqZWN0O1xuXG4vKipcbiAqIEVycm9yIHByZWZpeGVzIHVzZWQgZm9yIGtub3duIHZlcmlmaWNhdGlvbiBmYWlsdXJlIGNhc2VzLlxuICpcbiAqIEZvciBjb21wYXRpYmlsaXR5LCB0aGVzZSBlcnJvciBwcmVmaXhlcyBtYXRjaCB0aGUgZXhpc3RpbmcgZXJyb3IgbWVzc2FnZXMsIGJ1dCB3aWxsIGJlIGFkanVzdGVkIGluIGEgZnV0dXJlIG1ham9yXG4gKiB2ZXJzaW9uIHVwZGF0ZSB0byBtYXRjaCB0aGUgc2NlbmFyaW9zIGJldHRlci5cbiAqXG4gKiBAYmV0YVxuICovXG5jb25zdCBKV1RfRVJST1IgPSB7XG4gIC8qKlxuICAgKiBUaHJvd24gd2hlbiBhIEpXVCBwYXlsb2FkIHNjaGVtYSBpcyB1bmV4cGVjdGVkIG9yIHdoZW4gdmFsaWRpdHkgcGVyaW9kIGRvZXMgbm90IG1hdGNoXG4gICAqL1xuICBJTlZBTElEX0pXVDogJ2ludmFsaWRfand0JyxcblxuICAvKipcbiAgICogVGhyb3duIHdoZW4gdGhlIHZlcmlmaWVyIGF1ZGllbmNlIGRvZXMgbm90IG1hdGNoIHRoZSBvbmUgc2V0IGluIHRoZSBKV1QgcGF5bG9hZFxuICAgKi9cbiAgSU5WQUxJRF9BVURJRU5DRTogJ2ludmFsaWRfY29uZmlnJyxcblxuICAvKipcbiAgICogVGhyb3duIHdoZW4gbm9uZSBvZiB0aGUgcHVibGljIGtleXMgb2YgdGhlIGlzc3VlciBtYXRjaCB0aGUgc2lnbmF0dXJlIG9mIHRoZSBKV1QuXG4gICAqXG4gICAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byBgTk9fU1VJVEFCTEVfS0VZU2Agd2hlbiB0aGUgYHByb29mUHVycG9zZWAgaXMgTk9UIHNwZWNpZmllZC5cbiAgICovXG4gIElOVkFMSURfU0lHTkFUVVJFOiAnaW52YWxpZF9zaWduYXR1cmUnLFxuXG4gIC8qKlxuICAgKiBUaHJvd24gd2hlbiB0aGUgRElEIGRvY3VtZW50IG9mIHRoZSBpc3N1ZXIgZG9lcyBub3QgaGF2ZSBhbnkga2V5cyB0aGF0IG1hdGNoIHRoZSBzaWduYXR1cmUgZm9yIHRoZSBnaXZlblxuICAgKiBgcHJvb2ZQdXJwb3NlYC5cbiAgICpcbiAgICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIGBpbnZhbGlkX3NpZ25hdHVyZWAsIHdoZW4gYSBgcHJvb2ZQdXJwb3NlYCBpcyBzcGVjaWZpZWQuXG4gICAqL1xuICBOT19TVUlUQUJMRV9LRVlTOiAnbm9fc3VpdGFibGVfa2V5cycsXG5cbiAgLyoqXG4gICAqIFRocm93biB3aGVuIHRoZSBgYWxnYCBvZiB0aGUgSldUIG9yIHRoZSBlbmNvZGluZyBvZiB0aGUga2V5IGlzIG5vdCBzdXBwb3J0ZWRcbiAgICovXG4gIE5PVF9TVVBQT1JURUQ6ICdub3Rfc3VwcG9ydGVkJyxcblxuICAvKipcbiAgICogVGhyb3duIHdoZW4gdGhlIERJRCByZXNvbHZlciBpcyB1bmFibGUgdG8gcmVzb2x2ZSB0aGUgaXNzdWVyIERJRC5cbiAgICovXG4gIFJFU09MVkVSX0VSUk9SOiAncmVzb2x2ZXJfZXJyb3InXG59O1xuXG5mdW5jdGlvbiBfY2F0Y2gkMShib2R5LCByZWNvdmVyKSB7XG4gIHRyeSB7XG4gICAgdmFyIHJlc3VsdCA9IGJvZHkoKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiByZWNvdmVyKGUpO1xuICB9XG5cbiAgaWYgKHJlc3VsdCAmJiByZXN1bHQudGhlbikge1xuICAgIHJldHVybiByZXN1bHQudGhlbih2b2lkIDAsIHJlY292ZXIpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuY29uc3QgdmVyaWZ5Q29uZGl0aW9uRGVsZWdhdGVkID0gZnVuY3Rpb24gKGp3dCwge1xuICBoZWFkZXIsXG4gIHBheWxvYWQsXG4gIGRhdGEsXG4gIHNpZ25hdHVyZVxufSwgYXV0aGVudGljYXRvciwgb3B0aW9ucykge1xuICB0cnkge1xuICAgIGlmICghYXV0aGVudGljYXRvci5jb25kaXRpb25EZWxlZ2F0ZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgY29uZGl0aW9uRGVsZWdhdGVkJyk7XG4gICAgfVxuXG4gICAgaWYgKCFvcHRpb25zLnJlc29sdmVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHJlc29sdmVyJyk7XG4gICAgfVxuXG4gICAgbGV0IGZvdW5kU2lnbmVyO1xuICAgIGNvbnN0IGlzc3VlciA9IGF1dGhlbnRpY2F0b3IuY29uZGl0aW9uRGVsZWdhdGVkO1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzb2x2ZUF1dGhlbnRpY2F0b3Iob3B0aW9ucy5yZXNvbHZlciwgaGVhZGVyLmFsZywgaXNzdWVyLCBvcHRpb25zLnByb29mUHVycG9zZSkpLnRoZW4oZnVuY3Rpb24gKGRpZEF1dGhlbnRpY2F0b3IpIHtcbiAgICAgIGxldCBfZXhpdDI7XG5cbiAgICAgIGZ1bmN0aW9uIF90ZW1wNihfcmVzdWx0NCkge1xuICAgICAgICBpZiAoX2V4aXQyKSA7XG5cbiAgICAgICAgaWYgKGZvdW5kU2lnbmVyKSB7XG4gICAgICAgICAgcmV0dXJuIGF1dGhlbnRpY2F0b3I7XG4gICAgICAgIH1cblxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7SldUX0VSUk9SLklOVkFMSURfU0lHTkFUVVJFfTogY29uZGl0aW9uIGZvciBhdXRoZW50aWNhdG9yICR7YXV0aGVudGljYXRvci5pZH0gaXMgbm90IG1ldC5gKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZGlkUmVzb2x1dGlvblJlc3VsdCA9IGRpZEF1dGhlbnRpY2F0b3IuZGlkUmVzb2x1dGlvblJlc3VsdDtcblxuICAgICAgaWYgKCFkaWRSZXNvbHV0aW9uUmVzdWx0Py5kaWREb2N1bWVudCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7SldUX0VSUk9SLlJFU09MVkVSX0VSUk9SfTogQ291bGQgbm90IHJlc29sdmUgZGVsZWdhdGVkIERJRCAke2lzc3Vlcn0uYCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGRlbGVnYXRlZEF1dGhlbnRpY2F0b3IgPSBkaWRBdXRoZW50aWNhdG9yLmF1dGhlbnRpY2F0b3JzLmZpbmQoYXV0aGVudGljYXRvciA9PiBhdXRoZW50aWNhdG9yLmlkID09PSBpc3N1ZXIpO1xuXG4gICAgICBpZiAoIWRlbGVnYXRlZEF1dGhlbnRpY2F0b3IpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke0pXVF9FUlJPUi5OT19TVUlUQUJMRV9LRVlTfTogQ291bGQgbm90IGZpbmQgZGVsZWdhdGVkIGF1dGhlbnRpY2F0b3IgJHtpc3N1ZXJ9IGluIGl0J3MgRElEIERvY3VtZW50YCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IF90ZW1wNSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGRlbGVnYXRlZEF1dGhlbnRpY2F0b3IudHlwZSA9PT0gQ09ORElUSU9OQUxfUFJPT0ZfMjAyMikge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmVyaWZ5SldUKGp3dCwgeyAuLi5vcHRpb25zLFxuICAgICAgICAgICAgLi4ue1xuICAgICAgICAgICAgICBkaWRBdXRoZW50aWNhdG9yOiB7XG4gICAgICAgICAgICAgICAgZGlkUmVzb2x1dGlvblJlc3VsdCxcbiAgICAgICAgICAgICAgICBhdXRoZW50aWNhdG9yczogW2RlbGVnYXRlZEF1dGhlbnRpY2F0b3JdLFxuICAgICAgICAgICAgICAgIGlzc3VlcjogZGVsZWdhdGVkQXV0aGVudGljYXRvci5pZFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSkpLnRoZW4oZnVuY3Rpb24gKHtcbiAgICAgICAgICAgIHZlcmlmaWVkXG4gICAgICAgICAgfSkge1xuICAgICAgICAgICAgaWYgKHZlcmlmaWVkKSB7XG4gICAgICAgICAgICAgIGZvdW5kU2lnbmVyID0gZGVsZWdhdGVkQXV0aGVudGljYXRvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm91bmRTaWduZXIgPSB2ZXJpZnlKV1REZWNvZGVkKHtcbiAgICAgICAgICAgICAgaGVhZGVyLFxuICAgICAgICAgICAgICBwYXlsb2FkLFxuICAgICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgICBzaWduYXR1cmVcbiAgICAgICAgICAgIH0sIGRlbGVnYXRlZEF1dGhlbnRpY2F0b3IpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGlmICghZS5tZXNzYWdlLnN0YXJ0c1dpdGgoJ2ludmFsaWRfc2lnbmF0dXJlOicpKSB0aHJvdyBlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSgpO1xuXG4gICAgICByZXR1cm4gX3RlbXA1ICYmIF90ZW1wNS50aGVuID8gX3RlbXA1LnRoZW4oX3RlbXA2KSA6IF90ZW1wNihfdGVtcDUpO1xuICAgIH0pO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGUpO1xuICB9XG59O1xuXG5jb25zdCBfaXRlcmF0b3JTeW1ib2wkMSA9IHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgPyBTeW1ib2wuaXRlcmF0b3IgfHwgKFN5bWJvbC5pdGVyYXRvciA9IFN5bWJvbChcIlN5bWJvbC5pdGVyYXRvclwiKSkgOiBcIkBAaXRlcmF0b3JcIjtcblxuZnVuY3Rpb24gX3NldHRsZSQyKHBhY3QsIHN0YXRlLCB2YWx1ZSkge1xuICBpZiAoIXBhY3Qucykge1xuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIF9QYWN0JDIpIHtcbiAgICAgIGlmICh2YWx1ZS5zKSB7XG4gICAgICAgIGlmIChzdGF0ZSAmIDEpIHtcbiAgICAgICAgICBzdGF0ZSA9IHZhbHVlLnM7XG4gICAgICAgIH1cblxuICAgICAgICB2YWx1ZSA9IHZhbHVlLnY7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWx1ZS5vID0gX3NldHRsZSQyLmJpbmQobnVsbCwgcGFjdCwgc3RhdGUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlICYmIHZhbHVlLnRoZW4pIHtcbiAgICAgIHZhbHVlLnRoZW4oX3NldHRsZSQyLmJpbmQobnVsbCwgcGFjdCwgc3RhdGUpLCBfc2V0dGxlJDIuYmluZChudWxsLCBwYWN0LCAyKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcGFjdC5zID0gc3RhdGU7XG4gICAgcGFjdC52ID0gdmFsdWU7XG4gICAgY29uc3Qgb2JzZXJ2ZXIgPSBwYWN0Lm87XG5cbiAgICBpZiAob2JzZXJ2ZXIpIHtcbiAgICAgIG9ic2VydmVyKHBhY3QpO1xuICAgIH1cbiAgfVxufVxuXG5jb25zdCBfUGFjdCQyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gX1BhY3QoKSB7fVxuXG4gIF9QYWN0LnByb3RvdHlwZS50aGVuID0gZnVuY3Rpb24gKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IF9QYWN0KCk7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLnM7XG5cbiAgICBpZiAoc3RhdGUpIHtcbiAgICAgIGNvbnN0IGNhbGxiYWNrID0gc3RhdGUgJiAxID8gb25GdWxmaWxsZWQgOiBvblJlamVjdGVkO1xuXG4gICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBfc2V0dGxlJDIocmVzdWx0LCAxLCBjYWxsYmFjayh0aGlzLnYpKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIF9zZXR0bGUkMihyZXN1bHQsIDIsIGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMubyA9IGZ1bmN0aW9uIChfdGhpcykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBfdGhpcy52O1xuXG4gICAgICAgIGlmIChfdGhpcy5zICYgMSkge1xuICAgICAgICAgIF9zZXR0bGUkMihyZXN1bHQsIDEsIG9uRnVsZmlsbGVkID8gb25GdWxmaWxsZWQodmFsdWUpIDogdmFsdWUpO1xuICAgICAgICB9IGVsc2UgaWYgKG9uUmVqZWN0ZWQpIHtcbiAgICAgICAgICBfc2V0dGxlJDIocmVzdWx0LCAxLCBvblJlamVjdGVkKHZhbHVlKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX3NldHRsZSQyKHJlc3VsdCwgMiwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIF9zZXR0bGUkMihyZXN1bHQsIDIsIGUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIHJldHVybiBfUGFjdDtcbn0oKTtcblxuZnVuY3Rpb24gX2lzU2V0dGxlZFBhY3QkMih0aGVuYWJsZSkge1xuICByZXR1cm4gdGhlbmFibGUgaW5zdGFuY2VvZiBfUGFjdCQyICYmIHRoZW5hYmxlLnMgJiAxO1xufVxuXG5mdW5jdGlvbiBfZm9yVG8kMihhcnJheSwgYm9keSwgY2hlY2spIHtcbiAgdmFyIGkgPSAtMSxcbiAgICAgIHBhY3QsXG4gICAgICByZWplY3Q7XG5cbiAgZnVuY3Rpb24gX2N5Y2xlKHJlc3VsdCkge1xuICAgIHRyeSB7XG4gICAgICB3aGlsZSAoKytpIDwgYXJyYXkubGVuZ3RoICYmICghY2hlY2sgfHwgIWNoZWNrKCkpKSB7XG4gICAgICAgIHJlc3VsdCA9IGJvZHkoaSk7XG5cbiAgICAgICAgaWYgKHJlc3VsdCAmJiByZXN1bHQudGhlbikge1xuICAgICAgICAgIGlmIChfaXNTZXR0bGVkUGFjdCQyKHJlc3VsdCkpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC52O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQudGhlbihfY3ljbGUsIHJlamVjdCB8fCAocmVqZWN0ID0gX3NldHRsZSQyLmJpbmQobnVsbCwgcGFjdCA9IG5ldyBfUGFjdCQyKCksIDIpKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChwYWN0KSB7XG4gICAgICAgIF9zZXR0bGUkMihwYWN0LCAxLCByZXN1bHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFjdCA9IHJlc3VsdDtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBfc2V0dGxlJDIocGFjdCB8fCAocGFjdCA9IG5ldyBfUGFjdCQyKCkpLCAyLCBlKTtcbiAgICB9XG4gIH1cblxuICBfY3ljbGUoKTtcblxuICByZXR1cm4gcGFjdDtcbn1cblxuY29uc3QgdmVyaWZ5Q29uZGl0aW9uV2VpZ2h0ZWRUaHJlc2hvbGQgPSBmdW5jdGlvbiAoand0LCB7XG4gIGhlYWRlcixcbiAgcGF5bG9hZCxcbiAgZGF0YSxcbiAgc2lnbmF0dXJlXG59LCBhdXRoZW50aWNhdG9yLCBvcHRpb25zKSB7XG4gIHRyeSB7XG4gICAgbGV0IF9leGl0O1xuXG4gICAgZnVuY3Rpb24gX3RlbXA0KF9yZXN1bHQzKSB7XG4gICAgICBpZiAoX2V4aXQpIHJldHVybiBfcmVzdWx0MztcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHtKV1RfRVJST1IuSU5WQUxJRF9TSUdOQVRVUkV9OiBjb25kaXRpb24gZm9yIGF1dGhlbnRpY2F0b3IgJHthdXRoZW50aWNhdG9yLmlkfSBpcyBub3QgbWV0LmApO1xuICAgIH1cblxuICAgIGlmICghYXV0aGVudGljYXRvci5jb25kaXRpb25XZWlnaHRlZFRocmVzaG9sZCB8fCAhYXV0aGVudGljYXRvci50aHJlc2hvbGQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgY29uZGl0aW9uV2VpZ2h0ZWRUaHJlc2hvbGQgYW5kIHRocmVzaG9sZCcpO1xuICAgIH1cblxuICAgIGNvbnN0IGlzc3VlcnMgPSBbXTtcbiAgICBjb25zdCB0aHJlc2hvbGQgPSBhdXRoZW50aWNhdG9yLnRocmVzaG9sZDtcbiAgICBsZXQgd2VpZ2h0Q291bnQgPSAwO1xuXG4gICAgY29uc3QgX3RlbXAzID0gX2Zvck9mJDEoYXV0aGVudGljYXRvci5jb25kaXRpb25XZWlnaHRlZFRocmVzaG9sZCwgZnVuY3Rpb24gKHdlaWdodGVkQ29uZGl0aW9uKSB7XG4gICAgICBmdW5jdGlvbiBfdGVtcDIoX3Jlc3VsdDIpIHtcbiAgICAgICAgaWYgKF9leGl0KSByZXR1cm4gX3Jlc3VsdDI7XG5cbiAgICAgICAgaWYgKGZvdW5kU2lnbmVyICYmICFpc3N1ZXJzLmluY2x1ZGVzKGZvdW5kU2lnbmVyLmlkKSkge1xuICAgICAgICAgIGlzc3VlcnMucHVzaChmb3VuZFNpZ25lci5pZCk7XG4gICAgICAgICAgd2VpZ2h0Q291bnQgKz0gd2VpZ2h0ZWRDb25kaXRpb24ud2VpZ2h0O1xuXG4gICAgICAgICAgaWYgKHdlaWdodENvdW50ID49IHRocmVzaG9sZCkge1xuICAgICAgICAgICAgX2V4aXQgPSAxO1xuICAgICAgICAgICAgcmV0dXJuIGF1dGhlbnRpY2F0b3I7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGN1cnJlbnRDb25kaXRpb24gPSB3ZWlnaHRlZENvbmRpdGlvbi5jb25kaXRpb247XG4gICAgICBsZXQgZm91bmRTaWduZXI7XG5cbiAgICAgIGNvbnN0IF90ZW1wID0gX2NhdGNoJDEoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoY3VycmVudENvbmRpdGlvbi50eXBlID09PSBDT05ESVRJT05BTF9QUk9PRl8yMDIyKSB7XG4gICAgICAgICAgaWYgKCFvcHRpb25zLmRpZEF1dGhlbnRpY2F0b3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgZGlkQXV0aGVudGljYXRvcicpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IG5ld09wdGlvbnMgPSB7IC4uLm9wdGlvbnMsXG4gICAgICAgICAgICBkaWRBdXRoZW50aWNhdG9yOiB7XG4gICAgICAgICAgICAgIGRpZFJlc29sdXRpb25SZXN1bHQ6IG9wdGlvbnMuZGlkQXV0aGVudGljYXRvcj8uZGlkUmVzb2x1dGlvblJlc3VsdCxcbiAgICAgICAgICAgICAgYXV0aGVudGljYXRvcnM6IFtjdXJyZW50Q29uZGl0aW9uXSxcbiAgICAgICAgICAgICAgaXNzdWVyOiBjdXJyZW50Q29uZGl0aW9uLmlkXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZlcmlmeUpXVChqd3QsIG5ld09wdGlvbnMpKS50aGVuKGZ1bmN0aW9uICh7XG4gICAgICAgICAgICB2ZXJpZmllZFxuICAgICAgICAgIH0pIHtcbiAgICAgICAgICAgIGlmICh2ZXJpZmllZCkge1xuICAgICAgICAgICAgICBmb3VuZFNpZ25lciA9IGN1cnJlbnRDb25kaXRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2ZXJpZnlKV1REZWNvZGVkKHtcbiAgICAgICAgICAgIGhlYWRlcixcbiAgICAgICAgICAgIHBheWxvYWQsXG4gICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgc2lnbmF0dXJlXG4gICAgICAgICAgfSwgY3VycmVudENvbmRpdGlvbikpLnRoZW4oZnVuY3Rpb24gKF92ZXJpZnlKV1REZWNvZGVkKSB7XG4gICAgICAgICAgICBmb3VuZFNpZ25lciA9IF92ZXJpZnlKV1REZWNvZGVkO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9LCBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAoIWUubWVzc2FnZS5zdGFydHNXaXRoKEpXVF9FUlJPUi5JTlZBTElEX1NJR05BVFVSRSkpIHRocm93IGU7XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIF90ZW1wICYmIF90ZW1wLnRoZW4gPyBfdGVtcC50aGVuKF90ZW1wMikgOiBfdGVtcDIoX3RlbXApO1xuICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfZXhpdDtcbiAgICB9KTtcblxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoX3RlbXAzICYmIF90ZW1wMy50aGVuID8gX3RlbXAzLnRoZW4oX3RlbXA0KSA6IF90ZW1wNChfdGVtcDMpKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gX2Zvck9mJDEodGFyZ2V0LCBib2R5LCBjaGVjaykge1xuICBpZiAodHlwZW9mIHRhcmdldFtfaXRlcmF0b3JTeW1ib2wkMV0gPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHZhciBpdGVyYXRvciA9IHRhcmdldFtfaXRlcmF0b3JTeW1ib2wkMV0oKSxcbiAgICAgICAgc3RlcCxcbiAgICAgICAgcGFjdCxcbiAgICAgICAgcmVqZWN0O1xuXG4gICAgZnVuY3Rpb24gX2N5Y2xlKHJlc3VsdCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSAmJiAoIWNoZWNrIHx8ICFjaGVjaygpKSkge1xuICAgICAgICAgIHJlc3VsdCA9IGJvZHkoc3RlcC52YWx1ZSk7XG5cbiAgICAgICAgICBpZiAocmVzdWx0ICYmIHJlc3VsdC50aGVuKSB7XG4gICAgICAgICAgICBpZiAoX2lzU2V0dGxlZFBhY3QkMihyZXN1bHQpKSB7XG4gICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC52O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVzdWx0LnRoZW4oX2N5Y2xlLCByZWplY3QgfHwgKHJlamVjdCA9IF9zZXR0bGUkMi5iaW5kKG51bGwsIHBhY3QgPSBuZXcgX1BhY3QkMigpLCAyKSkpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBhY3QpIHtcbiAgICAgICAgICBfc2V0dGxlJDIocGFjdCwgMSwgcmVzdWx0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYWN0ID0gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIF9zZXR0bGUkMihwYWN0IHx8IChwYWN0ID0gbmV3IF9QYWN0JDIoKSksIDIsIGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIF9jeWNsZSgpO1xuXG4gICAgaWYgKGl0ZXJhdG9yLnJldHVybikge1xuICAgICAgdmFyIF9maXh1cCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmICghc3RlcC5kb25lKSB7XG4gICAgICAgICAgICBpdGVyYXRvci5yZXR1cm4oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUpIHt9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfTtcblxuICAgICAgaWYgKHBhY3QgJiYgcGFjdC50aGVuKSB7XG4gICAgICAgIHJldHVybiBwYWN0LnRoZW4oX2ZpeHVwLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIHRocm93IF9maXh1cChlKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIF9maXh1cCgpO1xuICAgIH1cblxuICAgIHJldHVybiBwYWN0O1xuICB9IC8vIE5vIHN1cHBvcnQgZm9yIFN5bWJvbC5pdGVyYXRvclxuXG5cbiAgaWYgKCEoXCJsZW5ndGhcIiBpbiB0YXJnZXQpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk9iamVjdCBpcyBub3QgaXRlcmFibGVcIik7XG4gIH0gLy8gSGFuZGxlIGxpdmUgY29sbGVjdGlvbnMgcHJvcGVybHlcblxuXG4gIHZhciB2YWx1ZXMgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRhcmdldC5sZW5ndGg7IGkrKykge1xuICAgIHZhbHVlcy5wdXNoKHRhcmdldFtpXSk7XG4gIH1cblxuICByZXR1cm4gX2ZvclRvJDIodmFsdWVzLCBmdW5jdGlvbiAoaSkge1xuICAgIHJldHVybiBib2R5KHZhbHVlc1tpXSk7XG4gIH0sIGNoZWNrKTtcbn1cblxuY29uc3QgdmVyaWZ5Q29uZGl0aW9uYWxQcm9vZiA9IGZ1bmN0aW9uIChqd3QsIHtcbiAgaGVhZGVyLFxuICBwYXlsb2FkLFxuICBzaWduYXR1cmUsXG4gIGRhdGFcbn0sIGF1dGhlbnRpY2F0b3IsIG9wdGlvbnMpIHtcbiAgdHJ5IHtcbiAgICAvLyBWYWxpZGF0ZSB0aGUgY29uZGl0aW9uIGFjY29yZGluZyB0byBpdHMgY29uZGl0aW9uIHByb3BlcnR5XG4gICAgaWYgKGF1dGhlbnRpY2F0b3IuY29uZGl0aW9uV2VpZ2h0ZWRUaHJlc2hvbGQpIHtcbiAgICAgIHJldHVybiB2ZXJpZnlDb25kaXRpb25XZWlnaHRlZFRocmVzaG9sZChqd3QsIHtcbiAgICAgICAgaGVhZGVyLFxuICAgICAgICBwYXlsb2FkLFxuICAgICAgICBkYXRhLFxuICAgICAgICBzaWduYXR1cmVcbiAgICAgIH0sIGF1dGhlbnRpY2F0b3IsIG9wdGlvbnMpO1xuICAgIH0gZWxzZSBpZiAoYXV0aGVudGljYXRvci5jb25kaXRpb25EZWxlZ2F0ZWQpIHtcbiAgICAgIHJldHVybiB2ZXJpZnlDb25kaXRpb25EZWxlZ2F0ZWQoand0LCB7XG4gICAgICAgIGhlYWRlcixcbiAgICAgICAgcGF5bG9hZCxcbiAgICAgICAgZGF0YSxcbiAgICAgICAgc2lnbmF0dXJlXG4gICAgICB9LCBhdXRoZW50aWNhdG9yLCBvcHRpb25zKTtcbiAgICB9IC8vIFRPRE8gb3RoZXIgY29uZGl0aW9uc1xuXG5cbiAgICB0aHJvdyBuZXcgRXJyb3IoYCR7SldUX0VSUk9SLklOVkFMSURfSldUfTogY29uZGl0aW9uYWwgcHJvb2YgdHlwZSBkaWQgbm90IGZpbmQgY29uZGl0aW9uIGZvciBhdXRoZW50aWNhdG9yICR7YXV0aGVudGljYXRvci5pZH0uYCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZSk7XG4gIH1cbn07XG5jb25zdCB2ZXJpZnlQcm9vZiA9IGZ1bmN0aW9uIChqd3QsIHtcbiAgaGVhZGVyLFxuICBwYXlsb2FkLFxuICBzaWduYXR1cmUsXG4gIGRhdGFcbn0sIGF1dGhlbnRpY2F0b3IsIG9wdGlvbnMpIHtcbiAgdHJ5IHtcbiAgICBpZiAoYXV0aGVudGljYXRvci50eXBlID09PSBDT05ESVRJT05BTF9QUk9PRl8yMDIyKSB7XG4gICAgICByZXR1cm4gdmVyaWZ5Q29uZGl0aW9uYWxQcm9vZihqd3QsIHtcbiAgICAgICAgcGF5bG9hZCxcbiAgICAgICAgaGVhZGVyLFxuICAgICAgICBzaWduYXR1cmUsXG4gICAgICAgIGRhdGFcbiAgICAgIH0sIGF1dGhlbnRpY2F0b3IsIG9wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZlcmlmeUpXVERlY29kZWQoe1xuICAgICAgICBoZWFkZXIsXG4gICAgICAgIHBheWxvYWQsXG4gICAgICAgIGRhdGEsXG4gICAgICAgIHNpZ25hdHVyZVxuICAgICAgfSwgW2F1dGhlbnRpY2F0b3JdKSk7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGUpO1xuICB9XG59O1xuY29uc3QgQ09ORElUSU9OQUxfUFJPT0ZfMjAyMiA9ICdDb25kaXRpb25hbFByb29mMjAyMic7XG5cbi8qKlxuICogUmVzb2x2ZXMgcmVsZXZhbnQgcHVibGljIGtleXMgb3Igb3RoZXIgYXV0aGVudGljYXRpbmcgbWF0ZXJpYWwgdXNlZCB0byB2ZXJpZnkgc2lnbmF0dXJlIGZyb20gdGhlIERJRCBkb2N1bWVudCBvZlxuICogcHJvdmlkZWQgRElEXG4gKlxuICogIEBleGFtcGxlXG4gKiAgYGBgdHNcbiAqICByZXNvbHZlQXV0aGVudGljYXRvcihyZXNvbHZlciwgJ0VTMjU2SycsICdkaWQ6dXBvcnQ6Mm5RdGlRRzZDZ20xR1lUQmFhS0Fncjc2dVk3aVNleFVrcVgnKS50aGVuKG9iaiA9PiB7XG4gKiAgICAgIGNvbnN0IHBheWxvYWQgPSBvYmoucGF5bG9hZFxuICogICAgICBjb25zdCBwcm9maWxlID0gb2JqLnByb2ZpbGVcbiAqICAgICAgY29uc3Qgand0ID0gb2JqLmp3dFxuICogICAgICAvLyAuLi5cbiAqICB9KVxuICogIGBgYFxuICpcbiAqICBAcGFyYW0gcmVzb2x2ZXIgLSB7UmVzb2x2YWJsZX0gYSBESUQgcmVzb2x2ZXIgZnVuY3Rpb24gdGhhdCBjYW4gb2J0YWluIHRoZSBgRElERG9jdW1lbnRgIGZvciB0aGUgYGlzc3VlcmBcbiAqICBAcGFyYW0gYWxnIC0ge1N0cmluZ30gYSBKV1QgYWxnb3JpdGhtXG4gKiAgQHBhcmFtIGlzc3VlciAtIHtTdHJpbmd9IGEgRGVjZW50cmFsaXplZCBJZGVudGlmaWVyIChESUQpIHRvIGxvb2t1cFxuICogIEBwYXJhbSBwcm9vZlB1cnBvc2UgLSB7UHJvb2ZQdXJwb3NlVHlwZXN9ICpPcHRpb25hbCogVXNlIHRoZSB2ZXJpZmljYXRpb25NZXRob2QgbGlua2VkIGluIHRoYXQgc2VjdGlvbiBvZiB0aGVcbiAqICAgaXNzdWVyIERJRCBkb2N1bWVudFxuICogIEByZXR1cm4ge1Byb21pc2U8RElEQXV0aGVudGljYXRvcj59IGEgcHJvbWlzZSB3aGljaCByZXNvbHZlcyB3aXRoIGFuIG9iamVjdCBjb250YWluaW5nIGFuIGFycmF5IG9mIGF1dGhlbnRpY2F0b3JzXG4gKiAgIG9yIHJlamVjdHMgd2l0aCBhbiBlcnJvciBpZiBub25lIGV4aXN0XG4gKi9cbmZ1bmN0aW9uIF9zZXR0bGUkMShwYWN0LCBzdGF0ZSwgdmFsdWUpIHtcbiAgaWYgKCFwYWN0LnMpIHtcbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBfUGFjdCQxKSB7XG4gICAgICBpZiAodmFsdWUucykge1xuICAgICAgICBpZiAoc3RhdGUgJiAxKSB7XG4gICAgICAgICAgc3RhdGUgPSB2YWx1ZS5zO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFsdWUgPSB2YWx1ZS52O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWUubyA9IF9zZXR0bGUkMS5iaW5kKG51bGwsIHBhY3QsIHN0YXRlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh2YWx1ZSAmJiB2YWx1ZS50aGVuKSB7XG4gICAgICB2YWx1ZS50aGVuKF9zZXR0bGUkMS5iaW5kKG51bGwsIHBhY3QsIHN0YXRlKSwgX3NldHRsZSQxLmJpbmQobnVsbCwgcGFjdCwgMikpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHBhY3QucyA9IHN0YXRlO1xuICAgIHBhY3QudiA9IHZhbHVlO1xuICAgIGNvbnN0IG9ic2VydmVyID0gcGFjdC5vO1xuXG4gICAgaWYgKG9ic2VydmVyKSB7XG4gICAgICBvYnNlcnZlcihwYWN0KTtcbiAgICB9XG4gIH1cbn1cblxuY29uc3QgX1BhY3QkMSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIF9QYWN0KCkge31cblxuICBfUGFjdC5wcm90b3R5cGUudGhlbiA9IGZ1bmN0aW9uIChvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBfUGFjdCgpO1xuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5zO1xuXG4gICAgaWYgKHN0YXRlKSB7XG4gICAgICBjb25zdCBjYWxsYmFjayA9IHN0YXRlICYgMSA/IG9uRnVsZmlsbGVkIDogb25SZWplY3RlZDtcblxuICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgX3NldHRsZSQxKHJlc3VsdCwgMSwgY2FsbGJhY2sodGhpcy52KSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBfc2V0dGxlJDEocmVzdWx0LCAyLCBlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLm8gPSBmdW5jdGlvbiAoX3RoaXMpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gX3RoaXMudjtcblxuICAgICAgICBpZiAoX3RoaXMucyAmIDEpIHtcbiAgICAgICAgICBfc2V0dGxlJDEocmVzdWx0LCAxLCBvbkZ1bGZpbGxlZCA/IG9uRnVsZmlsbGVkKHZhbHVlKSA6IHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIGlmIChvblJlamVjdGVkKSB7XG4gICAgICAgICAgX3NldHRsZSQxKHJlc3VsdCwgMSwgb25SZWplY3RlZCh2YWx1ZSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF9zZXR0bGUkMShyZXN1bHQsIDIsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBfc2V0dGxlJDEocmVzdWx0LCAyLCBlKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICByZXR1cm4gX1BhY3Q7XG59KCk7XG5cbmZ1bmN0aW9uIF9pc1NldHRsZWRQYWN0JDEodGhlbmFibGUpIHtcbiAgcmV0dXJuIHRoZW5hYmxlIGluc3RhbmNlb2YgX1BhY3QkMSAmJiB0aGVuYWJsZS5zICYgMTtcbn1cblxuZnVuY3Rpb24gX2ZvclRvJDEoYXJyYXksIGJvZHksIGNoZWNrKSB7XG4gIHZhciBpID0gLTEsXG4gICAgICBwYWN0LFxuICAgICAgcmVqZWN0O1xuXG4gIGZ1bmN0aW9uIF9jeWNsZShyZXN1bHQpIHtcbiAgICB0cnkge1xuICAgICAgd2hpbGUgKCsraSA8IGFycmF5Lmxlbmd0aCAmJiAoIWNoZWNrIHx8ICFjaGVjaygpKSkge1xuICAgICAgICByZXN1bHQgPSBib2R5KGkpO1xuXG4gICAgICAgIGlmIChyZXN1bHQgJiYgcmVzdWx0LnRoZW4pIHtcbiAgICAgICAgICBpZiAoX2lzU2V0dGxlZFBhY3QkMShyZXN1bHQpKSB7XG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQudjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0LnRoZW4oX2N5Y2xlLCByZWplY3QgfHwgKHJlamVjdCA9IF9zZXR0bGUkMS5iaW5kKG51bGwsIHBhY3QgPSBuZXcgX1BhY3QkMSgpLCAyKSkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAocGFjdCkge1xuICAgICAgICBfc2V0dGxlJDEocGFjdCwgMSwgcmVzdWx0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhY3QgPSByZXN1bHQ7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgX3NldHRsZSQxKHBhY3QgfHwgKHBhY3QgPSBuZXcgX1BhY3QkMSgpKSwgMiwgZSk7XG4gICAgfVxuICB9XG5cbiAgX2N5Y2xlKCk7XG5cbiAgcmV0dXJuIHBhY3Q7XG59XG5cbmZ1bmN0aW9uIF9jYXRjaChib2R5LCByZWNvdmVyKSB7XG4gIHRyeSB7XG4gICAgdmFyIHJlc3VsdCA9IGJvZHkoKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiByZWNvdmVyKGUpO1xuICB9XG5cbiAgaWYgKHJlc3VsdCAmJiByZXN1bHQudGhlbikge1xuICAgIHJldHVybiByZXN1bHQudGhlbih2b2lkIDAsIHJlY292ZXIpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gX2ZvciQxKHRlc3QsIHVwZGF0ZSwgYm9keSkge1xuICB2YXIgc3RhZ2U7XG5cbiAgZm9yICg7Oykge1xuICAgIHZhciBzaG91bGRDb250aW51ZSA9IHRlc3QoKTtcblxuICAgIGlmIChfaXNTZXR0bGVkUGFjdCQxKHNob3VsZENvbnRpbnVlKSkge1xuICAgICAgc2hvdWxkQ29udGludWUgPSBzaG91bGRDb250aW51ZS52O1xuICAgIH1cblxuICAgIGlmICghc2hvdWxkQ29udGludWUpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgaWYgKHNob3VsZENvbnRpbnVlLnRoZW4pIHtcbiAgICAgIHN0YWdlID0gMDtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHZhciByZXN1bHQgPSBib2R5KCk7XG5cbiAgICBpZiAocmVzdWx0ICYmIHJlc3VsdC50aGVuKSB7XG4gICAgICBpZiAoX2lzU2V0dGxlZFBhY3QkMShyZXN1bHQpKSB7XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdC5zO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhZ2UgPSAxO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodXBkYXRlKSB7XG4gICAgICB2YXIgdXBkYXRlVmFsdWUgPSB1cGRhdGUoKTtcblxuICAgICAgaWYgKHVwZGF0ZVZhbHVlICYmIHVwZGF0ZVZhbHVlLnRoZW4gJiYgIV9pc1NldHRsZWRQYWN0JDEodXBkYXRlVmFsdWUpKSB7XG4gICAgICAgIHN0YWdlID0gMjtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIHBhY3QgPSBuZXcgX1BhY3QkMSgpO1xuXG4gIHZhciByZWplY3QgPSBfc2V0dGxlJDEuYmluZChudWxsLCBwYWN0LCAyKTtcblxuICAoc3RhZ2UgPT09IDAgPyBzaG91bGRDb250aW51ZS50aGVuKF9yZXN1bWVBZnRlclRlc3QpIDogc3RhZ2UgPT09IDEgPyByZXN1bHQudGhlbihfcmVzdW1lQWZ0ZXJCb2R5KSA6IHVwZGF0ZVZhbHVlLnRoZW4oX3Jlc3VtZUFmdGVyVXBkYXRlKSkudGhlbih2b2lkIDAsIHJlamVjdCk7XG4gIHJldHVybiBwYWN0O1xuXG4gIGZ1bmN0aW9uIF9yZXN1bWVBZnRlckJvZHkodmFsdWUpIHtcbiAgICByZXN1bHQgPSB2YWx1ZTtcblxuICAgIGRvIHtcbiAgICAgIGlmICh1cGRhdGUpIHtcbiAgICAgICAgdXBkYXRlVmFsdWUgPSB1cGRhdGUoKTtcblxuICAgICAgICBpZiAodXBkYXRlVmFsdWUgJiYgdXBkYXRlVmFsdWUudGhlbiAmJiAhX2lzU2V0dGxlZFBhY3QkMSh1cGRhdGVWYWx1ZSkpIHtcbiAgICAgICAgICB1cGRhdGVWYWx1ZS50aGVuKF9yZXN1bWVBZnRlclVwZGF0ZSkudGhlbih2b2lkIDAsIHJlamVjdCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHNob3VsZENvbnRpbnVlID0gdGVzdCgpO1xuXG4gICAgICBpZiAoIXNob3VsZENvbnRpbnVlIHx8IF9pc1NldHRsZWRQYWN0JDEoc2hvdWxkQ29udGludWUpICYmICFzaG91bGRDb250aW51ZS52KSB7XG4gICAgICAgIF9zZXR0bGUkMShwYWN0LCAxLCByZXN1bHQpO1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHNob3VsZENvbnRpbnVlLnRoZW4pIHtcbiAgICAgICAgc2hvdWxkQ29udGludWUudGhlbihfcmVzdW1lQWZ0ZXJUZXN0KS50aGVuKHZvaWQgMCwgcmVqZWN0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICByZXN1bHQgPSBib2R5KCk7XG5cbiAgICAgIGlmIChfaXNTZXR0bGVkUGFjdCQxKHJlc3VsdCkpIHtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnY7XG4gICAgICB9XG4gICAgfSB3aGlsZSAoIXJlc3VsdCB8fCAhcmVzdWx0LnRoZW4pO1xuXG4gICAgcmVzdWx0LnRoZW4oX3Jlc3VtZUFmdGVyQm9keSkudGhlbih2b2lkIDAsIHJlamVjdCk7XG4gIH1cblxuICBmdW5jdGlvbiBfcmVzdW1lQWZ0ZXJUZXN0KHNob3VsZENvbnRpbnVlKSB7XG4gICAgaWYgKHNob3VsZENvbnRpbnVlKSB7XG4gICAgICByZXN1bHQgPSBib2R5KCk7XG5cbiAgICAgIGlmIChyZXN1bHQgJiYgcmVzdWx0LnRoZW4pIHtcbiAgICAgICAgcmVzdWx0LnRoZW4oX3Jlc3VtZUFmdGVyQm9keSkudGhlbih2b2lkIDAsIHJlamVjdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfcmVzdW1lQWZ0ZXJCb2R5KHJlc3VsdCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIF9zZXR0bGUkMShwYWN0LCAxLCByZXN1bHQpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIF9yZXN1bWVBZnRlclVwZGF0ZSgpIHtcbiAgICBpZiAoc2hvdWxkQ29udGludWUgPSB0ZXN0KCkpIHtcbiAgICAgIGlmIChzaG91bGRDb250aW51ZS50aGVuKSB7XG4gICAgICAgIHNob3VsZENvbnRpbnVlLnRoZW4oX3Jlc3VtZUFmdGVyVGVzdCkudGhlbih2b2lkIDAsIHJlamVjdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfcmVzdW1lQWZ0ZXJUZXN0KHNob3VsZENvbnRpbnVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgX3NldHRsZSQxKHBhY3QsIDEsIHJlc3VsdCk7XG4gICAgfVxuICB9XG59XG5cbmNvbnN0IHJlc29sdmVBdXRoZW50aWNhdG9yID0gZnVuY3Rpb24gKHJlc29sdmVyLCBhbGcsIGlzc3VlciwgcHJvb2ZQdXJwb3NlKSB7XG4gIHRyeSB7XG4gICAgY29uc3QgdHlwZXMgPSBTVVBQT1JURURfUFVCTElDX0tFWV9UWVBFU1thbGddO1xuXG4gICAgaWYgKCF0eXBlcyB8fCB0eXBlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHtKV1RfRVJST1IuTk9UX1NVUFBPUlRFRH06IE5vIHN1cHBvcnRlZCBzaWduYXR1cmUgdHlwZXMgZm9yIGFsZ29yaXRobSAke2FsZ31gKTtcbiAgICB9XG5cbiAgICBsZXQgZGlkUmVzdWx0O1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzb2x2ZXIucmVzb2x2ZShpc3N1ZXIsIHtcbiAgICAgIGFjY2VwdDogRElEX0pTT05cbiAgICB9KSkudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAvLyBzdXBwb3J0IGxlZ2FjeSByZXNvbHZlcnMgdGhhdCBkbyBub3QgcHJvZHVjZSBESURSZXNvbHV0aW9uUmVzdWx0XG4gICAgICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMocmVzdWx0KS5pbmRleE9mKCdkaWREb2N1bWVudCcpID09PSAtMSkge1xuICAgICAgICBkaWRSZXN1bHQgPSB7XG4gICAgICAgICAgZGlkRG9jdW1lbnQ6IHJlc3VsdCxcbiAgICAgICAgICBkaWREb2N1bWVudE1ldGFkYXRhOiB7fSxcbiAgICAgICAgICBkaWRSZXNvbHV0aW9uTWV0YWRhdGE6IHtcbiAgICAgICAgICAgIGNvbnRlbnRUeXBlOiBESURfSlNPTlxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRpZFJlc3VsdCA9IHJlc3VsdDtcbiAgICAgIH1cblxuICAgICAgaWYgKGRpZFJlc3VsdC5kaWRSZXNvbHV0aW9uTWV0YWRhdGE/LmVycm9yIHx8IGRpZFJlc3VsdC5kaWREb2N1bWVudCA9PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBlcnJvcixcbiAgICAgICAgICBtZXNzYWdlXG4gICAgICAgIH0gPSBkaWRSZXN1bHQuZGlkUmVzb2x1dGlvbk1ldGFkYXRhO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7SldUX0VSUk9SLlJFU09MVkVSX0VSUk9SfTogVW5hYmxlIHRvIHJlc29sdmUgRElEIGRvY3VtZW50IGZvciAke2lzc3Vlcn06ICR7ZXJyb3J9LCAke21lc3NhZ2UgfHwgJyd9YCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGdldFB1YmxpY0tleUJ5SWQgPSAodmVyaWZpY2F0aW9uTWV0aG9kcywgcHViaWQpID0+IHtcbiAgICAgICAgY29uc3QgZmlsdGVyZWQgPSB2ZXJpZmljYXRpb25NZXRob2RzLmZpbHRlcigoe1xuICAgICAgICAgIGlkXG4gICAgICAgIH0pID0+IHB1YmlkID09PSBpZCk7XG4gICAgICAgIHJldHVybiBmaWx0ZXJlZC5sZW5ndGggPiAwID8gZmlsdGVyZWRbMF0gOiBudWxsO1xuICAgICAgfTtcblxuICAgICAgbGV0IHB1YmxpY0tleXNUb0NoZWNrID0gWy4uLihkaWRSZXN1bHQ/LmRpZERvY3VtZW50Py52ZXJpZmljYXRpb25NZXRob2QgfHwgW10pLCAuLi4oZGlkUmVzdWx0Py5kaWREb2N1bWVudD8ucHVibGljS2V5IHx8IFtdKV07XG5cbiAgICAgIGlmICh0eXBlb2YgcHJvb2ZQdXJwb3NlID09PSAnc3RyaW5nJykge1xuICAgICAgICAvLyBzdXBwb3J0IGxlZ2FjeSBESUQgRG9jdW1lbnRzIHRoYXQgZG8gbm90IGxpc3QgYXNzZXJ0aW9uTWV0aG9kXG4gICAgICAgIGlmIChwcm9vZlB1cnBvc2Uuc3RhcnRzV2l0aCgnYXNzZXJ0aW9uJykgJiYgIU9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGRpZFJlc3VsdD8uZGlkRG9jdW1lbnQpLmluY2x1ZGVzKCdhc3NlcnRpb25NZXRob2QnKSkge1xuICAgICAgICAgIGRpZFJlc3VsdC5kaWREb2N1bWVudCA9IHsgLi4uZGlkUmVzdWx0LmRpZERvY3VtZW50XG4gICAgICAgICAgfTtcbiAgICAgICAgICBkaWRSZXN1bHQuZGlkRG9jdW1lbnQuYXNzZXJ0aW9uTWV0aG9kID0gWy4uLnB1YmxpY0tleXNUb0NoZWNrLm1hcChwayA9PiBway5pZCldO1xuICAgICAgICB9XG5cbiAgICAgICAgcHVibGljS2V5c1RvQ2hlY2sgPSAoZGlkUmVzdWx0LmRpZERvY3VtZW50W3Byb29mUHVycG9zZV0gfHwgW10pLm1hcCh2ZXJpZmljYXRpb25NZXRob2QgPT4ge1xuICAgICAgICAgIGlmICh0eXBlb2YgdmVyaWZpY2F0aW9uTWV0aG9kID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIGdldFB1YmxpY0tleUJ5SWQocHVibGljS2V5c1RvQ2hlY2ssIHZlcmlmaWNhdGlvbk1ldGhvZCk7XG4gICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmVyaWZpY2F0aW9uTWV0aG9kLnB1YmxpY0tleSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIC8vIHRoaXMgaXMgYSBsZWdhY3kgZm9ybWF0XG4gICAgICAgICAgICByZXR1cm4gZ2V0UHVibGljS2V5QnlJZChwdWJsaWNLZXlzVG9DaGVjaywgdmVyaWZpY2F0aW9uTWV0aG9kLnB1YmxpY0tleSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB2ZXJpZmljYXRpb25NZXRob2Q7XG4gICAgICAgICAgfVxuICAgICAgICB9KS5maWx0ZXIoa2V5ID0+IGtleSAhPSBudWxsKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgYXV0aGVudGljYXRvcnMgPSBwdWJsaWNLZXlzVG9DaGVjay5maWx0ZXIoKHtcbiAgICAgICAgdHlwZVxuICAgICAgfSkgPT4gdHlwZXMuZmluZChzdXBwb3J0ZWQgPT4gc3VwcG9ydGVkID09PSB0eXBlKSk7XG5cbiAgICAgIGlmICh0eXBlb2YgcHJvb2ZQdXJwb3NlID09PSAnc3RyaW5nJyAmJiAoIWF1dGhlbnRpY2F0b3JzIHx8IGF1dGhlbnRpY2F0b3JzLmxlbmd0aCA9PT0gMCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke0pXVF9FUlJPUi5OT19TVUlUQUJMRV9LRVlTfTogRElEIGRvY3VtZW50IGZvciAke2lzc3Vlcn0gZG9lcyBub3QgaGF2ZSBwdWJsaWMga2V5cyBzdWl0YWJsZSBmb3IgJHthbGd9IHdpdGggJHtwcm9vZlB1cnBvc2V9IHB1cnBvc2VgKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFhdXRoZW50aWNhdG9ycyB8fCBhdXRoZW50aWNhdG9ycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke0pXVF9FUlJPUi5OT19TVUlUQUJMRV9LRVlTfTogRElEIGRvY3VtZW50IGZvciAke2lzc3Vlcn0gZG9lcyBub3QgaGF2ZSBwdWJsaWMga2V5cyBmb3IgJHthbGd9YCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGF1dGhlbnRpY2F0b3JzLFxuICAgICAgICBpc3N1ZXIsXG4gICAgICAgIGRpZFJlc29sdXRpb25SZXN1bHQ6IGRpZFJlc3VsdFxuICAgICAgfTtcbiAgICB9KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlKTtcbiAgfVxufTtcblxuLyoqXG4gKiAgVmVyaWZpZXMgZ2l2ZW4gSldULiBJZiB0aGUgSldUIGlzIHZhbGlkLCB0aGUgcHJvbWlzZSByZXR1cm5zIGFuIG9iamVjdCBpbmNsdWRpbmcgdGhlIEpXVCwgdGhlIHBheWxvYWQgb2YgdGhlIEpXVCxcbiAqICBhbmQgdGhlIERJRCBkb2N1bWVudCBvZiB0aGUgaXNzdWVyIG9mIHRoZSBKV1QuXG4gKlxuICogIEBleGFtcGxlXG4gKiAgYGBgdHNcbiAqICB2ZXJpZnlKV1QoXG4gKiAgICAgICdkaWQ6dXBvcnQ6ZXlKMGVYQWlPaUpLVjFRaUxDSmhiR2NpT2lKRlV6STFOa3NpZlEuZXlKeVpYRjFaLi4uLicsXG4gKiAgICAgIHthdWRpZW5jZTogJzVBOGJSV1UzRjdqM1JFeDN2a0ouLi4nLCBjYWxsYmFja1VybDogJ2h0dHBzOi8vLi4uJ31cbiAqICAgICkudGhlbihvYmogPT4ge1xuICogICAgICAgIGNvbnN0IGRpZCA9IG9iai5kaWQgLy8gRElEIG9mIHNpZ25lclxuICogICAgICAgIGNvbnN0IHBheWxvYWQgPSBvYmoucGF5bG9hZFxuICogICAgICAgIGNvbnN0IGRvYyA9IG9iai5kaWRSZXNvbHV0aW9uUmVzdWx0LmRpZERvY3VtZW50IC8vIERJRCBEb2N1bWVudCBvZiBpc3N1ZXJcbiAqICAgICAgICBjb25zdCBqd3QgPSBvYmouand0XG4gKiAgICAgICAgY29uc3Qgc2lnbmVyS2V5SWQgPSBvYmouc2lnbmVyLmlkIC8vIElEIG9mIGtleSBpbiBESUQgZG9jdW1lbnQgdGhhdCBzaWduZWQgSldUXG4gKiAgICAgICAgLi4uXG4gKiAgICB9KVxuICogIGBgYFxuICpcbiAqICBAcGFyYW0gICAge1N0cmluZ30gICAgICAgICAgICBqd3QgICAgICAgICAgICAgICAgYSBKU09OIFdlYiBUb2tlbiB0byB2ZXJpZnlcbiAqICBAcGFyYW0gICAge09iamVjdH0gICAgICAgICAgICBbb3B0aW9uc10gICAgICAgICAgIGFuIHVuc2lnbmVkIGNyZWRlbnRpYWwgb2JqZWN0XG4gKiAgQHBhcmFtICAgIHtCb29sZWFufSAgICAgICAgICAgb3B0aW9ucy5hdXRoICAgICAgICBSZXF1aXJlIHNpZ25lciB0byBiZSBsaXN0ZWQgaW4gdGhlIGF1dGhlbnRpY2F0aW9uIHNlY3Rpb24gb2YgdGhlXG4gKiAgIERJRCBkb2N1bWVudCAoZm9yIEF1dGhlbnRpY2F0aW9uIHB1cnBvc2VzKVxuICogIEBwYXJhbSAgICB7U3RyaW5nfSAgICAgICAgICAgIG9wdGlvbnMuYXVkaWVuY2UgICAgRElEIG9mIHRoZSByZWNpcGllbnQgb2YgdGhlIEpXVFxuICogIEBwYXJhbSAgICB7U3RyaW5nfSAgICAgICAgICAgIG9wdGlvbnMuY2FsbGJhY2tVcmwgY2FsbGJhY2sgdXJsIGluIEpXVFxuICogIEByZXR1cm4gICB7UHJvbWlzZTxPYmplY3QsIEVycm9yPn0gICAgICAgICAgICAgICBhIHByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgd2l0aCBhIHJlc3BvbnNlIG9iamVjdCBvciByZWplY3RzIHdpdGggYW5cbiAqICAgZXJyb3JcbiAqL1xuY29uc3QgdmVyaWZ5SldUID0gZnVuY3Rpb24gKGp3dCwgb3B0aW9ucyA9IHtcbiAgcmVzb2x2ZXI6IHVuZGVmaW5lZCxcbiAgYXV0aDogdW5kZWZpbmVkLFxuICBhdWRpZW5jZTogdW5kZWZpbmVkLFxuICBjYWxsYmFja1VybDogdW5kZWZpbmVkLFxuICBza2V3VGltZTogdW5kZWZpbmVkLFxuICBwcm9vZlB1cnBvc2U6IHVuZGVmaW5lZCxcbiAgcG9saWNpZXM6IHt9LFxuICBkaWRBdXRoZW50aWNhdG9yOiB1bmRlZmluZWRcbn0pIHtcbiAgdHJ5IHtcbiAgICBmdW5jdGlvbiBfdGVtcDcoKSB7XG4gICAgICBsZXQgX2V4aXQ7XG5cbiAgICAgIGZ1bmN0aW9uIF90ZW1wNShfcmVzdWx0KSB7XG4gICAgICAgIGlmIChfZXhpdCkgO1xuXG4gICAgICAgIGlmIChzaWduZXIpIHtcbiAgICAgICAgICBjb25zdCBub3cgPSB0eXBlb2Ygb3B0aW9ucy5wb2xpY2llcz8ubm93ID09PSAnbnVtYmVyJyA/IG9wdGlvbnMucG9saWNpZXMubm93IDogTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMTAwMCk7XG4gICAgICAgICAgY29uc3Qgc2tld1RpbWUgPSB0eXBlb2Ygb3B0aW9ucy5za2V3VGltZSAhPT0gJ3VuZGVmaW5lZCcgJiYgb3B0aW9ucy5za2V3VGltZSA+PSAwID8gb3B0aW9ucy5za2V3VGltZSA6IE5CRl9TS0VXO1xuICAgICAgICAgIGNvbnN0IG5vd1NrZXdlZCA9IG5vdyArIHNrZXdUaW1lO1xuXG4gICAgICAgICAgaWYgKG9wdGlvbnMucG9saWNpZXM/Lm5iZiAhPT0gZmFsc2UgJiYgcGF5bG9hZC5uYmYpIHtcbiAgICAgICAgICAgIGlmIChwYXlsb2FkLm5iZiA+IG5vd1NrZXdlZCkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7SldUX0VSUk9SLklOVkFMSURfSldUfTogSldUIG5vdCB2YWxpZCBiZWZvcmUgbmJmOiAke3BheWxvYWQubmJmfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy5wb2xpY2llcz8uaWF0ICE9PSBmYWxzZSAmJiBwYXlsb2FkLmlhdCAmJiBwYXlsb2FkLmlhdCA+IG5vd1NrZXdlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke0pXVF9FUlJPUi5JTlZBTElEX0pXVH06IEpXVCBub3QgdmFsaWQgeWV0IChpc3N1ZWQgaW4gdGhlIGZ1dHVyZSkgaWF0OiAke3BheWxvYWQuaWF0fWApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChvcHRpb25zLnBvbGljaWVzPy5leHAgIT09IGZhbHNlICYmIHBheWxvYWQuZXhwICYmIHBheWxvYWQuZXhwIDw9IG5vdyAtIHNrZXdUaW1lKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7SldUX0VSUk9SLklOVkFMSURfSldUfTogSldUIGhhcyBleHBpcmVkOiBleHA6ICR7cGF5bG9hZC5leHB9IDwgbm93OiAke25vd31gKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAob3B0aW9ucy5wb2xpY2llcz8uYXVkICE9PSBmYWxzZSAmJiBwYXlsb2FkLmF1ZCkge1xuICAgICAgICAgICAgaWYgKCFvcHRpb25zLmF1ZGllbmNlICYmICFvcHRpb25zLmNhbGxiYWNrVXJsKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtKV1RfRVJST1IuSU5WQUxJRF9BVURJRU5DRX06IEpXVCBhdWRpZW5jZSBpcyByZXF1aXJlZCBidXQgeW91ciBhcHAgYWRkcmVzcyBoYXMgbm90IGJlZW4gY29uZmlndXJlZGApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBhdWRBcnJheSA9IEFycmF5LmlzQXJyYXkocGF5bG9hZC5hdWQpID8gcGF5bG9hZC5hdWQgOiBbcGF5bG9hZC5hdWRdO1xuICAgICAgICAgICAgY29uc3QgbWF0Y2hlZEF1ZGllbmNlID0gYXVkQXJyYXkuZmluZChpdGVtID0+IG9wdGlvbnMuYXVkaWVuY2UgPT09IGl0ZW0gfHwgb3B0aW9ucy5jYWxsYmFja1VybCA9PT0gaXRlbSk7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWF0Y2hlZEF1ZGllbmNlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7SldUX0VSUk9SLklOVkFMSURfQVVESUVOQ0V9OiBKV1QgYXVkaWVuY2UgZG9lcyBub3QgbWF0Y2ggeW91ciBESUQgb3IgY2FsbGJhY2sgdXJsYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZlcmlmaWVkOiB0cnVlLFxuICAgICAgICAgICAgcGF5bG9hZCxcbiAgICAgICAgICAgIGRpZFJlc29sdXRpb25SZXN1bHQsXG4gICAgICAgICAgICBpc3N1ZXIsXG4gICAgICAgICAgICBzaWduZXIsXG4gICAgICAgICAgICBqd3QsXG4gICAgICAgICAgICBwb2xpY2llczogb3B0aW9ucy5wb2xpY2llc1xuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7SldUX0VSUk9SLklOVkFMSURfU0lHTkFUVVJFfTogSldUIG5vdCB2YWxpZC4gaXNzdWVyIERJRCBkb2N1bWVudCBkb2VzIG5vdCBjb250YWluIGEgdmVyaWZpY2F0aW9uTWV0aG9kIHRoYXQgbWF0Y2hlcyB0aGUgc2lnbmF0dXJlLmApO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB7XG4gICAgICAgIGRpZFxuICAgICAgfSA9IHBhcnNlKGRpZFVybCk7XG4gICAgICBsZXQgc2lnbmVyID0gbnVsbDtcblxuICAgICAgY29uc3QgX3RlbXA0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoZGlkICE9PSBkaWRVcmwpIHtcbiAgICAgICAgICBjb25zdCBhdXRoZW50aWNhdG9yID0gYXV0aGVudGljYXRvcnMuZmluZChhdXRoID0+IGF1dGguaWQgPT09IGRpZFVybCk7XG5cbiAgICAgICAgICBpZiAoIWF1dGhlbnRpY2F0b3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtKV1RfRVJST1IuSU5WQUxJRF9KV1R9OiBObyBhdXRoZW50aWNhdG9yIGZvdW5kIGZvciBkaWQgVVJMICR7ZGlkVXJsfWApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmVyaWZ5UHJvb2Yoand0LCB7XG4gICAgICAgICAgICBwYXlsb2FkLFxuICAgICAgICAgICAgaGVhZGVyLFxuICAgICAgICAgICAgc2lnbmF0dXJlLFxuICAgICAgICAgICAgZGF0YVxuICAgICAgICAgIH0sIGF1dGhlbnRpY2F0b3IsIG9wdGlvbnMpKS50aGVuKGZ1bmN0aW9uIChfdmVyaWZ5UHJvb2YpIHtcbiAgICAgICAgICAgIHNpZ25lciA9IF92ZXJpZnlQcm9vZjtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgICAgcmV0dXJuIF9mb3IkMShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gIV9leGl0ICYmICFzaWduZXIgJiYgaSA8IGF1dGhlbnRpY2F0b3JzLmxlbmd0aDtcbiAgICAgICAgICB9LCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIF90ZW1wMyhfcmVzdWx0Mikge1xuICAgICAgICAgICAgICBpZiAoX2V4aXQpIDtcbiAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBhdXRoZW50aWNhdG9yID0gYXV0aGVudGljYXRvcnNbaV07XG5cbiAgICAgICAgICAgIGNvbnN0IF90ZW1wMiA9IF9jYXRjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmVyaWZ5UHJvb2Yoand0LCB7XG4gICAgICAgICAgICAgICAgcGF5bG9hZCxcbiAgICAgICAgICAgICAgICBoZWFkZXIsXG4gICAgICAgICAgICAgICAgc2lnbmF0dXJlLFxuICAgICAgICAgICAgICAgIGRhdGFcbiAgICAgICAgICAgICAgfSwgYXV0aGVudGljYXRvciwgb3B0aW9ucykpLnRoZW4oZnVuY3Rpb24gKF92ZXJpZnlQcm9vZjIpIHtcbiAgICAgICAgICAgICAgICBzaWduZXIgPSBfdmVyaWZ5UHJvb2YyO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgIGlmICghZS5tZXNzYWdlLmluY2x1ZGVzKEpXVF9FUlJPUi5JTlZBTElEX1NJR05BVFVSRSkgfHwgaSA9PT0gYXV0aGVudGljYXRvcnMubGVuZ3RoIC0gMSkgdGhyb3cgZTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gX3RlbXAyICYmIF90ZW1wMi50aGVuID8gX3RlbXAyLnRoZW4oX3RlbXAzKSA6IF90ZW1wMyhfdGVtcDIpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KCk7XG5cbiAgICAgIHJldHVybiBfdGVtcDQgJiYgX3RlbXA0LnRoZW4gPyBfdGVtcDQudGhlbihfdGVtcDUpIDogX3RlbXA1KF90ZW1wNCk7XG4gICAgfVxuXG4gICAgaWYgKCFvcHRpb25zLnJlc29sdmVyKSB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmdfcmVzb2x2ZXI6IE5vIERJRCByZXNvbHZlciBoYXMgYmVlbiBjb25maWd1cmVkJyk7XG4gICAgY29uc3Qge1xuICAgICAgcGF5bG9hZCxcbiAgICAgIGhlYWRlcixcbiAgICAgIHNpZ25hdHVyZSxcbiAgICAgIGRhdGFcbiAgICB9ID0gZGVjb2RlSldUKGp3dCwgZmFsc2UpO1xuICAgIGNvbnN0IHByb29mUHVycG9zZSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvcHRpb25zLCAnYXV0aCcpID8gb3B0aW9ucy5hdXRoID8gJ2F1dGhlbnRpY2F0aW9uJyA6IHVuZGVmaW5lZCA6IG9wdGlvbnMucHJvb2ZQdXJwb3NlO1xuICAgIGxldCBkaWRVcmw7XG5cbiAgICBpZiAoIXBheWxvYWQuaXNzICYmICFwYXlsb2FkLmNsaWVudF9pZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke0pXVF9FUlJPUi5JTlZBTElEX0pXVH06IEpXVCBpc3Mgb3IgY2xpZW50X2lkIGFyZSByZXF1aXJlZGApO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmRpZEF1dGhlbnRpY2F0b3IpIHtcbiAgICAgIGRpZFVybCA9IG9wdGlvbnMuZGlkQXV0aGVudGljYXRvci5pc3N1ZXI7XG4gICAgfSBlbHNlIGlmIChwYXlsb2FkLmlzcyA9PT0gU0VMRl9JU1NVRURfVjIgfHwgcGF5bG9hZC5pc3MgPT09IFNFTEZfSVNTVUVEX1YyX1ZDX0lOVEVST1ApIHtcbiAgICAgIGlmICghcGF5bG9hZC5zdWIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke0pXVF9FUlJPUi5JTlZBTElEX0pXVH06IEpXVCBzdWIgaXMgcmVxdWlyZWRgKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBwYXlsb2FkLnN1Yl9qd2sgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGRpZFVybCA9IHBheWxvYWQuc3ViO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGlkVXJsID0gKGhlYWRlci5raWQgfHwgJycpLnNwbGl0KCcjJylbMF07XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwYXlsb2FkLmlzcyA9PT0gU0VMRl9JU1NVRURfVjBfMSkge1xuICAgICAgaWYgKCFwYXlsb2FkLmRpZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7SldUX0VSUk9SLklOVkFMSURfSldUfTogSldUIGRpZCBpcyByZXF1aXJlZGApO1xuICAgICAgfVxuXG4gICAgICBkaWRVcmwgPSBwYXlsb2FkLmRpZDtcbiAgICB9IGVsc2UgaWYgKCFwYXlsb2FkLmlzcyAmJiBwYXlsb2FkLnNjb3BlID09PSAnb3BlbmlkJyAmJiBwYXlsb2FkLnJlZGlyZWN0X3VyaSkge1xuICAgICAgLy8gU0lPUCBSZXF1ZXN0IHBheWxvYWRcbiAgICAgIC8vIGh0dHBzOi8vaWRlbnRpdHkuZm91bmRhdGlvbi9qd3QtdmMtcHJlc2VudGF0aW9uLXByb2ZpbGUvI3NlbGYtaXNzdWVkLW9wLXJlcXVlc3Qtb2JqZWN0XG4gICAgICBpZiAoIXBheWxvYWQuY2xpZW50X2lkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtKV1RfRVJST1IuSU5WQUxJRF9KV1R9OiBKV1QgY2xpZW50X2lkIGlzIHJlcXVpcmVkYCk7XG4gICAgICB9XG5cbiAgICAgIGRpZFVybCA9IHBheWxvYWQuY2xpZW50X2lkO1xuICAgIH0gZWxzZSB7XG4gICAgICBkaWRVcmwgPSBwYXlsb2FkLmlzcztcbiAgICB9XG5cbiAgICBpZiAoIWRpZFVybCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke0pXVF9FUlJPUi5JTlZBTElEX0pXVH06IE5vIERJRCBoYXMgYmVlbiBmb3VuZCBpbiB0aGUgSldUYCk7XG4gICAgfVxuXG4gICAgbGV0IGF1dGhlbnRpY2F0b3JzO1xuICAgIGxldCBpc3N1ZXI7XG4gICAgbGV0IGRpZFJlc29sdXRpb25SZXN1bHQ7XG5cbiAgICBjb25zdCBfdGVtcDYgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAob3B0aW9ucy5kaWRBdXRoZW50aWNhdG9yKSB7XG4gICAgICAgICh7XG4gICAgICAgICAgZGlkUmVzb2x1dGlvblJlc3VsdCxcbiAgICAgICAgICBhdXRoZW50aWNhdG9ycyxcbiAgICAgICAgICBpc3N1ZXJcbiAgICAgICAgfSA9IG9wdGlvbnMuZGlkQXV0aGVudGljYXRvcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc29sdmVBdXRoZW50aWNhdG9yKG9wdGlvbnMucmVzb2x2ZXIsIGhlYWRlci5hbGcsIGRpZFVybCwgcHJvb2ZQdXJwb3NlKSkudGhlbihmdW5jdGlvbiAoX3Jlc29sdmVBdXRoZW50aWNhdG9yKSB7XG4gICAgICAgICAgKHtcbiAgICAgICAgICAgIGRpZFJlc29sdXRpb25SZXN1bHQsXG4gICAgICAgICAgICBhdXRoZW50aWNhdG9ycyxcbiAgICAgICAgICAgIGlzc3VlclxuICAgICAgICAgIH0gPSBfcmVzb2x2ZUF1dGhlbnRpY2F0b3IpO1xuICAgICAgICAgIC8vIEFkZCB0byBvcHRpb25zIG9iamVjdCBmb3IgcmVjdXJzaXZlIHJlZmVyZW5jZVxuICAgICAgICAgIG9wdGlvbnMuZGlkQXV0aGVudGljYXRvciA9IHtcbiAgICAgICAgICAgIGRpZFJlc29sdXRpb25SZXN1bHQsXG4gICAgICAgICAgICBhdXRoZW50aWNhdG9ycyxcbiAgICAgICAgICAgIGlzc3VlclxuICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0oKTtcblxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoX3RlbXA2ICYmIF90ZW1wNi50aGVuID8gX3RlbXA2LnRoZW4oX3RlbXA3KSA6IF90ZW1wNyhfdGVtcDYpKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlKTtcbiAgfVxufTtcblxuLyoqXG4gKiAgQ3JlYXRlcyBhIG11bHRpLXNpZ25hdHVyZSBzaWduZWQgSldUIGdpdmVuIG11bHRpcGxlIGlzc3VlcnMgYW5kIHRoZWlyIGNvcnJlc3BvbmRpbmcgc2lnbmVycywgYW5kIGEgcGF5bG9hZCBmb3JcbiAqIHdoaWNoIHRoZSBzaWduYXR1cmUgaXMgb3Zlci5cbiAqXG4gKiAgQGV4YW1wbGVcbiAqICBjb25zdCBzaWduZXIgPSBFUzI1NktTaWduZXIocHJvY2Vzcy5lbnYuUFJJVkFURV9LRVkpXG4gKiAgY3JlYXRlSldUKHthZGRyZXNzOiAnNUE4YlJXVTNGN2ozUkV4M3ZrSi4uLicsIHNpZ25lcn0sIHtrZXkxOiAndmFsdWUnLCBrZXkyOiAuLi4sIC4uLiB9KS50aGVuKGp3dCA9PiB7XG4gKiAgICAgIC4uLlxuICogIH0pXG4gKlxuICogIEBwYXJhbSAgICB7T2JqZWN0fSAgICAgICAgICAgIHBheWxvYWQgICAgICAgICAgICAgICBwYXlsb2FkIG9iamVjdFxuICogIEBwYXJhbSAgICB7T2JqZWN0fSAgICAgICAgICAgIFtvcHRpb25zXSAgICAgICAgICAgICBhbiB1bnNpZ25lZCBjcmVkZW50aWFsIG9iamVjdFxuICogIEBwYXJhbSAgICB7Ym9vbGVhbn0gICAgICAgICAgIG9wdGlvbnMuZXhwaXJlc0luICAgICBvcHRpb25hbCBmbGFnIHRvIGRlbm90ZSB0aGUgZXhwaXJhdGlvbiB0aW1lXG4gKiAgQHBhcmFtICAgIHtib29sZWFufSAgICAgICAgICAgb3B0aW9ucy5jYW5vbmljYWxpemUgIG9wdGlvbmFsIGZsYWcgdG8gY2Fub25pY2FsaXplIGhlYWRlciBhbmQgcGF5bG9hZCBiZWZvcmUgc2lnbmluZ1xuICogIEBwYXJhbSAgICB7T2JqZWN0W119ICAgICAgICAgIGlzc3VlcnMgICAgICAgICAgICAgICBhcnJheSBvZiB0aGUgaXNzdWVycywgdGhlaXIgc2lnbmVycyBhbmQgYWxnb3JpdGhtc1xuICogIEBwYXJhbSAgICB7c3RyaW5nfSAgICAgICAgICAgIGlzc3VlcnNbXS5pc3N1ZXIgICAgICBUaGUgRElEIG9mIHRoZSBpc3N1ZXIgKHNpZ25lcikgb2YgSldUXG4gKiAgQHBhcmFtICAgIHtTaWduZXJ9ICAgICAgICAgICAgaXNzdWVyc1tdLnNpZ25lciAgICAgIGEgYFNpZ25lcmAgZnVuY3Rpb24sIFBsZWFzZSBzZWUgYEVTMjU2S1NpZ25lcmAgb3IgYEVkRFNBU2lnbmVyYFxuICogIEBwYXJhbSAgICB7U3RyaW5nfSAgICAgICAgICAgIGlzc3VlcnNbXS5hbGcgICAgICAgICBbREVQUkVDQVRFRF0gVGhlIEpXVCBzaWduaW5nIGFsZ29yaXRobSB0byB1c2UuIFN1cHBvcnRzOlxuICogICBbRVMyNTZLLCBFUzI1NkstUiwgRWQyNTUxOSwgRWREU0FdLCBEZWZhdWx0cyB0bzogRVMyNTZLLiBQbGVhc2UgdXNlIGBoZWFkZXIuYWxnYCB0byBzcGVjaWZ5IHRoZSBhbGdvcml0aG1cbiAqICBAcmV0dXJuICAge1Byb21pc2U8T2JqZWN0LCBFcnJvcj59ICAgICAgICAgICAgICAgICAgYSBwcm9taXNlIHdoaWNoIHJlc29sdmVzIHdpdGggYSBzaWduZWQgSlNPTiBXZWIgVG9rZW4gb3JcbiAqICAgcmVqZWN0cyB3aXRoIGFuIGVycm9yXG4gKi9cbmNvbnN0IGNyZWF0ZU11bHRpc2lnbmF0dXJlSldUID0gZnVuY3Rpb24gKHBheWxvYWQsIHtcbiAgZXhwaXJlc0luLFxuICBjYW5vbmljYWxpemVcbn0sIGlzc3VlcnMpIHtcbiAgdHJ5IHtcbiAgICBpZiAoaXNzdWVycy5sZW5ndGggPT09IDApIHRocm93IG5ldyBFcnJvcignaW52YWxpZF9hcmd1bWVudDogbXVzdCBwcm92aWRlIG9uZSBvciBtb3JlIGlzc3VlcnMnKTtcbiAgICBsZXQgcGF5bG9hZFJlc3VsdCA9IHBheWxvYWQ7XG4gICAgbGV0IGp3dCA9ICcnO1xuXG4gICAgY29uc3QgX3RlbXAgPSBfZm9yVG8kMShpc3N1ZXJzLCBmdW5jdGlvbiAoaSkge1xuICAgICAgY29uc3QgaXNzdWVyID0gaXNzdWVyc1tpXTtcbiAgICAgIGNvbnN0IGhlYWRlciA9IHtcbiAgICAgICAgdHlwOiAnSldUJyxcbiAgICAgICAgYWxnOiBpc3N1ZXIuYWxnXG4gICAgICB9OyAvLyBDcmVhdGUgbmVzdGVkIEpXVFxuICAgICAgLy8gU2VlIFBvaW50IDUgb2YgaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzc1MTkjc2VjdGlvbi03LjFcbiAgICAgIC8vIEFmdGVyIHRoZSBmaXJzdCBKV1QgaXMgY3JlYXRlZCAodGhlIGZpcnN0IEpXUyksIHRoZSBuZXh0IEpXVCBpcyBjcmVhdGVkIGJ5IGlucHV0dGluZyB0aGUgcHJldmlvdXMgSldUIGFzIHRoZVxuICAgICAgLy8gcGF5bG9hZFxuXG4gICAgICBpZiAoaSAhPT0gMCkge1xuICAgICAgICBoZWFkZXIuY3R5ID0gJ0pXVCc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoY3JlYXRlSldUKHBheWxvYWRSZXN1bHQsIHsgLi4uaXNzdWVyLFxuICAgICAgICBjYW5vbmljYWxpemUsXG4gICAgICAgIGV4cGlyZXNJblxuICAgICAgfSwgaGVhZGVyKSkudGhlbihmdW5jdGlvbiAoX2NyZWF0ZUpXVCkge1xuICAgICAgICBqd3QgPSBfY3JlYXRlSldUO1xuICAgICAgICBwYXlsb2FkUmVzdWx0ID0ge1xuICAgICAgICAgIGp3dFxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKF90ZW1wICYmIF90ZW1wLnRoZW4gPyBfdGVtcC50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBqd3Q7XG4gICAgfSkgOiBqd3QpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGUpO1xuICB9XG59O1xuXG4vKipcbiAqICBDcmVhdGVzIGEgc2lnbmVkIEpXVCBnaXZlbiBhbiBhZGRyZXNzIHdoaWNoIGJlY29tZXMgdGhlIGlzc3VlciwgYSBzaWduZXIsIGFuZCBhIHBheWxvYWQgZm9yIHdoaWNoIHRoZSBzaWduYXR1cmUgaXNcbiAqIG92ZXIuXG4gKlxuICogIEBleGFtcGxlXG4gKiAgY29uc3Qgc2lnbmVyID0gRVMyNTZLU2lnbmVyKHByb2Nlc3MuZW52LlBSSVZBVEVfS0VZKVxuICogIGNyZWF0ZUpXVCh7YWRkcmVzczogJzVBOGJSV1UzRjdqM1JFeDN2a0ouLi4nLCBzaWduZXJ9LCB7a2V5MTogJ3ZhbHVlJywga2V5MjogLi4uLCAuLi4gfSkudGhlbihqd3QgPT4ge1xuICogICAgICAuLi5cbiAqICB9KVxuICpcbiAqICBAcGFyYW0gICAge09iamVjdH0gICAgICAgICAgICBwYXlsb2FkICAgICAgICAgICAgICAgcGF5bG9hZCBvYmplY3RcbiAqICBAcGFyYW0gICAge09iamVjdH0gICAgICAgICAgICBbb3B0aW9uc10gICAgICAgICAgICAgYW4gdW5zaWduZWQgY3JlZGVudGlhbCBvYmplY3RcbiAqICBAcGFyYW0gICAge1N0cmluZ30gICAgICAgICAgICBvcHRpb25zLmlzc3VlciAgICAgICAgVGhlIERJRCBvZiB0aGUgaXNzdWVyIChzaWduZXIpIG9mIEpXVFxuICogIEBwYXJhbSAgICB7U3RyaW5nfSAgICAgICAgICAgIG9wdGlvbnMuYWxnICAgICAgICAgICBbREVQUkVDQVRFRF0gVGhlIEpXVCBzaWduaW5nIGFsZ29yaXRobSB0byB1c2UuIFN1cHBvcnRzOlxuICogICBbRVMyNTZLLCBFUzI1NkstUiwgRWQyNTUxOSwgRWREU0FdLCBEZWZhdWx0cyB0bzogRVMyNTZLLiBQbGVhc2UgdXNlIGBoZWFkZXIuYWxnYCB0byBzcGVjaWZ5IHRoZSBhbGdvcml0aG1cbiAqICBAcGFyYW0gICAge1NpZ25lcn0gICAgICAgICAgICBvcHRpb25zLnNpZ25lciAgICAgICAgYSBgU2lnbmVyYCBmdW5jdGlvbiwgUGxlYXNlIHNlZSBgRVMyNTZLU2lnbmVyYCBvciBgRWREU0FTaWduZXJgXG4gKiAgQHBhcmFtICAgIHtib29sZWFufSAgICAgICAgICAgb3B0aW9ucy5jYW5vbmljYWxpemUgIG9wdGlvbmFsIGZsYWcgdG8gY2Fub25pY2FsaXplIGhlYWRlciBhbmQgcGF5bG9hZCBiZWZvcmUgc2lnbmluZ1xuICogIEBwYXJhbSAgICB7T2JqZWN0fSAgICAgICAgICAgIGhlYWRlciAgICAgICAgICAgICAgICBvcHRpb25hbCBvYmplY3QgdG8gc3BlY2lmeSBvciBjdXN0b21pemUgdGhlIEpXVCBoZWFkZXJcbiAqICBAcmV0dXJuICAge1Byb21pc2U8T2JqZWN0LCBFcnJvcj59ICAgICAgICAgICAgICAgICAgYSBwcm9taXNlIHdoaWNoIHJlc29sdmVzIHdpdGggYSBzaWduZWQgSlNPTiBXZWIgVG9rZW4gb3JcbiAqICAgcmVqZWN0cyB3aXRoIGFuIGVycm9yXG4gKi9cbmNvbnN0IGNyZWF0ZUpXVCA9IGZ1bmN0aW9uIChwYXlsb2FkLCB7XG4gIGlzc3VlcixcbiAgc2lnbmVyLFxuICBhbGcsXG4gIGV4cGlyZXNJbixcbiAgY2Fub25pY2FsaXplXG59LCBoZWFkZXIgPSB7fSkge1xuICB0cnkge1xuICAgIGlmICghc2lnbmVyKSB0aHJvdyBuZXcgRXJyb3IoJ21pc3Npbmdfc2lnbmVyOiBObyBTaWduZXIgZnVuY3Rpb25hbGl0eSBoYXMgYmVlbiBjb25maWd1cmVkJyk7XG4gICAgaWYgKCFpc3N1ZXIpIHRocm93IG5ldyBFcnJvcignbWlzc2luZ19pc3N1ZXI6IE5vIGlzc3VpbmcgRElEIGhhcyBiZWVuIGNvbmZpZ3VyZWQnKTtcbiAgICBpZiAoIWhlYWRlci50eXApIGhlYWRlci50eXAgPSAnSldUJztcbiAgICBpZiAoIWhlYWRlci5hbGcpIGhlYWRlci5hbGcgPSBhbGc7XG4gICAgY29uc3QgdGltZXN0YW1wcyA9IHtcbiAgICAgIGlhdDogTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMTAwMCksXG4gICAgICBleHA6IHVuZGVmaW5lZFxuICAgIH07XG5cbiAgICBpZiAoZXhwaXJlc0luKSB7XG4gICAgICBpZiAodHlwZW9mIGV4cGlyZXNJbiA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgdGltZXN0YW1wcy5leHAgPSAocGF5bG9hZC5uYmYgfHwgdGltZXN0YW1wcy5pYXQpICsgTWF0aC5mbG9vcihleHBpcmVzSW4pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkX2FyZ3VtZW50OiBKV1QgZXhwaXJlc0luIGlzIG5vdCBhIG51bWJlcicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGZ1bGxQYXlsb2FkID0geyAuLi50aW1lc3RhbXBzLFxuICAgICAgLi4ucGF5bG9hZCxcbiAgICAgIGlzczogaXNzdWVyXG4gICAgfTtcbiAgICByZXR1cm4gY3JlYXRlSldTKGZ1bGxQYXlsb2FkLCBzaWduZXIsIGhlYWRlciwge1xuICAgICAgY2Fub25pY2FsaXplXG4gICAgfSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZSk7XG4gIH1cbn07XG5cbi8qKlxuICogIENyZWF0ZXMgYSBzaWduZWQgSldTIGdpdmVuIGEgcGF5bG9hZCwgYSBzaWduZXIsIGFuZCBhbiBvcHRpb25hbCBoZWFkZXIuXG4gKlxuICogIEBleGFtcGxlXG4gKiAgY29uc3Qgc2lnbmVyID0gRVMyNTZLU2lnbmVyKHByb2Nlc3MuZW52LlBSSVZBVEVfS0VZKVxuICogIGNvbnN0IGp3cyA9IGF3YWl0IGNyZWF0ZUpXUyh7IG15OiAncGF5bG9hZCcgfSwgc2lnbmVyKVxuICpcbiAqICBAcGFyYW0gICAge09iamVjdH0gICAgICAgICAgICBwYXlsb2FkICAgICAgICAgICBwYXlsb2FkIG9iamVjdFxuICogIEBwYXJhbSAgICB7U2lnbmVyfSAgICAgICAgICAgIHNpZ25lciAgICAgICAgICAgIGEgc2lnbmVyLCBzZWUgYEVTMjU2S1NpZ25lciBvciBgRWREU0FTaWduZXJgXG4gKiAgQHBhcmFtICAgIHtPYmplY3R9ICAgICAgICAgICAgaGVhZGVyICAgICAgICAgICAgb3B0aW9uYWwgb2JqZWN0IHRvIHNwZWNpZnkgb3IgY3VzdG9taXplIHRoZSBKV1MgaGVhZGVyXG4gKiAgQHBhcmFtICAgIHtPYmplY3R9ICAgICAgICAgICAgb3B0aW9ucyAgICAgICAgICAgY2FuIGJlIHVzZWQgdG8gdHJpZ2dlciBhdXRvbWF0aWMgY2Fub25pY2FsaXphdGlvbiBvZiBoZWFkZXIgYW5kXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXlsb2FkIHByb3BlcnRpZXNcbiAqICBAcmV0dXJuICAge1Byb21pc2U8c3RyaW5nPn0gICAgICAgICAgICAgICAgICAgICBhIFByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgdG8gYSBKV1Mgc3RyaW5nIG9yIHJlamVjdHMgd2l0aCBhbiBlcnJvclxuICovXG5jb25zdCBjcmVhdGVKV1MgPSBmdW5jdGlvbiAocGF5bG9hZCwgc2lnbmVyLCBoZWFkZXIgPSB7fSwgb3B0aW9ucyA9IHt9KSB7XG4gIHRyeSB7XG4gICAgaWYgKCFoZWFkZXIuYWxnKSBoZWFkZXIuYWxnID0gZGVmYXVsdEFsZztcbiAgICBjb25zdCBlbmNvZGVkUGF5bG9hZCA9IHR5cGVvZiBwYXlsb2FkID09PSAnc3RyaW5nJyA/IHBheWxvYWQgOiBlbmNvZGVTZWN0aW9uKHBheWxvYWQsIG9wdGlvbnMuY2Fub25pY2FsaXplKTtcbiAgICBjb25zdCBzaWduaW5nSW5wdXQgPSBbZW5jb2RlU2VjdGlvbihoZWFkZXIsIG9wdGlvbnMuY2Fub25pY2FsaXplKSwgZW5jb2RlZFBheWxvYWRdLmpvaW4oJy4nKTtcbiAgICBjb25zdCBqd3RTaWduZXIgPSBTaWduZXJBbGcoaGVhZGVyLmFsZyk7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShqd3RTaWduZXIoc2lnbmluZ0lucHV0LCBzaWduZXIpKS50aGVuKGZ1bmN0aW9uIChzaWduYXR1cmUpIHtcbiAgICAgIC8vIEpXUyBDb21wYWN0IFNlcmlhbGl6YXRpb25cbiAgICAgIC8vIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM3NTE1I3NlY3Rpb24tNy4xXG4gICAgICByZXR1cm4gW3NpZ25pbmdJbnB1dCwgc2lnbmF0dXJlXS5qb2luKCcuJyk7XG4gICAgfSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZSk7XG4gIH1cbn07XG5jb25zdCBTRUxGX0lTU1VFRF9WMiA9ICdodHRwczovL3NlbGYtaXNzdWVkLm1lL3YyJztcbmNvbnN0IFNFTEZfSVNTVUVEX1YyX1ZDX0lOVEVST1AgPSAnaHR0cHM6Ly9zZWxmLWlzc3VlZC5tZS92Mi9vcGVuaWQtdmMnOyAvLyBodHRwczovL2lkZW50aXR5LmZvdW5kYXRpb24vand0LXZjLXByZXNlbnRhdGlvbi1wcm9maWxlLyNpZC10b2tlbi12YWxpZGF0aW9uXG5cbmNvbnN0IFNFTEZfSVNTVUVEX1YwXzEgPSAnaHR0cHM6Ly9zZWxmLWlzc3VlZC5tZSc7XG5jb25zdCBkZWZhdWx0QWxnID0gJ0VTMjU2Syc7XG5jb25zdCBESURfSlNPTiA9ICdhcHBsaWNhdGlvbi9kaWQranNvbic7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5cbmZ1bmN0aW9uIGVuY29kZVNlY3Rpb24oZGF0YSwgc2hvdWxkQ2Fub25pY2FsaXplID0gZmFsc2UpIHtcbiAgaWYgKHNob3VsZENhbm9uaWNhbGl6ZSkge1xuICAgIHJldHVybiBlbmNvZGVCYXNlNjR1cmwoY2Fub25pY2FsaXplRGF0YShkYXRhKSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGVuY29kZUJhc2U2NHVybChKU09OLnN0cmluZ2lmeShkYXRhKSk7XG4gIH1cbn1cblxuY29uc3QgTkJGX1NLRVcgPSAzMDA7XG5cbmZ1bmN0aW9uIGRlY29kZUpXUyhqd3MpIHtcbiAgY29uc3QgcGFydHMgPSBqd3MubWF0Y2goL14oW2EtekEtWjAtOV8tXSspXFwuKFthLXpBLVowLTlfLV0rKVxcLihbYS16QS1aMC05Xy1dKykkLyk7XG5cbiAgaWYgKHBhcnRzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGhlYWRlcjogSlNPTi5wYXJzZShkZWNvZGVCYXNlNjR1cmwocGFydHNbMV0pKSxcbiAgICAgIHBheWxvYWQ6IHBhcnRzWzJdLFxuICAgICAgc2lnbmF0dXJlOiBwYXJ0c1szXSxcbiAgICAgIGRhdGE6IGAke3BhcnRzWzFdfS4ke3BhcnRzWzJdfWBcbiAgICB9O1xuICB9XG5cbiAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkX2FyZ3VtZW50OiBJbmNvcnJlY3QgZm9ybWF0IEpXUycpO1xufVxuLyoqXG4gKiAgRGVjb2RlcyBhIEpXVCBhbmQgcmV0dXJucyBhbiBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBwYXlsb2FkXG4gKlxuICogIEBleGFtcGxlXG4gKiAgZGVjb2RlSldUKCdleUowZVhBaU9pSktWMVFpTENKaGJHY2lPaUpGVXpJMU5rc2lmUS5leUpwWVhRaU9qRTEuLi4nKVxuICpcbiAqICBAcGFyYW0gICAge1N0cmluZ30gICAgICAgICAgICBqd3QgICAgICAgICAgICAgICAgYSBKU09OIFdlYiBUb2tlbiB0byB2ZXJpZnlcbiAqIEBwYXJhbSAgICB7T2JqZWN0fSAgICAgICAgICAgIFtyZWN1cnNlXSAgICAgICAgICB3aGV0aGVyIHRvIHJlY3Vyc2UgaW50byB0aGUgcGF5bG9hZCB0byBkZWNvZGUgYW55IG5lc3RlZCBKV1RzXG4gKiAgQHJldHVybiAgIHtPYmplY3R9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEgSlMgb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgZGVjb2RlZCBKV1RcbiAqL1xuXG5cbmZ1bmN0aW9uIGRlY29kZUpXVChqd3QsIHJlY3Vyc2UgPSB0cnVlKSB7XG4gIGlmICghand0KSB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWRfYXJndW1lbnQ6IG5vIEpXVCBwYXNzZWQgaW50byBkZWNvZGVKV1QnKTtcblxuICB0cnkge1xuICAgIGNvbnN0IGp3cyA9IGRlY29kZUpXUyhqd3QpO1xuICAgIGNvbnN0IGRlY29kZWRKd3QgPSBPYmplY3QuYXNzaWduKGp3cywge1xuICAgICAgcGF5bG9hZDogSlNPTi5wYXJzZShkZWNvZGVCYXNlNjR1cmwoandzLnBheWxvYWQpKVxuICAgIH0pO1xuICAgIGNvbnN0IGlzcyA9IGRlY29kZWRKd3QucGF5bG9hZC5pc3M7XG5cbiAgICBpZiAoZGVjb2RlZEp3dC5oZWFkZXIuY3R5ID09PSAnSldUJyAmJiByZWN1cnNlKSB7XG4gICAgICBjb25zdCBpbm5lckRlY29kZWRKd3QgPSBkZWNvZGVKV1QoZGVjb2RlZEp3dC5wYXlsb2FkLmp3dCk7XG4gICAgICBpZiAoaW5uZXJEZWNvZGVkSnd0LnBheWxvYWQuaXNzICE9PSBpc3MpIHRocm93IG5ldyBFcnJvcihgJHtKV1RfRVJST1IuSU5WQUxJRF9KV1R9OiBtdWx0aXBsZSBpc3N1ZXJzYCk7XG4gICAgICByZXR1cm4gaW5uZXJEZWNvZGVkSnd0O1xuICAgIH1cblxuICAgIHJldHVybiBkZWNvZGVkSnd0O1xuICB9IGNhdGNoIChlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkX2FyZ3VtZW50OiAke0pXVF9FUlJPUi5JTlZBTElEX0pXVH06ICR7ZX1gKTtcbiAgfVxufVxuZnVuY3Rpb24gdmVyaWZ5SldURGVjb2RlZCh7XG4gIGhlYWRlcixcbiAgcGF5bG9hZCxcbiAgZGF0YSxcbiAgc2lnbmF0dXJlXG59LCBwdWJLZXlzKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShwdWJLZXlzKSkgcHViS2V5cyA9IFtwdWJLZXlzXTtcbiAgY29uc3QgaXNzID0gcGF5bG9hZC5pc3M7XG4gIGxldCByZWN1cnNlID0gdHJ1ZTtcblxuICBkbyB7XG4gICAgaWYgKGlzcyAhPT0gcGF5bG9hZC5pc3MpIHRocm93IG5ldyBFcnJvcihgJHtKV1RfRVJST1IuSU5WQUxJRF9KV1R9OiBtdWx0aXBsZSBpc3N1ZXJzYCk7XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gVmVyaWZpZXJBbGdvcml0aG0oaGVhZGVyLmFsZykoZGF0YSwgc2lnbmF0dXJlLCBwdWJLZXlzKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKCFlLm1lc3NhZ2Uuc3RhcnRzV2l0aChKV1RfRVJST1IuSU5WQUxJRF9TSUdOQVRVUkUpKSB0aHJvdyBlO1xuICAgIH0gLy8gVE9ETyBwcm9iYWJseSBiZXN0IHRvIGNyZWF0ZSBjb3B5IG9iamVjdHMgdGhhbiByZXBsYWNlIHJlZmVyZW5jZSBvYmplY3RzXG5cblxuICAgIGlmIChoZWFkZXIuY3R5ICE9PSAnSldUJykge1xuICAgICAgcmVjdXJzZSA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICAoe1xuICAgICAgICBwYXlsb2FkLFxuICAgICAgICBoZWFkZXIsXG4gICAgICAgIHNpZ25hdHVyZSxcbiAgICAgICAgZGF0YVxuICAgICAgfSA9IGRlY29kZUpXVChwYXlsb2FkLmp3dCwgZmFsc2UpKTtcbiAgICB9XG4gIH0gd2hpbGUgKHJlY3Vyc2UpO1xuXG4gIHRocm93IG5ldyBFcnJvcihgJHtKV1RfRVJST1IuSU5WQUxJRF9TSUdOQVRVUkV9OiBubyBtYXRjaGluZyBwdWJsaWMga2V5IGZvdW5kYCk7XG59XG5mdW5jdGlvbiB2ZXJpZnlKV1NEZWNvZGVkKHtcbiAgaGVhZGVyLFxuICBkYXRhLFxuICBzaWduYXR1cmVcbn0sIHB1YktleXMpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KHB1YktleXMpKSBwdWJLZXlzID0gW3B1YktleXNdO1xuICBjb25zdCBzaWduZXIgPSBWZXJpZmllckFsZ29yaXRobShoZWFkZXIuYWxnKShkYXRhLCBzaWduYXR1cmUsIHB1YktleXMpO1xuICByZXR1cm4gc2lnbmVyO1xufVxuLyoqXG4gKiAgVmVyaWZpZXMgZ2l2ZW4gSldTLiBJZiB0aGUgSldTIGlzIHZhbGlkLCByZXR1cm5zIHRoZSBwdWJsaWMga2V5IHRoYXQgd2FzXG4gKiAgdXNlZCB0byBzaWduIHRoZSBKV1MsIG9yIHRocm93cyBhbiBgRXJyb3JgIGlmIG5vbmUgb2YgdGhlIGBwdWJLZXlzYCBtYXRjaC5cbiAqXG4gKiAgQGV4YW1wbGVcbiAqICBjb25zdCBwdWJLZXkgPSB2ZXJpZnlKV1MoJ2V5SjBlWEFpT2lKS1YxUWlMQ0poYkdjaU9pSkZVekkxTmtzaWZRLmV5SnlaWEYxWi4uLi4nLCB7IHB1YmxpY0tleUhleDogJzB4MTIzNDEuLi4nIH0pXG4gKlxuICogIEBwYXJhbSAgICB7U3RyaW5nfSAgICAgICAgICAgICAgICAgICAgICAgICAgandzICAgICAgICAgQSBKV1Mgc3RyaW5nIHRvIHZlcmlmeVxuICogIEBwYXJhbSAgICB7QXJyYXk8VmVyaWZpY2F0aW9uTWV0aG9kPiB8IFZlcmlmaWNhdGlvbk1ldGhvZH0gICAgcHViS2V5cyAgICAgVGhlIHB1YmxpYyBrZXlzIHVzZWQgdG8gdmVyaWZ5IHRoZSBKV1NcbiAqICBAcmV0dXJuICAge1ZlcmlmaWNhdGlvbk1ldGhvZH0gICAgICAgICAgICAgICAgICAgICAgIFRoZSBwdWJsaWMga2V5IHVzZWQgdG8gc2lnbiB0aGUgSldTXG4gKi9cblxuZnVuY3Rpb24gdmVyaWZ5SldTKGp3cywgcHViS2V5cykge1xuICBjb25zdCBqd3NEZWNvZGVkID0gZGVjb2RlSldTKGp3cyk7XG4gIHJldHVybiB2ZXJpZnlKV1NEZWNvZGVkKGp3c0RlY29kZWQsIHB1YktleXMpO1xufVxuXG5jb25zdCBfaXRlcmF0b3JTeW1ib2wgPSB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiID8gU3ltYm9sLml0ZXJhdG9yIHx8IChTeW1ib2wuaXRlcmF0b3IgPSBTeW1ib2woXCJTeW1ib2wuaXRlcmF0b3JcIikpIDogXCJAQGl0ZXJhdG9yXCI7XG5cbmZ1bmN0aW9uIF9zZXR0bGUocGFjdCwgc3RhdGUsIHZhbHVlKSB7XG4gIGlmICghcGFjdC5zKSB7XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgX1BhY3QpIHtcbiAgICAgIGlmICh2YWx1ZS5zKSB7XG4gICAgICAgIGlmIChzdGF0ZSAmIDEpIHtcbiAgICAgICAgICBzdGF0ZSA9IHZhbHVlLnM7XG4gICAgICAgIH1cblxuICAgICAgICB2YWx1ZSA9IHZhbHVlLnY7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWx1ZS5vID0gX3NldHRsZS5iaW5kKG51bGwsIHBhY3QsIHN0YXRlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh2YWx1ZSAmJiB2YWx1ZS50aGVuKSB7XG4gICAgICB2YWx1ZS50aGVuKF9zZXR0bGUuYmluZChudWxsLCBwYWN0LCBzdGF0ZSksIF9zZXR0bGUuYmluZChudWxsLCBwYWN0LCAyKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcGFjdC5zID0gc3RhdGU7XG4gICAgcGFjdC52ID0gdmFsdWU7XG4gICAgY29uc3Qgb2JzZXJ2ZXIgPSBwYWN0Lm87XG5cbiAgICBpZiAob2JzZXJ2ZXIpIHtcbiAgICAgIG9ic2VydmVyKHBhY3QpO1xuICAgIH1cbiAgfVxufVxuXG5jb25zdCBfUGFjdCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIF9QYWN0KCkge31cblxuICBfUGFjdC5wcm90b3R5cGUudGhlbiA9IGZ1bmN0aW9uIChvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBfUGFjdCgpO1xuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5zO1xuXG4gICAgaWYgKHN0YXRlKSB7XG4gICAgICBjb25zdCBjYWxsYmFjayA9IHN0YXRlICYgMSA/IG9uRnVsZmlsbGVkIDogb25SZWplY3RlZDtcblxuICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgX3NldHRsZShyZXN1bHQsIDEsIGNhbGxiYWNrKHRoaXMudikpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgX3NldHRsZShyZXN1bHQsIDIsIGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMubyA9IGZ1bmN0aW9uIChfdGhpcykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBfdGhpcy52O1xuXG4gICAgICAgIGlmIChfdGhpcy5zICYgMSkge1xuICAgICAgICAgIF9zZXR0bGUocmVzdWx0LCAxLCBvbkZ1bGZpbGxlZCA/IG9uRnVsZmlsbGVkKHZhbHVlKSA6IHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIGlmIChvblJlamVjdGVkKSB7XG4gICAgICAgICAgX3NldHRsZShyZXN1bHQsIDEsIG9uUmVqZWN0ZWQodmFsdWUpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfc2V0dGxlKHJlc3VsdCwgMiwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIF9zZXR0bGUocmVzdWx0LCAyLCBlKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICByZXR1cm4gX1BhY3Q7XG59KCk7XG5cbmZ1bmN0aW9uIF9pc1NldHRsZWRQYWN0KHRoZW5hYmxlKSB7XG4gIHJldHVybiB0aGVuYWJsZSBpbnN0YW5jZW9mIF9QYWN0ICYmIHRoZW5hYmxlLnMgJiAxO1xufVxuXG5mdW5jdGlvbiBfZm9yVG8oYXJyYXksIGJvZHksIGNoZWNrKSB7XG4gIHZhciBpID0gLTEsXG4gICAgICBwYWN0LFxuICAgICAgcmVqZWN0O1xuXG4gIGZ1bmN0aW9uIF9jeWNsZShyZXN1bHQpIHtcbiAgICB0cnkge1xuICAgICAgd2hpbGUgKCsraSA8IGFycmF5Lmxlbmd0aCAmJiAoIWNoZWNrIHx8ICFjaGVjaygpKSkge1xuICAgICAgICByZXN1bHQgPSBib2R5KGkpO1xuXG4gICAgICAgIGlmIChyZXN1bHQgJiYgcmVzdWx0LnRoZW4pIHtcbiAgICAgICAgICBpZiAoX2lzU2V0dGxlZFBhY3QocmVzdWx0KSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnY7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdC50aGVuKF9jeWNsZSwgcmVqZWN0IHx8IChyZWplY3QgPSBfc2V0dGxlLmJpbmQobnVsbCwgcGFjdCA9IG5ldyBfUGFjdCgpLCAyKSkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAocGFjdCkge1xuICAgICAgICBfc2V0dGxlKHBhY3QsIDEsIHJlc3VsdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYWN0ID0gcmVzdWx0O1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIF9zZXR0bGUocGFjdCB8fCAocGFjdCA9IG5ldyBfUGFjdCgpKSwgMiwgZSk7XG4gICAgfVxuICB9XG5cbiAgX2N5Y2xlKCk7XG5cbiAgcmV0dXJuIHBhY3Q7XG59XG5cbmZ1bmN0aW9uIF9mb3JPZih0YXJnZXQsIGJvZHksIGNoZWNrKSB7XG4gIGlmICh0eXBlb2YgdGFyZ2V0W19pdGVyYXRvclN5bWJvbF0gPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHZhciBpdGVyYXRvciA9IHRhcmdldFtfaXRlcmF0b3JTeW1ib2xdKCksXG4gICAgICAgIHN0ZXAsXG4gICAgICAgIHBhY3QsXG4gICAgICAgIHJlamVjdDtcblxuICAgIGZ1bmN0aW9uIF9jeWNsZShyZXN1bHQpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUgJiYgKCFjaGVjayB8fCAhY2hlY2soKSkpIHtcbiAgICAgICAgICByZXN1bHQgPSBib2R5KHN0ZXAudmFsdWUpO1xuXG4gICAgICAgICAgaWYgKHJlc3VsdCAmJiByZXN1bHQudGhlbikge1xuICAgICAgICAgICAgaWYgKF9pc1NldHRsZWRQYWN0KHJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnY7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXN1bHQudGhlbihfY3ljbGUsIHJlamVjdCB8fCAocmVqZWN0ID0gX3NldHRsZS5iaW5kKG51bGwsIHBhY3QgPSBuZXcgX1BhY3QoKSwgMikpKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYWN0KSB7XG4gICAgICAgICAgX3NldHRsZShwYWN0LCAxLCByZXN1bHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhY3QgPSByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgX3NldHRsZShwYWN0IHx8IChwYWN0ID0gbmV3IF9QYWN0KCkpLCAyLCBlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBfY3ljbGUoKTtcblxuICAgIGlmIChpdGVyYXRvci5yZXR1cm4pIHtcbiAgICAgIHZhciBfZml4dXAgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoIXN0ZXAuZG9uZSkge1xuICAgICAgICAgICAgaXRlcmF0b3IucmV0dXJuKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7fVxuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH07XG5cbiAgICAgIGlmIChwYWN0ICYmIHBhY3QudGhlbikge1xuICAgICAgICByZXR1cm4gcGFjdC50aGVuKF9maXh1cCwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICB0aHJvdyBfZml4dXAoZSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBfZml4dXAoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGFjdDtcbiAgfSAvLyBObyBzdXBwb3J0IGZvciBTeW1ib2wuaXRlcmF0b3JcblxuXG4gIGlmICghKFwibGVuZ3RoXCIgaW4gdGFyZ2V0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJPYmplY3QgaXMgbm90IGl0ZXJhYmxlXCIpO1xuICB9IC8vIEhhbmRsZSBsaXZlIGNvbGxlY3Rpb25zIHByb3Blcmx5XG5cblxuICB2YXIgdmFsdWVzID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0YXJnZXQubGVuZ3RoOyBpKyspIHtcbiAgICB2YWx1ZXMucHVzaCh0YXJnZXRbaV0pO1xuICB9XG5cbiAgcmV0dXJuIF9mb3JUbyh2YWx1ZXMsIGZ1bmN0aW9uIChpKSB7XG4gICAgcmV0dXJuIGJvZHkodmFsdWVzW2ldKTtcbiAgfSwgY2hlY2spO1xufVxuXG5mdW5jdGlvbiBfZm9yKHRlc3QsIHVwZGF0ZSwgYm9keSkge1xuICB2YXIgc3RhZ2U7XG5cbiAgZm9yICg7Oykge1xuICAgIHZhciBzaG91bGRDb250aW51ZSA9IHRlc3QoKTtcblxuICAgIGlmIChfaXNTZXR0bGVkUGFjdChzaG91bGRDb250aW51ZSkpIHtcbiAgICAgIHNob3VsZENvbnRpbnVlID0gc2hvdWxkQ29udGludWUudjtcbiAgICB9XG5cbiAgICBpZiAoIXNob3VsZENvbnRpbnVlKSB7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGlmIChzaG91bGRDb250aW51ZS50aGVuKSB7XG4gICAgICBzdGFnZSA9IDA7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICB2YXIgcmVzdWx0ID0gYm9keSgpO1xuXG4gICAgaWYgKHJlc3VsdCAmJiByZXN1bHQudGhlbikge1xuICAgICAgaWYgKF9pc1NldHRsZWRQYWN0KHJlc3VsdCkpIHtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGFnZSA9IDE7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh1cGRhdGUpIHtcbiAgICAgIHZhciB1cGRhdGVWYWx1ZSA9IHVwZGF0ZSgpO1xuXG4gICAgICBpZiAodXBkYXRlVmFsdWUgJiYgdXBkYXRlVmFsdWUudGhlbiAmJiAhX2lzU2V0dGxlZFBhY3QodXBkYXRlVmFsdWUpKSB7XG4gICAgICAgIHN0YWdlID0gMjtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIHBhY3QgPSBuZXcgX1BhY3QoKTtcblxuICB2YXIgcmVqZWN0ID0gX3NldHRsZS5iaW5kKG51bGwsIHBhY3QsIDIpO1xuXG4gIChzdGFnZSA9PT0gMCA/IHNob3VsZENvbnRpbnVlLnRoZW4oX3Jlc3VtZUFmdGVyVGVzdCkgOiBzdGFnZSA9PT0gMSA/IHJlc3VsdC50aGVuKF9yZXN1bWVBZnRlckJvZHkpIDogdXBkYXRlVmFsdWUudGhlbihfcmVzdW1lQWZ0ZXJVcGRhdGUpKS50aGVuKHZvaWQgMCwgcmVqZWN0KTtcbiAgcmV0dXJuIHBhY3Q7XG5cbiAgZnVuY3Rpb24gX3Jlc3VtZUFmdGVyQm9keSh2YWx1ZSkge1xuICAgIHJlc3VsdCA9IHZhbHVlO1xuXG4gICAgZG8ge1xuICAgICAgaWYgKHVwZGF0ZSkge1xuICAgICAgICB1cGRhdGVWYWx1ZSA9IHVwZGF0ZSgpO1xuXG4gICAgICAgIGlmICh1cGRhdGVWYWx1ZSAmJiB1cGRhdGVWYWx1ZS50aGVuICYmICFfaXNTZXR0bGVkUGFjdCh1cGRhdGVWYWx1ZSkpIHtcbiAgICAgICAgICB1cGRhdGVWYWx1ZS50aGVuKF9yZXN1bWVBZnRlclVwZGF0ZSkudGhlbih2b2lkIDAsIHJlamVjdCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHNob3VsZENvbnRpbnVlID0gdGVzdCgpO1xuXG4gICAgICBpZiAoIXNob3VsZENvbnRpbnVlIHx8IF9pc1NldHRsZWRQYWN0KHNob3VsZENvbnRpbnVlKSAmJiAhc2hvdWxkQ29udGludWUudikge1xuICAgICAgICBfc2V0dGxlKHBhY3QsIDEsIHJlc3VsdCk7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2hvdWxkQ29udGludWUudGhlbikge1xuICAgICAgICBzaG91bGRDb250aW51ZS50aGVuKF9yZXN1bWVBZnRlclRlc3QpLnRoZW4odm9pZCAwLCByZWplY3QpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHJlc3VsdCA9IGJvZHkoKTtcblxuICAgICAgaWYgKF9pc1NldHRsZWRQYWN0KHJlc3VsdCkpIHtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnY7XG4gICAgICB9XG4gICAgfSB3aGlsZSAoIXJlc3VsdCB8fCAhcmVzdWx0LnRoZW4pO1xuXG4gICAgcmVzdWx0LnRoZW4oX3Jlc3VtZUFmdGVyQm9keSkudGhlbih2b2lkIDAsIHJlamVjdCk7XG4gIH1cblxuICBmdW5jdGlvbiBfcmVzdW1lQWZ0ZXJUZXN0KHNob3VsZENvbnRpbnVlKSB7XG4gICAgaWYgKHNob3VsZENvbnRpbnVlKSB7XG4gICAgICByZXN1bHQgPSBib2R5KCk7XG5cbiAgICAgIGlmIChyZXN1bHQgJiYgcmVzdWx0LnRoZW4pIHtcbiAgICAgICAgcmVzdWx0LnRoZW4oX3Jlc3VtZUFmdGVyQm9keSkudGhlbih2b2lkIDAsIHJlamVjdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfcmVzdW1lQWZ0ZXJCb2R5KHJlc3VsdCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIF9zZXR0bGUocGFjdCwgMSwgcmVzdWx0KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBfcmVzdW1lQWZ0ZXJVcGRhdGUoKSB7XG4gICAgaWYgKHNob3VsZENvbnRpbnVlID0gdGVzdCgpKSB7XG4gICAgICBpZiAoc2hvdWxkQ29udGludWUudGhlbikge1xuICAgICAgICBzaG91bGRDb250aW51ZS50aGVuKF9yZXN1bWVBZnRlclRlc3QpLnRoZW4odm9pZCAwLCByZWplY3QpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX3Jlc3VtZUFmdGVyVGVzdChzaG91bGRDb250aW51ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIF9zZXR0bGUocGFjdCwgMSwgcmVzdWx0KTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVKV0UoandlKSB7XG4gIGlmICghKGp3ZS5wcm90ZWN0ZWQgJiYgandlLml2ICYmIGp3ZS5jaXBoZXJ0ZXh0ICYmIGp3ZS50YWcpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdiYWRfandlOiBtaXNzaW5nIHByb3BlcnRpZXMnKTtcbiAgfVxuXG4gIGlmIChqd2UucmVjaXBpZW50cykge1xuICAgIGp3ZS5yZWNpcGllbnRzLm1hcChyZWMgPT4ge1xuICAgICAgaWYgKCEocmVjLmhlYWRlciAmJiByZWMuZW5jcnlwdGVkX2tleSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWRfandlOiBtYWxmb3JtZWQgcmVjaXBpZW50cycpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVuY29kZUpXRSh7XG4gIGNpcGhlcnRleHQsXG4gIHRhZyxcbiAgaXYsXG4gIHByb3RlY3RlZEhlYWRlcixcbiAgcmVjaXBpZW50XG59LCBhYWQpIHtcbiAgY29uc3QgandlID0ge1xuICAgIHByb3RlY3RlZDogcHJvdGVjdGVkSGVhZGVyLFxuICAgIGl2OiBieXRlc1RvQmFzZTY0dXJsKGl2ID8/IG5ldyBVaW50OEFycmF5KDApKSxcbiAgICBjaXBoZXJ0ZXh0OiBieXRlc1RvQmFzZTY0dXJsKGNpcGhlcnRleHQpLFxuICAgIHRhZzogYnl0ZXNUb0Jhc2U2NHVybCh0YWcgPz8gbmV3IFVpbnQ4QXJyYXkoMCkpXG4gIH07XG4gIGlmIChhYWQpIGp3ZS5hYWQgPSBieXRlc1RvQmFzZTY0dXJsKGFhZCk7XG4gIGlmIChyZWNpcGllbnQpIGp3ZS5yZWNpcGllbnRzID0gW3JlY2lwaWVudF07XG4gIHJldHVybiBqd2U7XG59XG5cbmNvbnN0IGRlY3J5cHRKV0UgPSBmdW5jdGlvbiAoandlLCBkZWNyeXB0ZXIpIHtcbiAgdHJ5IHtcbiAgICBsZXQgX2V4aXQ7XG5cbiAgICBmdW5jdGlvbiBfdGVtcDUoX3Jlc3VsdCkge1xuICAgICAgaWYgKF9leGl0KSA7XG4gICAgICBpZiAoY2xlYXJ0ZXh0ID09PSBudWxsKSB0aHJvdyBuZXcgRXJyb3IoJ2ZhaWx1cmU6IEZhaWxlZCB0byBkZWNyeXB0Jyk7XG4gICAgICByZXR1cm4gY2xlYXJ0ZXh0O1xuICAgIH1cblxuICAgIHZhbGlkYXRlSldFKGp3ZSk7XG4gICAgY29uc3QgcHJvdEhlYWRlciA9IEpTT04ucGFyc2UoZGVjb2RlQmFzZTY0dXJsKGp3ZS5wcm90ZWN0ZWQpKTtcbiAgICBpZiAocHJvdEhlYWRlci5lbmMgIT09IGRlY3J5cHRlci5lbmMpIHRocm93IG5ldyBFcnJvcihgbm90X3N1cHBvcnRlZDogRGVjcnlwdGVyIGRvZXMgbm90IHN1cHBvcnRlZDogJyR7cHJvdEhlYWRlci5lbmN9J2ApO1xuICAgIGNvbnN0IHNlYWxlZCA9IHRvU2VhbGVkKGp3ZS5jaXBoZXJ0ZXh0LCBqd2UudGFnKTtcbiAgICBjb25zdCBhYWQgPSBzdHJpbmdUb0J5dGVzKGp3ZS5hYWQgPyBgJHtqd2UucHJvdGVjdGVkfS4ke2p3ZS5hYWR9YCA6IGp3ZS5wcm90ZWN0ZWQpO1xuICAgIGxldCBjbGVhcnRleHQgPSBudWxsO1xuXG4gICAgY29uc3QgX3RlbXA0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHByb3RIZWFkZXIuYWxnID09PSAnZGlyJyAmJiBkZWNyeXB0ZXIuYWxnID09PSAnZGlyJykge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGRlY3J5cHRlci5kZWNyeXB0KHNlYWxlZCwgYmFzZTY0VG9CeXRlcyhqd2UuaXYpLCBhYWQpKS50aGVuKGZ1bmN0aW9uIChfZGVjcnlwdGVyJGRlY3J5cHQpIHtcbiAgICAgICAgICBjbGVhcnRleHQgPSBfZGVjcnlwdGVyJGRlY3J5cHQ7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghandlLnJlY2lwaWVudHMgfHwgandlLnJlY2lwaWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWRfandlOiBtaXNzaW5nIHJlY2lwaWVudHMnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgICAgcmV0dXJuIF9mb3IoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICFjbGVhcnRleHQgJiYgaSA8IGp3ZS5yZWNpcGllbnRzLmxlbmd0aDtcbiAgICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gaSsrO1xuICAgICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlY2lwaWVudCA9IGp3ZS5yZWNpcGllbnRzW2ldO1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihyZWNpcGllbnQuaGVhZGVyLCBwcm90SGVhZGVyKTtcblxuICAgICAgICAgICAgY29uc3QgX3RlbXAzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBpZiAocmVjaXBpZW50LmhlYWRlci5hbGcgPT09IGRlY3J5cHRlci5hbGcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGRlY3J5cHRlci5kZWNyeXB0KHNlYWxlZCwgYmFzZTY0VG9CeXRlcyhqd2UuaXYpLCBhYWQsIHJlY2lwaWVudCkpLnRoZW4oZnVuY3Rpb24gKF9kZWNyeXB0ZXIkZGVjcnlwdDIpIHtcbiAgICAgICAgICAgICAgICAgIGNsZWFydGV4dCA9IF9kZWNyeXB0ZXIkZGVjcnlwdDI7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0oKTtcblxuICAgICAgICAgICAgaWYgKF90ZW1wMyAmJiBfdGVtcDMudGhlbikgcmV0dXJuIF90ZW1wMy50aGVuKGZ1bmN0aW9uICgpIHt9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSgpO1xuICAgIH0oKTtcblxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoX3RlbXA0ICYmIF90ZW1wNC50aGVuID8gX3RlbXA0LnRoZW4oX3RlbXA1KSA6IF90ZW1wNShfdGVtcDQpKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlKTtcbiAgfVxufTtcbmNvbnN0IGNyZWF0ZUpXRSA9IGZ1bmN0aW9uIChjbGVhcnRleHQsIGVuY3J5cHRlcnMsIHByb3RlY3RlZEhlYWRlciA9IHt9LCBhYWQsIHVzZVNpbmdsZUVwaGVtZXJhbEtleSA9IGZhbHNlKSB7XG4gIHRyeSB7XG4gICAgaWYgKGVuY3J5cHRlcnNbMF0uYWxnID09PSAnZGlyJykge1xuICAgICAgaWYgKGVuY3J5cHRlcnMubGVuZ3RoID4gMSkgdGhyb3cgbmV3IEVycm9yKCdub3Rfc3VwcG9ydGVkOiBDYW4gb25seSBkbyBcImRpclwiIGVuY3J5cHRpb24gdG8gb25lIGtleS4nKTtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZW5jcnlwdGVyc1swXS5lbmNyeXB0KGNsZWFydGV4dCwgcHJvdGVjdGVkSGVhZGVyLCBhYWQpKS50aGVuKGZ1bmN0aW9uIChlbmNyeXB0aW9uUmVzdWx0KSB7XG4gICAgICAgIHJldHVybiBlbmNvZGVKV0UoZW5jcnlwdGlvblJlc3VsdCwgYWFkKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB0bXBFbmMgPSBlbmNyeXB0ZXJzWzBdLmVuYztcblxuICAgICAgaWYgKCFlbmNyeXB0ZXJzLnJlZHVjZSgoYWNjLCBlbmNyeXB0ZXIpID0+IGFjYyAmJiBlbmNyeXB0ZXIuZW5jID09PSB0bXBFbmMsIHRydWUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZF9hcmd1bWVudDogSW5jb21wYXRpYmxlIGVuY3J5cHRlcnMgcGFzc2VkJyk7XG4gICAgICB9XG5cbiAgICAgIGxldCBjZWs7XG4gICAgICBsZXQgandlO1xuICAgICAgbGV0IGVwaztcblxuICAgICAgaWYgKHVzZVNpbmdsZUVwaGVtZXJhbEtleSkge1xuICAgICAgICBlcGsgPSBlbmNyeXB0ZXJzWzBdLmdlbkVwaz8uKCk7XG4gICAgICAgIGNvbnN0IGFsZyA9IGVuY3J5cHRlcnNbMF0uYWxnO1xuICAgICAgICBwcm90ZWN0ZWRIZWFkZXIgPSB7IC4uLnByb3RlY3RlZEhlYWRlcixcbiAgICAgICAgICBhbGcsXG4gICAgICAgICAgZXBrOiBlcGs/LnB1YmxpY0tleUpXS1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBjb25zdCBfdGVtcDIgPSBfZm9yT2YoZW5jcnlwdGVycywgZnVuY3Rpb24gKGVuY3J5cHRlcikge1xuICAgICAgICBjb25zdCBfdGVtcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoIWNlaykge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShlbmNyeXB0ZXIuZW5jcnlwdChjbGVhcnRleHQsIHByb3RlY3RlZEhlYWRlciwgYWFkLCBlcGspKS50aGVuKGZ1bmN0aW9uIChlbmNyeXB0aW9uUmVzdWx0KSB7XG4gICAgICAgICAgICAgIGNlayA9IGVuY3J5cHRpb25SZXN1bHQuY2VrO1xuICAgICAgICAgICAgICBqd2UgPSBlbmNvZGVKV0UoZW5jcnlwdGlvblJlc3VsdCwgYWFkKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGVuY3J5cHRlci5lbmNyeXB0Q2VrPy4oY2VrLCBlcGspKS50aGVuKGZ1bmN0aW9uIChyZWNpcGllbnQpIHtcbiAgICAgICAgICAgICAgaWYgKHJlY2lwaWVudCkge1xuICAgICAgICAgICAgICAgIGp3ZT8ucmVjaXBpZW50cz8ucHVzaChyZWNpcGllbnQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0oKTtcblxuICAgICAgICBpZiAoX3RlbXAgJiYgX3RlbXAudGhlbikgcmV0dXJuIF90ZW1wLnRoZW4oZnVuY3Rpb24gKCkge30pO1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoX3RlbXAyICYmIF90ZW1wMi50aGVuID8gX3RlbXAyLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gandlO1xuICAgICAgfSkgOiBqd2UpO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlKTtcbiAgfVxufTtcblxuZnVuY3Rpb24geGMyMHBFbmNyeXB0ZXIoa2V5KSB7XG4gIHJldHVybiAoY2xlYXJ0ZXh0LCBhYWQpID0+IHtcbiAgICBjb25zdCBpdiA9IHJhbmRvbUJ5dGVzKDI0KTtcbiAgICBjb25zdCBjaXBoZXIgPSB4Y2hhY2hhMjBwb2x5MTMwNShrZXksIGl2LCBhYWQpO1xuICAgIGNvbnN0IHNlYWxlZCA9IGNpcGhlci5lbmNyeXB0KGNsZWFydGV4dCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNpcGhlcnRleHQ6IHNlYWxlZC5zdWJhcnJheSgwLCBzZWFsZWQubGVuZ3RoIC0gMTYpLFxuICAgICAgdGFnOiBzZWFsZWQuc3ViYXJyYXkoc2VhbGVkLmxlbmd0aCAtIDE2KSxcbiAgICAgIGl2XG4gICAgfTtcbiAgfTtcbn1cbmZ1bmN0aW9uIHhjMjBwRGlyRW5jcnlwdGVyKGtleSkge1xuICBjb25zdCBlbmNyeXB0ID0gZnVuY3Rpb24gKGNsZWFydGV4dCwgcHJvdGVjdGVkSGVhZGVyID0ge30sIGFhZCkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBwcm90SGVhZGVyID0gZW5jb2RlQmFzZTY0dXJsKEpTT04uc3RyaW5naWZ5KE9iamVjdC5hc3NpZ24oe1xuICAgICAgICBhbGdcbiAgICAgIH0sIHByb3RlY3RlZEhlYWRlciwge1xuICAgICAgICBlbmNcbiAgICAgIH0pKSk7XG4gICAgICBjb25zdCBlbmNvZGVkQWFkID0gc3RyaW5nVG9CeXRlcyhhYWQgPyBgJHtwcm90SGVhZGVyfS4ke2J5dGVzVG9CYXNlNjR1cmwoYWFkKX1gIDogcHJvdEhlYWRlcik7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHsgLi4ueGMyMHBFbmNyeXB0KGNsZWFydGV4dCwgZW5jb2RlZEFhZCksXG4gICAgICAgIHByb3RlY3RlZEhlYWRlcjogcHJvdEhlYWRlclxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGUpO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCB4YzIwcEVuY3J5cHQgPSB4YzIwcEVuY3J5cHRlcihrZXkpO1xuICBjb25zdCBlbmMgPSAnWEMyMFAnO1xuICBjb25zdCBhbGcgPSAnZGlyJztcbiAgcmV0dXJuIHtcbiAgICBhbGcsXG4gICAgZW5jLFxuICAgIGVuY3J5cHRcbiAgfTtcbn1cbmZ1bmN0aW9uIHhjMjBwRGlyRGVjcnlwdGVyKGtleSkge1xuICBjb25zdCBkZWNyeXB0ID0gZnVuY3Rpb24gKHNlYWxlZCwgaXYsIGFhZCkge1xuICAgIHRyeSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHhjaGFjaGEyMHBvbHkxMzA1KGtleSwgaXYsIGFhZCkuZGVjcnlwdChzZWFsZWQpKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobnVsbCk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGUpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4ge1xuICAgIGFsZzogJ2RpcicsXG4gICAgZW5jOiAnWEMyMFAnLFxuICAgIGRlY3J5cHRcbiAgfTtcbn1cblxuY29uc3QgY3JlYXRlWDI1NTE5RWNkaEVzS2VrID0gZnVuY3Rpb24gKHJlY2lwaWVudFB1YmxpY0tleSwgc2VuZGVyU2VjcmV0LCAvLyB1bnVzZWRcbmFsZywgYXB1LCAvLyB1bnVzZWRcbmFwdiwgZXBoZW1lcmFsS2V5UGFpcikge1xuICB0cnkge1xuICAgIGNvbnN0IGNydiA9ICdYMjU1MTknO1xuICAgIGNvbnN0IGtleUxlbiA9IDI1NjtcbiAgICBjb25zdCBlcGhlbWVyYWwgPSBlcGhlbWVyYWxLZXlQYWlyID8gZ2VuZXJhdGVLZXlQYWlyRnJvbVNlZWQoZXBoZW1lcmFsS2V5UGFpci5zZWNyZXRLZXkpIDogZ2VuZXJhdGVLZXlQYWlyKCk7XG4gICAgY29uc3QgZXBrID0ge1xuICAgICAga3R5OiAnT0tQJyxcbiAgICAgIGNydixcbiAgICAgIHg6IGJ5dGVzVG9CYXNlNjR1cmwoZXBoZW1lcmFsLnB1YmxpY0tleSlcbiAgICB9O1xuICAgIGNvbnN0IHNoYXJlZFNlY3JldCA9IHgyNTUxOS5nZXRTaGFyZWRTZWNyZXQoZXBoZW1lcmFsLnNlY3JldEtleSwgcmVjaXBpZW50UHVibGljS2V5KTsgLy8gS2V5IEVuY3J5cHRpb24gS2V5XG5cbiAgICBjb25zdCBjb25zdW1lckluZm8gPSBiYXNlNjRUb0J5dGVzKGFwdiA/PyAnJyk7XG4gICAgY29uc3Qga2VrID0gY29uY2F0S0RGKHNoYXJlZFNlY3JldCwga2V5TGVuLCBhbGcsIHVuZGVmaW5lZCwgY29uc3VtZXJJbmZvKTtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgIGVwayxcbiAgICAgIGtla1xuICAgIH0pO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGUpO1xuICB9XG59O1xuY29uc3QgY29tcHV0ZVgyNTUxOUVjZGhFc0tlayA9IGZ1bmN0aW9uIChyZWNpcGllbnQsIHJlY2VpdmVyU2VjcmV0LCBhbGcpIHtcbiAgdHJ5IHtcbiAgICBmdW5jdGlvbiBfdGVtcDIoKSB7XG4gICAgICAvLyBLZXkgRW5jcnlwdGlvbiBLZXlcbiAgICAgIGxldCBwcm9kdWNlckluZm8gPSB1bmRlZmluZWQ7XG4gICAgICBsZXQgY29uc3VtZXJJbmZvID0gdW5kZWZpbmVkO1xuICAgICAgaWYgKHJlY2lwaWVudC5oZWFkZXIuYXB1KSBwcm9kdWNlckluZm8gPSBiYXNlNjRUb0J5dGVzKHJlY2lwaWVudC5oZWFkZXIuYXB1KTtcbiAgICAgIGlmIChyZWNpcGllbnQuaGVhZGVyLmFwdikgY29uc3VtZXJJbmZvID0gYmFzZTY0VG9CeXRlcyhyZWNpcGllbnQuaGVhZGVyLmFwdik7XG4gICAgICByZXR1cm4gY29uY2F0S0RGKHNoYXJlZFNlY3JldCwga2V5TGVuLCBhbGcsIHByb2R1Y2VySW5mbywgY29uc3VtZXJJbmZvKTtcbiAgICB9XG5cbiAgICBjb25zdCBjcnYgPSAnWDI1NTE5JztcbiAgICBjb25zdCBrZXlMZW4gPSAyNTY7XG4gICAgY29uc3QgaGVhZGVyID0gcmVjaXBpZW50LmhlYWRlcjtcbiAgICBpZiAoaGVhZGVyLmVwaz8uY3J2ICE9PSBjcnYgfHwgdHlwZW9mIGhlYWRlci5lcGsueCA9PSAndW5kZWZpbmVkJykgcmV0dXJuIFByb21pc2UucmVzb2x2ZShudWxsKTtcbiAgICBjb25zdCBwdWJsaWNLZXkgPSBiYXNlNjRUb0J5dGVzKGhlYWRlci5lcGsueCk7XG4gICAgbGV0IHNoYXJlZFNlY3JldDtcblxuICAgIGNvbnN0IF90ZW1wID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHJlY2VpdmVyU2VjcmV0IGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICBzaGFyZWRTZWNyZXQgPSB4MjU1MTkuZ2V0U2hhcmVkU2VjcmV0KHJlY2VpdmVyU2VjcmV0LCBwdWJsaWNLZXkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZWNlaXZlclNlY3JldChwdWJsaWNLZXkpKS50aGVuKGZ1bmN0aW9uIChfcmVjZWl2ZXJTZWNyZXQpIHtcbiAgICAgICAgICBzaGFyZWRTZWNyZXQgPSBfcmVjZWl2ZXJTZWNyZXQ7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0oKTtcblxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoX3RlbXAgJiYgX3RlbXAudGhlbiA/IF90ZW1wLnRoZW4oX3RlbXAyKSA6IF90ZW1wMihfdGVtcCkpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGUpO1xuICB9XG59O1xuXG5jb25zdCBjcmVhdGVYMjU1MTlFY2RoMVBVdjNLZWsgPSBmdW5jdGlvbiAocmVjaXBpZW50UHVibGljS2V5LCBzZW5kZXJTZWNyZXQsIGFsZywgLy8gbXVzdCBiZSBwcm92aWRlZCBhcyB0aGlzIGlzIHRoZSBrZXkgYWdyZWVtZW50IGFsZyArIHRoZSBrZXkgd3JhcHBlciBhbGcsIEV4YW1wbGU6ICdFQ0RILUVTK0EyNTZLVydcbmFwdSwgYXB2LCBlcGhlbWVyYWxLZXlQYWlyKSB7XG4gIHRyeSB7XG4gICAgZnVuY3Rpb24gX3RlbXA0KCkge1xuICAgICAgY29uc3Qgc2hhcmVkU2VjcmV0ID0gbmV3IFVpbnQ4QXJyYXkoekUubGVuZ3RoICsgelMubGVuZ3RoKTtcbiAgICAgIHNoYXJlZFNlY3JldC5zZXQoekUpO1xuICAgICAgc2hhcmVkU2VjcmV0LnNldCh6UywgekUubGVuZ3RoKTtcbiAgICAgIGxldCBwYXJ0eVVJbmZvID0gbmV3IFVpbnQ4QXJyYXkoMCk7XG4gICAgICBsZXQgcGFydHlWSW5mbyA9IG5ldyBVaW50OEFycmF5KDApO1xuICAgICAgaWYgKGFwdSkgcGFydHlVSW5mbyA9IGJhc2U2NFRvQnl0ZXMoYXB1KTtcbiAgICAgIGlmIChhcHYpIHBhcnR5VkluZm8gPSBiYXNlNjRUb0J5dGVzKGFwdik7IC8vIEtleSBFbmNyeXB0aW9uIEtleVxuXG4gICAgICBjb25zdCBrZWsgPSBjb25jYXRLREYoc2hhcmVkU2VjcmV0LCBrZXlMZW4sIGFsZywgcGFydHlVSW5mbywgcGFydHlWSW5mbyk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBlcGssXG4gICAgICAgIGtla1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBjb25zdCBjcnYgPSAnWDI1NTE5JztcbiAgICBjb25zdCBrZXlMZW4gPSAyNTY7XG4gICAgY29uc3QgZXBoZW1lcmFsID0gZXBoZW1lcmFsS2V5UGFpciA/IGdlbmVyYXRlS2V5UGFpckZyb21TZWVkKGVwaGVtZXJhbEtleVBhaXIuc2VjcmV0S2V5KSA6IGdlbmVyYXRlS2V5UGFpcigpO1xuICAgIGNvbnN0IGVwayA9IHtcbiAgICAgIGt0eTogJ09LUCcsXG4gICAgICBjcnYsXG4gICAgICB4OiBieXRlc1RvQmFzZTY0dXJsKGVwaGVtZXJhbC5wdWJsaWNLZXkpXG4gICAgfTtcbiAgICBjb25zdCB6RSA9IHgyNTUxOS5nZXRTaGFyZWRTZWNyZXQoZXBoZW1lcmFsLnNlY3JldEtleSwgcmVjaXBpZW50UHVibGljS2V5KTsgLy8gRUNESC0xUFUgcmVxdWlyZXMgYWRkaXRpb25hbCBzaGFyZWQgc2VjcmV0IGJldHdlZW5cbiAgICAvLyBzdGF0aWMga2V5IG9mIHNlbmRlciBhbmQgc3RhdGljIGtleSBvZiByZWNpcGllbnRcblxuICAgIGxldCB6UztcblxuICAgIGNvbnN0IF90ZW1wMyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChzZW5kZXJTZWNyZXQgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgIHpTID0geDI1NTE5LmdldFNoYXJlZFNlY3JldChzZW5kZXJTZWNyZXQsIHJlY2lwaWVudFB1YmxpY0tleSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHNlbmRlclNlY3JldChyZWNpcGllbnRQdWJsaWNLZXkpKS50aGVuKGZ1bmN0aW9uIChfc2VuZGVyU2VjcmV0KSB7XG4gICAgICAgICAgelMgPSBfc2VuZGVyU2VjcmV0O1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KCk7XG5cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKF90ZW1wMyAmJiBfdGVtcDMudGhlbiA/IF90ZW1wMy50aGVuKF90ZW1wNCkgOiBfdGVtcDQoX3RlbXAzKSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZSk7XG4gIH1cbn07XG5jb25zdCBjb21wdXRlWDI1NTE5RWNkaDFQVXYzS2VrID0gZnVuY3Rpb24gKHJlY2lwaWVudCwgcmVjaXBpZW50U2VjcmV0LCBzZW5kZXJQdWJsaWNLZXksIGFsZykge1xuICB0cnkge1xuICAgIGZ1bmN0aW9uIF90ZW1wMigpIHtcbiAgICAgIGNvbnN0IHNoYXJlZFNlY3JldCA9IG5ldyBVaW50OEFycmF5KHpFLmxlbmd0aCArIHpTLmxlbmd0aCk7XG4gICAgICBzaGFyZWRTZWNyZXQuc2V0KHpFKTtcbiAgICAgIHNoYXJlZFNlY3JldC5zZXQoelMsIHpFLmxlbmd0aCk7IC8vIEtleSBFbmNyeXB0aW9uIEtleVxuXG4gICAgICBsZXQgcHJvZHVjZXJJbmZvO1xuICAgICAgbGV0IGNvbnN1bWVySW5mbztcbiAgICAgIGlmIChyZWNpcGllbnQuaGVhZGVyLmFwdSkgcHJvZHVjZXJJbmZvID0gYmFzZTY0VG9CeXRlcyhyZWNpcGllbnQuaGVhZGVyLmFwdSk7XG4gICAgICBpZiAocmVjaXBpZW50LmhlYWRlci5hcHYpIGNvbnN1bWVySW5mbyA9IGJhc2U2NFRvQnl0ZXMocmVjaXBpZW50LmhlYWRlci5hcHYpO1xuICAgICAgcmV0dXJuIGNvbmNhdEtERihzaGFyZWRTZWNyZXQsIGtleUxlbiwgYWxnLCBwcm9kdWNlckluZm8sIGNvbnN1bWVySW5mbyk7XG4gICAgfVxuXG4gICAgY29uc3QgY3J2ID0gJ1gyNTUxOSc7XG4gICAgY29uc3Qga2V5TGVuID0gMjU2O1xuICAgIGNvbnN0IGhlYWRlciA9IHJlY2lwaWVudC5oZWFkZXI7XG4gICAgaWYgKGhlYWRlci5lcGs/LmNydiAhPT0gY3J2IHx8IHR5cGVvZiBoZWFkZXIuZXBrLnggPT0gJ3VuZGVmaW5lZCcpIHJldHVybiBQcm9taXNlLnJlc29sdmUobnVsbCk7IC8vIEVDREgtMVBVIHJlcXVpcmVzIGFkZGl0aW9uYWwgc2hhcmVkIHNlY3JldCBiZXR3ZWVuXG4gICAgLy8gc3RhdGljIGtleSBvZiBzZW5kZXIgYW5kIHN0YXRpYyBrZXkgb2YgcmVjaXBpZW50XG5cbiAgICBjb25zdCBwdWJsaWNLZXkgPSBiYXNlNjRUb0J5dGVzKGhlYWRlci5lcGsueCk7XG4gICAgbGV0IHpFO1xuICAgIGxldCB6UztcblxuICAgIGNvbnN0IF90ZW1wID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHJlY2lwaWVudFNlY3JldCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgekUgPSB4MjU1MTkuZ2V0U2hhcmVkU2VjcmV0KHJlY2lwaWVudFNlY3JldCwgcHVibGljS2V5KTtcbiAgICAgICAgelMgPSB4MjU1MTkuZ2V0U2hhcmVkU2VjcmV0KHJlY2lwaWVudFNlY3JldCwgc2VuZGVyUHVibGljS2V5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVjaXBpZW50U2VjcmV0KHB1YmxpY0tleSkpLnRoZW4oZnVuY3Rpb24gKF9yZWNpcGllbnRTZWNyZXQpIHtcbiAgICAgICAgICB6RSA9IF9yZWNpcGllbnRTZWNyZXQ7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZWNpcGllbnRTZWNyZXQoc2VuZGVyUHVibGljS2V5KSkudGhlbihmdW5jdGlvbiAoX3JlY2lwaWVudFNlY3JldDIpIHtcbiAgICAgICAgICAgIHpTID0gX3JlY2lwaWVudFNlY3JldDI7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0oKTtcblxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoX3RlbXAgJiYgX3RlbXAudGhlbiA/IF90ZW1wLnRoZW4oX3RlbXAyKSA6IF90ZW1wMihfdGVtcCkpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGUpO1xuICB9XG59O1xuXG4vKipcbiAqIFdyYXBzIGFuIFgyNTUxOSBzZWNyZXQga2V5IGludG8gYW4gRUNESCBtZXRob2QgdGhhdCBjYW4gYmUgdXNlZCB0byBjb21wdXRlIGEgc2hhcmVkIHNlY3JldCB3aXRoIGEgcHVibGljIGtleS5cbiAqIEBwYXJhbSBteVNlY3JldEtleSBBIGBVaW50OEFycmF5YCBvZiBsZW5ndGggMzIgcmVwcmVzZW50aW5nIHRoZSBieXRlcyBvZiBteSBzZWNyZXQga2V5XG4gKiBAcmV0dXJucyBhbiBgRUNESGAgbWV0aG9kIHdpdGggdGhlIHNpZ25hdHVyZSBgKHRoZWlyUHVibGljS2V5OiBVaW50OEFycmF5KSA9PiBQcm9taXNlPFVpbnQ4QXJyYXk+YFxuICpcbiAqIEB0aHJvd3MgJ2ludmFsaWRfYXJndW1lbnQ6Li4uJyBpZiB0aGUgc2VjcmV0IGtleSBzaXplIGlzIHdyb25nXG4gKi9cblxuZnVuY3Rpb24gY3JlYXRlWDI1NTE5RUNESChteVNlY3JldEtleSkge1xuICBpZiAobXlTZWNyZXRLZXkubGVuZ3RoICE9PSAzMikge1xuICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZF9hcmd1bWVudDogaW5jb3JyZWN0IHNlY3JldCBrZXkgbGVuZ3RoIGZvciBYMjU1MTknKTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAodGhlaXJQdWJsaWNLZXkpIHtcbiAgICB0cnkge1xuICAgICAgaWYgKHRoZWlyUHVibGljS2V5Lmxlbmd0aCAhPT0gMzIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkX2FyZ3VtZW50OiBpbmNvcnJlY3QgcHVibGljS2V5IGtleSBsZW5ndGggZm9yIFgyNTUxOScpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHgyNTUxOS5nZXRTaGFyZWRTZWNyZXQobXlTZWNyZXRLZXksIHRoZWlyUHVibGljS2V5KSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGUpO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRnVsbEVuY3J5cHRlcihyZWNpcGllbnRQdWJsaWNLZXksIHNlbmRlclNlY3JldCwgb3B0aW9ucyA9IHt9LCBrZWtDcmVhdG9yLCBrZXlXcmFwcGVyLCBjb250ZW50RW5jcnlwdGVyKSB7XG4gIGNvbnN0IGVuY3J5cHQgPSBmdW5jdGlvbiAoY2xlYXJ0ZXh0LCBwcm90ZWN0ZWRIZWFkZXIgPSB7fSwgYWFkLCBlcGhlbWVyYWxLZXlQYWlyKSB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIHdlIHdvbid0IHdhbnQgYWxnIHRvIGJlIHNldCB0byBkaXIgZnJvbSB4YzIwcERpckVuY3J5cHRlclxuICAgICAgT2JqZWN0LmFzc2lnbihwcm90ZWN0ZWRIZWFkZXIsIHtcbiAgICAgICAgYWxnOiB1bmRlZmluZWRcbiAgICAgIH0pOyAvLyBDb250ZW50IEVuY3J5cHRpb24gS2V5XG5cbiAgICAgIGNvbnN0IGNlayA9IHJhbmRvbUJ5dGVzKDMyKTtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZW5jcnlwdENlayhjZWssIGVwaGVtZXJhbEtleVBhaXIpKS50aGVuKGZ1bmN0aW9uIChyZWNpcGllbnQpIHtcbiAgICAgICAgLy8gZ2V0dGluZyBhbiBlcGhlbWVyYWwga2V5IG1lYW5zIHRoZSBlcGsgaXMgc2V0IG9ubHkgb25jZSBwZXIgYWxsIHJlY2lwaWVudHNcbiAgICAgICAgaWYgKGVwaGVtZXJhbEtleVBhaXIpIHtcbiAgICAgICAgICBwcm90ZWN0ZWRIZWFkZXIuYWxnID0gYCR7a2VrQ3JlYXRvci5hbGd9KyR7a2V5V3JhcHBlci5hbGd9YDtcbiAgICAgICAgICBwcm90ZWN0ZWRIZWFkZXIuZXBrID0gZXBoZW1lcmFsS2V5UGFpci5wdWJsaWNLZXlKV0s7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGNvbnRlbnRFbmNyeXB0ZXIuZnJvbShjZWspLmVuY3J5cHQoY2xlYXJ0ZXh0LCBwcm90ZWN0ZWRIZWFkZXIsIGFhZCkpLnRoZW4oZnVuY3Rpb24gKF9jb250ZW50RW5jcnlwdGVyJGZybykge1xuICAgICAgICAgIHJldHVybiB7IC4uLl9jb250ZW50RW5jcnlwdGVyJGZybyxcbiAgICAgICAgICAgIHJlY2lwaWVudCxcbiAgICAgICAgICAgIGNla1xuICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGUpO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCBlbmNyeXB0Q2VrID0gZnVuY3Rpb24gKGNlaywgZXBoZW1lcmFsS2V5UGFpcikge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGtla0NyZWF0b3IuY3JlYXRlS2VrKHJlY2lwaWVudFB1YmxpY0tleSwgc2VuZGVyU2VjcmV0LCBgJHtrZWtDcmVhdG9yLmFsZ30rJHtrZXlXcmFwcGVyLmFsZ31gLCBvcHRpb25zLmFwdSwgb3B0aW9ucy5hcHYsIGVwaGVtZXJhbEtleVBhaXIpKS50aGVuKGZ1bmN0aW9uICh7XG4gICAgICAgIGVwayxcbiAgICAgICAga2VrXG4gICAgICB9KSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoa2V5V3JhcHBlci5mcm9tKGtlaykud3JhcChjZWspKS50aGVuKGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgICAgICBjb25zdCByZWNpcGllbnQgPSB7XG4gICAgICAgICAgICBlbmNyeXB0ZWRfa2V5OiBieXRlc1RvQmFzZTY0dXJsKHJlcy5jaXBoZXJ0ZXh0KSxcbiAgICAgICAgICAgIGhlYWRlcjoge31cbiAgICAgICAgICB9O1xuICAgICAgICAgIGlmIChyZXMuaXYpIHJlY2lwaWVudC5oZWFkZXIuaXYgPSBieXRlc1RvQmFzZTY0dXJsKHJlcy5pdik7XG4gICAgICAgICAgaWYgKHJlcy50YWcpIHJlY2lwaWVudC5oZWFkZXIudGFnID0gYnl0ZXNUb0Jhc2U2NHVybChyZXMudGFnKTtcbiAgICAgICAgICBpZiAob3B0aW9ucy5raWQpIHJlY2lwaWVudC5oZWFkZXIua2lkID0gb3B0aW9ucy5raWQ7XG4gICAgICAgICAgaWYgKG9wdGlvbnMuYXB1KSByZWNpcGllbnQuaGVhZGVyLmFwdSA9IG9wdGlvbnMuYXB1O1xuICAgICAgICAgIGlmIChvcHRpb25zLmFwdikgcmVjaXBpZW50LmhlYWRlci5hcHYgPSBvcHRpb25zLmFwdjtcblxuICAgICAgICAgIGlmICghZXBoZW1lcmFsS2V5UGFpcikge1xuICAgICAgICAgICAgcmVjaXBpZW50LmhlYWRlci5hbGcgPSBgJHtrZWtDcmVhdG9yLmFsZ30rJHtrZXlXcmFwcGVyLmFsZ31gO1xuICAgICAgICAgICAgcmVjaXBpZW50LmhlYWRlci5lcGsgPSBlcGs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHJlY2lwaWVudDtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZSk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiB7XG4gICAgYWxnOiBrZXlXcmFwcGVyLmFsZyxcbiAgICBlbmM6IGNvbnRlbnRFbmNyeXB0ZXIuZW5jLFxuICAgIGVuY3J5cHQsXG4gICAgZW5jcnlwdENlayxcbiAgICBnZW5FcGs6IGdlblgyNTUxOUVwaGVtZXJhbEtleVBhaXJcbiAgfTtcbn1cblxuLyoqXG4gKiBAZGVwcmVjYXRlZCBVc2VcbiAqICAge0BsaW5rIHhjMjBwQXV0aEVuY3J5cHRlckVjZGgxUHVWM3gyNTUxOVdpdGhYYzIwUGt3VjIgfCB4YzIwcEF1dGhFbmNyeXB0ZXJFY2RoMVB1VjN4MjU1MTlXaXRoWGMyMFBrd1YyKCkgfSBpbnN0ZWFkXG4gKi9cblxuY29uc3QgcmVzb2x2ZVgyNTUxOUVuY3J5cHRlcnMgPSBmdW5jdGlvbiAoZGlkcywgcmVzb2x2ZXIpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBlbmNyeXB0ZXJzRm9yRElEID0gZnVuY3Rpb24gKGRpZCwgcmVzb2x2ZWQgPSBbXSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXNvbHZlci5yZXNvbHZlKGRpZCkpLnRoZW4oZnVuY3Rpb24gKHtcbiAgICAgICAgICBkaWRSZXNvbHV0aW9uTWV0YWRhdGEsXG4gICAgICAgICAgZGlkRG9jdW1lbnRcbiAgICAgICAgfSkge1xuICAgICAgICAgIGZ1bmN0aW9uIF90ZW1wMigpIHtcbiAgICAgICAgICAgIGNvbnN0IGFncmVlbWVudEtleXMgPSBkaWREb2N1bWVudC5rZXlBZ3JlZW1lbnQ/Lm1hcChrZXkgPT4ge1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWy4uLihkaWREb2N1bWVudC5wdWJsaWNLZXkgfHwgW10pLCAuLi4oZGlkRG9jdW1lbnQudmVyaWZpY2F0aW9uTWV0aG9kIHx8IFtdKV0uZmluZChwayA9PiBway5pZCA9PT0ga2V5KTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybiBrZXk7XG4gICAgICAgICAgICB9KT8uZmlsdGVyKGtleSA9PiB0eXBlb2Yga2V5ICE9PSAndW5kZWZpbmVkJyk7XG4gICAgICAgICAgICBjb25zdCBwa3MgPSBhZ3JlZW1lbnRLZXlzPy5maWx0ZXIoa2V5ID0+IFsnWDI1NTE5S2V5QWdyZWVtZW50S2V5MjAxOScsICdYMjU1MTlLZXlBZ3JlZW1lbnRLZXkyMDIwJywgJ0pzb25XZWJLZXkyMDIwJywgJ011bHRpa2V5J10uaW5jbHVkZXMoa2V5LnR5cGUpKSA/PyBbXTtcbiAgICAgICAgICAgIGlmICghcGtzLmxlbmd0aCAmJiAhY29udHJvbGxlckVuY3J5cHRlcnMubGVuZ3RoKSB0aHJvdyBuZXcgRXJyb3IoYG5vX3N1aXRhYmxlX2tleXM6IENvdWxkIG5vdCBmaW5kIFgyNTUxOSBrZXkgZm9yICR7ZGlkfWApO1xuICAgICAgICAgICAgcmV0dXJuIHBrcy5tYXAocGsgPT4ge1xuICAgICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgICAga2V5Qnl0ZXMsXG4gICAgICAgICAgICAgICAga2V5VHlwZVxuICAgICAgICAgICAgICB9ID0gZXh0cmFjdFB1YmxpY0tleUJ5dGVzKHBrKTtcblxuICAgICAgICAgICAgICBpZiAoa2V5VHlwZSA9PT0gJ1gyNTUxOScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geDI1NTE5RW5jcnlwdGVyKGtleUJ5dGVzLCBway5pZCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLmZpbHRlcihpc0RlZmluZWQpLmNvbmNhdCguLi5jb250cm9sbGVyRW5jcnlwdGVycyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmVzb2x2ZWQucHVzaChkaWQpO1xuXG4gICAgICAgICAgaWYgKGRpZFJlc29sdXRpb25NZXRhZGF0YT8uZXJyb3IgfHwgZGlkRG9jdW1lbnQgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGByZXNvbHZlcl9lcnJvcjogQ291bGQgbm90IHJlc29sdmUgJHtkaWR9OiAke2RpZFJlc29sdXRpb25NZXRhZGF0YS5lcnJvcn0sICR7ZGlkUmVzb2x1dGlvbk1ldGFkYXRhLm1lc3NhZ2V9YCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbGV0IGNvbnRyb2xsZXJFbmNyeXB0ZXJzID0gW107XG5cbiAgICAgICAgICBpZiAoIWRpZERvY3VtZW50LmNvbnRyb2xsZXIgJiYgIWRpZERvY3VtZW50LmtleUFncmVlbWVudCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBub19zdWl0YWJsZV9rZXlzOiBDb3VsZCBub3QgZmluZCB4MjU1MTkga2V5IGZvciAke2RpZH1gKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBfdGVtcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChkaWREb2N1bWVudC5jb250cm9sbGVyKSB7XG4gICAgICAgICAgICAgIGxldCBjb250cm9sbGVycyA9IEFycmF5LmlzQXJyYXkoZGlkRG9jdW1lbnQuY29udHJvbGxlcikgPyBkaWREb2N1bWVudC5jb250cm9sbGVyIDogW2RpZERvY3VtZW50LmNvbnRyb2xsZXJdO1xuICAgICAgICAgICAgICBjb250cm9sbGVycyA9IGNvbnRyb2xsZXJzLmZpbHRlcihjID0+ICFyZXNvbHZlZC5pbmNsdWRlcyhjKSk7XG4gICAgICAgICAgICAgIGNvbnN0IGVuY3J5cHRlclByb21pc2VzID0gY29udHJvbGxlcnMubWFwKGRpZCA9PiBlbmNyeXB0ZXJzRm9yRElEKGRpZCwgcmVzb2x2ZWQpLmNhdGNoKCgpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShQcm9taXNlLmFsbChlbmNyeXB0ZXJQcm9taXNlcykpLnRoZW4oZnVuY3Rpb24gKGVuY3J5cHRlckFycmF5cykge1xuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXJFbmNyeXB0ZXJzID0gW10uY29uY2F0KC4uLmVuY3J5cHRlckFycmF5cyk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0oKTtcblxuICAgICAgICAgIHJldHVybiBfdGVtcCAmJiBfdGVtcC50aGVuID8gX3RlbXAudGhlbihfdGVtcDIpIDogX3RlbXAyKF90ZW1wKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3QgZW5jcnlwdGVyUHJvbWlzZXMgPSBkaWRzLm1hcChkaWQgPT4gZW5jcnlwdGVyc0ZvckRJRChkaWQpKTtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKFByb21pc2UuYWxsKGVuY3J5cHRlclByb21pc2VzKSkudGhlbihmdW5jdGlvbiAoZW5jcnlwdGVyQXJyYXlzKSB7XG4gICAgICByZXR1cm4gW10uY29uY2F0KC4uLmVuY3J5cHRlckFycmF5cyk7XG4gICAgfSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZSk7XG4gIH1cbn07XG4vKipcbiAqIEBkZXByZWNhdGVkIFVzZSB7QGxpbmsgeGMyMHBBbm9uRGVjcnlwdGVyRWNkaEVTeDI1NTE5V2l0aFhjMjBQa3dWMiB8IHhjMjBwQW5vbkRlY3J5cHRlckVjZGhFU3gyNTUxOVdpdGhYYzIwUGt3VjIoKSB9XG4gKiAgIGluc3RlYWRcbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGVBdXRoRW5jcnlwdGVyKHJlY2lwaWVudFB1YmxpY0tleSwgc2VuZGVyU2VjcmV0LCBvcHRpb25zID0ge30pIHtcbiAgcmV0dXJuIHhjMjBwQXV0aEVuY3J5cHRlckVjZGgxUHVWM3gyNTUxOVdpdGhYYzIwUGt3VjIocmVjaXBpZW50UHVibGljS2V5LCBzZW5kZXJTZWNyZXQsIG9wdGlvbnMpO1xufVxuLyoqXG4gKiBAZGVwcmVjYXRlZCBVc2Uge0BsaW5rIHhjMjBwQW5vbkVuY3J5cHRlckVjZGhFU3gyNTUxOVdpdGhYYzIwUGt3VjIgfCB4YzIwcEFub25FbmNyeXB0ZXJFY2RoRVN4MjU1MTlXaXRoWGMyMFBrd1YyKCkgfVxuICogICBpbnN0ZWFkXG4gKi9cblxuZnVuY3Rpb24gY3JlYXRlQW5vbkVuY3J5cHRlcihwdWJsaWNLZXksIG9wdGlvbnMgPSB7fSkge1xuICByZXR1cm4geGMyMHBBbm9uRW5jcnlwdGVyRWNkaEVTeDI1NTE5V2l0aFhjMjBQa3dWMihwdWJsaWNLZXksIG9wdGlvbnMpO1xufVxuLyoqXG4gKiBAZGVwcmVjYXRlZCBVc2VcbiAqICAge0BsaW5rIHhjMjBwQXV0aERlY3J5cHRlckVjZGgxUHVWM3gyNTUxOVdpdGhYYzIwUGt3VjIgfCB4YzIwcEF1dGhEZWNyeXB0ZXJFY2RoMVB1VjN4MjU1MTlXaXRoWGMyMFBrd1YyKCkgfSBpbnN0ZWFkXG4gKi9cblxuZnVuY3Rpb24gY3JlYXRlQXV0aERlY3J5cHRlcihyZWNpcGllbnRTZWNyZXQsIHNlbmRlclB1YmxpY0tleSkge1xuICByZXR1cm4geGMyMHBBdXRoRGVjcnlwdGVyRWNkaDFQdVYzeDI1NTE5V2l0aFhjMjBQa3dWMihyZWNpcGllbnRTZWNyZXQsIHNlbmRlclB1YmxpY0tleSk7XG59XG4vKipcbiAqIEBkZXByZWNhdGVkIFVzZSB7QGxpbmsgeGMyMHBBbm9uRGVjcnlwdGVyRWNkaEVTeDI1NTE5V2l0aFhjMjBQa3dWMiB8IHhjMjBwQW5vbkRlY3J5cHRlckVjZGhFU3gyNTUxOVdpdGhYYzIwUGt3VjIoKSB9XG4gKiAgIGluc3RlYWRcbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGVBbm9uRGVjcnlwdGVyKHJlY2lwaWVudFNlY3JldCkge1xuICByZXR1cm4geGMyMHBBbm9uRGVjcnlwdGVyRWNkaEVTeDI1NTE5V2l0aFhjMjBQa3dWMihyZWNpcGllbnRTZWNyZXQpO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVIZWFkZXIoaGVhZGVyKSB7XG4gIGlmICghKGhlYWRlciAmJiBoZWFkZXIuZXBrICYmIGhlYWRlci5pdiAmJiBoZWFkZXIudGFnKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignYmFkX2p3ZTogbWFsZm9ybWVkIGhlYWRlcicpO1xuICB9XG5cbiAgcmV0dXJuIGhlYWRlcjtcbn1cbmNvbnN0IHhjMjBwS2V5V3JhcHBlciA9IHtcbiAgZnJvbTogd3JhcHBpbmdLZXkgPT4ge1xuICAgIGNvbnN0IHdyYXAgPSBmdW5jdGlvbiAoY2VrKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHhjMjBwRW5jcnlwdGVyKHdyYXBwaW5nS2V5KShjZWspKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4ge1xuICAgICAgd3JhcFxuICAgIH07XG4gIH0sXG4gIGFsZzogJ1hDMjBQS1cnXG59O1xuLyoqXG4gKiBAZGVwcmVjYXRlZCBVc2Uge0BsaW5rIHhjMjBwQW5vbkVuY3J5cHRlckVjZGhFU3gyNTUxOVdpdGhYYzIwUGt3VjIgfCB4YzIwcEFub25FbmNyeXB0ZXJFY2RoRVN4MjU1MTlXaXRoWGMyMFBrd1YyKCkgfVxuICogICBpbnN0ZWFkXG4gKi9cblxuZnVuY3Rpb24geDI1NTE5RW5jcnlwdGVyKHB1YmxpY0tleSwga2lkLCBhcHYpIHtcbiAgcmV0dXJuIHhjMjBwQW5vbkVuY3J5cHRlckVjZGhFU3gyNTUxOVdpdGhYYzIwUGt3VjIocHVibGljS2V5LCB7XG4gICAga2lkLFxuICAgIGFwdlxuICB9KTtcbn1cbi8qKlxuICogUmVjb21tZW5kZWQgZW5jcnlwdGVyIGZvciBhbm9ueW1vdXMgZW5jcnlwdGlvbiAoaS5lLiBubyBzZW5kZXIgYXV0aGVudGljYXRpb24pLlxuICogVXNlcyB7QGxpbmsgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL2RyYWZ0LWFtcmluZ2VyLWpvc2UtY2hhY2hhLTAyIHwgRUNESC1FUytYQzIwUEtXIHYyfS5cbiAqXG4gKiBAcGFyYW0gcmVjaXBpZW50UHVibGljS2V5IC0gdGhlIGJ5dGUgYXJyYXkgcmVwcmVzZW50aW5nIHRoZSByZWNpcGllbnQgcHVibGljIGtleVxuICogQHBhcmFtIG9wdGlvbnMgLSB7QGxpbmsgQW5vbkVuY3J5cHRQYXJhbXN9IHVzZWQgdG8gc3BlY2lmeSB0aGUgcmVjaXBpZW50IGtleSBJRCAoYGtpZGApXG4gKlxuICogQHJldHVybnMgYW4ge0BsaW5rIEVuY3J5cHRlcn0gaW5zdGFuY2UgdXNhYmxlIHdpdGgge0BsaW5rIGNyZWF0ZUpXRX1cbiAqXG4gKiBOT1RFOiBFQ0RILUVTK1hDMjBQS1cgaXMgYSBwcm9wb3NlZCBkcmFmdCBpbiBJRVRGIGFuZCBub3QgYSBzdGFuZGFyZCB5ZXQgYW5kXG4gKiBpcyBzdWJqZWN0IHRvIGNoYW5nZSBhcyBuZXcgcmV2aXNpb25zIG9yIHVudGlsIHRoZSBvZmZpY2lhbCBDRlJHIHNwZWNpZmljYXRpb24gaXMgcmVsZWFzZWQuXG4gKi9cblxuZnVuY3Rpb24geGMyMHBBbm9uRW5jcnlwdGVyRWNkaEVTeDI1NTE5V2l0aFhjMjBQa3dWMihyZWNpcGllbnRQdWJsaWNLZXksIG9wdGlvbnMgPSB7fSkge1xuICByZXR1cm4gY3JlYXRlRnVsbEVuY3J5cHRlcihyZWNpcGllbnRQdWJsaWNLZXksIHVuZGVmaW5lZCwgb3B0aW9ucywge1xuICAgIGNyZWF0ZUtlazogY3JlYXRlWDI1NTE5RWNkaEVzS2VrLFxuICAgIGFsZzogJ0VDREgtRVMnXG4gIH0sIHhjMjBwS2V5V3JhcHBlciwge1xuICAgIGZyb206IGNlayA9PiB4YzIwcERpckVuY3J5cHRlcihjZWspLFxuICAgIGVuYzogJ1hDMjBQJ1xuICB9KTtcbn1cbi8qKlxuICogIFJlY29tbWVuZGVkIGVuY3J5cHRlciBmb3IgYXV0aGVudGljYXRlZCBlbmNyeXB0aW9uIChpLmUuIHNlbmRlciBhdXRoZW50aWNhdGlvbiBhbmQgcmVxdWlyZXNcbiAqICBzZW5kZXIgcHJpdmF0ZSBrZXkgdG8gZW5jcnlwdCB0aGUgZGF0YSkuXG4gKiAgVXNlcyB7QGxpbmsgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL2RyYWZ0LW1hZGRlbi1qb3NlLWVjZGgtMXB1LTAzIHwgRUNESC0xUFUgdjMgfSBhbmRcbiAqICB7QGxpbmsgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL2RyYWZ0LWFtcmluZ2VyLWpvc2UtY2hhY2hhLTAyIHwgWEMyMFBLVyB2MiB9LlxuICpcbiAqICBAcGFyYW0gcmVjaXBpZW50UHVibGljS2V5IC0gdGhlIGJ5dGUgYXJyYXkgcmVwcmVzZW50aW5nIHRoZSByZWNpcGllbnQgcHVibGljIGtleVxuICogIEBwYXJhbSBzZW5kZXJTZWNyZXQgLSBlaXRoZXIgYSBVaW50OEFycmF5IHJlcHJlc2VudGluZyB0aGUgc2VuZGVyIHNlY3JldCBrZXkgb3JcbiAqICAgIGFuIEVDREggZnVuY3Rpb24gdGhhdCB3cmFwcyB0aGUga2V5IGFuZCBjYW4gcHJvbWlzZSBhIHNoYXJlZCBzZWNyZXQgZ2l2ZW4gYSBwdWJsaWMga2V5XG4gKiAgQHBhcmFtIG9wdGlvbnMgLSB7QGxpbmsgQXV0aEVuY3J5cHRQYXJhbXN9IHVzZWQgdG8gc3BlY2lmeSBleHRyYSBoZWFkZXIgcGFyYW1ldGVyc1xuICpcbiAqICBAcmV0dXJucyBhbiB7QGxpbmsgRW5jcnlwdGVyfSBpbnN0YW5jZSB1c2FibGUgd2l0aCB7QGxpbmsgY3JlYXRlSldFfVxuICpcbiAqICBOT1RFOiBFQ0RILTFQVSBhbmQgWEMyMFBLVyBhcmUgcHJvcG9zZWQgZHJhZnRzIGluIElFVEYgYW5kIG5vdCBhIHN0YW5kYXJkIHlldCBhbmRcbiAqICBhcmUgc3ViamVjdCB0byBjaGFuZ2UgYXMgbmV3IHJldmlzaW9ucyBvciB1bnRpbCB0aGUgb2ZmaWNpYWwgQ0ZSRyBzcGVjaWZpY2F0aW9uIGFyZSByZWxlYXNlZC5cbiAqXG4gKiBJbXBsZW1lbnRzIEVDREgtMVBVK1hDMjBQS1cgd2l0aCBYQ2hhQ2hhMjBQb2x5MTMwNSBiYXNlZCBvbiB0aGUgZm9sbG93aW5nIHNwZWNzOlxuICogICAtIHtAbGluayBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvZHJhZnQtYW1yaW5nZXItam9zZS1jaGFjaGEtMDIgfCBYQzIwUEtXfVxuICogICAtIHtAbGluayBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvZHJhZnQtbWFkZGVuLWpvc2UtZWNkaC0xcHUtMDMgfCBFQ0RILTFQVX1cbiAqL1xuXG5mdW5jdGlvbiB4YzIwcEF1dGhFbmNyeXB0ZXJFY2RoMVB1VjN4MjU1MTlXaXRoWGMyMFBrd1YyKHJlY2lwaWVudFB1YmxpY0tleSwgc2VuZGVyU2VjcmV0LCBvcHRpb25zID0ge30pIHtcbiAgcmV0dXJuIGNyZWF0ZUZ1bGxFbmNyeXB0ZXIocmVjaXBpZW50UHVibGljS2V5LCBzZW5kZXJTZWNyZXQsIG9wdGlvbnMsIHtcbiAgICBjcmVhdGVLZWs6IGNyZWF0ZVgyNTUxOUVjZGgxUFV2M0tlayxcbiAgICBhbGc6ICdFQ0RILTFQVSdcbiAgfSwgeGMyMHBLZXlXcmFwcGVyLCB7XG4gICAgZnJvbTogY2VrID0+IHhjMjBwRGlyRW5jcnlwdGVyKGNlayksXG4gICAgZW5jOiAnWEMyMFAnXG4gIH0pO1xufVxuZnVuY3Rpb24geDI1NTE5RGVjcnlwdGVyKHJlY2VpdmVyU2VjcmV0KSB7XG4gIHJldHVybiB4YzIwcEFub25EZWNyeXB0ZXJFY2RoRVN4MjU1MTlXaXRoWGMyMFBrd1YyKHJlY2VpdmVyU2VjcmV0KTtcbn1cbi8qKlxuICogUmVjb21tZW5kZWQgZGVjcnlwdGVyIGZvciBhbm9ueW1vdXMgZW5jcnlwdGlvbiAoaS5lLiBubyBzZW5kZXIgYXV0aGVudGljYXRpb24pLlxuICogVXNlcyB7QGxpbmsgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL2RyYWZ0LWFtcmluZ2VyLWpvc2UtY2hhY2hhLTAyIHwgRUNESC1FUytYQzIwUEtXIHYyIH0uXG4gKlxuICogQHBhcmFtIHJlY2lwaWVudFNlY3JldCAtIGVpdGhlciBhIFVpbnQ4QXJyYXkgcmVwcmVzZW50aW5nIHRoZSByZWNpcGllbnQgc2VjcmV0IGtleSBvclxuICogICBhbiBFQ0RIIGZ1bmN0aW9uIHRoYXQgd3JhcHMgdGhlIGtleSBhbmQgY2FuIHByb21pc2UgYSBzaGFyZWQgc2VjcmV0IGdpdmVuIGEgcHVibGljIGtleVxuICpcbiAqIEByZXR1cm5zIGEge0BsaW5rIERlY3J5cHRlcn0gaW5zdGFuY2UgdXNhYmxlIHdpdGgge0BsaW5rIGRlY3J5cHRKV0V9XG4gKlxuICogTk9URTogRUNESC1FUytYQzIwUEtXIGlzIGEgcHJvcG9zZWQgZHJhZnQgaW4gSUVURiBhbmQgbm90IGEgc3RhbmRhcmQgeWV0IGFuZFxuICogaXMgc3ViamVjdCB0byBjaGFuZ2UgYXMgbmV3IHJldmlzaW9ucyBvciB1bnRpbCB0aGUgb2ZmaWNpYWwgQ0ZSRyBzcGVjaWZpY2F0aW9uIGlzIHJlbGVhc2VkLlxuICpcbiAqIEBiZXRhXG4gKi9cblxuZnVuY3Rpb24geGMyMHBBbm9uRGVjcnlwdGVyRWNkaEVTeDI1NTE5V2l0aFhjMjBQa3dWMihyZWNpcGllbnRTZWNyZXQpIHtcbiAgY29uc3QgZGVjcnlwdCA9IGZ1bmN0aW9uIChzZWFsZWQsIGl2LCBhYWQsIHJlY2lwaWVudCkge1xuICAgIHRyeSB7XG4gICAgICByZWNpcGllbnQgPSByZWNpcGllbnQ7XG4gICAgICBjb25zdCBoZWFkZXIgPSB2YWxpZGF0ZUhlYWRlcihyZWNpcGllbnQuaGVhZGVyKTtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoY29tcHV0ZVgyNTUxOUVjZGhFc0tlayhyZWNpcGllbnQsIHJlY2lwaWVudFNlY3JldCwgYWxnKSkudGhlbihmdW5jdGlvbiAoa2VrKSB7XG4gICAgICAgIGlmICgha2VrKSByZXR1cm4gbnVsbDsgLy8gQ29udGVudCBFbmNyeXB0aW9uIEtleVxuXG4gICAgICAgIGNvbnN0IHNlYWxlZENlayA9IHRvU2VhbGVkKHJlY2lwaWVudC5lbmNyeXB0ZWRfa2V5LCBoZWFkZXIudGFnKTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh4YzIwcERpckRlY3J5cHRlcihrZWspLmRlY3J5cHQoc2VhbGVkQ2VrLCBiYXNlNjRUb0J5dGVzKGhlYWRlci5pdikpKS50aGVuKGZ1bmN0aW9uIChjZWspIHtcbiAgICAgICAgICByZXR1cm4gY2VrID09PSBudWxsID8gbnVsbCA6IHhjMjBwRGlyRGVjcnlwdGVyKGNlaykuZGVjcnlwdChzZWFsZWQsIGl2LCBhYWQpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlKTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgYWxnID0gJ0VDREgtRVMrWEMyMFBLVyc7XG4gIGNvbnN0IGVuYyA9ICdYQzIwUCc7XG4gIHJldHVybiB7XG4gICAgYWxnLFxuICAgIGVuYyxcbiAgICBkZWNyeXB0XG4gIH07XG59XG4vKipcbiAqIFJlY29tbWVuZGVkIGRlY3J5cHRlciBmb3IgYXV0aGVudGljYXRlZCBlbmNyeXB0aW9uIChpLmUuIHNlbmRlciBhdXRoZW50aWNhdGlvbiBhbmQgcmVxdWlyZXNcbiAqIHNlbmRlciBwdWJsaWMga2V5IHRvIGRlY3J5cHQgdGhlIGRhdGEpLlxuICogVXNlcyB7QGxpbmsgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL2RyYWZ0LW1hZGRlbi1qb3NlLWVjZGgtMXB1LTAzIHwgRUNESC0xUFUgdjMgfSBhbmRcbiAqIHtAbGluayBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvZHJhZnQtYW1yaW5nZXItam9zZS1jaGFjaGEtMDIgfCBYQzIwUEtXIHYyIH0uXG4gKlxuICogQHBhcmFtIHJlY2lwaWVudFNlY3JldCAtIGVpdGhlciBhIFVpbnQ4QXJyYXkgcmVwcmVzZW50aW5nIHRoZSByZWNpcGllbnQgc2VjcmV0IGtleSBvclxuICogICBhbiBFQ0RIIGZ1bmN0aW9uIHRoYXQgd3JhcHMgdGhlIGtleSBhbmQgY2FuIHByb21pc2UgYSBzaGFyZWQgc2VjcmV0IGdpdmVuIGEgcHVibGljIGtleVxuICogQHBhcmFtIHNlbmRlclB1YmxpY0tleSAtIHRoZSBieXRlIGFycmF5IHJlcHJlc2VudGluZyB0aGUgc2VuZGVyIHB1YmxpYyBrZXlcbiAqXG4gKiBAcmV0dXJucyBhIHtAbGluayBEZWNyeXB0ZXJ9IGluc3RhbmNlIHVzYWJsZSB3aXRoIHtAbGluayBkZWNyeXB0SldFfVxuICpcbiAqIE5PVEU6IEVDREgtMVBVIGFuZCBYQzIwUEtXIGFyZSBwcm9wb3NlZCBkcmFmdHMgaW4gSUVURiBhbmQgbm90IGEgc3RhbmRhcmQgeWV0IGFuZFxuICogYXJlIHN1YmplY3QgdG8gY2hhbmdlIGFzIG5ldyByZXZpc2lvbnMgb3IgdW50aWwgdGhlIG9mZmljaWFsIENGUkcgc3BlY2lmaWNhdGlvbiBhcmUgcmVsZWFzZWQuXG4gKlxuICogQGJldGFcbiAqXG4gKiBJbXBsZW1lbnRzIEVDREgtMVBVK1hDMjBQS1cgd2l0aCBYQ2hhQ2hhMjBQb2x5MTMwNSBiYXNlZCBvbiB0aGUgZm9sbG93aW5nIHNwZWNzOlxuICogICAtIHtAbGluayBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvZHJhZnQtYW1yaW5nZXItam9zZS1jaGFjaGEtMDIgfCBYQzIwUEtXfVxuICogICAtIHtAbGluayBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvZHJhZnQtbWFkZGVuLWpvc2UtZWNkaC0xcHUtMDMgfCBFQ0RILTFQVX1cbiAqL1xuXG5mdW5jdGlvbiB4YzIwcEF1dGhEZWNyeXB0ZXJFY2RoMVB1VjN4MjU1MTlXaXRoWGMyMFBrd1YyKHJlY2lwaWVudFNlY3JldCwgc2VuZGVyUHVibGljS2V5KSB7XG4gIGNvbnN0IGRlY3J5cHQgPSBmdW5jdGlvbiAoc2VhbGVkLCBpdiwgYWFkLCByZWNpcGllbnQpIHtcbiAgICB0cnkge1xuICAgICAgcmVjaXBpZW50ID0gcmVjaXBpZW50O1xuICAgICAgY29uc3QgaGVhZGVyID0gdmFsaWRhdGVIZWFkZXIocmVjaXBpZW50LmhlYWRlcik7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGNvbXB1dGVYMjU1MTlFY2RoMVBVdjNLZWsocmVjaXBpZW50LCByZWNpcGllbnRTZWNyZXQsIHNlbmRlclB1YmxpY0tleSwgYWxnKSkudGhlbihmdW5jdGlvbiAoa2VrKSB7XG4gICAgICAgIGlmICgha2VrKSByZXR1cm4gbnVsbDsgLy8gQ29udGVudCBFbmNyeXB0aW9uIEtleVxuXG4gICAgICAgIGNvbnN0IHNlYWxlZENlayA9IHRvU2VhbGVkKHJlY2lwaWVudC5lbmNyeXB0ZWRfa2V5LCBoZWFkZXIudGFnKTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh4YzIwcERpckRlY3J5cHRlcihrZWspLmRlY3J5cHQoc2VhbGVkQ2VrLCBiYXNlNjRUb0J5dGVzKGhlYWRlci5pdikpKS50aGVuKGZ1bmN0aW9uIChjZWspIHtcbiAgICAgICAgICByZXR1cm4gY2VrID09PSBudWxsID8gbnVsbCA6IHhjMjBwRGlyRGVjcnlwdGVyKGNlaykuZGVjcnlwdChzZWFsZWQsIGl2LCBhYWQpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlKTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgYWxnID0gJ0VDREgtMVBVK1hDMjBQS1cnO1xuICBjb25zdCBlbmMgPSAnWEMyMFAnO1xuICByZXR1cm4ge1xuICAgIGFsZyxcbiAgICBlbmMsXG4gICAgZGVjcnlwdFxuICB9O1xufVxuXG5leHBvcnQgeyBFUzI1NktTaWduZXIsIEVTMjU2U2lnbmVyLCBFZERTQVNpZ25lciwgRWxsaXB0aWNTaWduZXIsIEpXVF9FUlJPUiwgTmFjbFNpZ25lciwgU2ltcGxlU2lnbmVyLCBiYXNlNThUb0J5dGVzLCBiYXNlNjRUb0J5dGVzLCBieXRlc1RvQmFzZTU4LCBieXRlc1RvQmFzZTY0dXJsLCBieXRlc1RvSGV4LCBieXRlc1RvTXVsdGliYXNlLCBjb21wdXRlWDI1NTE5RWNkaDFQVXYzS2VrLCBjb21wdXRlWDI1NTE5RWNkaEVzS2VrLCBjb25jYXRLREYsIGNyZWF0ZUFub25EZWNyeXB0ZXIsIGNyZWF0ZUFub25FbmNyeXB0ZXIsIGNyZWF0ZUF1dGhEZWNyeXB0ZXIsIGNyZWF0ZUF1dGhFbmNyeXB0ZXIsIGNyZWF0ZUZ1bGxFbmNyeXB0ZXIsIGNyZWF0ZUpXRSwgY3JlYXRlSldTLCBjcmVhdGVKV1QsIGNyZWF0ZU11bHRpc2lnbmF0dXJlSldULCBjcmVhdGVYMjU1MTlFQ0RILCBjcmVhdGVYMjU1MTlFY2RoMVBVdjNLZWssIGNyZWF0ZVgyNTUxOUVjZGhFc0tlaywgZGVjb2RlSldULCBkZWNyeXB0SldFLCBleHRyYWN0UHVibGljS2V5Qnl0ZXMsIGdlblgyNTUxOUVwaGVtZXJhbEtleVBhaXIsIGhleFRvQnl0ZXMsIG11bHRpYmFzZVRvQnl0ZXMsIHJlc29sdmVYMjU1MTlFbmNyeXB0ZXJzLCBzdXBwb3J0ZWRDb2RlY3MsIHRvRXRoZXJldW1BZGRyZXNzLCB2ZXJpZnlKV1MsIHZlcmlmeUpXVCwgeDI1NTE5RGVjcnlwdGVyLCB4MjU1MTlFbmNyeXB0ZXIsIHhjMjBwQXV0aERlY3J5cHRlckVjZGgxUHVWM3gyNTUxOVdpdGhYYzIwUGt3VjIsIHhjMjBwQXV0aEVuY3J5cHRlckVjZGgxUHVWM3gyNTUxOVdpdGhYYzIwUGt3VjIsIHhjMjBwRGlyRGVjcnlwdGVyLCB4YzIwcERpckVuY3J5cHRlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubW9kdWxlLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/did-jwt/lib/index.module.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/did-jwt/node_modules/@scure/base/index.js":
/*!********************************************************************!*\
  !*** ../../node_modules/did-jwt/node_modules/@scure/base/index.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   base16: () => (/* binding */ base16),\n/* harmony export */   base32: () => (/* binding */ base32),\n/* harmony export */   base32crockford: () => (/* binding */ base32crockford),\n/* harmony export */   base32hex: () => (/* binding */ base32hex),\n/* harmony export */   base32hexnopad: () => (/* binding */ base32hexnopad),\n/* harmony export */   base32nopad: () => (/* binding */ base32nopad),\n/* harmony export */   base58: () => (/* binding */ base58),\n/* harmony export */   base58check: () => (/* binding */ base58check),\n/* harmony export */   base58flickr: () => (/* binding */ base58flickr),\n/* harmony export */   base58xmr: () => (/* binding */ base58xmr),\n/* harmony export */   base58xrp: () => (/* binding */ base58xrp),\n/* harmony export */   base64: () => (/* binding */ base64),\n/* harmony export */   base64nopad: () => (/* binding */ base64nopad),\n/* harmony export */   base64url: () => (/* binding */ base64url),\n/* harmony export */   base64urlnopad: () => (/* binding */ base64urlnopad),\n/* harmony export */   bech32: () => (/* binding */ bech32),\n/* harmony export */   bech32m: () => (/* binding */ bech32m),\n/* harmony export */   bytes: () => (/* binding */ bytes),\n/* harmony export */   bytesToString: () => (/* binding */ bytesToString),\n/* harmony export */   createBase58check: () => (/* binding */ createBase58check),\n/* harmony export */   hex: () => (/* binding */ hex),\n/* harmony export */   str: () => (/* binding */ str),\n/* harmony export */   stringToBytes: () => (/* binding */ stringToBytes),\n/* harmony export */   utf8: () => (/* binding */ utf8),\n/* harmony export */   utils: () => (/* binding */ utils)\n/* harmony export */ });\n/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nfunction isBytes(a) {\n    return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\n/** Asserts something is Uint8Array. */\nfunction abytes(b) {\n    if (!isBytes(b))\n        throw new Error('Uint8Array expected');\n}\nfunction isArrayOf(isString, arr) {\n    if (!Array.isArray(arr))\n        return false;\n    if (arr.length === 0)\n        return true;\n    if (isString) {\n        return arr.every((item) => typeof item === 'string');\n    }\n    else {\n        return arr.every((item) => Number.isSafeInteger(item));\n    }\n}\nfunction afn(input) {\n    if (typeof input !== 'function')\n        throw new Error('function expected');\n    return true;\n}\nfunction astr(label, input) {\n    if (typeof input !== 'string')\n        throw new Error(`${label}: string expected`);\n    return true;\n}\nfunction anumber(n) {\n    if (!Number.isSafeInteger(n))\n        throw new Error(`invalid integer: ${n}`);\n}\nfunction aArr(input) {\n    if (!Array.isArray(input))\n        throw new Error('array expected');\n}\nfunction astrArr(label, input) {\n    if (!isArrayOf(true, input))\n        throw new Error(`${label}: array of strings expected`);\n}\nfunction anumArr(label, input) {\n    if (!isArrayOf(false, input))\n        throw new Error(`${label}: array of numbers expected`);\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction chain(...args) {\n    const id = (a) => a;\n    // Wrap call in closure so JIT can inline calls\n    const wrap = (a, b) => (c) => a(b(c));\n    // Construct chain of args[-1].encode(args[-2].encode([...]))\n    const encode = args.map((x) => x.encode).reduceRight(wrap, id);\n    // Construct chain of args[0].decode(args[1].decode(...))\n    const decode = args.map((x) => x.decode).reduce(wrap, id);\n    return { encode, decode };\n}\n/**\n * Encodes integer radix representation to array of strings using alphabet and back.\n * Could also be array of strings.\n * @__NO_SIDE_EFFECTS__\n */\nfunction alphabet(letters) {\n    // mapping 1 to \"b\"\n    const lettersA = typeof letters === 'string' ? letters.split('') : letters;\n    const len = lettersA.length;\n    astrArr('alphabet', lettersA);\n    // mapping \"b\" to 1\n    const indexes = new Map(lettersA.map((l, i) => [l, i]));\n    return {\n        encode: (digits) => {\n            aArr(digits);\n            return digits.map((i) => {\n                if (!Number.isSafeInteger(i) || i < 0 || i >= len)\n                    throw new Error(`alphabet.encode: digit index outside alphabet \"${i}\". Allowed: ${letters}`);\n                return lettersA[i];\n            });\n        },\n        decode: (input) => {\n            aArr(input);\n            return input.map((letter) => {\n                astr('alphabet.decode', letter);\n                const i = indexes.get(letter);\n                if (i === undefined)\n                    throw new Error(`Unknown letter: \"${letter}\". Allowed: ${letters}`);\n                return i;\n            });\n        },\n    };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction join(separator = '') {\n    astr('join', separator);\n    return {\n        encode: (from) => {\n            astrArr('join.decode', from);\n            return from.join(separator);\n        },\n        decode: (to) => {\n            astr('join.decode', to);\n            return to.split(separator);\n        },\n    };\n}\n/**\n * Pad strings array so it has integer number of bits\n * @__NO_SIDE_EFFECTS__\n */\nfunction padding(bits, chr = '=') {\n    anumber(bits);\n    astr('padding', chr);\n    return {\n        encode(data) {\n            astrArr('padding.encode', data);\n            while ((data.length * bits) % 8)\n                data.push(chr);\n            return data;\n        },\n        decode(input) {\n            astrArr('padding.decode', input);\n            let end = input.length;\n            if ((end * bits) % 8)\n                throw new Error('padding: invalid, string should have whole number of bytes');\n            for (; end > 0 && input[end - 1] === chr; end--) {\n                const last = end - 1;\n                const byte = last * bits;\n                if (byte % 8 === 0)\n                    throw new Error('padding: invalid, string has too much padding');\n            }\n            return input.slice(0, end);\n        },\n    };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction normalize(fn) {\n    afn(fn);\n    return { encode: (from) => from, decode: (to) => fn(to) };\n}\n/**\n * Slow: O(n^2) time complexity\n */\nfunction convertRadix(data, from, to) {\n    // base 1 is impossible\n    if (from < 2)\n        throw new Error(`convertRadix: invalid from=${from}, base cannot be less than 2`);\n    if (to < 2)\n        throw new Error(`convertRadix: invalid to=${to}, base cannot be less than 2`);\n    aArr(data);\n    if (!data.length)\n        return [];\n    let pos = 0;\n    const res = [];\n    const digits = Array.from(data, (d) => {\n        anumber(d);\n        if (d < 0 || d >= from)\n            throw new Error(`invalid integer: ${d}`);\n        return d;\n    });\n    const dlen = digits.length;\n    while (true) {\n        let carry = 0;\n        let done = true;\n        for (let i = pos; i < dlen; i++) {\n            const digit = digits[i];\n            const fromCarry = from * carry;\n            const digitBase = fromCarry + digit;\n            if (!Number.isSafeInteger(digitBase) ||\n                fromCarry / from !== carry ||\n                digitBase - digit !== fromCarry) {\n                throw new Error('convertRadix: carry overflow');\n            }\n            const div = digitBase / to;\n            carry = digitBase % to;\n            const rounded = Math.floor(div);\n            digits[i] = rounded;\n            if (!Number.isSafeInteger(rounded) || rounded * to + carry !== digitBase)\n                throw new Error('convertRadix: carry overflow');\n            if (!done)\n                continue;\n            else if (!rounded)\n                pos = i;\n            else\n                done = false;\n        }\n        res.push(carry);\n        if (done)\n            break;\n    }\n    for (let i = 0; i < data.length - 1 && data[i] === 0; i++)\n        res.push(0);\n    return res.reverse();\n}\nconst gcd = (a, b) => (b === 0 ? a : gcd(b, a % b));\nconst radix2carry = /* @__NO_SIDE_EFFECTS__ */ (from, to) => from + (to - gcd(from, to));\nconst powers = /* @__PURE__ */ (() => {\n    let res = [];\n    for (let i = 0; i < 40; i++)\n        res.push(2 ** i);\n    return res;\n})();\n/**\n * Implemented with numbers, because BigInt is 5x slower\n */\nfunction convertRadix2(data, from, to, padding) {\n    aArr(data);\n    if (from <= 0 || from > 32)\n        throw new Error(`convertRadix2: wrong from=${from}`);\n    if (to <= 0 || to > 32)\n        throw new Error(`convertRadix2: wrong to=${to}`);\n    if (radix2carry(from, to) > 32) {\n        throw new Error(`convertRadix2: carry overflow from=${from} to=${to} carryBits=${radix2carry(from, to)}`);\n    }\n    let carry = 0;\n    let pos = 0; // bitwise position in current element\n    const max = powers[from];\n    const mask = powers[to] - 1;\n    const res = [];\n    for (const n of data) {\n        anumber(n);\n        if (n >= max)\n            throw new Error(`convertRadix2: invalid data word=${n} from=${from}`);\n        carry = (carry << from) | n;\n        if (pos + from > 32)\n            throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from}`);\n        pos += from;\n        for (; pos >= to; pos -= to)\n            res.push(((carry >> (pos - to)) & mask) >>> 0);\n        const pow = powers[pos];\n        if (pow === undefined)\n            throw new Error('invalid carry');\n        carry &= pow - 1; // clean carry, otherwise it will cause overflow\n    }\n    carry = (carry << (to - pos)) & mask;\n    if (!padding && pos >= from)\n        throw new Error('Excess padding');\n    if (!padding && carry > 0)\n        throw new Error(`Non-zero padding: ${carry}`);\n    if (padding && pos > 0)\n        res.push(carry >>> 0);\n    return res;\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction radix(num) {\n    anumber(num);\n    const _256 = 2 ** 8;\n    return {\n        encode: (bytes) => {\n            if (!isBytes(bytes))\n                throw new Error('radix.encode input should be Uint8Array');\n            return convertRadix(Array.from(bytes), _256, num);\n        },\n        decode: (digits) => {\n            anumArr('radix.decode', digits);\n            return Uint8Array.from(convertRadix(digits, num, _256));\n        },\n    };\n}\n/**\n * If both bases are power of same number (like `2**8 <-> 2**64`),\n * there is a linear algorithm. For now we have implementation for power-of-two bases only.\n * @__NO_SIDE_EFFECTS__\n */\nfunction radix2(bits, revPadding = false) {\n    anumber(bits);\n    if (bits <= 0 || bits > 32)\n        throw new Error('radix2: bits should be in (0..32]');\n    if (radix2carry(8, bits) > 32 || radix2carry(bits, 8) > 32)\n        throw new Error('radix2: carry overflow');\n    return {\n        encode: (bytes) => {\n            if (!isBytes(bytes))\n                throw new Error('radix2.encode input should be Uint8Array');\n            return convertRadix2(Array.from(bytes), 8, bits, !revPadding);\n        },\n        decode: (digits) => {\n            anumArr('radix2.decode', digits);\n            return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding));\n        },\n    };\n}\nfunction unsafeWrapper(fn) {\n    afn(fn);\n    return function (...args) {\n        try {\n            return fn.apply(null, args);\n        }\n        catch (e) { }\n    };\n}\nfunction checksum(len, fn) {\n    anumber(len);\n    afn(fn);\n    return {\n        encode(data) {\n            if (!isBytes(data))\n                throw new Error('checksum.encode: input should be Uint8Array');\n            const sum = fn(data).slice(0, len);\n            const res = new Uint8Array(data.length + len);\n            res.set(data);\n            res.set(sum, data.length);\n            return res;\n        },\n        decode(data) {\n            if (!isBytes(data))\n                throw new Error('checksum.decode: input should be Uint8Array');\n            const payload = data.slice(0, -len);\n            const oldChecksum = data.slice(-len);\n            const newChecksum = fn(payload).slice(0, len);\n            for (let i = 0; i < len; i++)\n                if (newChecksum[i] !== oldChecksum[i])\n                    throw new Error('Invalid checksum');\n            return payload;\n        },\n    };\n}\n// prettier-ignore\nconst utils = {\n    alphabet, chain, checksum, convertRadix, convertRadix2, radix, radix2, join, padding,\n};\n// RFC 4648 aka RFC 3548\n// ---------------------\n/**\n * base16 encoding from RFC 4648.\n * @example\n * ```js\n * base16.encode(Uint8Array.from([0x12, 0xab]));\n * // => '12AB'\n * ```\n */\nconst base16 = chain(radix2(4), alphabet('0123456789ABCDEF'), join(''));\n/**\n * base32 encoding from RFC 4648. Has padding.\n * Use `base32nopad` for unpadded version.\n * Also check out `base32hex`, `base32hexnopad`, `base32crockford`.\n * @example\n * ```js\n * base32.encode(Uint8Array.from([0x12, 0xab]));\n * // => 'CKVQ===='\n * base32.decode('CKVQ====');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\nconst base32 = chain(radix2(5), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'), padding(5), join(''));\n/**\n * base32 encoding from RFC 4648. No padding.\n * Use `base32` for padded version.\n * Also check out `base32hex`, `base32hexnopad`, `base32crockford`.\n * @example\n * ```js\n * base32nopad.encode(Uint8Array.from([0x12, 0xab]));\n * // => 'CKVQ'\n * base32nopad.decode('CKVQ');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\nconst base32nopad = chain(radix2(5), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'), join(''));\n/**\n * base32 encoding from RFC 4648. Padded. Compared to ordinary `base32`, slightly different alphabet.\n * Use `base32hexnopad` for unpadded version.\n * @example\n * ```js\n * base32hex.encode(Uint8Array.from([0x12, 0xab]));\n * // => '2ALG===='\n * base32hex.decode('2ALG====');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\nconst base32hex = chain(radix2(5), alphabet('0123456789ABCDEFGHIJKLMNOPQRSTUV'), padding(5), join(''));\n/**\n * base32 encoding from RFC 4648. No padding. Compared to ordinary `base32`, slightly different alphabet.\n * Use `base32hex` for padded version.\n * @example\n * ```js\n * base32hexnopad.encode(Uint8Array.from([0x12, 0xab]));\n * // => '2ALG'\n * base32hexnopad.decode('2ALG');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\nconst base32hexnopad = chain(radix2(5), alphabet('0123456789ABCDEFGHIJKLMNOPQRSTUV'), join(''));\n/**\n * base32 encoding from RFC 4648. Doug Crockford's version.\n * https://www.crockford.com/base32.html\n * @example\n * ```js\n * base32crockford.encode(Uint8Array.from([0x12, 0xab]));\n * // => '2ANG'\n * base32crockford.decode('2ANG');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\nconst base32crockford = chain(radix2(5), alphabet('0123456789ABCDEFGHJKMNPQRSTVWXYZ'), join(''), normalize((s) => s.toUpperCase().replace(/O/g, '0').replace(/[IL]/g, '1')));\n// Built-in base64 conversion https://caniuse.com/mdn-javascript_builtins_uint8array_frombase64\n// prettier-ignore\nconst hasBase64Builtin = /* @__PURE__ */ (() => typeof Uint8Array.from([]).toBase64 === 'function' &&\n    typeof Uint8Array.fromBase64 === 'function')();\nconst decodeBase64Builtin = (s, isUrl) => {\n    astr('base64', s);\n    const re = isUrl ? /^[A-Za-z0-9=_-]+$/ : /^[A-Za-z0-9=+/]+$/;\n    const alphabet = isUrl ? 'base64url' : 'base64';\n    if (s.length > 0 && !re.test(s))\n        throw new Error('invalid base64');\n    return Uint8Array.fromBase64(s, { alphabet, lastChunkHandling: 'strict' });\n};\n/**\n * base64 from RFC 4648. Padded.\n * Use `base64nopad` for unpadded version.\n * Also check out `base64url`, `base64urlnopad`.\n * Falls back to built-in function, when available.\n * @example\n * ```js\n * base64.encode(Uint8Array.from([0x12, 0xab]));\n * // => 'Eqs='\n * base64.decode('Eqs=');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\n// prettier-ignore\nconst base64 = hasBase64Builtin ? {\n    encode(b) { abytes(b); return b.toBase64(); },\n    decode(s) { return decodeBase64Builtin(s, false); },\n} : chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'), padding(6), join(''));\n/**\n * base64 from RFC 4648. No padding.\n * Use `base64` for padded version.\n * @example\n * ```js\n * base64nopad.encode(Uint8Array.from([0x12, 0xab]));\n * // => 'Eqs'\n * base64nopad.decode('Eqs');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\nconst base64nopad = chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'), join(''));\n/**\n * base64 from RFC 4648, using URL-safe alphabet. Padded.\n * Use `base64urlnopad` for unpadded version.\n * Falls back to built-in function, when available.\n * @example\n * ```js\n * base64url.encode(Uint8Array.from([0x12, 0xab]));\n * // => 'Eqs='\n * base64url.decode('Eqs=');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\n// prettier-ignore\nconst base64url = hasBase64Builtin ? {\n    encode(b) { abytes(b); return b.toBase64({ alphabet: 'base64url' }); },\n    decode(s) { return decodeBase64Builtin(s, true); },\n} : chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'), padding(6), join(''));\n/**\n * base64 from RFC 4648, using URL-safe alphabet. No padding.\n * Use `base64url` for padded version.\n * @example\n * ```js\n * base64urlnopad.encode(Uint8Array.from([0x12, 0xab]));\n * // => 'Eqs'\n * base64urlnopad.decode('Eqs');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\nconst base64urlnopad = chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'), join(''));\n// base58 code\n// -----------\nconst genBase58 = /* @__NO_SIDE_EFFECTS__ */ (abc) => chain(radix(58), alphabet(abc), join(''));\n/**\n * base58: base64 without ambigous characters +, /, 0, O, I, l.\n * Quadratic (O(n^2)) - so, can't be used on large inputs.\n * @example\n * ```js\n * base58.decode('01abcdef');\n * // => '3UhJW'\n * ```\n */\nconst base58 = genBase58('123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz');\n/**\n * base58: flickr version. Check out `base58`.\n */\nconst base58flickr = genBase58('123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ');\n/**\n * base58: XRP version. Check out `base58`.\n */\nconst base58xrp = genBase58('rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz');\n// Data len (index) -> encoded block len\nconst XMR_BLOCK_LEN = [0, 2, 3, 5, 6, 7, 9, 10, 11];\n/**\n * base58: XMR version. Check out `base58`.\n * Done in 8-byte blocks (which equals 11 chars in decoding). Last (non-full) block padded with '1' to size in XMR_BLOCK_LEN.\n * Block encoding significantly reduces quadratic complexity of base58.\n */\nconst base58xmr = {\n    encode(data) {\n        let res = '';\n        for (let i = 0; i < data.length; i += 8) {\n            const block = data.subarray(i, i + 8);\n            res += base58.encode(block).padStart(XMR_BLOCK_LEN[block.length], '1');\n        }\n        return res;\n    },\n    decode(str) {\n        let res = [];\n        for (let i = 0; i < str.length; i += 11) {\n            const slice = str.slice(i, i + 11);\n            const blockLen = XMR_BLOCK_LEN.indexOf(slice.length);\n            const block = base58.decode(slice);\n            for (let j = 0; j < block.length - blockLen; j++) {\n                if (block[j] !== 0)\n                    throw new Error('base58xmr: wrong padding');\n            }\n            res = res.concat(Array.from(block.slice(block.length - blockLen)));\n        }\n        return Uint8Array.from(res);\n    },\n};\n/**\n * Method, which creates base58check encoder.\n * Requires function, calculating sha256.\n */\nconst createBase58check = (sha256) => chain(checksum(4, (data) => sha256(sha256(data))), base58);\n/**\n * Use `createBase58check` instead.\n * @deprecated\n */\nconst base58check = createBase58check;\nconst BECH_ALPHABET = chain(alphabet('qpzry9x8gf2tvdw0s3jn54khce6mua7l'), join(''));\nconst POLYMOD_GENERATORS = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3];\nfunction bech32Polymod(pre) {\n    const b = pre >> 25;\n    let chk = (pre & 0x1ffffff) << 5;\n    for (let i = 0; i < POLYMOD_GENERATORS.length; i++) {\n        if (((b >> i) & 1) === 1)\n            chk ^= POLYMOD_GENERATORS[i];\n    }\n    return chk;\n}\nfunction bechChecksum(prefix, words, encodingConst = 1) {\n    const len = prefix.length;\n    let chk = 1;\n    for (let i = 0; i < len; i++) {\n        const c = prefix.charCodeAt(i);\n        if (c < 33 || c > 126)\n            throw new Error(`Invalid prefix (${prefix})`);\n        chk = bech32Polymod(chk) ^ (c >> 5);\n    }\n    chk = bech32Polymod(chk);\n    for (let i = 0; i < len; i++)\n        chk = bech32Polymod(chk) ^ (prefix.charCodeAt(i) & 0x1f);\n    for (let v of words)\n        chk = bech32Polymod(chk) ^ v;\n    for (let i = 0; i < 6; i++)\n        chk = bech32Polymod(chk);\n    chk ^= encodingConst;\n    return BECH_ALPHABET.encode(convertRadix2([chk % powers[30]], 30, 5, false));\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction genBech32(encoding) {\n    const ENCODING_CONST = encoding === 'bech32' ? 1 : 0x2bc830a3;\n    const _words = radix2(5);\n    const fromWords = _words.decode;\n    const toWords = _words.encode;\n    const fromWordsUnsafe = unsafeWrapper(fromWords);\n    function encode(prefix, words, limit = 90) {\n        astr('bech32.encode prefix', prefix);\n        if (isBytes(words))\n            words = Array.from(words);\n        anumArr('bech32.encode', words);\n        const plen = prefix.length;\n        if (plen === 0)\n            throw new TypeError(`Invalid prefix length ${plen}`);\n        const actualLength = plen + 7 + words.length;\n        if (limit !== false && actualLength > limit)\n            throw new TypeError(`Length ${actualLength} exceeds limit ${limit}`);\n        const lowered = prefix.toLowerCase();\n        const sum = bechChecksum(lowered, words, ENCODING_CONST);\n        return `${lowered}1${BECH_ALPHABET.encode(words)}${sum}`;\n    }\n    function decode(str, limit = 90) {\n        astr('bech32.decode input', str);\n        const slen = str.length;\n        if (slen < 8 || (limit !== false && slen > limit))\n            throw new TypeError(`invalid string length: ${slen} (${str}). Expected (8..${limit})`);\n        // don't allow mixed case\n        const lowered = str.toLowerCase();\n        if (str !== lowered && str !== str.toUpperCase())\n            throw new Error(`String must be lowercase or uppercase`);\n        const sepIndex = lowered.lastIndexOf('1');\n        if (sepIndex === 0 || sepIndex === -1)\n            throw new Error(`Letter \"1\" must be present between prefix and data only`);\n        const prefix = lowered.slice(0, sepIndex);\n        const data = lowered.slice(sepIndex + 1);\n        if (data.length < 6)\n            throw new Error('Data must be at least 6 characters long');\n        const words = BECH_ALPHABET.decode(data).slice(0, -6);\n        const sum = bechChecksum(prefix, words, ENCODING_CONST);\n        if (!data.endsWith(sum))\n            throw new Error(`Invalid checksum in ${str}: expected \"${sum}\"`);\n        return { prefix, words };\n    }\n    const decodeUnsafe = unsafeWrapper(decode);\n    function decodeToBytes(str) {\n        const { prefix, words } = decode(str, false);\n        return { prefix, words, bytes: fromWords(words) };\n    }\n    function encodeFromBytes(prefix, bytes) {\n        return encode(prefix, toWords(bytes));\n    }\n    return {\n        encode,\n        decode,\n        encodeFromBytes,\n        decodeToBytes,\n        decodeUnsafe,\n        fromWords,\n        fromWordsUnsafe,\n        toWords,\n    };\n}\n/**\n * bech32 from BIP 173. Operates on words.\n * For high-level, check out scure-btc-signer:\n * https://github.com/paulmillr/scure-btc-signer.\n */\nconst bech32 = genBech32('bech32');\n/**\n * bech32m from BIP 350. Operates on words.\n * It was to mitigate `bech32` weaknesses.\n * For high-level, check out scure-btc-signer:\n * https://github.com/paulmillr/scure-btc-signer.\n */\nconst bech32m = genBech32('bech32m');\n/**\n * UTF-8-to-byte decoder. Uses built-in TextDecoder / TextEncoder.\n * @example\n * ```js\n * const b = utf8.decode(\"hey\"); // => new Uint8Array([ 104, 101, 121 ])\n * const str = utf8.encode(b); // \"hey\"\n * ```\n */\nconst utf8 = {\n    encode: (data) => new TextDecoder().decode(data),\n    decode: (str) => new TextEncoder().encode(str),\n};\n// Built-in hex conversion https://caniuse.com/mdn-javascript_builtins_uint8array_fromhex\n// prettier-ignore\nconst hasHexBuiltin = /* @__PURE__ */ (() => typeof Uint8Array.from([]).toHex === 'function' &&\n    typeof Uint8Array.fromHex === 'function')();\n// prettier-ignore\nconst hexBuiltin = {\n    encode(data) { abytes(data); return data.toHex(); },\n    decode(s) { astr('hex', s); return Uint8Array.fromHex(s); },\n};\n/**\n * hex string decoder. Uses built-in function, when available.\n * @example\n * ```js\n * const b = hex.decode(\"0102ff\"); // => new Uint8Array([ 1, 2, 255 ])\n * const str = hex.encode(b); // \"0102ff\"\n * ```\n */\nconst hex = hasHexBuiltin\n    ? hexBuiltin\n    : chain(radix2(4), alphabet('0123456789abcdef'), join(''), normalize((s) => {\n        if (typeof s !== 'string' || s.length % 2 !== 0)\n            throw new TypeError(`hex.decode: expected string, got ${typeof s} with length ${s.length}`);\n        return s.toLowerCase();\n    }));\n// prettier-ignore\nconst CODERS = {\n    utf8, hex, base16, base32, base64, base64url, base58, base58xmr\n};\nconst coderTypeError = 'Invalid encoding type. Available types: utf8, hex, base16, base32, base64, base64url, base58, base58xmr';\n/** @deprecated */\nconst bytesToString = (type, bytes) => {\n    if (typeof type !== 'string' || !CODERS.hasOwnProperty(type))\n        throw new TypeError(coderTypeError);\n    if (!isBytes(bytes))\n        throw new TypeError('bytesToString() expects Uint8Array');\n    return CODERS[type].encode(bytes);\n};\n/** @deprecated */\nconst str = bytesToString; // as in python, but for bytes only\n/** @deprecated */\nconst stringToBytes = (type, str) => {\n    if (!CODERS.hasOwnProperty(type))\n        throw new TypeError(coderTypeError);\n    if (typeof str !== 'string')\n        throw new TypeError('stringToBytes() expects string');\n    return CODERS[type].decode(str);\n};\n/** @deprecated */\nconst bytes = stringToBytes;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2RpZC1qd3Qvbm9kZV9tb2R1bGVzL0BzY3VyZS9iYXNlL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixNQUFNO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLEVBQUU7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsTUFBTTtBQUNqQztBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsTUFBTTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0ZBQXNGLEVBQUUsY0FBYyxRQUFRO0FBQzlHO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsT0FBTyxjQUFjLFFBQVE7QUFDckY7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG1DQUFtQztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsS0FBSztBQUMzRDtBQUNBLG9EQUFvRCxHQUFHO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsRUFBRTtBQUNsRDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixVQUFVO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNDQUFzQztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELEtBQUs7QUFDMUQ7QUFDQSxtREFBbUQsR0FBRztBQUN0RDtBQUNBLDhEQUE4RCxNQUFNLEtBQUssSUFBSSxZQUFZLHNCQUFzQjtBQUMvRztBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSxHQUFHLE9BQU8sS0FBSztBQUMvRTtBQUNBO0FBQ0EsaUVBQWlFLEtBQUssT0FBTyxLQUFLO0FBQ2xGO0FBQ0EsZUFBZSxXQUFXO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsTUFBTTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsU0FBUztBQUNyQztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyx1Q0FBdUM7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sMkJBQTJCO0FBQ2xDO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AiLCJzb3VyY2VzIjpbIi9ob21lL2JhcmIvYWEvQXNzb2NpYXRlZEFjY291bnRzL25vZGVfbW9kdWxlcy9kaWQtand0L25vZGVfbW9kdWxlcy9Ac2N1cmUvYmFzZS9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgc2N1cmUtYmFzZSAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuZnVuY3Rpb24gaXNCeXRlcyhhKSB7XG4gICAgcmV0dXJuIGEgaW5zdGFuY2VvZiBVaW50OEFycmF5IHx8IChBcnJheUJ1ZmZlci5pc1ZpZXcoYSkgJiYgYS5jb25zdHJ1Y3Rvci5uYW1lID09PSAnVWludDhBcnJheScpO1xufVxuLyoqIEFzc2VydHMgc29tZXRoaW5nIGlzIFVpbnQ4QXJyYXkuICovXG5mdW5jdGlvbiBhYnl0ZXMoYikge1xuICAgIGlmICghaXNCeXRlcyhiKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVaW50OEFycmF5IGV4cGVjdGVkJyk7XG59XG5mdW5jdGlvbiBpc0FycmF5T2YoaXNTdHJpbmcsIGFycikge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShhcnIpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGFyci5sZW5ndGggPT09IDApXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGlmIChpc1N0cmluZykge1xuICAgICAgICByZXR1cm4gYXJyLmV2ZXJ5KChpdGVtKSA9PiB0eXBlb2YgaXRlbSA9PT0gJ3N0cmluZycpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGFyci5ldmVyeSgoaXRlbSkgPT4gTnVtYmVyLmlzU2FmZUludGVnZXIoaXRlbSkpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGFmbihpbnB1dCkge1xuICAgIGlmICh0eXBlb2YgaW5wdXQgIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZnVuY3Rpb24gZXhwZWN0ZWQnKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGFzdHIobGFiZWwsIGlucHV0KSB7XG4gICAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtsYWJlbH06IHN0cmluZyBleHBlY3RlZGApO1xuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gYW51bWJlcihuKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihuKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGludGVnZXI6ICR7bn1gKTtcbn1cbmZ1bmN0aW9uIGFBcnIoaW5wdXQpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoaW5wdXQpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FycmF5IGV4cGVjdGVkJyk7XG59XG5mdW5jdGlvbiBhc3RyQXJyKGxhYmVsLCBpbnB1dCkge1xuICAgIGlmICghaXNBcnJheU9mKHRydWUsIGlucHV0KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2xhYmVsfTogYXJyYXkgb2Ygc3RyaW5ncyBleHBlY3RlZGApO1xufVxuZnVuY3Rpb24gYW51bUFycihsYWJlbCwgaW5wdXQpIHtcbiAgICBpZiAoIWlzQXJyYXlPZihmYWxzZSwgaW5wdXQpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7bGFiZWx9OiBhcnJheSBvZiBudW1iZXJzIGV4cGVjdGVkYCk7XG59XG4vKipcbiAqIEBfX05PX1NJREVfRUZGRUNUU19fXG4gKi9cbmZ1bmN0aW9uIGNoYWluKC4uLmFyZ3MpIHtcbiAgICBjb25zdCBpZCA9IChhKSA9PiBhO1xuICAgIC8vIFdyYXAgY2FsbCBpbiBjbG9zdXJlIHNvIEpJVCBjYW4gaW5saW5lIGNhbGxzXG4gICAgY29uc3Qgd3JhcCA9IChhLCBiKSA9PiAoYykgPT4gYShiKGMpKTtcbiAgICAvLyBDb25zdHJ1Y3QgY2hhaW4gb2YgYXJnc1stMV0uZW5jb2RlKGFyZ3NbLTJdLmVuY29kZShbLi4uXSkpXG4gICAgY29uc3QgZW5jb2RlID0gYXJncy5tYXAoKHgpID0+IHguZW5jb2RlKS5yZWR1Y2VSaWdodCh3cmFwLCBpZCk7XG4gICAgLy8gQ29uc3RydWN0IGNoYWluIG9mIGFyZ3NbMF0uZGVjb2RlKGFyZ3NbMV0uZGVjb2RlKC4uLikpXG4gICAgY29uc3QgZGVjb2RlID0gYXJncy5tYXAoKHgpID0+IHguZGVjb2RlKS5yZWR1Y2Uod3JhcCwgaWQpO1xuICAgIHJldHVybiB7IGVuY29kZSwgZGVjb2RlIH07XG59XG4vKipcbiAqIEVuY29kZXMgaW50ZWdlciByYWRpeCByZXByZXNlbnRhdGlvbiB0byBhcnJheSBvZiBzdHJpbmdzIHVzaW5nIGFscGhhYmV0IGFuZCBiYWNrLlxuICogQ291bGQgYWxzbyBiZSBhcnJheSBvZiBzdHJpbmdzLlxuICogQF9fTk9fU0lERV9FRkZFQ1RTX19cbiAqL1xuZnVuY3Rpb24gYWxwaGFiZXQobGV0dGVycykge1xuICAgIC8vIG1hcHBpbmcgMSB0byBcImJcIlxuICAgIGNvbnN0IGxldHRlcnNBID0gdHlwZW9mIGxldHRlcnMgPT09ICdzdHJpbmcnID8gbGV0dGVycy5zcGxpdCgnJykgOiBsZXR0ZXJzO1xuICAgIGNvbnN0IGxlbiA9IGxldHRlcnNBLmxlbmd0aDtcbiAgICBhc3RyQXJyKCdhbHBoYWJldCcsIGxldHRlcnNBKTtcbiAgICAvLyBtYXBwaW5nIFwiYlwiIHRvIDFcbiAgICBjb25zdCBpbmRleGVzID0gbmV3IE1hcChsZXR0ZXJzQS5tYXAoKGwsIGkpID0+IFtsLCBpXSkpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGVuY29kZTogKGRpZ2l0cykgPT4ge1xuICAgICAgICAgICAgYUFycihkaWdpdHMpO1xuICAgICAgICAgICAgcmV0dXJuIGRpZ2l0cy5tYXAoKGkpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKGkpIHx8IGkgPCAwIHx8IGkgPj0gbGVuKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGFscGhhYmV0LmVuY29kZTogZGlnaXQgaW5kZXggb3V0c2lkZSBhbHBoYWJldCBcIiR7aX1cIi4gQWxsb3dlZDogJHtsZXR0ZXJzfWApO1xuICAgICAgICAgICAgICAgIHJldHVybiBsZXR0ZXJzQVtpXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBkZWNvZGU6IChpbnB1dCkgPT4ge1xuICAgICAgICAgICAgYUFycihpbnB1dCk7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQubWFwKChsZXR0ZXIpID0+IHtcbiAgICAgICAgICAgICAgICBhc3RyKCdhbHBoYWJldC5kZWNvZGUnLCBsZXR0ZXIpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGkgPSBpbmRleGVzLmdldChsZXR0ZXIpO1xuICAgICAgICAgICAgICAgIGlmIChpID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBsZXR0ZXI6IFwiJHtsZXR0ZXJ9XCIuIEFsbG93ZWQ6ICR7bGV0dGVyc31gKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgIH07XG59XG4vKipcbiAqIEBfX05PX1NJREVfRUZGRUNUU19fXG4gKi9cbmZ1bmN0aW9uIGpvaW4oc2VwYXJhdG9yID0gJycpIHtcbiAgICBhc3RyKCdqb2luJywgc2VwYXJhdG9yKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBlbmNvZGU6IChmcm9tKSA9PiB7XG4gICAgICAgICAgICBhc3RyQXJyKCdqb2luLmRlY29kZScsIGZyb20pO1xuICAgICAgICAgICAgcmV0dXJuIGZyb20uam9pbihzZXBhcmF0b3IpO1xuICAgICAgICB9LFxuICAgICAgICBkZWNvZGU6ICh0bykgPT4ge1xuICAgICAgICAgICAgYXN0cignam9pbi5kZWNvZGUnLCB0byk7XG4gICAgICAgICAgICByZXR1cm4gdG8uc3BsaXQoc2VwYXJhdG9yKTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuLyoqXG4gKiBQYWQgc3RyaW5ncyBhcnJheSBzbyBpdCBoYXMgaW50ZWdlciBudW1iZXIgb2YgYml0c1xuICogQF9fTk9fU0lERV9FRkZFQ1RTX19cbiAqL1xuZnVuY3Rpb24gcGFkZGluZyhiaXRzLCBjaHIgPSAnPScpIHtcbiAgICBhbnVtYmVyKGJpdHMpO1xuICAgIGFzdHIoJ3BhZGRpbmcnLCBjaHIpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGVuY29kZShkYXRhKSB7XG4gICAgICAgICAgICBhc3RyQXJyKCdwYWRkaW5nLmVuY29kZScsIGRhdGEpO1xuICAgICAgICAgICAgd2hpbGUgKChkYXRhLmxlbmd0aCAqIGJpdHMpICUgOClcbiAgICAgICAgICAgICAgICBkYXRhLnB1c2goY2hyKTtcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9LFxuICAgICAgICBkZWNvZGUoaW5wdXQpIHtcbiAgICAgICAgICAgIGFzdHJBcnIoJ3BhZGRpbmcuZGVjb2RlJywgaW5wdXQpO1xuICAgICAgICAgICAgbGV0IGVuZCA9IGlucHV0Lmxlbmd0aDtcbiAgICAgICAgICAgIGlmICgoZW5kICogYml0cykgJSA4KVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncGFkZGluZzogaW52YWxpZCwgc3RyaW5nIHNob3VsZCBoYXZlIHdob2xlIG51bWJlciBvZiBieXRlcycpO1xuICAgICAgICAgICAgZm9yICg7IGVuZCA+IDAgJiYgaW5wdXRbZW5kIC0gMV0gPT09IGNocjsgZW5kLS0pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsYXN0ID0gZW5kIC0gMTtcbiAgICAgICAgICAgICAgICBjb25zdCBieXRlID0gbGFzdCAqIGJpdHM7XG4gICAgICAgICAgICAgICAgaWYgKGJ5dGUgJSA4ID09PSAwKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BhZGRpbmc6IGludmFsaWQsIHN0cmluZyBoYXMgdG9vIG11Y2ggcGFkZGluZycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGlucHV0LnNsaWNlKDAsIGVuZCk7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbi8qKlxuICogQF9fTk9fU0lERV9FRkZFQ1RTX19cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplKGZuKSB7XG4gICAgYWZuKGZuKTtcbiAgICByZXR1cm4geyBlbmNvZGU6IChmcm9tKSA9PiBmcm9tLCBkZWNvZGU6ICh0bykgPT4gZm4odG8pIH07XG59XG4vKipcbiAqIFNsb3c6IE8obl4yKSB0aW1lIGNvbXBsZXhpdHlcbiAqL1xuZnVuY3Rpb24gY29udmVydFJhZGl4KGRhdGEsIGZyb20sIHRvKSB7XG4gICAgLy8gYmFzZSAxIGlzIGltcG9zc2libGVcbiAgICBpZiAoZnJvbSA8IDIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgY29udmVydFJhZGl4OiBpbnZhbGlkIGZyb209JHtmcm9tfSwgYmFzZSBjYW5ub3QgYmUgbGVzcyB0aGFuIDJgKTtcbiAgICBpZiAodG8gPCAyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNvbnZlcnRSYWRpeDogaW52YWxpZCB0bz0ke3RvfSwgYmFzZSBjYW5ub3QgYmUgbGVzcyB0aGFuIDJgKTtcbiAgICBhQXJyKGRhdGEpO1xuICAgIGlmICghZGF0YS5sZW5ndGgpXG4gICAgICAgIHJldHVybiBbXTtcbiAgICBsZXQgcG9zID0gMDtcbiAgICBjb25zdCByZXMgPSBbXTtcbiAgICBjb25zdCBkaWdpdHMgPSBBcnJheS5mcm9tKGRhdGEsIChkKSA9PiB7XG4gICAgICAgIGFudW1iZXIoZCk7XG4gICAgICAgIGlmIChkIDwgMCB8fCBkID49IGZyb20pXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgaW50ZWdlcjogJHtkfWApO1xuICAgICAgICByZXR1cm4gZDtcbiAgICB9KTtcbiAgICBjb25zdCBkbGVuID0gZGlnaXRzLmxlbmd0aDtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBsZXQgY2FycnkgPSAwO1xuICAgICAgICBsZXQgZG9uZSA9IHRydWU7XG4gICAgICAgIGZvciAobGV0IGkgPSBwb3M7IGkgPCBkbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGRpZ2l0ID0gZGlnaXRzW2ldO1xuICAgICAgICAgICAgY29uc3QgZnJvbUNhcnJ5ID0gZnJvbSAqIGNhcnJ5O1xuICAgICAgICAgICAgY29uc3QgZGlnaXRCYXNlID0gZnJvbUNhcnJ5ICsgZGlnaXQ7XG4gICAgICAgICAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKGRpZ2l0QmFzZSkgfHxcbiAgICAgICAgICAgICAgICBmcm9tQ2FycnkgLyBmcm9tICE9PSBjYXJyeSB8fFxuICAgICAgICAgICAgICAgIGRpZ2l0QmFzZSAtIGRpZ2l0ICE9PSBmcm9tQ2FycnkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvbnZlcnRSYWRpeDogY2Fycnkgb3ZlcmZsb3cnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGRpdiA9IGRpZ2l0QmFzZSAvIHRvO1xuICAgICAgICAgICAgY2FycnkgPSBkaWdpdEJhc2UgJSB0bztcbiAgICAgICAgICAgIGNvbnN0IHJvdW5kZWQgPSBNYXRoLmZsb29yKGRpdik7XG4gICAgICAgICAgICBkaWdpdHNbaV0gPSByb3VuZGVkO1xuICAgICAgICAgICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihyb3VuZGVkKSB8fCByb3VuZGVkICogdG8gKyBjYXJyeSAhPT0gZGlnaXRCYXNlKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY29udmVydFJhZGl4OiBjYXJyeSBvdmVyZmxvdycpO1xuICAgICAgICAgICAgaWYgKCFkb25lKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgZWxzZSBpZiAoIXJvdW5kZWQpXG4gICAgICAgICAgICAgICAgcG9zID0gaTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBkb25lID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmVzLnB1c2goY2FycnkpO1xuICAgICAgICBpZiAoZG9uZSlcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoIC0gMSAmJiBkYXRhW2ldID09PSAwOyBpKyspXG4gICAgICAgIHJlcy5wdXNoKDApO1xuICAgIHJldHVybiByZXMucmV2ZXJzZSgpO1xufVxuY29uc3QgZ2NkID0gKGEsIGIpID0+IChiID09PSAwID8gYSA6IGdjZChiLCBhICUgYikpO1xuY29uc3QgcmFkaXgyY2FycnkgPSAvKiBAX19OT19TSURFX0VGRkVDVFNfXyAqLyAoZnJvbSwgdG8pID0+IGZyb20gKyAodG8gLSBnY2QoZnJvbSwgdG8pKTtcbmNvbnN0IHBvd2VycyA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4ge1xuICAgIGxldCByZXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDQwOyBpKyspXG4gICAgICAgIHJlcy5wdXNoKDIgKiogaSk7XG4gICAgcmV0dXJuIHJlcztcbn0pKCk7XG4vKipcbiAqIEltcGxlbWVudGVkIHdpdGggbnVtYmVycywgYmVjYXVzZSBCaWdJbnQgaXMgNXggc2xvd2VyXG4gKi9cbmZ1bmN0aW9uIGNvbnZlcnRSYWRpeDIoZGF0YSwgZnJvbSwgdG8sIHBhZGRpbmcpIHtcbiAgICBhQXJyKGRhdGEpO1xuICAgIGlmIChmcm9tIDw9IDAgfHwgZnJvbSA+IDMyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNvbnZlcnRSYWRpeDI6IHdyb25nIGZyb209JHtmcm9tfWApO1xuICAgIGlmICh0byA8PSAwIHx8IHRvID4gMzIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgY29udmVydFJhZGl4Mjogd3JvbmcgdG89JHt0b31gKTtcbiAgICBpZiAocmFkaXgyY2FycnkoZnJvbSwgdG8pID4gMzIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjb252ZXJ0UmFkaXgyOiBjYXJyeSBvdmVyZmxvdyBmcm9tPSR7ZnJvbX0gdG89JHt0b30gY2FycnlCaXRzPSR7cmFkaXgyY2FycnkoZnJvbSwgdG8pfWApO1xuICAgIH1cbiAgICBsZXQgY2FycnkgPSAwO1xuICAgIGxldCBwb3MgPSAwOyAvLyBiaXR3aXNlIHBvc2l0aW9uIGluIGN1cnJlbnQgZWxlbWVudFxuICAgIGNvbnN0IG1heCA9IHBvd2Vyc1tmcm9tXTtcbiAgICBjb25zdCBtYXNrID0gcG93ZXJzW3RvXSAtIDE7XG4gICAgY29uc3QgcmVzID0gW107XG4gICAgZm9yIChjb25zdCBuIG9mIGRhdGEpIHtcbiAgICAgICAgYW51bWJlcihuKTtcbiAgICAgICAgaWYgKG4gPj0gbWF4KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjb252ZXJ0UmFkaXgyOiBpbnZhbGlkIGRhdGEgd29yZD0ke259IGZyb209JHtmcm9tfWApO1xuICAgICAgICBjYXJyeSA9IChjYXJyeSA8PCBmcm9tKSB8IG47XG4gICAgICAgIGlmIChwb3MgKyBmcm9tID4gMzIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNvbnZlcnRSYWRpeDI6IGNhcnJ5IG92ZXJmbG93IHBvcz0ke3Bvc30gZnJvbT0ke2Zyb219YCk7XG4gICAgICAgIHBvcyArPSBmcm9tO1xuICAgICAgICBmb3IgKDsgcG9zID49IHRvOyBwb3MgLT0gdG8pXG4gICAgICAgICAgICByZXMucHVzaCgoKGNhcnJ5ID4+IChwb3MgLSB0bykpICYgbWFzaykgPj4+IDApO1xuICAgICAgICBjb25zdCBwb3cgPSBwb3dlcnNbcG9zXTtcbiAgICAgICAgaWYgKHBvdyA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGNhcnJ5Jyk7XG4gICAgICAgIGNhcnJ5ICY9IHBvdyAtIDE7IC8vIGNsZWFuIGNhcnJ5LCBvdGhlcndpc2UgaXQgd2lsbCBjYXVzZSBvdmVyZmxvd1xuICAgIH1cbiAgICBjYXJyeSA9IChjYXJyeSA8PCAodG8gLSBwb3MpKSAmIG1hc2s7XG4gICAgaWYgKCFwYWRkaW5nICYmIHBvcyA+PSBmcm9tKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4Y2VzcyBwYWRkaW5nJyk7XG4gICAgaWYgKCFwYWRkaW5nICYmIGNhcnJ5ID4gMClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBOb24temVybyBwYWRkaW5nOiAke2NhcnJ5fWApO1xuICAgIGlmIChwYWRkaW5nICYmIHBvcyA+IDApXG4gICAgICAgIHJlcy5wdXNoKGNhcnJ5ID4+PiAwKTtcbiAgICByZXR1cm4gcmVzO1xufVxuLyoqXG4gKiBAX19OT19TSURFX0VGRkVDVFNfX1xuICovXG5mdW5jdGlvbiByYWRpeChudW0pIHtcbiAgICBhbnVtYmVyKG51bSk7XG4gICAgY29uc3QgXzI1NiA9IDIgKiogODtcbiAgICByZXR1cm4ge1xuICAgICAgICBlbmNvZGU6IChieXRlcykgPT4ge1xuICAgICAgICAgICAgaWYgKCFpc0J5dGVzKGJ5dGVzKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JhZGl4LmVuY29kZSBpbnB1dCBzaG91bGQgYmUgVWludDhBcnJheScpO1xuICAgICAgICAgICAgcmV0dXJuIGNvbnZlcnRSYWRpeChBcnJheS5mcm9tKGJ5dGVzKSwgXzI1NiwgbnVtKTtcbiAgICAgICAgfSxcbiAgICAgICAgZGVjb2RlOiAoZGlnaXRzKSA9PiB7XG4gICAgICAgICAgICBhbnVtQXJyKCdyYWRpeC5kZWNvZGUnLCBkaWdpdHMpO1xuICAgICAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShjb252ZXJ0UmFkaXgoZGlnaXRzLCBudW0sIF8yNTYpKTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuLyoqXG4gKiBJZiBib3RoIGJhc2VzIGFyZSBwb3dlciBvZiBzYW1lIG51bWJlciAobGlrZSBgMioqOCA8LT4gMioqNjRgKSxcbiAqIHRoZXJlIGlzIGEgbGluZWFyIGFsZ29yaXRobS4gRm9yIG5vdyB3ZSBoYXZlIGltcGxlbWVudGF0aW9uIGZvciBwb3dlci1vZi10d28gYmFzZXMgb25seS5cbiAqIEBfX05PX1NJREVfRUZGRUNUU19fXG4gKi9cbmZ1bmN0aW9uIHJhZGl4MihiaXRzLCByZXZQYWRkaW5nID0gZmFsc2UpIHtcbiAgICBhbnVtYmVyKGJpdHMpO1xuICAgIGlmIChiaXRzIDw9IDAgfHwgYml0cyA+IDMyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JhZGl4MjogYml0cyBzaG91bGQgYmUgaW4gKDAuLjMyXScpO1xuICAgIGlmIChyYWRpeDJjYXJyeSg4LCBiaXRzKSA+IDMyIHx8IHJhZGl4MmNhcnJ5KGJpdHMsIDgpID4gMzIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncmFkaXgyOiBjYXJyeSBvdmVyZmxvdycpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGVuY29kZTogKGJ5dGVzKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWlzQnl0ZXMoYnl0ZXMpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncmFkaXgyLmVuY29kZSBpbnB1dCBzaG91bGQgYmUgVWludDhBcnJheScpO1xuICAgICAgICAgICAgcmV0dXJuIGNvbnZlcnRSYWRpeDIoQXJyYXkuZnJvbShieXRlcyksIDgsIGJpdHMsICFyZXZQYWRkaW5nKTtcbiAgICAgICAgfSxcbiAgICAgICAgZGVjb2RlOiAoZGlnaXRzKSA9PiB7XG4gICAgICAgICAgICBhbnVtQXJyKCdyYWRpeDIuZGVjb2RlJywgZGlnaXRzKTtcbiAgICAgICAgICAgIHJldHVybiBVaW50OEFycmF5LmZyb20oY29udmVydFJhZGl4MihkaWdpdHMsIGJpdHMsIDgsIHJldlBhZGRpbmcpKTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuZnVuY3Rpb24gdW5zYWZlV3JhcHBlcihmbikge1xuICAgIGFmbihmbik7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHsgfVxuICAgIH07XG59XG5mdW5jdGlvbiBjaGVja3N1bShsZW4sIGZuKSB7XG4gICAgYW51bWJlcihsZW4pO1xuICAgIGFmbihmbik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZW5jb2RlKGRhdGEpIHtcbiAgICAgICAgICAgIGlmICghaXNCeXRlcyhkYXRhKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NoZWNrc3VtLmVuY29kZTogaW5wdXQgc2hvdWxkIGJlIFVpbnQ4QXJyYXknKTtcbiAgICAgICAgICAgIGNvbnN0IHN1bSA9IGZuKGRhdGEpLnNsaWNlKDAsIGxlbik7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBuZXcgVWludDhBcnJheShkYXRhLmxlbmd0aCArIGxlbik7XG4gICAgICAgICAgICByZXMuc2V0KGRhdGEpO1xuICAgICAgICAgICAgcmVzLnNldChzdW0sIGRhdGEubGVuZ3RoKTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH0sXG4gICAgICAgIGRlY29kZShkYXRhKSB7XG4gICAgICAgICAgICBpZiAoIWlzQnl0ZXMoZGF0YSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjaGVja3N1bS5kZWNvZGU6IGlucHV0IHNob3VsZCBiZSBVaW50OEFycmF5Jyk7XG4gICAgICAgICAgICBjb25zdCBwYXlsb2FkID0gZGF0YS5zbGljZSgwLCAtbGVuKTtcbiAgICAgICAgICAgIGNvbnN0IG9sZENoZWNrc3VtID0gZGF0YS5zbGljZSgtbGVuKTtcbiAgICAgICAgICAgIGNvbnN0IG5ld0NoZWNrc3VtID0gZm4ocGF5bG9hZCkuc2xpY2UoMCwgbGVuKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspXG4gICAgICAgICAgICAgICAgaWYgKG5ld0NoZWNrc3VtW2ldICE9PSBvbGRDaGVja3N1bVtpXSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNoZWNrc3VtJyk7XG4gICAgICAgICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuLy8gcHJldHRpZXItaWdub3JlXG5leHBvcnQgY29uc3QgdXRpbHMgPSB7XG4gICAgYWxwaGFiZXQsIGNoYWluLCBjaGVja3N1bSwgY29udmVydFJhZGl4LCBjb252ZXJ0UmFkaXgyLCByYWRpeCwgcmFkaXgyLCBqb2luLCBwYWRkaW5nLFxufTtcbi8vIFJGQyA0NjQ4IGFrYSBSRkMgMzU0OFxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vKipcbiAqIGJhc2UxNiBlbmNvZGluZyBmcm9tIFJGQyA0NjQ4LlxuICogQGV4YW1wbGVcbiAqIGBgYGpzXG4gKiBiYXNlMTYuZW5jb2RlKFVpbnQ4QXJyYXkuZnJvbShbMHgxMiwgMHhhYl0pKTtcbiAqIC8vID0+ICcxMkFCJ1xuICogYGBgXG4gKi9cbmV4cG9ydCBjb25zdCBiYXNlMTYgPSBjaGFpbihyYWRpeDIoNCksIGFscGhhYmV0KCcwMTIzNDU2Nzg5QUJDREVGJyksIGpvaW4oJycpKTtcbi8qKlxuICogYmFzZTMyIGVuY29kaW5nIGZyb20gUkZDIDQ2NDguIEhhcyBwYWRkaW5nLlxuICogVXNlIGBiYXNlMzJub3BhZGAgZm9yIHVucGFkZGVkIHZlcnNpb24uXG4gKiBBbHNvIGNoZWNrIG91dCBgYmFzZTMyaGV4YCwgYGJhc2UzMmhleG5vcGFkYCwgYGJhc2UzMmNyb2NrZm9yZGAuXG4gKiBAZXhhbXBsZVxuICogYGBganNcbiAqIGJhc2UzMi5lbmNvZGUoVWludDhBcnJheS5mcm9tKFsweDEyLCAweGFiXSkpO1xuICogLy8gPT4gJ0NLVlE9PT09J1xuICogYmFzZTMyLmRlY29kZSgnQ0tWUT09PT0nKTtcbiAqIC8vID0+IFVpbnQ4QXJyYXkuZnJvbShbMHgxMiwgMHhhYl0pXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNvbnN0IGJhc2UzMiA9IGNoYWluKHJhZGl4Mig1KSwgYWxwaGFiZXQoJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaMjM0NTY3JyksIHBhZGRpbmcoNSksIGpvaW4oJycpKTtcbi8qKlxuICogYmFzZTMyIGVuY29kaW5nIGZyb20gUkZDIDQ2NDguIE5vIHBhZGRpbmcuXG4gKiBVc2UgYGJhc2UzMmAgZm9yIHBhZGRlZCB2ZXJzaW9uLlxuICogQWxzbyBjaGVjayBvdXQgYGJhc2UzMmhleGAsIGBiYXNlMzJoZXhub3BhZGAsIGBiYXNlMzJjcm9ja2ZvcmRgLlxuICogQGV4YW1wbGVcbiAqIGBgYGpzXG4gKiBiYXNlMzJub3BhZC5lbmNvZGUoVWludDhBcnJheS5mcm9tKFsweDEyLCAweGFiXSkpO1xuICogLy8gPT4gJ0NLVlEnXG4gKiBiYXNlMzJub3BhZC5kZWNvZGUoJ0NLVlEnKTtcbiAqIC8vID0+IFVpbnQ4QXJyYXkuZnJvbShbMHgxMiwgMHhhYl0pXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNvbnN0IGJhc2UzMm5vcGFkID0gY2hhaW4ocmFkaXgyKDUpLCBhbHBoYWJldCgnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVoyMzQ1NjcnKSwgam9pbignJykpO1xuLyoqXG4gKiBiYXNlMzIgZW5jb2RpbmcgZnJvbSBSRkMgNDY0OC4gUGFkZGVkLiBDb21wYXJlZCB0byBvcmRpbmFyeSBgYmFzZTMyYCwgc2xpZ2h0bHkgZGlmZmVyZW50IGFscGhhYmV0LlxuICogVXNlIGBiYXNlMzJoZXhub3BhZGAgZm9yIHVucGFkZGVkIHZlcnNpb24uXG4gKiBAZXhhbXBsZVxuICogYGBganNcbiAqIGJhc2UzMmhleC5lbmNvZGUoVWludDhBcnJheS5mcm9tKFsweDEyLCAweGFiXSkpO1xuICogLy8gPT4gJzJBTEc9PT09J1xuICogYmFzZTMyaGV4LmRlY29kZSgnMkFMRz09PT0nKTtcbiAqIC8vID0+IFVpbnQ4QXJyYXkuZnJvbShbMHgxMiwgMHhhYl0pXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNvbnN0IGJhc2UzMmhleCA9IGNoYWluKHJhZGl4Mig1KSwgYWxwaGFiZXQoJzAxMjM0NTY3ODlBQkNERUZHSElKS0xNTk9QUVJTVFVWJyksIHBhZGRpbmcoNSksIGpvaW4oJycpKTtcbi8qKlxuICogYmFzZTMyIGVuY29kaW5nIGZyb20gUkZDIDQ2NDguIE5vIHBhZGRpbmcuIENvbXBhcmVkIHRvIG9yZGluYXJ5IGBiYXNlMzJgLCBzbGlnaHRseSBkaWZmZXJlbnQgYWxwaGFiZXQuXG4gKiBVc2UgYGJhc2UzMmhleGAgZm9yIHBhZGRlZCB2ZXJzaW9uLlxuICogQGV4YW1wbGVcbiAqIGBgYGpzXG4gKiBiYXNlMzJoZXhub3BhZC5lbmNvZGUoVWludDhBcnJheS5mcm9tKFsweDEyLCAweGFiXSkpO1xuICogLy8gPT4gJzJBTEcnXG4gKiBiYXNlMzJoZXhub3BhZC5kZWNvZGUoJzJBTEcnKTtcbiAqIC8vID0+IFVpbnQ4QXJyYXkuZnJvbShbMHgxMiwgMHhhYl0pXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNvbnN0IGJhc2UzMmhleG5vcGFkID0gY2hhaW4ocmFkaXgyKDUpLCBhbHBoYWJldCgnMDEyMzQ1Njc4OUFCQ0RFRkdISUpLTE1OT1BRUlNUVVYnKSwgam9pbignJykpO1xuLyoqXG4gKiBiYXNlMzIgZW5jb2RpbmcgZnJvbSBSRkMgNDY0OC4gRG91ZyBDcm9ja2ZvcmQncyB2ZXJzaW9uLlxuICogaHR0cHM6Ly93d3cuY3JvY2tmb3JkLmNvbS9iYXNlMzIuaHRtbFxuICogQGV4YW1wbGVcbiAqIGBgYGpzXG4gKiBiYXNlMzJjcm9ja2ZvcmQuZW5jb2RlKFVpbnQ4QXJyYXkuZnJvbShbMHgxMiwgMHhhYl0pKTtcbiAqIC8vID0+ICcyQU5HJ1xuICogYmFzZTMyY3JvY2tmb3JkLmRlY29kZSgnMkFORycpO1xuICogLy8gPT4gVWludDhBcnJheS5mcm9tKFsweDEyLCAweGFiXSlcbiAqIGBgYFxuICovXG5leHBvcnQgY29uc3QgYmFzZTMyY3JvY2tmb3JkID0gY2hhaW4ocmFkaXgyKDUpLCBhbHBoYWJldCgnMDEyMzQ1Njc4OUFCQ0RFRkdISktNTlBRUlNUVldYWVonKSwgam9pbignJyksIG5vcm1hbGl6ZSgocykgPT4gcy50b1VwcGVyQ2FzZSgpLnJlcGxhY2UoL08vZywgJzAnKS5yZXBsYWNlKC9bSUxdL2csICcxJykpKTtcbi8vIEJ1aWx0LWluIGJhc2U2NCBjb252ZXJzaW9uIGh0dHBzOi8vY2FuaXVzZS5jb20vbWRuLWphdmFzY3JpcHRfYnVpbHRpbnNfdWludDhhcnJheV9mcm9tYmFzZTY0XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IGhhc0Jhc2U2NEJ1aWx0aW4gPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IHR5cGVvZiBVaW50OEFycmF5LmZyb20oW10pLnRvQmFzZTY0ID09PSAnZnVuY3Rpb24nICYmXG4gICAgdHlwZW9mIFVpbnQ4QXJyYXkuZnJvbUJhc2U2NCA9PT0gJ2Z1bmN0aW9uJykoKTtcbmNvbnN0IGRlY29kZUJhc2U2NEJ1aWx0aW4gPSAocywgaXNVcmwpID0+IHtcbiAgICBhc3RyKCdiYXNlNjQnLCBzKTtcbiAgICBjb25zdCByZSA9IGlzVXJsID8gL15bQS1aYS16MC05PV8tXSskLyA6IC9eW0EtWmEtejAtOT0rL10rJC87XG4gICAgY29uc3QgYWxwaGFiZXQgPSBpc1VybCA/ICdiYXNlNjR1cmwnIDogJ2Jhc2U2NCc7XG4gICAgaWYgKHMubGVuZ3RoID4gMCAmJiAhcmUudGVzdChzKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGJhc2U2NCcpO1xuICAgIHJldHVybiBVaW50OEFycmF5LmZyb21CYXNlNjQocywgeyBhbHBoYWJldCwgbGFzdENodW5rSGFuZGxpbmc6ICdzdHJpY3QnIH0pO1xufTtcbi8qKlxuICogYmFzZTY0IGZyb20gUkZDIDQ2NDguIFBhZGRlZC5cbiAqIFVzZSBgYmFzZTY0bm9wYWRgIGZvciB1bnBhZGRlZCB2ZXJzaW9uLlxuICogQWxzbyBjaGVjayBvdXQgYGJhc2U2NHVybGAsIGBiYXNlNjR1cmxub3BhZGAuXG4gKiBGYWxscyBiYWNrIHRvIGJ1aWx0LWluIGZ1bmN0aW9uLCB3aGVuIGF2YWlsYWJsZS5cbiAqIEBleGFtcGxlXG4gKiBgYGBqc1xuICogYmFzZTY0LmVuY29kZShVaW50OEFycmF5LmZyb20oWzB4MTIsIDB4YWJdKSk7XG4gKiAvLyA9PiAnRXFzPSdcbiAqIGJhc2U2NC5kZWNvZGUoJ0Vxcz0nKTtcbiAqIC8vID0+IFVpbnQ4QXJyYXkuZnJvbShbMHgxMiwgMHhhYl0pXG4gKiBgYGBcbiAqL1xuLy8gcHJldHRpZXItaWdub3JlXG5leHBvcnQgY29uc3QgYmFzZTY0ID0gaGFzQmFzZTY0QnVpbHRpbiA/IHtcbiAgICBlbmNvZGUoYikgeyBhYnl0ZXMoYik7IHJldHVybiBiLnRvQmFzZTY0KCk7IH0sXG4gICAgZGVjb2RlKHMpIHsgcmV0dXJuIGRlY29kZUJhc2U2NEJ1aWx0aW4ocywgZmFsc2UpOyB9LFxufSA6IGNoYWluKHJhZGl4Mig2KSwgYWxwaGFiZXQoJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nKSwgcGFkZGluZyg2KSwgam9pbignJykpO1xuLyoqXG4gKiBiYXNlNjQgZnJvbSBSRkMgNDY0OC4gTm8gcGFkZGluZy5cbiAqIFVzZSBgYmFzZTY0YCBmb3IgcGFkZGVkIHZlcnNpb24uXG4gKiBAZXhhbXBsZVxuICogYGBganNcbiAqIGJhc2U2NG5vcGFkLmVuY29kZShVaW50OEFycmF5LmZyb20oWzB4MTIsIDB4YWJdKSk7XG4gKiAvLyA9PiAnRXFzJ1xuICogYmFzZTY0bm9wYWQuZGVjb2RlKCdFcXMnKTtcbiAqIC8vID0+IFVpbnQ4QXJyYXkuZnJvbShbMHgxMiwgMHhhYl0pXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNvbnN0IGJhc2U2NG5vcGFkID0gY2hhaW4ocmFkaXgyKDYpLCBhbHBoYWJldCgnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLycpLCBqb2luKCcnKSk7XG4vKipcbiAqIGJhc2U2NCBmcm9tIFJGQyA0NjQ4LCB1c2luZyBVUkwtc2FmZSBhbHBoYWJldC4gUGFkZGVkLlxuICogVXNlIGBiYXNlNjR1cmxub3BhZGAgZm9yIHVucGFkZGVkIHZlcnNpb24uXG4gKiBGYWxscyBiYWNrIHRvIGJ1aWx0LWluIGZ1bmN0aW9uLCB3aGVuIGF2YWlsYWJsZS5cbiAqIEBleGFtcGxlXG4gKiBgYGBqc1xuICogYmFzZTY0dXJsLmVuY29kZShVaW50OEFycmF5LmZyb20oWzB4MTIsIDB4YWJdKSk7XG4gKiAvLyA9PiAnRXFzPSdcbiAqIGJhc2U2NHVybC5kZWNvZGUoJ0Vxcz0nKTtcbiAqIC8vID0+IFVpbnQ4QXJyYXkuZnJvbShbMHgxMiwgMHhhYl0pXG4gKiBgYGBcbiAqL1xuLy8gcHJldHRpZXItaWdub3JlXG5leHBvcnQgY29uc3QgYmFzZTY0dXJsID0gaGFzQmFzZTY0QnVpbHRpbiA/IHtcbiAgICBlbmNvZGUoYikgeyBhYnl0ZXMoYik7IHJldHVybiBiLnRvQmFzZTY0KHsgYWxwaGFiZXQ6ICdiYXNlNjR1cmwnIH0pOyB9LFxuICAgIGRlY29kZShzKSB7IHJldHVybiBkZWNvZGVCYXNlNjRCdWlsdGluKHMsIHRydWUpOyB9LFxufSA6IGNoYWluKHJhZGl4Mig2KSwgYWxwaGFiZXQoJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5LV8nKSwgcGFkZGluZyg2KSwgam9pbignJykpO1xuLyoqXG4gKiBiYXNlNjQgZnJvbSBSRkMgNDY0OCwgdXNpbmcgVVJMLXNhZmUgYWxwaGFiZXQuIE5vIHBhZGRpbmcuXG4gKiBVc2UgYGJhc2U2NHVybGAgZm9yIHBhZGRlZCB2ZXJzaW9uLlxuICogQGV4YW1wbGVcbiAqIGBgYGpzXG4gKiBiYXNlNjR1cmxub3BhZC5lbmNvZGUoVWludDhBcnJheS5mcm9tKFsweDEyLCAweGFiXSkpO1xuICogLy8gPT4gJ0VxcydcbiAqIGJhc2U2NHVybG5vcGFkLmRlY29kZSgnRXFzJyk7XG4gKiAvLyA9PiBVaW50OEFycmF5LmZyb20oWzB4MTIsIDB4YWJdKVxuICogYGBgXG4gKi9cbmV4cG9ydCBjb25zdCBiYXNlNjR1cmxub3BhZCA9IGNoYWluKHJhZGl4Mig2KSwgYWxwaGFiZXQoJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5LV8nKSwgam9pbignJykpO1xuLy8gYmFzZTU4IGNvZGVcbi8vIC0tLS0tLS0tLS0tXG5jb25zdCBnZW5CYXNlNTggPSAvKiBAX19OT19TSURFX0VGRkVDVFNfXyAqLyAoYWJjKSA9PiBjaGFpbihyYWRpeCg1OCksIGFscGhhYmV0KGFiYyksIGpvaW4oJycpKTtcbi8qKlxuICogYmFzZTU4OiBiYXNlNjQgd2l0aG91dCBhbWJpZ291cyBjaGFyYWN0ZXJzICssIC8sIDAsIE8sIEksIGwuXG4gKiBRdWFkcmF0aWMgKE8obl4yKSkgLSBzbywgY2FuJ3QgYmUgdXNlZCBvbiBsYXJnZSBpbnB1dHMuXG4gKiBAZXhhbXBsZVxuICogYGBganNcbiAqIGJhc2U1OC5kZWNvZGUoJzAxYWJjZGVmJyk7XG4gKiAvLyA9PiAnM1VoSlcnXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNvbnN0IGJhc2U1OCA9IGdlbkJhc2U1OCgnMTIzNDU2Nzg5QUJDREVGR0hKS0xNTlBRUlNUVVZXWFlaYWJjZGVmZ2hpamttbm9wcXJzdHV2d3h5eicpO1xuLyoqXG4gKiBiYXNlNTg6IGZsaWNrciB2ZXJzaW9uLiBDaGVjayBvdXQgYGJhc2U1OGAuXG4gKi9cbmV4cG9ydCBjb25zdCBiYXNlNThmbGlja3IgPSBnZW5CYXNlNTgoJzEyMzQ1Njc4OWFiY2RlZmdoaWprbW5vcHFyc3R1dnd4eXpBQkNERUZHSEpLTE1OUFFSU1RVVldYWVonKTtcbi8qKlxuICogYmFzZTU4OiBYUlAgdmVyc2lvbi4gQ2hlY2sgb3V0IGBiYXNlNThgLlxuICovXG5leHBvcnQgY29uc3QgYmFzZTU4eHJwID0gZ2VuQmFzZTU4KCdycHNobmFmMzl3QlVETkVHSEpLTE00UFFSU1Q3VldYWVoyYmNkZUNnNjVqa204b0ZxaTF0dXZBeHl6Jyk7XG4vLyBEYXRhIGxlbiAoaW5kZXgpIC0+IGVuY29kZWQgYmxvY2sgbGVuXG5jb25zdCBYTVJfQkxPQ0tfTEVOID0gWzAsIDIsIDMsIDUsIDYsIDcsIDksIDEwLCAxMV07XG4vKipcbiAqIGJhc2U1ODogWE1SIHZlcnNpb24uIENoZWNrIG91dCBgYmFzZTU4YC5cbiAqIERvbmUgaW4gOC1ieXRlIGJsb2NrcyAod2hpY2ggZXF1YWxzIDExIGNoYXJzIGluIGRlY29kaW5nKS4gTGFzdCAobm9uLWZ1bGwpIGJsb2NrIHBhZGRlZCB3aXRoICcxJyB0byBzaXplIGluIFhNUl9CTE9DS19MRU4uXG4gKiBCbG9jayBlbmNvZGluZyBzaWduaWZpY2FudGx5IHJlZHVjZXMgcXVhZHJhdGljIGNvbXBsZXhpdHkgb2YgYmFzZTU4LlxuICovXG5leHBvcnQgY29uc3QgYmFzZTU4eG1yID0ge1xuICAgIGVuY29kZShkYXRhKSB7XG4gICAgICAgIGxldCByZXMgPSAnJztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSArPSA4KSB7XG4gICAgICAgICAgICBjb25zdCBibG9jayA9IGRhdGEuc3ViYXJyYXkoaSwgaSArIDgpO1xuICAgICAgICAgICAgcmVzICs9IGJhc2U1OC5lbmNvZGUoYmxvY2spLnBhZFN0YXJ0KFhNUl9CTE9DS19MRU5bYmxvY2subGVuZ3RoXSwgJzEnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH0sXG4gICAgZGVjb2RlKHN0cikge1xuICAgICAgICBsZXQgcmVzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSArPSAxMSkge1xuICAgICAgICAgICAgY29uc3Qgc2xpY2UgPSBzdHIuc2xpY2UoaSwgaSArIDExKTtcbiAgICAgICAgICAgIGNvbnN0IGJsb2NrTGVuID0gWE1SX0JMT0NLX0xFTi5pbmRleE9mKHNsaWNlLmxlbmd0aCk7XG4gICAgICAgICAgICBjb25zdCBibG9jayA9IGJhc2U1OC5kZWNvZGUoc2xpY2UpO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBibG9jay5sZW5ndGggLSBibG9ja0xlbjsgaisrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGJsb2NrW2pdICE9PSAwKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Jhc2U1OHhtcjogd3JvbmcgcGFkZGluZycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzID0gcmVzLmNvbmNhdChBcnJheS5mcm9tKGJsb2NrLnNsaWNlKGJsb2NrLmxlbmd0aCAtIGJsb2NrTGVuKSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LmZyb20ocmVzKTtcbiAgICB9LFxufTtcbi8qKlxuICogTWV0aG9kLCB3aGljaCBjcmVhdGVzIGJhc2U1OGNoZWNrIGVuY29kZXIuXG4gKiBSZXF1aXJlcyBmdW5jdGlvbiwgY2FsY3VsYXRpbmcgc2hhMjU2LlxuICovXG5leHBvcnQgY29uc3QgY3JlYXRlQmFzZTU4Y2hlY2sgPSAoc2hhMjU2KSA9PiBjaGFpbihjaGVja3N1bSg0LCAoZGF0YSkgPT4gc2hhMjU2KHNoYTI1NihkYXRhKSkpLCBiYXNlNTgpO1xuLyoqXG4gKiBVc2UgYGNyZWF0ZUJhc2U1OGNoZWNrYCBpbnN0ZWFkLlxuICogQGRlcHJlY2F0ZWRcbiAqL1xuZXhwb3J0IGNvbnN0IGJhc2U1OGNoZWNrID0gY3JlYXRlQmFzZTU4Y2hlY2s7XG5jb25zdCBCRUNIX0FMUEhBQkVUID0gY2hhaW4oYWxwaGFiZXQoJ3FwenJ5OXg4Z2YydHZkdzBzM2puNTRraGNlNm11YTdsJyksIGpvaW4oJycpKTtcbmNvbnN0IFBPTFlNT0RfR0VORVJBVE9SUyA9IFsweDNiNmE1N2IyLCAweDI2NTA4ZTZkLCAweDFlYTExOWZhLCAweDNkNDIzM2RkLCAweDJhMTQ2MmIzXTtcbmZ1bmN0aW9uIGJlY2gzMlBvbHltb2QocHJlKSB7XG4gICAgY29uc3QgYiA9IHByZSA+PiAyNTtcbiAgICBsZXQgY2hrID0gKHByZSAmIDB4MWZmZmZmZikgPDwgNTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IFBPTFlNT0RfR0VORVJBVE9SUy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoKChiID4+IGkpICYgMSkgPT09IDEpXG4gICAgICAgICAgICBjaGsgXj0gUE9MWU1PRF9HRU5FUkFUT1JTW2ldO1xuICAgIH1cbiAgICByZXR1cm4gY2hrO1xufVxuZnVuY3Rpb24gYmVjaENoZWNrc3VtKHByZWZpeCwgd29yZHMsIGVuY29kaW5nQ29uc3QgPSAxKSB7XG4gICAgY29uc3QgbGVuID0gcHJlZml4Lmxlbmd0aDtcbiAgICBsZXQgY2hrID0gMTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGMgPSBwcmVmaXguY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKGMgPCAzMyB8fCBjID4gMTI2KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHByZWZpeCAoJHtwcmVmaXh9KWApO1xuICAgICAgICBjaGsgPSBiZWNoMzJQb2x5bW9kKGNoaykgXiAoYyA+PiA1KTtcbiAgICB9XG4gICAgY2hrID0gYmVjaDMyUG9seW1vZChjaGspO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspXG4gICAgICAgIGNoayA9IGJlY2gzMlBvbHltb2QoY2hrKSBeIChwcmVmaXguY2hhckNvZGVBdChpKSAmIDB4MWYpO1xuICAgIGZvciAobGV0IHYgb2Ygd29yZHMpXG4gICAgICAgIGNoayA9IGJlY2gzMlBvbHltb2QoY2hrKSBeIHY7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA2OyBpKyspXG4gICAgICAgIGNoayA9IGJlY2gzMlBvbHltb2QoY2hrKTtcbiAgICBjaGsgXj0gZW5jb2RpbmdDb25zdDtcbiAgICByZXR1cm4gQkVDSF9BTFBIQUJFVC5lbmNvZGUoY29udmVydFJhZGl4MihbY2hrICUgcG93ZXJzWzMwXV0sIDMwLCA1LCBmYWxzZSkpO1xufVxuLyoqXG4gKiBAX19OT19TSURFX0VGRkVDVFNfX1xuICovXG5mdW5jdGlvbiBnZW5CZWNoMzIoZW5jb2RpbmcpIHtcbiAgICBjb25zdCBFTkNPRElOR19DT05TVCA9IGVuY29kaW5nID09PSAnYmVjaDMyJyA/IDEgOiAweDJiYzgzMGEzO1xuICAgIGNvbnN0IF93b3JkcyA9IHJhZGl4Mig1KTtcbiAgICBjb25zdCBmcm9tV29yZHMgPSBfd29yZHMuZGVjb2RlO1xuICAgIGNvbnN0IHRvV29yZHMgPSBfd29yZHMuZW5jb2RlO1xuICAgIGNvbnN0IGZyb21Xb3Jkc1Vuc2FmZSA9IHVuc2FmZVdyYXBwZXIoZnJvbVdvcmRzKTtcbiAgICBmdW5jdGlvbiBlbmNvZGUocHJlZml4LCB3b3JkcywgbGltaXQgPSA5MCkge1xuICAgICAgICBhc3RyKCdiZWNoMzIuZW5jb2RlIHByZWZpeCcsIHByZWZpeCk7XG4gICAgICAgIGlmIChpc0J5dGVzKHdvcmRzKSlcbiAgICAgICAgICAgIHdvcmRzID0gQXJyYXkuZnJvbSh3b3Jkcyk7XG4gICAgICAgIGFudW1BcnIoJ2JlY2gzMi5lbmNvZGUnLCB3b3Jkcyk7XG4gICAgICAgIGNvbnN0IHBsZW4gPSBwcmVmaXgubGVuZ3RoO1xuICAgICAgICBpZiAocGxlbiA9PT0gMClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgcHJlZml4IGxlbmd0aCAke3BsZW59YCk7XG4gICAgICAgIGNvbnN0IGFjdHVhbExlbmd0aCA9IHBsZW4gKyA3ICsgd29yZHMubGVuZ3RoO1xuICAgICAgICBpZiAobGltaXQgIT09IGZhbHNlICYmIGFjdHVhbExlbmd0aCA+IGxpbWl0KVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTGVuZ3RoICR7YWN0dWFsTGVuZ3RofSBleGNlZWRzIGxpbWl0ICR7bGltaXR9YCk7XG4gICAgICAgIGNvbnN0IGxvd2VyZWQgPSBwcmVmaXgudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgY29uc3Qgc3VtID0gYmVjaENoZWNrc3VtKGxvd2VyZWQsIHdvcmRzLCBFTkNPRElOR19DT05TVCk7XG4gICAgICAgIHJldHVybiBgJHtsb3dlcmVkfTEke0JFQ0hfQUxQSEFCRVQuZW5jb2RlKHdvcmRzKX0ke3N1bX1gO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZWNvZGUoc3RyLCBsaW1pdCA9IDkwKSB7XG4gICAgICAgIGFzdHIoJ2JlY2gzMi5kZWNvZGUgaW5wdXQnLCBzdHIpO1xuICAgICAgICBjb25zdCBzbGVuID0gc3RyLmxlbmd0aDtcbiAgICAgICAgaWYgKHNsZW4gPCA4IHx8IChsaW1pdCAhPT0gZmFsc2UgJiYgc2xlbiA+IGxpbWl0KSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYGludmFsaWQgc3RyaW5nIGxlbmd0aDogJHtzbGVufSAoJHtzdHJ9KS4gRXhwZWN0ZWQgKDguLiR7bGltaXR9KWApO1xuICAgICAgICAvLyBkb24ndCBhbGxvdyBtaXhlZCBjYXNlXG4gICAgICAgIGNvbnN0IGxvd2VyZWQgPSBzdHIudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKHN0ciAhPT0gbG93ZXJlZCAmJiBzdHIgIT09IHN0ci50b1VwcGVyQ2FzZSgpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBTdHJpbmcgbXVzdCBiZSBsb3dlcmNhc2Ugb3IgdXBwZXJjYXNlYCk7XG4gICAgICAgIGNvbnN0IHNlcEluZGV4ID0gbG93ZXJlZC5sYXN0SW5kZXhPZignMScpO1xuICAgICAgICBpZiAoc2VwSW5kZXggPT09IDAgfHwgc2VwSW5kZXggPT09IC0xKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBMZXR0ZXIgXCIxXCIgbXVzdCBiZSBwcmVzZW50IGJldHdlZW4gcHJlZml4IGFuZCBkYXRhIG9ubHlgKTtcbiAgICAgICAgY29uc3QgcHJlZml4ID0gbG93ZXJlZC5zbGljZSgwLCBzZXBJbmRleCk7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBsb3dlcmVkLnNsaWNlKHNlcEluZGV4ICsgMSk7XG4gICAgICAgIGlmIChkYXRhLmxlbmd0aCA8IDYpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RhdGEgbXVzdCBiZSBhdCBsZWFzdCA2IGNoYXJhY3RlcnMgbG9uZycpO1xuICAgICAgICBjb25zdCB3b3JkcyA9IEJFQ0hfQUxQSEFCRVQuZGVjb2RlKGRhdGEpLnNsaWNlKDAsIC02KTtcbiAgICAgICAgY29uc3Qgc3VtID0gYmVjaENoZWNrc3VtKHByZWZpeCwgd29yZHMsIEVOQ09ESU5HX0NPTlNUKTtcbiAgICAgICAgaWYgKCFkYXRhLmVuZHNXaXRoKHN1bSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgY2hlY2tzdW0gaW4gJHtzdHJ9OiBleHBlY3RlZCBcIiR7c3VtfVwiYCk7XG4gICAgICAgIHJldHVybiB7IHByZWZpeCwgd29yZHMgfTtcbiAgICB9XG4gICAgY29uc3QgZGVjb2RlVW5zYWZlID0gdW5zYWZlV3JhcHBlcihkZWNvZGUpO1xuICAgIGZ1bmN0aW9uIGRlY29kZVRvQnl0ZXMoc3RyKSB7XG4gICAgICAgIGNvbnN0IHsgcHJlZml4LCB3b3JkcyB9ID0gZGVjb2RlKHN0ciwgZmFsc2UpO1xuICAgICAgICByZXR1cm4geyBwcmVmaXgsIHdvcmRzLCBieXRlczogZnJvbVdvcmRzKHdvcmRzKSB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBlbmNvZGVGcm9tQnl0ZXMocHJlZml4LCBieXRlcykge1xuICAgICAgICByZXR1cm4gZW5jb2RlKHByZWZpeCwgdG9Xb3JkcyhieXRlcykpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBlbmNvZGUsXG4gICAgICAgIGRlY29kZSxcbiAgICAgICAgZW5jb2RlRnJvbUJ5dGVzLFxuICAgICAgICBkZWNvZGVUb0J5dGVzLFxuICAgICAgICBkZWNvZGVVbnNhZmUsXG4gICAgICAgIGZyb21Xb3JkcyxcbiAgICAgICAgZnJvbVdvcmRzVW5zYWZlLFxuICAgICAgICB0b1dvcmRzLFxuICAgIH07XG59XG4vKipcbiAqIGJlY2gzMiBmcm9tIEJJUCAxNzMuIE9wZXJhdGVzIG9uIHdvcmRzLlxuICogRm9yIGhpZ2gtbGV2ZWwsIGNoZWNrIG91dCBzY3VyZS1idGMtc2lnbmVyOlxuICogaHR0cHM6Ly9naXRodWIuY29tL3BhdWxtaWxsci9zY3VyZS1idGMtc2lnbmVyLlxuICovXG5leHBvcnQgY29uc3QgYmVjaDMyID0gZ2VuQmVjaDMyKCdiZWNoMzInKTtcbi8qKlxuICogYmVjaDMybSBmcm9tIEJJUCAzNTAuIE9wZXJhdGVzIG9uIHdvcmRzLlxuICogSXQgd2FzIHRvIG1pdGlnYXRlIGBiZWNoMzJgIHdlYWtuZXNzZXMuXG4gKiBGb3IgaGlnaC1sZXZlbCwgY2hlY2sgb3V0IHNjdXJlLWJ0Yy1zaWduZXI6XG4gKiBodHRwczovL2dpdGh1Yi5jb20vcGF1bG1pbGxyL3NjdXJlLWJ0Yy1zaWduZXIuXG4gKi9cbmV4cG9ydCBjb25zdCBiZWNoMzJtID0gZ2VuQmVjaDMyKCdiZWNoMzJtJyk7XG4vKipcbiAqIFVURi04LXRvLWJ5dGUgZGVjb2Rlci4gVXNlcyBidWlsdC1pbiBUZXh0RGVjb2RlciAvIFRleHRFbmNvZGVyLlxuICogQGV4YW1wbGVcbiAqIGBgYGpzXG4gKiBjb25zdCBiID0gdXRmOC5kZWNvZGUoXCJoZXlcIik7IC8vID0+IG5ldyBVaW50OEFycmF5KFsgMTA0LCAxMDEsIDEyMSBdKVxuICogY29uc3Qgc3RyID0gdXRmOC5lbmNvZGUoYik7IC8vIFwiaGV5XCJcbiAqIGBgYFxuICovXG5leHBvcnQgY29uc3QgdXRmOCA9IHtcbiAgICBlbmNvZGU6IChkYXRhKSA9PiBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUoZGF0YSksXG4gICAgZGVjb2RlOiAoc3RyKSA9PiBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoc3RyKSxcbn07XG4vLyBCdWlsdC1pbiBoZXggY29udmVyc2lvbiBodHRwczovL2Nhbml1c2UuY29tL21kbi1qYXZhc2NyaXB0X2J1aWx0aW5zX3VpbnQ4YXJyYXlfZnJvbWhleFxuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBoYXNIZXhCdWlsdGluID0gLyogQF9fUFVSRV9fICovICgoKSA9PiB0eXBlb2YgVWludDhBcnJheS5mcm9tKFtdKS50b0hleCA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgIHR5cGVvZiBVaW50OEFycmF5LmZyb21IZXggPT09ICdmdW5jdGlvbicpKCk7XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IGhleEJ1aWx0aW4gPSB7XG4gICAgZW5jb2RlKGRhdGEpIHsgYWJ5dGVzKGRhdGEpOyByZXR1cm4gZGF0YS50b0hleCgpOyB9LFxuICAgIGRlY29kZShzKSB7IGFzdHIoJ2hleCcsIHMpOyByZXR1cm4gVWludDhBcnJheS5mcm9tSGV4KHMpOyB9LFxufTtcbi8qKlxuICogaGV4IHN0cmluZyBkZWNvZGVyLiBVc2VzIGJ1aWx0LWluIGZ1bmN0aW9uLCB3aGVuIGF2YWlsYWJsZS5cbiAqIEBleGFtcGxlXG4gKiBgYGBqc1xuICogY29uc3QgYiA9IGhleC5kZWNvZGUoXCIwMTAyZmZcIik7IC8vID0+IG5ldyBVaW50OEFycmF5KFsgMSwgMiwgMjU1IF0pXG4gKiBjb25zdCBzdHIgPSBoZXguZW5jb2RlKGIpOyAvLyBcIjAxMDJmZlwiXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNvbnN0IGhleCA9IGhhc0hleEJ1aWx0aW5cbiAgICA/IGhleEJ1aWx0aW5cbiAgICA6IGNoYWluKHJhZGl4Mig0KSwgYWxwaGFiZXQoJzAxMjM0NTY3ODlhYmNkZWYnKSwgam9pbignJyksIG5vcm1hbGl6ZSgocykgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIHMgIT09ICdzdHJpbmcnIHx8IHMubGVuZ3RoICUgMiAhPT0gMClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYGhleC5kZWNvZGU6IGV4cGVjdGVkIHN0cmluZywgZ290ICR7dHlwZW9mIHN9IHdpdGggbGVuZ3RoICR7cy5sZW5ndGh9YCk7XG4gICAgICAgIHJldHVybiBzLnRvTG93ZXJDYXNlKCk7XG4gICAgfSkpO1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBDT0RFUlMgPSB7XG4gICAgdXRmOCwgaGV4LCBiYXNlMTYsIGJhc2UzMiwgYmFzZTY0LCBiYXNlNjR1cmwsIGJhc2U1OCwgYmFzZTU4eG1yXG59O1xuY29uc3QgY29kZXJUeXBlRXJyb3IgPSAnSW52YWxpZCBlbmNvZGluZyB0eXBlLiBBdmFpbGFibGUgdHlwZXM6IHV0ZjgsIGhleCwgYmFzZTE2LCBiYXNlMzIsIGJhc2U2NCwgYmFzZTY0dXJsLCBiYXNlNTgsIGJhc2U1OHhtcic7XG4vKiogQGRlcHJlY2F0ZWQgKi9cbmV4cG9ydCBjb25zdCBieXRlc1RvU3RyaW5nID0gKHR5cGUsIGJ5dGVzKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB0eXBlICE9PSAnc3RyaW5nJyB8fCAhQ09ERVJTLmhhc093blByb3BlcnR5KHR5cGUpKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGNvZGVyVHlwZUVycm9yKTtcbiAgICBpZiAoIWlzQnl0ZXMoYnl0ZXMpKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdieXRlc1RvU3RyaW5nKCkgZXhwZWN0cyBVaW50OEFycmF5Jyk7XG4gICAgcmV0dXJuIENPREVSU1t0eXBlXS5lbmNvZGUoYnl0ZXMpO1xufTtcbi8qKiBAZGVwcmVjYXRlZCAqL1xuZXhwb3J0IGNvbnN0IHN0ciA9IGJ5dGVzVG9TdHJpbmc7IC8vIGFzIGluIHB5dGhvbiwgYnV0IGZvciBieXRlcyBvbmx5XG4vKiogQGRlcHJlY2F0ZWQgKi9cbmV4cG9ydCBjb25zdCBzdHJpbmdUb0J5dGVzID0gKHR5cGUsIHN0cikgPT4ge1xuICAgIGlmICghQ09ERVJTLmhhc093blByb3BlcnR5KHR5cGUpKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGNvZGVyVHlwZUVycm9yKTtcbiAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3N0cmluZ1RvQnl0ZXMoKSBleHBlY3RzIHN0cmluZycpO1xuICAgIHJldHVybiBDT0RFUlNbdHlwZV0uZGVjb2RlKHN0cik7XG59O1xuLyoqIEBkZXByZWNhdGVkICovXG5leHBvcnQgY29uc3QgYnl0ZXMgPSBzdHJpbmdUb0J5dGVzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/did-jwt/node_modules/@scure/base/index.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/did-jwt/node_modules/multiformats/esm/src/bases/base.js":
/*!**********************************************************************************!*\
  !*** ../../node_modules/did-jwt/node_modules/multiformats/esm/src/bases/base.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Codec: () => (/* binding */ Codec),\n/* harmony export */   baseX: () => (/* binding */ baseX),\n/* harmony export */   from: () => (/* binding */ from),\n/* harmony export */   or: () => (/* binding */ or),\n/* harmony export */   rfc4648: () => (/* binding */ rfc4648)\n/* harmony export */ });\n/* harmony import */ var _vendor_base_x_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../vendor/base-x.js */ \"(rsc)/../../node_modules/did-jwt/node_modules/multiformats/esm/vendor/base-x.js\");\n/* harmony import */ var _bytes_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../bytes.js */ \"(rsc)/../../node_modules/did-jwt/node_modules/multiformats/esm/src/bytes.js\");\n\n\nclass Encoder {\n  constructor(name, prefix, baseEncode) {\n    this.name = name;\n    this.prefix = prefix;\n    this.baseEncode = baseEncode;\n  }\n  encode(bytes) {\n    if (bytes instanceof Uint8Array) {\n      return `${ this.prefix }${ this.baseEncode(bytes) }`;\n    } else {\n      throw Error('Unknown type, must be binary type');\n    }\n  }\n}\nclass Decoder {\n  constructor(name, prefix, baseDecode) {\n    this.name = name;\n    this.prefix = prefix;\n    if (prefix.codePointAt(0) === undefined) {\n      throw new Error('Invalid prefix character');\n    }\n    this.prefixCodePoint = prefix.codePointAt(0);\n    this.baseDecode = baseDecode;\n  }\n  decode(text) {\n    if (typeof text === 'string') {\n      if (text.codePointAt(0) !== this.prefixCodePoint) {\n        throw Error(`Unable to decode multibase string ${ JSON.stringify(text) }, ${ this.name } decoder only supports inputs prefixed with ${ this.prefix }`);\n      }\n      return this.baseDecode(text.slice(this.prefix.length));\n    } else {\n      throw Error('Can only multibase decode strings');\n    }\n  }\n  or(decoder) {\n    return or(this, decoder);\n  }\n}\nclass ComposedDecoder {\n  constructor(decoders) {\n    this.decoders = decoders;\n  }\n  or(decoder) {\n    return or(this, decoder);\n  }\n  decode(input) {\n    const prefix = input[0];\n    const decoder = this.decoders[prefix];\n    if (decoder) {\n      return decoder.decode(input);\n    } else {\n      throw RangeError(`Unable to decode multibase string ${ JSON.stringify(input) }, only inputs prefixed with ${ Object.keys(this.decoders) } are supported`);\n    }\n  }\n}\nconst or = (left, right) => new ComposedDecoder({\n  ...left.decoders || { [left.prefix]: left },\n  ...right.decoders || { [right.prefix]: right }\n});\nclass Codec {\n  constructor(name, prefix, baseEncode, baseDecode) {\n    this.name = name;\n    this.prefix = prefix;\n    this.baseEncode = baseEncode;\n    this.baseDecode = baseDecode;\n    this.encoder = new Encoder(name, prefix, baseEncode);\n    this.decoder = new Decoder(name, prefix, baseDecode);\n  }\n  encode(input) {\n    return this.encoder.encode(input);\n  }\n  decode(input) {\n    return this.decoder.decode(input);\n  }\n}\nconst from = ({name, prefix, encode, decode}) => new Codec(name, prefix, encode, decode);\nconst baseX = ({prefix, name, alphabet}) => {\n  const {encode, decode} = (0,_vendor_base_x_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(alphabet, name);\n  return from({\n    prefix,\n    name,\n    encode,\n    decode: text => (0,_bytes_js__WEBPACK_IMPORTED_MODULE_1__.coerce)(decode(text))\n  });\n};\nconst decode = (string, alphabet, bitsPerChar, name) => {\n  const codes = {};\n  for (let i = 0; i < alphabet.length; ++i) {\n    codes[alphabet[i]] = i;\n  }\n  let end = string.length;\n  while (string[end - 1] === '=') {\n    --end;\n  }\n  const out = new Uint8Array(end * bitsPerChar / 8 | 0);\n  let bits = 0;\n  let buffer = 0;\n  let written = 0;\n  for (let i = 0; i < end; ++i) {\n    const value = codes[string[i]];\n    if (value === undefined) {\n      throw new SyntaxError(`Non-${ name } character`);\n    }\n    buffer = buffer << bitsPerChar | value;\n    bits += bitsPerChar;\n    if (bits >= 8) {\n      bits -= 8;\n      out[written++] = 255 & buffer >> bits;\n    }\n  }\n  if (bits >= bitsPerChar || 255 & buffer << 8 - bits) {\n    throw new SyntaxError('Unexpected end of data');\n  }\n  return out;\n};\nconst encode = (data, alphabet, bitsPerChar) => {\n  const pad = alphabet[alphabet.length - 1] === '=';\n  const mask = (1 << bitsPerChar) - 1;\n  let out = '';\n  let bits = 0;\n  let buffer = 0;\n  for (let i = 0; i < data.length; ++i) {\n    buffer = buffer << 8 | data[i];\n    bits += 8;\n    while (bits > bitsPerChar) {\n      bits -= bitsPerChar;\n      out += alphabet[mask & buffer >> bits];\n    }\n  }\n  if (bits) {\n    out += alphabet[mask & buffer << bitsPerChar - bits];\n  }\n  if (pad) {\n    while (out.length * bitsPerChar & 7) {\n      out += '=';\n    }\n  }\n  return out;\n};\nconst rfc4648 = ({name, prefix, bitsPerChar, alphabet}) => {\n  return from({\n    prefix,\n    name,\n    encode(input) {\n      return encode(input, alphabet, bitsPerChar);\n    },\n    decode(input) {\n      return decode(input, alphabet, bitsPerChar, name);\n    }\n  });\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2RpZC1qd3Qvbm9kZV9tb2R1bGVzL211bHRpZm9ybWF0cy9lc20vc3JjL2Jhc2VzL2Jhc2UuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUEyQztBQUNOO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsYUFBYSxHQUFHLHdCQUF3QjtBQUN6RCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxzQkFBc0IsS0FBSyxZQUFZLDhDQUE4QyxhQUFhO0FBQzVKO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sNkRBQTZELHVCQUF1QiwrQkFBK0IsNkJBQTZCO0FBQ2hKO0FBQ0E7QUFDQTtBQUNPO0FBQ1Asd0JBQXdCLHFCQUFxQjtBQUM3Qyx5QkFBeUI7QUFDekIsQ0FBQztBQUNNO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sZUFBZSw2QkFBNkI7QUFDNUMsZ0JBQWdCLHVCQUF1QjtBQUM5QyxTQUFTLGdCQUFnQixFQUFFLDZEQUFLO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlEQUFNO0FBQzFCLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IscUJBQXFCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBLG9DQUFvQyxPQUFPO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sa0JBQWtCLG9DQUFvQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCIsInNvdXJjZXMiOlsiL2hvbWUvYmFyYi9hYS9Bc3NvY2lhdGVkQWNjb3VudHMvbm9kZV9tb2R1bGVzL2RpZC1qd3Qvbm9kZV9tb2R1bGVzL211bHRpZm9ybWF0cy9lc20vc3JjL2Jhc2VzL2Jhc2UuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGJhc2V4IGZyb20gJy4uLy4uL3ZlbmRvci9iYXNlLXguanMnO1xuaW1wb3J0IHsgY29lcmNlIH0gZnJvbSAnLi4vYnl0ZXMuanMnO1xuY2xhc3MgRW5jb2RlciB7XG4gIGNvbnN0cnVjdG9yKG5hbWUsIHByZWZpeCwgYmFzZUVuY29kZSkge1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy5wcmVmaXggPSBwcmVmaXg7XG4gICAgdGhpcy5iYXNlRW5jb2RlID0gYmFzZUVuY29kZTtcbiAgfVxuICBlbmNvZGUoYnl0ZXMpIHtcbiAgICBpZiAoYnl0ZXMgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICByZXR1cm4gYCR7IHRoaXMucHJlZml4IH0keyB0aGlzLmJhc2VFbmNvZGUoYnl0ZXMpIH1gO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBFcnJvcignVW5rbm93biB0eXBlLCBtdXN0IGJlIGJpbmFyeSB0eXBlJyk7XG4gICAgfVxuICB9XG59XG5jbGFzcyBEZWNvZGVyIHtcbiAgY29uc3RydWN0b3IobmFtZSwgcHJlZml4LCBiYXNlRGVjb2RlKSB7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLnByZWZpeCA9IHByZWZpeDtcbiAgICBpZiAocHJlZml4LmNvZGVQb2ludEF0KDApID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBwcmVmaXggY2hhcmFjdGVyJyk7XG4gICAgfVxuICAgIHRoaXMucHJlZml4Q29kZVBvaW50ID0gcHJlZml4LmNvZGVQb2ludEF0KDApO1xuICAgIHRoaXMuYmFzZURlY29kZSA9IGJhc2VEZWNvZGU7XG4gIH1cbiAgZGVjb2RlKHRleHQpIHtcbiAgICBpZiAodHlwZW9mIHRleHQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBpZiAodGV4dC5jb2RlUG9pbnRBdCgwKSAhPT0gdGhpcy5wcmVmaXhDb2RlUG9pbnQpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoYFVuYWJsZSB0byBkZWNvZGUgbXVsdGliYXNlIHN0cmluZyAkeyBKU09OLnN0cmluZ2lmeSh0ZXh0KSB9LCAkeyB0aGlzLm5hbWUgfSBkZWNvZGVyIG9ubHkgc3VwcG9ydHMgaW5wdXRzIHByZWZpeGVkIHdpdGggJHsgdGhpcy5wcmVmaXggfWApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuYmFzZURlY29kZSh0ZXh0LnNsaWNlKHRoaXMucHJlZml4Lmxlbmd0aCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBFcnJvcignQ2FuIG9ubHkgbXVsdGliYXNlIGRlY29kZSBzdHJpbmdzJyk7XG4gICAgfVxuICB9XG4gIG9yKGRlY29kZXIpIHtcbiAgICByZXR1cm4gb3IodGhpcywgZGVjb2Rlcik7XG4gIH1cbn1cbmNsYXNzIENvbXBvc2VkRGVjb2RlciB7XG4gIGNvbnN0cnVjdG9yKGRlY29kZXJzKSB7XG4gICAgdGhpcy5kZWNvZGVycyA9IGRlY29kZXJzO1xuICB9XG4gIG9yKGRlY29kZXIpIHtcbiAgICByZXR1cm4gb3IodGhpcywgZGVjb2Rlcik7XG4gIH1cbiAgZGVjb2RlKGlucHV0KSB7XG4gICAgY29uc3QgcHJlZml4ID0gaW5wdXRbMF07XG4gICAgY29uc3QgZGVjb2RlciA9IHRoaXMuZGVjb2RlcnNbcHJlZml4XTtcbiAgICBpZiAoZGVjb2Rlcikge1xuICAgICAgcmV0dXJuIGRlY29kZXIuZGVjb2RlKGlucHV0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgUmFuZ2VFcnJvcihgVW5hYmxlIHRvIGRlY29kZSBtdWx0aWJhc2Ugc3RyaW5nICR7IEpTT04uc3RyaW5naWZ5KGlucHV0KSB9LCBvbmx5IGlucHV0cyBwcmVmaXhlZCB3aXRoICR7IE9iamVjdC5rZXlzKHRoaXMuZGVjb2RlcnMpIH0gYXJlIHN1cHBvcnRlZGApO1xuICAgIH1cbiAgfVxufVxuZXhwb3J0IGNvbnN0IG9yID0gKGxlZnQsIHJpZ2h0KSA9PiBuZXcgQ29tcG9zZWREZWNvZGVyKHtcbiAgLi4ubGVmdC5kZWNvZGVycyB8fCB7IFtsZWZ0LnByZWZpeF06IGxlZnQgfSxcbiAgLi4ucmlnaHQuZGVjb2RlcnMgfHwgeyBbcmlnaHQucHJlZml4XTogcmlnaHQgfVxufSk7XG5leHBvcnQgY2xhc3MgQ29kZWMge1xuICBjb25zdHJ1Y3RvcihuYW1lLCBwcmVmaXgsIGJhc2VFbmNvZGUsIGJhc2VEZWNvZGUpIHtcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMucHJlZml4ID0gcHJlZml4O1xuICAgIHRoaXMuYmFzZUVuY29kZSA9IGJhc2VFbmNvZGU7XG4gICAgdGhpcy5iYXNlRGVjb2RlID0gYmFzZURlY29kZTtcbiAgICB0aGlzLmVuY29kZXIgPSBuZXcgRW5jb2RlcihuYW1lLCBwcmVmaXgsIGJhc2VFbmNvZGUpO1xuICAgIHRoaXMuZGVjb2RlciA9IG5ldyBEZWNvZGVyKG5hbWUsIHByZWZpeCwgYmFzZURlY29kZSk7XG4gIH1cbiAgZW5jb2RlKGlucHV0KSB7XG4gICAgcmV0dXJuIHRoaXMuZW5jb2Rlci5lbmNvZGUoaW5wdXQpO1xuICB9XG4gIGRlY29kZShpbnB1dCkge1xuICAgIHJldHVybiB0aGlzLmRlY29kZXIuZGVjb2RlKGlucHV0KTtcbiAgfVxufVxuZXhwb3J0IGNvbnN0IGZyb20gPSAoe25hbWUsIHByZWZpeCwgZW5jb2RlLCBkZWNvZGV9KSA9PiBuZXcgQ29kZWMobmFtZSwgcHJlZml4LCBlbmNvZGUsIGRlY29kZSk7XG5leHBvcnQgY29uc3QgYmFzZVggPSAoe3ByZWZpeCwgbmFtZSwgYWxwaGFiZXR9KSA9PiB7XG4gIGNvbnN0IHtlbmNvZGUsIGRlY29kZX0gPSBiYXNleChhbHBoYWJldCwgbmFtZSk7XG4gIHJldHVybiBmcm9tKHtcbiAgICBwcmVmaXgsXG4gICAgbmFtZSxcbiAgICBlbmNvZGUsXG4gICAgZGVjb2RlOiB0ZXh0ID0+IGNvZXJjZShkZWNvZGUodGV4dCkpXG4gIH0pO1xufTtcbmNvbnN0IGRlY29kZSA9IChzdHJpbmcsIGFscGhhYmV0LCBiaXRzUGVyQ2hhciwgbmFtZSkgPT4ge1xuICBjb25zdCBjb2RlcyA9IHt9O1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGFscGhhYmV0Lmxlbmd0aDsgKytpKSB7XG4gICAgY29kZXNbYWxwaGFiZXRbaV1dID0gaTtcbiAgfVxuICBsZXQgZW5kID0gc3RyaW5nLmxlbmd0aDtcbiAgd2hpbGUgKHN0cmluZ1tlbmQgLSAxXSA9PT0gJz0nKSB7XG4gICAgLS1lbmQ7XG4gIH1cbiAgY29uc3Qgb3V0ID0gbmV3IFVpbnQ4QXJyYXkoZW5kICogYml0c1BlckNoYXIgLyA4IHwgMCk7XG4gIGxldCBiaXRzID0gMDtcbiAgbGV0IGJ1ZmZlciA9IDA7XG4gIGxldCB3cml0dGVuID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbmQ7ICsraSkge1xuICAgIGNvbnN0IHZhbHVlID0gY29kZXNbc3RyaW5nW2ldXTtcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBOb24tJHsgbmFtZSB9IGNoYXJhY3RlcmApO1xuICAgIH1cbiAgICBidWZmZXIgPSBidWZmZXIgPDwgYml0c1BlckNoYXIgfCB2YWx1ZTtcbiAgICBiaXRzICs9IGJpdHNQZXJDaGFyO1xuICAgIGlmIChiaXRzID49IDgpIHtcbiAgICAgIGJpdHMgLT0gODtcbiAgICAgIG91dFt3cml0dGVuKytdID0gMjU1ICYgYnVmZmVyID4+IGJpdHM7XG4gICAgfVxuICB9XG4gIGlmIChiaXRzID49IGJpdHNQZXJDaGFyIHx8IDI1NSAmIGJ1ZmZlciA8PCA4IC0gYml0cykge1xuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignVW5leHBlY3RlZCBlbmQgb2YgZGF0YScpO1xuICB9XG4gIHJldHVybiBvdXQ7XG59O1xuY29uc3QgZW5jb2RlID0gKGRhdGEsIGFscGhhYmV0LCBiaXRzUGVyQ2hhcikgPT4ge1xuICBjb25zdCBwYWQgPSBhbHBoYWJldFthbHBoYWJldC5sZW5ndGggLSAxXSA9PT0gJz0nO1xuICBjb25zdCBtYXNrID0gKDEgPDwgYml0c1BlckNoYXIpIC0gMTtcbiAgbGV0IG91dCA9ICcnO1xuICBsZXQgYml0cyA9IDA7XG4gIGxldCBidWZmZXIgPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyArK2kpIHtcbiAgICBidWZmZXIgPSBidWZmZXIgPDwgOCB8IGRhdGFbaV07XG4gICAgYml0cyArPSA4O1xuICAgIHdoaWxlIChiaXRzID4gYml0c1BlckNoYXIpIHtcbiAgICAgIGJpdHMgLT0gYml0c1BlckNoYXI7XG4gICAgICBvdXQgKz0gYWxwaGFiZXRbbWFzayAmIGJ1ZmZlciA+PiBiaXRzXTtcbiAgICB9XG4gIH1cbiAgaWYgKGJpdHMpIHtcbiAgICBvdXQgKz0gYWxwaGFiZXRbbWFzayAmIGJ1ZmZlciA8PCBiaXRzUGVyQ2hhciAtIGJpdHNdO1xuICB9XG4gIGlmIChwYWQpIHtcbiAgICB3aGlsZSAob3V0Lmxlbmd0aCAqIGJpdHNQZXJDaGFyICYgNykge1xuICAgICAgb3V0ICs9ICc9JztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG91dDtcbn07XG5leHBvcnQgY29uc3QgcmZjNDY0OCA9ICh7bmFtZSwgcHJlZml4LCBiaXRzUGVyQ2hhciwgYWxwaGFiZXR9KSA9PiB7XG4gIHJldHVybiBmcm9tKHtcbiAgICBwcmVmaXgsXG4gICAgbmFtZSxcbiAgICBlbmNvZGUoaW5wdXQpIHtcbiAgICAgIHJldHVybiBlbmNvZGUoaW5wdXQsIGFscGhhYmV0LCBiaXRzUGVyQ2hhcik7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQpIHtcbiAgICAgIHJldHVybiBkZWNvZGUoaW5wdXQsIGFscGhhYmV0LCBiaXRzUGVyQ2hhciwgbmFtZSk7XG4gICAgfVxuICB9KTtcbn07Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/did-jwt/node_modules/multiformats/esm/src/bases/base.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/did-jwt/node_modules/multiformats/esm/src/bases/base10.js":
/*!************************************************************************************!*\
  !*** ../../node_modules/did-jwt/node_modules/multiformats/esm/src/bases/base10.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   base10: () => (/* binding */ base10)\n/* harmony export */ });\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ \"(rsc)/../../node_modules/did-jwt/node_modules/multiformats/esm/src/bases/base.js\");\n\nconst base10 = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.baseX)({\n  prefix: '9',\n  name: 'base10',\n  alphabet: '0123456789'\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2RpZC1qd3Qvbm9kZV9tb2R1bGVzL211bHRpZm9ybWF0cy9lc20vc3JjL2Jhc2VzL2Jhc2UxMC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFrQztBQUMzQixlQUFlLCtDQUFLO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIi9ob21lL2JhcmIvYWEvQXNzb2NpYXRlZEFjY291bnRzL25vZGVfbW9kdWxlcy9kaWQtand0L25vZGVfbW9kdWxlcy9tdWx0aWZvcm1hdHMvZXNtL3NyYy9iYXNlcy9iYXNlMTAuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgYmFzZVggfSBmcm9tICcuL2Jhc2UuanMnO1xuZXhwb3J0IGNvbnN0IGJhc2UxMCA9IGJhc2VYKHtcbiAgcHJlZml4OiAnOScsXG4gIG5hbWU6ICdiYXNlMTAnLFxuICBhbHBoYWJldDogJzAxMjM0NTY3ODknXG59KTsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/did-jwt/node_modules/multiformats/esm/src/bases/base10.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/did-jwt/node_modules/multiformats/esm/src/bases/base16.js":
/*!************************************************************************************!*\
  !*** ../../node_modules/did-jwt/node_modules/multiformats/esm/src/bases/base16.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   base16: () => (/* binding */ base16),\n/* harmony export */   base16upper: () => (/* binding */ base16upper)\n/* harmony export */ });\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ \"(rsc)/../../node_modules/did-jwt/node_modules/multiformats/esm/src/bases/base.js\");\n\nconst base16 = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.rfc4648)({\n  prefix: 'f',\n  name: 'base16',\n  alphabet: '0123456789abcdef',\n  bitsPerChar: 4\n});\nconst base16upper = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.rfc4648)({\n  prefix: 'F',\n  name: 'base16upper',\n  alphabet: '0123456789ABCDEF',\n  bitsPerChar: 4\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2RpZC1qd3Qvbm9kZV9tb2R1bGVzL211bHRpZm9ybWF0cy9lc20vc3JjL2Jhc2VzL2Jhc2UxNi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBb0M7QUFDN0IsZUFBZSxpREFBTztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDTSxvQkFBb0IsaURBQU87QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwic291cmNlcyI6WyIvaG9tZS9iYXJiL2FhL0Fzc29jaWF0ZWRBY2NvdW50cy9ub2RlX21vZHVsZXMvZGlkLWp3dC9ub2RlX21vZHVsZXMvbXVsdGlmb3JtYXRzL2VzbS9zcmMvYmFzZXMvYmFzZTE2LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHJmYzQ2NDggfSBmcm9tICcuL2Jhc2UuanMnO1xuZXhwb3J0IGNvbnN0IGJhc2UxNiA9IHJmYzQ2NDgoe1xuICBwcmVmaXg6ICdmJyxcbiAgbmFtZTogJ2Jhc2UxNicsXG4gIGFscGhhYmV0OiAnMDEyMzQ1Njc4OWFiY2RlZicsXG4gIGJpdHNQZXJDaGFyOiA0XG59KTtcbmV4cG9ydCBjb25zdCBiYXNlMTZ1cHBlciA9IHJmYzQ2NDgoe1xuICBwcmVmaXg6ICdGJyxcbiAgbmFtZTogJ2Jhc2UxNnVwcGVyJyxcbiAgYWxwaGFiZXQ6ICcwMTIzNDU2Nzg5QUJDREVGJyxcbiAgYml0c1BlckNoYXI6IDRcbn0pOyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/did-jwt/node_modules/multiformats/esm/src/bases/base16.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/did-jwt/node_modules/multiformats/esm/src/bases/base2.js":
/*!***********************************************************************************!*\
  !*** ../../node_modules/did-jwt/node_modules/multiformats/esm/src/bases/base2.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   base2: () => (/* binding */ base2)\n/* harmony export */ });\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ \"(rsc)/../../node_modules/did-jwt/node_modules/multiformats/esm/src/bases/base.js\");\n\nconst base2 = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.rfc4648)({\n  prefix: '0',\n  name: 'base2',\n  alphabet: '01',\n  bitsPerChar: 1\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2RpZC1qd3Qvbm9kZV9tb2R1bGVzL211bHRpZm9ybWF0cy9lc20vc3JjL2Jhc2VzL2Jhc2UyLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQW9DO0FBQzdCLGNBQWMsaURBQU87QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwic291cmNlcyI6WyIvaG9tZS9iYXJiL2FhL0Fzc29jaWF0ZWRBY2NvdW50cy9ub2RlX21vZHVsZXMvZGlkLWp3dC9ub2RlX21vZHVsZXMvbXVsdGlmb3JtYXRzL2VzbS9zcmMvYmFzZXMvYmFzZTIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcmZjNDY0OCB9IGZyb20gJy4vYmFzZS5qcyc7XG5leHBvcnQgY29uc3QgYmFzZTIgPSByZmM0NjQ4KHtcbiAgcHJlZml4OiAnMCcsXG4gIG5hbWU6ICdiYXNlMicsXG4gIGFscGhhYmV0OiAnMDEnLFxuICBiaXRzUGVyQ2hhcjogMVxufSk7Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/did-jwt/node_modules/multiformats/esm/src/bases/base2.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/did-jwt/node_modules/multiformats/esm/src/bases/base256emoji.js":
/*!******************************************************************************************!*\
  !*** ../../node_modules/did-jwt/node_modules/multiformats/esm/src/bases/base256emoji.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   base256emoji: () => (/* binding */ base256emoji)\n/* harmony export */ });\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ \"(rsc)/../../node_modules/did-jwt/node_modules/multiformats/esm/src/bases/base.js\");\n\nconst alphabet = Array.from('\\uD83D\\uDE80\\uD83E\\uDE90\\u2604\\uD83D\\uDEF0\\uD83C\\uDF0C\\uD83C\\uDF11\\uD83C\\uDF12\\uD83C\\uDF13\\uD83C\\uDF14\\uD83C\\uDF15\\uD83C\\uDF16\\uD83C\\uDF17\\uD83C\\uDF18\\uD83C\\uDF0D\\uD83C\\uDF0F\\uD83C\\uDF0E\\uD83D\\uDC09\\u2600\\uD83D\\uDCBB\\uD83D\\uDDA5\\uD83D\\uDCBE\\uD83D\\uDCBF\\uD83D\\uDE02\\u2764\\uD83D\\uDE0D\\uD83E\\uDD23\\uD83D\\uDE0A\\uD83D\\uDE4F\\uD83D\\uDC95\\uD83D\\uDE2D\\uD83D\\uDE18\\uD83D\\uDC4D\\uD83D\\uDE05\\uD83D\\uDC4F\\uD83D\\uDE01\\uD83D\\uDD25\\uD83E\\uDD70\\uD83D\\uDC94\\uD83D\\uDC96\\uD83D\\uDC99\\uD83D\\uDE22\\uD83E\\uDD14\\uD83D\\uDE06\\uD83D\\uDE44\\uD83D\\uDCAA\\uD83D\\uDE09\\u263A\\uD83D\\uDC4C\\uD83E\\uDD17\\uD83D\\uDC9C\\uD83D\\uDE14\\uD83D\\uDE0E\\uD83D\\uDE07\\uD83C\\uDF39\\uD83E\\uDD26\\uD83C\\uDF89\\uD83D\\uDC9E\\u270C\\u2728\\uD83E\\uDD37\\uD83D\\uDE31\\uD83D\\uDE0C\\uD83C\\uDF38\\uD83D\\uDE4C\\uD83D\\uDE0B\\uD83D\\uDC97\\uD83D\\uDC9A\\uD83D\\uDE0F\\uD83D\\uDC9B\\uD83D\\uDE42\\uD83D\\uDC93\\uD83E\\uDD29\\uD83D\\uDE04\\uD83D\\uDE00\\uD83D\\uDDA4\\uD83D\\uDE03\\uD83D\\uDCAF\\uD83D\\uDE48\\uD83D\\uDC47\\uD83C\\uDFB6\\uD83D\\uDE12\\uD83E\\uDD2D\\u2763\\uD83D\\uDE1C\\uD83D\\uDC8B\\uD83D\\uDC40\\uD83D\\uDE2A\\uD83D\\uDE11\\uD83D\\uDCA5\\uD83D\\uDE4B\\uD83D\\uDE1E\\uD83D\\uDE29\\uD83D\\uDE21\\uD83E\\uDD2A\\uD83D\\uDC4A\\uD83E\\uDD73\\uD83D\\uDE25\\uD83E\\uDD24\\uD83D\\uDC49\\uD83D\\uDC83\\uD83D\\uDE33\\u270B\\uD83D\\uDE1A\\uD83D\\uDE1D\\uD83D\\uDE34\\uD83C\\uDF1F\\uD83D\\uDE2C\\uD83D\\uDE43\\uD83C\\uDF40\\uD83C\\uDF37\\uD83D\\uDE3B\\uD83D\\uDE13\\u2B50\\u2705\\uD83E\\uDD7A\\uD83C\\uDF08\\uD83D\\uDE08\\uD83E\\uDD18\\uD83D\\uDCA6\\u2714\\uD83D\\uDE23\\uD83C\\uDFC3\\uD83D\\uDC90\\u2639\\uD83C\\uDF8A\\uD83D\\uDC98\\uD83D\\uDE20\\u261D\\uD83D\\uDE15\\uD83C\\uDF3A\\uD83C\\uDF82\\uD83C\\uDF3B\\uD83D\\uDE10\\uD83D\\uDD95\\uD83D\\uDC9D\\uD83D\\uDE4A\\uD83D\\uDE39\\uD83D\\uDDE3\\uD83D\\uDCAB\\uD83D\\uDC80\\uD83D\\uDC51\\uD83C\\uDFB5\\uD83E\\uDD1E\\uD83D\\uDE1B\\uD83D\\uDD34\\uD83D\\uDE24\\uD83C\\uDF3C\\uD83D\\uDE2B\\u26BD\\uD83E\\uDD19\\u2615\\uD83C\\uDFC6\\uD83E\\uDD2B\\uD83D\\uDC48\\uD83D\\uDE2E\\uD83D\\uDE46\\uD83C\\uDF7B\\uD83C\\uDF43\\uD83D\\uDC36\\uD83D\\uDC81\\uD83D\\uDE32\\uD83C\\uDF3F\\uD83E\\uDDE1\\uD83C\\uDF81\\u26A1\\uD83C\\uDF1E\\uD83C\\uDF88\\u274C\\u270A\\uD83D\\uDC4B\\uD83D\\uDE30\\uD83E\\uDD28\\uD83D\\uDE36\\uD83E\\uDD1D\\uD83D\\uDEB6\\uD83D\\uDCB0\\uD83C\\uDF53\\uD83D\\uDCA2\\uD83E\\uDD1F\\uD83D\\uDE41\\uD83D\\uDEA8\\uD83D\\uDCA8\\uD83E\\uDD2C\\u2708\\uD83C\\uDF80\\uD83C\\uDF7A\\uD83E\\uDD13\\uD83D\\uDE19\\uD83D\\uDC9F\\uD83C\\uDF31\\uD83D\\uDE16\\uD83D\\uDC76\\uD83E\\uDD74\\u25B6\\u27A1\\u2753\\uD83D\\uDC8E\\uD83D\\uDCB8\\u2B07\\uD83D\\uDE28\\uD83C\\uDF1A\\uD83E\\uDD8B\\uD83D\\uDE37\\uD83D\\uDD7A\\u26A0\\uD83D\\uDE45\\uD83D\\uDE1F\\uD83D\\uDE35\\uD83D\\uDC4E\\uD83E\\uDD32\\uD83E\\uDD20\\uD83E\\uDD27\\uD83D\\uDCCC\\uD83D\\uDD35\\uD83D\\uDC85\\uD83E\\uDDD0\\uD83D\\uDC3E\\uD83C\\uDF52\\uD83D\\uDE17\\uD83E\\uDD11\\uD83C\\uDF0A\\uD83E\\uDD2F\\uD83D\\uDC37\\u260E\\uD83D\\uDCA7\\uD83D\\uDE2F\\uD83D\\uDC86\\uD83D\\uDC46\\uD83C\\uDFA4\\uD83D\\uDE47\\uD83C\\uDF51\\u2744\\uD83C\\uDF34\\uD83D\\uDCA3\\uD83D\\uDC38\\uD83D\\uDC8C\\uD83D\\uDCCD\\uD83E\\uDD40\\uD83E\\uDD22\\uD83D\\uDC45\\uD83D\\uDCA1\\uD83D\\uDCA9\\uD83D\\uDC50\\uD83D\\uDCF8\\uD83D\\uDC7B\\uD83E\\uDD10\\uD83E\\uDD2E\\uD83C\\uDFBC\\uD83E\\uDD75\\uD83D\\uDEA9\\uD83C\\uDF4E\\uD83C\\uDF4A\\uD83D\\uDC7C\\uD83D\\uDC8D\\uD83D\\uDCE3\\uD83E\\uDD42');\nconst alphabetBytesToChars = alphabet.reduce((p, c, i) => {\n  p[i] = c;\n  return p;\n}, []);\nconst alphabetCharsToBytes = alphabet.reduce((p, c, i) => {\n  p[c.codePointAt(0)] = i;\n  return p;\n}, []);\nfunction encode(data) {\n  return data.reduce((p, c) => {\n    p += alphabetBytesToChars[c];\n    return p;\n  }, '');\n}\nfunction decode(str) {\n  const byts = [];\n  for (const char of str) {\n    const byt = alphabetCharsToBytes[char.codePointAt(0)];\n    if (byt === undefined) {\n      throw new Error(`Non-base256emoji character: ${ char }`);\n    }\n    byts.push(byt);\n  }\n  return new Uint8Array(byts);\n}\nconst base256emoji = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.from)({\n  prefix: '\\uD83D\\uDE80',\n  name: 'base256emoji',\n  encode,\n  decode\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2RpZC1qd3Qvbm9kZV9tb2R1bGVzL211bHRpZm9ybWF0cy9lc20vc3JjL2Jhc2VzL2Jhc2UyNTZlbW9qaS5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELE1BQU07QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLHFCQUFxQiw4Q0FBSTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIi9ob21lL2JhcmIvYWEvQXNzb2NpYXRlZEFjY291bnRzL25vZGVfbW9kdWxlcy9kaWQtand0L25vZGVfbW9kdWxlcy9tdWx0aWZvcm1hdHMvZXNtL3NyYy9iYXNlcy9iYXNlMjU2ZW1vamkuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZnJvbSB9IGZyb20gJy4vYmFzZS5qcyc7XG5jb25zdCBhbHBoYWJldCA9IEFycmF5LmZyb20oJ1xcdUQ4M0RcXHVERTgwXFx1RDgzRVxcdURFOTBcXHUyNjA0XFx1RDgzRFxcdURFRjBcXHVEODNDXFx1REYwQ1xcdUQ4M0NcXHVERjExXFx1RDgzQ1xcdURGMTJcXHVEODNDXFx1REYxM1xcdUQ4M0NcXHVERjE0XFx1RDgzQ1xcdURGMTVcXHVEODNDXFx1REYxNlxcdUQ4M0NcXHVERjE3XFx1RDgzQ1xcdURGMThcXHVEODNDXFx1REYwRFxcdUQ4M0NcXHVERjBGXFx1RDgzQ1xcdURGMEVcXHVEODNEXFx1REMwOVxcdTI2MDBcXHVEODNEXFx1RENCQlxcdUQ4M0RcXHVEREE1XFx1RDgzRFxcdURDQkVcXHVEODNEXFx1RENCRlxcdUQ4M0RcXHVERTAyXFx1Mjc2NFxcdUQ4M0RcXHVERTBEXFx1RDgzRVxcdUREMjNcXHVEODNEXFx1REUwQVxcdUQ4M0RcXHVERTRGXFx1RDgzRFxcdURDOTVcXHVEODNEXFx1REUyRFxcdUQ4M0RcXHVERTE4XFx1RDgzRFxcdURDNERcXHVEODNEXFx1REUwNVxcdUQ4M0RcXHVEQzRGXFx1RDgzRFxcdURFMDFcXHVEODNEXFx1REQyNVxcdUQ4M0VcXHVERDcwXFx1RDgzRFxcdURDOTRcXHVEODNEXFx1REM5NlxcdUQ4M0RcXHVEQzk5XFx1RDgzRFxcdURFMjJcXHVEODNFXFx1REQxNFxcdUQ4M0RcXHVERTA2XFx1RDgzRFxcdURFNDRcXHVEODNEXFx1RENBQVxcdUQ4M0RcXHVERTA5XFx1MjYzQVxcdUQ4M0RcXHVEQzRDXFx1RDgzRVxcdUREMTdcXHVEODNEXFx1REM5Q1xcdUQ4M0RcXHVERTE0XFx1RDgzRFxcdURFMEVcXHVEODNEXFx1REUwN1xcdUQ4M0NcXHVERjM5XFx1RDgzRVxcdUREMjZcXHVEODNDXFx1REY4OVxcdUQ4M0RcXHVEQzlFXFx1MjcwQ1xcdTI3MjhcXHVEODNFXFx1REQzN1xcdUQ4M0RcXHVERTMxXFx1RDgzRFxcdURFMENcXHVEODNDXFx1REYzOFxcdUQ4M0RcXHVERTRDXFx1RDgzRFxcdURFMEJcXHVEODNEXFx1REM5N1xcdUQ4M0RcXHVEQzlBXFx1RDgzRFxcdURFMEZcXHVEODNEXFx1REM5QlxcdUQ4M0RcXHVERTQyXFx1RDgzRFxcdURDOTNcXHVEODNFXFx1REQyOVxcdUQ4M0RcXHVERTA0XFx1RDgzRFxcdURFMDBcXHVEODNEXFx1RERBNFxcdUQ4M0RcXHVERTAzXFx1RDgzRFxcdURDQUZcXHVEODNEXFx1REU0OFxcdUQ4M0RcXHVEQzQ3XFx1RDgzQ1xcdURGQjZcXHVEODNEXFx1REUxMlxcdUQ4M0VcXHVERDJEXFx1Mjc2M1xcdUQ4M0RcXHVERTFDXFx1RDgzRFxcdURDOEJcXHVEODNEXFx1REM0MFxcdUQ4M0RcXHVERTJBXFx1RDgzRFxcdURFMTFcXHVEODNEXFx1RENBNVxcdUQ4M0RcXHVERTRCXFx1RDgzRFxcdURFMUVcXHVEODNEXFx1REUyOVxcdUQ4M0RcXHVERTIxXFx1RDgzRVxcdUREMkFcXHVEODNEXFx1REM0QVxcdUQ4M0VcXHVERDczXFx1RDgzRFxcdURFMjVcXHVEODNFXFx1REQyNFxcdUQ4M0RcXHVEQzQ5XFx1RDgzRFxcdURDODNcXHVEODNEXFx1REUzM1xcdTI3MEJcXHVEODNEXFx1REUxQVxcdUQ4M0RcXHVERTFEXFx1RDgzRFxcdURFMzRcXHVEODNDXFx1REYxRlxcdUQ4M0RcXHVERTJDXFx1RDgzRFxcdURFNDNcXHVEODNDXFx1REY0MFxcdUQ4M0NcXHVERjM3XFx1RDgzRFxcdURFM0JcXHVEODNEXFx1REUxM1xcdTJCNTBcXHUyNzA1XFx1RDgzRVxcdUREN0FcXHVEODNDXFx1REYwOFxcdUQ4M0RcXHVERTA4XFx1RDgzRVxcdUREMThcXHVEODNEXFx1RENBNlxcdTI3MTRcXHVEODNEXFx1REUyM1xcdUQ4M0NcXHVERkMzXFx1RDgzRFxcdURDOTBcXHUyNjM5XFx1RDgzQ1xcdURGOEFcXHVEODNEXFx1REM5OFxcdUQ4M0RcXHVERTIwXFx1MjYxRFxcdUQ4M0RcXHVERTE1XFx1RDgzQ1xcdURGM0FcXHVEODNDXFx1REY4MlxcdUQ4M0NcXHVERjNCXFx1RDgzRFxcdURFMTBcXHVEODNEXFx1REQ5NVxcdUQ4M0RcXHVEQzlEXFx1RDgzRFxcdURFNEFcXHVEODNEXFx1REUzOVxcdUQ4M0RcXHVEREUzXFx1RDgzRFxcdURDQUJcXHVEODNEXFx1REM4MFxcdUQ4M0RcXHVEQzUxXFx1RDgzQ1xcdURGQjVcXHVEODNFXFx1REQxRVxcdUQ4M0RcXHVERTFCXFx1RDgzRFxcdUREMzRcXHVEODNEXFx1REUyNFxcdUQ4M0NcXHVERjNDXFx1RDgzRFxcdURFMkJcXHUyNkJEXFx1RDgzRVxcdUREMTlcXHUyNjE1XFx1RDgzQ1xcdURGQzZcXHVEODNFXFx1REQyQlxcdUQ4M0RcXHVEQzQ4XFx1RDgzRFxcdURFMkVcXHVEODNEXFx1REU0NlxcdUQ4M0NcXHVERjdCXFx1RDgzQ1xcdURGNDNcXHVEODNEXFx1REMzNlxcdUQ4M0RcXHVEQzgxXFx1RDgzRFxcdURFMzJcXHVEODNDXFx1REYzRlxcdUQ4M0VcXHVEREUxXFx1RDgzQ1xcdURGODFcXHUyNkExXFx1RDgzQ1xcdURGMUVcXHVEODNDXFx1REY4OFxcdTI3NENcXHUyNzBBXFx1RDgzRFxcdURDNEJcXHVEODNEXFx1REUzMFxcdUQ4M0VcXHVERDI4XFx1RDgzRFxcdURFMzZcXHVEODNFXFx1REQxRFxcdUQ4M0RcXHVERUI2XFx1RDgzRFxcdURDQjBcXHVEODNDXFx1REY1M1xcdUQ4M0RcXHVEQ0EyXFx1RDgzRVxcdUREMUZcXHVEODNEXFx1REU0MVxcdUQ4M0RcXHVERUE4XFx1RDgzRFxcdURDQThcXHVEODNFXFx1REQyQ1xcdTI3MDhcXHVEODNDXFx1REY4MFxcdUQ4M0NcXHVERjdBXFx1RDgzRVxcdUREMTNcXHVEODNEXFx1REUxOVxcdUQ4M0RcXHVEQzlGXFx1RDgzQ1xcdURGMzFcXHVEODNEXFx1REUxNlxcdUQ4M0RcXHVEQzc2XFx1RDgzRVxcdURENzRcXHUyNUI2XFx1MjdBMVxcdTI3NTNcXHVEODNEXFx1REM4RVxcdUQ4M0RcXHVEQ0I4XFx1MkIwN1xcdUQ4M0RcXHVERTI4XFx1RDgzQ1xcdURGMUFcXHVEODNFXFx1REQ4QlxcdUQ4M0RcXHVERTM3XFx1RDgzRFxcdUREN0FcXHUyNkEwXFx1RDgzRFxcdURFNDVcXHVEODNEXFx1REUxRlxcdUQ4M0RcXHVERTM1XFx1RDgzRFxcdURDNEVcXHVEODNFXFx1REQzMlxcdUQ4M0VcXHVERDIwXFx1RDgzRVxcdUREMjdcXHVEODNEXFx1RENDQ1xcdUQ4M0RcXHVERDM1XFx1RDgzRFxcdURDODVcXHVEODNFXFx1REREMFxcdUQ4M0RcXHVEQzNFXFx1RDgzQ1xcdURGNTJcXHVEODNEXFx1REUxN1xcdUQ4M0VcXHVERDExXFx1RDgzQ1xcdURGMEFcXHVEODNFXFx1REQyRlxcdUQ4M0RcXHVEQzM3XFx1MjYwRVxcdUQ4M0RcXHVEQ0E3XFx1RDgzRFxcdURFMkZcXHVEODNEXFx1REM4NlxcdUQ4M0RcXHVEQzQ2XFx1RDgzQ1xcdURGQTRcXHVEODNEXFx1REU0N1xcdUQ4M0NcXHVERjUxXFx1Mjc0NFxcdUQ4M0NcXHVERjM0XFx1RDgzRFxcdURDQTNcXHVEODNEXFx1REMzOFxcdUQ4M0RcXHVEQzhDXFx1RDgzRFxcdURDQ0RcXHVEODNFXFx1REQ0MFxcdUQ4M0VcXHVERDIyXFx1RDgzRFxcdURDNDVcXHVEODNEXFx1RENBMVxcdUQ4M0RcXHVEQ0E5XFx1RDgzRFxcdURDNTBcXHVEODNEXFx1RENGOFxcdUQ4M0RcXHVEQzdCXFx1RDgzRVxcdUREMTBcXHVEODNFXFx1REQyRVxcdUQ4M0NcXHVERkJDXFx1RDgzRVxcdURENzVcXHVEODNEXFx1REVBOVxcdUQ4M0NcXHVERjRFXFx1RDgzQ1xcdURGNEFcXHVEODNEXFx1REM3Q1xcdUQ4M0RcXHVEQzhEXFx1RDgzRFxcdURDRTNcXHVEODNFXFx1REQ0MicpO1xuY29uc3QgYWxwaGFiZXRCeXRlc1RvQ2hhcnMgPSBhbHBoYWJldC5yZWR1Y2UoKHAsIGMsIGkpID0+IHtcbiAgcFtpXSA9IGM7XG4gIHJldHVybiBwO1xufSwgW10pO1xuY29uc3QgYWxwaGFiZXRDaGFyc1RvQnl0ZXMgPSBhbHBoYWJldC5yZWR1Y2UoKHAsIGMsIGkpID0+IHtcbiAgcFtjLmNvZGVQb2ludEF0KDApXSA9IGk7XG4gIHJldHVybiBwO1xufSwgW10pO1xuZnVuY3Rpb24gZW5jb2RlKGRhdGEpIHtcbiAgcmV0dXJuIGRhdGEucmVkdWNlKChwLCBjKSA9PiB7XG4gICAgcCArPSBhbHBoYWJldEJ5dGVzVG9DaGFyc1tjXTtcbiAgICByZXR1cm4gcDtcbiAgfSwgJycpO1xufVxuZnVuY3Rpb24gZGVjb2RlKHN0cikge1xuICBjb25zdCBieXRzID0gW107XG4gIGZvciAoY29uc3QgY2hhciBvZiBzdHIpIHtcbiAgICBjb25zdCBieXQgPSBhbHBoYWJldENoYXJzVG9CeXRlc1tjaGFyLmNvZGVQb2ludEF0KDApXTtcbiAgICBpZiAoYnl0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTm9uLWJhc2UyNTZlbW9qaSBjaGFyYWN0ZXI6ICR7IGNoYXIgfWApO1xuICAgIH1cbiAgICBieXRzLnB1c2goYnl0KTtcbiAgfVxuICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYnl0cyk7XG59XG5leHBvcnQgY29uc3QgYmFzZTI1NmVtb2ppID0gZnJvbSh7XG4gIHByZWZpeDogJ1xcdUQ4M0RcXHVERTgwJyxcbiAgbmFtZTogJ2Jhc2UyNTZlbW9qaScsXG4gIGVuY29kZSxcbiAgZGVjb2RlXG59KTsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/did-jwt/node_modules/multiformats/esm/src/bases/base256emoji.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/did-jwt/node_modules/multiformats/esm/src/bases/base32.js":
/*!************************************************************************************!*\
  !*** ../../node_modules/did-jwt/node_modules/multiformats/esm/src/bases/base32.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   base32: () => (/* binding */ base32),\n/* harmony export */   base32hex: () => (/* binding */ base32hex),\n/* harmony export */   base32hexpad: () => (/* binding */ base32hexpad),\n/* harmony export */   base32hexpadupper: () => (/* binding */ base32hexpadupper),\n/* harmony export */   base32hexupper: () => (/* binding */ base32hexupper),\n/* harmony export */   base32pad: () => (/* binding */ base32pad),\n/* harmony export */   base32padupper: () => (/* binding */ base32padupper),\n/* harmony export */   base32upper: () => (/* binding */ base32upper),\n/* harmony export */   base32z: () => (/* binding */ base32z)\n/* harmony export */ });\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ \"(rsc)/../../node_modules/did-jwt/node_modules/multiformats/esm/src/bases/base.js\");\n\nconst base32 = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.rfc4648)({\n  prefix: 'b',\n  name: 'base32',\n  alphabet: 'abcdefghijklmnopqrstuvwxyz234567',\n  bitsPerChar: 5\n});\nconst base32upper = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.rfc4648)({\n  prefix: 'B',\n  name: 'base32upper',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567',\n  bitsPerChar: 5\n});\nconst base32pad = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.rfc4648)({\n  prefix: 'c',\n  name: 'base32pad',\n  alphabet: 'abcdefghijklmnopqrstuvwxyz234567=',\n  bitsPerChar: 5\n});\nconst base32padupper = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.rfc4648)({\n  prefix: 'C',\n  name: 'base32padupper',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=',\n  bitsPerChar: 5\n});\nconst base32hex = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.rfc4648)({\n  prefix: 'v',\n  name: 'base32hex',\n  alphabet: '0123456789abcdefghijklmnopqrstuv',\n  bitsPerChar: 5\n});\nconst base32hexupper = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.rfc4648)({\n  prefix: 'V',\n  name: 'base32hexupper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV',\n  bitsPerChar: 5\n});\nconst base32hexpad = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.rfc4648)({\n  prefix: 't',\n  name: 'base32hexpad',\n  alphabet: '0123456789abcdefghijklmnopqrstuv=',\n  bitsPerChar: 5\n});\nconst base32hexpadupper = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.rfc4648)({\n  prefix: 'T',\n  name: 'base32hexpadupper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV=',\n  bitsPerChar: 5\n});\nconst base32z = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.rfc4648)({\n  prefix: 'h',\n  name: 'base32z',\n  alphabet: 'ybndrfg8ejkmcpqxot1uwisza345h769',\n  bitsPerChar: 5\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2RpZC1qd3Qvbm9kZV9tb2R1bGVzL211bHRpZm9ybWF0cy9lc20vc3JjL2Jhc2VzL2Jhc2UzMi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQW9DO0FBQzdCLGVBQWUsaURBQU87QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ00sb0JBQW9CLGlEQUFPO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNNLGtCQUFrQixpREFBTztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDTSx1QkFBdUIsaURBQU87QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ00sa0JBQWtCLGlEQUFPO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNNLHVCQUF1QixpREFBTztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDTSxxQkFBcUIsaURBQU87QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ00sMEJBQTBCLGlEQUFPO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNNLGdCQUFnQixpREFBTztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIi9ob21lL2JhcmIvYWEvQXNzb2NpYXRlZEFjY291bnRzL25vZGVfbW9kdWxlcy9kaWQtand0L25vZGVfbW9kdWxlcy9tdWx0aWZvcm1hdHMvZXNtL3NyYy9iYXNlcy9iYXNlMzIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcmZjNDY0OCB9IGZyb20gJy4vYmFzZS5qcyc7XG5leHBvcnQgY29uc3QgYmFzZTMyID0gcmZjNDY0OCh7XG4gIHByZWZpeDogJ2InLFxuICBuYW1lOiAnYmFzZTMyJyxcbiAgYWxwaGFiZXQ6ICdhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejIzNDU2NycsXG4gIGJpdHNQZXJDaGFyOiA1XG59KTtcbmV4cG9ydCBjb25zdCBiYXNlMzJ1cHBlciA9IHJmYzQ2NDgoe1xuICBwcmVmaXg6ICdCJyxcbiAgbmFtZTogJ2Jhc2UzMnVwcGVyJyxcbiAgYWxwaGFiZXQ6ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWjIzNDU2NycsXG4gIGJpdHNQZXJDaGFyOiA1XG59KTtcbmV4cG9ydCBjb25zdCBiYXNlMzJwYWQgPSByZmM0NjQ4KHtcbiAgcHJlZml4OiAnYycsXG4gIG5hbWU6ICdiYXNlMzJwYWQnLFxuICBhbHBoYWJldDogJ2FiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MjM0NTY3PScsXG4gIGJpdHNQZXJDaGFyOiA1XG59KTtcbmV4cG9ydCBjb25zdCBiYXNlMzJwYWR1cHBlciA9IHJmYzQ2NDgoe1xuICBwcmVmaXg6ICdDJyxcbiAgbmFtZTogJ2Jhc2UzMnBhZHVwcGVyJyxcbiAgYWxwaGFiZXQ6ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWjIzNDU2Nz0nLFxuICBiaXRzUGVyQ2hhcjogNVxufSk7XG5leHBvcnQgY29uc3QgYmFzZTMyaGV4ID0gcmZjNDY0OCh7XG4gIHByZWZpeDogJ3YnLFxuICBuYW1lOiAnYmFzZTMyaGV4JyxcbiAgYWxwaGFiZXQ6ICcwMTIzNDU2Nzg5YWJjZGVmZ2hpamtsbW5vcHFyc3R1dicsXG4gIGJpdHNQZXJDaGFyOiA1XG59KTtcbmV4cG9ydCBjb25zdCBiYXNlMzJoZXh1cHBlciA9IHJmYzQ2NDgoe1xuICBwcmVmaXg6ICdWJyxcbiAgbmFtZTogJ2Jhc2UzMmhleHVwcGVyJyxcbiAgYWxwaGFiZXQ6ICcwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVicsXG4gIGJpdHNQZXJDaGFyOiA1XG59KTtcbmV4cG9ydCBjb25zdCBiYXNlMzJoZXhwYWQgPSByZmM0NjQ4KHtcbiAgcHJlZml4OiAndCcsXG4gIG5hbWU6ICdiYXNlMzJoZXhwYWQnLFxuICBhbHBoYWJldDogJzAxMjM0NTY3ODlhYmNkZWZnaGlqa2xtbm9wcXJzdHV2PScsXG4gIGJpdHNQZXJDaGFyOiA1XG59KTtcbmV4cG9ydCBjb25zdCBiYXNlMzJoZXhwYWR1cHBlciA9IHJmYzQ2NDgoe1xuICBwcmVmaXg6ICdUJyxcbiAgbmFtZTogJ2Jhc2UzMmhleHBhZHVwcGVyJyxcbiAgYWxwaGFiZXQ6ICcwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVj0nLFxuICBiaXRzUGVyQ2hhcjogNVxufSk7XG5leHBvcnQgY29uc3QgYmFzZTMyeiA9IHJmYzQ2NDgoe1xuICBwcmVmaXg6ICdoJyxcbiAgbmFtZTogJ2Jhc2UzMnonLFxuICBhbHBoYWJldDogJ3libmRyZmc4ZWprbWNwcXhvdDF1d2lzemEzNDVoNzY5JyxcbiAgYml0c1BlckNoYXI6IDVcbn0pOyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/did-jwt/node_modules/multiformats/esm/src/bases/base32.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/did-jwt/node_modules/multiformats/esm/src/bases/base36.js":
/*!************************************************************************************!*\
  !*** ../../node_modules/did-jwt/node_modules/multiformats/esm/src/bases/base36.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   base36: () => (/* binding */ base36),\n/* harmony export */   base36upper: () => (/* binding */ base36upper)\n/* harmony export */ });\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ \"(rsc)/../../node_modules/did-jwt/node_modules/multiformats/esm/src/bases/base.js\");\n\nconst base36 = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.baseX)({\n  prefix: 'k',\n  name: 'base36',\n  alphabet: '0123456789abcdefghijklmnopqrstuvwxyz'\n});\nconst base36upper = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.baseX)({\n  prefix: 'K',\n  name: 'base36upper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2RpZC1qd3Qvbm9kZV9tb2R1bGVzL211bHRpZm9ybWF0cy9lc20vc3JjL2Jhc2VzL2Jhc2UzNi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBa0M7QUFDM0IsZUFBZSwrQ0FBSztBQUMzQjtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ00sb0JBQW9CLCtDQUFLO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIi9ob21lL2JhcmIvYWEvQXNzb2NpYXRlZEFjY291bnRzL25vZGVfbW9kdWxlcy9kaWQtand0L25vZGVfbW9kdWxlcy9tdWx0aWZvcm1hdHMvZXNtL3NyYy9iYXNlcy9iYXNlMzYuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgYmFzZVggfSBmcm9tICcuL2Jhc2UuanMnO1xuZXhwb3J0IGNvbnN0IGJhc2UzNiA9IGJhc2VYKHtcbiAgcHJlZml4OiAnaycsXG4gIG5hbWU6ICdiYXNlMzYnLFxuICBhbHBoYWJldDogJzAxMjM0NTY3ODlhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5eidcbn0pO1xuZXhwb3J0IGNvbnN0IGJhc2UzNnVwcGVyID0gYmFzZVgoe1xuICBwcmVmaXg6ICdLJyxcbiAgbmFtZTogJ2Jhc2UzNnVwcGVyJyxcbiAgYWxwaGFiZXQ6ICcwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVonXG59KTsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/did-jwt/node_modules/multiformats/esm/src/bases/base36.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/did-jwt/node_modules/multiformats/esm/src/bases/base58.js":
/*!************************************************************************************!*\
  !*** ../../node_modules/did-jwt/node_modules/multiformats/esm/src/bases/base58.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   base58btc: () => (/* binding */ base58btc),\n/* harmony export */   base58flickr: () => (/* binding */ base58flickr)\n/* harmony export */ });\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ \"(rsc)/../../node_modules/did-jwt/node_modules/multiformats/esm/src/bases/base.js\");\n\nconst base58btc = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.baseX)({\n  name: 'base58btc',\n  prefix: 'z',\n  alphabet: '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\n});\nconst base58flickr = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.baseX)({\n  name: 'base58flickr',\n  prefix: 'Z',\n  alphabet: '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2RpZC1qd3Qvbm9kZV9tb2R1bGVzL211bHRpZm9ybWF0cy9lc20vc3JjL2Jhc2VzL2Jhc2U1OC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBa0M7QUFDM0Isa0JBQWtCLCtDQUFLO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDTSxxQkFBcUIsK0NBQUs7QUFDakM7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsiL2hvbWUvYmFyYi9hYS9Bc3NvY2lhdGVkQWNjb3VudHMvbm9kZV9tb2R1bGVzL2RpZC1qd3Qvbm9kZV9tb2R1bGVzL211bHRpZm9ybWF0cy9lc20vc3JjL2Jhc2VzL2Jhc2U1OC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBiYXNlWCB9IGZyb20gJy4vYmFzZS5qcyc7XG5leHBvcnQgY29uc3QgYmFzZTU4YnRjID0gYmFzZVgoe1xuICBuYW1lOiAnYmFzZTU4YnRjJyxcbiAgcHJlZml4OiAneicsXG4gIGFscGhhYmV0OiAnMTIzNDU2Nzg5QUJDREVGR0hKS0xNTlBRUlNUVVZXWFlaYWJjZGVmZ2hpamttbm9wcXJzdHV2d3h5eidcbn0pO1xuZXhwb3J0IGNvbnN0IGJhc2U1OGZsaWNrciA9IGJhc2VYKHtcbiAgbmFtZTogJ2Jhc2U1OGZsaWNrcicsXG4gIHByZWZpeDogJ1onLFxuICBhbHBoYWJldDogJzEyMzQ1Njc4OWFiY2RlZmdoaWprbW5vcHFyc3R1dnd4eXpBQkNERUZHSEpLTE1OUFFSU1RVVldYWVonXG59KTsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/did-jwt/node_modules/multiformats/esm/src/bases/base58.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/did-jwt/node_modules/multiformats/esm/src/bases/base64.js":
/*!************************************************************************************!*\
  !*** ../../node_modules/did-jwt/node_modules/multiformats/esm/src/bases/base64.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   base64: () => (/* binding */ base64),\n/* harmony export */   base64pad: () => (/* binding */ base64pad),\n/* harmony export */   base64url: () => (/* binding */ base64url),\n/* harmony export */   base64urlpad: () => (/* binding */ base64urlpad)\n/* harmony export */ });\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ \"(rsc)/../../node_modules/did-jwt/node_modules/multiformats/esm/src/bases/base.js\");\n\nconst base64 = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.rfc4648)({\n  prefix: 'm',\n  name: 'base64',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',\n  bitsPerChar: 6\n});\nconst base64pad = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.rfc4648)({\n  prefix: 'M',\n  name: 'base64pad',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',\n  bitsPerChar: 6\n});\nconst base64url = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.rfc4648)({\n  prefix: 'u',\n  name: 'base64url',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_',\n  bitsPerChar: 6\n});\nconst base64urlpad = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.rfc4648)({\n  prefix: 'U',\n  name: 'base64urlpad',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=',\n  bitsPerChar: 6\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2RpZC1qd3Qvbm9kZV9tb2R1bGVzL211bHRpZm9ybWF0cy9lc20vc3JjL2Jhc2VzL2Jhc2U2NC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFvQztBQUM3QixlQUFlLGlEQUFPO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNNLGtCQUFrQixpREFBTztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDTSxrQkFBa0IsaURBQU87QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ00scUJBQXFCLGlEQUFPO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsiL2hvbWUvYmFyYi9hYS9Bc3NvY2lhdGVkQWNjb3VudHMvbm9kZV9tb2R1bGVzL2RpZC1qd3Qvbm9kZV9tb2R1bGVzL211bHRpZm9ybWF0cy9lc20vc3JjL2Jhc2VzL2Jhc2U2NC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyByZmM0NjQ4IH0gZnJvbSAnLi9iYXNlLmpzJztcbmV4cG9ydCBjb25zdCBiYXNlNjQgPSByZmM0NjQ4KHtcbiAgcHJlZml4OiAnbScsXG4gIG5hbWU6ICdiYXNlNjQnLFxuICBhbHBoYWJldDogJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nLFxuICBiaXRzUGVyQ2hhcjogNlxufSk7XG5leHBvcnQgY29uc3QgYmFzZTY0cGFkID0gcmZjNDY0OCh7XG4gIHByZWZpeDogJ00nLFxuICBuYW1lOiAnYmFzZTY0cGFkJyxcbiAgYWxwaGFiZXQ6ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvPScsXG4gIGJpdHNQZXJDaGFyOiA2XG59KTtcbmV4cG9ydCBjb25zdCBiYXNlNjR1cmwgPSByZmM0NjQ4KHtcbiAgcHJlZml4OiAndScsXG4gIG5hbWU6ICdiYXNlNjR1cmwnLFxuICBhbHBoYWJldDogJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5LV8nLFxuICBiaXRzUGVyQ2hhcjogNlxufSk7XG5leHBvcnQgY29uc3QgYmFzZTY0dXJscGFkID0gcmZjNDY0OCh7XG4gIHByZWZpeDogJ1UnLFxuICBuYW1lOiAnYmFzZTY0dXJscGFkJyxcbiAgYWxwaGFiZXQ6ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OS1fPScsXG4gIGJpdHNQZXJDaGFyOiA2XG59KTsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/did-jwt/node_modules/multiformats/esm/src/bases/base64.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/did-jwt/node_modules/multiformats/esm/src/bases/base8.js":
/*!***********************************************************************************!*\
  !*** ../../node_modules/did-jwt/node_modules/multiformats/esm/src/bases/base8.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   base8: () => (/* binding */ base8)\n/* harmony export */ });\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ \"(rsc)/../../node_modules/did-jwt/node_modules/multiformats/esm/src/bases/base.js\");\n\nconst base8 = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.rfc4648)({\n  prefix: '7',\n  name: 'base8',\n  alphabet: '01234567',\n  bitsPerChar: 3\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2RpZC1qd3Qvbm9kZV9tb2R1bGVzL211bHRpZm9ybWF0cy9lc20vc3JjL2Jhc2VzL2Jhc2U4LmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQW9DO0FBQzdCLGNBQWMsaURBQU87QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwic291cmNlcyI6WyIvaG9tZS9iYXJiL2FhL0Fzc29jaWF0ZWRBY2NvdW50cy9ub2RlX21vZHVsZXMvZGlkLWp3dC9ub2RlX21vZHVsZXMvbXVsdGlmb3JtYXRzL2VzbS9zcmMvYmFzZXMvYmFzZTguanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcmZjNDY0OCB9IGZyb20gJy4vYmFzZS5qcyc7XG5leHBvcnQgY29uc3QgYmFzZTggPSByZmM0NjQ4KHtcbiAgcHJlZml4OiAnNycsXG4gIG5hbWU6ICdiYXNlOCcsXG4gIGFscGhhYmV0OiAnMDEyMzQ1NjcnLFxuICBiaXRzUGVyQ2hhcjogM1xufSk7Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/did-jwt/node_modules/multiformats/esm/src/bases/base8.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/did-jwt/node_modules/multiformats/esm/src/bases/identity.js":
/*!**************************************************************************************!*\
  !*** ../../node_modules/did-jwt/node_modules/multiformats/esm/src/bases/identity.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   identity: () => (/* binding */ identity)\n/* harmony export */ });\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ \"(rsc)/../../node_modules/did-jwt/node_modules/multiformats/esm/src/bases/base.js\");\n/* harmony import */ var _bytes_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../bytes.js */ \"(rsc)/../../node_modules/did-jwt/node_modules/multiformats/esm/src/bytes.js\");\n\n\nconst identity = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.from)({\n  prefix: '\\0',\n  name: 'identity',\n  encode: buf => (0,_bytes_js__WEBPACK_IMPORTED_MODULE_1__.toString)(buf),\n  decode: str => (0,_bytes_js__WEBPACK_IMPORTED_MODULE_1__.fromString)(str)\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2RpZC1qd3Qvbm9kZV9tb2R1bGVzL211bHRpZm9ybWF0cy9lc20vc3JjL2Jhc2VzL2lkZW50aXR5LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFpQztBQUlaO0FBQ2QsaUJBQWlCLDhDQUFJO0FBQzVCO0FBQ0E7QUFDQSxpQkFBaUIsbURBQVE7QUFDekIsaUJBQWlCLHFEQUFVO0FBQzNCLENBQUMiLCJzb3VyY2VzIjpbIi9ob21lL2JhcmIvYWEvQXNzb2NpYXRlZEFjY291bnRzL25vZGVfbW9kdWxlcy9kaWQtand0L25vZGVfbW9kdWxlcy9tdWx0aWZvcm1hdHMvZXNtL3NyYy9iYXNlcy9pZGVudGl0eS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBmcm9tIH0gZnJvbSAnLi9iYXNlLmpzJztcbmltcG9ydCB7XG4gIGZyb21TdHJpbmcsXG4gIHRvU3RyaW5nXG59IGZyb20gJy4uL2J5dGVzLmpzJztcbmV4cG9ydCBjb25zdCBpZGVudGl0eSA9IGZyb20oe1xuICBwcmVmaXg6ICdcXDAnLFxuICBuYW1lOiAnaWRlbnRpdHknLFxuICBlbmNvZGU6IGJ1ZiA9PiB0b1N0cmluZyhidWYpLFxuICBkZWNvZGU6IHN0ciA9PiBmcm9tU3RyaW5nKHN0cilcbn0pOyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/did-jwt/node_modules/multiformats/esm/src/bases/identity.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/did-jwt/node_modules/multiformats/esm/src/basics.js":
/*!******************************************************************************!*\
  !*** ../../node_modules/did-jwt/node_modules/multiformats/esm/src/basics.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CID: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_14__.CID),\n/* harmony export */   bases: () => (/* binding */ bases),\n/* harmony export */   bytes: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_14__.bytes),\n/* harmony export */   codecs: () => (/* binding */ codecs),\n/* harmony export */   digest: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_14__.digest),\n/* harmony export */   hasher: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_14__.hasher),\n/* harmony export */   hashes: () => (/* binding */ hashes),\n/* harmony export */   varint: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_14__.varint)\n/* harmony export */ });\n/* harmony import */ var _bases_identity_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bases/identity.js */ \"(rsc)/../../node_modules/did-jwt/node_modules/multiformats/esm/src/bases/identity.js\");\n/* harmony import */ var _bases_base2_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./bases/base2.js */ \"(rsc)/../../node_modules/did-jwt/node_modules/multiformats/esm/src/bases/base2.js\");\n/* harmony import */ var _bases_base8_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./bases/base8.js */ \"(rsc)/../../node_modules/did-jwt/node_modules/multiformats/esm/src/bases/base8.js\");\n/* harmony import */ var _bases_base10_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./bases/base10.js */ \"(rsc)/../../node_modules/did-jwt/node_modules/multiformats/esm/src/bases/base10.js\");\n/* harmony import */ var _bases_base16_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./bases/base16.js */ \"(rsc)/../../node_modules/did-jwt/node_modules/multiformats/esm/src/bases/base16.js\");\n/* harmony import */ var _bases_base32_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./bases/base32.js */ \"(rsc)/../../node_modules/did-jwt/node_modules/multiformats/esm/src/bases/base32.js\");\n/* harmony import */ var _bases_base36_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./bases/base36.js */ \"(rsc)/../../node_modules/did-jwt/node_modules/multiformats/esm/src/bases/base36.js\");\n/* harmony import */ var _bases_base58_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./bases/base58.js */ \"(rsc)/../../node_modules/did-jwt/node_modules/multiformats/esm/src/bases/base58.js\");\n/* harmony import */ var _bases_base64_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./bases/base64.js */ \"(rsc)/../../node_modules/did-jwt/node_modules/multiformats/esm/src/bases/base64.js\");\n/* harmony import */ var _bases_base256emoji_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./bases/base256emoji.js */ \"(rsc)/../../node_modules/did-jwt/node_modules/multiformats/esm/src/bases/base256emoji.js\");\n/* harmony import */ var _hashes_sha2_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./hashes/sha2.js */ \"(rsc)/../../node_modules/did-jwt/node_modules/multiformats/esm/src/hashes/sha2.js\");\n/* harmony import */ var _hashes_identity_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./hashes/identity.js */ \"(rsc)/../../node_modules/did-jwt/node_modules/multiformats/esm/src/hashes/identity.js\");\n/* harmony import */ var _codecs_raw_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./codecs/raw.js */ \"(rsc)/../../node_modules/did-jwt/node_modules/multiformats/esm/src/codecs/raw.js\");\n/* harmony import */ var _codecs_json_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./codecs/json.js */ \"(rsc)/../../node_modules/did-jwt/node_modules/multiformats/esm/src/codecs/json.js\");\n/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./index.js */ \"(rsc)/../../node_modules/did-jwt/node_modules/multiformats/esm/src/index.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst bases = {\n  ..._bases_identity_js__WEBPACK_IMPORTED_MODULE_0__,\n  ..._bases_base2_js__WEBPACK_IMPORTED_MODULE_1__,\n  ..._bases_base8_js__WEBPACK_IMPORTED_MODULE_2__,\n  ..._bases_base10_js__WEBPACK_IMPORTED_MODULE_3__,\n  ..._bases_base16_js__WEBPACK_IMPORTED_MODULE_4__,\n  ..._bases_base32_js__WEBPACK_IMPORTED_MODULE_5__,\n  ..._bases_base36_js__WEBPACK_IMPORTED_MODULE_6__,\n  ..._bases_base58_js__WEBPACK_IMPORTED_MODULE_7__,\n  ..._bases_base64_js__WEBPACK_IMPORTED_MODULE_8__,\n  ..._bases_base256emoji_js__WEBPACK_IMPORTED_MODULE_9__\n};\nconst hashes = {\n  ..._hashes_sha2_js__WEBPACK_IMPORTED_MODULE_10__,\n  ..._hashes_identity_js__WEBPACK_IMPORTED_MODULE_11__\n};\nconst codecs = {\n  raw: _codecs_raw_js__WEBPACK_IMPORTED_MODULE_12__,\n  json: _codecs_json_js__WEBPACK_IMPORTED_MODULE_13__\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2RpZC1qd3Qvbm9kZV9tb2R1bGVzL211bHRpZm9ybWF0cy9lc20vc3JjL2Jhc2ljcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFvRDtBQUNWO0FBQ0E7QUFDRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDWTtBQUNmO0FBQ1E7QUFDVjtBQUNFO0FBT3JCO0FBQ3BCO0FBQ0EsS0FBSywrQ0FBWTtBQUNqQixLQUFLLDRDQUFLO0FBQ1YsS0FBSyw0Q0FBSztBQUNWLEtBQUssNkNBQU07QUFDWCxLQUFLLDZDQUFNO0FBQ1gsS0FBSyw2Q0FBTTtBQUNYLEtBQUssNkNBQU07QUFDWCxLQUFLLDZDQUFNO0FBQ1gsS0FBSyw2Q0FBTTtBQUNYLEtBQUssbURBQVk7QUFDakI7QUFDQTtBQUNBLEtBQUssNkNBQUk7QUFDVCxLQUFLLGlEQUFRO0FBQ2I7QUFDQTtBQUNBLEtBQUs7QUFDTCxNQUFNO0FBQ04iLCJzb3VyY2VzIjpbIi9ob21lL2JhcmIvYWEvQXNzb2NpYXRlZEFjY291bnRzL25vZGVfbW9kdWxlcy9kaWQtand0L25vZGVfbW9kdWxlcy9tdWx0aWZvcm1hdHMvZXNtL3NyYy9iYXNpY3MuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgaWRlbnRpdHlCYXNlIGZyb20gJy4vYmFzZXMvaWRlbnRpdHkuanMnO1xuaW1wb3J0ICogYXMgYmFzZTIgZnJvbSAnLi9iYXNlcy9iYXNlMi5qcyc7XG5pbXBvcnQgKiBhcyBiYXNlOCBmcm9tICcuL2Jhc2VzL2Jhc2U4LmpzJztcbmltcG9ydCAqIGFzIGJhc2UxMCBmcm9tICcuL2Jhc2VzL2Jhc2UxMC5qcyc7XG5pbXBvcnQgKiBhcyBiYXNlMTYgZnJvbSAnLi9iYXNlcy9iYXNlMTYuanMnO1xuaW1wb3J0ICogYXMgYmFzZTMyIGZyb20gJy4vYmFzZXMvYmFzZTMyLmpzJztcbmltcG9ydCAqIGFzIGJhc2UzNiBmcm9tICcuL2Jhc2VzL2Jhc2UzNi5qcyc7XG5pbXBvcnQgKiBhcyBiYXNlNTggZnJvbSAnLi9iYXNlcy9iYXNlNTguanMnO1xuaW1wb3J0ICogYXMgYmFzZTY0IGZyb20gJy4vYmFzZXMvYmFzZTY0LmpzJztcbmltcG9ydCAqIGFzIGJhc2UyNTZlbW9qaSBmcm9tICcuL2Jhc2VzL2Jhc2UyNTZlbW9qaS5qcyc7XG5pbXBvcnQgKiBhcyBzaGEyIGZyb20gJy4vaGFzaGVzL3NoYTIuanMnO1xuaW1wb3J0ICogYXMgaWRlbnRpdHkgZnJvbSAnLi9oYXNoZXMvaWRlbnRpdHkuanMnO1xuaW1wb3J0ICogYXMgcmF3IGZyb20gJy4vY29kZWNzL3Jhdy5qcyc7XG5pbXBvcnQgKiBhcyBqc29uIGZyb20gJy4vY29kZWNzL2pzb24uanMnO1xuaW1wb3J0IHtcbiAgQ0lELFxuICBoYXNoZXIsXG4gIGRpZ2VzdCxcbiAgdmFyaW50LFxuICBieXRlc1xufSBmcm9tICcuL2luZGV4LmpzJztcbmNvbnN0IGJhc2VzID0ge1xuICAuLi5pZGVudGl0eUJhc2UsXG4gIC4uLmJhc2UyLFxuICAuLi5iYXNlOCxcbiAgLi4uYmFzZTEwLFxuICAuLi5iYXNlMTYsXG4gIC4uLmJhc2UzMixcbiAgLi4uYmFzZTM2LFxuICAuLi5iYXNlNTgsXG4gIC4uLmJhc2U2NCxcbiAgLi4uYmFzZTI1NmVtb2ppXG59O1xuY29uc3QgaGFzaGVzID0ge1xuICAuLi5zaGEyLFxuICAuLi5pZGVudGl0eVxufTtcbmNvbnN0IGNvZGVjcyA9IHtcbiAgcmF3LFxuICBqc29uXG59O1xuZXhwb3J0IHtcbiAgQ0lELFxuICBoYXNoZXIsXG4gIGRpZ2VzdCxcbiAgdmFyaW50LFxuICBieXRlcyxcbiAgaGFzaGVzLFxuICBiYXNlcyxcbiAgY29kZWNzXG59OyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/did-jwt/node_modules/multiformats/esm/src/basics.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/did-jwt/node_modules/multiformats/esm/src/bytes.js":
/*!*****************************************************************************!*\
  !*** ../../node_modules/did-jwt/node_modules/multiformats/esm/src/bytes.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   coerce: () => (/* binding */ coerce),\n/* harmony export */   empty: () => (/* binding */ empty),\n/* harmony export */   equals: () => (/* binding */ equals),\n/* harmony export */   fromHex: () => (/* binding */ fromHex),\n/* harmony export */   fromString: () => (/* binding */ fromString),\n/* harmony export */   isBinary: () => (/* binding */ isBinary),\n/* harmony export */   toHex: () => (/* binding */ toHex),\n/* harmony export */   toString: () => (/* binding */ toString)\n/* harmony export */ });\nconst empty = new Uint8Array(0);\nconst toHex = d => d.reduce((hex, byte) => hex + byte.toString(16).padStart(2, '0'), '');\nconst fromHex = hex => {\n  const hexes = hex.match(/../g);\n  return hexes ? new Uint8Array(hexes.map(b => parseInt(b, 16))) : empty;\n};\nconst equals = (aa, bb) => {\n  if (aa === bb)\n    return true;\n  if (aa.byteLength !== bb.byteLength) {\n    return false;\n  }\n  for (let ii = 0; ii < aa.byteLength; ii++) {\n    if (aa[ii] !== bb[ii]) {\n      return false;\n    }\n  }\n  return true;\n};\nconst coerce = o => {\n  if (o instanceof Uint8Array && o.constructor.name === 'Uint8Array')\n    return o;\n  if (o instanceof ArrayBuffer)\n    return new Uint8Array(o);\n  if (ArrayBuffer.isView(o)) {\n    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);\n  }\n  throw new Error('Unknown type, must be binary type');\n};\nconst isBinary = o => o instanceof ArrayBuffer || ArrayBuffer.isView(o);\nconst fromString = str => new TextEncoder().encode(str);\nconst toString = b => new TextDecoder().decode(b);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2RpZC1qd3Qvbm9kZV9tb2R1bGVzL211bHRpZm9ybWF0cy9lc20vc3JjL2J5dGVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG9CQUFvQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvYmFyYi9hYS9Bc3NvY2lhdGVkQWNjb3VudHMvbm9kZV9tb2R1bGVzL2RpZC1qd3Qvbm9kZV9tb2R1bGVzL211bHRpZm9ybWF0cy9lc20vc3JjL2J5dGVzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGVtcHR5ID0gbmV3IFVpbnQ4QXJyYXkoMCk7XG5jb25zdCB0b0hleCA9IGQgPT4gZC5yZWR1Y2UoKGhleCwgYnl0ZSkgPT4gaGV4ICsgYnl0ZS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKSwgJycpO1xuY29uc3QgZnJvbUhleCA9IGhleCA9PiB7XG4gIGNvbnN0IGhleGVzID0gaGV4Lm1hdGNoKC8uLi9nKTtcbiAgcmV0dXJuIGhleGVzID8gbmV3IFVpbnQ4QXJyYXkoaGV4ZXMubWFwKGIgPT4gcGFyc2VJbnQoYiwgMTYpKSkgOiBlbXB0eTtcbn07XG5jb25zdCBlcXVhbHMgPSAoYWEsIGJiKSA9PiB7XG4gIGlmIChhYSA9PT0gYmIpXG4gICAgcmV0dXJuIHRydWU7XG4gIGlmIChhYS5ieXRlTGVuZ3RoICE9PSBiYi5ieXRlTGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZvciAobGV0IGlpID0gMDsgaWkgPCBhYS5ieXRlTGVuZ3RoOyBpaSsrKSB7XG4gICAgaWYgKGFhW2lpXSAhPT0gYmJbaWldKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufTtcbmNvbnN0IGNvZXJjZSA9IG8gPT4ge1xuICBpZiAobyBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgJiYgby5jb25zdHJ1Y3Rvci5uYW1lID09PSAnVWludDhBcnJheScpXG4gICAgcmV0dXJuIG87XG4gIGlmIChvIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpXG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KG8pO1xuICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KG8pKSB7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KG8uYnVmZmVyLCBvLmJ5dGVPZmZzZXQsIG8uYnl0ZUxlbmd0aCk7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHR5cGUsIG11c3QgYmUgYmluYXJ5IHR5cGUnKTtcbn07XG5jb25zdCBpc0JpbmFyeSA9IG8gPT4gbyBpbnN0YW5jZW9mIEFycmF5QnVmZmVyIHx8IEFycmF5QnVmZmVyLmlzVmlldyhvKTtcbmNvbnN0IGZyb21TdHJpbmcgPSBzdHIgPT4gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHN0cik7XG5jb25zdCB0b1N0cmluZyA9IGIgPT4gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKGIpO1xuZXhwb3J0IHtcbiAgZXF1YWxzLFxuICBjb2VyY2UsXG4gIGlzQmluYXJ5LFxuICBmcm9tSGV4LFxuICB0b0hleCxcbiAgZnJvbVN0cmluZyxcbiAgdG9TdHJpbmcsXG4gIGVtcHR5XG59OyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/did-jwt/node_modules/multiformats/esm/src/bytes.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/did-jwt/node_modules/multiformats/esm/src/cid.js":
/*!***************************************************************************!*\
  !*** ../../node_modules/did-jwt/node_modules/multiformats/esm/src/cid.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CID: () => (/* binding */ CID)\n/* harmony export */ });\n/* harmony import */ var _varint_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./varint.js */ \"(rsc)/../../node_modules/did-jwt/node_modules/multiformats/esm/src/varint.js\");\n/* harmony import */ var _hashes_digest_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./hashes/digest.js */ \"(rsc)/../../node_modules/did-jwt/node_modules/multiformats/esm/src/hashes/digest.js\");\n/* harmony import */ var _bases_base58_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./bases/base58.js */ \"(rsc)/../../node_modules/did-jwt/node_modules/multiformats/esm/src/bases/base58.js\");\n/* harmony import */ var _bases_base32_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./bases/base32.js */ \"(rsc)/../../node_modules/did-jwt/node_modules/multiformats/esm/src/bases/base32.js\");\n/* harmony import */ var _bytes_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./bytes.js */ \"(rsc)/../../node_modules/did-jwt/node_modules/multiformats/esm/src/bytes.js\");\n\n\n\n\n\nclass CID {\n  constructor(version, code, multihash, bytes) {\n    this.code = code;\n    this.version = version;\n    this.multihash = multihash;\n    this.bytes = bytes;\n    this.byteOffset = bytes.byteOffset;\n    this.byteLength = bytes.byteLength;\n    this.asCID = this;\n    this._baseCache = new Map();\n    Object.defineProperties(this, {\n      byteOffset: hidden,\n      byteLength: hidden,\n      code: readonly,\n      version: readonly,\n      multihash: readonly,\n      bytes: readonly,\n      _baseCache: hidden,\n      asCID: hidden\n    });\n  }\n  toV0() {\n    switch (this.version) {\n    case 0: {\n        return this;\n      }\n    default: {\n        const {code, multihash} = this;\n        if (code !== DAG_PB_CODE) {\n          throw new Error('Cannot convert a non dag-pb CID to CIDv0');\n        }\n        if (multihash.code !== SHA_256_CODE) {\n          throw new Error('Cannot convert non sha2-256 multihash CID to CIDv0');\n        }\n        return CID.createV0(multihash);\n      }\n    }\n  }\n  toV1() {\n    switch (this.version) {\n    case 0: {\n        const {code, digest} = this.multihash;\n        const multihash = _hashes_digest_js__WEBPACK_IMPORTED_MODULE_1__.create(code, digest);\n        return CID.createV1(this.code, multihash);\n      }\n    case 1: {\n        return this;\n      }\n    default: {\n        throw Error(`Can not convert CID version ${ this.version } to version 0. This is a bug please report`);\n      }\n    }\n  }\n  equals(other) {\n    return other && this.code === other.code && this.version === other.version && _hashes_digest_js__WEBPACK_IMPORTED_MODULE_1__.equals(this.multihash, other.multihash);\n  }\n  toString(base) {\n    const {bytes, version, _baseCache} = this;\n    switch (version) {\n    case 0:\n      return toStringV0(bytes, _baseCache, base || _bases_base58_js__WEBPACK_IMPORTED_MODULE_2__.base58btc.encoder);\n    default:\n      return toStringV1(bytes, _baseCache, base || _bases_base32_js__WEBPACK_IMPORTED_MODULE_3__.base32.encoder);\n    }\n  }\n  toJSON() {\n    return {\n      code: this.code,\n      version: this.version,\n      hash: this.multihash.bytes\n    };\n  }\n  get [Symbol.toStringTag]() {\n    return 'CID';\n  }\n  [Symbol.for('nodejs.util.inspect.custom')]() {\n    return 'CID(' + this.toString() + ')';\n  }\n  static isCID(value) {\n    deprecate(/^0\\.0/, IS_CID_DEPRECATION);\n    return !!(value && (value[cidSymbol] || value.asCID === value));\n  }\n  get toBaseEncodedString() {\n    throw new Error('Deprecated, use .toString()');\n  }\n  get codec() {\n    throw new Error('\"codec\" property is deprecated, use integer \"code\" property instead');\n  }\n  get buffer() {\n    throw new Error('Deprecated .buffer property, use .bytes to get Uint8Array instead');\n  }\n  get multibaseName() {\n    throw new Error('\"multibaseName\" property is deprecated');\n  }\n  get prefix() {\n    throw new Error('\"prefix\" property is deprecated');\n  }\n  static asCID(value) {\n    if (value instanceof CID) {\n      return value;\n    } else if (value != null && value.asCID === value) {\n      const {version, code, multihash, bytes} = value;\n      return new CID(version, code, multihash, bytes || encodeCID(version, code, multihash.bytes));\n    } else if (value != null && value[cidSymbol] === true) {\n      const {version, multihash, code} = value;\n      const digest = _hashes_digest_js__WEBPACK_IMPORTED_MODULE_1__.decode(multihash);\n      return CID.create(version, code, digest);\n    } else {\n      return null;\n    }\n  }\n  static create(version, code, digest) {\n    if (typeof code !== 'number') {\n      throw new Error('String codecs are no longer supported');\n    }\n    switch (version) {\n    case 0: {\n        if (code !== DAG_PB_CODE) {\n          throw new Error(`Version 0 CID must use dag-pb (code: ${ DAG_PB_CODE }) block encoding`);\n        } else {\n          return new CID(version, code, digest, digest.bytes);\n        }\n      }\n    case 1: {\n        const bytes = encodeCID(version, code, digest.bytes);\n        return new CID(version, code, digest, bytes);\n      }\n    default: {\n        throw new Error('Invalid version');\n      }\n    }\n  }\n  static createV0(digest) {\n    return CID.create(0, DAG_PB_CODE, digest);\n  }\n  static createV1(code, digest) {\n    return CID.create(1, code, digest);\n  }\n  static decode(bytes) {\n    const [cid, remainder] = CID.decodeFirst(bytes);\n    if (remainder.length) {\n      throw new Error('Incorrect length');\n    }\n    return cid;\n  }\n  static decodeFirst(bytes) {\n    const specs = CID.inspectBytes(bytes);\n    const prefixSize = specs.size - specs.multihashSize;\n    const multihashBytes = (0,_bytes_js__WEBPACK_IMPORTED_MODULE_4__.coerce)(bytes.subarray(prefixSize, prefixSize + specs.multihashSize));\n    if (multihashBytes.byteLength !== specs.multihashSize) {\n      throw new Error('Incorrect length');\n    }\n    const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);\n    const digest = new _hashes_digest_js__WEBPACK_IMPORTED_MODULE_1__.Digest(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);\n    const cid = specs.version === 0 ? CID.createV0(digest) : CID.createV1(specs.codec, digest);\n    return [\n      cid,\n      bytes.subarray(specs.size)\n    ];\n  }\n  static inspectBytes(initialBytes) {\n    let offset = 0;\n    const next = () => {\n      const [i, length] = _varint_js__WEBPACK_IMPORTED_MODULE_0__.decode(initialBytes.subarray(offset));\n      offset += length;\n      return i;\n    };\n    let version = next();\n    let codec = DAG_PB_CODE;\n    if (version === 18) {\n      version = 0;\n      offset = 0;\n    } else if (version === 1) {\n      codec = next();\n    }\n    if (version !== 0 && version !== 1) {\n      throw new RangeError(`Invalid CID version ${ version }`);\n    }\n    const prefixSize = offset;\n    const multihashCode = next();\n    const digestSize = next();\n    const size = offset + digestSize;\n    const multihashSize = size - prefixSize;\n    return {\n      version,\n      codec,\n      multihashCode,\n      digestSize,\n      multihashSize,\n      size\n    };\n  }\n  static parse(source, base) {\n    const [prefix, bytes] = parseCIDtoBytes(source, base);\n    const cid = CID.decode(bytes);\n    cid._baseCache.set(prefix, source);\n    return cid;\n  }\n}\nconst parseCIDtoBytes = (source, base) => {\n  switch (source[0]) {\n  case 'Q': {\n      const decoder = base || _bases_base58_js__WEBPACK_IMPORTED_MODULE_2__.base58btc;\n      return [\n        _bases_base58_js__WEBPACK_IMPORTED_MODULE_2__.base58btc.prefix,\n        decoder.decode(`${ _bases_base58_js__WEBPACK_IMPORTED_MODULE_2__.base58btc.prefix }${ source }`)\n      ];\n    }\n  case _bases_base58_js__WEBPACK_IMPORTED_MODULE_2__.base58btc.prefix: {\n      const decoder = base || _bases_base58_js__WEBPACK_IMPORTED_MODULE_2__.base58btc;\n      return [\n        _bases_base58_js__WEBPACK_IMPORTED_MODULE_2__.base58btc.prefix,\n        decoder.decode(source)\n      ];\n    }\n  case _bases_base32_js__WEBPACK_IMPORTED_MODULE_3__.base32.prefix: {\n      const decoder = base || _bases_base32_js__WEBPACK_IMPORTED_MODULE_3__.base32;\n      return [\n        _bases_base32_js__WEBPACK_IMPORTED_MODULE_3__.base32.prefix,\n        decoder.decode(source)\n      ];\n    }\n  default: {\n      if (base == null) {\n        throw Error('To parse non base32 or base58btc encoded CID multibase decoder must be provided');\n      }\n      return [\n        source[0],\n        base.decode(source)\n      ];\n    }\n  }\n};\nconst toStringV0 = (bytes, cache, base) => {\n  const {prefix} = base;\n  if (prefix !== _bases_base58_js__WEBPACK_IMPORTED_MODULE_2__.base58btc.prefix) {\n    throw Error(`Cannot string encode V0 in ${ base.name } encoding`);\n  }\n  const cid = cache.get(prefix);\n  if (cid == null) {\n    const cid = base.encode(bytes).slice(1);\n    cache.set(prefix, cid);\n    return cid;\n  } else {\n    return cid;\n  }\n};\nconst toStringV1 = (bytes, cache, base) => {\n  const {prefix} = base;\n  const cid = cache.get(prefix);\n  if (cid == null) {\n    const cid = base.encode(bytes);\n    cache.set(prefix, cid);\n    return cid;\n  } else {\n    return cid;\n  }\n};\nconst DAG_PB_CODE = 112;\nconst SHA_256_CODE = 18;\nconst encodeCID = (version, code, multihash) => {\n  const codeOffset = _varint_js__WEBPACK_IMPORTED_MODULE_0__.encodingLength(version);\n  const hashOffset = codeOffset + _varint_js__WEBPACK_IMPORTED_MODULE_0__.encodingLength(code);\n  const bytes = new Uint8Array(hashOffset + multihash.byteLength);\n  _varint_js__WEBPACK_IMPORTED_MODULE_0__.encodeTo(version, bytes, 0);\n  _varint_js__WEBPACK_IMPORTED_MODULE_0__.encodeTo(code, bytes, codeOffset);\n  bytes.set(multihash, hashOffset);\n  return bytes;\n};\nconst cidSymbol = Symbol.for('@ipld/js-cid/CID');\nconst readonly = {\n  writable: false,\n  configurable: false,\n  enumerable: true\n};\nconst hidden = {\n  writable: false,\n  enumerable: false,\n  configurable: false\n};\nconst version = '0.0.0-dev';\nconst deprecate = (range, message) => {\n  if (range.test(version)) {\n    console.warn(message);\n  } else {\n    throw new Error(message);\n  }\n};\nconst IS_CID_DEPRECATION = `CID.isCID(v) is deprecated and will be removed in the next major release.\nFollowing code pattern:\n\nif (CID.isCID(value)) {\n  doSomethingWithCID(value)\n}\n\nIs replaced with:\n\nconst cid = CID.asCID(value)\nif (cid) {\n  // Make sure to use cid instead of value\n  doSomethingWithCID(cid)\n}\n`;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2RpZC1qd3Qvbm9kZV9tb2R1bGVzL211bHRpZm9ybWF0cy9lc20vc3JjL2NpZC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBc0M7QUFDTztBQUNDO0FBQ0g7QUFDUDtBQUM3QjtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsaUJBQWlCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxjQUFjO0FBQzdCLDBCQUEwQixxREFBYTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsZUFBZTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtGQUFrRixxREFBYTtBQUMvRjtBQUNBO0FBQ0EsV0FBVyw0QkFBNEI7QUFDdkM7QUFDQTtBQUNBLG1EQUFtRCx1REFBUztBQUM1RDtBQUNBLG1EQUFtRCxvREFBTTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixhQUFhLGlDQUFpQztBQUM5QztBQUNBLE1BQU07QUFDTixhQUFhLDBCQUEwQjtBQUN2QyxxQkFBcUIscURBQWE7QUFDbEM7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUsYUFBYTtBQUNoRixVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsaURBQU07QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIscURBQWE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDhDQUFhO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsbURBQW1ELFNBQVM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsdURBQVM7QUFDdkM7QUFDQSxRQUFRLHVEQUFTO0FBQ2pCLDJCQUEyQix1REFBUyxTQUFTLEdBQUcsUUFBUTtBQUN4RDtBQUNBO0FBQ0EsT0FBTyx1REFBUztBQUNoQiw4QkFBOEIsdURBQVM7QUFDdkM7QUFDQSxRQUFRLHVEQUFTO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLE9BQU8sb0RBQU07QUFDYiw4QkFBOEIsb0RBQU07QUFDcEM7QUFDQSxRQUFRLG9EQUFNO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxRQUFRO0FBQ2pCLGlCQUFpQix1REFBUztBQUMxQiwrQ0FBK0MsWUFBWTtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLFFBQVE7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsc0RBQXFCO0FBQzFDLGtDQUFrQyxzREFBcUI7QUFDdkQ7QUFDQSxFQUFFLGdEQUFlO0FBQ2pCLEVBQUUsZ0RBQWU7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvYmFyYi9hYS9Bc3NvY2lhdGVkQWNjb3VudHMvbm9kZV9tb2R1bGVzL2RpZC1qd3Qvbm9kZV9tb2R1bGVzL211bHRpZm9ybWF0cy9lc20vc3JjL2NpZC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyB2YXJpbnQgZnJvbSAnLi92YXJpbnQuanMnO1xuaW1wb3J0ICogYXMgRGlnZXN0IGZyb20gJy4vaGFzaGVzL2RpZ2VzdC5qcyc7XG5pbXBvcnQgeyBiYXNlNThidGMgfSBmcm9tICcuL2Jhc2VzL2Jhc2U1OC5qcyc7XG5pbXBvcnQgeyBiYXNlMzIgfSBmcm9tICcuL2Jhc2VzL2Jhc2UzMi5qcyc7XG5pbXBvcnQgeyBjb2VyY2UgfSBmcm9tICcuL2J5dGVzLmpzJztcbmV4cG9ydCBjbGFzcyBDSUQge1xuICBjb25zdHJ1Y3Rvcih2ZXJzaW9uLCBjb2RlLCBtdWx0aWhhc2gsIGJ5dGVzKSB7XG4gICAgdGhpcy5jb2RlID0gY29kZTtcbiAgICB0aGlzLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgIHRoaXMubXVsdGloYXNoID0gbXVsdGloYXNoO1xuICAgIHRoaXMuYnl0ZXMgPSBieXRlcztcbiAgICB0aGlzLmJ5dGVPZmZzZXQgPSBieXRlcy5ieXRlT2Zmc2V0O1xuICAgIHRoaXMuYnl0ZUxlbmd0aCA9IGJ5dGVzLmJ5dGVMZW5ndGg7XG4gICAgdGhpcy5hc0NJRCA9IHRoaXM7XG4gICAgdGhpcy5fYmFzZUNhY2hlID0gbmV3IE1hcCgpO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcbiAgICAgIGJ5dGVPZmZzZXQ6IGhpZGRlbixcbiAgICAgIGJ5dGVMZW5ndGg6IGhpZGRlbixcbiAgICAgIGNvZGU6IHJlYWRvbmx5LFxuICAgICAgdmVyc2lvbjogcmVhZG9ubHksXG4gICAgICBtdWx0aWhhc2g6IHJlYWRvbmx5LFxuICAgICAgYnl0ZXM6IHJlYWRvbmx5LFxuICAgICAgX2Jhc2VDYWNoZTogaGlkZGVuLFxuICAgICAgYXNDSUQ6IGhpZGRlblxuICAgIH0pO1xuICB9XG4gIHRvVjAoKSB7XG4gICAgc3dpdGNoICh0aGlzLnZlcnNpb24pIHtcbiAgICBjYXNlIDA6IHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgZGVmYXVsdDoge1xuICAgICAgICBjb25zdCB7Y29kZSwgbXVsdGloYXNofSA9IHRoaXM7XG4gICAgICAgIGlmIChjb2RlICE9PSBEQUdfUEJfQ09ERSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNvbnZlcnQgYSBub24gZGFnLXBiIENJRCB0byBDSUR2MCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtdWx0aWhhc2guY29kZSAhPT0gU0hBXzI1Nl9DT0RFKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgY29udmVydCBub24gc2hhMi0yNTYgbXVsdGloYXNoIENJRCB0byBDSUR2MCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBDSUQuY3JlYXRlVjAobXVsdGloYXNoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgdG9WMSgpIHtcbiAgICBzd2l0Y2ggKHRoaXMudmVyc2lvbikge1xuICAgIGNhc2UgMDoge1xuICAgICAgICBjb25zdCB7Y29kZSwgZGlnZXN0fSA9IHRoaXMubXVsdGloYXNoO1xuICAgICAgICBjb25zdCBtdWx0aWhhc2ggPSBEaWdlc3QuY3JlYXRlKGNvZGUsIGRpZ2VzdCk7XG4gICAgICAgIHJldHVybiBDSUQuY3JlYXRlVjEodGhpcy5jb2RlLCBtdWx0aWhhc2gpO1xuICAgICAgfVxuICAgIGNhc2UgMToge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICBkZWZhdWx0OiB7XG4gICAgICAgIHRocm93IEVycm9yKGBDYW4gbm90IGNvbnZlcnQgQ0lEIHZlcnNpb24gJHsgdGhpcy52ZXJzaW9uIH0gdG8gdmVyc2lvbiAwLiBUaGlzIGlzIGEgYnVnIHBsZWFzZSByZXBvcnRgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZXF1YWxzKG90aGVyKSB7XG4gICAgcmV0dXJuIG90aGVyICYmIHRoaXMuY29kZSA9PT0gb3RoZXIuY29kZSAmJiB0aGlzLnZlcnNpb24gPT09IG90aGVyLnZlcnNpb24gJiYgRGlnZXN0LmVxdWFscyh0aGlzLm11bHRpaGFzaCwgb3RoZXIubXVsdGloYXNoKTtcbiAgfVxuICB0b1N0cmluZyhiYXNlKSB7XG4gICAgY29uc3Qge2J5dGVzLCB2ZXJzaW9uLCBfYmFzZUNhY2hlfSA9IHRoaXM7XG4gICAgc3dpdGNoICh2ZXJzaW9uKSB7XG4gICAgY2FzZSAwOlxuICAgICAgcmV0dXJuIHRvU3RyaW5nVjAoYnl0ZXMsIF9iYXNlQ2FjaGUsIGJhc2UgfHwgYmFzZTU4YnRjLmVuY29kZXIpO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gdG9TdHJpbmdWMShieXRlcywgX2Jhc2VDYWNoZSwgYmFzZSB8fCBiYXNlMzIuZW5jb2Rlcik7XG4gICAgfVxuICB9XG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY29kZTogdGhpcy5jb2RlLFxuICAgICAgdmVyc2lvbjogdGhpcy52ZXJzaW9uLFxuICAgICAgaGFzaDogdGhpcy5tdWx0aWhhc2guYnl0ZXNcbiAgICB9O1xuICB9XG4gIGdldCBbU3ltYm9sLnRvU3RyaW5nVGFnXSgpIHtcbiAgICByZXR1cm4gJ0NJRCc7XG4gIH1cbiAgW1N5bWJvbC5mb3IoJ25vZGVqcy51dGlsLmluc3BlY3QuY3VzdG9tJyldKCkge1xuICAgIHJldHVybiAnQ0lEKCcgKyB0aGlzLnRvU3RyaW5nKCkgKyAnKSc7XG4gIH1cbiAgc3RhdGljIGlzQ0lEKHZhbHVlKSB7XG4gICAgZGVwcmVjYXRlKC9eMFxcLjAvLCBJU19DSURfREVQUkVDQVRJT04pO1xuICAgIHJldHVybiAhISh2YWx1ZSAmJiAodmFsdWVbY2lkU3ltYm9sXSB8fCB2YWx1ZS5hc0NJRCA9PT0gdmFsdWUpKTtcbiAgfVxuICBnZXQgdG9CYXNlRW5jb2RlZFN0cmluZygpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0RlcHJlY2F0ZWQsIHVzZSAudG9TdHJpbmcoKScpO1xuICB9XG4gIGdldCBjb2RlYygpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiY29kZWNcIiBwcm9wZXJ0eSBpcyBkZXByZWNhdGVkLCB1c2UgaW50ZWdlciBcImNvZGVcIiBwcm9wZXJ0eSBpbnN0ZWFkJyk7XG4gIH1cbiAgZ2V0IGJ1ZmZlcigpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0RlcHJlY2F0ZWQgLmJ1ZmZlciBwcm9wZXJ0eSwgdXNlIC5ieXRlcyB0byBnZXQgVWludDhBcnJheSBpbnN0ZWFkJyk7XG4gIH1cbiAgZ2V0IG11bHRpYmFzZU5hbWUoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdcIm11bHRpYmFzZU5hbWVcIiBwcm9wZXJ0eSBpcyBkZXByZWNhdGVkJyk7XG4gIH1cbiAgZ2V0IHByZWZpeCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1wicHJlZml4XCIgcHJvcGVydHkgaXMgZGVwcmVjYXRlZCcpO1xuICB9XG4gIHN0YXRpYyBhc0NJRCh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIENJRCkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0gZWxzZSBpZiAodmFsdWUgIT0gbnVsbCAmJiB2YWx1ZS5hc0NJRCA9PT0gdmFsdWUpIHtcbiAgICAgIGNvbnN0IHt2ZXJzaW9uLCBjb2RlLCBtdWx0aWhhc2gsIGJ5dGVzfSA9IHZhbHVlO1xuICAgICAgcmV0dXJuIG5ldyBDSUQodmVyc2lvbiwgY29kZSwgbXVsdGloYXNoLCBieXRlcyB8fCBlbmNvZGVDSUQodmVyc2lvbiwgY29kZSwgbXVsdGloYXNoLmJ5dGVzKSk7XG4gICAgfSBlbHNlIGlmICh2YWx1ZSAhPSBudWxsICYmIHZhbHVlW2NpZFN5bWJvbF0gPT09IHRydWUpIHtcbiAgICAgIGNvbnN0IHt2ZXJzaW9uLCBtdWx0aWhhc2gsIGNvZGV9ID0gdmFsdWU7XG4gICAgICBjb25zdCBkaWdlc3QgPSBEaWdlc3QuZGVjb2RlKG11bHRpaGFzaCk7XG4gICAgICByZXR1cm4gQ0lELmNyZWF0ZSh2ZXJzaW9uLCBjb2RlLCBkaWdlc3QpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cbiAgc3RhdGljIGNyZWF0ZSh2ZXJzaW9uLCBjb2RlLCBkaWdlc3QpIHtcbiAgICBpZiAodHlwZW9mIGNvZGUgIT09ICdudW1iZXInKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1N0cmluZyBjb2RlY3MgYXJlIG5vIGxvbmdlciBzdXBwb3J0ZWQnKTtcbiAgICB9XG4gICAgc3dpdGNoICh2ZXJzaW9uKSB7XG4gICAgY2FzZSAwOiB7XG4gICAgICAgIGlmIChjb2RlICE9PSBEQUdfUEJfQ09ERSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVmVyc2lvbiAwIENJRCBtdXN0IHVzZSBkYWctcGIgKGNvZGU6ICR7IERBR19QQl9DT0RFIH0pIGJsb2NrIGVuY29kaW5nYCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBDSUQodmVyc2lvbiwgY29kZSwgZGlnZXN0LCBkaWdlc3QuYnl0ZXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgY2FzZSAxOiB7XG4gICAgICAgIGNvbnN0IGJ5dGVzID0gZW5jb2RlQ0lEKHZlcnNpb24sIGNvZGUsIGRpZ2VzdC5ieXRlcyk7XG4gICAgICAgIHJldHVybiBuZXcgQ0lEKHZlcnNpb24sIGNvZGUsIGRpZ2VzdCwgYnl0ZXMpO1xuICAgICAgfVxuICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHZlcnNpb24nKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgc3RhdGljIGNyZWF0ZVYwKGRpZ2VzdCkge1xuICAgIHJldHVybiBDSUQuY3JlYXRlKDAsIERBR19QQl9DT0RFLCBkaWdlc3QpO1xuICB9XG4gIHN0YXRpYyBjcmVhdGVWMShjb2RlLCBkaWdlc3QpIHtcbiAgICByZXR1cm4gQ0lELmNyZWF0ZSgxLCBjb2RlLCBkaWdlc3QpO1xuICB9XG4gIHN0YXRpYyBkZWNvZGUoYnl0ZXMpIHtcbiAgICBjb25zdCBbY2lkLCByZW1haW5kZXJdID0gQ0lELmRlY29kZUZpcnN0KGJ5dGVzKTtcbiAgICBpZiAocmVtYWluZGVyLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbmNvcnJlY3QgbGVuZ3RoJyk7XG4gICAgfVxuICAgIHJldHVybiBjaWQ7XG4gIH1cbiAgc3RhdGljIGRlY29kZUZpcnN0KGJ5dGVzKSB7XG4gICAgY29uc3Qgc3BlY3MgPSBDSUQuaW5zcGVjdEJ5dGVzKGJ5dGVzKTtcbiAgICBjb25zdCBwcmVmaXhTaXplID0gc3BlY3Muc2l6ZSAtIHNwZWNzLm11bHRpaGFzaFNpemU7XG4gICAgY29uc3QgbXVsdGloYXNoQnl0ZXMgPSBjb2VyY2UoYnl0ZXMuc3ViYXJyYXkocHJlZml4U2l6ZSwgcHJlZml4U2l6ZSArIHNwZWNzLm11bHRpaGFzaFNpemUpKTtcbiAgICBpZiAobXVsdGloYXNoQnl0ZXMuYnl0ZUxlbmd0aCAhPT0gc3BlY3MubXVsdGloYXNoU2l6ZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbmNvcnJlY3QgbGVuZ3RoJyk7XG4gICAgfVxuICAgIGNvbnN0IGRpZ2VzdEJ5dGVzID0gbXVsdGloYXNoQnl0ZXMuc3ViYXJyYXkoc3BlY3MubXVsdGloYXNoU2l6ZSAtIHNwZWNzLmRpZ2VzdFNpemUpO1xuICAgIGNvbnN0IGRpZ2VzdCA9IG5ldyBEaWdlc3QuRGlnZXN0KHNwZWNzLm11bHRpaGFzaENvZGUsIHNwZWNzLmRpZ2VzdFNpemUsIGRpZ2VzdEJ5dGVzLCBtdWx0aWhhc2hCeXRlcyk7XG4gICAgY29uc3QgY2lkID0gc3BlY3MudmVyc2lvbiA9PT0gMCA/IENJRC5jcmVhdGVWMChkaWdlc3QpIDogQ0lELmNyZWF0ZVYxKHNwZWNzLmNvZGVjLCBkaWdlc3QpO1xuICAgIHJldHVybiBbXG4gICAgICBjaWQsXG4gICAgICBieXRlcy5zdWJhcnJheShzcGVjcy5zaXplKVxuICAgIF07XG4gIH1cbiAgc3RhdGljIGluc3BlY3RCeXRlcyhpbml0aWFsQnl0ZXMpIHtcbiAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICBjb25zdCBuZXh0ID0gKCkgPT4ge1xuICAgICAgY29uc3QgW2ksIGxlbmd0aF0gPSB2YXJpbnQuZGVjb2RlKGluaXRpYWxCeXRlcy5zdWJhcnJheShvZmZzZXQpKTtcbiAgICAgIG9mZnNldCArPSBsZW5ndGg7XG4gICAgICByZXR1cm4gaTtcbiAgICB9O1xuICAgIGxldCB2ZXJzaW9uID0gbmV4dCgpO1xuICAgIGxldCBjb2RlYyA9IERBR19QQl9DT0RFO1xuICAgIGlmICh2ZXJzaW9uID09PSAxOCkge1xuICAgICAgdmVyc2lvbiA9IDA7XG4gICAgICBvZmZzZXQgPSAwO1xuICAgIH0gZWxzZSBpZiAodmVyc2lvbiA9PT0gMSkge1xuICAgICAgY29kZWMgPSBuZXh0KCk7XG4gICAgfVxuICAgIGlmICh2ZXJzaW9uICE9PSAwICYmIHZlcnNpb24gIT09IDEpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBJbnZhbGlkIENJRCB2ZXJzaW9uICR7IHZlcnNpb24gfWApO1xuICAgIH1cbiAgICBjb25zdCBwcmVmaXhTaXplID0gb2Zmc2V0O1xuICAgIGNvbnN0IG11bHRpaGFzaENvZGUgPSBuZXh0KCk7XG4gICAgY29uc3QgZGlnZXN0U2l6ZSA9IG5leHQoKTtcbiAgICBjb25zdCBzaXplID0gb2Zmc2V0ICsgZGlnZXN0U2l6ZTtcbiAgICBjb25zdCBtdWx0aWhhc2hTaXplID0gc2l6ZSAtIHByZWZpeFNpemU7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZlcnNpb24sXG4gICAgICBjb2RlYyxcbiAgICAgIG11bHRpaGFzaENvZGUsXG4gICAgICBkaWdlc3RTaXplLFxuICAgICAgbXVsdGloYXNoU2l6ZSxcbiAgICAgIHNpemVcbiAgICB9O1xuICB9XG4gIHN0YXRpYyBwYXJzZShzb3VyY2UsIGJhc2UpIHtcbiAgICBjb25zdCBbcHJlZml4LCBieXRlc10gPSBwYXJzZUNJRHRvQnl0ZXMoc291cmNlLCBiYXNlKTtcbiAgICBjb25zdCBjaWQgPSBDSUQuZGVjb2RlKGJ5dGVzKTtcbiAgICBjaWQuX2Jhc2VDYWNoZS5zZXQocHJlZml4LCBzb3VyY2UpO1xuICAgIHJldHVybiBjaWQ7XG4gIH1cbn1cbmNvbnN0IHBhcnNlQ0lEdG9CeXRlcyA9IChzb3VyY2UsIGJhc2UpID0+IHtcbiAgc3dpdGNoIChzb3VyY2VbMF0pIHtcbiAgY2FzZSAnUSc6IHtcbiAgICAgIGNvbnN0IGRlY29kZXIgPSBiYXNlIHx8IGJhc2U1OGJ0YztcbiAgICAgIHJldHVybiBbXG4gICAgICAgIGJhc2U1OGJ0Yy5wcmVmaXgsXG4gICAgICAgIGRlY29kZXIuZGVjb2RlKGAkeyBiYXNlNThidGMucHJlZml4IH0keyBzb3VyY2UgfWApXG4gICAgICBdO1xuICAgIH1cbiAgY2FzZSBiYXNlNThidGMucHJlZml4OiB7XG4gICAgICBjb25zdCBkZWNvZGVyID0gYmFzZSB8fCBiYXNlNThidGM7XG4gICAgICByZXR1cm4gW1xuICAgICAgICBiYXNlNThidGMucHJlZml4LFxuICAgICAgICBkZWNvZGVyLmRlY29kZShzb3VyY2UpXG4gICAgICBdO1xuICAgIH1cbiAgY2FzZSBiYXNlMzIucHJlZml4OiB7XG4gICAgICBjb25zdCBkZWNvZGVyID0gYmFzZSB8fCBiYXNlMzI7XG4gICAgICByZXR1cm4gW1xuICAgICAgICBiYXNlMzIucHJlZml4LFxuICAgICAgICBkZWNvZGVyLmRlY29kZShzb3VyY2UpXG4gICAgICBdO1xuICAgIH1cbiAgZGVmYXVsdDoge1xuICAgICAgaWYgKGJhc2UgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBFcnJvcignVG8gcGFyc2Ugbm9uIGJhc2UzMiBvciBiYXNlNThidGMgZW5jb2RlZCBDSUQgbXVsdGliYXNlIGRlY29kZXIgbXVzdCBiZSBwcm92aWRlZCcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFtcbiAgICAgICAgc291cmNlWzBdLFxuICAgICAgICBiYXNlLmRlY29kZShzb3VyY2UpXG4gICAgICBdO1xuICAgIH1cbiAgfVxufTtcbmNvbnN0IHRvU3RyaW5nVjAgPSAoYnl0ZXMsIGNhY2hlLCBiYXNlKSA9PiB7XG4gIGNvbnN0IHtwcmVmaXh9ID0gYmFzZTtcbiAgaWYgKHByZWZpeCAhPT0gYmFzZTU4YnRjLnByZWZpeCkge1xuICAgIHRocm93IEVycm9yKGBDYW5ub3Qgc3RyaW5nIGVuY29kZSBWMCBpbiAkeyBiYXNlLm5hbWUgfSBlbmNvZGluZ2ApO1xuICB9XG4gIGNvbnN0IGNpZCA9IGNhY2hlLmdldChwcmVmaXgpO1xuICBpZiAoY2lkID09IG51bGwpIHtcbiAgICBjb25zdCBjaWQgPSBiYXNlLmVuY29kZShieXRlcykuc2xpY2UoMSk7XG4gICAgY2FjaGUuc2V0KHByZWZpeCwgY2lkKTtcbiAgICByZXR1cm4gY2lkO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBjaWQ7XG4gIH1cbn07XG5jb25zdCB0b1N0cmluZ1YxID0gKGJ5dGVzLCBjYWNoZSwgYmFzZSkgPT4ge1xuICBjb25zdCB7cHJlZml4fSA9IGJhc2U7XG4gIGNvbnN0IGNpZCA9IGNhY2hlLmdldChwcmVmaXgpO1xuICBpZiAoY2lkID09IG51bGwpIHtcbiAgICBjb25zdCBjaWQgPSBiYXNlLmVuY29kZShieXRlcyk7XG4gICAgY2FjaGUuc2V0KHByZWZpeCwgY2lkKTtcbiAgICByZXR1cm4gY2lkO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBjaWQ7XG4gIH1cbn07XG5jb25zdCBEQUdfUEJfQ09ERSA9IDExMjtcbmNvbnN0IFNIQV8yNTZfQ09ERSA9IDE4O1xuY29uc3QgZW5jb2RlQ0lEID0gKHZlcnNpb24sIGNvZGUsIG11bHRpaGFzaCkgPT4ge1xuICBjb25zdCBjb2RlT2Zmc2V0ID0gdmFyaW50LmVuY29kaW5nTGVuZ3RoKHZlcnNpb24pO1xuICBjb25zdCBoYXNoT2Zmc2V0ID0gY29kZU9mZnNldCArIHZhcmludC5lbmNvZGluZ0xlbmd0aChjb2RlKTtcbiAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheShoYXNoT2Zmc2V0ICsgbXVsdGloYXNoLmJ5dGVMZW5ndGgpO1xuICB2YXJpbnQuZW5jb2RlVG8odmVyc2lvbiwgYnl0ZXMsIDApO1xuICB2YXJpbnQuZW5jb2RlVG8oY29kZSwgYnl0ZXMsIGNvZGVPZmZzZXQpO1xuICBieXRlcy5zZXQobXVsdGloYXNoLCBoYXNoT2Zmc2V0KTtcbiAgcmV0dXJuIGJ5dGVzO1xufTtcbmNvbnN0IGNpZFN5bWJvbCA9IFN5bWJvbC5mb3IoJ0BpcGxkL2pzLWNpZC9DSUQnKTtcbmNvbnN0IHJlYWRvbmx5ID0ge1xuICB3cml0YWJsZTogZmFsc2UsXG4gIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gIGVudW1lcmFibGU6IHRydWVcbn07XG5jb25zdCBoaWRkZW4gPSB7XG4gIHdyaXRhYmxlOiBmYWxzZSxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGNvbmZpZ3VyYWJsZTogZmFsc2Vcbn07XG5jb25zdCB2ZXJzaW9uID0gJzAuMC4wLWRldic7XG5jb25zdCBkZXByZWNhdGUgPSAocmFuZ2UsIG1lc3NhZ2UpID0+IHtcbiAgaWYgKHJhbmdlLnRlc3QodmVyc2lvbikpIHtcbiAgICBjb25zb2xlLndhcm4obWVzc2FnZSk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICB9XG59O1xuY29uc3QgSVNfQ0lEX0RFUFJFQ0FUSU9OID0gYENJRC5pc0NJRCh2KSBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgcmVsZWFzZS5cbkZvbGxvd2luZyBjb2RlIHBhdHRlcm46XG5cbmlmIChDSUQuaXNDSUQodmFsdWUpKSB7XG4gIGRvU29tZXRoaW5nV2l0aENJRCh2YWx1ZSlcbn1cblxuSXMgcmVwbGFjZWQgd2l0aDpcblxuY29uc3QgY2lkID0gQ0lELmFzQ0lEKHZhbHVlKVxuaWYgKGNpZCkge1xuICAvLyBNYWtlIHN1cmUgdG8gdXNlIGNpZCBpbnN0ZWFkIG9mIHZhbHVlXG4gIGRvU29tZXRoaW5nV2l0aENJRChjaWQpXG59XG5gOyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/did-jwt/node_modules/multiformats/esm/src/cid.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/did-jwt/node_modules/multiformats/esm/src/codecs/json.js":
/*!***********************************************************************************!*\
  !*** ../../node_modules/did-jwt/node_modules/multiformats/esm/src/codecs/json.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   code: () => (/* binding */ code),\n/* harmony export */   decode: () => (/* binding */ decode),\n/* harmony export */   encode: () => (/* binding */ encode),\n/* harmony export */   name: () => (/* binding */ name)\n/* harmony export */ });\nconst textEncoder = new TextEncoder();\nconst textDecoder = new TextDecoder();\nconst name = 'json';\nconst code = 512;\nconst encode = node => textEncoder.encode(JSON.stringify(node));\nconst decode = data => JSON.parse(textDecoder.decode(data));//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2RpZC1qd3Qvbm9kZV9tb2R1bGVzL211bHRpZm9ybWF0cy9lc20vc3JjL2NvZGVjcy9qc29uLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBO0FBQ087QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL2JhcmIvYWEvQXNzb2NpYXRlZEFjY291bnRzL25vZGVfbW9kdWxlcy9kaWQtand0L25vZGVfbW9kdWxlcy9tdWx0aWZvcm1hdHMvZXNtL3NyYy9jb2RlY3MvanNvbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCB0ZXh0RW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuY29uc3QgdGV4dERlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKTtcbmV4cG9ydCBjb25zdCBuYW1lID0gJ2pzb24nO1xuZXhwb3J0IGNvbnN0IGNvZGUgPSA1MTI7XG5leHBvcnQgY29uc3QgZW5jb2RlID0gbm9kZSA9PiB0ZXh0RW5jb2Rlci5lbmNvZGUoSlNPTi5zdHJpbmdpZnkobm9kZSkpO1xuZXhwb3J0IGNvbnN0IGRlY29kZSA9IGRhdGEgPT4gSlNPTi5wYXJzZSh0ZXh0RGVjb2Rlci5kZWNvZGUoZGF0YSkpOyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/did-jwt/node_modules/multiformats/esm/src/codecs/json.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/did-jwt/node_modules/multiformats/esm/src/codecs/raw.js":
/*!**********************************************************************************!*\
  !*** ../../node_modules/did-jwt/node_modules/multiformats/esm/src/codecs/raw.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   code: () => (/* binding */ code),\n/* harmony export */   decode: () => (/* binding */ decode),\n/* harmony export */   encode: () => (/* binding */ encode),\n/* harmony export */   name: () => (/* binding */ name)\n/* harmony export */ });\n/* harmony import */ var _bytes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../bytes.js */ \"(rsc)/../../node_modules/did-jwt/node_modules/multiformats/esm/src/bytes.js\");\n\nconst name = 'raw';\nconst code = 85;\nconst encode = node => (0,_bytes_js__WEBPACK_IMPORTED_MODULE_0__.coerce)(node);\nconst decode = data => (0,_bytes_js__WEBPACK_IMPORTED_MODULE_0__.coerce)(data);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2RpZC1qd3Qvbm9kZV9tb2R1bGVzL211bHRpZm9ybWF0cy9lc20vc3JjL2NvZGVjcy9yYXcuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBcUM7QUFDOUI7QUFDQTtBQUNBLHVCQUF1QixpREFBTTtBQUM3Qix1QkFBdUIsaURBQU0iLCJzb3VyY2VzIjpbIi9ob21lL2JhcmIvYWEvQXNzb2NpYXRlZEFjY291bnRzL25vZGVfbW9kdWxlcy9kaWQtand0L25vZGVfbW9kdWxlcy9tdWx0aWZvcm1hdHMvZXNtL3NyYy9jb2RlY3MvcmF3LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNvZXJjZSB9IGZyb20gJy4uL2J5dGVzLmpzJztcbmV4cG9ydCBjb25zdCBuYW1lID0gJ3Jhdyc7XG5leHBvcnQgY29uc3QgY29kZSA9IDg1O1xuZXhwb3J0IGNvbnN0IGVuY29kZSA9IG5vZGUgPT4gY29lcmNlKG5vZGUpO1xuZXhwb3J0IGNvbnN0IGRlY29kZSA9IGRhdGEgPT4gY29lcmNlKGRhdGEpOyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/did-jwt/node_modules/multiformats/esm/src/codecs/raw.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/did-jwt/node_modules/multiformats/esm/src/hashes/digest.js":
/*!*************************************************************************************!*\
  !*** ../../node_modules/did-jwt/node_modules/multiformats/esm/src/hashes/digest.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Digest: () => (/* binding */ Digest),\n/* harmony export */   create: () => (/* binding */ create),\n/* harmony export */   decode: () => (/* binding */ decode),\n/* harmony export */   equals: () => (/* binding */ equals)\n/* harmony export */ });\n/* harmony import */ var _bytes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../bytes.js */ \"(rsc)/../../node_modules/did-jwt/node_modules/multiformats/esm/src/bytes.js\");\n/* harmony import */ var _varint_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../varint.js */ \"(rsc)/../../node_modules/did-jwt/node_modules/multiformats/esm/src/varint.js\");\n\n\nconst create = (code, digest) => {\n  const size = digest.byteLength;\n  const sizeOffset = _varint_js__WEBPACK_IMPORTED_MODULE_1__.encodingLength(code);\n  const digestOffset = sizeOffset + _varint_js__WEBPACK_IMPORTED_MODULE_1__.encodingLength(size);\n  const bytes = new Uint8Array(digestOffset + size);\n  _varint_js__WEBPACK_IMPORTED_MODULE_1__.encodeTo(code, bytes, 0);\n  _varint_js__WEBPACK_IMPORTED_MODULE_1__.encodeTo(size, bytes, sizeOffset);\n  bytes.set(digest, digestOffset);\n  return new Digest(code, size, digest, bytes);\n};\nconst decode = multihash => {\n  const bytes = (0,_bytes_js__WEBPACK_IMPORTED_MODULE_0__.coerce)(multihash);\n  const [code, sizeOffset] = _varint_js__WEBPACK_IMPORTED_MODULE_1__.decode(bytes);\n  const [size, digestOffset] = _varint_js__WEBPACK_IMPORTED_MODULE_1__.decode(bytes.subarray(sizeOffset));\n  const digest = bytes.subarray(sizeOffset + digestOffset);\n  if (digest.byteLength !== size) {\n    throw new Error('Incorrect length');\n  }\n  return new Digest(code, size, digest, bytes);\n};\nconst equals = (a, b) => {\n  if (a === b) {\n    return true;\n  } else {\n    return a.code === b.code && a.size === b.size && (0,_bytes_js__WEBPACK_IMPORTED_MODULE_0__.equals)(a.bytes, b.bytes);\n  }\n};\nclass Digest {\n  constructor(code, size, digest, bytes) {\n    this.code = code;\n    this.size = size;\n    this.digest = digest;\n    this.bytes = bytes;\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2RpZC1qd3Qvbm9kZV9tb2R1bGVzL211bHRpZm9ybWF0cy9lc20vc3JjL2hhc2hlcy9kaWdlc3QuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBR3FCO0FBQ2tCO0FBQ2hDO0FBQ1A7QUFDQSxxQkFBcUIsc0RBQXFCO0FBQzFDLG9DQUFvQyxzREFBcUI7QUFDekQ7QUFDQSxFQUFFLGdEQUFlO0FBQ2pCLEVBQUUsZ0RBQWU7QUFDakI7QUFDQTtBQUNBO0FBQ087QUFDUCxnQkFBZ0IsaURBQU07QUFDdEIsNkJBQTZCLDhDQUFhO0FBQzFDLCtCQUErQiw4Q0FBYTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSxJQUFJO0FBQ0oscURBQXFELGlEQUFVO0FBQy9EO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9iYXJiL2FhL0Fzc29jaWF0ZWRBY2NvdW50cy9ub2RlX21vZHVsZXMvZGlkLWp3dC9ub2RlX21vZHVsZXMvbXVsdGlmb3JtYXRzL2VzbS9zcmMvaGFzaGVzL2RpZ2VzdC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBjb2VyY2UsXG4gIGVxdWFscyBhcyBlcXVhbEJ5dGVzXG59IGZyb20gJy4uL2J5dGVzLmpzJztcbmltcG9ydCAqIGFzIHZhcmludCBmcm9tICcuLi92YXJpbnQuanMnO1xuZXhwb3J0IGNvbnN0IGNyZWF0ZSA9IChjb2RlLCBkaWdlc3QpID0+IHtcbiAgY29uc3Qgc2l6ZSA9IGRpZ2VzdC5ieXRlTGVuZ3RoO1xuICBjb25zdCBzaXplT2Zmc2V0ID0gdmFyaW50LmVuY29kaW5nTGVuZ3RoKGNvZGUpO1xuICBjb25zdCBkaWdlc3RPZmZzZXQgPSBzaXplT2Zmc2V0ICsgdmFyaW50LmVuY29kaW5nTGVuZ3RoKHNpemUpO1xuICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KGRpZ2VzdE9mZnNldCArIHNpemUpO1xuICB2YXJpbnQuZW5jb2RlVG8oY29kZSwgYnl0ZXMsIDApO1xuICB2YXJpbnQuZW5jb2RlVG8oc2l6ZSwgYnl0ZXMsIHNpemVPZmZzZXQpO1xuICBieXRlcy5zZXQoZGlnZXN0LCBkaWdlc3RPZmZzZXQpO1xuICByZXR1cm4gbmV3IERpZ2VzdChjb2RlLCBzaXplLCBkaWdlc3QsIGJ5dGVzKTtcbn07XG5leHBvcnQgY29uc3QgZGVjb2RlID0gbXVsdGloYXNoID0+IHtcbiAgY29uc3QgYnl0ZXMgPSBjb2VyY2UobXVsdGloYXNoKTtcbiAgY29uc3QgW2NvZGUsIHNpemVPZmZzZXRdID0gdmFyaW50LmRlY29kZShieXRlcyk7XG4gIGNvbnN0IFtzaXplLCBkaWdlc3RPZmZzZXRdID0gdmFyaW50LmRlY29kZShieXRlcy5zdWJhcnJheShzaXplT2Zmc2V0KSk7XG4gIGNvbnN0IGRpZ2VzdCA9IGJ5dGVzLnN1YmFycmF5KHNpemVPZmZzZXQgKyBkaWdlc3RPZmZzZXQpO1xuICBpZiAoZGlnZXN0LmJ5dGVMZW5ndGggIT09IHNpemUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0luY29ycmVjdCBsZW5ndGgnKTtcbiAgfVxuICByZXR1cm4gbmV3IERpZ2VzdChjb2RlLCBzaXplLCBkaWdlc3QsIGJ5dGVzKTtcbn07XG5leHBvcnQgY29uc3QgZXF1YWxzID0gKGEsIGIpID0+IHtcbiAgaWYgKGEgPT09IGIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYS5jb2RlID09PSBiLmNvZGUgJiYgYS5zaXplID09PSBiLnNpemUgJiYgZXF1YWxCeXRlcyhhLmJ5dGVzLCBiLmJ5dGVzKTtcbiAgfVxufTtcbmV4cG9ydCBjbGFzcyBEaWdlc3Qge1xuICBjb25zdHJ1Y3Rvcihjb2RlLCBzaXplLCBkaWdlc3QsIGJ5dGVzKSB7XG4gICAgdGhpcy5jb2RlID0gY29kZTtcbiAgICB0aGlzLnNpemUgPSBzaXplO1xuICAgIHRoaXMuZGlnZXN0ID0gZGlnZXN0O1xuICAgIHRoaXMuYnl0ZXMgPSBieXRlcztcbiAgfVxufSJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/did-jwt/node_modules/multiformats/esm/src/hashes/digest.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/did-jwt/node_modules/multiformats/esm/src/hashes/hasher.js":
/*!*************************************************************************************!*\
  !*** ../../node_modules/did-jwt/node_modules/multiformats/esm/src/hashes/hasher.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Hasher: () => (/* binding */ Hasher),\n/* harmony export */   from: () => (/* binding */ from)\n/* harmony export */ });\n/* harmony import */ var _digest_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./digest.js */ \"(rsc)/../../node_modules/did-jwt/node_modules/multiformats/esm/src/hashes/digest.js\");\n\nconst from = ({name, code, encode}) => new Hasher(name, code, encode);\nclass Hasher {\n  constructor(name, code, encode) {\n    this.name = name;\n    this.code = code;\n    this.encode = encode;\n  }\n  digest(input) {\n    if (input instanceof Uint8Array) {\n      const result = this.encode(input);\n      return result instanceof Uint8Array ? _digest_js__WEBPACK_IMPORTED_MODULE_0__.create(this.code, result) : result.then(digest => _digest_js__WEBPACK_IMPORTED_MODULE_0__.create(this.code, digest));\n    } else {\n      throw Error('Unknown type, must be binary type');\n    }\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2RpZC1qd3Qvbm9kZV9tb2R1bGVzL211bHRpZm9ybWF0cy9lc20vc3JjL2hhc2hlcy9oYXNoZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQXNDO0FBQy9CLGVBQWUsbUJBQW1CO0FBQ2xDO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0Qyw4Q0FBYSw0Q0FBNEMsOENBQWE7QUFDbEgsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9iYXJiL2FhL0Fzc29jaWF0ZWRBY2NvdW50cy9ub2RlX21vZHVsZXMvZGlkLWp3dC9ub2RlX21vZHVsZXMvbXVsdGlmb3JtYXRzL2VzbS9zcmMvaGFzaGVzL2hhc2hlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBEaWdlc3QgZnJvbSAnLi9kaWdlc3QuanMnO1xuZXhwb3J0IGNvbnN0IGZyb20gPSAoe25hbWUsIGNvZGUsIGVuY29kZX0pID0+IG5ldyBIYXNoZXIobmFtZSwgY29kZSwgZW5jb2RlKTtcbmV4cG9ydCBjbGFzcyBIYXNoZXIge1xuICBjb25zdHJ1Y3RvcihuYW1lLCBjb2RlLCBlbmNvZGUpIHtcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gICAgdGhpcy5lbmNvZGUgPSBlbmNvZGU7XG4gIH1cbiAgZGlnZXN0KGlucHV0KSB7XG4gICAgaWYgKGlucHV0IGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5lbmNvZGUoaW5wdXQpO1xuICAgICAgcmV0dXJuIHJlc3VsdCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgPyBEaWdlc3QuY3JlYXRlKHRoaXMuY29kZSwgcmVzdWx0KSA6IHJlc3VsdC50aGVuKGRpZ2VzdCA9PiBEaWdlc3QuY3JlYXRlKHRoaXMuY29kZSwgZGlnZXN0KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IEVycm9yKCdVbmtub3duIHR5cGUsIG11c3QgYmUgYmluYXJ5IHR5cGUnKTtcbiAgICB9XG4gIH1cbn0iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/did-jwt/node_modules/multiformats/esm/src/hashes/hasher.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/did-jwt/node_modules/multiformats/esm/src/hashes/identity.js":
/*!***************************************************************************************!*\
  !*** ../../node_modules/did-jwt/node_modules/multiformats/esm/src/hashes/identity.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   identity: () => (/* binding */ identity)\n/* harmony export */ });\n/* harmony import */ var _bytes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../bytes.js */ \"(rsc)/../../node_modules/did-jwt/node_modules/multiformats/esm/src/bytes.js\");\n/* harmony import */ var _digest_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./digest.js */ \"(rsc)/../../node_modules/did-jwt/node_modules/multiformats/esm/src/hashes/digest.js\");\n\n\nconst code = 0;\nconst name = 'identity';\nconst encode = _bytes_js__WEBPACK_IMPORTED_MODULE_0__.coerce;\nconst digest = input => _digest_js__WEBPACK_IMPORTED_MODULE_1__.create(code, encode(input));\nconst identity = {\n  code,\n  name,\n  encode,\n  digest\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2RpZC1qd3Qvbm9kZV9tb2R1bGVzL211bHRpZm9ybWF0cy9lc20vc3JjL2hhc2hlcy9pZGVudGl0eS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBcUM7QUFDQztBQUN0QztBQUNBO0FBQ0EsZUFBZSw2Q0FBTTtBQUNyQix3QkFBd0IsOENBQWE7QUFDOUI7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9iYXJiL2FhL0Fzc29jaWF0ZWRBY2NvdW50cy9ub2RlX21vZHVsZXMvZGlkLWp3dC9ub2RlX21vZHVsZXMvbXVsdGlmb3JtYXRzL2VzbS9zcmMvaGFzaGVzL2lkZW50aXR5LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNvZXJjZSB9IGZyb20gJy4uL2J5dGVzLmpzJztcbmltcG9ydCAqIGFzIERpZ2VzdCBmcm9tICcuL2RpZ2VzdC5qcyc7XG5jb25zdCBjb2RlID0gMDtcbmNvbnN0IG5hbWUgPSAnaWRlbnRpdHknO1xuY29uc3QgZW5jb2RlID0gY29lcmNlO1xuY29uc3QgZGlnZXN0ID0gaW5wdXQgPT4gRGlnZXN0LmNyZWF0ZShjb2RlLCBlbmNvZGUoaW5wdXQpKTtcbmV4cG9ydCBjb25zdCBpZGVudGl0eSA9IHtcbiAgY29kZSxcbiAgbmFtZSxcbiAgZW5jb2RlLFxuICBkaWdlc3Rcbn07Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/did-jwt/node_modules/multiformats/esm/src/hashes/identity.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/did-jwt/node_modules/multiformats/esm/src/hashes/sha2.js":
/*!***********************************************************************************!*\
  !*** ../../node_modules/did-jwt/node_modules/multiformats/esm/src/hashes/sha2.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   sha256: () => (/* binding */ sha256),\n/* harmony export */   sha512: () => (/* binding */ sha512)\n/* harmony export */ });\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! crypto */ \"crypto\");\n/* harmony import */ var _hasher_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./hasher.js */ \"(rsc)/../../node_modules/did-jwt/node_modules/multiformats/esm/src/hashes/hasher.js\");\n/* harmony import */ var _bytes_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../bytes.js */ \"(rsc)/../../node_modules/did-jwt/node_modules/multiformats/esm/src/bytes.js\");\n\n\n\nconst sha256 = (0,_hasher_js__WEBPACK_IMPORTED_MODULE_1__.from)({\n  name: 'sha2-256',\n  code: 18,\n  encode: input => (0,_bytes_js__WEBPACK_IMPORTED_MODULE_2__.coerce)(crypto__WEBPACK_IMPORTED_MODULE_0__.createHash('sha256').update(input).digest())\n});\nconst sha512 = (0,_hasher_js__WEBPACK_IMPORTED_MODULE_1__.from)({\n  name: 'sha2-512',\n  code: 19,\n  encode: input => (0,_bytes_js__WEBPACK_IMPORTED_MODULE_2__.coerce)(crypto__WEBPACK_IMPORTED_MODULE_0__.createHash('sha512').update(input).digest())\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2RpZC1qd3Qvbm9kZV9tb2R1bGVzL211bHRpZm9ybWF0cy9lc20vc3JjL2hhc2hlcy9zaGEyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQTRCO0FBQ087QUFDRTtBQUM5QixlQUFlLGdEQUFJO0FBQzFCO0FBQ0E7QUFDQSxtQkFBbUIsaURBQU0sQ0FBQyw4Q0FBaUI7QUFDM0MsQ0FBQztBQUNNLGVBQWUsZ0RBQUk7QUFDMUI7QUFDQTtBQUNBLG1CQUFtQixpREFBTSxDQUFDLDhDQUFpQjtBQUMzQyxDQUFDIiwic291cmNlcyI6WyIvaG9tZS9iYXJiL2FhL0Fzc29jaWF0ZWRBY2NvdW50cy9ub2RlX21vZHVsZXMvZGlkLWp3dC9ub2RlX21vZHVsZXMvbXVsdGlmb3JtYXRzL2VzbS9zcmMvaGFzaGVzL3NoYTIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGNyeXB0byBmcm9tICdjcnlwdG8nO1xuaW1wb3J0IHsgZnJvbSB9IGZyb20gJy4vaGFzaGVyLmpzJztcbmltcG9ydCB7IGNvZXJjZSB9IGZyb20gJy4uL2J5dGVzLmpzJztcbmV4cG9ydCBjb25zdCBzaGEyNTYgPSBmcm9tKHtcbiAgbmFtZTogJ3NoYTItMjU2JyxcbiAgY29kZTogMTgsXG4gIGVuY29kZTogaW5wdXQgPT4gY29lcmNlKGNyeXB0by5jcmVhdGVIYXNoKCdzaGEyNTYnKS51cGRhdGUoaW5wdXQpLmRpZ2VzdCgpKVxufSk7XG5leHBvcnQgY29uc3Qgc2hhNTEyID0gZnJvbSh7XG4gIG5hbWU6ICdzaGEyLTUxMicsXG4gIGNvZGU6IDE5LFxuICBlbmNvZGU6IGlucHV0ID0+IGNvZXJjZShjcnlwdG8uY3JlYXRlSGFzaCgnc2hhNTEyJykudXBkYXRlKGlucHV0KS5kaWdlc3QoKSlcbn0pOyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/did-jwt/node_modules/multiformats/esm/src/hashes/sha2.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/did-jwt/node_modules/multiformats/esm/src/index.js":
/*!*****************************************************************************!*\
  !*** ../../node_modules/did-jwt/node_modules/multiformats/esm/src/index.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CID: () => (/* reexport safe */ _cid_js__WEBPACK_IMPORTED_MODULE_0__.CID),\n/* harmony export */   bytes: () => (/* reexport module object */ _bytes_js__WEBPACK_IMPORTED_MODULE_2__),\n/* harmony export */   digest: () => (/* reexport module object */ _hashes_digest_js__WEBPACK_IMPORTED_MODULE_4__),\n/* harmony export */   hasher: () => (/* reexport module object */ _hashes_hasher_js__WEBPACK_IMPORTED_MODULE_3__),\n/* harmony export */   varint: () => (/* reexport module object */ _varint_js__WEBPACK_IMPORTED_MODULE_1__)\n/* harmony export */ });\n/* harmony import */ var _cid_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cid.js */ \"(rsc)/../../node_modules/did-jwt/node_modules/multiformats/esm/src/cid.js\");\n/* harmony import */ var _varint_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./varint.js */ \"(rsc)/../../node_modules/did-jwt/node_modules/multiformats/esm/src/varint.js\");\n/* harmony import */ var _bytes_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./bytes.js */ \"(rsc)/../../node_modules/did-jwt/node_modules/multiformats/esm/src/bytes.js\");\n/* harmony import */ var _hashes_hasher_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./hashes/hasher.js */ \"(rsc)/../../node_modules/did-jwt/node_modules/multiformats/esm/src/hashes/hasher.js\");\n/* harmony import */ var _hashes_digest_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./hashes/digest.js */ \"(rsc)/../../node_modules/did-jwt/node_modules/multiformats/esm/src/hashes/digest.js\");\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2RpZC1qd3Qvbm9kZV9tb2R1bGVzL211bHRpZm9ybWF0cy9lc20vc3JjL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBK0I7QUFDTztBQUNGO0FBQ1M7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvYmFyYi9hYS9Bc3NvY2lhdGVkQWNjb3VudHMvbm9kZV9tb2R1bGVzL2RpZC1qd3Qvbm9kZV9tb2R1bGVzL211bHRpZm9ybWF0cy9lc20vc3JjL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENJRCB9IGZyb20gJy4vY2lkLmpzJztcbmltcG9ydCAqIGFzIHZhcmludCBmcm9tICcuL3ZhcmludC5qcyc7XG5pbXBvcnQgKiBhcyBieXRlcyBmcm9tICcuL2J5dGVzLmpzJztcbmltcG9ydCAqIGFzIGhhc2hlciBmcm9tICcuL2hhc2hlcy9oYXNoZXIuanMnO1xuaW1wb3J0ICogYXMgZGlnZXN0IGZyb20gJy4vaGFzaGVzL2RpZ2VzdC5qcyc7XG5leHBvcnQge1xuICBDSUQsXG4gIGhhc2hlcixcbiAgZGlnZXN0LFxuICB2YXJpbnQsXG4gIGJ5dGVzXG59OyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/did-jwt/node_modules/multiformats/esm/src/index.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/did-jwt/node_modules/multiformats/esm/src/varint.js":
/*!******************************************************************************!*\
  !*** ../../node_modules/did-jwt/node_modules/multiformats/esm/src/varint.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decode: () => (/* binding */ decode),\n/* harmony export */   encodeTo: () => (/* binding */ encodeTo),\n/* harmony export */   encodingLength: () => (/* binding */ encodingLength)\n/* harmony export */ });\n/* harmony import */ var _vendor_varint_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../vendor/varint.js */ \"(rsc)/../../node_modules/did-jwt/node_modules/multiformats/esm/vendor/varint.js\");\n\nconst decode = (data, offset = 0) => {\n  const code = _vendor_varint_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].decode(data, offset);\n  return [\n    code,\n    _vendor_varint_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].decode.bytes\n  ];\n};\nconst encodeTo = (int, target, offset = 0) => {\n  _vendor_varint_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].encode(int, target, offset);\n  return target;\n};\nconst encodingLength = int => {\n  return _vendor_varint_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].encodingLength(int);\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2RpZC1qd3Qvbm9kZV9tb2R1bGVzL211bHRpZm9ybWF0cy9lc20vc3JjL3ZhcmludC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQXlDO0FBQ2xDO0FBQ1AsZUFBZSx5REFBTTtBQUNyQjtBQUNBO0FBQ0EsSUFBSSx5REFBTTtBQUNWO0FBQ0E7QUFDTztBQUNQLEVBQUUseURBQU07QUFDUjtBQUNBO0FBQ087QUFDUCxTQUFTLHlEQUFNO0FBQ2YiLCJzb3VyY2VzIjpbIi9ob21lL2JhcmIvYWEvQXNzb2NpYXRlZEFjY291bnRzL25vZGVfbW9kdWxlcy9kaWQtand0L25vZGVfbW9kdWxlcy9tdWx0aWZvcm1hdHMvZXNtL3NyYy92YXJpbnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHZhcmludCBmcm9tICcuLi92ZW5kb3IvdmFyaW50LmpzJztcbmV4cG9ydCBjb25zdCBkZWNvZGUgPSAoZGF0YSwgb2Zmc2V0ID0gMCkgPT4ge1xuICBjb25zdCBjb2RlID0gdmFyaW50LmRlY29kZShkYXRhLCBvZmZzZXQpO1xuICByZXR1cm4gW1xuICAgIGNvZGUsXG4gICAgdmFyaW50LmRlY29kZS5ieXRlc1xuICBdO1xufTtcbmV4cG9ydCBjb25zdCBlbmNvZGVUbyA9IChpbnQsIHRhcmdldCwgb2Zmc2V0ID0gMCkgPT4ge1xuICB2YXJpbnQuZW5jb2RlKGludCwgdGFyZ2V0LCBvZmZzZXQpO1xuICByZXR1cm4gdGFyZ2V0O1xufTtcbmV4cG9ydCBjb25zdCBlbmNvZGluZ0xlbmd0aCA9IGludCA9PiB7XG4gIHJldHVybiB2YXJpbnQuZW5jb2RpbmdMZW5ndGgoaW50KTtcbn07Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/did-jwt/node_modules/multiformats/esm/src/varint.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/did-jwt/node_modules/multiformats/esm/vendor/base-x.js":
/*!*********************************************************************************!*\
  !*** ../../node_modules/did-jwt/node_modules/multiformats/esm/vendor/base-x.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nfunction base(ALPHABET, name) {\n  if (ALPHABET.length >= 255) {\n    throw new TypeError('Alphabet too long');\n  }\n  var BASE_MAP = new Uint8Array(256);\n  for (var j = 0; j < BASE_MAP.length; j++) {\n    BASE_MAP[j] = 255;\n  }\n  for (var i = 0; i < ALPHABET.length; i++) {\n    var x = ALPHABET.charAt(i);\n    var xc = x.charCodeAt(0);\n    if (BASE_MAP[xc] !== 255) {\n      throw new TypeError(x + ' is ambiguous');\n    }\n    BASE_MAP[xc] = i;\n  }\n  var BASE = ALPHABET.length;\n  var LEADER = ALPHABET.charAt(0);\n  var FACTOR = Math.log(BASE) / Math.log(256);\n  var iFACTOR = Math.log(256) / Math.log(BASE);\n  function encode(source) {\n    if (source instanceof Uint8Array);\n    else if (ArrayBuffer.isView(source)) {\n      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);\n    } else if (Array.isArray(source)) {\n      source = Uint8Array.from(source);\n    }\n    if (!(source instanceof Uint8Array)) {\n      throw new TypeError('Expected Uint8Array');\n    }\n    if (source.length === 0) {\n      return '';\n    }\n    var zeroes = 0;\n    var length = 0;\n    var pbegin = 0;\n    var pend = source.length;\n    while (pbegin !== pend && source[pbegin] === 0) {\n      pbegin++;\n      zeroes++;\n    }\n    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;\n    var b58 = new Uint8Array(size);\n    while (pbegin !== pend) {\n      var carry = source[pbegin];\n      var i = 0;\n      for (var it1 = size - 1; (carry !== 0 || i < length) && it1 !== -1; it1--, i++) {\n        carry += 256 * b58[it1] >>> 0;\n        b58[it1] = carry % BASE >>> 0;\n        carry = carry / BASE >>> 0;\n      }\n      if (carry !== 0) {\n        throw new Error('Non-zero carry');\n      }\n      length = i;\n      pbegin++;\n    }\n    var it2 = size - length;\n    while (it2 !== size && b58[it2] === 0) {\n      it2++;\n    }\n    var str = LEADER.repeat(zeroes);\n    for (; it2 < size; ++it2) {\n      str += ALPHABET.charAt(b58[it2]);\n    }\n    return str;\n  }\n  function decodeUnsafe(source) {\n    if (typeof source !== 'string') {\n      throw new TypeError('Expected String');\n    }\n    if (source.length === 0) {\n      return new Uint8Array();\n    }\n    var psz = 0;\n    if (source[psz] === ' ') {\n      return;\n    }\n    var zeroes = 0;\n    var length = 0;\n    while (source[psz] === LEADER) {\n      zeroes++;\n      psz++;\n    }\n    var size = (source.length - psz) * FACTOR + 1 >>> 0;\n    var b256 = new Uint8Array(size);\n    while (source[psz]) {\n      var carry = BASE_MAP[source.charCodeAt(psz)];\n      if (carry === 255) {\n        return;\n      }\n      var i = 0;\n      for (var it3 = size - 1; (carry !== 0 || i < length) && it3 !== -1; it3--, i++) {\n        carry += BASE * b256[it3] >>> 0;\n        b256[it3] = carry % 256 >>> 0;\n        carry = carry / 256 >>> 0;\n      }\n      if (carry !== 0) {\n        throw new Error('Non-zero carry');\n      }\n      length = i;\n      psz++;\n    }\n    if (source[psz] === ' ') {\n      return;\n    }\n    var it4 = size - length;\n    while (it4 !== size && b256[it4] === 0) {\n      it4++;\n    }\n    var vch = new Uint8Array(zeroes + (size - it4));\n    var j = zeroes;\n    while (it4 !== size) {\n      vch[j++] = b256[it4++];\n    }\n    return vch;\n  }\n  function decode(string) {\n    var buffer = decodeUnsafe(string);\n    if (buffer) {\n      return buffer;\n    }\n    throw new Error(`Non-${ name } character`);\n  }\n  return {\n    encode: encode,\n    decodeUnsafe: decodeUnsafe,\n    decode: decode\n  };\n}\nvar src = base;\nvar _brrp__multiformats_scope_baseX = src;\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_brrp__multiformats_scope_baseX);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2RpZC1qd3Qvbm9kZV9tb2R1bGVzL211bHRpZm9ybWF0cy9lc20vdmVuZG9yL2Jhc2UteC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixxQkFBcUI7QUFDdkM7QUFDQTtBQUNBLGtCQUFrQixxQkFBcUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQiwyQ0FBMkM7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsMkNBQTJDO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsT0FBTztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBZSwrQkFBK0IiLCJzb3VyY2VzIjpbIi9ob21lL2JhcmIvYWEvQXNzb2NpYXRlZEFjY291bnRzL25vZGVfbW9kdWxlcy9kaWQtand0L25vZGVfbW9kdWxlcy9tdWx0aWZvcm1hdHMvZXNtL3ZlbmRvci9iYXNlLXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gYmFzZShBTFBIQUJFVCwgbmFtZSkge1xuICBpZiAoQUxQSEFCRVQubGVuZ3RoID49IDI1NSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FscGhhYmV0IHRvbyBsb25nJyk7XG4gIH1cbiAgdmFyIEJBU0VfTUFQID0gbmV3IFVpbnQ4QXJyYXkoMjU2KTtcbiAgZm9yICh2YXIgaiA9IDA7IGogPCBCQVNFX01BUC5sZW5ndGg7IGorKykge1xuICAgIEJBU0VfTUFQW2pdID0gMjU1O1xuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgQUxQSEFCRVQubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgeCA9IEFMUEhBQkVULmNoYXJBdChpKTtcbiAgICB2YXIgeGMgPSB4LmNoYXJDb2RlQXQoMCk7XG4gICAgaWYgKEJBU0VfTUFQW3hjXSAhPT0gMjU1KSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHggKyAnIGlzIGFtYmlndW91cycpO1xuICAgIH1cbiAgICBCQVNFX01BUFt4Y10gPSBpO1xuICB9XG4gIHZhciBCQVNFID0gQUxQSEFCRVQubGVuZ3RoO1xuICB2YXIgTEVBREVSID0gQUxQSEFCRVQuY2hhckF0KDApO1xuICB2YXIgRkFDVE9SID0gTWF0aC5sb2coQkFTRSkgLyBNYXRoLmxvZygyNTYpO1xuICB2YXIgaUZBQ1RPUiA9IE1hdGgubG9nKDI1NikgLyBNYXRoLmxvZyhCQVNFKTtcbiAgZnVuY3Rpb24gZW5jb2RlKHNvdXJjZSkge1xuICAgIGlmIChzb3VyY2UgaW5zdGFuY2VvZiBVaW50OEFycmF5KTtcbiAgICBlbHNlIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoc291cmNlKSkge1xuICAgICAgc291cmNlID0gbmV3IFVpbnQ4QXJyYXkoc291cmNlLmJ1ZmZlciwgc291cmNlLmJ5dGVPZmZzZXQsIHNvdXJjZS5ieXRlTGVuZ3RoKTtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoc291cmNlKSkge1xuICAgICAgc291cmNlID0gVWludDhBcnJheS5mcm9tKHNvdXJjZSk7XG4gICAgfVxuICAgIGlmICghKHNvdXJjZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBVaW50OEFycmF5Jyk7XG4gICAgfVxuICAgIGlmIChzb3VyY2UubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHZhciB6ZXJvZXMgPSAwO1xuICAgIHZhciBsZW5ndGggPSAwO1xuICAgIHZhciBwYmVnaW4gPSAwO1xuICAgIHZhciBwZW5kID0gc291cmNlLmxlbmd0aDtcbiAgICB3aGlsZSAocGJlZ2luICE9PSBwZW5kICYmIHNvdXJjZVtwYmVnaW5dID09PSAwKSB7XG4gICAgICBwYmVnaW4rKztcbiAgICAgIHplcm9lcysrO1xuICAgIH1cbiAgICB2YXIgc2l6ZSA9IChwZW5kIC0gcGJlZ2luKSAqIGlGQUNUT1IgKyAxID4+PiAwO1xuICAgIHZhciBiNTggPSBuZXcgVWludDhBcnJheShzaXplKTtcbiAgICB3aGlsZSAocGJlZ2luICE9PSBwZW5kKSB7XG4gICAgICB2YXIgY2FycnkgPSBzb3VyY2VbcGJlZ2luXTtcbiAgICAgIHZhciBpID0gMDtcbiAgICAgIGZvciAodmFyIGl0MSA9IHNpemUgLSAxOyAoY2FycnkgIT09IDAgfHwgaSA8IGxlbmd0aCkgJiYgaXQxICE9PSAtMTsgaXQxLS0sIGkrKykge1xuICAgICAgICBjYXJyeSArPSAyNTYgKiBiNThbaXQxXSA+Pj4gMDtcbiAgICAgICAgYjU4W2l0MV0gPSBjYXJyeSAlIEJBU0UgPj4+IDA7XG4gICAgICAgIGNhcnJ5ID0gY2FycnkgLyBCQVNFID4+PiAwO1xuICAgICAgfVxuICAgICAgaWYgKGNhcnJ5ICE9PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm9uLXplcm8gY2FycnknKTtcbiAgICAgIH1cbiAgICAgIGxlbmd0aCA9IGk7XG4gICAgICBwYmVnaW4rKztcbiAgICB9XG4gICAgdmFyIGl0MiA9IHNpemUgLSBsZW5ndGg7XG4gICAgd2hpbGUgKGl0MiAhPT0gc2l6ZSAmJiBiNThbaXQyXSA9PT0gMCkge1xuICAgICAgaXQyKys7XG4gICAgfVxuICAgIHZhciBzdHIgPSBMRUFERVIucmVwZWF0KHplcm9lcyk7XG4gICAgZm9yICg7IGl0MiA8IHNpemU7ICsraXQyKSB7XG4gICAgICBzdHIgKz0gQUxQSEFCRVQuY2hhckF0KGI1OFtpdDJdKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxuICBmdW5jdGlvbiBkZWNvZGVVbnNhZmUoc291cmNlKSB7XG4gICAgaWYgKHR5cGVvZiBzb3VyY2UgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBTdHJpbmcnKTtcbiAgICB9XG4gICAgaWYgKHNvdXJjZS5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBuZXcgVWludDhBcnJheSgpO1xuICAgIH1cbiAgICB2YXIgcHN6ID0gMDtcbiAgICBpZiAoc291cmNlW3Bzel0gPT09ICcgJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgemVyb2VzID0gMDtcbiAgICB2YXIgbGVuZ3RoID0gMDtcbiAgICB3aGlsZSAoc291cmNlW3Bzel0gPT09IExFQURFUikge1xuICAgICAgemVyb2VzKys7XG4gICAgICBwc3orKztcbiAgICB9XG4gICAgdmFyIHNpemUgPSAoc291cmNlLmxlbmd0aCAtIHBzeikgKiBGQUNUT1IgKyAxID4+PiAwO1xuICAgIHZhciBiMjU2ID0gbmV3IFVpbnQ4QXJyYXkoc2l6ZSk7XG4gICAgd2hpbGUgKHNvdXJjZVtwc3pdKSB7XG4gICAgICB2YXIgY2FycnkgPSBCQVNFX01BUFtzb3VyY2UuY2hhckNvZGVBdChwc3opXTtcbiAgICAgIGlmIChjYXJyeSA9PT0gMjU1KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBpID0gMDtcbiAgICAgIGZvciAodmFyIGl0MyA9IHNpemUgLSAxOyAoY2FycnkgIT09IDAgfHwgaSA8IGxlbmd0aCkgJiYgaXQzICE9PSAtMTsgaXQzLS0sIGkrKykge1xuICAgICAgICBjYXJyeSArPSBCQVNFICogYjI1NltpdDNdID4+PiAwO1xuICAgICAgICBiMjU2W2l0M10gPSBjYXJyeSAlIDI1NiA+Pj4gMDtcbiAgICAgICAgY2FycnkgPSBjYXJyeSAvIDI1NiA+Pj4gMDtcbiAgICAgIH1cbiAgICAgIGlmIChjYXJyeSAhPT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vbi16ZXJvIGNhcnJ5Jyk7XG4gICAgICB9XG4gICAgICBsZW5ndGggPSBpO1xuICAgICAgcHN6Kys7XG4gICAgfVxuICAgIGlmIChzb3VyY2VbcHN6XSA9PT0gJyAnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBpdDQgPSBzaXplIC0gbGVuZ3RoO1xuICAgIHdoaWxlIChpdDQgIT09IHNpemUgJiYgYjI1NltpdDRdID09PSAwKSB7XG4gICAgICBpdDQrKztcbiAgICB9XG4gICAgdmFyIHZjaCA9IG5ldyBVaW50OEFycmF5KHplcm9lcyArIChzaXplIC0gaXQ0KSk7XG4gICAgdmFyIGogPSB6ZXJvZXM7XG4gICAgd2hpbGUgKGl0NCAhPT0gc2l6ZSkge1xuICAgICAgdmNoW2orK10gPSBiMjU2W2l0NCsrXTtcbiAgICB9XG4gICAgcmV0dXJuIHZjaDtcbiAgfVxuICBmdW5jdGlvbiBkZWNvZGUoc3RyaW5nKSB7XG4gICAgdmFyIGJ1ZmZlciA9IGRlY29kZVVuc2FmZShzdHJpbmcpO1xuICAgIGlmIChidWZmZXIpIHtcbiAgICAgIHJldHVybiBidWZmZXI7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgTm9uLSR7IG5hbWUgfSBjaGFyYWN0ZXJgKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGVuY29kZTogZW5jb2RlLFxuICAgIGRlY29kZVVuc2FmZTogZGVjb2RlVW5zYWZlLFxuICAgIGRlY29kZTogZGVjb2RlXG4gIH07XG59XG52YXIgc3JjID0gYmFzZTtcbnZhciBfYnJycF9fbXVsdGlmb3JtYXRzX3Njb3BlX2Jhc2VYID0gc3JjO1xuZXhwb3J0IGRlZmF1bHQgX2JycnBfX211bHRpZm9ybWF0c19zY29wZV9iYXNlWDsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/did-jwt/node_modules/multiformats/esm/vendor/base-x.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/did-jwt/node_modules/multiformats/esm/vendor/varint.js":
/*!*********************************************************************************!*\
  !*** ../../node_modules/did-jwt/node_modules/multiformats/esm/vendor/varint.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nvar encode_1 = encode;\nvar MSB = 128, REST = 127, MSBALL = ~REST, INT = Math.pow(2, 31);\nfunction encode(num, out, offset) {\n  out = out || [];\n  offset = offset || 0;\n  var oldOffset = offset;\n  while (num >= INT) {\n    out[offset++] = num & 255 | MSB;\n    num /= 128;\n  }\n  while (num & MSBALL) {\n    out[offset++] = num & 255 | MSB;\n    num >>>= 7;\n  }\n  out[offset] = num | 0;\n  encode.bytes = offset - oldOffset + 1;\n  return out;\n}\nvar decode = read;\nvar MSB$1 = 128, REST$1 = 127;\nfunction read(buf, offset) {\n  var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf.length;\n  do {\n    if (counter >= l) {\n      read.bytes = 0;\n      throw new RangeError('Could not decode varint');\n    }\n    b = buf[counter++];\n    res += shift < 28 ? (b & REST$1) << shift : (b & REST$1) * Math.pow(2, shift);\n    shift += 7;\n  } while (b >= MSB$1);\n  read.bytes = counter - offset;\n  return res;\n}\nvar N1 = Math.pow(2, 7);\nvar N2 = Math.pow(2, 14);\nvar N3 = Math.pow(2, 21);\nvar N4 = Math.pow(2, 28);\nvar N5 = Math.pow(2, 35);\nvar N6 = Math.pow(2, 42);\nvar N7 = Math.pow(2, 49);\nvar N8 = Math.pow(2, 56);\nvar N9 = Math.pow(2, 63);\nvar length = function (value) {\n  return value < N1 ? 1 : value < N2 ? 2 : value < N3 ? 3 : value < N4 ? 4 : value < N5 ? 5 : value < N6 ? 6 : value < N7 ? 7 : value < N8 ? 8 : value < N9 ? 9 : 10;\n};\nvar varint = {\n  encode: encode_1,\n  decode: decode,\n  encodingLength: length\n};\nvar _brrp_varint = varint;\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_brrp_varint);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2RpZC1qd3Qvbm9kZV9tb2R1bGVzL211bHRpZm9ybWF0cy9lc20vdmVuZG9yL3ZhcmludC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFlLFlBQVkiLCJzb3VyY2VzIjpbIi9ob21lL2JhcmIvYWEvQXNzb2NpYXRlZEFjY291bnRzL25vZGVfbW9kdWxlcy9kaWQtand0L25vZGVfbW9kdWxlcy9tdWx0aWZvcm1hdHMvZXNtL3ZlbmRvci92YXJpbnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGVuY29kZV8xID0gZW5jb2RlO1xudmFyIE1TQiA9IDEyOCwgUkVTVCA9IDEyNywgTVNCQUxMID0gflJFU1QsIElOVCA9IE1hdGgucG93KDIsIDMxKTtcbmZ1bmN0aW9uIGVuY29kZShudW0sIG91dCwgb2Zmc2V0KSB7XG4gIG91dCA9IG91dCB8fCBbXTtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHx8IDA7XG4gIHZhciBvbGRPZmZzZXQgPSBvZmZzZXQ7XG4gIHdoaWxlIChudW0gPj0gSU5UKSB7XG4gICAgb3V0W29mZnNldCsrXSA9IG51bSAmIDI1NSB8IE1TQjtcbiAgICBudW0gLz0gMTI4O1xuICB9XG4gIHdoaWxlIChudW0gJiBNU0JBTEwpIHtcbiAgICBvdXRbb2Zmc2V0KytdID0gbnVtICYgMjU1IHwgTVNCO1xuICAgIG51bSA+Pj49IDc7XG4gIH1cbiAgb3V0W29mZnNldF0gPSBudW0gfCAwO1xuICBlbmNvZGUuYnl0ZXMgPSBvZmZzZXQgLSBvbGRPZmZzZXQgKyAxO1xuICByZXR1cm4gb3V0O1xufVxudmFyIGRlY29kZSA9IHJlYWQ7XG52YXIgTVNCJDEgPSAxMjgsIFJFU1QkMSA9IDEyNztcbmZ1bmN0aW9uIHJlYWQoYnVmLCBvZmZzZXQpIHtcbiAgdmFyIHJlcyA9IDAsIG9mZnNldCA9IG9mZnNldCB8fCAwLCBzaGlmdCA9IDAsIGNvdW50ZXIgPSBvZmZzZXQsIGIsIGwgPSBidWYubGVuZ3RoO1xuICBkbyB7XG4gICAgaWYgKGNvdW50ZXIgPj0gbCkge1xuICAgICAgcmVhZC5ieXRlcyA9IDA7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQ291bGQgbm90IGRlY29kZSB2YXJpbnQnKTtcbiAgICB9XG4gICAgYiA9IGJ1Zltjb3VudGVyKytdO1xuICAgIHJlcyArPSBzaGlmdCA8IDI4ID8gKGIgJiBSRVNUJDEpIDw8IHNoaWZ0IDogKGIgJiBSRVNUJDEpICogTWF0aC5wb3coMiwgc2hpZnQpO1xuICAgIHNoaWZ0ICs9IDc7XG4gIH0gd2hpbGUgKGIgPj0gTVNCJDEpO1xuICByZWFkLmJ5dGVzID0gY291bnRlciAtIG9mZnNldDtcbiAgcmV0dXJuIHJlcztcbn1cbnZhciBOMSA9IE1hdGgucG93KDIsIDcpO1xudmFyIE4yID0gTWF0aC5wb3coMiwgMTQpO1xudmFyIE4zID0gTWF0aC5wb3coMiwgMjEpO1xudmFyIE40ID0gTWF0aC5wb3coMiwgMjgpO1xudmFyIE41ID0gTWF0aC5wb3coMiwgMzUpO1xudmFyIE42ID0gTWF0aC5wb3coMiwgNDIpO1xudmFyIE43ID0gTWF0aC5wb3coMiwgNDkpO1xudmFyIE44ID0gTWF0aC5wb3coMiwgNTYpO1xudmFyIE45ID0gTWF0aC5wb3coMiwgNjMpO1xudmFyIGxlbmd0aCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPCBOMSA/IDEgOiB2YWx1ZSA8IE4yID8gMiA6IHZhbHVlIDwgTjMgPyAzIDogdmFsdWUgPCBONCA/IDQgOiB2YWx1ZSA8IE41ID8gNSA6IHZhbHVlIDwgTjYgPyA2IDogdmFsdWUgPCBONyA/IDcgOiB2YWx1ZSA8IE44ID8gOCA6IHZhbHVlIDwgTjkgPyA5IDogMTA7XG59O1xudmFyIHZhcmludCA9IHtcbiAgZW5jb2RlOiBlbmNvZGVfMSxcbiAgZGVjb2RlOiBkZWNvZGUsXG4gIGVuY29kaW5nTGVuZ3RoOiBsZW5ndGhcbn07XG52YXIgX2JycnBfdmFyaW50ID0gdmFyaW50O1xuZXhwb3J0IGRlZmF1bHQgX2JycnBfdmFyaW50OyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/did-jwt/node_modules/multiformats/esm/vendor/varint.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/did-jwt/node_modules/uint8arrays/esm/src/alloc.js":
/*!****************************************************************************!*\
  !*** ../../node_modules/did-jwt/node_modules/uint8arrays/esm/src/alloc.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   alloc: () => (/* binding */ alloc),\n/* harmony export */   allocUnsafe: () => (/* binding */ allocUnsafe)\n/* harmony export */ });\n/* harmony import */ var _util_as_uint8array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util/as-uint8array.js */ \"(rsc)/../../node_modules/did-jwt/node_modules/uint8arrays/esm/src/util/as-uint8array.js\");\n\nfunction alloc(size = 0) {\n  if (globalThis.Buffer != null && globalThis.Buffer.alloc != null) {\n    return (0,_util_as_uint8array_js__WEBPACK_IMPORTED_MODULE_0__.asUint8Array)(globalThis.Buffer.alloc(size));\n  }\n  return new Uint8Array(size);\n}\nfunction allocUnsafe(size = 0) {\n  if (globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null) {\n    return (0,_util_as_uint8array_js__WEBPACK_IMPORTED_MODULE_0__.asUint8Array)(globalThis.Buffer.allocUnsafe(size));\n  }\n  return new Uint8Array(size);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2RpZC1qd3Qvbm9kZV9tb2R1bGVzL3VpbnQ4YXJyYXlzL2VzbS9zcmMvYWxsb2MuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQXVEO0FBQ2hEO0FBQ1A7QUFDQSxXQUFXLG9FQUFZO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxXQUFXLG9FQUFZO0FBQ3ZCO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvYmFyYi9hYS9Bc3NvY2lhdGVkQWNjb3VudHMvbm9kZV9tb2R1bGVzL2RpZC1qd3Qvbm9kZV9tb2R1bGVzL3VpbnQ4YXJyYXlzL2VzbS9zcmMvYWxsb2MuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgYXNVaW50OEFycmF5IH0gZnJvbSAnLi91dGlsL2FzLXVpbnQ4YXJyYXkuanMnO1xuZXhwb3J0IGZ1bmN0aW9uIGFsbG9jKHNpemUgPSAwKSB7XG4gIGlmIChnbG9iYWxUaGlzLkJ1ZmZlciAhPSBudWxsICYmIGdsb2JhbFRoaXMuQnVmZmVyLmFsbG9jICE9IG51bGwpIHtcbiAgICByZXR1cm4gYXNVaW50OEFycmF5KGdsb2JhbFRoaXMuQnVmZmVyLmFsbG9jKHNpemUpKTtcbiAgfVxuICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoc2l6ZSk7XG59XG5leHBvcnQgZnVuY3Rpb24gYWxsb2NVbnNhZmUoc2l6ZSA9IDApIHtcbiAgaWYgKGdsb2JhbFRoaXMuQnVmZmVyICE9IG51bGwgJiYgZ2xvYmFsVGhpcy5CdWZmZXIuYWxsb2NVbnNhZmUgIT0gbnVsbCkge1xuICAgIHJldHVybiBhc1VpbnQ4QXJyYXkoZ2xvYmFsVGhpcy5CdWZmZXIuYWxsb2NVbnNhZmUoc2l6ZSkpO1xuICB9XG4gIHJldHVybiBuZXcgVWludDhBcnJheShzaXplKTtcbn0iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/did-jwt/node_modules/uint8arrays/esm/src/alloc.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/did-jwt/node_modules/uint8arrays/esm/src/compare.js":
/*!******************************************************************************!*\
  !*** ../../node_modules/did-jwt/node_modules/uint8arrays/esm/src/compare.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   compare: () => (/* binding */ compare)\n/* harmony export */ });\nfunction compare(a, b) {\n  for (let i = 0; i < a.byteLength; i++) {\n    if (a[i] < b[i]) {\n      return -1;\n    }\n    if (a[i] > b[i]) {\n      return 1;\n    }\n  }\n  if (a.byteLength > b.byteLength) {\n    return 1;\n  }\n  if (a.byteLength < b.byteLength) {\n    return -1;\n  }\n  return 0;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2RpZC1qd3Qvbm9kZV9tb2R1bGVzL3VpbnQ4YXJyYXlzL2VzbS9zcmMvY29tcGFyZS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQU87QUFDUCxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvYmFyYi9hYS9Bc3NvY2lhdGVkQWNjb3VudHMvbm9kZV9tb2R1bGVzL2RpZC1qd3Qvbm9kZV9tb2R1bGVzL3VpbnQ4YXJyYXlzL2VzbS9zcmMvY29tcGFyZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZnVuY3Rpb24gY29tcGFyZShhLCBiKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYS5ieXRlTGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoYVtpXSA8IGJbaV0pIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgaWYgKGFbaV0gPiBiW2ldKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG4gIH1cbiAgaWYgKGEuYnl0ZUxlbmd0aCA+IGIuYnl0ZUxlbmd0aCkge1xuICAgIHJldHVybiAxO1xuICB9XG4gIGlmIChhLmJ5dGVMZW5ndGggPCBiLmJ5dGVMZW5ndGgpIHtcbiAgICByZXR1cm4gLTE7XG4gIH1cbiAgcmV0dXJuIDA7XG59Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/did-jwt/node_modules/uint8arrays/esm/src/compare.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/did-jwt/node_modules/uint8arrays/esm/src/concat.js":
/*!*****************************************************************************!*\
  !*** ../../node_modules/did-jwt/node_modules/uint8arrays/esm/src/concat.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   concat: () => (/* binding */ concat)\n/* harmony export */ });\n/* harmony import */ var _alloc_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./alloc.js */ \"(rsc)/../../node_modules/did-jwt/node_modules/uint8arrays/esm/src/alloc.js\");\n/* harmony import */ var _util_as_uint8array_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util/as-uint8array.js */ \"(rsc)/../../node_modules/did-jwt/node_modules/uint8arrays/esm/src/util/as-uint8array.js\");\n\n\nfunction concat(arrays, length) {\n  if (!length) {\n    length = arrays.reduce((acc, curr) => acc + curr.length, 0);\n  }\n  const output = (0,_alloc_js__WEBPACK_IMPORTED_MODULE_0__.allocUnsafe)(length);\n  let offset = 0;\n  for (const arr of arrays) {\n    output.set(arr, offset);\n    offset += arr.length;\n  }\n  return (0,_util_as_uint8array_js__WEBPACK_IMPORTED_MODULE_1__.asUint8Array)(output);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2RpZC1qd3Qvbm9kZV9tb2R1bGVzL3VpbnQ4YXJyYXlzL2VzbS9zcmMvY29uY2F0LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUF5QztBQUNjO0FBQ2hEO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHNEQUFXO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLG9FQUFZO0FBQ3JCIiwic291cmNlcyI6WyIvaG9tZS9iYXJiL2FhL0Fzc29jaWF0ZWRBY2NvdW50cy9ub2RlX21vZHVsZXMvZGlkLWp3dC9ub2RlX21vZHVsZXMvdWludDhhcnJheXMvZXNtL3NyYy9jb25jYXQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgYWxsb2NVbnNhZmUgfSBmcm9tICcuL2FsbG9jLmpzJztcbmltcG9ydCB7IGFzVWludDhBcnJheSB9IGZyb20gJy4vdXRpbC9hcy11aW50OGFycmF5LmpzJztcbmV4cG9ydCBmdW5jdGlvbiBjb25jYXQoYXJyYXlzLCBsZW5ndGgpIHtcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSBhcnJheXMucmVkdWNlKChhY2MsIGN1cnIpID0+IGFjYyArIGN1cnIubGVuZ3RoLCAwKTtcbiAgfVxuICBjb25zdCBvdXRwdXQgPSBhbGxvY1Vuc2FmZShsZW5ndGgpO1xuICBsZXQgb2Zmc2V0ID0gMDtcbiAgZm9yIChjb25zdCBhcnIgb2YgYXJyYXlzKSB7XG4gICAgb3V0cHV0LnNldChhcnIsIG9mZnNldCk7XG4gICAgb2Zmc2V0ICs9IGFyci5sZW5ndGg7XG4gIH1cbiAgcmV0dXJuIGFzVWludDhBcnJheShvdXRwdXQpO1xufSJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/did-jwt/node_modules/uint8arrays/esm/src/concat.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/did-jwt/node_modules/uint8arrays/esm/src/equals.js":
/*!*****************************************************************************!*\
  !*** ../../node_modules/did-jwt/node_modules/uint8arrays/esm/src/equals.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   equals: () => (/* binding */ equals)\n/* harmony export */ });\nfunction equals(a, b) {\n  if (a === b) {\n    return true;\n  }\n  if (a.byteLength !== b.byteLength) {\n    return false;\n  }\n  for (let i = 0; i < a.byteLength; i++) {\n    if (a[i] !== b[i]) {\n      return false;\n    }\n  }\n  return true;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2RpZC1qd3Qvbm9kZV9tb2R1bGVzL3VpbnQ4YXJyYXlzL2VzbS9zcmMvZXF1YWxzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9iYXJiL2FhL0Fzc29jaWF0ZWRBY2NvdW50cy9ub2RlX21vZHVsZXMvZGlkLWp3dC9ub2RlX21vZHVsZXMvdWludDhhcnJheXMvZXNtL3NyYy9lcXVhbHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGZ1bmN0aW9uIGVxdWFscyhhLCBiKSB7XG4gIGlmIChhID09PSBiKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKGEuYnl0ZUxlbmd0aCAhPT0gYi5ieXRlTGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYS5ieXRlTGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn0iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/did-jwt/node_modules/uint8arrays/esm/src/equals.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/did-jwt/node_modules/uint8arrays/esm/src/from-string.js":
/*!**********************************************************************************!*\
  !*** ../../node_modules/did-jwt/node_modules/uint8arrays/esm/src/from-string.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fromString: () => (/* binding */ fromString)\n/* harmony export */ });\n/* harmony import */ var _util_bases_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util/bases.js */ \"(rsc)/../../node_modules/did-jwt/node_modules/uint8arrays/esm/src/util/bases.js\");\n/* harmony import */ var _util_as_uint8array_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util/as-uint8array.js */ \"(rsc)/../../node_modules/did-jwt/node_modules/uint8arrays/esm/src/util/as-uint8array.js\");\n\n\nfunction fromString(string, encoding = 'utf8') {\n  const base = _util_bases_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"][encoding];\n  if (!base) {\n    throw new Error(`Unsupported encoding \"${ encoding }\"`);\n  }\n  if ((encoding === 'utf8' || encoding === 'utf-8') && globalThis.Buffer != null && globalThis.Buffer.from != null) {\n    return (0,_util_as_uint8array_js__WEBPACK_IMPORTED_MODULE_1__.asUint8Array)(globalThis.Buffer.from(string, 'utf-8'));\n  }\n  return base.decoder.decode(`${ base.prefix }${ string }`);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2RpZC1qd3Qvbm9kZV9tb2R1bGVzL3VpbnQ4YXJyYXlzL2VzbS9zcmMvZnJvbS1zdHJpbmcuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQW9DO0FBQ21CO0FBQ2hEO0FBQ1AsZUFBZSxzREFBSztBQUNwQjtBQUNBLDhDQUE4QyxVQUFVO0FBQ3hEO0FBQ0E7QUFDQSxXQUFXLG9FQUFZO0FBQ3ZCO0FBQ0EsaUNBQWlDLGFBQWEsR0FBRyxRQUFRO0FBQ3pEIiwic291cmNlcyI6WyIvaG9tZS9iYXJiL2FhL0Fzc29jaWF0ZWRBY2NvdW50cy9ub2RlX21vZHVsZXMvZGlkLWp3dC9ub2RlX21vZHVsZXMvdWludDhhcnJheXMvZXNtL3NyYy9mcm9tLXN0cmluZy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgYmFzZXMgZnJvbSAnLi91dGlsL2Jhc2VzLmpzJztcbmltcG9ydCB7IGFzVWludDhBcnJheSB9IGZyb20gJy4vdXRpbC9hcy11aW50OGFycmF5LmpzJztcbmV4cG9ydCBmdW5jdGlvbiBmcm9tU3RyaW5nKHN0cmluZywgZW5jb2RpbmcgPSAndXRmOCcpIHtcbiAgY29uc3QgYmFzZSA9IGJhc2VzW2VuY29kaW5nXTtcbiAgaWYgKCFiYXNlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBlbmNvZGluZyBcIiR7IGVuY29kaW5nIH1cImApO1xuICB9XG4gIGlmICgoZW5jb2RpbmcgPT09ICd1dGY4JyB8fCBlbmNvZGluZyA9PT0gJ3V0Zi04JykgJiYgZ2xvYmFsVGhpcy5CdWZmZXIgIT0gbnVsbCAmJiBnbG9iYWxUaGlzLkJ1ZmZlci5mcm9tICE9IG51bGwpIHtcbiAgICByZXR1cm4gYXNVaW50OEFycmF5KGdsb2JhbFRoaXMuQnVmZmVyLmZyb20oc3RyaW5nLCAndXRmLTgnKSk7XG4gIH1cbiAgcmV0dXJuIGJhc2UuZGVjb2Rlci5kZWNvZGUoYCR7IGJhc2UucHJlZml4IH0keyBzdHJpbmcgfWApO1xufSJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/did-jwt/node_modules/uint8arrays/esm/src/from-string.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/did-jwt/node_modules/uint8arrays/esm/src/index.js":
/*!****************************************************************************!*\
  !*** ../../node_modules/did-jwt/node_modules/uint8arrays/esm/src/index.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   compare: () => (/* reexport safe */ _compare_js__WEBPACK_IMPORTED_MODULE_0__.compare),\n/* harmony export */   concat: () => (/* reexport safe */ _concat_js__WEBPACK_IMPORTED_MODULE_1__.concat),\n/* harmony export */   equals: () => (/* reexport safe */ _equals_js__WEBPACK_IMPORTED_MODULE_2__.equals),\n/* harmony export */   fromString: () => (/* reexport safe */ _from_string_js__WEBPACK_IMPORTED_MODULE_3__.fromString),\n/* harmony export */   toString: () => (/* reexport safe */ _to_string_js__WEBPACK_IMPORTED_MODULE_4__.toString),\n/* harmony export */   xor: () => (/* reexport safe */ _xor_js__WEBPACK_IMPORTED_MODULE_5__.xor)\n/* harmony export */ });\n/* harmony import */ var _compare_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./compare.js */ \"(rsc)/../../node_modules/did-jwt/node_modules/uint8arrays/esm/src/compare.js\");\n/* harmony import */ var _concat_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./concat.js */ \"(rsc)/../../node_modules/did-jwt/node_modules/uint8arrays/esm/src/concat.js\");\n/* harmony import */ var _equals_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./equals.js */ \"(rsc)/../../node_modules/did-jwt/node_modules/uint8arrays/esm/src/equals.js\");\n/* harmony import */ var _from_string_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./from-string.js */ \"(rsc)/../../node_modules/did-jwt/node_modules/uint8arrays/esm/src/from-string.js\");\n/* harmony import */ var _to_string_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./to-string.js */ \"(rsc)/../../node_modules/did-jwt/node_modules/uint8arrays/esm/src/to-string.js\");\n/* harmony import */ var _xor_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./xor.js */ \"(rsc)/../../node_modules/did-jwt/node_modules/uint8arrays/esm/src/xor.js\");\n\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2RpZC1qd3Qvbm9kZV9tb2R1bGVzL3VpbnQ4YXJyYXlzL2VzbS9zcmMvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQXVDO0FBQ0Y7QUFDQTtBQUNTO0FBQ0o7QUFDWCIsInNvdXJjZXMiOlsiL2hvbWUvYmFyYi9hYS9Bc3NvY2lhdGVkQWNjb3VudHMvbm9kZV9tb2R1bGVzL2RpZC1qd3Qvbm9kZV9tb2R1bGVzL3VpbnQ4YXJyYXlzL2VzbS9zcmMvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY29tcGFyZSB9IGZyb20gJy4vY29tcGFyZS5qcyc7XG5pbXBvcnQgeyBjb25jYXQgfSBmcm9tICcuL2NvbmNhdC5qcyc7XG5pbXBvcnQgeyBlcXVhbHMgfSBmcm9tICcuL2VxdWFscy5qcyc7XG5pbXBvcnQgeyBmcm9tU3RyaW5nIH0gZnJvbSAnLi9mcm9tLXN0cmluZy5qcyc7XG5pbXBvcnQgeyB0b1N0cmluZyB9IGZyb20gJy4vdG8tc3RyaW5nLmpzJztcbmltcG9ydCB7IHhvciB9IGZyb20gJy4veG9yLmpzJztcbmV4cG9ydCB7XG4gIGNvbXBhcmUsXG4gIGNvbmNhdCxcbiAgZXF1YWxzLFxuICBmcm9tU3RyaW5nLFxuICB0b1N0cmluZyxcbiAgeG9yXG59OyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/did-jwt/node_modules/uint8arrays/esm/src/index.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/did-jwt/node_modules/uint8arrays/esm/src/to-string.js":
/*!********************************************************************************!*\
  !*** ../../node_modules/did-jwt/node_modules/uint8arrays/esm/src/to-string.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   toString: () => (/* binding */ toString)\n/* harmony export */ });\n/* harmony import */ var _util_bases_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util/bases.js */ \"(rsc)/../../node_modules/did-jwt/node_modules/uint8arrays/esm/src/util/bases.js\");\n\nfunction toString(array, encoding = 'utf8') {\n  const base = _util_bases_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"][encoding];\n  if (!base) {\n    throw new Error(`Unsupported encoding \"${ encoding }\"`);\n  }\n  if ((encoding === 'utf8' || encoding === 'utf-8') && globalThis.Buffer != null && globalThis.Buffer.from != null) {\n    return globalThis.Buffer.from(array.buffer, array.byteOffset, array.byteLength).toString('utf8');\n  }\n  return base.encoder.encode(array).substring(1);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2RpZC1qd3Qvbm9kZV9tb2R1bGVzL3VpbnQ4YXJyYXlzL2VzbS9zcmMvdG8tc3RyaW5nLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQW9DO0FBQzdCO0FBQ1AsZUFBZSxzREFBSztBQUNwQjtBQUNBLDhDQUE4QyxVQUFVO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvYmFyYi9hYS9Bc3NvY2lhdGVkQWNjb3VudHMvbm9kZV9tb2R1bGVzL2RpZC1qd3Qvbm9kZV9tb2R1bGVzL3VpbnQ4YXJyYXlzL2VzbS9zcmMvdG8tc3RyaW5nLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBiYXNlcyBmcm9tICcuL3V0aWwvYmFzZXMuanMnO1xuZXhwb3J0IGZ1bmN0aW9uIHRvU3RyaW5nKGFycmF5LCBlbmNvZGluZyA9ICd1dGY4Jykge1xuICBjb25zdCBiYXNlID0gYmFzZXNbZW5jb2RpbmddO1xuICBpZiAoIWJhc2UpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGVuY29kaW5nIFwiJHsgZW5jb2RpbmcgfVwiYCk7XG4gIH1cbiAgaWYgKChlbmNvZGluZyA9PT0gJ3V0ZjgnIHx8IGVuY29kaW5nID09PSAndXRmLTgnKSAmJiBnbG9iYWxUaGlzLkJ1ZmZlciAhPSBudWxsICYmIGdsb2JhbFRoaXMuQnVmZmVyLmZyb20gIT0gbnVsbCkge1xuICAgIHJldHVybiBnbG9iYWxUaGlzLkJ1ZmZlci5mcm9tKGFycmF5LmJ1ZmZlciwgYXJyYXkuYnl0ZU9mZnNldCwgYXJyYXkuYnl0ZUxlbmd0aCkudG9TdHJpbmcoJ3V0ZjgnKTtcbiAgfVxuICByZXR1cm4gYmFzZS5lbmNvZGVyLmVuY29kZShhcnJheSkuc3Vic3RyaW5nKDEpO1xufSJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/did-jwt/node_modules/uint8arrays/esm/src/to-string.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/did-jwt/node_modules/uint8arrays/esm/src/util/as-uint8array.js":
/*!*****************************************************************************************!*\
  !*** ../../node_modules/did-jwt/node_modules/uint8arrays/esm/src/util/as-uint8array.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   asUint8Array: () => (/* binding */ asUint8Array)\n/* harmony export */ });\nfunction asUint8Array(buf) {\n  if (globalThis.Buffer != null) {\n    return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);\n  }\n  return buf;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2RpZC1qd3Qvbm9kZV9tb2R1bGVzL3VpbnQ4YXJyYXlzL2VzbS9zcmMvdXRpbC9hcy11aW50OGFycmF5LmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL2JhcmIvYWEvQXNzb2NpYXRlZEFjY291bnRzL25vZGVfbW9kdWxlcy9kaWQtand0L25vZGVfbW9kdWxlcy91aW50OGFycmF5cy9lc20vc3JjL3V0aWwvYXMtdWludDhhcnJheS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZnVuY3Rpb24gYXNVaW50OEFycmF5KGJ1Zikge1xuICBpZiAoZ2xvYmFsVGhpcy5CdWZmZXIgIT0gbnVsbCkge1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShidWYuYnVmZmVyLCBidWYuYnl0ZU9mZnNldCwgYnVmLmJ5dGVMZW5ndGgpO1xuICB9XG4gIHJldHVybiBidWY7XG59Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/did-jwt/node_modules/uint8arrays/esm/src/util/as-uint8array.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/did-jwt/node_modules/uint8arrays/esm/src/util/bases.js":
/*!*********************************************************************************!*\
  !*** ../../node_modules/did-jwt/node_modules/uint8arrays/esm/src/util/bases.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var multiformats_basics__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! multiformats/basics */ \"(rsc)/../../node_modules/did-jwt/node_modules/multiformats/esm/src/basics.js\");\n/* harmony import */ var _alloc_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../alloc.js */ \"(rsc)/../../node_modules/did-jwt/node_modules/uint8arrays/esm/src/alloc.js\");\n\n\nfunction createCodec(name, prefix, encode, decode) {\n  return {\n    name,\n    prefix,\n    encoder: {\n      name,\n      prefix,\n      encode\n    },\n    decoder: { decode }\n  };\n}\nconst string = createCodec('utf8', 'u', buf => {\n  const decoder = new TextDecoder('utf8');\n  return 'u' + decoder.decode(buf);\n}, str => {\n  const encoder = new TextEncoder();\n  return encoder.encode(str.substring(1));\n});\nconst ascii = createCodec('ascii', 'a', buf => {\n  let string = 'a';\n  for (let i = 0; i < buf.length; i++) {\n    string += String.fromCharCode(buf[i]);\n  }\n  return string;\n}, str => {\n  str = str.substring(1);\n  const buf = (0,_alloc_js__WEBPACK_IMPORTED_MODULE_1__.allocUnsafe)(str.length);\n  for (let i = 0; i < str.length; i++) {\n    buf[i] = str.charCodeAt(i);\n  }\n  return buf;\n});\nconst BASES = {\n  utf8: string,\n  'utf-8': string,\n  hex: multiformats_basics__WEBPACK_IMPORTED_MODULE_0__.bases.base16,\n  latin1: ascii,\n  ascii: ascii,\n  binary: ascii,\n  ...multiformats_basics__WEBPACK_IMPORTED_MODULE_0__.bases\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (BASES);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2RpZC1qd3Qvbm9kZV9tb2R1bGVzL3VpbnQ4YXJyYXlzL2VzbS9zcmMvdXRpbC9iYXNlcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBNEM7QUFDRjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLGtCQUFrQixnQkFBZ0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsY0FBYyxzREFBVztBQUN6QixrQkFBa0IsZ0JBQWdCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxPQUFPLHNEQUFLO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsS0FBSyxzREFBSztBQUNWO0FBQ0EsaUVBQWUsS0FBSyIsInNvdXJjZXMiOlsiL2hvbWUvYmFyYi9hYS9Bc3NvY2lhdGVkQWNjb3VudHMvbm9kZV9tb2R1bGVzL2RpZC1qd3Qvbm9kZV9tb2R1bGVzL3VpbnQ4YXJyYXlzL2VzbS9zcmMvdXRpbC9iYXNlcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBiYXNlcyB9IGZyb20gJ211bHRpZm9ybWF0cy9iYXNpY3MnO1xuaW1wb3J0IHsgYWxsb2NVbnNhZmUgfSBmcm9tICcuLi9hbGxvYy5qcyc7XG5mdW5jdGlvbiBjcmVhdGVDb2RlYyhuYW1lLCBwcmVmaXgsIGVuY29kZSwgZGVjb2RlKSB7XG4gIHJldHVybiB7XG4gICAgbmFtZSxcbiAgICBwcmVmaXgsXG4gICAgZW5jb2Rlcjoge1xuICAgICAgbmFtZSxcbiAgICAgIHByZWZpeCxcbiAgICAgIGVuY29kZVxuICAgIH0sXG4gICAgZGVjb2RlcjogeyBkZWNvZGUgfVxuICB9O1xufVxuY29uc3Qgc3RyaW5nID0gY3JlYXRlQ29kZWMoJ3V0ZjgnLCAndScsIGJ1ZiA9PiB7XG4gIGNvbnN0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoJ3V0ZjgnKTtcbiAgcmV0dXJuICd1JyArIGRlY29kZXIuZGVjb2RlKGJ1Zik7XG59LCBzdHIgPT4ge1xuICBjb25zdCBlbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gIHJldHVybiBlbmNvZGVyLmVuY29kZShzdHIuc3Vic3RyaW5nKDEpKTtcbn0pO1xuY29uc3QgYXNjaWkgPSBjcmVhdGVDb2RlYygnYXNjaWknLCAnYScsIGJ1ZiA9PiB7XG4gIGxldCBzdHJpbmcgPSAnYSc7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYnVmLmxlbmd0aDsgaSsrKSB7XG4gICAgc3RyaW5nICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKTtcbiAgfVxuICByZXR1cm4gc3RyaW5nO1xufSwgc3RyID0+IHtcbiAgc3RyID0gc3RyLnN1YnN0cmluZygxKTtcbiAgY29uc3QgYnVmID0gYWxsb2NVbnNhZmUoc3RyLmxlbmd0aCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgYnVmW2ldID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gIH1cbiAgcmV0dXJuIGJ1Zjtcbn0pO1xuY29uc3QgQkFTRVMgPSB7XG4gIHV0Zjg6IHN0cmluZyxcbiAgJ3V0Zi04Jzogc3RyaW5nLFxuICBoZXg6IGJhc2VzLmJhc2UxNixcbiAgbGF0aW4xOiBhc2NpaSxcbiAgYXNjaWk6IGFzY2lpLFxuICBiaW5hcnk6IGFzY2lpLFxuICAuLi5iYXNlc1xufTtcbmV4cG9ydCBkZWZhdWx0IEJBU0VTOyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/did-jwt/node_modules/uint8arrays/esm/src/util/bases.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/did-jwt/node_modules/uint8arrays/esm/src/xor.js":
/*!**************************************************************************!*\
  !*** ../../node_modules/did-jwt/node_modules/uint8arrays/esm/src/xor.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   xor: () => (/* binding */ xor)\n/* harmony export */ });\n/* harmony import */ var _alloc_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./alloc.js */ \"(rsc)/../../node_modules/did-jwt/node_modules/uint8arrays/esm/src/alloc.js\");\n/* harmony import */ var _util_as_uint8array_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util/as-uint8array.js */ \"(rsc)/../../node_modules/did-jwt/node_modules/uint8arrays/esm/src/util/as-uint8array.js\");\n\n\nfunction xor(a, b) {\n  if (a.length !== b.length) {\n    throw new Error('Inputs should have the same length');\n  }\n  const result = (0,_alloc_js__WEBPACK_IMPORTED_MODULE_0__.allocUnsafe)(a.length);\n  for (let i = 0; i < a.length; i++) {\n    result[i] = a[i] ^ b[i];\n  }\n  return (0,_util_as_uint8array_js__WEBPACK_IMPORTED_MODULE_1__.asUint8Array)(result);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2RpZC1qd3Qvbm9kZV9tb2R1bGVzL3VpbnQ4YXJyYXlzL2VzbS9zcmMveG9yLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUF5QztBQUNjO0FBQ2hEO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHNEQUFXO0FBQzVCLGtCQUFrQixjQUFjO0FBQ2hDO0FBQ0E7QUFDQSxTQUFTLG9FQUFZO0FBQ3JCIiwic291cmNlcyI6WyIvaG9tZS9iYXJiL2FhL0Fzc29jaWF0ZWRBY2NvdW50cy9ub2RlX21vZHVsZXMvZGlkLWp3dC9ub2RlX21vZHVsZXMvdWludDhhcnJheXMvZXNtL3NyYy94b3IuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgYWxsb2NVbnNhZmUgfSBmcm9tICcuL2FsbG9jLmpzJztcbmltcG9ydCB7IGFzVWludDhBcnJheSB9IGZyb20gJy4vdXRpbC9hcy11aW50OGFycmF5LmpzJztcbmV4cG9ydCBmdW5jdGlvbiB4b3IoYSwgYikge1xuICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dHMgc2hvdWxkIGhhdmUgdGhlIHNhbWUgbGVuZ3RoJyk7XG4gIH1cbiAgY29uc3QgcmVzdWx0ID0gYWxsb2NVbnNhZmUoYS5sZW5ndGgpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICByZXN1bHRbaV0gPSBhW2ldIF4gYltpXTtcbiAgfVxuICByZXR1cm4gYXNVaW50OEFycmF5KHJlc3VsdCk7XG59Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/did-jwt/node_modules/uint8arrays/esm/src/xor.js\n");

/***/ })

};
;