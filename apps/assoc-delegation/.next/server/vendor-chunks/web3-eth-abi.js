/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/web3-eth-abi";
exports.ids = ["vendor-chunks/web3-eth-abi"];
exports.modules = {

/***/ "(rsc)/../../node_modules/web3-eth-abi/lib/index.js":
/*!****************************************************!*\
  !*** ../../node_modules/web3-eth-abi/lib/index.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*\n This file is part of web3.js.\n\n web3.js is free software: you can redistribute it and/or modify\n it under the terms of the GNU Lesser General Public License as published by\n the Free Software Foundation, either version 3 of the License, or\n (at your option) any later version.\n\n web3.js is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n GNU Lesser General Public License for more details.\n\n You should have received a copy of the GNU Lesser General Public License\n along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n */\n/**\n * @file index.js\n * @author Marek Kotewicz <marek@parity.io>\n * @author Fabian Vogelsteller <fabian@frozeman.de>\n * @date 2018\n */\nvar Buffer = (__webpack_require__(/*! buffer */ \"buffer\").Buffer);\nvar utils = __webpack_require__(/*! web3-utils */ \"(rsc)/../../node_modules/web3-utils/lib/index.js\");\nvar EthersAbiCoder = (__webpack_require__(/*! @ethersproject/abi */ \"(rsc)/../../node_modules/@ethersproject/abi/lib.esm/index.js\").AbiCoder);\nvar ParamType = (__webpack_require__(/*! @ethersproject/abi */ \"(rsc)/../../node_modules/@ethersproject/abi/lib.esm/index.js\").ParamType);\nvar ethersAbiCoder = new EthersAbiCoder(function (type, value) {\n    if (type.match(/^u?int/) && !Array.isArray(value) && (!(!!value && typeof value === 'object') || value.constructor.name !== 'BN')) {\n        return value.toString();\n    }\n    return value;\n});\n// result method\nfunction Result() {\n}\n/**\n * ABICoder prototype should be used to encode/decode solidity params of any type\n */\nvar ABICoder = function () {\n};\n/**\n * Encodes the function name to its ABI representation, which are the first 4 bytes of the sha3 of the function name including  types.\n *\n * @method encodeFunctionSignature\n * @param {String|Object} functionName\n * @return {String} encoded function name\n */\nABICoder.prototype.encodeFunctionSignature = function (functionName) {\n    if (typeof functionName === 'function' || typeof functionName === 'object' && functionName) {\n        functionName = utils._jsonInterfaceMethodToString(functionName);\n    }\n    return utils.sha3(functionName).slice(0, 10);\n};\n/**\n * Encodes the function name to its ABI representation, which are the first 4 bytes of the sha3 of the function name including  types.\n *\n * @method encodeEventSignature\n * @param {String|Object} functionName\n * @return {String} encoded function name\n */\nABICoder.prototype.encodeEventSignature = function (functionName) {\n    if (typeof functionName === 'function' || typeof functionName === 'object' && functionName) {\n        functionName = utils._jsonInterfaceMethodToString(functionName);\n    }\n    return utils.sha3(functionName);\n};\n/**\n * Should be used to encode plain param\n *\n * @method encodeParameter\n *\n * @param {String|Object} type\n * @param {any} param\n *\n * @return {String} encoded plain param\n */\nABICoder.prototype.encodeParameter = function (type, param) {\n    return this.encodeParameters([type], [param]);\n};\n/**\n * Should be used to encode list of params\n *\n * @method encodeParameters\n *\n * @param {Array<String|Object>} types\n * @param {Array<any>} params\n *\n * @return {String} encoded list of params\n */\nABICoder.prototype.encodeParameters = function (types, params) {\n    var self = this;\n    types = self.mapTypes(types);\n    params = params.map(function (param, index) {\n        let type = types[index];\n        if (typeof type === 'object' && type.type) {\n            // We may get a named type of shape {name, type}\n            type = type.type;\n        }\n        param = self.formatParam(type, param);\n        // Format params for tuples\n        if (typeof type === 'string' && type.includes('tuple')) {\n            const coder = ethersAbiCoder._getCoder(ParamType.from(type));\n            const modifyParams = (coder, param) => {\n                if (coder.name === 'array') {\n                    if (!coder.type.match(/\\[(\\d+)\\]/)) {\n                        return param.map(p => modifyParams(ethersAbiCoder._getCoder(ParamType.from(coder.type.replace('[]', ''))), p));\n                    }\n                    const arrayLength = parseInt(coder.type.match(/\\[(\\d+)\\]/)[1]);\n                    if (param.length !== arrayLength) {\n                        throw new Error('Array length does not matches with the given input');\n                    }\n                    return param.map(p => modifyParams(ethersAbiCoder._getCoder(ParamType.from(coder.type.replace(/\\[\\d+\\]/, ''))), p));\n                }\n                coder.coders.forEach((c, i) => {\n                    if (c.name === 'tuple') {\n                        modifyParams(c, param[i]);\n                    }\n                    else {\n                        param[i] = self.formatParam(c.name, param[i]);\n                    }\n                });\n            };\n            modifyParams(coder, param);\n        }\n        return param;\n    });\n    return ethersAbiCoder.encode(types, params);\n};\n/**\n * Map types if simplified format is used\n *\n * @method mapTypes\n * @param {Array} types\n * @return {Array}\n */\nABICoder.prototype.mapTypes = function (types) {\n    var self = this;\n    var mappedTypes = [];\n    types.forEach(function (type) {\n        // Remap `function` type params to bytes24 since Ethers does not\n        // recognize former type. Solidity docs say `Function` is a bytes24\n        // encoding the contract address followed by the function selector hash.\n        if (typeof type === 'object' && type.type === 'function') {\n            type = Object.assign({}, type, { type: \"bytes24\" });\n        }\n        if (self.isSimplifiedStructFormat(type)) {\n            var structName = Object.keys(type)[0];\n            mappedTypes.push(Object.assign(self.mapStructNameAndType(structName), {\n                components: self.mapStructToCoderFormat(type[structName])\n            }));\n            return;\n        }\n        mappedTypes.push(type);\n    });\n    return mappedTypes;\n};\n/**\n * Check if type is simplified struct format\n *\n * @method isSimplifiedStructFormat\n * @param {string | Object} type\n * @returns {boolean}\n */\nABICoder.prototype.isSimplifiedStructFormat = function (type) {\n    return typeof type === 'object' && typeof type.components === 'undefined' && typeof type.name === 'undefined';\n};\n/**\n * Maps the correct tuple type and name when the simplified format in encode/decodeParameter is used\n *\n * @method mapStructNameAndType\n * @param {string} structName\n * @return {{type: string, name: *}}\n */\nABICoder.prototype.mapStructNameAndType = function (structName) {\n    var type = 'tuple';\n    if (structName.indexOf('[]') > -1) {\n        type = 'tuple[]';\n        structName = structName.slice(0, -2);\n    }\n    return { type: type, name: structName };\n};\n/**\n * Maps the simplified format in to the expected format of the ABICoder\n *\n * @method mapStructToCoderFormat\n * @param {Object} struct\n * @return {Array}\n */\nABICoder.prototype.mapStructToCoderFormat = function (struct) {\n    var self = this;\n    var components = [];\n    Object.keys(struct).forEach(function (key) {\n        if (typeof struct[key] === 'object') {\n            components.push(Object.assign(self.mapStructNameAndType(key), {\n                components: self.mapStructToCoderFormat(struct[key])\n            }));\n            return;\n        }\n        components.push({\n            name: key,\n            type: struct[key]\n        });\n    });\n    return components;\n};\n/**\n * Handle some formatting of params for backwards compatability with Ethers V4\n *\n * @method formatParam\n * @param {String} - type\n * @param {any} - param\n * @return {any} - The formatted param\n */\nABICoder.prototype.formatParam = function (type, param) {\n    const paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);\n    const paramTypeBytesArray = new RegExp(/^bytes([0-9]*)\\[\\]$/);\n    const paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);\n    const paramTypeNumberArray = new RegExp(/^(u?int)([0-9]*)\\[\\]$/);\n    // Format BN to string\n    if (utils.isBN(param) || utils.isBigNumber(param)) {\n        return param.toString(10);\n    }\n    if (type.match(paramTypeBytesArray) || type.match(paramTypeNumberArray)) {\n        return param.map(p => this.formatParam(type.replace('[]', ''), p));\n    }\n    // Format correct width for u?int[0-9]*\n    let match = type.match(paramTypeNumber);\n    if (match) {\n        let size = parseInt(match[2] || \"256\");\n        if (size / 8 < param.length) {\n            param = param.startsWith(\"-\")\n                // pad to correct bit width, with - at the beginning\n                ? `-${utils.leftPad(param.substring(1), size)}`\n                // pad to correct bit width\n                : utils.leftPad(param, size);\n        }\n    }\n    // Format correct length for bytes[0-9]+\n    match = type.match(paramTypeBytes);\n    if (match) {\n        if (Buffer.isBuffer(param)) {\n            param = utils.toHex(param);\n        }\n        // format to correct length\n        let size = parseInt(match[1]);\n        if (size) {\n            let maxSize = size * 2;\n            if (param.substring(0, 2) === '0x') {\n                maxSize += 2;\n            }\n            if (param.length < maxSize) {\n                // pad to correct length\n                param = utils.rightPad(param, size * 2);\n            }\n        }\n        // format odd-length bytes to even-length\n        if (param.length % 2 === 1) {\n            param = '0x0' + param.substring(2);\n        }\n    }\n    return param;\n};\n/**\n * Encodes a function call from its json interface and parameters.\n *\n * @method encodeFunctionCall\n * @param {Array} jsonInterface\n * @param {Array} params\n * @return {String} The encoded ABI for this function call\n */\nABICoder.prototype.encodeFunctionCall = function (jsonInterface, params) {\n    return this.encodeFunctionSignature(jsonInterface) + this.encodeParameters(jsonInterface.inputs, params).replace('0x', '');\n};\n/**\n * Should be used to decode bytes to plain param\n *\n * @method decodeParameter\n * @param {String} type\n * @param {String} bytes\n * @return {Object} plain param\n */\nABICoder.prototype.decodeParameter = function (type, bytes) {\n    return this.decodeParameters([type], bytes)[0];\n};\n/**\n * Should be used to decode list of params\n *\n * @method decodeParameter\n * @param {Array} outputs\n * @param {String} bytes\n * @return {Array} array of plain params\n */\nABICoder.prototype.decodeParameters = function (outputs, bytes) {\n    return this.decodeParametersWith(outputs, bytes, false);\n};\n/**\n * Should be used to decode list of params\n *\n * @method decodeParameter\n * @param {Array} outputs\n * @param {String} bytes\n * @param {Boolean} loose\n * @return {Array} array of plain params\n */\nABICoder.prototype.decodeParametersWith = function (outputs, bytes, loose) {\n    if (outputs.length > 0 && (!bytes || bytes === '0x' || bytes === '0X')) {\n        throw new Error('Returned values aren\\'t valid, did it run Out of Gas? ' +\n            'You might also see this error if you are not using the ' +\n            'correct ABI for the contract you are retrieving data from, ' +\n            'requesting data from a block number that does not exist, ' +\n            'or querying a node which is not fully synced.');\n    }\n    var res = ethersAbiCoder.decode(this.mapTypes(outputs), '0x' + bytes.replace(/0x/i, ''), loose);\n    var returnValue = new Result();\n    returnValue.__length__ = 0;\n    outputs.forEach(function (output, i) {\n        var decodedValue = res[returnValue.__length__];\n        const isStringObject = typeof output === 'object' && output.type && output.type === 'string';\n        const isStringType = typeof output === 'string' && output === 'string';\n        // only convert `0x` to null if it's not string value\n        decodedValue = (decodedValue === '0x' && !isStringObject && !isStringType) ? null : decodedValue;\n        returnValue[i] = decodedValue;\n        if ((typeof output === 'function' || !!output && typeof output === 'object') && output.name) {\n            returnValue[output.name] = decodedValue;\n        }\n        returnValue.__length__++;\n    });\n    return returnValue;\n};\n/**\n * Decodes events non- and indexed parameters.\n *\n * @method decodeLog\n * @param {Object} inputs\n * @param {String} data\n * @param {Array} topics\n * @return {Array} array of plain params\n */\nABICoder.prototype.decodeLog = function (inputs, data, topics) {\n    var _this = this;\n    topics = Array.isArray(topics) ? topics : [topics];\n    data = data || '';\n    var notIndexedInputs = [];\n    var indexedParams = [];\n    var topicCount = 0;\n    // TODO check for anonymous logs?\n    inputs.forEach(function (input, i) {\n        if (input.indexed) {\n            indexedParams[i] = (['bool', 'int', 'uint', 'address', 'fixed', 'ufixed'].find(function (staticType) {\n                return input.type.indexOf(staticType) !== -1;\n            })) ? _this.decodeParameter(input.type, topics[topicCount]) : topics[topicCount];\n            topicCount++;\n        }\n        else {\n            notIndexedInputs[i] = input;\n        }\n    });\n    var nonIndexedData = data;\n    var notIndexedParams = (nonIndexedData) ? this.decodeParametersWith(notIndexedInputs, nonIndexedData, true) : [];\n    var returnValue = new Result();\n    returnValue.__length__ = 0;\n    inputs.forEach(function (res, i) {\n        returnValue[i] = (res.type === 'string') ? '' : null;\n        if (typeof notIndexedParams[i] !== 'undefined') {\n            returnValue[i] = notIndexedParams[i];\n        }\n        if (typeof indexedParams[i] !== 'undefined') {\n            returnValue[i] = indexedParams[i];\n        }\n        if (res.name) {\n            returnValue[res.name] = returnValue[i];\n        }\n        returnValue.__length__++;\n    });\n    return returnValue;\n};\nvar coder = new ABICoder();\nmodule.exports = coder;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL3dlYjMtZXRoLWFiaS9saWIvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsb0RBQXdCO0FBQ3JDLFlBQVksbUJBQU8sQ0FBQyxvRUFBWTtBQUNoQyxxQkFBcUIsd0hBQXNDO0FBQzNELGdCQUFnQix5SEFBdUM7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGVBQWU7QUFDMUIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGVBQWU7QUFDMUIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQixXQUFXLEtBQUs7QUFDaEI7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxzQkFBc0I7QUFDakMsV0FBVyxZQUFZO0FBQ3ZCO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxVQUFVLGlCQUFpQjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlCQUFpQjtBQUM1QixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxLQUFLO0FBQ2hCLFlBQVksS0FBSztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHdDQUF3QztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFFBQVE7QUFDbkIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsT0FBTztBQUNsQixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvYmFyYi9hYS9Bc3NvY2lhdGVkQWNjb3VudHMvbm9kZV9tb2R1bGVzL3dlYjMtZXRoLWFiaS9saWIvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiBUaGlzIGZpbGUgaXMgcGFydCBvZiB3ZWIzLmpzLlxuXG4gd2ViMy5qcyBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gd2ViMy5qcyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gYWxvbmcgd2l0aCB3ZWIzLmpzLiAgSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuICovXG4vKipcbiAqIEBmaWxlIGluZGV4LmpzXG4gKiBAYXV0aG9yIE1hcmVrIEtvdGV3aWN6IDxtYXJla0BwYXJpdHkuaW8+XG4gKiBAYXV0aG9yIEZhYmlhbiBWb2dlbHN0ZWxsZXIgPGZhYmlhbkBmcm96ZW1hbi5kZT5cbiAqIEBkYXRlIDIwMThcbiAqL1xudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlcjtcbnZhciB1dGlscyA9IHJlcXVpcmUoJ3dlYjMtdXRpbHMnKTtcbnZhciBFdGhlcnNBYmlDb2RlciA9IHJlcXVpcmUoJ0BldGhlcnNwcm9qZWN0L2FiaScpLkFiaUNvZGVyO1xudmFyIFBhcmFtVHlwZSA9IHJlcXVpcmUoJ0BldGhlcnNwcm9qZWN0L2FiaScpLlBhcmFtVHlwZTtcbnZhciBldGhlcnNBYmlDb2RlciA9IG5ldyBFdGhlcnNBYmlDb2RlcihmdW5jdGlvbiAodHlwZSwgdmFsdWUpIHtcbiAgICBpZiAodHlwZS5tYXRjaCgvXnU/aW50LykgJiYgIUFycmF5LmlzQXJyYXkodmFsdWUpICYmICghKCEhdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JykgfHwgdmFsdWUuY29uc3RydWN0b3IubmFtZSAhPT0gJ0JOJykpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn0pO1xuLy8gcmVzdWx0IG1ldGhvZFxuZnVuY3Rpb24gUmVzdWx0KCkge1xufVxuLyoqXG4gKiBBQklDb2RlciBwcm90b3R5cGUgc2hvdWxkIGJlIHVzZWQgdG8gZW5jb2RlL2RlY29kZSBzb2xpZGl0eSBwYXJhbXMgb2YgYW55IHR5cGVcbiAqL1xudmFyIEFCSUNvZGVyID0gZnVuY3Rpb24gKCkge1xufTtcbi8qKlxuICogRW5jb2RlcyB0aGUgZnVuY3Rpb24gbmFtZSB0byBpdHMgQUJJIHJlcHJlc2VudGF0aW9uLCB3aGljaCBhcmUgdGhlIGZpcnN0IDQgYnl0ZXMgb2YgdGhlIHNoYTMgb2YgdGhlIGZ1bmN0aW9uIG5hbWUgaW5jbHVkaW5nICB0eXBlcy5cbiAqXG4gKiBAbWV0aG9kIGVuY29kZUZ1bmN0aW9uU2lnbmF0dXJlXG4gKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IGZ1bmN0aW9uTmFtZVxuICogQHJldHVybiB7U3RyaW5nfSBlbmNvZGVkIGZ1bmN0aW9uIG5hbWVcbiAqL1xuQUJJQ29kZXIucHJvdG90eXBlLmVuY29kZUZ1bmN0aW9uU2lnbmF0dXJlID0gZnVuY3Rpb24gKGZ1bmN0aW9uTmFtZSkge1xuICAgIGlmICh0eXBlb2YgZnVuY3Rpb25OYW1lID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBmdW5jdGlvbk5hbWUgPT09ICdvYmplY3QnICYmIGZ1bmN0aW9uTmFtZSkge1xuICAgICAgICBmdW5jdGlvbk5hbWUgPSB1dGlscy5fanNvbkludGVyZmFjZU1ldGhvZFRvU3RyaW5nKGZ1bmN0aW9uTmFtZSk7XG4gICAgfVxuICAgIHJldHVybiB1dGlscy5zaGEzKGZ1bmN0aW9uTmFtZSkuc2xpY2UoMCwgMTApO1xufTtcbi8qKlxuICogRW5jb2RlcyB0aGUgZnVuY3Rpb24gbmFtZSB0byBpdHMgQUJJIHJlcHJlc2VudGF0aW9uLCB3aGljaCBhcmUgdGhlIGZpcnN0IDQgYnl0ZXMgb2YgdGhlIHNoYTMgb2YgdGhlIGZ1bmN0aW9uIG5hbWUgaW5jbHVkaW5nICB0eXBlcy5cbiAqXG4gKiBAbWV0aG9kIGVuY29kZUV2ZW50U2lnbmF0dXJlXG4gKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IGZ1bmN0aW9uTmFtZVxuICogQHJldHVybiB7U3RyaW5nfSBlbmNvZGVkIGZ1bmN0aW9uIG5hbWVcbiAqL1xuQUJJQ29kZXIucHJvdG90eXBlLmVuY29kZUV2ZW50U2lnbmF0dXJlID0gZnVuY3Rpb24gKGZ1bmN0aW9uTmFtZSkge1xuICAgIGlmICh0eXBlb2YgZnVuY3Rpb25OYW1lID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBmdW5jdGlvbk5hbWUgPT09ICdvYmplY3QnICYmIGZ1bmN0aW9uTmFtZSkge1xuICAgICAgICBmdW5jdGlvbk5hbWUgPSB1dGlscy5fanNvbkludGVyZmFjZU1ldGhvZFRvU3RyaW5nKGZ1bmN0aW9uTmFtZSk7XG4gICAgfVxuICAgIHJldHVybiB1dGlscy5zaGEzKGZ1bmN0aW9uTmFtZSk7XG59O1xuLyoqXG4gKiBTaG91bGQgYmUgdXNlZCB0byBlbmNvZGUgcGxhaW4gcGFyYW1cbiAqXG4gKiBAbWV0aG9kIGVuY29kZVBhcmFtZXRlclxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gdHlwZVxuICogQHBhcmFtIHthbnl9IHBhcmFtXG4gKlxuICogQHJldHVybiB7U3RyaW5nfSBlbmNvZGVkIHBsYWluIHBhcmFtXG4gKi9cbkFCSUNvZGVyLnByb3RvdHlwZS5lbmNvZGVQYXJhbWV0ZXIgPSBmdW5jdGlvbiAodHlwZSwgcGFyYW0pIHtcbiAgICByZXR1cm4gdGhpcy5lbmNvZGVQYXJhbWV0ZXJzKFt0eXBlXSwgW3BhcmFtXSk7XG59O1xuLyoqXG4gKiBTaG91bGQgYmUgdXNlZCB0byBlbmNvZGUgbGlzdCBvZiBwYXJhbXNcbiAqXG4gKiBAbWV0aG9kIGVuY29kZVBhcmFtZXRlcnNcbiAqXG4gKiBAcGFyYW0ge0FycmF5PFN0cmluZ3xPYmplY3Q+fSB0eXBlc1xuICogQHBhcmFtIHtBcnJheTxhbnk+fSBwYXJhbXNcbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9IGVuY29kZWQgbGlzdCBvZiBwYXJhbXNcbiAqL1xuQUJJQ29kZXIucHJvdG90eXBlLmVuY29kZVBhcmFtZXRlcnMgPSBmdW5jdGlvbiAodHlwZXMsIHBhcmFtcykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB0eXBlcyA9IHNlbGYubWFwVHlwZXModHlwZXMpO1xuICAgIHBhcmFtcyA9IHBhcmFtcy5tYXAoZnVuY3Rpb24gKHBhcmFtLCBpbmRleCkge1xuICAgICAgICBsZXQgdHlwZSA9IHR5cGVzW2luZGV4XTtcbiAgICAgICAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlLnR5cGUpIHtcbiAgICAgICAgICAgIC8vIFdlIG1heSBnZXQgYSBuYW1lZCB0eXBlIG9mIHNoYXBlIHtuYW1lLCB0eXBlfVxuICAgICAgICAgICAgdHlwZSA9IHR5cGUudHlwZTtcbiAgICAgICAgfVxuICAgICAgICBwYXJhbSA9IHNlbGYuZm9ybWF0UGFyYW0odHlwZSwgcGFyYW0pO1xuICAgICAgICAvLyBGb3JtYXQgcGFyYW1zIGZvciB0dXBsZXNcbiAgICAgICAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyAmJiB0eXBlLmluY2x1ZGVzKCd0dXBsZScpKSB7XG4gICAgICAgICAgICBjb25zdCBjb2RlciA9IGV0aGVyc0FiaUNvZGVyLl9nZXRDb2RlcihQYXJhbVR5cGUuZnJvbSh0eXBlKSk7XG4gICAgICAgICAgICBjb25zdCBtb2RpZnlQYXJhbXMgPSAoY29kZXIsIHBhcmFtKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGNvZGVyLm5hbWUgPT09ICdhcnJheScpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjb2Rlci50eXBlLm1hdGNoKC9cXFsoXFxkKylcXF0vKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcmFtLm1hcChwID0+IG1vZGlmeVBhcmFtcyhldGhlcnNBYmlDb2Rlci5fZ2V0Q29kZXIoUGFyYW1UeXBlLmZyb20oY29kZXIudHlwZS5yZXBsYWNlKCdbXScsICcnKSkpLCBwKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXJyYXlMZW5ndGggPSBwYXJzZUludChjb2Rlci50eXBlLm1hdGNoKC9cXFsoXFxkKylcXF0vKVsxXSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbS5sZW5ndGggIT09IGFycmF5TGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FycmF5IGxlbmd0aCBkb2VzIG5vdCBtYXRjaGVzIHdpdGggdGhlIGdpdmVuIGlucHV0Jyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcmFtLm1hcChwID0+IG1vZGlmeVBhcmFtcyhldGhlcnNBYmlDb2Rlci5fZ2V0Q29kZXIoUGFyYW1UeXBlLmZyb20oY29kZXIudHlwZS5yZXBsYWNlKC9cXFtcXGQrXFxdLywgJycpKSksIHApKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29kZXIuY29kZXJzLmZvckVhY2goKGMsIGkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGMubmFtZSA9PT0gJ3R1cGxlJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbW9kaWZ5UGFyYW1zKGMsIHBhcmFtW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtW2ldID0gc2VsZi5mb3JtYXRQYXJhbShjLm5hbWUsIHBhcmFtW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIG1vZGlmeVBhcmFtcyhjb2RlciwgcGFyYW0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJhbTtcbiAgICB9KTtcbiAgICByZXR1cm4gZXRoZXJzQWJpQ29kZXIuZW5jb2RlKHR5cGVzLCBwYXJhbXMpO1xufTtcbi8qKlxuICogTWFwIHR5cGVzIGlmIHNpbXBsaWZpZWQgZm9ybWF0IGlzIHVzZWRcbiAqXG4gKiBAbWV0aG9kIG1hcFR5cGVzXG4gKiBAcGFyYW0ge0FycmF5fSB0eXBlc1xuICogQHJldHVybiB7QXJyYXl9XG4gKi9cbkFCSUNvZGVyLnByb3RvdHlwZS5tYXBUeXBlcyA9IGZ1bmN0aW9uICh0eXBlcykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgbWFwcGVkVHlwZXMgPSBbXTtcbiAgICB0eXBlcy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIC8vIFJlbWFwIGBmdW5jdGlvbmAgdHlwZSBwYXJhbXMgdG8gYnl0ZXMyNCBzaW5jZSBFdGhlcnMgZG9lcyBub3RcbiAgICAgICAgLy8gcmVjb2duaXplIGZvcm1lciB0eXBlLiBTb2xpZGl0eSBkb2NzIHNheSBgRnVuY3Rpb25gIGlzIGEgYnl0ZXMyNFxuICAgICAgICAvLyBlbmNvZGluZyB0aGUgY29udHJhY3QgYWRkcmVzcyBmb2xsb3dlZCBieSB0aGUgZnVuY3Rpb24gc2VsZWN0b3IgaGFzaC5cbiAgICAgICAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlLnR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHR5cGUgPSBPYmplY3QuYXNzaWduKHt9LCB0eXBlLCB7IHR5cGU6IFwiYnl0ZXMyNFwiIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZWxmLmlzU2ltcGxpZmllZFN0cnVjdEZvcm1hdCh0eXBlKSkge1xuICAgICAgICAgICAgdmFyIHN0cnVjdE5hbWUgPSBPYmplY3Qua2V5cyh0eXBlKVswXTtcbiAgICAgICAgICAgIG1hcHBlZFR5cGVzLnB1c2goT2JqZWN0LmFzc2lnbihzZWxmLm1hcFN0cnVjdE5hbWVBbmRUeXBlKHN0cnVjdE5hbWUpLCB7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50czogc2VsZi5tYXBTdHJ1Y3RUb0NvZGVyRm9ybWF0KHR5cGVbc3RydWN0TmFtZV0pXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbWFwcGVkVHlwZXMucHVzaCh0eXBlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gbWFwcGVkVHlwZXM7XG59O1xuLyoqXG4gKiBDaGVjayBpZiB0eXBlIGlzIHNpbXBsaWZpZWQgc3RydWN0IGZvcm1hdFxuICpcbiAqIEBtZXRob2QgaXNTaW1wbGlmaWVkU3RydWN0Rm9ybWF0XG4gKiBAcGFyYW0ge3N0cmluZyB8IE9iamVjdH0gdHlwZVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbkFCSUNvZGVyLnByb3RvdHlwZS5pc1NpbXBsaWZpZWRTdHJ1Y3RGb3JtYXQgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgIHJldHVybiB0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHR5cGUuY29tcG9uZW50cyA9PT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHR5cGUubmFtZSA9PT0gJ3VuZGVmaW5lZCc7XG59O1xuLyoqXG4gKiBNYXBzIHRoZSBjb3JyZWN0IHR1cGxlIHR5cGUgYW5kIG5hbWUgd2hlbiB0aGUgc2ltcGxpZmllZCBmb3JtYXQgaW4gZW5jb2RlL2RlY29kZVBhcmFtZXRlciBpcyB1c2VkXG4gKlxuICogQG1ldGhvZCBtYXBTdHJ1Y3ROYW1lQW5kVHlwZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0cnVjdE5hbWVcbiAqIEByZXR1cm4ge3t0eXBlOiBzdHJpbmcsIG5hbWU6ICp9fVxuICovXG5BQklDb2Rlci5wcm90b3R5cGUubWFwU3RydWN0TmFtZUFuZFR5cGUgPSBmdW5jdGlvbiAoc3RydWN0TmFtZSkge1xuICAgIHZhciB0eXBlID0gJ3R1cGxlJztcbiAgICBpZiAoc3RydWN0TmFtZS5pbmRleE9mKCdbXScpID4gLTEpIHtcbiAgICAgICAgdHlwZSA9ICd0dXBsZVtdJztcbiAgICAgICAgc3RydWN0TmFtZSA9IHN0cnVjdE5hbWUuc2xpY2UoMCwgLTIpO1xuICAgIH1cbiAgICByZXR1cm4geyB0eXBlOiB0eXBlLCBuYW1lOiBzdHJ1Y3ROYW1lIH07XG59O1xuLyoqXG4gKiBNYXBzIHRoZSBzaW1wbGlmaWVkIGZvcm1hdCBpbiB0byB0aGUgZXhwZWN0ZWQgZm9ybWF0IG9mIHRoZSBBQklDb2RlclxuICpcbiAqIEBtZXRob2QgbWFwU3RydWN0VG9Db2RlckZvcm1hdFxuICogQHBhcmFtIHtPYmplY3R9IHN0cnVjdFxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cbkFCSUNvZGVyLnByb3RvdHlwZS5tYXBTdHJ1Y3RUb0NvZGVyRm9ybWF0ID0gZnVuY3Rpb24gKHN0cnVjdCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgY29tcG9uZW50cyA9IFtdO1xuICAgIE9iamVjdC5rZXlzKHN0cnVjdCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc3RydWN0W2tleV0gPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBjb21wb25lbnRzLnB1c2goT2JqZWN0LmFzc2lnbihzZWxmLm1hcFN0cnVjdE5hbWVBbmRUeXBlKGtleSksIHtcbiAgICAgICAgICAgICAgICBjb21wb25lbnRzOiBzZWxmLm1hcFN0cnVjdFRvQ29kZXJGb3JtYXQoc3RydWN0W2tleV0pXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29tcG9uZW50cy5wdXNoKHtcbiAgICAgICAgICAgIG5hbWU6IGtleSxcbiAgICAgICAgICAgIHR5cGU6IHN0cnVjdFtrZXldXG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiBjb21wb25lbnRzO1xufTtcbi8qKlxuICogSGFuZGxlIHNvbWUgZm9ybWF0dGluZyBvZiBwYXJhbXMgZm9yIGJhY2t3YXJkcyBjb21wYXRhYmlsaXR5IHdpdGggRXRoZXJzIFY0XG4gKlxuICogQG1ldGhvZCBmb3JtYXRQYXJhbVxuICogQHBhcmFtIHtTdHJpbmd9IC0gdHlwZVxuICogQHBhcmFtIHthbnl9IC0gcGFyYW1cbiAqIEByZXR1cm4ge2FueX0gLSBUaGUgZm9ybWF0dGVkIHBhcmFtXG4gKi9cbkFCSUNvZGVyLnByb3RvdHlwZS5mb3JtYXRQYXJhbSA9IGZ1bmN0aW9uICh0eXBlLCBwYXJhbSkge1xuICAgIGNvbnN0IHBhcmFtVHlwZUJ5dGVzID0gbmV3IFJlZ0V4cCgvXmJ5dGVzKFswLTldKikkLyk7XG4gICAgY29uc3QgcGFyYW1UeXBlQnl0ZXNBcnJheSA9IG5ldyBSZWdFeHAoL15ieXRlcyhbMC05XSopXFxbXFxdJC8pO1xuICAgIGNvbnN0IHBhcmFtVHlwZU51bWJlciA9IG5ldyBSZWdFeHAoL14odT9pbnQpKFswLTldKikkLyk7XG4gICAgY29uc3QgcGFyYW1UeXBlTnVtYmVyQXJyYXkgPSBuZXcgUmVnRXhwKC9eKHU/aW50KShbMC05XSopXFxbXFxdJC8pO1xuICAgIC8vIEZvcm1hdCBCTiB0byBzdHJpbmdcbiAgICBpZiAodXRpbHMuaXNCTihwYXJhbSkgfHwgdXRpbHMuaXNCaWdOdW1iZXIocGFyYW0pKSB7XG4gICAgICAgIHJldHVybiBwYXJhbS50b1N0cmluZygxMCk7XG4gICAgfVxuICAgIGlmICh0eXBlLm1hdGNoKHBhcmFtVHlwZUJ5dGVzQXJyYXkpIHx8IHR5cGUubWF0Y2gocGFyYW1UeXBlTnVtYmVyQXJyYXkpKSB7XG4gICAgICAgIHJldHVybiBwYXJhbS5tYXAocCA9PiB0aGlzLmZvcm1hdFBhcmFtKHR5cGUucmVwbGFjZSgnW10nLCAnJyksIHApKTtcbiAgICB9XG4gICAgLy8gRm9ybWF0IGNvcnJlY3Qgd2lkdGggZm9yIHU/aW50WzAtOV0qXG4gICAgbGV0IG1hdGNoID0gdHlwZS5tYXRjaChwYXJhbVR5cGVOdW1iZXIpO1xuICAgIGlmIChtYXRjaCkge1xuICAgICAgICBsZXQgc2l6ZSA9IHBhcnNlSW50KG1hdGNoWzJdIHx8IFwiMjU2XCIpO1xuICAgICAgICBpZiAoc2l6ZSAvIDggPCBwYXJhbS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHBhcmFtID0gcGFyYW0uc3RhcnRzV2l0aChcIi1cIilcbiAgICAgICAgICAgICAgICAvLyBwYWQgdG8gY29ycmVjdCBiaXQgd2lkdGgsIHdpdGggLSBhdCB0aGUgYmVnaW5uaW5nXG4gICAgICAgICAgICAgICAgPyBgLSR7dXRpbHMubGVmdFBhZChwYXJhbS5zdWJzdHJpbmcoMSksIHNpemUpfWBcbiAgICAgICAgICAgICAgICAvLyBwYWQgdG8gY29ycmVjdCBiaXQgd2lkdGhcbiAgICAgICAgICAgICAgICA6IHV0aWxzLmxlZnRQYWQocGFyYW0sIHNpemUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEZvcm1hdCBjb3JyZWN0IGxlbmd0aCBmb3IgYnl0ZXNbMC05XStcbiAgICBtYXRjaCA9IHR5cGUubWF0Y2gocGFyYW1UeXBlQnl0ZXMpO1xuICAgIGlmIChtYXRjaCkge1xuICAgICAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKHBhcmFtKSkge1xuICAgICAgICAgICAgcGFyYW0gPSB1dGlscy50b0hleChwYXJhbSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZm9ybWF0IHRvIGNvcnJlY3QgbGVuZ3RoXG4gICAgICAgIGxldCBzaXplID0gcGFyc2VJbnQobWF0Y2hbMV0pO1xuICAgICAgICBpZiAoc2l6ZSkge1xuICAgICAgICAgICAgbGV0IG1heFNpemUgPSBzaXplICogMjtcbiAgICAgICAgICAgIGlmIChwYXJhbS5zdWJzdHJpbmcoMCwgMikgPT09ICcweCcpIHtcbiAgICAgICAgICAgICAgICBtYXhTaXplICs9IDI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFyYW0ubGVuZ3RoIDwgbWF4U2l6ZSkge1xuICAgICAgICAgICAgICAgIC8vIHBhZCB0byBjb3JyZWN0IGxlbmd0aFxuICAgICAgICAgICAgICAgIHBhcmFtID0gdXRpbHMucmlnaHRQYWQocGFyYW0sIHNpemUgKiAyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBmb3JtYXQgb2RkLWxlbmd0aCBieXRlcyB0byBldmVuLWxlbmd0aFxuICAgICAgICBpZiAocGFyYW0ubGVuZ3RoICUgMiA9PT0gMSkge1xuICAgICAgICAgICAgcGFyYW0gPSAnMHgwJyArIHBhcmFtLnN1YnN0cmluZygyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcGFyYW07XG59O1xuLyoqXG4gKiBFbmNvZGVzIGEgZnVuY3Rpb24gY2FsbCBmcm9tIGl0cyBqc29uIGludGVyZmFjZSBhbmQgcGFyYW1ldGVycy5cbiAqXG4gKiBAbWV0aG9kIGVuY29kZUZ1bmN0aW9uQ2FsbFxuICogQHBhcmFtIHtBcnJheX0ganNvbkludGVyZmFjZVxuICogQHBhcmFtIHtBcnJheX0gcGFyYW1zXG4gKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSBlbmNvZGVkIEFCSSBmb3IgdGhpcyBmdW5jdGlvbiBjYWxsXG4gKi9cbkFCSUNvZGVyLnByb3RvdHlwZS5lbmNvZGVGdW5jdGlvbkNhbGwgPSBmdW5jdGlvbiAoanNvbkludGVyZmFjZSwgcGFyYW1zKSB7XG4gICAgcmV0dXJuIHRoaXMuZW5jb2RlRnVuY3Rpb25TaWduYXR1cmUoanNvbkludGVyZmFjZSkgKyB0aGlzLmVuY29kZVBhcmFtZXRlcnMoanNvbkludGVyZmFjZS5pbnB1dHMsIHBhcmFtcykucmVwbGFjZSgnMHgnLCAnJyk7XG59O1xuLyoqXG4gKiBTaG91bGQgYmUgdXNlZCB0byBkZWNvZGUgYnl0ZXMgdG8gcGxhaW4gcGFyYW1cbiAqXG4gKiBAbWV0aG9kIGRlY29kZVBhcmFtZXRlclxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBieXRlc1xuICogQHJldHVybiB7T2JqZWN0fSBwbGFpbiBwYXJhbVxuICovXG5BQklDb2Rlci5wcm90b3R5cGUuZGVjb2RlUGFyYW1ldGVyID0gZnVuY3Rpb24gKHR5cGUsIGJ5dGVzKSB7XG4gICAgcmV0dXJuIHRoaXMuZGVjb2RlUGFyYW1ldGVycyhbdHlwZV0sIGJ5dGVzKVswXTtcbn07XG4vKipcbiAqIFNob3VsZCBiZSB1c2VkIHRvIGRlY29kZSBsaXN0IG9mIHBhcmFtc1xuICpcbiAqIEBtZXRob2QgZGVjb2RlUGFyYW1ldGVyXG4gKiBAcGFyYW0ge0FycmF5fSBvdXRwdXRzXG4gKiBAcGFyYW0ge1N0cmluZ30gYnl0ZXNcbiAqIEByZXR1cm4ge0FycmF5fSBhcnJheSBvZiBwbGFpbiBwYXJhbXNcbiAqL1xuQUJJQ29kZXIucHJvdG90eXBlLmRlY29kZVBhcmFtZXRlcnMgPSBmdW5jdGlvbiAob3V0cHV0cywgYnl0ZXMpIHtcbiAgICByZXR1cm4gdGhpcy5kZWNvZGVQYXJhbWV0ZXJzV2l0aChvdXRwdXRzLCBieXRlcywgZmFsc2UpO1xufTtcbi8qKlxuICogU2hvdWxkIGJlIHVzZWQgdG8gZGVjb2RlIGxpc3Qgb2YgcGFyYW1zXG4gKlxuICogQG1ldGhvZCBkZWNvZGVQYXJhbWV0ZXJcbiAqIEBwYXJhbSB7QXJyYXl9IG91dHB1dHNcbiAqIEBwYXJhbSB7U3RyaW5nfSBieXRlc1xuICogQHBhcmFtIHtCb29sZWFufSBsb29zZVxuICogQHJldHVybiB7QXJyYXl9IGFycmF5IG9mIHBsYWluIHBhcmFtc1xuICovXG5BQklDb2Rlci5wcm90b3R5cGUuZGVjb2RlUGFyYW1ldGVyc1dpdGggPSBmdW5jdGlvbiAob3V0cHV0cywgYnl0ZXMsIGxvb3NlKSB7XG4gICAgaWYgKG91dHB1dHMubGVuZ3RoID4gMCAmJiAoIWJ5dGVzIHx8IGJ5dGVzID09PSAnMHgnIHx8IGJ5dGVzID09PSAnMFgnKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JldHVybmVkIHZhbHVlcyBhcmVuXFwndCB2YWxpZCwgZGlkIGl0IHJ1biBPdXQgb2YgR2FzPyAnICtcbiAgICAgICAgICAgICdZb3UgbWlnaHQgYWxzbyBzZWUgdGhpcyBlcnJvciBpZiB5b3UgYXJlIG5vdCB1c2luZyB0aGUgJyArXG4gICAgICAgICAgICAnY29ycmVjdCBBQkkgZm9yIHRoZSBjb250cmFjdCB5b3UgYXJlIHJldHJpZXZpbmcgZGF0YSBmcm9tLCAnICtcbiAgICAgICAgICAgICdyZXF1ZXN0aW5nIGRhdGEgZnJvbSBhIGJsb2NrIG51bWJlciB0aGF0IGRvZXMgbm90IGV4aXN0LCAnICtcbiAgICAgICAgICAgICdvciBxdWVyeWluZyBhIG5vZGUgd2hpY2ggaXMgbm90IGZ1bGx5IHN5bmNlZC4nKTtcbiAgICB9XG4gICAgdmFyIHJlcyA9IGV0aGVyc0FiaUNvZGVyLmRlY29kZSh0aGlzLm1hcFR5cGVzKG91dHB1dHMpLCAnMHgnICsgYnl0ZXMucmVwbGFjZSgvMHgvaSwgJycpLCBsb29zZSk7XG4gICAgdmFyIHJldHVyblZhbHVlID0gbmV3IFJlc3VsdCgpO1xuICAgIHJldHVyblZhbHVlLl9fbGVuZ3RoX18gPSAwO1xuICAgIG91dHB1dHMuZm9yRWFjaChmdW5jdGlvbiAob3V0cHV0LCBpKSB7XG4gICAgICAgIHZhciBkZWNvZGVkVmFsdWUgPSByZXNbcmV0dXJuVmFsdWUuX19sZW5ndGhfX107XG4gICAgICAgIGNvbnN0IGlzU3RyaW5nT2JqZWN0ID0gdHlwZW9mIG91dHB1dCA9PT0gJ29iamVjdCcgJiYgb3V0cHV0LnR5cGUgJiYgb3V0cHV0LnR5cGUgPT09ICdzdHJpbmcnO1xuICAgICAgICBjb25zdCBpc1N0cmluZ1R5cGUgPSB0eXBlb2Ygb3V0cHV0ID09PSAnc3RyaW5nJyAmJiBvdXRwdXQgPT09ICdzdHJpbmcnO1xuICAgICAgICAvLyBvbmx5IGNvbnZlcnQgYDB4YCB0byBudWxsIGlmIGl0J3Mgbm90IHN0cmluZyB2YWx1ZVxuICAgICAgICBkZWNvZGVkVmFsdWUgPSAoZGVjb2RlZFZhbHVlID09PSAnMHgnICYmICFpc1N0cmluZ09iamVjdCAmJiAhaXNTdHJpbmdUeXBlKSA/IG51bGwgOiBkZWNvZGVkVmFsdWU7XG4gICAgICAgIHJldHVyblZhbHVlW2ldID0gZGVjb2RlZFZhbHVlO1xuICAgICAgICBpZiAoKHR5cGVvZiBvdXRwdXQgPT09ICdmdW5jdGlvbicgfHwgISFvdXRwdXQgJiYgdHlwZW9mIG91dHB1dCA9PT0gJ29iamVjdCcpICYmIG91dHB1dC5uYW1lKSB7XG4gICAgICAgICAgICByZXR1cm5WYWx1ZVtvdXRwdXQubmFtZV0gPSBkZWNvZGVkVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuVmFsdWUuX19sZW5ndGhfXysrO1xuICAgIH0pO1xuICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbn07XG4vKipcbiAqIERlY29kZXMgZXZlbnRzIG5vbi0gYW5kIGluZGV4ZWQgcGFyYW1ldGVycy5cbiAqXG4gKiBAbWV0aG9kIGRlY29kZUxvZ1xuICogQHBhcmFtIHtPYmplY3R9IGlucHV0c1xuICogQHBhcmFtIHtTdHJpbmd9IGRhdGFcbiAqIEBwYXJhbSB7QXJyYXl9IHRvcGljc1xuICogQHJldHVybiB7QXJyYXl9IGFycmF5IG9mIHBsYWluIHBhcmFtc1xuICovXG5BQklDb2Rlci5wcm90b3R5cGUuZGVjb2RlTG9nID0gZnVuY3Rpb24gKGlucHV0cywgZGF0YSwgdG9waWNzKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICB0b3BpY3MgPSBBcnJheS5pc0FycmF5KHRvcGljcykgPyB0b3BpY3MgOiBbdG9waWNzXTtcbiAgICBkYXRhID0gZGF0YSB8fCAnJztcbiAgICB2YXIgbm90SW5kZXhlZElucHV0cyA9IFtdO1xuICAgIHZhciBpbmRleGVkUGFyYW1zID0gW107XG4gICAgdmFyIHRvcGljQ291bnQgPSAwO1xuICAgIC8vIFRPRE8gY2hlY2sgZm9yIGFub255bW91cyBsb2dzP1xuICAgIGlucHV0cy5mb3JFYWNoKGZ1bmN0aW9uIChpbnB1dCwgaSkge1xuICAgICAgICBpZiAoaW5wdXQuaW5kZXhlZCkge1xuICAgICAgICAgICAgaW5kZXhlZFBhcmFtc1tpXSA9IChbJ2Jvb2wnLCAnaW50JywgJ3VpbnQnLCAnYWRkcmVzcycsICdmaXhlZCcsICd1Zml4ZWQnXS5maW5kKGZ1bmN0aW9uIChzdGF0aWNUeXBlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlucHV0LnR5cGUuaW5kZXhPZihzdGF0aWNUeXBlKSAhPT0gLTE7XG4gICAgICAgICAgICB9KSkgPyBfdGhpcy5kZWNvZGVQYXJhbWV0ZXIoaW5wdXQudHlwZSwgdG9waWNzW3RvcGljQ291bnRdKSA6IHRvcGljc1t0b3BpY0NvdW50XTtcbiAgICAgICAgICAgIHRvcGljQ291bnQrKztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG5vdEluZGV4ZWRJbnB1dHNbaV0gPSBpbnB1dDtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHZhciBub25JbmRleGVkRGF0YSA9IGRhdGE7XG4gICAgdmFyIG5vdEluZGV4ZWRQYXJhbXMgPSAobm9uSW5kZXhlZERhdGEpID8gdGhpcy5kZWNvZGVQYXJhbWV0ZXJzV2l0aChub3RJbmRleGVkSW5wdXRzLCBub25JbmRleGVkRGF0YSwgdHJ1ZSkgOiBbXTtcbiAgICB2YXIgcmV0dXJuVmFsdWUgPSBuZXcgUmVzdWx0KCk7XG4gICAgcmV0dXJuVmFsdWUuX19sZW5ndGhfXyA9IDA7XG4gICAgaW5wdXRzLmZvckVhY2goZnVuY3Rpb24gKHJlcywgaSkge1xuICAgICAgICByZXR1cm5WYWx1ZVtpXSA9IChyZXMudHlwZSA9PT0gJ3N0cmluZycpID8gJycgOiBudWxsO1xuICAgICAgICBpZiAodHlwZW9mIG5vdEluZGV4ZWRQYXJhbXNbaV0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm5WYWx1ZVtpXSA9IG5vdEluZGV4ZWRQYXJhbXNbaV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBpbmRleGVkUGFyYW1zW2ldICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuVmFsdWVbaV0gPSBpbmRleGVkUGFyYW1zW2ldO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXMubmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuVmFsdWVbcmVzLm5hbWVdID0gcmV0dXJuVmFsdWVbaV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuVmFsdWUuX19sZW5ndGhfXysrO1xuICAgIH0pO1xuICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbn07XG52YXIgY29kZXIgPSBuZXcgQUJJQ29kZXIoKTtcbm1vZHVsZS5leHBvcnRzID0gY29kZXI7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/web3-eth-abi/lib/index.js\n");

/***/ })

};
;