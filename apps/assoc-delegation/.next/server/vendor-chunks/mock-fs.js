/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/mock-fs";
exports.ids = ["vendor-chunks/mock-fs"];
exports.modules = {

/***/ "(rsc)/../../node_modules/mock-fs/lib/binding.js":
/*!*************************************************!*\
  !*** ../../node_modules/mock-fs/lib/binding.js ***!
  \*************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\n\nconst path = __webpack_require__(/*! path */ \"path\");\n\nconst File = __webpack_require__(/*! ./file */ \"(rsc)/../../node_modules/mock-fs/lib/file.js\");\nconst FileDescriptor = __webpack_require__(/*! ./descriptor */ \"(rsc)/../../node_modules/mock-fs/lib/descriptor.js\");\nconst Directory = __webpack_require__(/*! ./directory */ \"(rsc)/../../node_modules/mock-fs/lib/directory.js\");\nconst SymbolicLink = __webpack_require__(/*! ./symlink */ \"(rsc)/../../node_modules/mock-fs/lib/symlink.js\");\nconst FSError = __webpack_require__(/*! ./error */ \"(rsc)/../../node_modules/mock-fs/lib/error.js\");\nconst constants = __webpack_require__(/*! constants */ \"constants\");\nconst getPathParts = (__webpack_require__(/*! ./filesystem */ \"(rsc)/../../node_modules/mock-fs/lib/filesystem.js\").getPathParts);\nconst bufferFrom = (__webpack_require__(/*! ./buffer */ \"(rsc)/../../node_modules/mock-fs/lib/buffer.js\").from);\nconst bufferAlloc = (__webpack_require__(/*! ./buffer */ \"(rsc)/../../node_modules/mock-fs/lib/buffer.js\").alloc);\n\nconst MODE_TO_KTYPE = {\n  [constants.S_IFREG]: constants.UV_DIRENT_FILE,\n  [constants.S_IFDIR]: constants.UV_DIRENT_DIR,\n  [constants.S_IFBLK]: constants.UV_DIRENT_BLOCK,\n  [constants.S_IFCHR]: constants.UV_DIRENT_CHAR,\n  [constants.S_IFLNK]: constants.UV_DIRENT_LINK,\n  [constants.S_IFIFO]: constants.UV_DIRENT_FIFO,\n  [constants.S_IFSOCK]: constants.UV_DIRENT_SOCKET\n};\n\n/** Workaround for optimizations in node 8+ */\nconst fsBinding = process.binding('fs');\nconst kUsePromises = fsBinding.kUsePromises;\nlet statValues;\nif (fsBinding.statValues) {\n  statValues = fsBinding.statValues; // node 10+\n} else if (fsBinding.getStatValues) {\n  statValues = fsBinding.getStatValues(); // node 8\n} else {\n  statValues = [];\n}\n\n// nodejs v6,8,10 and v12 before v12.10.0 has length 28\n// nodejs v12.10.0+ has length 36\nconst statContainsNs = statValues.length > 28;\n\n/** Introduction of BigUint64Array in 10.5 */\nlet BigUint64Array;\nif (global.BigUint64Array) {\n  BigUint64Array = global.BigUint64Array;\n} else {\n  BigUint64Array = function() {};\n}\n\nconst MAX_LINKS = 50;\n\n/**\n * Call the provided function and either return the result or call the callback\n * with it (depending on if a callback is provided).\n * @param {function()} callback Optional callback.\n * @param {Object} ctx Context object (optional), only for nodejs v10+.\n * @param {Object} thisArg This argument for the following function.\n * @param {function()} func Function to call.\n * @return {*} Return (if callback is not provided).\n */\nfunction maybeCallback(callback, ctx, thisArg, func) {\n  let err = null;\n  let val;\n\n  if (kUsePromises && callback === kUsePromises) {\n    // support nodejs v10+ fs.promises\n    try {\n      val = func.call(thisArg);\n    } catch (e) {\n      err = e;\n    }\n    return new Promise(function(resolve, reject) {\n      process.nextTick(function() {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(val);\n        }\n      });\n    });\n  } else if (callback && typeof callback === 'function') {\n    try {\n      val = func.call(thisArg);\n    } catch (e) {\n      err = e;\n    }\n    process.nextTick(function() {\n      if (val === undefined) {\n        callback(err);\n      } else {\n        callback(err, val);\n      }\n    });\n  } else if (ctx && typeof ctx === 'object') {\n    try {\n      return func.call(thisArg);\n    } catch (e) {\n      // default to errno for UNKNOWN\n      ctx.code = e.code || 'UNKNOWN';\n      ctx.errno = e.errno || FSError.codes.UNKNOWN.errno;\n    }\n  } else {\n    return func.call(thisArg);\n  }\n}\n\n/**\n * set syscall property on context object, only for nodejs v10+.\n * @param {Object} ctx Context object (optional), only for nodejs v10+.\n * @param {String} syscall Name of syscall.\n */\nfunction markSyscall(ctx, syscall) {\n  if (ctx && typeof ctx === 'object') {\n    ctx.syscall = syscall;\n  }\n}\n\n/**\n * Handle FSReqWrap oncomplete.\n * @param {Function} callback The callback.\n * @return {Function} The normalized callback.\n */\nfunction normalizeCallback(callback) {\n  if (callback && typeof callback.oncomplete === 'function') {\n    // Unpack callback from FSReqWrap\n    callback = callback.oncomplete.bind(callback);\n  }\n  return callback;\n}\n\n/**\n * Handle stat optimizations introduced in Node 8.\n * See https://github.com/nodejs/node/pull/11665.\n * @param {Function} callback The callback.\n * @return {Function} The wrapped callback.\n */\nfunction wrapStatsCallback(callback) {\n  if (callback && typeof callback.oncomplete === 'function') {\n    // Unpack callback from FSReqWrap\n    callback = callback.oncomplete.bind(callback);\n  }\n  if (typeof callback === 'function') {\n    return function(err, stats) {\n      if (stats) {\n        fillStatsArray(stats, statValues);\n      }\n      callback.apply(this, arguments);\n    };\n  } else {\n    return callback;\n  }\n}\n\nfunction getDirentType(mode) {\n  const ktype = MODE_TO_KTYPE[mode & constants.S_IFMT];\n\n  if (ktype === undefined) {\n    return constants.UV_DIRENT_UNKNOWN;\n  }\n\n  return ktype;\n}\n\nfunction notImplemented() {\n  throw new Error('Method not implemented');\n}\n\nfunction deBuffer(p) {\n  return Buffer.isBuffer(p) ? p.toString() : p;\n}\n\n/**\n * Create a new stats object.\n * @param {Object} config Stats properties.\n * @constructor\n */\nfunction Stats(config) {\n  for (const key in config) {\n    this[key] = config[key];\n  }\n  // node 10 expects an array internally\n  // see https://github.com/nodejs/node/pull/19714\n  fillStatsArray(config, this);\n}\n\n/**\n * Check if mode indicates property.\n * @param {number} property Property to check.\n * @return {boolean} Property matches mode.\n */\nStats.prototype._checkModeProperty = function(property) {\n  return (this.mode & constants.S_IFMT) === property;\n};\n\n/**\n * @return {Boolean} Is a directory.\n */\nStats.prototype.isDirectory = function() {\n  return this._checkModeProperty(constants.S_IFDIR);\n};\n\n/**\n * @return {Boolean} Is a regular file.\n */\nStats.prototype.isFile = function() {\n  return this._checkModeProperty(constants.S_IFREG);\n};\n\n/**\n * @return {Boolean} Is a block device.\n */\nStats.prototype.isBlockDevice = function() {\n  return this._checkModeProperty(constants.S_IFBLK);\n};\n\n/**\n * @return {Boolean} Is a character device.\n */\nStats.prototype.isCharacterDevice = function() {\n  return this._checkModeProperty(constants.S_IFCHR);\n};\n\n/**\n * @return {Boolean} Is a symbolic link.\n */\nStats.prototype.isSymbolicLink = function() {\n  return this._checkModeProperty(constants.S_IFLNK);\n};\n\n/**\n * @return {Boolean} Is a named pipe.\n */\nStats.prototype.isFIFO = function() {\n  return this._checkModeProperty(constants.S_IFIFO);\n};\n\n/**\n * @return {Boolean} Is a socket.\n */\nStats.prototype.isSocket = function() {\n  return this._checkModeProperty(constants.S_IFSOCK);\n};\n\n/**\n * Create a new binding with the given file system.\n * @param {FileSystem} system Mock file system.\n * @constructor\n */\nfunction Binding(system) {\n  /**\n   * Mock file system.\n   * @type {FileSystem}\n   */\n  this._system = system;\n\n  /**\n   * Stats constructor.\n   * @type {function}\n   */\n  this.Stats = Stats;\n\n  /**\n   * Lookup of open files.\n   * @type {Object.<number, FileDescriptor>}\n   */\n  this._openFiles = {};\n\n  /**\n   * Counter for file descriptors.\n   * @type {number}\n   */\n  this._counter = -1;\n\n  const stdin = new FileDescriptor(constants.O_RDWR);\n  stdin.setItem(new File.StandardInput());\n  this.trackDescriptor(stdin);\n\n  const stdout = new FileDescriptor(constants.O_RDWR);\n  stdout.setItem(new File.StandardOutput());\n  this.trackDescriptor(stdout);\n\n  const stderr = new FileDescriptor(constants.O_RDWR);\n  stderr.setItem(new File.StandardError());\n  this.trackDescriptor(stderr);\n}\n\n/**\n * Get the file system underlying this binding.\n * @return {FileSystem} The underlying file system.\n */\nBinding.prototype.getSystem = function() {\n  return this._system;\n};\n\n/**\n * Reset the file system underlying this binding.\n * @param {FileSystem} system The new file system.\n */\nBinding.prototype.setSystem = function(system) {\n  this._system = system;\n};\n\n/**\n * Get a file descriptor.\n * @param {number} fd File descriptor identifier.\n * @return {FileDescriptor} File descriptor.\n */\nBinding.prototype.getDescriptorById = function(fd) {\n  if (!this._openFiles.hasOwnProperty(fd)) {\n    throw new FSError('EBADF');\n  }\n  return this._openFiles[fd];\n};\n\n/**\n * Keep track of a file descriptor as open.\n * @param {FileDescriptor} descriptor The file descriptor.\n * @return {number} Identifier for file descriptor.\n */\nBinding.prototype.trackDescriptor = function(descriptor) {\n  const fd = ++this._counter;\n  this._openFiles[fd] = descriptor;\n  return fd;\n};\n\n/**\n * Stop tracking a file descriptor as open.\n * @param {number} fd Identifier for file descriptor.\n */\nBinding.prototype.untrackDescriptorById = function(fd) {\n  if (!this._openFiles.hasOwnProperty(fd)) {\n    throw new FSError('EBADF');\n  }\n  delete this._openFiles[fd];\n};\n\n/**\n * Resolve the canonicalized absolute pathname.\n * @param {string|Buffer} filepath The file path.\n * @param {string} encoding The encoding for the return.\n * @param {Object} ctx Context object (optional), only for nodejs v10+.\n * @return {string|Buffer} The real path.\n */\nBinding.prototype.realpath = function(filepath, encoding, callback, ctx) {\n  markSyscall(ctx, 'realpath');\n\n  return maybeCallback(normalizeCallback(callback), ctx, this, function() {\n    let realPath;\n    filepath = deBuffer(filepath);\n    const resolved = path.resolve(filepath);\n    const parts = getPathParts(resolved);\n    let item = this._system.getRoot();\n    let itemPath = '/';\n    let name, i, ii;\n    for (i = 0, ii = parts.length; i < ii; ++i) {\n      name = parts[i];\n      while (item instanceof SymbolicLink) {\n        itemPath = path.resolve(path.dirname(itemPath), item.getPath());\n        item = this._system.getItem(itemPath);\n      }\n      if (!item) {\n        throw new FSError('ENOENT', filepath);\n      }\n      if (item instanceof Directory) {\n        itemPath = path.resolve(itemPath, name);\n        item = item.getItem(name);\n      } else {\n        throw new FSError('ENOTDIR', filepath);\n      }\n    }\n    if (item) {\n      while (item instanceof SymbolicLink) {\n        itemPath = path.resolve(path.dirname(itemPath), item.getPath());\n        item = this._system.getItem(itemPath);\n      }\n      realPath = itemPath;\n    } else {\n      throw new FSError('ENOENT', filepath);\n    }\n\n    if (process.platform === 'win32' && realPath.startsWith('\\\\\\\\?\\\\')) {\n      // Remove win32 file namespace prefix \\\\?\\\n      realPath = realPath.slice(4);\n    }\n\n    if (encoding === 'buffer') {\n      realPath = bufferFrom(realPath);\n    }\n\n    return realPath;\n  });\n};\n\n/**\n * Fill a Float64Array with stat information\n * This is based on the internal FillStatsArray function in Node.\n * https://github.com/nodejs/node/blob/4e05952a8a75af6df625415db612d3a9a1322682/src/node_file.cc#L533\n * @param {Object} stats An object with file stats\n * @param {Float64Array} statValues A Float64Array where stat values should be inserted\n * @returns {void}\n */\nfunction fillStatsArray(stats, statValues) {\n  statValues[0] = stats.dev;\n  statValues[1] = stats.mode;\n  statValues[2] = stats.nlink;\n  statValues[3] = stats.uid;\n  statValues[4] = stats.gid;\n  statValues[5] = stats.rdev;\n  statValues[6] = stats.blksize;\n  statValues[7] = stats.ino;\n  statValues[8] = stats.size;\n  statValues[9] = stats.blocks;\n\n  if (statContainsNs) {\n    // nodejs v12.10.0+\n    // This is based on the internal FillStatsArray function in Node.\n    // https://github.com/nodejs/node/blob/3a2e75d9a5c31d20e429d505b82dd182e33f459a/src/node_file.h#L153-L187\n    statValues[10] = Math.floor(stats.atimeMs / 1000);\n    statValues[11] = (stats.atimeMs % 1000) * 1000000;\n    statValues[12] = Math.floor(stats.mtimeMs / 1000);\n    statValues[13] = (stats.mtimeMs % 1000) * 1000000;\n    statValues[14] = Math.floor(stats.ctimeMs / 1000);\n    statValues[15] = (stats.ctimeMs % 1000) * 1000000;\n    statValues[16] = Math.floor(stats.birthtimeMs / 1000);\n    statValues[17] = (stats.birthtimeMs % 1000) * 1000000;\n  } else {\n    // nodejs before v12.10.0\n    // This is based on the internal FillStatsArray function in Node.\n    // https://github.com/nodejs/node/blob/4e05952a8a75af6df625415db612d3a9a1322682/src/node_file.cc#L533\n    statValues[10] = stats.atimeMs;\n    statValues[11] = stats.mtimeMs;\n    statValues[12] = stats.ctimeMs;\n    statValues[13] = stats.birthtimeMs;\n  }\n}\n\n/**\n * Stat an item.\n * @param {string} filepath Path.\n * @param {function(Error, Stats)|Float64Array|BigUint64Array} callback Callback (optional). In Node 7.7.0+ this will be a Float64Array\n * that should be filled with stat values.\n * @param {Object} ctx Context object (optional), only for nodejs v10+.\n * @return {Stats|undefined} Stats or undefined (if sync).\n */\nBinding.prototype.stat = function(filepath, options, callback, ctx) {\n  // this seems wound not happen in nodejs v10+\n  if (arguments.length < 3) {\n    callback = options;\n    options = {};\n  }\n\n  markSyscall(ctx, 'stat');\n\n  return maybeCallback(wrapStatsCallback(callback), ctx, this, function() {\n    filepath = deBuffer(filepath);\n    let item = this._system.getItem(filepath);\n    if (item instanceof SymbolicLink) {\n      item = this._system.getItem(\n        path.resolve(path.dirname(filepath), item.getPath())\n      );\n    }\n    if (!item) {\n      throw new FSError('ENOENT', filepath);\n    }\n    const stats = item.getStats();\n\n    // In Node 7.7.0+, binding.stat accepts a Float64Array as the second argument,\n    // which should be filled with stat values.\n    // In prior versions of Node, binding.stat simply returns a Stats instance.\n    if (\n      callback instanceof Float64Array ||\n      callback instanceof BigUint64Array\n    ) {\n      fillStatsArray(stats, callback);\n    } else {\n      fillStatsArray(stats, statValues);\n      return new Stats(stats);\n    }\n  });\n};\n\n/**\n * Stat an item.\n * @param {number} fd File descriptor.\n * @param {function(Error, Stats)|Float64Array|BigUint64Array} callback Callback (optional). In Node 7.7.0+ this will be a Float64Array\n * that should be filled with stat values.\n * @param {Object} ctx Context object (optional), only for nodejs v10+.\n * @return {Stats|undefined} Stats or undefined (if sync).\n */\nBinding.prototype.fstat = function(fd, options, callback, ctx) {\n  if (arguments.length < 3) {\n    callback = options;\n    options = {};\n  }\n\n  markSyscall(ctx, 'fstat');\n\n  return maybeCallback(wrapStatsCallback(callback), ctx, this, function() {\n    const descriptor = this.getDescriptorById(fd);\n    const item = descriptor.getItem();\n    const stats = item.getStats();\n\n    // In Node 7.7.0+, binding.stat accepts a Float64Array as the second argument,\n    // which should be filled with stat values.\n    // In prior versions of Node, binding.stat simply returns a Stats instance.\n    if (\n      callback instanceof Float64Array ||\n      callback instanceof BigUint64Array\n    ) {\n      fillStatsArray(stats, callback);\n    } else {\n      fillStatsArray(stats, statValues);\n      return new Stats(stats);\n    }\n  });\n};\n\n/**\n * Close a file descriptor.\n * @param {number} fd File descriptor.\n * @param {function(Error)} callback Callback (optional).\n * @param {Object} ctx Context object (optional), only for nodejs v10+.\n */\nBinding.prototype.close = function(fd, callback, ctx) {\n  markSyscall(ctx, 'close');\n\n  return maybeCallback(normalizeCallback(callback), ctx, this, function() {\n    this.untrackDescriptorById(fd);\n  });\n};\n\n/**\n * Open and possibly create a file.\n * @param {string} pathname File path.\n * @param {number} flags Flags.\n * @param {number} mode Mode.\n * @param {function(Error, string)} callback Callback (optional).\n * @param {Object} ctx Context object (optional), only for nodejs v10+.\n * @return {string} File descriptor (if sync).\n */\nBinding.prototype.open = function(pathname, flags, mode, callback, ctx) {\n  markSyscall(ctx, 'open');\n\n  return maybeCallback(normalizeCallback(callback), ctx, this, function() {\n    pathname = deBuffer(pathname);\n    const descriptor = new FileDescriptor(flags);\n    let item = this._system.getItem(pathname);\n    while (item instanceof SymbolicLink) {\n      item = this._system.getItem(\n        path.resolve(path.dirname(pathname), item.getPath())\n      );\n    }\n    if (descriptor.isExclusive() && item) {\n      throw new FSError('EEXIST', pathname);\n    }\n    if (descriptor.isCreate() && !item) {\n      const parent = this._system.getItem(path.dirname(pathname));\n      if (!parent) {\n        throw new FSError('ENOENT', pathname);\n      }\n      if (!(parent instanceof Directory)) {\n        throw new FSError('ENOTDIR', pathname);\n      }\n      item = new File();\n      if (mode) {\n        item.setMode(mode);\n      }\n      parent.addItem(path.basename(pathname), item);\n    }\n    if (descriptor.isRead()) {\n      if (!item) {\n        throw new FSError('ENOENT', pathname);\n      }\n      if (!item.canRead()) {\n        throw new FSError('EACCES', pathname);\n      }\n    }\n    if (descriptor.isWrite() && !item.canWrite()) {\n      throw new FSError('EACCES', pathname);\n    }\n    if (\n      item instanceof Directory &&\n      (descriptor.isTruncate() || descriptor.isAppend())\n    ) {\n      throw new FSError('EISDIR', pathname);\n    }\n    if (descriptor.isTruncate()) {\n      if (!(item instanceof File)) {\n        throw new FSError('EBADF');\n      }\n      item.setContent('');\n    }\n    if (descriptor.isTruncate() || descriptor.isAppend()) {\n      descriptor.setPosition(item.getContent().length);\n    }\n    descriptor.setItem(item);\n    return this.trackDescriptor(descriptor);\n  });\n};\n\n/**\n * Open a file handler. A new api in nodejs v10+ for fs.promises\n * @param {string} pathname File path.\n * @param {number} flags Flags.\n * @param {number} mode Mode.\n * @param {function} callback Callback (optional), expecting kUsePromises in nodejs v10+.\n */\nBinding.prototype.openFileHandle = function(pathname, flags, mode, callback) {\n  const self = this;\n\n  return this.open(pathname, flags, mode, kUsePromises).then(function(fd) {\n    // nodejs v10+ fs.promises FileHandler constructor only ask these three properties.\n    return {\n      getAsyncId: notImplemented,\n      fd: fd,\n      close: function() {\n        return self.close(fd, kUsePromises);\n      }\n    };\n  });\n};\n\n/**\n * Read from a file descriptor.\n * @param {string} fd File descriptor.\n * @param {Buffer} buffer Buffer that the contents will be written to.\n * @param {number} offset Offset in the buffer to start writing to.\n * @param {number} length Number of bytes to read.\n * @param {?number} position Where to begin reading in the file.  If null,\n *     data will be read from the current file position.\n * @param {function(Error, number, Buffer)} callback Callback (optional) called\n *     with any error, number of bytes read, and the buffer.\n * @param {Object} ctx Context object (optional), only for nodejs v10+.\n * @return {number} Number of bytes read (if sync).\n */\nBinding.prototype.read = function(\n  fd,\n  buffer,\n  offset,\n  length,\n  position,\n  callback,\n  ctx\n) {\n  markSyscall(ctx, 'read');\n\n  return maybeCallback(normalizeCallback(callback), ctx, this, function() {\n    const descriptor = this.getDescriptorById(fd);\n    if (!descriptor.isRead()) {\n      throw new FSError('EBADF');\n    }\n    const file = descriptor.getItem();\n    if (file instanceof Directory) {\n      throw new FSError('EISDIR');\n    }\n    if (!(file instanceof File)) {\n      // deleted or not a regular file\n      throw new FSError('EBADF');\n    }\n    if (typeof position !== 'number' || position < 0) {\n      position = descriptor.getPosition();\n    }\n    const content = file.getContent();\n    const start = Math.min(position, content.length);\n    const end = Math.min(position + length, content.length);\n    const read = start < end ? content.copy(buffer, offset, start, end) : 0;\n    descriptor.setPosition(position + read);\n    return read;\n  });\n};\n\n/**\n * Write to a file descriptor given a buffer.\n * @param {string} src Source file.\n * @param {string} dest Destination file.\n * @param {number} flags Modifiers for copy operation.\n * @param {function(Error)} callback Callback (optional) called\n *     with any error.\n * @param {Object} ctx Context object (optional), only for nodejs v10+.\n */\nBinding.prototype.copyFile = function(src, dest, flags, callback, ctx) {\n  markSyscall(ctx, 'copyfile');\n\n  return maybeCallback(normalizeCallback(callback), ctx, this, function() {\n    src = deBuffer(src);\n    dest = deBuffer(dest);\n    const srcFd = this.open(src, constants.O_RDONLY);\n\n    try {\n      const srcDescriptor = this.getDescriptorById(srcFd);\n      if (!srcDescriptor.isRead()) {\n        throw new FSError('EBADF');\n      }\n      const srcFile = srcDescriptor.getItem();\n      if (!(srcFile instanceof File)) {\n        throw new FSError('EBADF');\n      }\n      const srcContent = srcFile.getContent();\n\n      let destFlags =\n        constants.O_WRONLY | constants.O_CREAT | constants.O_TRUNC;\n\n      if ((flags & constants.COPYFILE_EXCL) === constants.COPYFILE_EXCL) {\n        destFlags |= constants.O_EXCL;\n      }\n\n      const destFd = this.open(dest, destFlags);\n\n      try {\n        this.write(destFd, srcContent, 0, srcContent.length, 0);\n      } finally {\n        this.close(destFd);\n      }\n    } finally {\n      this.close(srcFd);\n    }\n  });\n};\n\n/**\n * Write to a file descriptor given a buffer.\n * @param {string} fd File descriptor.\n * @param {Array<Buffer>} buffers Array of buffers with contents to write.\n * @param {?number} position Where to begin writing in the file.  If null,\n *     data will be written to the current file position.\n * @param {function(Error, number, Buffer)} callback Callback (optional) called\n *     with any error, number of bytes written, and the buffer.\n * @param {Object} ctx Context object (optional), only for nodejs v10+.\n * @return {number} Number of bytes written (if sync).\n */\nBinding.prototype.writeBuffers = function(\n  fd,\n  buffers,\n  position,\n  callback,\n  ctx\n) {\n  markSyscall(ctx, 'write');\n\n  return maybeCallback(normalizeCallback(callback), ctx, this, function() {\n    const descriptor = this.getDescriptorById(fd);\n    if (!descriptor.isWrite()) {\n      throw new FSError('EBADF');\n    }\n    const file = descriptor.getItem();\n    if (!(file instanceof File)) {\n      // not a regular file\n      throw new FSError('EBADF');\n    }\n    if (typeof position !== 'number' || position < 0) {\n      position = descriptor.getPosition();\n    }\n    let content = file.getContent();\n    const newContent = Buffer.concat(buffers);\n    const newLength = position + newContent.length;\n    if (content.length < newLength) {\n      const tempContent = bufferAlloc(newLength);\n      content.copy(tempContent);\n      content = tempContent;\n    }\n    const written = newContent.copy(content, position);\n    file.setContent(content);\n    descriptor.setPosition(newLength);\n    return written;\n  });\n};\n\n/**\n * Write to a file descriptor given a buffer.\n * @param {string} fd File descriptor.\n * @param {Buffer} buffer Buffer with contents to write.\n * @param {number} offset Offset in the buffer to start writing from.\n * @param {number} length Number of bytes to write.\n * @param {?number} position Where to begin writing in the file.  If null,\n *     data will be written to the current file position.\n * @param {function(Error, number, Buffer)} callback Callback (optional) called\n *     with any error, number of bytes written, and the buffer.\n * @param {Object} ctx Context object (optional), only for nodejs v10+.\n * @return {number} Number of bytes written (if sync).\n */\nBinding.prototype.writeBuffer = function(\n  fd,\n  buffer,\n  offset,\n  length,\n  position,\n  callback,\n  ctx\n) {\n  markSyscall(ctx, 'write');\n\n  return maybeCallback(normalizeCallback(callback), ctx, this, function() {\n    const descriptor = this.getDescriptorById(fd);\n    if (!descriptor.isWrite()) {\n      throw new FSError('EBADF');\n    }\n    const file = descriptor.getItem();\n    if (!(file instanceof File)) {\n      // not a regular file\n      throw new FSError('EBADF');\n    }\n    if (typeof position !== 'number' || position < 0) {\n      position = descriptor.getPosition();\n    }\n    let content = file.getContent();\n    const newLength = position + length;\n    if (content.length < newLength) {\n      const newContent = bufferAlloc(newLength);\n      content.copy(newContent);\n      content = newContent;\n    }\n    const sourceEnd = Math.min(offset + length, buffer.length);\n    const written = bufferFrom(buffer).copy(\n      content,\n      position,\n      offset,\n      sourceEnd\n    );\n    file.setContent(content);\n    descriptor.setPosition(newLength);\n    return written;\n  });\n};\n\n/**\n * Alias for writeBuffer (used in Node <= 0.10).\n * @param {string} fd File descriptor.\n * @param {Buffer} buffer Buffer with contents to write.\n * @param {number} offset Offset in the buffer to start writing from.\n * @param {number} length Number of bytes to write.\n * @param {?number} position Where to begin writing in the file.  If null,\n *     data will be written to the current file position.\n * @param {function(Error, number, Buffer)} callback Callback (optional) called\n *     with any error, number of bytes written, and the buffer.\n * @param {Object} ctx Context object (optional), only for nodejs v10+.\n * @return {number} Number of bytes written (if sync).\n */\nBinding.prototype.write = Binding.prototype.writeBuffer;\n\n/**\n * Write to a file descriptor given a string.\n * @param {string} fd File descriptor.\n * @param {string} string String with contents to write.\n * @param {number} position Where to begin writing in the file.  If null,\n *     data will be written to the current file position.\n * @param {string} encoding String encoding.\n * @param {function(Error, number, string)} callback Callback (optional) called\n *     with any error, number of bytes written, and the string.\n * @return {number} Number of bytes written (if sync).\n */\nBinding.prototype.writeString = function(\n  fd,\n  string,\n  position,\n  encoding,\n  callback,\n  ctx\n) {\n  markSyscall(ctx, 'write');\n\n  const buffer = bufferFrom(string, encoding);\n  let wrapper;\n  if (callback && callback !== kUsePromises) {\n    if (callback.oncomplete) {\n      callback = callback.oncomplete.bind(callback);\n    }\n    wrapper = function(err, written, returned) {\n      callback(err, written, returned && string);\n    };\n  }\n  return this.writeBuffer(fd, buffer, 0, string.length, position, wrapper, ctx);\n};\n\n/**\n * Rename a file.\n * @param {string} oldPath Old pathname.\n * @param {string} newPath New pathname.\n * @param {function(Error)} callback Callback (optional).\n * @param {Object} ctx Context object (optional), only for nodejs v10+.\n * @return {undefined}\n */\nBinding.prototype.rename = function(oldPath, newPath, callback, ctx) {\n  markSyscall(ctx, 'rename');\n\n  return maybeCallback(normalizeCallback(callback), ctx, this, function() {\n    oldPath = deBuffer(oldPath);\n    newPath = deBuffer(newPath);\n    const oldItem = this._system.getItem(oldPath);\n    if (!oldItem) {\n      throw new FSError('ENOENT', oldPath);\n    }\n    const oldParent = this._system.getItem(path.dirname(oldPath));\n    const oldName = path.basename(oldPath);\n    const newItem = this._system.getItem(newPath);\n    const newParent = this._system.getItem(path.dirname(newPath));\n    const newName = path.basename(newPath);\n    if (newItem) {\n      // make sure they are the same type\n      if (oldItem instanceof File) {\n        if (newItem instanceof Directory) {\n          throw new FSError('EISDIR', newPath);\n        }\n      } else if (oldItem instanceof Directory) {\n        if (!(newItem instanceof Directory)) {\n          throw new FSError('ENOTDIR', newPath);\n        }\n        if (newItem.list().length > 0) {\n          throw new FSError('ENOTEMPTY', newPath);\n        }\n      }\n      newParent.removeItem(newName);\n    } else {\n      if (!newParent) {\n        throw new FSError('ENOENT', newPath);\n      }\n      if (!(newParent instanceof Directory)) {\n        throw new FSError('ENOTDIR', newPath);\n      }\n    }\n    oldParent.removeItem(oldName);\n    newParent.addItem(newName, oldItem);\n  });\n};\n\n/**\n * Read a directory.\n * @param {string} dirpath Path to directory.\n * @param {string} encoding The encoding ('utf-8' or 'buffer').\n * @param {boolean} withFileTypes whether or not to return fs.Dirent objects\n * @param {function(Error, (Array.<string>|Array.<Buffer>)} callback Callback\n *     (optional) called with any error or array of items in the directory.\n * @param {Object} ctx Context object (optional), only for nodejs v10+.\n * @return {Array.<string>|Array.<Buffer>} Array of items in directory (if sync).\n */\nBinding.prototype.readdir = function(\n  dirpath,\n  encoding,\n  withFileTypes,\n  callback,\n  ctx\n) {\n  // again, the shorter arguments would not happen in nodejs v10+\n  if (arguments.length === 2) {\n    callback = encoding;\n    encoding = 'utf-8';\n  } else if (arguments.length === 3) {\n    callback = withFileTypes;\n  }\n\n  markSyscall(ctx, 'scandir');\n\n  return maybeCallback(normalizeCallback(callback), ctx, this, function() {\n    dirpath = deBuffer(dirpath);\n    let dpath = dirpath;\n    let dir = this._system.getItem(dirpath);\n    while (dir instanceof SymbolicLink) {\n      dpath = path.resolve(path.dirname(dpath), dir.getPath());\n      dir = this._system.getItem(dpath);\n    }\n    if (!dir) {\n      throw new FSError('ENOENT', dirpath);\n    }\n    if (!(dir instanceof Directory)) {\n      throw new FSError('ENOTDIR', dirpath);\n    }\n    if (!dir.canRead()) {\n      throw new FSError('EACCES', dirpath);\n    }\n\n    let list = dir.list();\n    if (encoding === 'buffer') {\n      list = list.map(function(item) {\n        return bufferFrom(item);\n      });\n    }\n\n    if (withFileTypes === true) {\n      const types = list.map(function(name) {\n        const stats = dir.getItem(name).getStats();\n\n        return getDirentType(stats.mode);\n      });\n      list = [list, types];\n    }\n\n    return list;\n  });\n};\n\n/**\n * Create a directory.\n * @param {string} pathname Path to new directory.\n * @param {number} mode Permissions.\n * @param {boolean} recursive Recursively create deep directory. (added in nodejs v10+)\n * @param {function(Error)} callback Optional callback.\n * @param {Object} ctx Context object (optional), only for nodejs v10+.\n */\nBinding.prototype.mkdir = function(pathname, mode, recursive, callback, ctx) {\n  if (typeof recursive !== 'boolean') {\n    // when running nodejs < 10\n    ctx = callback;\n    callback = recursive;\n    recursive = false;\n  }\n\n  markSyscall(ctx, 'mkdir');\n\n  return maybeCallback(normalizeCallback(callback), ctx, this, function() {\n    pathname = deBuffer(pathname);\n    const item = this._system.getItem(pathname);\n    if (item) {\n      if (recursive && item instanceof Directory) {\n        // silently pass existing folder in recursive mode\n        return;\n      }\n      throw new FSError('EEXIST', pathname);\n    }\n\n    const _mkdir = function(_pathname) {\n      const parentDir = path.dirname(_pathname);\n      let parent = this._system.getItem(parentDir);\n      if (!parent) {\n        if (!recursive) {\n          throw new FSError('ENOENT', _pathname);\n        }\n        parent = _mkdir(parentDir, true);\n      }\n      this.access(parentDir, parseInt('0002', 8));\n      const dir = new Directory();\n      if (mode) {\n        dir.setMode(mode);\n      }\n      return parent.addItem(path.basename(_pathname), dir);\n    }.bind(this);\n\n    _mkdir(pathname);\n  });\n};\n\n/**\n * Remove a directory.\n * @param {string} pathname Path to directory.\n * @param {function(Error)} callback Optional callback.\n * @param {Object} ctx Context object (optional), only for nodejs v10+.\n */\nBinding.prototype.rmdir = function(pathname, callback, ctx) {\n  markSyscall(ctx, 'rmdir');\n\n  return maybeCallback(normalizeCallback(callback), ctx, this, function() {\n    pathname = deBuffer(pathname);\n    const item = this._system.getItem(pathname);\n    if (!item) {\n      throw new FSError('ENOENT', pathname);\n    }\n    if (!(item instanceof Directory)) {\n      throw new FSError('ENOTDIR', pathname);\n    }\n    if (item.list().length > 0) {\n      throw new FSError('ENOTEMPTY', pathname);\n    }\n    this.access(path.dirname(pathname), parseInt('0002', 8));\n    const parent = this._system.getItem(path.dirname(pathname));\n    parent.removeItem(path.basename(pathname));\n  });\n};\n\nconst PATH_CHARS =\n  'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';\n\nconst MAX_ATTEMPTS = 62 * 62 * 62;\n\n/**\n * Create a directory based on a template.\n * See http://web.mit.edu/freebsd/head/lib/libc/stdio/mktemp.c\n * @param {string} template Path template (trailing Xs will be replaced).\n * @param {string} encoding The encoding ('utf-8' or 'buffer').\n * @param {function(Error, string)} callback Optional callback.\n * @param {Object} ctx Context object (optional), only for nodejs v10+.\n */\nBinding.prototype.mkdtemp = function(prefix, encoding, callback, ctx) {\n  if (encoding && typeof encoding !== 'string') {\n    callback = encoding;\n    encoding = 'utf-8';\n  }\n\n  markSyscall(ctx, 'mkdtemp');\n\n  return maybeCallback(normalizeCallback(callback), ctx, this, function() {\n    prefix = prefix.replace(/X{0,6}$/, 'XXXXXX');\n    const parentPath = path.dirname(prefix);\n    const parent = this._system.getItem(parentPath);\n    if (!parent) {\n      throw new FSError('ENOENT', prefix);\n    }\n    if (!(parent instanceof Directory)) {\n      throw new FSError('ENOTDIR', prefix);\n    }\n    this.access(parentPath, parseInt('0002', 8));\n    const template = path.basename(prefix);\n    let unique = false;\n    let count = 0;\n    let name;\n    while (!unique && count < MAX_ATTEMPTS) {\n      let position = template.length - 1;\n      let replacement = '';\n      while (template.charAt(position) === 'X') {\n        replacement += PATH_CHARS.charAt(\n          Math.floor(PATH_CHARS.length * Math.random())\n        );\n        position -= 1;\n      }\n      const candidate = template.slice(0, position + 1) + replacement;\n      if (!parent.getItem(candidate)) {\n        name = candidate;\n        unique = true;\n      }\n      count += 1;\n    }\n    if (!name) {\n      throw new FSError('EEXIST', prefix);\n    }\n    const dir = new Directory();\n    parent.addItem(name, dir);\n    let uniquePath = path.join(parentPath, name);\n    if (encoding === 'buffer') {\n      uniquePath = bufferFrom(uniquePath);\n    }\n    return uniquePath;\n  });\n};\n\n/**\n * Truncate a file.\n * @param {number} fd File descriptor.\n * @param {number} len Number of bytes.\n * @param {function(Error)} callback Optional callback.\n * @param {Object} ctx Context object (optional), only for nodejs v10+.\n */\nBinding.prototype.ftruncate = function(fd, len, callback, ctx) {\n  markSyscall(ctx, 'ftruncate');\n\n  return maybeCallback(normalizeCallback(callback), ctx, this, function() {\n    const descriptor = this.getDescriptorById(fd);\n    if (!descriptor.isWrite()) {\n      throw new FSError('EINVAL');\n    }\n    const file = descriptor.getItem();\n    if (!(file instanceof File)) {\n      throw new FSError('EINVAL');\n    }\n    const content = file.getContent();\n    const newContent = bufferAlloc(len);\n    content.copy(newContent);\n    file.setContent(newContent);\n  });\n};\n\n/**\n * Legacy support.\n * @param {number} fd File descriptor.\n * @param {number} len Number of bytes.\n * @param {function(Error)} callback Optional callback.\n * @param {Object} ctx Context object (optional), only for nodejs v10+.\n */\nBinding.prototype.truncate = Binding.prototype.ftruncate;\n\n/**\n * Change user and group owner.\n * @param {string} pathname Path.\n * @param {number} uid User id.\n * @param {number} gid Group id.\n * @param {function(Error)} callback Optional callback.\n * @param {Object} ctx Context object (optional), only for nodejs v10+.\n */\nBinding.prototype.chown = function(pathname, uid, gid, callback, ctx) {\n  markSyscall(ctx, 'chown');\n\n  return maybeCallback(normalizeCallback(callback), ctx, this, function() {\n    pathname = deBuffer(pathname);\n    const item = this._system.getItem(pathname);\n    if (!item) {\n      throw new FSError('ENOENT', pathname);\n    }\n    item.setUid(uid);\n    item.setGid(gid);\n  });\n};\n\n/**\n * Change user and group owner.\n * @param {number} fd File descriptor.\n * @param {number} uid User id.\n * @param {number} gid Group id.\n * @param {function(Error)} callback Optional callback.\n * @param {Object} ctx Context object (optional), only for nodejs v10+.\n */\nBinding.prototype.fchown = function(fd, uid, gid, callback, ctx) {\n  markSyscall(ctx, 'fchown');\n\n  return maybeCallback(normalizeCallback(callback), ctx, this, function() {\n    const descriptor = this.getDescriptorById(fd);\n    const item = descriptor.getItem();\n    item.setUid(uid);\n    item.setGid(gid);\n  });\n};\n\n/**\n * Change permissions.\n * @param {string} pathname Path.\n * @param {number} mode Mode.\n * @param {function(Error)} callback Optional callback.\n * @param {Object} ctx Context object (optional), only for nodejs v10+.\n */\nBinding.prototype.chmod = function(pathname, mode, callback, ctx) {\n  markSyscall(ctx, 'chmod');\n\n  return maybeCallback(normalizeCallback(callback), ctx, this, function() {\n    pathname = deBuffer(pathname);\n    const item = this._system.getItem(pathname);\n    if (!item) {\n      throw new FSError('ENOENT', pathname);\n    }\n    item.setMode(mode);\n  });\n};\n\n/**\n * Change permissions.\n * @param {number} fd File descriptor.\n * @param {number} mode Mode.\n * @param {function(Error)} callback Optional callback.\n * @param {Object} ctx Context object (optional), only for nodejs v10+.\n */\nBinding.prototype.fchmod = function(fd, mode, callback, ctx) {\n  markSyscall(ctx, 'fchmod');\n\n  return maybeCallback(normalizeCallback(callback), ctx, this, function() {\n    const descriptor = this.getDescriptorById(fd);\n    const item = descriptor.getItem();\n    item.setMode(mode);\n  });\n};\n\n/**\n * Delete a named item.\n * @param {string} pathname Path to item.\n * @param {function(Error)} callback Optional callback.\n * @param {Object} ctx Context object (optional), only for nodejs v10+.\n */\nBinding.prototype.unlink = function(pathname, callback, ctx) {\n  markSyscall(ctx, 'unlink');\n\n  return maybeCallback(normalizeCallback(callback), ctx, this, function() {\n    pathname = deBuffer(pathname);\n    const item = this._system.getItem(pathname);\n    if (!item) {\n      throw new FSError('ENOENT', pathname);\n    }\n    if (item instanceof Directory) {\n      throw new FSError('EPERM', pathname);\n    }\n    const parent = this._system.getItem(path.dirname(pathname));\n    parent.removeItem(path.basename(pathname));\n  });\n};\n\n/**\n * Update timestamps.\n * @param {string} pathname Path to item.\n * @param {number} atime Access time (in seconds).\n * @param {number} mtime Modification time (in seconds).\n * @param {function(Error)} callback Optional callback.\n * @param {Object} ctx Context object (optional), only for nodejs v10+.\n */\nBinding.prototype.utimes = function(pathname, atime, mtime, callback, ctx) {\n  markSyscall(ctx, 'utimes');\n\n  return maybeCallback(normalizeCallback(callback), ctx, this, function() {\n    pathname = deBuffer(pathname);\n    const item = this._system.getItem(pathname);\n    if (!item) {\n      throw new FSError('ENOENT', pathname);\n    }\n    item.setATime(new Date(atime * 1000));\n    item.setMTime(new Date(mtime * 1000));\n  });\n};\n\n/**\n * Update timestamps.\n * @param {number} fd File descriptor.\n * @param {number} atime Access time (in seconds).\n * @param {number} mtime Modification time (in seconds).\n * @param {function(Error)} callback Optional callback.\n * @param {Object} ctx Context object (optional), only for nodejs v10+.\n */\nBinding.prototype.futimes = function(fd, atime, mtime, callback, ctx) {\n  markSyscall(ctx, 'futimes');\n\n  return maybeCallback(normalizeCallback(callback), ctx, this, function() {\n    const descriptor = this.getDescriptorById(fd);\n    const item = descriptor.getItem();\n    item.setATime(new Date(atime * 1000));\n    item.setMTime(new Date(mtime * 1000));\n  });\n};\n\n/**\n * Synchronize in-core state with storage device.\n * @param {number} fd File descriptor.\n * @param {function(Error)} callback Optional callback.\n * @param {Object} ctx Context object (optional), only for nodejs v10+.\n */\nBinding.prototype.fsync = function(fd, callback, ctx) {\n  markSyscall(ctx, 'fsync');\n\n  return maybeCallback(normalizeCallback(callback), ctx, this, function() {\n    this.getDescriptorById(fd);\n  });\n};\n\n/**\n * Synchronize in-core metadata state with storage device.\n * @param {number} fd File descriptor.\n * @param {function(Error)} callback Optional callback.\n * @param {Object} ctx Context object (optional), only for nodejs v10+.\n */\nBinding.prototype.fdatasync = function(fd, callback, ctx) {\n  markSyscall(ctx, 'fdatasync');\n\n  return maybeCallback(normalizeCallback(callback), ctx, this, function() {\n    this.getDescriptorById(fd);\n  });\n};\n\n/**\n * Create a hard link.\n * @param {string} srcPath The existing file.\n * @param {string} destPath The new link to create.\n * @param {function(Error)} callback Optional callback.\n * @param {Object} ctx Context object (optional), only for nodejs v10+.\n */\nBinding.prototype.link = function(srcPath, destPath, callback, ctx) {\n  markSyscall(ctx, 'link');\n\n  return maybeCallback(normalizeCallback(callback), ctx, this, function() {\n    srcPath = deBuffer(srcPath);\n    destPath = deBuffer(destPath);\n    const item = this._system.getItem(srcPath);\n    if (!item) {\n      throw new FSError('ENOENT', srcPath);\n    }\n    if (item instanceof Directory) {\n      throw new FSError('EPERM', srcPath);\n    }\n    if (this._system.getItem(destPath)) {\n      throw new FSError('EEXIST', destPath);\n    }\n    const parent = this._system.getItem(path.dirname(destPath));\n    if (!parent) {\n      throw new FSError('ENOENT', destPath);\n    }\n    if (!(parent instanceof Directory)) {\n      throw new FSError('ENOTDIR', destPath);\n    }\n    parent.addItem(path.basename(destPath), item);\n  });\n};\n\n/**\n * Create a symbolic link.\n * @param {string} srcPath Path from link to the source file.\n * @param {string} destPath Path for the generated link.\n * @param {string} type Ignored (used for Windows only).\n * @param {function(Error)} callback Optional callback.\n * @param {Object} ctx Context object (optional), only for nodejs v10+.\n */\nBinding.prototype.symlink = function(srcPath, destPath, type, callback, ctx) {\n  markSyscall(ctx, 'symlink');\n\n  return maybeCallback(normalizeCallback(callback), ctx, this, function() {\n    srcPath = deBuffer(srcPath);\n    destPath = deBuffer(destPath);\n    if (this._system.getItem(destPath)) {\n      throw new FSError('EEXIST', destPath);\n    }\n    const parent = this._system.getItem(path.dirname(destPath));\n    if (!parent) {\n      throw new FSError('ENOENT', destPath);\n    }\n    if (!(parent instanceof Directory)) {\n      throw new FSError('ENOTDIR', destPath);\n    }\n    const link = new SymbolicLink();\n    link.setPath(srcPath);\n    parent.addItem(path.basename(destPath), link);\n  });\n};\n\n/**\n * Read the contents of a symbolic link.\n * @param {string} pathname Path to symbolic link.\n * @param {string} encoding The encoding ('utf-8' or 'buffer').\n * @param {function(Error, (string|Buffer))} callback Optional callback.\n * @param {Object} ctx Context object (optional), only for nodejs v10+.\n * @return {string|Buffer} Symbolic link contents (path to source).\n */\nBinding.prototype.readlink = function(pathname, encoding, callback, ctx) {\n  if (encoding && typeof encoding !== 'string') {\n    // this would not happend in nodejs v10+\n    callback = encoding;\n    encoding = 'utf-8';\n  }\n\n  markSyscall(ctx, 'readlink');\n\n  return maybeCallback(normalizeCallback(callback), ctx, this, function() {\n    pathname = deBuffer(pathname);\n    const link = this._system.getItem(pathname);\n    if (!link) {\n      throw new FSError('ENOENT', pathname);\n    }\n    if (!(link instanceof SymbolicLink)) {\n      throw new FSError('EINVAL', pathname);\n    }\n    let linkPath = link.getPath();\n    if (encoding === 'buffer') {\n      linkPath = bufferFrom(linkPath);\n    }\n    return linkPath;\n  });\n};\n\n/**\n * Stat an item.\n * @param {string} filepath Path.\n * @param {function(Error, Stats)|Float64Array|BigUint64Array} callback Callback (optional). In Node 7.7.0+ this will be a Float64Array\n * that should be filled with stat values.\n * @param {Object} ctx Context object (optional), only for nodejs v10+.\n * @return {Stats|undefined} Stats or undefined (if sync).\n */\nBinding.prototype.lstat = function(filepath, options, callback, ctx) {\n  if (arguments.length < 3) {\n    // this would not happend in nodejs v10+\n    callback = options;\n    options = {};\n  }\n\n  markSyscall(ctx, 'lstat');\n\n  return maybeCallback(wrapStatsCallback(callback), ctx, this, function() {\n    filepath = deBuffer(filepath);\n    const item = this._system.getItem(filepath);\n    if (!item) {\n      throw new FSError('ENOENT', filepath);\n    }\n    const stats = item.getStats();\n\n    // In Node 7.7.0+, binding.stat accepts a Float64Array as the second argument,\n    // which should be filled with stat values.\n    // In prior versions of Node, binding.stat simply returns a Stats instance.\n    if (\n      callback instanceof Float64Array ||\n      callback instanceof BigUint64Array\n    ) {\n      fillStatsArray(stats, callback);\n    } else {\n      fillStatsArray(stats, statValues);\n      return new Stats(item.getStats());\n    }\n  });\n};\n\n/**\n * Tests user permissions.\n * @param {string} filepath Path.\n * @param {number} mode Mode.\n * @param {function(Error)} callback Callback (optional).\n * @param {Object} ctx Context object (optional), only for nodejs v10+.\n */\nBinding.prototype.access = function(filepath, mode, callback, ctx) {\n  markSyscall(ctx, 'access');\n\n  return maybeCallback(normalizeCallback(callback), ctx, this, function() {\n    filepath = deBuffer(filepath);\n    let item = this._system.getItem(filepath);\n    let links = 0;\n    while (item instanceof SymbolicLink) {\n      if (links > MAX_LINKS) {\n        throw new FSError('ELOOP', filepath);\n      }\n      filepath = path.resolve(path.dirname(filepath), item.getPath());\n      item = this._system.getItem(filepath);\n      ++links;\n    }\n    if (!item) {\n      throw new FSError('ENOENT', filepath);\n    }\n    if (mode && process.getuid && process.getgid) {\n      const itemMode = item.getMode();\n      if (item.getUid() === process.getuid()) {\n        if ((itemMode & (mode * 64)) !== mode * 64) {\n          throw new FSError('EACCES', filepath);\n        }\n      } else if (item.getGid() === process.getgid()) {\n        if ((itemMode & (mode * 8)) !== mode * 8) {\n          throw new FSError('EACCES', filepath);\n        }\n      } else {\n        if ((itemMode & mode) !== mode) {\n          throw new FSError('EACCES', filepath);\n        }\n      }\n    }\n  });\n};\n\n/**\n * Not yet implemented.\n * @type {function()}\n */\nBinding.prototype.StatWatcher = notImplemented;\n\n/**\n * Export the binding constructor.\n * @type {function()}\n */\nexports = module.exports = Binding;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL21vY2stZnMvbGliL2JpbmRpbmcuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsYUFBYSxtQkFBTyxDQUFDLGtCQUFNOztBQUUzQixhQUFhLG1CQUFPLENBQUMsNERBQVE7QUFDN0IsdUJBQXVCLG1CQUFPLENBQUMsd0VBQWM7QUFDN0Msa0JBQWtCLG1CQUFPLENBQUMsc0VBQWE7QUFDdkMscUJBQXFCLG1CQUFPLENBQUMsa0VBQVc7QUFDeEMsZ0JBQWdCLG1CQUFPLENBQUMsOERBQVM7QUFDakMsa0JBQWtCLG1CQUFPLENBQUMsNEJBQVc7QUFDckMscUJBQXFCLDRHQUFvQztBQUN6RCxtQkFBbUIsNEZBQXdCO0FBQzNDLG9CQUFvQiw2RkFBeUI7O0FBRTdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDLEVBQUU7QUFDRiwwQ0FBMEM7QUFDMUMsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxZQUFZO0FBQ3ZCLFlBQVksR0FBRztBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFlBQVksVUFBVTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixZQUFZLFVBQVU7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFlBQVk7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksWUFBWTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWSxnQkFBZ0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsZ0JBQWdCO0FBQzNCLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsWUFBWSxlQUFlO0FBQzNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLFFBQVE7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxjQUFjO0FBQ3pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsb0RBQW9EO0FBQy9EO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVksaUJBQWlCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsb0RBQW9EO0FBQy9EO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVksaUJBQWlCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsaUJBQWlCO0FBQzVCLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyx5QkFBeUI7QUFDcEMsV0FBVyxRQUFRO0FBQ25CLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFVBQVU7QUFDckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQjtBQUNBLFdBQVcsaUNBQWlDO0FBQzVDO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLGlCQUFpQjtBQUM1QjtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLGVBQWU7QUFDMUIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0EsV0FBVyxpQ0FBaUM7QUFDNUM7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQjtBQUNBLFdBQVcsaUNBQWlDO0FBQzVDO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQjtBQUNBLFdBQVcsaUNBQWlDO0FBQzVDO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVksUUFBUTtBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLGlDQUFpQztBQUM1QztBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxpQkFBaUI7QUFDNUIsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQixXQUFXLGlEQUFpRDtBQUM1RDtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZLCtCQUErQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQixXQUFXLGlCQUFpQjtBQUM1QixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxpQkFBaUI7QUFDNUIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcseUJBQXlCO0FBQ3BDLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSwrQkFBK0IsSUFBSTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxpQkFBaUI7QUFDNUIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLGlCQUFpQjtBQUM1QixXQUFXLFFBQVE7QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxpQkFBaUI7QUFDNUIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLGlCQUFpQjtBQUM1QixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxpQkFBaUI7QUFDNUIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLGlCQUFpQjtBQUM1QixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxpQkFBaUI7QUFDNUIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLGlCQUFpQjtBQUM1QixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsaUJBQWlCO0FBQzVCLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsaUJBQWlCO0FBQzVCLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsaUJBQWlCO0FBQzVCLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLGlCQUFpQjtBQUM1QixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxpQkFBaUI7QUFDNUIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLGtDQUFrQztBQUM3QyxXQUFXLFFBQVE7QUFDbkIsWUFBWSxlQUFlO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLG9EQUFvRDtBQUMvRDtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZLGlCQUFpQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLGlCQUFpQjtBQUM1QixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9iYXJiL2FhL0Fzc29jaWF0ZWRBY2NvdW50cy9ub2RlX21vZHVsZXMvbW9jay1mcy9saWIvYmluZGluZy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG5cbmNvbnN0IEZpbGUgPSByZXF1aXJlKCcuL2ZpbGUnKTtcbmNvbnN0IEZpbGVEZXNjcmlwdG9yID0gcmVxdWlyZSgnLi9kZXNjcmlwdG9yJyk7XG5jb25zdCBEaXJlY3RvcnkgPSByZXF1aXJlKCcuL2RpcmVjdG9yeScpO1xuY29uc3QgU3ltYm9saWNMaW5rID0gcmVxdWlyZSgnLi9zeW1saW5rJyk7XG5jb25zdCBGU0Vycm9yID0gcmVxdWlyZSgnLi9lcnJvcicpO1xuY29uc3QgY29uc3RhbnRzID0gcmVxdWlyZSgnY29uc3RhbnRzJyk7XG5jb25zdCBnZXRQYXRoUGFydHMgPSByZXF1aXJlKCcuL2ZpbGVzeXN0ZW0nKS5nZXRQYXRoUGFydHM7XG5jb25zdCBidWZmZXJGcm9tID0gcmVxdWlyZSgnLi9idWZmZXInKS5mcm9tO1xuY29uc3QgYnVmZmVyQWxsb2MgPSByZXF1aXJlKCcuL2J1ZmZlcicpLmFsbG9jO1xuXG5jb25zdCBNT0RFX1RPX0tUWVBFID0ge1xuICBbY29uc3RhbnRzLlNfSUZSRUddOiBjb25zdGFudHMuVVZfRElSRU5UX0ZJTEUsXG4gIFtjb25zdGFudHMuU19JRkRJUl06IGNvbnN0YW50cy5VVl9ESVJFTlRfRElSLFxuICBbY29uc3RhbnRzLlNfSUZCTEtdOiBjb25zdGFudHMuVVZfRElSRU5UX0JMT0NLLFxuICBbY29uc3RhbnRzLlNfSUZDSFJdOiBjb25zdGFudHMuVVZfRElSRU5UX0NIQVIsXG4gIFtjb25zdGFudHMuU19JRkxOS106IGNvbnN0YW50cy5VVl9ESVJFTlRfTElOSyxcbiAgW2NvbnN0YW50cy5TX0lGSUZPXTogY29uc3RhbnRzLlVWX0RJUkVOVF9GSUZPLFxuICBbY29uc3RhbnRzLlNfSUZTT0NLXTogY29uc3RhbnRzLlVWX0RJUkVOVF9TT0NLRVRcbn07XG5cbi8qKiBXb3JrYXJvdW5kIGZvciBvcHRpbWl6YXRpb25zIGluIG5vZGUgOCsgKi9cbmNvbnN0IGZzQmluZGluZyA9IHByb2Nlc3MuYmluZGluZygnZnMnKTtcbmNvbnN0IGtVc2VQcm9taXNlcyA9IGZzQmluZGluZy5rVXNlUHJvbWlzZXM7XG5sZXQgc3RhdFZhbHVlcztcbmlmIChmc0JpbmRpbmcuc3RhdFZhbHVlcykge1xuICBzdGF0VmFsdWVzID0gZnNCaW5kaW5nLnN0YXRWYWx1ZXM7IC8vIG5vZGUgMTArXG59IGVsc2UgaWYgKGZzQmluZGluZy5nZXRTdGF0VmFsdWVzKSB7XG4gIHN0YXRWYWx1ZXMgPSBmc0JpbmRpbmcuZ2V0U3RhdFZhbHVlcygpOyAvLyBub2RlIDhcbn0gZWxzZSB7XG4gIHN0YXRWYWx1ZXMgPSBbXTtcbn1cblxuLy8gbm9kZWpzIHY2LDgsMTAgYW5kIHYxMiBiZWZvcmUgdjEyLjEwLjAgaGFzIGxlbmd0aCAyOFxuLy8gbm9kZWpzIHYxMi4xMC4wKyBoYXMgbGVuZ3RoIDM2XG5jb25zdCBzdGF0Q29udGFpbnNOcyA9IHN0YXRWYWx1ZXMubGVuZ3RoID4gMjg7XG5cbi8qKiBJbnRyb2R1Y3Rpb24gb2YgQmlnVWludDY0QXJyYXkgaW4gMTAuNSAqL1xubGV0IEJpZ1VpbnQ2NEFycmF5O1xuaWYgKGdsb2JhbC5CaWdVaW50NjRBcnJheSkge1xuICBCaWdVaW50NjRBcnJheSA9IGdsb2JhbC5CaWdVaW50NjRBcnJheTtcbn0gZWxzZSB7XG4gIEJpZ1VpbnQ2NEFycmF5ID0gZnVuY3Rpb24oKSB7fTtcbn1cblxuY29uc3QgTUFYX0xJTktTID0gNTA7XG5cbi8qKlxuICogQ2FsbCB0aGUgcHJvdmlkZWQgZnVuY3Rpb24gYW5kIGVpdGhlciByZXR1cm4gdGhlIHJlc3VsdCBvciBjYWxsIHRoZSBjYWxsYmFja1xuICogd2l0aCBpdCAoZGVwZW5kaW5nIG9uIGlmIGEgY2FsbGJhY2sgaXMgcHJvdmlkZWQpLlxuICogQHBhcmFtIHtmdW5jdGlvbigpfSBjYWxsYmFjayBPcHRpb25hbCBjYWxsYmFjay5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjdHggQ29udGV4dCBvYmplY3QgKG9wdGlvbmFsKSwgb25seSBmb3Igbm9kZWpzIHYxMCsuXG4gKiBAcGFyYW0ge09iamVjdH0gdGhpc0FyZyBUaGlzIGFyZ3VtZW50IGZvciB0aGUgZm9sbG93aW5nIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtmdW5jdGlvbigpfSBmdW5jIEZ1bmN0aW9uIHRvIGNhbGwuXG4gKiBAcmV0dXJuIHsqfSBSZXR1cm4gKGlmIGNhbGxiYWNrIGlzIG5vdCBwcm92aWRlZCkuXG4gKi9cbmZ1bmN0aW9uIG1heWJlQ2FsbGJhY2soY2FsbGJhY2ssIGN0eCwgdGhpc0FyZywgZnVuYykge1xuICBsZXQgZXJyID0gbnVsbDtcbiAgbGV0IHZhbDtcblxuICBpZiAoa1VzZVByb21pc2VzICYmIGNhbGxiYWNrID09PSBrVXNlUHJvbWlzZXMpIHtcbiAgICAvLyBzdXBwb3J0IG5vZGVqcyB2MTArIGZzLnByb21pc2VzXG4gICAgdHJ5IHtcbiAgICAgIHZhbCA9IGZ1bmMuY2FsbCh0aGlzQXJnKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBlcnIgPSBlO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzb2x2ZSh2YWwpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSBlbHNlIGlmIChjYWxsYmFjayAmJiB0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICB0cnkge1xuICAgICAgdmFsID0gZnVuYy5jYWxsKHRoaXNBcmcpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGVyciA9IGU7XG4gICAgfVxuICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodmFsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbGxiYWNrKGVyciwgdmFsKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSBlbHNlIGlmIChjdHggJiYgdHlwZW9mIGN0eCA9PT0gJ29iamVjdCcpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBkZWZhdWx0IHRvIGVycm5vIGZvciBVTktOT1dOXG4gICAgICBjdHguY29kZSA9IGUuY29kZSB8fCAnVU5LTk9XTic7XG4gICAgICBjdHguZXJybm8gPSBlLmVycm5vIHx8IEZTRXJyb3IuY29kZXMuVU5LTk9XTi5lcnJubztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnKTtcbiAgfVxufVxuXG4vKipcbiAqIHNldCBzeXNjYWxsIHByb3BlcnR5IG9uIGNvbnRleHQgb2JqZWN0LCBvbmx5IGZvciBub2RlanMgdjEwKy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjdHggQ29udGV4dCBvYmplY3QgKG9wdGlvbmFsKSwgb25seSBmb3Igbm9kZWpzIHYxMCsuXG4gKiBAcGFyYW0ge1N0cmluZ30gc3lzY2FsbCBOYW1lIG9mIHN5c2NhbGwuXG4gKi9cbmZ1bmN0aW9uIG1hcmtTeXNjYWxsKGN0eCwgc3lzY2FsbCkge1xuICBpZiAoY3R4ICYmIHR5cGVvZiBjdHggPT09ICdvYmplY3QnKSB7XG4gICAgY3R4LnN5c2NhbGwgPSBzeXNjYWxsO1xuICB9XG59XG5cbi8qKlxuICogSGFuZGxlIEZTUmVxV3JhcCBvbmNvbXBsZXRlLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGNhbGxiYWNrLlxuICogQHJldHVybiB7RnVuY3Rpb259IFRoZSBub3JtYWxpemVkIGNhbGxiYWNrLlxuICovXG5mdW5jdGlvbiBub3JtYWxpemVDYWxsYmFjayhjYWxsYmFjaykge1xuICBpZiAoY2FsbGJhY2sgJiYgdHlwZW9mIGNhbGxiYWNrLm9uY29tcGxldGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBVbnBhY2sgY2FsbGJhY2sgZnJvbSBGU1JlcVdyYXBcbiAgICBjYWxsYmFjayA9IGNhbGxiYWNrLm9uY29tcGxldGUuYmluZChjYWxsYmFjayk7XG4gIH1cbiAgcmV0dXJuIGNhbGxiYWNrO1xufVxuXG4vKipcbiAqIEhhbmRsZSBzdGF0IG9wdGltaXphdGlvbnMgaW50cm9kdWNlZCBpbiBOb2RlIDguXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL3B1bGwvMTE2NjUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgY2FsbGJhY2suXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gVGhlIHdyYXBwZWQgY2FsbGJhY2suXG4gKi9cbmZ1bmN0aW9uIHdyYXBTdGF0c0NhbGxiYWNrKGNhbGxiYWNrKSB7XG4gIGlmIChjYWxsYmFjayAmJiB0eXBlb2YgY2FsbGJhY2sub25jb21wbGV0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIFVucGFjayBjYWxsYmFjayBmcm9tIEZTUmVxV3JhcFxuICAgIGNhbGxiYWNrID0gY2FsbGJhY2sub25jb21wbGV0ZS5iaW5kKGNhbGxiYWNrKTtcbiAgfVxuICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGVyciwgc3RhdHMpIHtcbiAgICAgIGlmIChzdGF0cykge1xuICAgICAgICBmaWxsU3RhdHNBcnJheShzdGF0cywgc3RhdFZhbHVlcyk7XG4gICAgICB9XG4gICAgICBjYWxsYmFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldERpcmVudFR5cGUobW9kZSkge1xuICBjb25zdCBrdHlwZSA9IE1PREVfVE9fS1RZUEVbbW9kZSAmIGNvbnN0YW50cy5TX0lGTVRdO1xuXG4gIGlmIChrdHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGNvbnN0YW50cy5VVl9ESVJFTlRfVU5LTk9XTjtcbiAgfVxuXG4gIHJldHVybiBrdHlwZTtcbn1cblxuZnVuY3Rpb24gbm90SW1wbGVtZW50ZWQoKSB7XG4gIHRocm93IG5ldyBFcnJvcignTWV0aG9kIG5vdCBpbXBsZW1lbnRlZCcpO1xufVxuXG5mdW5jdGlvbiBkZUJ1ZmZlcihwKSB7XG4gIHJldHVybiBCdWZmZXIuaXNCdWZmZXIocCkgPyBwLnRvU3RyaW5nKCkgOiBwO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBzdGF0cyBvYmplY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIFN0YXRzIHByb3BlcnRpZXMuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gU3RhdHMoY29uZmlnKSB7XG4gIGZvciAoY29uc3Qga2V5IGluIGNvbmZpZykge1xuICAgIHRoaXNba2V5XSA9IGNvbmZpZ1trZXldO1xuICB9XG4gIC8vIG5vZGUgMTAgZXhwZWN0cyBhbiBhcnJheSBpbnRlcm5hbGx5XG4gIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvcHVsbC8xOTcxNFxuICBmaWxsU3RhdHNBcnJheShjb25maWcsIHRoaXMpO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIG1vZGUgaW5kaWNhdGVzIHByb3BlcnR5LlxuICogQHBhcmFtIHtudW1iZXJ9IHByb3BlcnR5IFByb3BlcnR5IHRvIGNoZWNrLlxuICogQHJldHVybiB7Ym9vbGVhbn0gUHJvcGVydHkgbWF0Y2hlcyBtb2RlLlxuICovXG5TdGF0cy5wcm90b3R5cGUuX2NoZWNrTW9kZVByb3BlcnR5ID0gZnVuY3Rpb24ocHJvcGVydHkpIHtcbiAgcmV0dXJuICh0aGlzLm1vZGUgJiBjb25zdGFudHMuU19JRk1UKSA9PT0gcHJvcGVydHk7XG59O1xuXG4vKipcbiAqIEByZXR1cm4ge0Jvb2xlYW59IElzIGEgZGlyZWN0b3J5LlxuICovXG5TdGF0cy5wcm90b3R5cGUuaXNEaXJlY3RvcnkgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2NoZWNrTW9kZVByb3BlcnR5KGNvbnN0YW50cy5TX0lGRElSKTtcbn07XG5cbi8qKlxuICogQHJldHVybiB7Qm9vbGVhbn0gSXMgYSByZWd1bGFyIGZpbGUuXG4gKi9cblN0YXRzLnByb3RvdHlwZS5pc0ZpbGUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2NoZWNrTW9kZVByb3BlcnR5KGNvbnN0YW50cy5TX0lGUkVHKTtcbn07XG5cbi8qKlxuICogQHJldHVybiB7Qm9vbGVhbn0gSXMgYSBibG9jayBkZXZpY2UuXG4gKi9cblN0YXRzLnByb3RvdHlwZS5pc0Jsb2NrRGV2aWNlID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9jaGVja01vZGVQcm9wZXJ0eShjb25zdGFudHMuU19JRkJMSyk7XG59O1xuXG4vKipcbiAqIEByZXR1cm4ge0Jvb2xlYW59IElzIGEgY2hhcmFjdGVyIGRldmljZS5cbiAqL1xuU3RhdHMucHJvdG90eXBlLmlzQ2hhcmFjdGVyRGV2aWNlID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9jaGVja01vZGVQcm9wZXJ0eShjb25zdGFudHMuU19JRkNIUik7XG59O1xuXG4vKipcbiAqIEByZXR1cm4ge0Jvb2xlYW59IElzIGEgc3ltYm9saWMgbGluay5cbiAqL1xuU3RhdHMucHJvdG90eXBlLmlzU3ltYm9saWNMaW5rID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9jaGVja01vZGVQcm9wZXJ0eShjb25zdGFudHMuU19JRkxOSyk7XG59O1xuXG4vKipcbiAqIEByZXR1cm4ge0Jvb2xlYW59IElzIGEgbmFtZWQgcGlwZS5cbiAqL1xuU3RhdHMucHJvdG90eXBlLmlzRklGTyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fY2hlY2tNb2RlUHJvcGVydHkoY29uc3RhbnRzLlNfSUZJRk8pO1xufTtcblxuLyoqXG4gKiBAcmV0dXJuIHtCb29sZWFufSBJcyBhIHNvY2tldC5cbiAqL1xuU3RhdHMucHJvdG90eXBlLmlzU29ja2V0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9jaGVja01vZGVQcm9wZXJ0eShjb25zdGFudHMuU19JRlNPQ0spO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgYmluZGluZyB3aXRoIHRoZSBnaXZlbiBmaWxlIHN5c3RlbS5cbiAqIEBwYXJhbSB7RmlsZVN5c3RlbX0gc3lzdGVtIE1vY2sgZmlsZSBzeXN0ZW0uXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gQmluZGluZyhzeXN0ZW0pIHtcbiAgLyoqXG4gICAqIE1vY2sgZmlsZSBzeXN0ZW0uXG4gICAqIEB0eXBlIHtGaWxlU3lzdGVtfVxuICAgKi9cbiAgdGhpcy5fc3lzdGVtID0gc3lzdGVtO1xuXG4gIC8qKlxuICAgKiBTdGF0cyBjb25zdHJ1Y3Rvci5cbiAgICogQHR5cGUge2Z1bmN0aW9ufVxuICAgKi9cbiAgdGhpcy5TdGF0cyA9IFN0YXRzO1xuXG4gIC8qKlxuICAgKiBMb29rdXAgb2Ygb3BlbiBmaWxlcy5cbiAgICogQHR5cGUge09iamVjdC48bnVtYmVyLCBGaWxlRGVzY3JpcHRvcj59XG4gICAqL1xuICB0aGlzLl9vcGVuRmlsZXMgPSB7fTtcblxuICAvKipcbiAgICogQ291bnRlciBmb3IgZmlsZSBkZXNjcmlwdG9ycy5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIHRoaXMuX2NvdW50ZXIgPSAtMTtcblxuICBjb25zdCBzdGRpbiA9IG5ldyBGaWxlRGVzY3JpcHRvcihjb25zdGFudHMuT19SRFdSKTtcbiAgc3RkaW4uc2V0SXRlbShuZXcgRmlsZS5TdGFuZGFyZElucHV0KCkpO1xuICB0aGlzLnRyYWNrRGVzY3JpcHRvcihzdGRpbik7XG5cbiAgY29uc3Qgc3Rkb3V0ID0gbmV3IEZpbGVEZXNjcmlwdG9yKGNvbnN0YW50cy5PX1JEV1IpO1xuICBzdGRvdXQuc2V0SXRlbShuZXcgRmlsZS5TdGFuZGFyZE91dHB1dCgpKTtcbiAgdGhpcy50cmFja0Rlc2NyaXB0b3Ioc3Rkb3V0KTtcblxuICBjb25zdCBzdGRlcnIgPSBuZXcgRmlsZURlc2NyaXB0b3IoY29uc3RhbnRzLk9fUkRXUik7XG4gIHN0ZGVyci5zZXRJdGVtKG5ldyBGaWxlLlN0YW5kYXJkRXJyb3IoKSk7XG4gIHRoaXMudHJhY2tEZXNjcmlwdG9yKHN0ZGVycik7XG59XG5cbi8qKlxuICogR2V0IHRoZSBmaWxlIHN5c3RlbSB1bmRlcmx5aW5nIHRoaXMgYmluZGluZy5cbiAqIEByZXR1cm4ge0ZpbGVTeXN0ZW19IFRoZSB1bmRlcmx5aW5nIGZpbGUgc3lzdGVtLlxuICovXG5CaW5kaW5nLnByb3RvdHlwZS5nZXRTeXN0ZW0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX3N5c3RlbTtcbn07XG5cbi8qKlxuICogUmVzZXQgdGhlIGZpbGUgc3lzdGVtIHVuZGVybHlpbmcgdGhpcyBiaW5kaW5nLlxuICogQHBhcmFtIHtGaWxlU3lzdGVtfSBzeXN0ZW0gVGhlIG5ldyBmaWxlIHN5c3RlbS5cbiAqL1xuQmluZGluZy5wcm90b3R5cGUuc2V0U3lzdGVtID0gZnVuY3Rpb24oc3lzdGVtKSB7XG4gIHRoaXMuX3N5c3RlbSA9IHN5c3RlbTtcbn07XG5cbi8qKlxuICogR2V0IGEgZmlsZSBkZXNjcmlwdG9yLlxuICogQHBhcmFtIHtudW1iZXJ9IGZkIEZpbGUgZGVzY3JpcHRvciBpZGVudGlmaWVyLlxuICogQHJldHVybiB7RmlsZURlc2NyaXB0b3J9IEZpbGUgZGVzY3JpcHRvci5cbiAqL1xuQmluZGluZy5wcm90b3R5cGUuZ2V0RGVzY3JpcHRvckJ5SWQgPSBmdW5jdGlvbihmZCkge1xuICBpZiAoIXRoaXMuX29wZW5GaWxlcy5oYXNPd25Qcm9wZXJ0eShmZCkpIHtcbiAgICB0aHJvdyBuZXcgRlNFcnJvcignRUJBREYnKTtcbiAgfVxuICByZXR1cm4gdGhpcy5fb3BlbkZpbGVzW2ZkXTtcbn07XG5cbi8qKlxuICogS2VlcCB0cmFjayBvZiBhIGZpbGUgZGVzY3JpcHRvciBhcyBvcGVuLlxuICogQHBhcmFtIHtGaWxlRGVzY3JpcHRvcn0gZGVzY3JpcHRvciBUaGUgZmlsZSBkZXNjcmlwdG9yLlxuICogQHJldHVybiB7bnVtYmVyfSBJZGVudGlmaWVyIGZvciBmaWxlIGRlc2NyaXB0b3IuXG4gKi9cbkJpbmRpbmcucHJvdG90eXBlLnRyYWNrRGVzY3JpcHRvciA9IGZ1bmN0aW9uKGRlc2NyaXB0b3IpIHtcbiAgY29uc3QgZmQgPSArK3RoaXMuX2NvdW50ZXI7XG4gIHRoaXMuX29wZW5GaWxlc1tmZF0gPSBkZXNjcmlwdG9yO1xuICByZXR1cm4gZmQ7XG59O1xuXG4vKipcbiAqIFN0b3AgdHJhY2tpbmcgYSBmaWxlIGRlc2NyaXB0b3IgYXMgb3Blbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmZCBJZGVudGlmaWVyIGZvciBmaWxlIGRlc2NyaXB0b3IuXG4gKi9cbkJpbmRpbmcucHJvdG90eXBlLnVudHJhY2tEZXNjcmlwdG9yQnlJZCA9IGZ1bmN0aW9uKGZkKSB7XG4gIGlmICghdGhpcy5fb3BlbkZpbGVzLmhhc093blByb3BlcnR5KGZkKSkge1xuICAgIHRocm93IG5ldyBGU0Vycm9yKCdFQkFERicpO1xuICB9XG4gIGRlbGV0ZSB0aGlzLl9vcGVuRmlsZXNbZmRdO1xufTtcblxuLyoqXG4gKiBSZXNvbHZlIHRoZSBjYW5vbmljYWxpemVkIGFic29sdXRlIHBhdGhuYW1lLlxuICogQHBhcmFtIHtzdHJpbmd8QnVmZmVyfSBmaWxlcGF0aCBUaGUgZmlsZSBwYXRoLlxuICogQHBhcmFtIHtzdHJpbmd9IGVuY29kaW5nIFRoZSBlbmNvZGluZyBmb3IgdGhlIHJldHVybi5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjdHggQ29udGV4dCBvYmplY3QgKG9wdGlvbmFsKSwgb25seSBmb3Igbm9kZWpzIHYxMCsuXG4gKiBAcmV0dXJuIHtzdHJpbmd8QnVmZmVyfSBUaGUgcmVhbCBwYXRoLlxuICovXG5CaW5kaW5nLnByb3RvdHlwZS5yZWFscGF0aCA9IGZ1bmN0aW9uKGZpbGVwYXRoLCBlbmNvZGluZywgY2FsbGJhY2ssIGN0eCkge1xuICBtYXJrU3lzY2FsbChjdHgsICdyZWFscGF0aCcpO1xuXG4gIHJldHVybiBtYXliZUNhbGxiYWNrKG5vcm1hbGl6ZUNhbGxiYWNrKGNhbGxiYWNrKSwgY3R4LCB0aGlzLCBmdW5jdGlvbigpIHtcbiAgICBsZXQgcmVhbFBhdGg7XG4gICAgZmlsZXBhdGggPSBkZUJ1ZmZlcihmaWxlcGF0aCk7XG4gICAgY29uc3QgcmVzb2x2ZWQgPSBwYXRoLnJlc29sdmUoZmlsZXBhdGgpO1xuICAgIGNvbnN0IHBhcnRzID0gZ2V0UGF0aFBhcnRzKHJlc29sdmVkKTtcbiAgICBsZXQgaXRlbSA9IHRoaXMuX3N5c3RlbS5nZXRSb290KCk7XG4gICAgbGV0IGl0ZW1QYXRoID0gJy8nO1xuICAgIGxldCBuYW1lLCBpLCBpaTtcbiAgICBmb3IgKGkgPSAwLCBpaSA9IHBhcnRzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgIG5hbWUgPSBwYXJ0c1tpXTtcbiAgICAgIHdoaWxlIChpdGVtIGluc3RhbmNlb2YgU3ltYm9saWNMaW5rKSB7XG4gICAgICAgIGl0ZW1QYXRoID0gcGF0aC5yZXNvbHZlKHBhdGguZGlybmFtZShpdGVtUGF0aCksIGl0ZW0uZ2V0UGF0aCgpKTtcbiAgICAgICAgaXRlbSA9IHRoaXMuX3N5c3RlbS5nZXRJdGVtKGl0ZW1QYXRoKTtcbiAgICAgIH1cbiAgICAgIGlmICghaXRlbSkge1xuICAgICAgICB0aHJvdyBuZXcgRlNFcnJvcignRU5PRU5UJywgZmlsZXBhdGgpO1xuICAgICAgfVxuICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBEaXJlY3RvcnkpIHtcbiAgICAgICAgaXRlbVBhdGggPSBwYXRoLnJlc29sdmUoaXRlbVBhdGgsIG5hbWUpO1xuICAgICAgICBpdGVtID0gaXRlbS5nZXRJdGVtKG5hbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEZTRXJyb3IoJ0VOT1RESVInLCBmaWxlcGF0aCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpdGVtKSB7XG4gICAgICB3aGlsZSAoaXRlbSBpbnN0YW5jZW9mIFN5bWJvbGljTGluaykge1xuICAgICAgICBpdGVtUGF0aCA9IHBhdGgucmVzb2x2ZShwYXRoLmRpcm5hbWUoaXRlbVBhdGgpLCBpdGVtLmdldFBhdGgoKSk7XG4gICAgICAgIGl0ZW0gPSB0aGlzLl9zeXN0ZW0uZ2V0SXRlbShpdGVtUGF0aCk7XG4gICAgICB9XG4gICAgICByZWFsUGF0aCA9IGl0ZW1QYXRoO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRlNFcnJvcignRU5PRU5UJywgZmlsZXBhdGgpO1xuICAgIH1cblxuICAgIGlmIChwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInICYmIHJlYWxQYXRoLnN0YXJ0c1dpdGgoJ1xcXFxcXFxcP1xcXFwnKSkge1xuICAgICAgLy8gUmVtb3ZlIHdpbjMyIGZpbGUgbmFtZXNwYWNlIHByZWZpeCBcXFxcP1xcXG4gICAgICByZWFsUGF0aCA9IHJlYWxQYXRoLnNsaWNlKDQpO1xuICAgIH1cblxuICAgIGlmIChlbmNvZGluZyA9PT0gJ2J1ZmZlcicpIHtcbiAgICAgIHJlYWxQYXRoID0gYnVmZmVyRnJvbShyZWFsUGF0aCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlYWxQYXRoO1xuICB9KTtcbn07XG5cbi8qKlxuICogRmlsbCBhIEZsb2F0NjRBcnJheSB3aXRoIHN0YXQgaW5mb3JtYXRpb25cbiAqIFRoaXMgaXMgYmFzZWQgb24gdGhlIGludGVybmFsIEZpbGxTdGF0c0FycmF5IGZ1bmN0aW9uIGluIE5vZGUuXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvYmxvYi80ZTA1OTUyYThhNzVhZjZkZjYyNTQxNWRiNjEyZDNhOWExMzIyNjgyL3NyYy9ub2RlX2ZpbGUuY2MjTDUzM1xuICogQHBhcmFtIHtPYmplY3R9IHN0YXRzIEFuIG9iamVjdCB3aXRoIGZpbGUgc3RhdHNcbiAqIEBwYXJhbSB7RmxvYXQ2NEFycmF5fSBzdGF0VmFsdWVzIEEgRmxvYXQ2NEFycmF5IHdoZXJlIHN0YXQgdmFsdWVzIHNob3VsZCBiZSBpbnNlcnRlZFxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmZ1bmN0aW9uIGZpbGxTdGF0c0FycmF5KHN0YXRzLCBzdGF0VmFsdWVzKSB7XG4gIHN0YXRWYWx1ZXNbMF0gPSBzdGF0cy5kZXY7XG4gIHN0YXRWYWx1ZXNbMV0gPSBzdGF0cy5tb2RlO1xuICBzdGF0VmFsdWVzWzJdID0gc3RhdHMubmxpbms7XG4gIHN0YXRWYWx1ZXNbM10gPSBzdGF0cy51aWQ7XG4gIHN0YXRWYWx1ZXNbNF0gPSBzdGF0cy5naWQ7XG4gIHN0YXRWYWx1ZXNbNV0gPSBzdGF0cy5yZGV2O1xuICBzdGF0VmFsdWVzWzZdID0gc3RhdHMuYmxrc2l6ZTtcbiAgc3RhdFZhbHVlc1s3XSA9IHN0YXRzLmlubztcbiAgc3RhdFZhbHVlc1s4XSA9IHN0YXRzLnNpemU7XG4gIHN0YXRWYWx1ZXNbOV0gPSBzdGF0cy5ibG9ja3M7XG5cbiAgaWYgKHN0YXRDb250YWluc05zKSB7XG4gICAgLy8gbm9kZWpzIHYxMi4xMC4wK1xuICAgIC8vIFRoaXMgaXMgYmFzZWQgb24gdGhlIGludGVybmFsIEZpbGxTdGF0c0FycmF5IGZ1bmN0aW9uIGluIE5vZGUuXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2Jsb2IvM2EyZTc1ZDlhNWMzMWQyMGU0MjlkNTA1YjgyZGQxODJlMzNmNDU5YS9zcmMvbm9kZV9maWxlLmgjTDE1My1MMTg3XG4gICAgc3RhdFZhbHVlc1sxMF0gPSBNYXRoLmZsb29yKHN0YXRzLmF0aW1lTXMgLyAxMDAwKTtcbiAgICBzdGF0VmFsdWVzWzExXSA9IChzdGF0cy5hdGltZU1zICUgMTAwMCkgKiAxMDAwMDAwO1xuICAgIHN0YXRWYWx1ZXNbMTJdID0gTWF0aC5mbG9vcihzdGF0cy5tdGltZU1zIC8gMTAwMCk7XG4gICAgc3RhdFZhbHVlc1sxM10gPSAoc3RhdHMubXRpbWVNcyAlIDEwMDApICogMTAwMDAwMDtcbiAgICBzdGF0VmFsdWVzWzE0XSA9IE1hdGguZmxvb3Ioc3RhdHMuY3RpbWVNcyAvIDEwMDApO1xuICAgIHN0YXRWYWx1ZXNbMTVdID0gKHN0YXRzLmN0aW1lTXMgJSAxMDAwKSAqIDEwMDAwMDA7XG4gICAgc3RhdFZhbHVlc1sxNl0gPSBNYXRoLmZsb29yKHN0YXRzLmJpcnRodGltZU1zIC8gMTAwMCk7XG4gICAgc3RhdFZhbHVlc1sxN10gPSAoc3RhdHMuYmlydGh0aW1lTXMgJSAxMDAwKSAqIDEwMDAwMDA7XG4gIH0gZWxzZSB7XG4gICAgLy8gbm9kZWpzIGJlZm9yZSB2MTIuMTAuMFxuICAgIC8vIFRoaXMgaXMgYmFzZWQgb24gdGhlIGludGVybmFsIEZpbGxTdGF0c0FycmF5IGZ1bmN0aW9uIGluIE5vZGUuXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2Jsb2IvNGUwNTk1MmE4YTc1YWY2ZGY2MjU0MTVkYjYxMmQzYTlhMTMyMjY4Mi9zcmMvbm9kZV9maWxlLmNjI0w1MzNcbiAgICBzdGF0VmFsdWVzWzEwXSA9IHN0YXRzLmF0aW1lTXM7XG4gICAgc3RhdFZhbHVlc1sxMV0gPSBzdGF0cy5tdGltZU1zO1xuICAgIHN0YXRWYWx1ZXNbMTJdID0gc3RhdHMuY3RpbWVNcztcbiAgICBzdGF0VmFsdWVzWzEzXSA9IHN0YXRzLmJpcnRodGltZU1zO1xuICB9XG59XG5cbi8qKlxuICogU3RhdCBhbiBpdGVtLlxuICogQHBhcmFtIHtzdHJpbmd9IGZpbGVwYXRoIFBhdGguXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yLCBTdGF0cyl8RmxvYXQ2NEFycmF5fEJpZ1VpbnQ2NEFycmF5fSBjYWxsYmFjayBDYWxsYmFjayAob3B0aW9uYWwpLiBJbiBOb2RlIDcuNy4wKyB0aGlzIHdpbGwgYmUgYSBGbG9hdDY0QXJyYXlcbiAqIHRoYXQgc2hvdWxkIGJlIGZpbGxlZCB3aXRoIHN0YXQgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IGN0eCBDb250ZXh0IG9iamVjdCAob3B0aW9uYWwpLCBvbmx5IGZvciBub2RlanMgdjEwKy5cbiAqIEByZXR1cm4ge1N0YXRzfHVuZGVmaW5lZH0gU3RhdHMgb3IgdW5kZWZpbmVkIChpZiBzeW5jKS5cbiAqL1xuQmluZGluZy5wcm90b3R5cGUuc3RhdCA9IGZ1bmN0aW9uKGZpbGVwYXRoLCBvcHRpb25zLCBjYWxsYmFjaywgY3R4KSB7XG4gIC8vIHRoaXMgc2VlbXMgd291bmQgbm90IGhhcHBlbiBpbiBub2RlanMgdjEwK1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDMpIHtcbiAgICBjYWxsYmFjayA9IG9wdGlvbnM7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgbWFya1N5c2NhbGwoY3R4LCAnc3RhdCcpO1xuXG4gIHJldHVybiBtYXliZUNhbGxiYWNrKHdyYXBTdGF0c0NhbGxiYWNrKGNhbGxiYWNrKSwgY3R4LCB0aGlzLCBmdW5jdGlvbigpIHtcbiAgICBmaWxlcGF0aCA9IGRlQnVmZmVyKGZpbGVwYXRoKTtcbiAgICBsZXQgaXRlbSA9IHRoaXMuX3N5c3RlbS5nZXRJdGVtKGZpbGVwYXRoKTtcbiAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIFN5bWJvbGljTGluaykge1xuICAgICAgaXRlbSA9IHRoaXMuX3N5c3RlbS5nZXRJdGVtKFxuICAgICAgICBwYXRoLnJlc29sdmUocGF0aC5kaXJuYW1lKGZpbGVwYXRoKSwgaXRlbS5nZXRQYXRoKCkpXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoIWl0ZW0pIHtcbiAgICAgIHRocm93IG5ldyBGU0Vycm9yKCdFTk9FTlQnLCBmaWxlcGF0aCk7XG4gICAgfVxuICAgIGNvbnN0IHN0YXRzID0gaXRlbS5nZXRTdGF0cygpO1xuXG4gICAgLy8gSW4gTm9kZSA3LjcuMCssIGJpbmRpbmcuc3RhdCBhY2NlcHRzIGEgRmxvYXQ2NEFycmF5IGFzIHRoZSBzZWNvbmQgYXJndW1lbnQsXG4gICAgLy8gd2hpY2ggc2hvdWxkIGJlIGZpbGxlZCB3aXRoIHN0YXQgdmFsdWVzLlxuICAgIC8vIEluIHByaW9yIHZlcnNpb25zIG9mIE5vZGUsIGJpbmRpbmcuc3RhdCBzaW1wbHkgcmV0dXJucyBhIFN0YXRzIGluc3RhbmNlLlxuICAgIGlmIChcbiAgICAgIGNhbGxiYWNrIGluc3RhbmNlb2YgRmxvYXQ2NEFycmF5IHx8XG4gICAgICBjYWxsYmFjayBpbnN0YW5jZW9mIEJpZ1VpbnQ2NEFycmF5XG4gICAgKSB7XG4gICAgICBmaWxsU3RhdHNBcnJheShzdGF0cywgY2FsbGJhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICBmaWxsU3RhdHNBcnJheShzdGF0cywgc3RhdFZhbHVlcyk7XG4gICAgICByZXR1cm4gbmV3IFN0YXRzKHN0YXRzKTtcbiAgICB9XG4gIH0pO1xufTtcblxuLyoqXG4gKiBTdGF0IGFuIGl0ZW0uXG4gKiBAcGFyYW0ge251bWJlcn0gZmQgRmlsZSBkZXNjcmlwdG9yLlxuICogQHBhcmFtIHtmdW5jdGlvbihFcnJvciwgU3RhdHMpfEZsb2F0NjRBcnJheXxCaWdVaW50NjRBcnJheX0gY2FsbGJhY2sgQ2FsbGJhY2sgKG9wdGlvbmFsKS4gSW4gTm9kZSA3LjcuMCsgdGhpcyB3aWxsIGJlIGEgRmxvYXQ2NEFycmF5XG4gKiB0aGF0IHNob3VsZCBiZSBmaWxsZWQgd2l0aCBzdGF0IHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjdHggQ29udGV4dCBvYmplY3QgKG9wdGlvbmFsKSwgb25seSBmb3Igbm9kZWpzIHYxMCsuXG4gKiBAcmV0dXJuIHtTdGF0c3x1bmRlZmluZWR9IFN0YXRzIG9yIHVuZGVmaW5lZCAoaWYgc3luYykuXG4gKi9cbkJpbmRpbmcucHJvdG90eXBlLmZzdGF0ID0gZnVuY3Rpb24oZmQsIG9wdGlvbnMsIGNhbGxiYWNrLCBjdHgpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAzKSB7XG4gICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIG1hcmtTeXNjYWxsKGN0eCwgJ2ZzdGF0Jyk7XG5cbiAgcmV0dXJuIG1heWJlQ2FsbGJhY2sod3JhcFN0YXRzQ2FsbGJhY2soY2FsbGJhY2spLCBjdHgsIHRoaXMsIGZ1bmN0aW9uKCkge1xuICAgIGNvbnN0IGRlc2NyaXB0b3IgPSB0aGlzLmdldERlc2NyaXB0b3JCeUlkKGZkKTtcbiAgICBjb25zdCBpdGVtID0gZGVzY3JpcHRvci5nZXRJdGVtKCk7XG4gICAgY29uc3Qgc3RhdHMgPSBpdGVtLmdldFN0YXRzKCk7XG5cbiAgICAvLyBJbiBOb2RlIDcuNy4wKywgYmluZGluZy5zdGF0IGFjY2VwdHMgYSBGbG9hdDY0QXJyYXkgYXMgdGhlIHNlY29uZCBhcmd1bWVudCxcbiAgICAvLyB3aGljaCBzaG91bGQgYmUgZmlsbGVkIHdpdGggc3RhdCB2YWx1ZXMuXG4gICAgLy8gSW4gcHJpb3IgdmVyc2lvbnMgb2YgTm9kZSwgYmluZGluZy5zdGF0IHNpbXBseSByZXR1cm5zIGEgU3RhdHMgaW5zdGFuY2UuXG4gICAgaWYgKFxuICAgICAgY2FsbGJhY2sgaW5zdGFuY2VvZiBGbG9hdDY0QXJyYXkgfHxcbiAgICAgIGNhbGxiYWNrIGluc3RhbmNlb2YgQmlnVWludDY0QXJyYXlcbiAgICApIHtcbiAgICAgIGZpbGxTdGF0c0FycmF5KHN0YXRzLCBjYWxsYmFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZpbGxTdGF0c0FycmF5KHN0YXRzLCBzdGF0VmFsdWVzKTtcbiAgICAgIHJldHVybiBuZXcgU3RhdHMoc3RhdHMpO1xuICAgIH1cbiAgfSk7XG59O1xuXG4vKipcbiAqIENsb3NlIGEgZmlsZSBkZXNjcmlwdG9yLlxuICogQHBhcmFtIHtudW1iZXJ9IGZkIEZpbGUgZGVzY3JpcHRvci5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IpfSBjYWxsYmFjayBDYWxsYmFjayAob3B0aW9uYWwpLlxuICogQHBhcmFtIHtPYmplY3R9IGN0eCBDb250ZXh0IG9iamVjdCAob3B0aW9uYWwpLCBvbmx5IGZvciBub2RlanMgdjEwKy5cbiAqL1xuQmluZGluZy5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbihmZCwgY2FsbGJhY2ssIGN0eCkge1xuICBtYXJrU3lzY2FsbChjdHgsICdjbG9zZScpO1xuXG4gIHJldHVybiBtYXliZUNhbGxiYWNrKG5vcm1hbGl6ZUNhbGxiYWNrKGNhbGxiYWNrKSwgY3R4LCB0aGlzLCBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnVudHJhY2tEZXNjcmlwdG9yQnlJZChmZCk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBPcGVuIGFuZCBwb3NzaWJseSBjcmVhdGUgYSBmaWxlLlxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGhuYW1lIEZpbGUgcGF0aC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmbGFncyBGbGFncy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtb2RlIE1vZGUuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yLCBzdHJpbmcpfSBjYWxsYmFjayBDYWxsYmFjayAob3B0aW9uYWwpLlxuICogQHBhcmFtIHtPYmplY3R9IGN0eCBDb250ZXh0IG9iamVjdCAob3B0aW9uYWwpLCBvbmx5IGZvciBub2RlanMgdjEwKy5cbiAqIEByZXR1cm4ge3N0cmluZ30gRmlsZSBkZXNjcmlwdG9yIChpZiBzeW5jKS5cbiAqL1xuQmluZGluZy5wcm90b3R5cGUub3BlbiA9IGZ1bmN0aW9uKHBhdGhuYW1lLCBmbGFncywgbW9kZSwgY2FsbGJhY2ssIGN0eCkge1xuICBtYXJrU3lzY2FsbChjdHgsICdvcGVuJyk7XG5cbiAgcmV0dXJuIG1heWJlQ2FsbGJhY2sobm9ybWFsaXplQ2FsbGJhY2soY2FsbGJhY2spLCBjdHgsIHRoaXMsIGZ1bmN0aW9uKCkge1xuICAgIHBhdGhuYW1lID0gZGVCdWZmZXIocGF0aG5hbWUpO1xuICAgIGNvbnN0IGRlc2NyaXB0b3IgPSBuZXcgRmlsZURlc2NyaXB0b3IoZmxhZ3MpO1xuICAgIGxldCBpdGVtID0gdGhpcy5fc3lzdGVtLmdldEl0ZW0ocGF0aG5hbWUpO1xuICAgIHdoaWxlIChpdGVtIGluc3RhbmNlb2YgU3ltYm9saWNMaW5rKSB7XG4gICAgICBpdGVtID0gdGhpcy5fc3lzdGVtLmdldEl0ZW0oXG4gICAgICAgIHBhdGgucmVzb2x2ZShwYXRoLmRpcm5hbWUocGF0aG5hbWUpLCBpdGVtLmdldFBhdGgoKSlcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChkZXNjcmlwdG9yLmlzRXhjbHVzaXZlKCkgJiYgaXRlbSkge1xuICAgICAgdGhyb3cgbmV3IEZTRXJyb3IoJ0VFWElTVCcsIHBhdGhuYW1lKTtcbiAgICB9XG4gICAgaWYgKGRlc2NyaXB0b3IuaXNDcmVhdGUoKSAmJiAhaXRlbSkge1xuICAgICAgY29uc3QgcGFyZW50ID0gdGhpcy5fc3lzdGVtLmdldEl0ZW0ocGF0aC5kaXJuYW1lKHBhdGhuYW1lKSk7XG4gICAgICBpZiAoIXBhcmVudCkge1xuICAgICAgICB0aHJvdyBuZXcgRlNFcnJvcignRU5PRU5UJywgcGF0aG5hbWUpO1xuICAgICAgfVxuICAgICAgaWYgKCEocGFyZW50IGluc3RhbmNlb2YgRGlyZWN0b3J5KSkge1xuICAgICAgICB0aHJvdyBuZXcgRlNFcnJvcignRU5PVERJUicsIHBhdGhuYW1lKTtcbiAgICAgIH1cbiAgICAgIGl0ZW0gPSBuZXcgRmlsZSgpO1xuICAgICAgaWYgKG1vZGUpIHtcbiAgICAgICAgaXRlbS5zZXRNb2RlKG1vZGUpO1xuICAgICAgfVxuICAgICAgcGFyZW50LmFkZEl0ZW0ocGF0aC5iYXNlbmFtZShwYXRobmFtZSksIGl0ZW0pO1xuICAgIH1cbiAgICBpZiAoZGVzY3JpcHRvci5pc1JlYWQoKSkge1xuICAgICAgaWYgKCFpdGVtKSB7XG4gICAgICAgIHRocm93IG5ldyBGU0Vycm9yKCdFTk9FTlQnLCBwYXRobmFtZSk7XG4gICAgICB9XG4gICAgICBpZiAoIWl0ZW0uY2FuUmVhZCgpKSB7XG4gICAgICAgIHRocm93IG5ldyBGU0Vycm9yKCdFQUNDRVMnLCBwYXRobmFtZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChkZXNjcmlwdG9yLmlzV3JpdGUoKSAmJiAhaXRlbS5jYW5Xcml0ZSgpKSB7XG4gICAgICB0aHJvdyBuZXcgRlNFcnJvcignRUFDQ0VTJywgcGF0aG5hbWUpO1xuICAgIH1cbiAgICBpZiAoXG4gICAgICBpdGVtIGluc3RhbmNlb2YgRGlyZWN0b3J5ICYmXG4gICAgICAoZGVzY3JpcHRvci5pc1RydW5jYXRlKCkgfHwgZGVzY3JpcHRvci5pc0FwcGVuZCgpKVxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEZTRXJyb3IoJ0VJU0RJUicsIHBhdGhuYW1lKTtcbiAgICB9XG4gICAgaWYgKGRlc2NyaXB0b3IuaXNUcnVuY2F0ZSgpKSB7XG4gICAgICBpZiAoIShpdGVtIGluc3RhbmNlb2YgRmlsZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEZTRXJyb3IoJ0VCQURGJyk7XG4gICAgICB9XG4gICAgICBpdGVtLnNldENvbnRlbnQoJycpO1xuICAgIH1cbiAgICBpZiAoZGVzY3JpcHRvci5pc1RydW5jYXRlKCkgfHwgZGVzY3JpcHRvci5pc0FwcGVuZCgpKSB7XG4gICAgICBkZXNjcmlwdG9yLnNldFBvc2l0aW9uKGl0ZW0uZ2V0Q29udGVudCgpLmxlbmd0aCk7XG4gICAgfVxuICAgIGRlc2NyaXB0b3Iuc2V0SXRlbShpdGVtKTtcbiAgICByZXR1cm4gdGhpcy50cmFja0Rlc2NyaXB0b3IoZGVzY3JpcHRvcik7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBPcGVuIGEgZmlsZSBoYW5kbGVyLiBBIG5ldyBhcGkgaW4gbm9kZWpzIHYxMCsgZm9yIGZzLnByb21pc2VzXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aG5hbWUgRmlsZSBwYXRoLlxuICogQHBhcmFtIHtudW1iZXJ9IGZsYWdzIEZsYWdzLlxuICogQHBhcmFtIHtudW1iZXJ9IG1vZGUgTW9kZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIChvcHRpb25hbCksIGV4cGVjdGluZyBrVXNlUHJvbWlzZXMgaW4gbm9kZWpzIHYxMCsuXG4gKi9cbkJpbmRpbmcucHJvdG90eXBlLm9wZW5GaWxlSGFuZGxlID0gZnVuY3Rpb24ocGF0aG5hbWUsIGZsYWdzLCBtb2RlLCBjYWxsYmFjaykge1xuICBjb25zdCBzZWxmID0gdGhpcztcblxuICByZXR1cm4gdGhpcy5vcGVuKHBhdGhuYW1lLCBmbGFncywgbW9kZSwga1VzZVByb21pc2VzKS50aGVuKGZ1bmN0aW9uKGZkKSB7XG4gICAgLy8gbm9kZWpzIHYxMCsgZnMucHJvbWlzZXMgRmlsZUhhbmRsZXIgY29uc3RydWN0b3Igb25seSBhc2sgdGhlc2UgdGhyZWUgcHJvcGVydGllcy5cbiAgICByZXR1cm4ge1xuICAgICAgZ2V0QXN5bmNJZDogbm90SW1wbGVtZW50ZWQsXG4gICAgICBmZDogZmQsXG4gICAgICBjbG9zZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBzZWxmLmNsb3NlKGZkLCBrVXNlUHJvbWlzZXMpO1xuICAgICAgfVxuICAgIH07XG4gIH0pO1xufTtcblxuLyoqXG4gKiBSZWFkIGZyb20gYSBmaWxlIGRlc2NyaXB0b3IuXG4gKiBAcGFyYW0ge3N0cmluZ30gZmQgRmlsZSBkZXNjcmlwdG9yLlxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZmZlciBCdWZmZXIgdGhhdCB0aGUgY29udGVudHMgd2lsbCBiZSB3cml0dGVuIHRvLlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQgaW4gdGhlIGJ1ZmZlciB0byBzdGFydCB3cml0aW5nIHRvLlxuICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aCBOdW1iZXIgb2YgYnl0ZXMgdG8gcmVhZC5cbiAqIEBwYXJhbSB7P251bWJlcn0gcG9zaXRpb24gV2hlcmUgdG8gYmVnaW4gcmVhZGluZyBpbiB0aGUgZmlsZS4gIElmIG51bGwsXG4gKiAgICAgZGF0YSB3aWxsIGJlIHJlYWQgZnJvbSB0aGUgY3VycmVudCBmaWxlIHBvc2l0aW9uLlxuICogQHBhcmFtIHtmdW5jdGlvbihFcnJvciwgbnVtYmVyLCBCdWZmZXIpfSBjYWxsYmFjayBDYWxsYmFjayAob3B0aW9uYWwpIGNhbGxlZFxuICogICAgIHdpdGggYW55IGVycm9yLCBudW1iZXIgb2YgYnl0ZXMgcmVhZCwgYW5kIHRoZSBidWZmZXIuXG4gKiBAcGFyYW0ge09iamVjdH0gY3R4IENvbnRleHQgb2JqZWN0IChvcHRpb25hbCksIG9ubHkgZm9yIG5vZGVqcyB2MTArLlxuICogQHJldHVybiB7bnVtYmVyfSBOdW1iZXIgb2YgYnl0ZXMgcmVhZCAoaWYgc3luYykuXG4gKi9cbkJpbmRpbmcucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbihcbiAgZmQsXG4gIGJ1ZmZlcixcbiAgb2Zmc2V0LFxuICBsZW5ndGgsXG4gIHBvc2l0aW9uLFxuICBjYWxsYmFjayxcbiAgY3R4XG4pIHtcbiAgbWFya1N5c2NhbGwoY3R4LCAncmVhZCcpO1xuXG4gIHJldHVybiBtYXliZUNhbGxiYWNrKG5vcm1hbGl6ZUNhbGxiYWNrKGNhbGxiYWNrKSwgY3R4LCB0aGlzLCBmdW5jdGlvbigpIHtcbiAgICBjb25zdCBkZXNjcmlwdG9yID0gdGhpcy5nZXREZXNjcmlwdG9yQnlJZChmZCk7XG4gICAgaWYgKCFkZXNjcmlwdG9yLmlzUmVhZCgpKSB7XG4gICAgICB0aHJvdyBuZXcgRlNFcnJvcignRUJBREYnKTtcbiAgICB9XG4gICAgY29uc3QgZmlsZSA9IGRlc2NyaXB0b3IuZ2V0SXRlbSgpO1xuICAgIGlmIChmaWxlIGluc3RhbmNlb2YgRGlyZWN0b3J5KSB7XG4gICAgICB0aHJvdyBuZXcgRlNFcnJvcignRUlTRElSJyk7XG4gICAgfVxuICAgIGlmICghKGZpbGUgaW5zdGFuY2VvZiBGaWxlKSkge1xuICAgICAgLy8gZGVsZXRlZCBvciBub3QgYSByZWd1bGFyIGZpbGVcbiAgICAgIHRocm93IG5ldyBGU0Vycm9yKCdFQkFERicpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHBvc2l0aW9uICE9PSAnbnVtYmVyJyB8fCBwb3NpdGlvbiA8IDApIHtcbiAgICAgIHBvc2l0aW9uID0gZGVzY3JpcHRvci5nZXRQb3NpdGlvbigpO1xuICAgIH1cbiAgICBjb25zdCBjb250ZW50ID0gZmlsZS5nZXRDb250ZW50KCk7XG4gICAgY29uc3Qgc3RhcnQgPSBNYXRoLm1pbihwb3NpdGlvbiwgY29udGVudC5sZW5ndGgpO1xuICAgIGNvbnN0IGVuZCA9IE1hdGgubWluKHBvc2l0aW9uICsgbGVuZ3RoLCBjb250ZW50Lmxlbmd0aCk7XG4gICAgY29uc3QgcmVhZCA9IHN0YXJ0IDwgZW5kID8gY29udGVudC5jb3B5KGJ1ZmZlciwgb2Zmc2V0LCBzdGFydCwgZW5kKSA6IDA7XG4gICAgZGVzY3JpcHRvci5zZXRQb3NpdGlvbihwb3NpdGlvbiArIHJlYWQpO1xuICAgIHJldHVybiByZWFkO1xuICB9KTtcbn07XG5cbi8qKlxuICogV3JpdGUgdG8gYSBmaWxlIGRlc2NyaXB0b3IgZ2l2ZW4gYSBidWZmZXIuXG4gKiBAcGFyYW0ge3N0cmluZ30gc3JjIFNvdXJjZSBmaWxlLlxuICogQHBhcmFtIHtzdHJpbmd9IGRlc3QgRGVzdGluYXRpb24gZmlsZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmbGFncyBNb2RpZmllcnMgZm9yIGNvcHkgb3BlcmF0aW9uLlxuICogQHBhcmFtIHtmdW5jdGlvbihFcnJvcil9IGNhbGxiYWNrIENhbGxiYWNrIChvcHRpb25hbCkgY2FsbGVkXG4gKiAgICAgd2l0aCBhbnkgZXJyb3IuXG4gKiBAcGFyYW0ge09iamVjdH0gY3R4IENvbnRleHQgb2JqZWN0IChvcHRpb25hbCksIG9ubHkgZm9yIG5vZGVqcyB2MTArLlxuICovXG5CaW5kaW5nLnByb3RvdHlwZS5jb3B5RmlsZSA9IGZ1bmN0aW9uKHNyYywgZGVzdCwgZmxhZ3MsIGNhbGxiYWNrLCBjdHgpIHtcbiAgbWFya1N5c2NhbGwoY3R4LCAnY29weWZpbGUnKTtcblxuICByZXR1cm4gbWF5YmVDYWxsYmFjayhub3JtYWxpemVDYWxsYmFjayhjYWxsYmFjayksIGN0eCwgdGhpcywgZnVuY3Rpb24oKSB7XG4gICAgc3JjID0gZGVCdWZmZXIoc3JjKTtcbiAgICBkZXN0ID0gZGVCdWZmZXIoZGVzdCk7XG4gICAgY29uc3Qgc3JjRmQgPSB0aGlzLm9wZW4oc3JjLCBjb25zdGFudHMuT19SRE9OTFkpO1xuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHNyY0Rlc2NyaXB0b3IgPSB0aGlzLmdldERlc2NyaXB0b3JCeUlkKHNyY0ZkKTtcbiAgICAgIGlmICghc3JjRGVzY3JpcHRvci5pc1JlYWQoKSkge1xuICAgICAgICB0aHJvdyBuZXcgRlNFcnJvcignRUJBREYnKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNyY0ZpbGUgPSBzcmNEZXNjcmlwdG9yLmdldEl0ZW0oKTtcbiAgICAgIGlmICghKHNyY0ZpbGUgaW5zdGFuY2VvZiBGaWxlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRlNFcnJvcignRUJBREYnKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNyY0NvbnRlbnQgPSBzcmNGaWxlLmdldENvbnRlbnQoKTtcblxuICAgICAgbGV0IGRlc3RGbGFncyA9XG4gICAgICAgIGNvbnN0YW50cy5PX1dST05MWSB8IGNvbnN0YW50cy5PX0NSRUFUIHwgY29uc3RhbnRzLk9fVFJVTkM7XG5cbiAgICAgIGlmICgoZmxhZ3MgJiBjb25zdGFudHMuQ09QWUZJTEVfRVhDTCkgPT09IGNvbnN0YW50cy5DT1BZRklMRV9FWENMKSB7XG4gICAgICAgIGRlc3RGbGFncyB8PSBjb25zdGFudHMuT19FWENMO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBkZXN0RmQgPSB0aGlzLm9wZW4oZGVzdCwgZGVzdEZsYWdzKTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy53cml0ZShkZXN0RmQsIHNyY0NvbnRlbnQsIDAsIHNyY0NvbnRlbnQubGVuZ3RoLCAwKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRoaXMuY2xvc2UoZGVzdEZkKTtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpcy5jbG9zZShzcmNGZCk7XG4gICAgfVxuICB9KTtcbn07XG5cbi8qKlxuICogV3JpdGUgdG8gYSBmaWxlIGRlc2NyaXB0b3IgZ2l2ZW4gYSBidWZmZXIuXG4gKiBAcGFyYW0ge3N0cmluZ30gZmQgRmlsZSBkZXNjcmlwdG9yLlxuICogQHBhcmFtIHtBcnJheTxCdWZmZXI+fSBidWZmZXJzIEFycmF5IG9mIGJ1ZmZlcnMgd2l0aCBjb250ZW50cyB0byB3cml0ZS5cbiAqIEBwYXJhbSB7P251bWJlcn0gcG9zaXRpb24gV2hlcmUgdG8gYmVnaW4gd3JpdGluZyBpbiB0aGUgZmlsZS4gIElmIG51bGwsXG4gKiAgICAgZGF0YSB3aWxsIGJlIHdyaXR0ZW4gdG8gdGhlIGN1cnJlbnQgZmlsZSBwb3NpdGlvbi5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IsIG51bWJlciwgQnVmZmVyKX0gY2FsbGJhY2sgQ2FsbGJhY2sgKG9wdGlvbmFsKSBjYWxsZWRcbiAqICAgICB3aXRoIGFueSBlcnJvciwgbnVtYmVyIG9mIGJ5dGVzIHdyaXR0ZW4sIGFuZCB0aGUgYnVmZmVyLlxuICogQHBhcmFtIHtPYmplY3R9IGN0eCBDb250ZXh0IG9iamVjdCAob3B0aW9uYWwpLCBvbmx5IGZvciBub2RlanMgdjEwKy5cbiAqIEByZXR1cm4ge251bWJlcn0gTnVtYmVyIG9mIGJ5dGVzIHdyaXR0ZW4gKGlmIHN5bmMpLlxuICovXG5CaW5kaW5nLnByb3RvdHlwZS53cml0ZUJ1ZmZlcnMgPSBmdW5jdGlvbihcbiAgZmQsXG4gIGJ1ZmZlcnMsXG4gIHBvc2l0aW9uLFxuICBjYWxsYmFjayxcbiAgY3R4XG4pIHtcbiAgbWFya1N5c2NhbGwoY3R4LCAnd3JpdGUnKTtcblxuICByZXR1cm4gbWF5YmVDYWxsYmFjayhub3JtYWxpemVDYWxsYmFjayhjYWxsYmFjayksIGN0eCwgdGhpcywgZnVuY3Rpb24oKSB7XG4gICAgY29uc3QgZGVzY3JpcHRvciA9IHRoaXMuZ2V0RGVzY3JpcHRvckJ5SWQoZmQpO1xuICAgIGlmICghZGVzY3JpcHRvci5pc1dyaXRlKCkpIHtcbiAgICAgIHRocm93IG5ldyBGU0Vycm9yKCdFQkFERicpO1xuICAgIH1cbiAgICBjb25zdCBmaWxlID0gZGVzY3JpcHRvci5nZXRJdGVtKCk7XG4gICAgaWYgKCEoZmlsZSBpbnN0YW5jZW9mIEZpbGUpKSB7XG4gICAgICAvLyBub3QgYSByZWd1bGFyIGZpbGVcbiAgICAgIHRocm93IG5ldyBGU0Vycm9yKCdFQkFERicpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHBvc2l0aW9uICE9PSAnbnVtYmVyJyB8fCBwb3NpdGlvbiA8IDApIHtcbiAgICAgIHBvc2l0aW9uID0gZGVzY3JpcHRvci5nZXRQb3NpdGlvbigpO1xuICAgIH1cbiAgICBsZXQgY29udGVudCA9IGZpbGUuZ2V0Q29udGVudCgpO1xuICAgIGNvbnN0IG5ld0NvbnRlbnQgPSBCdWZmZXIuY29uY2F0KGJ1ZmZlcnMpO1xuICAgIGNvbnN0IG5ld0xlbmd0aCA9IHBvc2l0aW9uICsgbmV3Q29udGVudC5sZW5ndGg7XG4gICAgaWYgKGNvbnRlbnQubGVuZ3RoIDwgbmV3TGVuZ3RoKSB7XG4gICAgICBjb25zdCB0ZW1wQ29udGVudCA9IGJ1ZmZlckFsbG9jKG5ld0xlbmd0aCk7XG4gICAgICBjb250ZW50LmNvcHkodGVtcENvbnRlbnQpO1xuICAgICAgY29udGVudCA9IHRlbXBDb250ZW50O1xuICAgIH1cbiAgICBjb25zdCB3cml0dGVuID0gbmV3Q29udGVudC5jb3B5KGNvbnRlbnQsIHBvc2l0aW9uKTtcbiAgICBmaWxlLnNldENvbnRlbnQoY29udGVudCk7XG4gICAgZGVzY3JpcHRvci5zZXRQb3NpdGlvbihuZXdMZW5ndGgpO1xuICAgIHJldHVybiB3cml0dGVuO1xuICB9KTtcbn07XG5cbi8qKlxuICogV3JpdGUgdG8gYSBmaWxlIGRlc2NyaXB0b3IgZ2l2ZW4gYSBidWZmZXIuXG4gKiBAcGFyYW0ge3N0cmluZ30gZmQgRmlsZSBkZXNjcmlwdG9yLlxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZmZlciBCdWZmZXIgd2l0aCBjb250ZW50cyB0byB3cml0ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0IGluIHRoZSBidWZmZXIgdG8gc3RhcnQgd3JpdGluZyBmcm9tLlxuICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aCBOdW1iZXIgb2YgYnl0ZXMgdG8gd3JpdGUuXG4gKiBAcGFyYW0gez9udW1iZXJ9IHBvc2l0aW9uIFdoZXJlIHRvIGJlZ2luIHdyaXRpbmcgaW4gdGhlIGZpbGUuICBJZiBudWxsLFxuICogICAgIGRhdGEgd2lsbCBiZSB3cml0dGVuIHRvIHRoZSBjdXJyZW50IGZpbGUgcG9zaXRpb24uXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yLCBudW1iZXIsIEJ1ZmZlcil9IGNhbGxiYWNrIENhbGxiYWNrIChvcHRpb25hbCkgY2FsbGVkXG4gKiAgICAgd2l0aCBhbnkgZXJyb3IsIG51bWJlciBvZiBieXRlcyB3cml0dGVuLCBhbmQgdGhlIGJ1ZmZlci5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjdHggQ29udGV4dCBvYmplY3QgKG9wdGlvbmFsKSwgb25seSBmb3Igbm9kZWpzIHYxMCsuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IE51bWJlciBvZiBieXRlcyB3cml0dGVuIChpZiBzeW5jKS5cbiAqL1xuQmluZGluZy5wcm90b3R5cGUud3JpdGVCdWZmZXIgPSBmdW5jdGlvbihcbiAgZmQsXG4gIGJ1ZmZlcixcbiAgb2Zmc2V0LFxuICBsZW5ndGgsXG4gIHBvc2l0aW9uLFxuICBjYWxsYmFjayxcbiAgY3R4XG4pIHtcbiAgbWFya1N5c2NhbGwoY3R4LCAnd3JpdGUnKTtcblxuICByZXR1cm4gbWF5YmVDYWxsYmFjayhub3JtYWxpemVDYWxsYmFjayhjYWxsYmFjayksIGN0eCwgdGhpcywgZnVuY3Rpb24oKSB7XG4gICAgY29uc3QgZGVzY3JpcHRvciA9IHRoaXMuZ2V0RGVzY3JpcHRvckJ5SWQoZmQpO1xuICAgIGlmICghZGVzY3JpcHRvci5pc1dyaXRlKCkpIHtcbiAgICAgIHRocm93IG5ldyBGU0Vycm9yKCdFQkFERicpO1xuICAgIH1cbiAgICBjb25zdCBmaWxlID0gZGVzY3JpcHRvci5nZXRJdGVtKCk7XG4gICAgaWYgKCEoZmlsZSBpbnN0YW5jZW9mIEZpbGUpKSB7XG4gICAgICAvLyBub3QgYSByZWd1bGFyIGZpbGVcbiAgICAgIHRocm93IG5ldyBGU0Vycm9yKCdFQkFERicpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHBvc2l0aW9uICE9PSAnbnVtYmVyJyB8fCBwb3NpdGlvbiA8IDApIHtcbiAgICAgIHBvc2l0aW9uID0gZGVzY3JpcHRvci5nZXRQb3NpdGlvbigpO1xuICAgIH1cbiAgICBsZXQgY29udGVudCA9IGZpbGUuZ2V0Q29udGVudCgpO1xuICAgIGNvbnN0IG5ld0xlbmd0aCA9IHBvc2l0aW9uICsgbGVuZ3RoO1xuICAgIGlmIChjb250ZW50Lmxlbmd0aCA8IG5ld0xlbmd0aCkge1xuICAgICAgY29uc3QgbmV3Q29udGVudCA9IGJ1ZmZlckFsbG9jKG5ld0xlbmd0aCk7XG4gICAgICBjb250ZW50LmNvcHkobmV3Q29udGVudCk7XG4gICAgICBjb250ZW50ID0gbmV3Q29udGVudDtcbiAgICB9XG4gICAgY29uc3Qgc291cmNlRW5kID0gTWF0aC5taW4ob2Zmc2V0ICsgbGVuZ3RoLCBidWZmZXIubGVuZ3RoKTtcbiAgICBjb25zdCB3cml0dGVuID0gYnVmZmVyRnJvbShidWZmZXIpLmNvcHkoXG4gICAgICBjb250ZW50LFxuICAgICAgcG9zaXRpb24sXG4gICAgICBvZmZzZXQsXG4gICAgICBzb3VyY2VFbmRcbiAgICApO1xuICAgIGZpbGUuc2V0Q29udGVudChjb250ZW50KTtcbiAgICBkZXNjcmlwdG9yLnNldFBvc2l0aW9uKG5ld0xlbmd0aCk7XG4gICAgcmV0dXJuIHdyaXR0ZW47XG4gIH0pO1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Igd3JpdGVCdWZmZXIgKHVzZWQgaW4gTm9kZSA8PSAwLjEwKS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBmZCBGaWxlIGRlc2NyaXB0b3IuXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnVmZmVyIEJ1ZmZlciB3aXRoIGNvbnRlbnRzIHRvIHdyaXRlLlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQgaW4gdGhlIGJ1ZmZlciB0byBzdGFydCB3cml0aW5nIGZyb20uXG4gKiBAcGFyYW0ge251bWJlcn0gbGVuZ3RoIE51bWJlciBvZiBieXRlcyB0byB3cml0ZS5cbiAqIEBwYXJhbSB7P251bWJlcn0gcG9zaXRpb24gV2hlcmUgdG8gYmVnaW4gd3JpdGluZyBpbiB0aGUgZmlsZS4gIElmIG51bGwsXG4gKiAgICAgZGF0YSB3aWxsIGJlIHdyaXR0ZW4gdG8gdGhlIGN1cnJlbnQgZmlsZSBwb3NpdGlvbi5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IsIG51bWJlciwgQnVmZmVyKX0gY2FsbGJhY2sgQ2FsbGJhY2sgKG9wdGlvbmFsKSBjYWxsZWRcbiAqICAgICB3aXRoIGFueSBlcnJvciwgbnVtYmVyIG9mIGJ5dGVzIHdyaXR0ZW4sIGFuZCB0aGUgYnVmZmVyLlxuICogQHBhcmFtIHtPYmplY3R9IGN0eCBDb250ZXh0IG9iamVjdCAob3B0aW9uYWwpLCBvbmx5IGZvciBub2RlanMgdjEwKy5cbiAqIEByZXR1cm4ge251bWJlcn0gTnVtYmVyIG9mIGJ5dGVzIHdyaXR0ZW4gKGlmIHN5bmMpLlxuICovXG5CaW5kaW5nLnByb3RvdHlwZS53cml0ZSA9IEJpbmRpbmcucHJvdG90eXBlLndyaXRlQnVmZmVyO1xuXG4vKipcbiAqIFdyaXRlIHRvIGEgZmlsZSBkZXNjcmlwdG9yIGdpdmVuIGEgc3RyaW5nLlxuICogQHBhcmFtIHtzdHJpbmd9IGZkIEZpbGUgZGVzY3JpcHRvci5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgU3RyaW5nIHdpdGggY29udGVudHMgdG8gd3JpdGUuXG4gKiBAcGFyYW0ge251bWJlcn0gcG9zaXRpb24gV2hlcmUgdG8gYmVnaW4gd3JpdGluZyBpbiB0aGUgZmlsZS4gIElmIG51bGwsXG4gKiAgICAgZGF0YSB3aWxsIGJlIHdyaXR0ZW4gdG8gdGhlIGN1cnJlbnQgZmlsZSBwb3NpdGlvbi5cbiAqIEBwYXJhbSB7c3RyaW5nfSBlbmNvZGluZyBTdHJpbmcgZW5jb2RpbmcuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yLCBudW1iZXIsIHN0cmluZyl9IGNhbGxiYWNrIENhbGxiYWNrIChvcHRpb25hbCkgY2FsbGVkXG4gKiAgICAgd2l0aCBhbnkgZXJyb3IsIG51bWJlciBvZiBieXRlcyB3cml0dGVuLCBhbmQgdGhlIHN0cmluZy5cbiAqIEByZXR1cm4ge251bWJlcn0gTnVtYmVyIG9mIGJ5dGVzIHdyaXR0ZW4gKGlmIHN5bmMpLlxuICovXG5CaW5kaW5nLnByb3RvdHlwZS53cml0ZVN0cmluZyA9IGZ1bmN0aW9uKFxuICBmZCxcbiAgc3RyaW5nLFxuICBwb3NpdGlvbixcbiAgZW5jb2RpbmcsXG4gIGNhbGxiYWNrLFxuICBjdHhcbikge1xuICBtYXJrU3lzY2FsbChjdHgsICd3cml0ZScpO1xuXG4gIGNvbnN0IGJ1ZmZlciA9IGJ1ZmZlckZyb20oc3RyaW5nLCBlbmNvZGluZyk7XG4gIGxldCB3cmFwcGVyO1xuICBpZiAoY2FsbGJhY2sgJiYgY2FsbGJhY2sgIT09IGtVc2VQcm9taXNlcykge1xuICAgIGlmIChjYWxsYmFjay5vbmNvbXBsZXRlKSB7XG4gICAgICBjYWxsYmFjayA9IGNhbGxiYWNrLm9uY29tcGxldGUuYmluZChjYWxsYmFjayk7XG4gICAgfVxuICAgIHdyYXBwZXIgPSBmdW5jdGlvbihlcnIsIHdyaXR0ZW4sIHJldHVybmVkKSB7XG4gICAgICBjYWxsYmFjayhlcnIsIHdyaXR0ZW4sIHJldHVybmVkICYmIHN0cmluZyk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gdGhpcy53cml0ZUJ1ZmZlcihmZCwgYnVmZmVyLCAwLCBzdHJpbmcubGVuZ3RoLCBwb3NpdGlvbiwgd3JhcHBlciwgY3R4KTtcbn07XG5cbi8qKlxuICogUmVuYW1lIGEgZmlsZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBvbGRQYXRoIE9sZCBwYXRobmFtZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBuZXdQYXRoIE5ldyBwYXRobmFtZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IpfSBjYWxsYmFjayBDYWxsYmFjayAob3B0aW9uYWwpLlxuICogQHBhcmFtIHtPYmplY3R9IGN0eCBDb250ZXh0IG9iamVjdCAob3B0aW9uYWwpLCBvbmx5IGZvciBub2RlanMgdjEwKy5cbiAqIEByZXR1cm4ge3VuZGVmaW5lZH1cbiAqL1xuQmluZGluZy5wcm90b3R5cGUucmVuYW1lID0gZnVuY3Rpb24ob2xkUGF0aCwgbmV3UGF0aCwgY2FsbGJhY2ssIGN0eCkge1xuICBtYXJrU3lzY2FsbChjdHgsICdyZW5hbWUnKTtcblxuICByZXR1cm4gbWF5YmVDYWxsYmFjayhub3JtYWxpemVDYWxsYmFjayhjYWxsYmFjayksIGN0eCwgdGhpcywgZnVuY3Rpb24oKSB7XG4gICAgb2xkUGF0aCA9IGRlQnVmZmVyKG9sZFBhdGgpO1xuICAgIG5ld1BhdGggPSBkZUJ1ZmZlcihuZXdQYXRoKTtcbiAgICBjb25zdCBvbGRJdGVtID0gdGhpcy5fc3lzdGVtLmdldEl0ZW0ob2xkUGF0aCk7XG4gICAgaWYgKCFvbGRJdGVtKSB7XG4gICAgICB0aHJvdyBuZXcgRlNFcnJvcignRU5PRU5UJywgb2xkUGF0aCk7XG4gICAgfVxuICAgIGNvbnN0IG9sZFBhcmVudCA9IHRoaXMuX3N5c3RlbS5nZXRJdGVtKHBhdGguZGlybmFtZShvbGRQYXRoKSk7XG4gICAgY29uc3Qgb2xkTmFtZSA9IHBhdGguYmFzZW5hbWUob2xkUGF0aCk7XG4gICAgY29uc3QgbmV3SXRlbSA9IHRoaXMuX3N5c3RlbS5nZXRJdGVtKG5ld1BhdGgpO1xuICAgIGNvbnN0IG5ld1BhcmVudCA9IHRoaXMuX3N5c3RlbS5nZXRJdGVtKHBhdGguZGlybmFtZShuZXdQYXRoKSk7XG4gICAgY29uc3QgbmV3TmFtZSA9IHBhdGguYmFzZW5hbWUobmV3UGF0aCk7XG4gICAgaWYgKG5ld0l0ZW0pIHtcbiAgICAgIC8vIG1ha2Ugc3VyZSB0aGV5IGFyZSB0aGUgc2FtZSB0eXBlXG4gICAgICBpZiAob2xkSXRlbSBpbnN0YW5jZW9mIEZpbGUpIHtcbiAgICAgICAgaWYgKG5ld0l0ZW0gaW5zdGFuY2VvZiBEaXJlY3RvcnkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlNFcnJvcignRUlTRElSJywgbmV3UGF0aCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAob2xkSXRlbSBpbnN0YW5jZW9mIERpcmVjdG9yeSkge1xuICAgICAgICBpZiAoIShuZXdJdGVtIGluc3RhbmNlb2YgRGlyZWN0b3J5KSkge1xuICAgICAgICAgIHRocm93IG5ldyBGU0Vycm9yKCdFTk9URElSJywgbmV3UGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5ld0l0ZW0ubGlzdCgpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlNFcnJvcignRU5PVEVNUFRZJywgbmV3UGF0aCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG5ld1BhcmVudC5yZW1vdmVJdGVtKG5ld05hbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIW5ld1BhcmVudCkge1xuICAgICAgICB0aHJvdyBuZXcgRlNFcnJvcignRU5PRU5UJywgbmV3UGF0aCk7XG4gICAgICB9XG4gICAgICBpZiAoIShuZXdQYXJlbnQgaW5zdGFuY2VvZiBEaXJlY3RvcnkpKSB7XG4gICAgICAgIHRocm93IG5ldyBGU0Vycm9yKCdFTk9URElSJywgbmV3UGF0aCk7XG4gICAgICB9XG4gICAgfVxuICAgIG9sZFBhcmVudC5yZW1vdmVJdGVtKG9sZE5hbWUpO1xuICAgIG5ld1BhcmVudC5hZGRJdGVtKG5ld05hbWUsIG9sZEl0ZW0pO1xuICB9KTtcbn07XG5cbi8qKlxuICogUmVhZCBhIGRpcmVjdG9yeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXJwYXRoIFBhdGggdG8gZGlyZWN0b3J5LlxuICogQHBhcmFtIHtzdHJpbmd9IGVuY29kaW5nIFRoZSBlbmNvZGluZyAoJ3V0Zi04JyBvciAnYnVmZmVyJykuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHdpdGhGaWxlVHlwZXMgd2hldGhlciBvciBub3QgdG8gcmV0dXJuIGZzLkRpcmVudCBvYmplY3RzXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yLCAoQXJyYXkuPHN0cmluZz58QXJyYXkuPEJ1ZmZlcj4pfSBjYWxsYmFjayBDYWxsYmFja1xuICogICAgIChvcHRpb25hbCkgY2FsbGVkIHdpdGggYW55IGVycm9yIG9yIGFycmF5IG9mIGl0ZW1zIGluIHRoZSBkaXJlY3RvcnkuXG4gKiBAcGFyYW0ge09iamVjdH0gY3R4IENvbnRleHQgb2JqZWN0IChvcHRpb25hbCksIG9ubHkgZm9yIG5vZGVqcyB2MTArLlxuICogQHJldHVybiB7QXJyYXkuPHN0cmluZz58QXJyYXkuPEJ1ZmZlcj59IEFycmF5IG9mIGl0ZW1zIGluIGRpcmVjdG9yeSAoaWYgc3luYykuXG4gKi9cbkJpbmRpbmcucHJvdG90eXBlLnJlYWRkaXIgPSBmdW5jdGlvbihcbiAgZGlycGF0aCxcbiAgZW5jb2RpbmcsXG4gIHdpdGhGaWxlVHlwZXMsXG4gIGNhbGxiYWNrLFxuICBjdHhcbikge1xuICAvLyBhZ2FpbiwgdGhlIHNob3J0ZXIgYXJndW1lbnRzIHdvdWxkIG5vdCBoYXBwZW4gaW4gbm9kZWpzIHYxMCtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICBjYWxsYmFjayA9IGVuY29kaW5nO1xuICAgIGVuY29kaW5nID0gJ3V0Zi04JztcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgY2FsbGJhY2sgPSB3aXRoRmlsZVR5cGVzO1xuICB9XG5cbiAgbWFya1N5c2NhbGwoY3R4LCAnc2NhbmRpcicpO1xuXG4gIHJldHVybiBtYXliZUNhbGxiYWNrKG5vcm1hbGl6ZUNhbGxiYWNrKGNhbGxiYWNrKSwgY3R4LCB0aGlzLCBmdW5jdGlvbigpIHtcbiAgICBkaXJwYXRoID0gZGVCdWZmZXIoZGlycGF0aCk7XG4gICAgbGV0IGRwYXRoID0gZGlycGF0aDtcbiAgICBsZXQgZGlyID0gdGhpcy5fc3lzdGVtLmdldEl0ZW0oZGlycGF0aCk7XG4gICAgd2hpbGUgKGRpciBpbnN0YW5jZW9mIFN5bWJvbGljTGluaykge1xuICAgICAgZHBhdGggPSBwYXRoLnJlc29sdmUocGF0aC5kaXJuYW1lKGRwYXRoKSwgZGlyLmdldFBhdGgoKSk7XG4gICAgICBkaXIgPSB0aGlzLl9zeXN0ZW0uZ2V0SXRlbShkcGF0aCk7XG4gICAgfVxuICAgIGlmICghZGlyKSB7XG4gICAgICB0aHJvdyBuZXcgRlNFcnJvcignRU5PRU5UJywgZGlycGF0aCk7XG4gICAgfVxuICAgIGlmICghKGRpciBpbnN0YW5jZW9mIERpcmVjdG9yeSkpIHtcbiAgICAgIHRocm93IG5ldyBGU0Vycm9yKCdFTk9URElSJywgZGlycGF0aCk7XG4gICAgfVxuICAgIGlmICghZGlyLmNhblJlYWQoKSkge1xuICAgICAgdGhyb3cgbmV3IEZTRXJyb3IoJ0VBQ0NFUycsIGRpcnBhdGgpO1xuICAgIH1cblxuICAgIGxldCBsaXN0ID0gZGlyLmxpc3QoKTtcbiAgICBpZiAoZW5jb2RpbmcgPT09ICdidWZmZXInKSB7XG4gICAgICBsaXN0ID0gbGlzdC5tYXAoZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICByZXR1cm4gYnVmZmVyRnJvbShpdGVtKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmICh3aXRoRmlsZVR5cGVzID09PSB0cnVlKSB7XG4gICAgICBjb25zdCB0eXBlcyA9IGxpc3QubWFwKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgY29uc3Qgc3RhdHMgPSBkaXIuZ2V0SXRlbShuYW1lKS5nZXRTdGF0cygpO1xuXG4gICAgICAgIHJldHVybiBnZXREaXJlbnRUeXBlKHN0YXRzLm1vZGUpO1xuICAgICAgfSk7XG4gICAgICBsaXN0ID0gW2xpc3QsIHR5cGVzXTtcbiAgICB9XG5cbiAgICByZXR1cm4gbGlzdDtcbiAgfSk7XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhIGRpcmVjdG9yeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRobmFtZSBQYXRoIHRvIG5ldyBkaXJlY3RvcnkuXG4gKiBAcGFyYW0ge251bWJlcn0gbW9kZSBQZXJtaXNzaW9ucy5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gcmVjdXJzaXZlIFJlY3Vyc2l2ZWx5IGNyZWF0ZSBkZWVwIGRpcmVjdG9yeS4gKGFkZGVkIGluIG5vZGVqcyB2MTArKVxuICogQHBhcmFtIHtmdW5jdGlvbihFcnJvcil9IGNhbGxiYWNrIE9wdGlvbmFsIGNhbGxiYWNrLlxuICogQHBhcmFtIHtPYmplY3R9IGN0eCBDb250ZXh0IG9iamVjdCAob3B0aW9uYWwpLCBvbmx5IGZvciBub2RlanMgdjEwKy5cbiAqL1xuQmluZGluZy5wcm90b3R5cGUubWtkaXIgPSBmdW5jdGlvbihwYXRobmFtZSwgbW9kZSwgcmVjdXJzaXZlLCBjYWxsYmFjaywgY3R4KSB7XG4gIGlmICh0eXBlb2YgcmVjdXJzaXZlICE9PSAnYm9vbGVhbicpIHtcbiAgICAvLyB3aGVuIHJ1bm5pbmcgbm9kZWpzIDwgMTBcbiAgICBjdHggPSBjYWxsYmFjaztcbiAgICBjYWxsYmFjayA9IHJlY3Vyc2l2ZTtcbiAgICByZWN1cnNpdmUgPSBmYWxzZTtcbiAgfVxuXG4gIG1hcmtTeXNjYWxsKGN0eCwgJ21rZGlyJyk7XG5cbiAgcmV0dXJuIG1heWJlQ2FsbGJhY2sobm9ybWFsaXplQ2FsbGJhY2soY2FsbGJhY2spLCBjdHgsIHRoaXMsIGZ1bmN0aW9uKCkge1xuICAgIHBhdGhuYW1lID0gZGVCdWZmZXIocGF0aG5hbWUpO1xuICAgIGNvbnN0IGl0ZW0gPSB0aGlzLl9zeXN0ZW0uZ2V0SXRlbShwYXRobmFtZSk7XG4gICAgaWYgKGl0ZW0pIHtcbiAgICAgIGlmIChyZWN1cnNpdmUgJiYgaXRlbSBpbnN0YW5jZW9mIERpcmVjdG9yeSkge1xuICAgICAgICAvLyBzaWxlbnRseSBwYXNzIGV4aXN0aW5nIGZvbGRlciBpbiByZWN1cnNpdmUgbW9kZVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgRlNFcnJvcignRUVYSVNUJywgcGF0aG5hbWUpO1xuICAgIH1cblxuICAgIGNvbnN0IF9ta2RpciA9IGZ1bmN0aW9uKF9wYXRobmFtZSkge1xuICAgICAgY29uc3QgcGFyZW50RGlyID0gcGF0aC5kaXJuYW1lKF9wYXRobmFtZSk7XG4gICAgICBsZXQgcGFyZW50ID0gdGhpcy5fc3lzdGVtLmdldEl0ZW0ocGFyZW50RGlyKTtcbiAgICAgIGlmICghcGFyZW50KSB7XG4gICAgICAgIGlmICghcmVjdXJzaXZlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTRXJyb3IoJ0VOT0VOVCcsIF9wYXRobmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgcGFyZW50ID0gX21rZGlyKHBhcmVudERpciwgdHJ1ZSk7XG4gICAgICB9XG4gICAgICB0aGlzLmFjY2VzcyhwYXJlbnREaXIsIHBhcnNlSW50KCcwMDAyJywgOCkpO1xuICAgICAgY29uc3QgZGlyID0gbmV3IERpcmVjdG9yeSgpO1xuICAgICAgaWYgKG1vZGUpIHtcbiAgICAgICAgZGlyLnNldE1vZGUobW9kZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcGFyZW50LmFkZEl0ZW0ocGF0aC5iYXNlbmFtZShfcGF0aG5hbWUpLCBkaXIpO1xuICAgIH0uYmluZCh0aGlzKTtcblxuICAgIF9ta2RpcihwYXRobmFtZSk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgYSBkaXJlY3RvcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aG5hbWUgUGF0aCB0byBkaXJlY3RvcnkuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yKX0gY2FsbGJhY2sgT3B0aW9uYWwgY2FsbGJhY2suXG4gKiBAcGFyYW0ge09iamVjdH0gY3R4IENvbnRleHQgb2JqZWN0IChvcHRpb25hbCksIG9ubHkgZm9yIG5vZGVqcyB2MTArLlxuICovXG5CaW5kaW5nLnByb3RvdHlwZS5ybWRpciA9IGZ1bmN0aW9uKHBhdGhuYW1lLCBjYWxsYmFjaywgY3R4KSB7XG4gIG1hcmtTeXNjYWxsKGN0eCwgJ3JtZGlyJyk7XG5cbiAgcmV0dXJuIG1heWJlQ2FsbGJhY2sobm9ybWFsaXplQ2FsbGJhY2soY2FsbGJhY2spLCBjdHgsIHRoaXMsIGZ1bmN0aW9uKCkge1xuICAgIHBhdGhuYW1lID0gZGVCdWZmZXIocGF0aG5hbWUpO1xuICAgIGNvbnN0IGl0ZW0gPSB0aGlzLl9zeXN0ZW0uZ2V0SXRlbShwYXRobmFtZSk7XG4gICAgaWYgKCFpdGVtKSB7XG4gICAgICB0aHJvdyBuZXcgRlNFcnJvcignRU5PRU5UJywgcGF0aG5hbWUpO1xuICAgIH1cbiAgICBpZiAoIShpdGVtIGluc3RhbmNlb2YgRGlyZWN0b3J5KSkge1xuICAgICAgdGhyb3cgbmV3IEZTRXJyb3IoJ0VOT1RESVInLCBwYXRobmFtZSk7XG4gICAgfVxuICAgIGlmIChpdGVtLmxpc3QoKS5sZW5ndGggPiAwKSB7XG4gICAgICB0aHJvdyBuZXcgRlNFcnJvcignRU5PVEVNUFRZJywgcGF0aG5hbWUpO1xuICAgIH1cbiAgICB0aGlzLmFjY2VzcyhwYXRoLmRpcm5hbWUocGF0aG5hbWUpLCBwYXJzZUludCgnMDAwMicsIDgpKTtcbiAgICBjb25zdCBwYXJlbnQgPSB0aGlzLl9zeXN0ZW0uZ2V0SXRlbShwYXRoLmRpcm5hbWUocGF0aG5hbWUpKTtcbiAgICBwYXJlbnQucmVtb3ZlSXRlbShwYXRoLmJhc2VuYW1lKHBhdGhuYW1lKSk7XG4gIH0pO1xufTtcblxuY29uc3QgUEFUSF9DSEFSUyA9XG4gICdhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ekFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaMDEyMzQ1Njc4OSc7XG5cbmNvbnN0IE1BWF9BVFRFTVBUUyA9IDYyICogNjIgKiA2MjtcblxuLyoqXG4gKiBDcmVhdGUgYSBkaXJlY3RvcnkgYmFzZWQgb24gYSB0ZW1wbGF0ZS5cbiAqIFNlZSBodHRwOi8vd2ViLm1pdC5lZHUvZnJlZWJzZC9oZWFkL2xpYi9saWJjL3N0ZGlvL21rdGVtcC5jXG4gKiBAcGFyYW0ge3N0cmluZ30gdGVtcGxhdGUgUGF0aCB0ZW1wbGF0ZSAodHJhaWxpbmcgWHMgd2lsbCBiZSByZXBsYWNlZCkuXG4gKiBAcGFyYW0ge3N0cmluZ30gZW5jb2RpbmcgVGhlIGVuY29kaW5nICgndXRmLTgnIG9yICdidWZmZXInKS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IsIHN0cmluZyl9IGNhbGxiYWNrIE9wdGlvbmFsIGNhbGxiYWNrLlxuICogQHBhcmFtIHtPYmplY3R9IGN0eCBDb250ZXh0IG9iamVjdCAob3B0aW9uYWwpLCBvbmx5IGZvciBub2RlanMgdjEwKy5cbiAqL1xuQmluZGluZy5wcm90b3R5cGUubWtkdGVtcCA9IGZ1bmN0aW9uKHByZWZpeCwgZW5jb2RpbmcsIGNhbGxiYWNrLCBjdHgpIHtcbiAgaWYgKGVuY29kaW5nICYmIHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycpIHtcbiAgICBjYWxsYmFjayA9IGVuY29kaW5nO1xuICAgIGVuY29kaW5nID0gJ3V0Zi04JztcbiAgfVxuXG4gIG1hcmtTeXNjYWxsKGN0eCwgJ21rZHRlbXAnKTtcblxuICByZXR1cm4gbWF5YmVDYWxsYmFjayhub3JtYWxpemVDYWxsYmFjayhjYWxsYmFjayksIGN0eCwgdGhpcywgZnVuY3Rpb24oKSB7XG4gICAgcHJlZml4ID0gcHJlZml4LnJlcGxhY2UoL1h7MCw2fSQvLCAnWFhYWFhYJyk7XG4gICAgY29uc3QgcGFyZW50UGF0aCA9IHBhdGguZGlybmFtZShwcmVmaXgpO1xuICAgIGNvbnN0IHBhcmVudCA9IHRoaXMuX3N5c3RlbS5nZXRJdGVtKHBhcmVudFBhdGgpO1xuICAgIGlmICghcGFyZW50KSB7XG4gICAgICB0aHJvdyBuZXcgRlNFcnJvcignRU5PRU5UJywgcHJlZml4KTtcbiAgICB9XG4gICAgaWYgKCEocGFyZW50IGluc3RhbmNlb2YgRGlyZWN0b3J5KSkge1xuICAgICAgdGhyb3cgbmV3IEZTRXJyb3IoJ0VOT1RESVInLCBwcmVmaXgpO1xuICAgIH1cbiAgICB0aGlzLmFjY2VzcyhwYXJlbnRQYXRoLCBwYXJzZUludCgnMDAwMicsIDgpKTtcbiAgICBjb25zdCB0ZW1wbGF0ZSA9IHBhdGguYmFzZW5hbWUocHJlZml4KTtcbiAgICBsZXQgdW5pcXVlID0gZmFsc2U7XG4gICAgbGV0IGNvdW50ID0gMDtcbiAgICBsZXQgbmFtZTtcbiAgICB3aGlsZSAoIXVuaXF1ZSAmJiBjb3VudCA8IE1BWF9BVFRFTVBUUykge1xuICAgICAgbGV0IHBvc2l0aW9uID0gdGVtcGxhdGUubGVuZ3RoIC0gMTtcbiAgICAgIGxldCByZXBsYWNlbWVudCA9ICcnO1xuICAgICAgd2hpbGUgKHRlbXBsYXRlLmNoYXJBdChwb3NpdGlvbikgPT09ICdYJykge1xuICAgICAgICByZXBsYWNlbWVudCArPSBQQVRIX0NIQVJTLmNoYXJBdChcbiAgICAgICAgICBNYXRoLmZsb29yKFBBVEhfQ0hBUlMubGVuZ3RoICogTWF0aC5yYW5kb20oKSlcbiAgICAgICAgKTtcbiAgICAgICAgcG9zaXRpb24gLT0gMTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHRlbXBsYXRlLnNsaWNlKDAsIHBvc2l0aW9uICsgMSkgKyByZXBsYWNlbWVudDtcbiAgICAgIGlmICghcGFyZW50LmdldEl0ZW0oY2FuZGlkYXRlKSkge1xuICAgICAgICBuYW1lID0gY2FuZGlkYXRlO1xuICAgICAgICB1bmlxdWUgPSB0cnVlO1xuICAgICAgfVxuICAgICAgY291bnQgKz0gMTtcbiAgICB9XG4gICAgaWYgKCFuYW1lKSB7XG4gICAgICB0aHJvdyBuZXcgRlNFcnJvcignRUVYSVNUJywgcHJlZml4KTtcbiAgICB9XG4gICAgY29uc3QgZGlyID0gbmV3IERpcmVjdG9yeSgpO1xuICAgIHBhcmVudC5hZGRJdGVtKG5hbWUsIGRpcik7XG4gICAgbGV0IHVuaXF1ZVBhdGggPSBwYXRoLmpvaW4ocGFyZW50UGF0aCwgbmFtZSk7XG4gICAgaWYgKGVuY29kaW5nID09PSAnYnVmZmVyJykge1xuICAgICAgdW5pcXVlUGF0aCA9IGJ1ZmZlckZyb20odW5pcXVlUGF0aCk7XG4gICAgfVxuICAgIHJldHVybiB1bmlxdWVQYXRoO1xuICB9KTtcbn07XG5cbi8qKlxuICogVHJ1bmNhdGUgYSBmaWxlLlxuICogQHBhcmFtIHtudW1iZXJ9IGZkIEZpbGUgZGVzY3JpcHRvci5cbiAqIEBwYXJhbSB7bnVtYmVyfSBsZW4gTnVtYmVyIG9mIGJ5dGVzLlxuICogQHBhcmFtIHtmdW5jdGlvbihFcnJvcil9IGNhbGxiYWNrIE9wdGlvbmFsIGNhbGxiYWNrLlxuICogQHBhcmFtIHtPYmplY3R9IGN0eCBDb250ZXh0IG9iamVjdCAob3B0aW9uYWwpLCBvbmx5IGZvciBub2RlanMgdjEwKy5cbiAqL1xuQmluZGluZy5wcm90b3R5cGUuZnRydW5jYXRlID0gZnVuY3Rpb24oZmQsIGxlbiwgY2FsbGJhY2ssIGN0eCkge1xuICBtYXJrU3lzY2FsbChjdHgsICdmdHJ1bmNhdGUnKTtcblxuICByZXR1cm4gbWF5YmVDYWxsYmFjayhub3JtYWxpemVDYWxsYmFjayhjYWxsYmFjayksIGN0eCwgdGhpcywgZnVuY3Rpb24oKSB7XG4gICAgY29uc3QgZGVzY3JpcHRvciA9IHRoaXMuZ2V0RGVzY3JpcHRvckJ5SWQoZmQpO1xuICAgIGlmICghZGVzY3JpcHRvci5pc1dyaXRlKCkpIHtcbiAgICAgIHRocm93IG5ldyBGU0Vycm9yKCdFSU5WQUwnKTtcbiAgICB9XG4gICAgY29uc3QgZmlsZSA9IGRlc2NyaXB0b3IuZ2V0SXRlbSgpO1xuICAgIGlmICghKGZpbGUgaW5zdGFuY2VvZiBGaWxlKSkge1xuICAgICAgdGhyb3cgbmV3IEZTRXJyb3IoJ0VJTlZBTCcpO1xuICAgIH1cbiAgICBjb25zdCBjb250ZW50ID0gZmlsZS5nZXRDb250ZW50KCk7XG4gICAgY29uc3QgbmV3Q29udGVudCA9IGJ1ZmZlckFsbG9jKGxlbik7XG4gICAgY29udGVudC5jb3B5KG5ld0NvbnRlbnQpO1xuICAgIGZpbGUuc2V0Q29udGVudChuZXdDb250ZW50KTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIExlZ2FjeSBzdXBwb3J0LlxuICogQHBhcmFtIHtudW1iZXJ9IGZkIEZpbGUgZGVzY3JpcHRvci5cbiAqIEBwYXJhbSB7bnVtYmVyfSBsZW4gTnVtYmVyIG9mIGJ5dGVzLlxuICogQHBhcmFtIHtmdW5jdGlvbihFcnJvcil9IGNhbGxiYWNrIE9wdGlvbmFsIGNhbGxiYWNrLlxuICogQHBhcmFtIHtPYmplY3R9IGN0eCBDb250ZXh0IG9iamVjdCAob3B0aW9uYWwpLCBvbmx5IGZvciBub2RlanMgdjEwKy5cbiAqL1xuQmluZGluZy5wcm90b3R5cGUudHJ1bmNhdGUgPSBCaW5kaW5nLnByb3RvdHlwZS5mdHJ1bmNhdGU7XG5cbi8qKlxuICogQ2hhbmdlIHVzZXIgYW5kIGdyb3VwIG93bmVyLlxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGhuYW1lIFBhdGguXG4gKiBAcGFyYW0ge251bWJlcn0gdWlkIFVzZXIgaWQuXG4gKiBAcGFyYW0ge251bWJlcn0gZ2lkIEdyb3VwIGlkLlxuICogQHBhcmFtIHtmdW5jdGlvbihFcnJvcil9IGNhbGxiYWNrIE9wdGlvbmFsIGNhbGxiYWNrLlxuICogQHBhcmFtIHtPYmplY3R9IGN0eCBDb250ZXh0IG9iamVjdCAob3B0aW9uYWwpLCBvbmx5IGZvciBub2RlanMgdjEwKy5cbiAqL1xuQmluZGluZy5wcm90b3R5cGUuY2hvd24gPSBmdW5jdGlvbihwYXRobmFtZSwgdWlkLCBnaWQsIGNhbGxiYWNrLCBjdHgpIHtcbiAgbWFya1N5c2NhbGwoY3R4LCAnY2hvd24nKTtcblxuICByZXR1cm4gbWF5YmVDYWxsYmFjayhub3JtYWxpemVDYWxsYmFjayhjYWxsYmFjayksIGN0eCwgdGhpcywgZnVuY3Rpb24oKSB7XG4gICAgcGF0aG5hbWUgPSBkZUJ1ZmZlcihwYXRobmFtZSk7XG4gICAgY29uc3QgaXRlbSA9IHRoaXMuX3N5c3RlbS5nZXRJdGVtKHBhdGhuYW1lKTtcbiAgICBpZiAoIWl0ZW0pIHtcbiAgICAgIHRocm93IG5ldyBGU0Vycm9yKCdFTk9FTlQnLCBwYXRobmFtZSk7XG4gICAgfVxuICAgIGl0ZW0uc2V0VWlkKHVpZCk7XG4gICAgaXRlbS5zZXRHaWQoZ2lkKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIENoYW5nZSB1c2VyIGFuZCBncm91cCBvd25lci5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmZCBGaWxlIGRlc2NyaXB0b3IuXG4gKiBAcGFyYW0ge251bWJlcn0gdWlkIFVzZXIgaWQuXG4gKiBAcGFyYW0ge251bWJlcn0gZ2lkIEdyb3VwIGlkLlxuICogQHBhcmFtIHtmdW5jdGlvbihFcnJvcil9IGNhbGxiYWNrIE9wdGlvbmFsIGNhbGxiYWNrLlxuICogQHBhcmFtIHtPYmplY3R9IGN0eCBDb250ZXh0IG9iamVjdCAob3B0aW9uYWwpLCBvbmx5IGZvciBub2RlanMgdjEwKy5cbiAqL1xuQmluZGluZy5wcm90b3R5cGUuZmNob3duID0gZnVuY3Rpb24oZmQsIHVpZCwgZ2lkLCBjYWxsYmFjaywgY3R4KSB7XG4gIG1hcmtTeXNjYWxsKGN0eCwgJ2ZjaG93bicpO1xuXG4gIHJldHVybiBtYXliZUNhbGxiYWNrKG5vcm1hbGl6ZUNhbGxiYWNrKGNhbGxiYWNrKSwgY3R4LCB0aGlzLCBmdW5jdGlvbigpIHtcbiAgICBjb25zdCBkZXNjcmlwdG9yID0gdGhpcy5nZXREZXNjcmlwdG9yQnlJZChmZCk7XG4gICAgY29uc3QgaXRlbSA9IGRlc2NyaXB0b3IuZ2V0SXRlbSgpO1xuICAgIGl0ZW0uc2V0VWlkKHVpZCk7XG4gICAgaXRlbS5zZXRHaWQoZ2lkKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIENoYW5nZSBwZXJtaXNzaW9ucy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRobmFtZSBQYXRoLlxuICogQHBhcmFtIHtudW1iZXJ9IG1vZGUgTW9kZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IpfSBjYWxsYmFjayBPcHRpb25hbCBjYWxsYmFjay5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjdHggQ29udGV4dCBvYmplY3QgKG9wdGlvbmFsKSwgb25seSBmb3Igbm9kZWpzIHYxMCsuXG4gKi9cbkJpbmRpbmcucHJvdG90eXBlLmNobW9kID0gZnVuY3Rpb24ocGF0aG5hbWUsIG1vZGUsIGNhbGxiYWNrLCBjdHgpIHtcbiAgbWFya1N5c2NhbGwoY3R4LCAnY2htb2QnKTtcblxuICByZXR1cm4gbWF5YmVDYWxsYmFjayhub3JtYWxpemVDYWxsYmFjayhjYWxsYmFjayksIGN0eCwgdGhpcywgZnVuY3Rpb24oKSB7XG4gICAgcGF0aG5hbWUgPSBkZUJ1ZmZlcihwYXRobmFtZSk7XG4gICAgY29uc3QgaXRlbSA9IHRoaXMuX3N5c3RlbS5nZXRJdGVtKHBhdGhuYW1lKTtcbiAgICBpZiAoIWl0ZW0pIHtcbiAgICAgIHRocm93IG5ldyBGU0Vycm9yKCdFTk9FTlQnLCBwYXRobmFtZSk7XG4gICAgfVxuICAgIGl0ZW0uc2V0TW9kZShtb2RlKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIENoYW5nZSBwZXJtaXNzaW9ucy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmZCBGaWxlIGRlc2NyaXB0b3IuXG4gKiBAcGFyYW0ge251bWJlcn0gbW9kZSBNb2RlLlxuICogQHBhcmFtIHtmdW5jdGlvbihFcnJvcil9IGNhbGxiYWNrIE9wdGlvbmFsIGNhbGxiYWNrLlxuICogQHBhcmFtIHtPYmplY3R9IGN0eCBDb250ZXh0IG9iamVjdCAob3B0aW9uYWwpLCBvbmx5IGZvciBub2RlanMgdjEwKy5cbiAqL1xuQmluZGluZy5wcm90b3R5cGUuZmNobW9kID0gZnVuY3Rpb24oZmQsIG1vZGUsIGNhbGxiYWNrLCBjdHgpIHtcbiAgbWFya1N5c2NhbGwoY3R4LCAnZmNobW9kJyk7XG5cbiAgcmV0dXJuIG1heWJlQ2FsbGJhY2sobm9ybWFsaXplQ2FsbGJhY2soY2FsbGJhY2spLCBjdHgsIHRoaXMsIGZ1bmN0aW9uKCkge1xuICAgIGNvbnN0IGRlc2NyaXB0b3IgPSB0aGlzLmdldERlc2NyaXB0b3JCeUlkKGZkKTtcbiAgICBjb25zdCBpdGVtID0gZGVzY3JpcHRvci5nZXRJdGVtKCk7XG4gICAgaXRlbS5zZXRNb2RlKG1vZGUpO1xuICB9KTtcbn07XG5cbi8qKlxuICogRGVsZXRlIGEgbmFtZWQgaXRlbS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRobmFtZSBQYXRoIHRvIGl0ZW0uXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yKX0gY2FsbGJhY2sgT3B0aW9uYWwgY2FsbGJhY2suXG4gKiBAcGFyYW0ge09iamVjdH0gY3R4IENvbnRleHQgb2JqZWN0IChvcHRpb25hbCksIG9ubHkgZm9yIG5vZGVqcyB2MTArLlxuICovXG5CaW5kaW5nLnByb3RvdHlwZS51bmxpbmsgPSBmdW5jdGlvbihwYXRobmFtZSwgY2FsbGJhY2ssIGN0eCkge1xuICBtYXJrU3lzY2FsbChjdHgsICd1bmxpbmsnKTtcblxuICByZXR1cm4gbWF5YmVDYWxsYmFjayhub3JtYWxpemVDYWxsYmFjayhjYWxsYmFjayksIGN0eCwgdGhpcywgZnVuY3Rpb24oKSB7XG4gICAgcGF0aG5hbWUgPSBkZUJ1ZmZlcihwYXRobmFtZSk7XG4gICAgY29uc3QgaXRlbSA9IHRoaXMuX3N5c3RlbS5nZXRJdGVtKHBhdGhuYW1lKTtcbiAgICBpZiAoIWl0ZW0pIHtcbiAgICAgIHRocm93IG5ldyBGU0Vycm9yKCdFTk9FTlQnLCBwYXRobmFtZSk7XG4gICAgfVxuICAgIGlmIChpdGVtIGluc3RhbmNlb2YgRGlyZWN0b3J5KSB7XG4gICAgICB0aHJvdyBuZXcgRlNFcnJvcignRVBFUk0nLCBwYXRobmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IHBhcmVudCA9IHRoaXMuX3N5c3RlbS5nZXRJdGVtKHBhdGguZGlybmFtZShwYXRobmFtZSkpO1xuICAgIHBhcmVudC5yZW1vdmVJdGVtKHBhdGguYmFzZW5hbWUocGF0aG5hbWUpKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIFVwZGF0ZSB0aW1lc3RhbXBzLlxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGhuYW1lIFBhdGggdG8gaXRlbS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBhdGltZSBBY2Nlc3MgdGltZSAoaW4gc2Vjb25kcykuXG4gKiBAcGFyYW0ge251bWJlcn0gbXRpbWUgTW9kaWZpY2F0aW9uIHRpbWUgKGluIHNlY29uZHMpLlxuICogQHBhcmFtIHtmdW5jdGlvbihFcnJvcil9IGNhbGxiYWNrIE9wdGlvbmFsIGNhbGxiYWNrLlxuICogQHBhcmFtIHtPYmplY3R9IGN0eCBDb250ZXh0IG9iamVjdCAob3B0aW9uYWwpLCBvbmx5IGZvciBub2RlanMgdjEwKy5cbiAqL1xuQmluZGluZy5wcm90b3R5cGUudXRpbWVzID0gZnVuY3Rpb24ocGF0aG5hbWUsIGF0aW1lLCBtdGltZSwgY2FsbGJhY2ssIGN0eCkge1xuICBtYXJrU3lzY2FsbChjdHgsICd1dGltZXMnKTtcblxuICByZXR1cm4gbWF5YmVDYWxsYmFjayhub3JtYWxpemVDYWxsYmFjayhjYWxsYmFjayksIGN0eCwgdGhpcywgZnVuY3Rpb24oKSB7XG4gICAgcGF0aG5hbWUgPSBkZUJ1ZmZlcihwYXRobmFtZSk7XG4gICAgY29uc3QgaXRlbSA9IHRoaXMuX3N5c3RlbS5nZXRJdGVtKHBhdGhuYW1lKTtcbiAgICBpZiAoIWl0ZW0pIHtcbiAgICAgIHRocm93IG5ldyBGU0Vycm9yKCdFTk9FTlQnLCBwYXRobmFtZSk7XG4gICAgfVxuICAgIGl0ZW0uc2V0QVRpbWUobmV3IERhdGUoYXRpbWUgKiAxMDAwKSk7XG4gICAgaXRlbS5zZXRNVGltZShuZXcgRGF0ZShtdGltZSAqIDEwMDApKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIFVwZGF0ZSB0aW1lc3RhbXBzLlxuICogQHBhcmFtIHtudW1iZXJ9IGZkIEZpbGUgZGVzY3JpcHRvci5cbiAqIEBwYXJhbSB7bnVtYmVyfSBhdGltZSBBY2Nlc3MgdGltZSAoaW4gc2Vjb25kcykuXG4gKiBAcGFyYW0ge251bWJlcn0gbXRpbWUgTW9kaWZpY2F0aW9uIHRpbWUgKGluIHNlY29uZHMpLlxuICogQHBhcmFtIHtmdW5jdGlvbihFcnJvcil9IGNhbGxiYWNrIE9wdGlvbmFsIGNhbGxiYWNrLlxuICogQHBhcmFtIHtPYmplY3R9IGN0eCBDb250ZXh0IG9iamVjdCAob3B0aW9uYWwpLCBvbmx5IGZvciBub2RlanMgdjEwKy5cbiAqL1xuQmluZGluZy5wcm90b3R5cGUuZnV0aW1lcyA9IGZ1bmN0aW9uKGZkLCBhdGltZSwgbXRpbWUsIGNhbGxiYWNrLCBjdHgpIHtcbiAgbWFya1N5c2NhbGwoY3R4LCAnZnV0aW1lcycpO1xuXG4gIHJldHVybiBtYXliZUNhbGxiYWNrKG5vcm1hbGl6ZUNhbGxiYWNrKGNhbGxiYWNrKSwgY3R4LCB0aGlzLCBmdW5jdGlvbigpIHtcbiAgICBjb25zdCBkZXNjcmlwdG9yID0gdGhpcy5nZXREZXNjcmlwdG9yQnlJZChmZCk7XG4gICAgY29uc3QgaXRlbSA9IGRlc2NyaXB0b3IuZ2V0SXRlbSgpO1xuICAgIGl0ZW0uc2V0QVRpbWUobmV3IERhdGUoYXRpbWUgKiAxMDAwKSk7XG4gICAgaXRlbS5zZXRNVGltZShuZXcgRGF0ZShtdGltZSAqIDEwMDApKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIFN5bmNocm9uaXplIGluLWNvcmUgc3RhdGUgd2l0aCBzdG9yYWdlIGRldmljZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmZCBGaWxlIGRlc2NyaXB0b3IuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yKX0gY2FsbGJhY2sgT3B0aW9uYWwgY2FsbGJhY2suXG4gKiBAcGFyYW0ge09iamVjdH0gY3R4IENvbnRleHQgb2JqZWN0IChvcHRpb25hbCksIG9ubHkgZm9yIG5vZGVqcyB2MTArLlxuICovXG5CaW5kaW5nLnByb3RvdHlwZS5mc3luYyA9IGZ1bmN0aW9uKGZkLCBjYWxsYmFjaywgY3R4KSB7XG4gIG1hcmtTeXNjYWxsKGN0eCwgJ2ZzeW5jJyk7XG5cbiAgcmV0dXJuIG1heWJlQ2FsbGJhY2sobm9ybWFsaXplQ2FsbGJhY2soY2FsbGJhY2spLCBjdHgsIHRoaXMsIGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuZ2V0RGVzY3JpcHRvckJ5SWQoZmQpO1xuICB9KTtcbn07XG5cbi8qKlxuICogU3luY2hyb25pemUgaW4tY29yZSBtZXRhZGF0YSBzdGF0ZSB3aXRoIHN0b3JhZ2UgZGV2aWNlLlxuICogQHBhcmFtIHtudW1iZXJ9IGZkIEZpbGUgZGVzY3JpcHRvci5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IpfSBjYWxsYmFjayBPcHRpb25hbCBjYWxsYmFjay5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjdHggQ29udGV4dCBvYmplY3QgKG9wdGlvbmFsKSwgb25seSBmb3Igbm9kZWpzIHYxMCsuXG4gKi9cbkJpbmRpbmcucHJvdG90eXBlLmZkYXRhc3luYyA9IGZ1bmN0aW9uKGZkLCBjYWxsYmFjaywgY3R4KSB7XG4gIG1hcmtTeXNjYWxsKGN0eCwgJ2ZkYXRhc3luYycpO1xuXG4gIHJldHVybiBtYXliZUNhbGxiYWNrKG5vcm1hbGl6ZUNhbGxiYWNrKGNhbGxiYWNrKSwgY3R4LCB0aGlzLCBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmdldERlc2NyaXB0b3JCeUlkKGZkKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhIGhhcmQgbGluay5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzcmNQYXRoIFRoZSBleGlzdGluZyBmaWxlLlxuICogQHBhcmFtIHtzdHJpbmd9IGRlc3RQYXRoIFRoZSBuZXcgbGluayB0byBjcmVhdGUuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yKX0gY2FsbGJhY2sgT3B0aW9uYWwgY2FsbGJhY2suXG4gKiBAcGFyYW0ge09iamVjdH0gY3R4IENvbnRleHQgb2JqZWN0IChvcHRpb25hbCksIG9ubHkgZm9yIG5vZGVqcyB2MTArLlxuICovXG5CaW5kaW5nLnByb3RvdHlwZS5saW5rID0gZnVuY3Rpb24oc3JjUGF0aCwgZGVzdFBhdGgsIGNhbGxiYWNrLCBjdHgpIHtcbiAgbWFya1N5c2NhbGwoY3R4LCAnbGluaycpO1xuXG4gIHJldHVybiBtYXliZUNhbGxiYWNrKG5vcm1hbGl6ZUNhbGxiYWNrKGNhbGxiYWNrKSwgY3R4LCB0aGlzLCBmdW5jdGlvbigpIHtcbiAgICBzcmNQYXRoID0gZGVCdWZmZXIoc3JjUGF0aCk7XG4gICAgZGVzdFBhdGggPSBkZUJ1ZmZlcihkZXN0UGF0aCk7XG4gICAgY29uc3QgaXRlbSA9IHRoaXMuX3N5c3RlbS5nZXRJdGVtKHNyY1BhdGgpO1xuICAgIGlmICghaXRlbSkge1xuICAgICAgdGhyb3cgbmV3IEZTRXJyb3IoJ0VOT0VOVCcsIHNyY1BhdGgpO1xuICAgIH1cbiAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIERpcmVjdG9yeSkge1xuICAgICAgdGhyb3cgbmV3IEZTRXJyb3IoJ0VQRVJNJywgc3JjUGF0aCk7XG4gICAgfVxuICAgIGlmICh0aGlzLl9zeXN0ZW0uZ2V0SXRlbShkZXN0UGF0aCkpIHtcbiAgICAgIHRocm93IG5ldyBGU0Vycm9yKCdFRVhJU1QnLCBkZXN0UGF0aCk7XG4gICAgfVxuICAgIGNvbnN0IHBhcmVudCA9IHRoaXMuX3N5c3RlbS5nZXRJdGVtKHBhdGguZGlybmFtZShkZXN0UGF0aCkpO1xuICAgIGlmICghcGFyZW50KSB7XG4gICAgICB0aHJvdyBuZXcgRlNFcnJvcignRU5PRU5UJywgZGVzdFBhdGgpO1xuICAgIH1cbiAgICBpZiAoIShwYXJlbnQgaW5zdGFuY2VvZiBEaXJlY3RvcnkpKSB7XG4gICAgICB0aHJvdyBuZXcgRlNFcnJvcignRU5PVERJUicsIGRlc3RQYXRoKTtcbiAgICB9XG4gICAgcGFyZW50LmFkZEl0ZW0ocGF0aC5iYXNlbmFtZShkZXN0UGF0aCksIGl0ZW0pO1xuICB9KTtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGEgc3ltYm9saWMgbGluay5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzcmNQYXRoIFBhdGggZnJvbSBsaW5rIHRvIHRoZSBzb3VyY2UgZmlsZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkZXN0UGF0aCBQYXRoIGZvciB0aGUgZ2VuZXJhdGVkIGxpbmsuXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBJZ25vcmVkICh1c2VkIGZvciBXaW5kb3dzIG9ubHkpLlxuICogQHBhcmFtIHtmdW5jdGlvbihFcnJvcil9IGNhbGxiYWNrIE9wdGlvbmFsIGNhbGxiYWNrLlxuICogQHBhcmFtIHtPYmplY3R9IGN0eCBDb250ZXh0IG9iamVjdCAob3B0aW9uYWwpLCBvbmx5IGZvciBub2RlanMgdjEwKy5cbiAqL1xuQmluZGluZy5wcm90b3R5cGUuc3ltbGluayA9IGZ1bmN0aW9uKHNyY1BhdGgsIGRlc3RQYXRoLCB0eXBlLCBjYWxsYmFjaywgY3R4KSB7XG4gIG1hcmtTeXNjYWxsKGN0eCwgJ3N5bWxpbmsnKTtcblxuICByZXR1cm4gbWF5YmVDYWxsYmFjayhub3JtYWxpemVDYWxsYmFjayhjYWxsYmFjayksIGN0eCwgdGhpcywgZnVuY3Rpb24oKSB7XG4gICAgc3JjUGF0aCA9IGRlQnVmZmVyKHNyY1BhdGgpO1xuICAgIGRlc3RQYXRoID0gZGVCdWZmZXIoZGVzdFBhdGgpO1xuICAgIGlmICh0aGlzLl9zeXN0ZW0uZ2V0SXRlbShkZXN0UGF0aCkpIHtcbiAgICAgIHRocm93IG5ldyBGU0Vycm9yKCdFRVhJU1QnLCBkZXN0UGF0aCk7XG4gICAgfVxuICAgIGNvbnN0IHBhcmVudCA9IHRoaXMuX3N5c3RlbS5nZXRJdGVtKHBhdGguZGlybmFtZShkZXN0UGF0aCkpO1xuICAgIGlmICghcGFyZW50KSB7XG4gICAgICB0aHJvdyBuZXcgRlNFcnJvcignRU5PRU5UJywgZGVzdFBhdGgpO1xuICAgIH1cbiAgICBpZiAoIShwYXJlbnQgaW5zdGFuY2VvZiBEaXJlY3RvcnkpKSB7XG4gICAgICB0aHJvdyBuZXcgRlNFcnJvcignRU5PVERJUicsIGRlc3RQYXRoKTtcbiAgICB9XG4gICAgY29uc3QgbGluayA9IG5ldyBTeW1ib2xpY0xpbmsoKTtcbiAgICBsaW5rLnNldFBhdGgoc3JjUGF0aCk7XG4gICAgcGFyZW50LmFkZEl0ZW0ocGF0aC5iYXNlbmFtZShkZXN0UGF0aCksIGxpbmspO1xuICB9KTtcbn07XG5cbi8qKlxuICogUmVhZCB0aGUgY29udGVudHMgb2YgYSBzeW1ib2xpYyBsaW5rLlxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGhuYW1lIFBhdGggdG8gc3ltYm9saWMgbGluay5cbiAqIEBwYXJhbSB7c3RyaW5nfSBlbmNvZGluZyBUaGUgZW5jb2RpbmcgKCd1dGYtOCcgb3IgJ2J1ZmZlcicpLlxuICogQHBhcmFtIHtmdW5jdGlvbihFcnJvciwgKHN0cmluZ3xCdWZmZXIpKX0gY2FsbGJhY2sgT3B0aW9uYWwgY2FsbGJhY2suXG4gKiBAcGFyYW0ge09iamVjdH0gY3R4IENvbnRleHQgb2JqZWN0IChvcHRpb25hbCksIG9ubHkgZm9yIG5vZGVqcyB2MTArLlxuICogQHJldHVybiB7c3RyaW5nfEJ1ZmZlcn0gU3ltYm9saWMgbGluayBjb250ZW50cyAocGF0aCB0byBzb3VyY2UpLlxuICovXG5CaW5kaW5nLnByb3RvdHlwZS5yZWFkbGluayA9IGZ1bmN0aW9uKHBhdGhuYW1lLCBlbmNvZGluZywgY2FsbGJhY2ssIGN0eCkge1xuICBpZiAoZW5jb2RpbmcgJiYgdHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJykge1xuICAgIC8vIHRoaXMgd291bGQgbm90IGhhcHBlbmQgaW4gbm9kZWpzIHYxMCtcbiAgICBjYWxsYmFjayA9IGVuY29kaW5nO1xuICAgIGVuY29kaW5nID0gJ3V0Zi04JztcbiAgfVxuXG4gIG1hcmtTeXNjYWxsKGN0eCwgJ3JlYWRsaW5rJyk7XG5cbiAgcmV0dXJuIG1heWJlQ2FsbGJhY2sobm9ybWFsaXplQ2FsbGJhY2soY2FsbGJhY2spLCBjdHgsIHRoaXMsIGZ1bmN0aW9uKCkge1xuICAgIHBhdGhuYW1lID0gZGVCdWZmZXIocGF0aG5hbWUpO1xuICAgIGNvbnN0IGxpbmsgPSB0aGlzLl9zeXN0ZW0uZ2V0SXRlbShwYXRobmFtZSk7XG4gICAgaWYgKCFsaW5rKSB7XG4gICAgICB0aHJvdyBuZXcgRlNFcnJvcignRU5PRU5UJywgcGF0aG5hbWUpO1xuICAgIH1cbiAgICBpZiAoIShsaW5rIGluc3RhbmNlb2YgU3ltYm9saWNMaW5rKSkge1xuICAgICAgdGhyb3cgbmV3IEZTRXJyb3IoJ0VJTlZBTCcsIHBhdGhuYW1lKTtcbiAgICB9XG4gICAgbGV0IGxpbmtQYXRoID0gbGluay5nZXRQYXRoKCk7XG4gICAgaWYgKGVuY29kaW5nID09PSAnYnVmZmVyJykge1xuICAgICAgbGlua1BhdGggPSBidWZmZXJGcm9tKGxpbmtQYXRoKTtcbiAgICB9XG4gICAgcmV0dXJuIGxpbmtQYXRoO1xuICB9KTtcbn07XG5cbi8qKlxuICogU3RhdCBhbiBpdGVtLlxuICogQHBhcmFtIHtzdHJpbmd9IGZpbGVwYXRoIFBhdGguXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yLCBTdGF0cyl8RmxvYXQ2NEFycmF5fEJpZ1VpbnQ2NEFycmF5fSBjYWxsYmFjayBDYWxsYmFjayAob3B0aW9uYWwpLiBJbiBOb2RlIDcuNy4wKyB0aGlzIHdpbGwgYmUgYSBGbG9hdDY0QXJyYXlcbiAqIHRoYXQgc2hvdWxkIGJlIGZpbGxlZCB3aXRoIHN0YXQgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IGN0eCBDb250ZXh0IG9iamVjdCAob3B0aW9uYWwpLCBvbmx5IGZvciBub2RlanMgdjEwKy5cbiAqIEByZXR1cm4ge1N0YXRzfHVuZGVmaW5lZH0gU3RhdHMgb3IgdW5kZWZpbmVkIChpZiBzeW5jKS5cbiAqL1xuQmluZGluZy5wcm90b3R5cGUubHN0YXQgPSBmdW5jdGlvbihmaWxlcGF0aCwgb3B0aW9ucywgY2FsbGJhY2ssIGN0eCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDMpIHtcbiAgICAvLyB0aGlzIHdvdWxkIG5vdCBoYXBwZW5kIGluIG5vZGVqcyB2MTArXG4gICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIG1hcmtTeXNjYWxsKGN0eCwgJ2xzdGF0Jyk7XG5cbiAgcmV0dXJuIG1heWJlQ2FsbGJhY2sod3JhcFN0YXRzQ2FsbGJhY2soY2FsbGJhY2spLCBjdHgsIHRoaXMsIGZ1bmN0aW9uKCkge1xuICAgIGZpbGVwYXRoID0gZGVCdWZmZXIoZmlsZXBhdGgpO1xuICAgIGNvbnN0IGl0ZW0gPSB0aGlzLl9zeXN0ZW0uZ2V0SXRlbShmaWxlcGF0aCk7XG4gICAgaWYgKCFpdGVtKSB7XG4gICAgICB0aHJvdyBuZXcgRlNFcnJvcignRU5PRU5UJywgZmlsZXBhdGgpO1xuICAgIH1cbiAgICBjb25zdCBzdGF0cyA9IGl0ZW0uZ2V0U3RhdHMoKTtcblxuICAgIC8vIEluIE5vZGUgNy43LjArLCBiaW5kaW5nLnN0YXQgYWNjZXB0cyBhIEZsb2F0NjRBcnJheSBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50LFxuICAgIC8vIHdoaWNoIHNob3VsZCBiZSBmaWxsZWQgd2l0aCBzdGF0IHZhbHVlcy5cbiAgICAvLyBJbiBwcmlvciB2ZXJzaW9ucyBvZiBOb2RlLCBiaW5kaW5nLnN0YXQgc2ltcGx5IHJldHVybnMgYSBTdGF0cyBpbnN0YW5jZS5cbiAgICBpZiAoXG4gICAgICBjYWxsYmFjayBpbnN0YW5jZW9mIEZsb2F0NjRBcnJheSB8fFxuICAgICAgY2FsbGJhY2sgaW5zdGFuY2VvZiBCaWdVaW50NjRBcnJheVxuICAgICkge1xuICAgICAgZmlsbFN0YXRzQXJyYXkoc3RhdHMsIGNhbGxiYWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZmlsbFN0YXRzQXJyYXkoc3RhdHMsIHN0YXRWYWx1ZXMpO1xuICAgICAgcmV0dXJuIG5ldyBTdGF0cyhpdGVtLmdldFN0YXRzKCkpO1xuICAgIH1cbiAgfSk7XG59O1xuXG4vKipcbiAqIFRlc3RzIHVzZXIgcGVybWlzc2lvbnMuXG4gKiBAcGFyYW0ge3N0cmluZ30gZmlsZXBhdGggUGF0aC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtb2RlIE1vZGUuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yKX0gY2FsbGJhY2sgQ2FsbGJhY2sgKG9wdGlvbmFsKS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjdHggQ29udGV4dCBvYmplY3QgKG9wdGlvbmFsKSwgb25seSBmb3Igbm9kZWpzIHYxMCsuXG4gKi9cbkJpbmRpbmcucHJvdG90eXBlLmFjY2VzcyA9IGZ1bmN0aW9uKGZpbGVwYXRoLCBtb2RlLCBjYWxsYmFjaywgY3R4KSB7XG4gIG1hcmtTeXNjYWxsKGN0eCwgJ2FjY2VzcycpO1xuXG4gIHJldHVybiBtYXliZUNhbGxiYWNrKG5vcm1hbGl6ZUNhbGxiYWNrKGNhbGxiYWNrKSwgY3R4LCB0aGlzLCBmdW5jdGlvbigpIHtcbiAgICBmaWxlcGF0aCA9IGRlQnVmZmVyKGZpbGVwYXRoKTtcbiAgICBsZXQgaXRlbSA9IHRoaXMuX3N5c3RlbS5nZXRJdGVtKGZpbGVwYXRoKTtcbiAgICBsZXQgbGlua3MgPSAwO1xuICAgIHdoaWxlIChpdGVtIGluc3RhbmNlb2YgU3ltYm9saWNMaW5rKSB7XG4gICAgICBpZiAobGlua3MgPiBNQVhfTElOS1MpIHtcbiAgICAgICAgdGhyb3cgbmV3IEZTRXJyb3IoJ0VMT09QJywgZmlsZXBhdGgpO1xuICAgICAgfVxuICAgICAgZmlsZXBhdGggPSBwYXRoLnJlc29sdmUocGF0aC5kaXJuYW1lKGZpbGVwYXRoKSwgaXRlbS5nZXRQYXRoKCkpO1xuICAgICAgaXRlbSA9IHRoaXMuX3N5c3RlbS5nZXRJdGVtKGZpbGVwYXRoKTtcbiAgICAgICsrbGlua3M7XG4gICAgfVxuICAgIGlmICghaXRlbSkge1xuICAgICAgdGhyb3cgbmV3IEZTRXJyb3IoJ0VOT0VOVCcsIGZpbGVwYXRoKTtcbiAgICB9XG4gICAgaWYgKG1vZGUgJiYgcHJvY2Vzcy5nZXR1aWQgJiYgcHJvY2Vzcy5nZXRnaWQpIHtcbiAgICAgIGNvbnN0IGl0ZW1Nb2RlID0gaXRlbS5nZXRNb2RlKCk7XG4gICAgICBpZiAoaXRlbS5nZXRVaWQoKSA9PT0gcHJvY2Vzcy5nZXR1aWQoKSkge1xuICAgICAgICBpZiAoKGl0ZW1Nb2RlICYgKG1vZGUgKiA2NCkpICE9PSBtb2RlICogNjQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlNFcnJvcignRUFDQ0VTJywgZmlsZXBhdGgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGl0ZW0uZ2V0R2lkKCkgPT09IHByb2Nlc3MuZ2V0Z2lkKCkpIHtcbiAgICAgICAgaWYgKChpdGVtTW9kZSAmIChtb2RlICogOCkpICE9PSBtb2RlICogOCkge1xuICAgICAgICAgIHRocm93IG5ldyBGU0Vycm9yKCdFQUNDRVMnLCBmaWxlcGF0aCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICgoaXRlbU1vZGUgJiBtb2RlKSAhPT0gbW9kZSkge1xuICAgICAgICAgIHRocm93IG5ldyBGU0Vycm9yKCdFQUNDRVMnLCBmaWxlcGF0aCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufTtcblxuLyoqXG4gKiBOb3QgeWV0IGltcGxlbWVudGVkLlxuICogQHR5cGUge2Z1bmN0aW9uKCl9XG4gKi9cbkJpbmRpbmcucHJvdG90eXBlLlN0YXRXYXRjaGVyID0gbm90SW1wbGVtZW50ZWQ7XG5cbi8qKlxuICogRXhwb3J0IHRoZSBiaW5kaW5nIGNvbnN0cnVjdG9yLlxuICogQHR5cGUge2Z1bmN0aW9uKCl9XG4gKi9cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IEJpbmRpbmc7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/mock-fs/lib/binding.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/mock-fs/lib/buffer.js":
/*!************************************************!*\
  !*** ../../node_modules/mock-fs/lib/buffer.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("exports.from =\n  Buffer.from ||\n  function(value, encoding) {\n    if (encoding) {\n      return new Buffer(value, encoding);\n    }\n    return new Buffer(value);\n  };\n\nexports.alloc =\n  Buffer.alloc ||\n  function(size) {\n    return new Buffer(size);\n  };\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL21vY2stZnMvbGliL2J1ZmZlci5qcyIsIm1hcHBpbmdzIjoiQUFBQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9iYXJiL2FhL0Fzc29jaWF0ZWRBY2NvdW50cy9ub2RlX21vZHVsZXMvbW9jay1mcy9saWIvYnVmZmVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydHMuZnJvbSA9XG4gIEJ1ZmZlci5mcm9tIHx8XG4gIGZ1bmN0aW9uKHZhbHVlLCBlbmNvZGluZykge1xuICAgIGlmIChlbmNvZGluZykge1xuICAgICAgcmV0dXJuIG5ldyBCdWZmZXIodmFsdWUsIGVuY29kaW5nKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBCdWZmZXIodmFsdWUpO1xuICB9O1xuXG5leHBvcnRzLmFsbG9jID1cbiAgQnVmZmVyLmFsbG9jIHx8XG4gIGZ1bmN0aW9uKHNpemUpIHtcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcihzaXplKTtcbiAgfTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/mock-fs/lib/buffer.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/mock-fs/lib/bypass.js":
/*!************************************************!*\
  !*** ../../node_modules/mock-fs/lib/bypass.js ***!
  \************************************************/
/***/ ((module, exports) => {

eval("const realBinding = process.binding('fs');\nlet storedBinding;\n\n/**\n * Perform action, bypassing mock FS\n * @example\n * // This file exists on the real FS, not on the mocked FS\n * const filePath = '/path/file.json';\n * const data = mock.bypass(() => fs.readFileSync(filePath, 'utf-8'));\n */\nexports = module.exports = function bypass(fn) {\n  if (typeof fn !== 'function') {\n    throw new Error(`Must provide a function to perform for mock.bypass()`);\n  }\n\n  disable();\n\n  let result;\n  try {\n    result = fn();\n  } finally {\n    if (result && typeof result.then === 'function') {\n      result.then(\n        r => {\n          enable();\n          return r;\n        },\n        err => {\n          enable();\n          throw err;\n        }\n      );\n    } else {\n      enable();\n    }\n  }\n\n  return result;\n};\n\n/**\n * Temporarily disable Mocked FS\n */\nfunction disable() {\n  if (realBinding._mockedBinding) {\n    storedBinding = realBinding._mockedBinding;\n    delete realBinding._mockedBinding;\n  }\n}\n\n/**\n * Enables Mocked FS after being disabled by disable()\n */\nfunction enable() {\n  if (storedBinding) {\n    realBinding._mockedBinding = storedBinding;\n    storedBinding = undefined;\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL21vY2stZnMvbGliL2J5cGFzcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9iYXJiL2FhL0Fzc29jaWF0ZWRBY2NvdW50cy9ub2RlX21vZHVsZXMvbW9jay1mcy9saWIvYnlwYXNzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IHJlYWxCaW5kaW5nID0gcHJvY2Vzcy5iaW5kaW5nKCdmcycpO1xubGV0IHN0b3JlZEJpbmRpbmc7XG5cbi8qKlxuICogUGVyZm9ybSBhY3Rpb24sIGJ5cGFzc2luZyBtb2NrIEZTXG4gKiBAZXhhbXBsZVxuICogLy8gVGhpcyBmaWxlIGV4aXN0cyBvbiB0aGUgcmVhbCBGUywgbm90IG9uIHRoZSBtb2NrZWQgRlNcbiAqIGNvbnN0IGZpbGVQYXRoID0gJy9wYXRoL2ZpbGUuanNvbic7XG4gKiBjb25zdCBkYXRhID0gbW9jay5ieXBhc3MoKCkgPT4gZnMucmVhZEZpbGVTeW5jKGZpbGVQYXRoLCAndXRmLTgnKSk7XG4gKi9cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGJ5cGFzcyhmbikge1xuICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBNdXN0IHByb3ZpZGUgYSBmdW5jdGlvbiB0byBwZXJmb3JtIGZvciBtb2NrLmJ5cGFzcygpYCk7XG4gIH1cblxuICBkaXNhYmxlKCk7XG5cbiAgbGV0IHJlc3VsdDtcbiAgdHJ5IHtcbiAgICByZXN1bHQgPSBmbigpO1xuICB9IGZpbmFsbHkge1xuICAgIGlmIChyZXN1bHQgJiYgdHlwZW9mIHJlc3VsdC50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXN1bHQudGhlbihcbiAgICAgICAgciA9PiB7XG4gICAgICAgICAgZW5hYmxlKCk7XG4gICAgICAgICAgcmV0dXJuIHI7XG4gICAgICAgIH0sXG4gICAgICAgIGVyciA9PiB7XG4gICAgICAgICAgZW5hYmxlKCk7XG4gICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbmFibGUoKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBUZW1wb3JhcmlseSBkaXNhYmxlIE1vY2tlZCBGU1xuICovXG5mdW5jdGlvbiBkaXNhYmxlKCkge1xuICBpZiAocmVhbEJpbmRpbmcuX21vY2tlZEJpbmRpbmcpIHtcbiAgICBzdG9yZWRCaW5kaW5nID0gcmVhbEJpbmRpbmcuX21vY2tlZEJpbmRpbmc7XG4gICAgZGVsZXRlIHJlYWxCaW5kaW5nLl9tb2NrZWRCaW5kaW5nO1xuICB9XG59XG5cbi8qKlxuICogRW5hYmxlcyBNb2NrZWQgRlMgYWZ0ZXIgYmVpbmcgZGlzYWJsZWQgYnkgZGlzYWJsZSgpXG4gKi9cbmZ1bmN0aW9uIGVuYWJsZSgpIHtcbiAgaWYgKHN0b3JlZEJpbmRpbmcpIHtcbiAgICByZWFsQmluZGluZy5fbW9ja2VkQmluZGluZyA9IHN0b3JlZEJpbmRpbmc7XG4gICAgc3RvcmVkQmluZGluZyA9IHVuZGVmaW5lZDtcbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/mock-fs/lib/bypass.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/mock-fs/lib/descriptor.js":
/*!****************************************************!*\
  !*** ../../node_modules/mock-fs/lib/descriptor.js ***!
  \****************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\n\nconst constants = __webpack_require__(/*! constants */ \"constants\");\n\n/**\n * Create a new file descriptor.\n * @param {number} flags Flags.\n * @constructor\n */\nfunction FileDescriptor(flags) {\n  /**\n   * Flags.\n   * @type {number}\n   */\n  this._flags = flags;\n\n  /**\n   * File system item.\n   * @type {Item}\n   */\n  this._item = null;\n\n  /**\n   * Current file position.\n   * @type {number}\n   */\n  this._position = 0;\n}\n\n/**\n * Set the item.\n * @param {Item} item File system item.\n */\nFileDescriptor.prototype.setItem = function(item) {\n  this._item = item;\n};\n\n/**\n * Get the item.\n * @return {Item} File system item.\n */\nFileDescriptor.prototype.getItem = function() {\n  return this._item;\n};\n\n/**\n * Get the current file position.\n * @return {number} File position.\n */\nFileDescriptor.prototype.getPosition = function() {\n  return this._position;\n};\n\n/**\n * Set the current file position.\n * @param {number} position File position.\n */\nFileDescriptor.prototype.setPosition = function(position) {\n  this._position = position;\n};\n\n/**\n * Check if file opened for appending.\n * @return {boolean} Opened for appending.\n */\nFileDescriptor.prototype.isAppend = function() {\n  return (this._flags & constants.O_APPEND) === constants.O_APPEND;\n};\n\n/**\n * Check if file opened for creation.\n * @return {boolean} Opened for creation.\n */\nFileDescriptor.prototype.isCreate = function() {\n  return (this._flags & constants.O_CREAT) === constants.O_CREAT;\n};\n\n/**\n * Check if file opened for reading.\n * @return {boolean} Opened for reading.\n */\nFileDescriptor.prototype.isRead = function() {\n  return (this._flags & constants.O_WRONLY) !== constants.O_WRONLY;\n};\n\n/**\n * Check if file opened for writing.\n * @return {boolean} Opened for writing.\n */\nFileDescriptor.prototype.isWrite = function() {\n  return (\n    (this._flags & constants.O_WRONLY) === constants.O_WRONLY ||\n    (this._flags & constants.O_RDWR) === constants.O_RDWR\n  );\n};\n\n/**\n * Check if file opened for truncating.\n * @return {boolean} Opened for truncating.\n */\nFileDescriptor.prototype.isTruncate = function() {\n  return (this._flags & constants.O_TRUNC) === constants.O_TRUNC;\n};\n\n/**\n * Check if file opened with exclusive flag.\n * @return {boolean} Opened with exclusive.\n */\nFileDescriptor.prototype.isExclusive = function() {\n  return (this._flags & constants.O_EXCL) === constants.O_EXCL;\n};\n\n/**\n * Export the constructor.\n * @type {function()}\n */\nexports = module.exports = FileDescriptor;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL21vY2stZnMvbGliL2Rlc2NyaXB0b3IuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsa0JBQWtCLG1CQUFPLENBQUMsNEJBQVc7O0FBRXJDO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLE1BQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvYmFyYi9hYS9Bc3NvY2lhdGVkQWNjb3VudHMvbm9kZV9tb2R1bGVzL21vY2stZnMvbGliL2Rlc2NyaXB0b3IuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBjb25zdGFudHMgPSByZXF1aXJlKCdjb25zdGFudHMnKTtcblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgZmlsZSBkZXNjcmlwdG9yLlxuICogQHBhcmFtIHtudW1iZXJ9IGZsYWdzIEZsYWdzLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIEZpbGVEZXNjcmlwdG9yKGZsYWdzKSB7XG4gIC8qKlxuICAgKiBGbGFncy5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIHRoaXMuX2ZsYWdzID0gZmxhZ3M7XG5cbiAgLyoqXG4gICAqIEZpbGUgc3lzdGVtIGl0ZW0uXG4gICAqIEB0eXBlIHtJdGVtfVxuICAgKi9cbiAgdGhpcy5faXRlbSA9IG51bGw7XG5cbiAgLyoqXG4gICAqIEN1cnJlbnQgZmlsZSBwb3NpdGlvbi5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIHRoaXMuX3Bvc2l0aW9uID0gMDtcbn1cblxuLyoqXG4gKiBTZXQgdGhlIGl0ZW0uXG4gKiBAcGFyYW0ge0l0ZW19IGl0ZW0gRmlsZSBzeXN0ZW0gaXRlbS5cbiAqL1xuRmlsZURlc2NyaXB0b3IucHJvdG90eXBlLnNldEl0ZW0gPSBmdW5jdGlvbihpdGVtKSB7XG4gIHRoaXMuX2l0ZW0gPSBpdGVtO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIGl0ZW0uXG4gKiBAcmV0dXJuIHtJdGVtfSBGaWxlIHN5c3RlbSBpdGVtLlxuICovXG5GaWxlRGVzY3JpcHRvci5wcm90b3R5cGUuZ2V0SXRlbSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5faXRlbTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBjdXJyZW50IGZpbGUgcG9zaXRpb24uXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEZpbGUgcG9zaXRpb24uXG4gKi9cbkZpbGVEZXNjcmlwdG9yLnByb3RvdHlwZS5nZXRQb3NpdGlvbiA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fcG9zaXRpb247XG59O1xuXG4vKipcbiAqIFNldCB0aGUgY3VycmVudCBmaWxlIHBvc2l0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IHBvc2l0aW9uIEZpbGUgcG9zaXRpb24uXG4gKi9cbkZpbGVEZXNjcmlwdG9yLnByb3RvdHlwZS5zZXRQb3NpdGlvbiA9IGZ1bmN0aW9uKHBvc2l0aW9uKSB7XG4gIHRoaXMuX3Bvc2l0aW9uID0gcG9zaXRpb247XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIGZpbGUgb3BlbmVkIGZvciBhcHBlbmRpbmcuXG4gKiBAcmV0dXJuIHtib29sZWFufSBPcGVuZWQgZm9yIGFwcGVuZGluZy5cbiAqL1xuRmlsZURlc2NyaXB0b3IucHJvdG90eXBlLmlzQXBwZW5kID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAodGhpcy5fZmxhZ3MgJiBjb25zdGFudHMuT19BUFBFTkQpID09PSBjb25zdGFudHMuT19BUFBFTkQ7XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIGZpbGUgb3BlbmVkIGZvciBjcmVhdGlvbi5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IE9wZW5lZCBmb3IgY3JlYXRpb24uXG4gKi9cbkZpbGVEZXNjcmlwdG9yLnByb3RvdHlwZS5pc0NyZWF0ZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKHRoaXMuX2ZsYWdzICYgY29uc3RhbnRzLk9fQ1JFQVQpID09PSBjb25zdGFudHMuT19DUkVBVDtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgZmlsZSBvcGVuZWQgZm9yIHJlYWRpbmcuXG4gKiBAcmV0dXJuIHtib29sZWFufSBPcGVuZWQgZm9yIHJlYWRpbmcuXG4gKi9cbkZpbGVEZXNjcmlwdG9yLnByb3RvdHlwZS5pc1JlYWQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuICh0aGlzLl9mbGFncyAmIGNvbnN0YW50cy5PX1dST05MWSkgIT09IGNvbnN0YW50cy5PX1dST05MWTtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgZmlsZSBvcGVuZWQgZm9yIHdyaXRpbmcuXG4gKiBAcmV0dXJuIHtib29sZWFufSBPcGVuZWQgZm9yIHdyaXRpbmcuXG4gKi9cbkZpbGVEZXNjcmlwdG9yLnByb3RvdHlwZS5pc1dyaXRlID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoXG4gICAgKHRoaXMuX2ZsYWdzICYgY29uc3RhbnRzLk9fV1JPTkxZKSA9PT0gY29uc3RhbnRzLk9fV1JPTkxZIHx8XG4gICAgKHRoaXMuX2ZsYWdzICYgY29uc3RhbnRzLk9fUkRXUikgPT09IGNvbnN0YW50cy5PX1JEV1JcbiAgKTtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgZmlsZSBvcGVuZWQgZm9yIHRydW5jYXRpbmcuXG4gKiBAcmV0dXJuIHtib29sZWFufSBPcGVuZWQgZm9yIHRydW5jYXRpbmcuXG4gKi9cbkZpbGVEZXNjcmlwdG9yLnByb3RvdHlwZS5pc1RydW5jYXRlID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAodGhpcy5fZmxhZ3MgJiBjb25zdGFudHMuT19UUlVOQykgPT09IGNvbnN0YW50cy5PX1RSVU5DO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiBmaWxlIG9wZW5lZCB3aXRoIGV4Y2x1c2l2ZSBmbGFnLlxuICogQHJldHVybiB7Ym9vbGVhbn0gT3BlbmVkIHdpdGggZXhjbHVzaXZlLlxuICovXG5GaWxlRGVzY3JpcHRvci5wcm90b3R5cGUuaXNFeGNsdXNpdmUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuICh0aGlzLl9mbGFncyAmIGNvbnN0YW50cy5PX0VYQ0wpID09PSBjb25zdGFudHMuT19FWENMO1xufTtcblxuLyoqXG4gKiBFeHBvcnQgdGhlIGNvbnN0cnVjdG9yLlxuICogQHR5cGUge2Z1bmN0aW9uKCl9XG4gKi9cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IEZpbGVEZXNjcmlwdG9yO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/mock-fs/lib/descriptor.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/mock-fs/lib/directory.js":
/*!***************************************************!*\
  !*** ../../node_modules/mock-fs/lib/directory.js ***!
  \***************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\n\nconst util = __webpack_require__(/*! util */ \"util\");\n\nconst Item = __webpack_require__(/*! ./item */ \"(rsc)/../../node_modules/mock-fs/lib/item.js\");\n\nconst constants = __webpack_require__(/*! constants */ \"constants\");\n\n/**\n * A directory.\n * @constructor\n */\nfunction Directory() {\n  Item.call(this);\n\n  /**\n   * Items in this directory.\n   * @type {Object.<string, Item>}\n   */\n  this._items = {};\n\n  /**\n   * Permissions.\n   */\n  this._mode = 511; // 0777\n}\nutil.inherits(Directory, Item);\n\n/**\n * Add an item to the directory.\n * @param {string} name The name to give the item.\n * @param {Item} item The item to add.\n * @return {Item} The added item.\n */\nDirectory.prototype.addItem = function(name, item) {\n  if (this._items.hasOwnProperty(name)) {\n    throw new Error('Item with the same name already exists: ' + name);\n  }\n  this._items[name] = item;\n  ++item.links;\n  if (item instanceof Directory) {\n    // for '.' entry\n    ++item.links;\n    // for subdirectory\n    ++this.links;\n  }\n  this.setMTime(new Date());\n  return item;\n};\n\n/**\n * Get a named item.\n * @param {string} name Item name.\n * @return {Item} The named item (or null if none).\n */\nDirectory.prototype.getItem = function(name) {\n  let item = null;\n  if (this._items.hasOwnProperty(name)) {\n    item = this._items[name];\n  }\n  return item;\n};\n\n/**\n * Remove an item.\n * @param {string} name Name of item to remove.\n * @return {Item} The orphan item.\n */\nDirectory.prototype.removeItem = function(name) {\n  if (!this._items.hasOwnProperty(name)) {\n    throw new Error('Item does not exist in directory: ' + name);\n  }\n  const item = this._items[name];\n  delete this._items[name];\n  --item.links;\n  if (item instanceof Directory) {\n    // for '.' entry\n    --item.links;\n    // for subdirectory\n    --this.links;\n  }\n  this.setMTime(new Date());\n  return item;\n};\n\n/**\n * Get list of item names in this directory.\n * @return {Array.<string>} Item names.\n */\nDirectory.prototype.list = function() {\n  return Object.keys(this._items).sort();\n};\n\n/**\n * Get directory stats.\n * @return {Object} Stats properties.\n */\nDirectory.prototype.getStats = function() {\n  const stats = Item.prototype.getStats.call(this);\n  stats.mode = this.getMode() | constants.S_IFDIR;\n  stats.size = 1;\n  stats.blocks = 1;\n  return stats;\n};\n\n/**\n * Export the constructor.\n * @type {function()}\n */\nexports = module.exports = Directory;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL21vY2stZnMvbGliL2RpcmVjdG9yeS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixhQUFhLG1CQUFPLENBQUMsa0JBQU07O0FBRTNCLGFBQWEsbUJBQU8sQ0FBQyw0REFBUTs7QUFFN0Isa0JBQWtCLG1CQUFPLENBQUMsNEJBQVc7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLE1BQU07QUFDakIsWUFBWSxNQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWSxNQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZLE1BQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxnQkFBZ0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvYmFyYi9hYS9Bc3NvY2lhdGVkQWNjb3VudHMvbm9kZV9tb2R1bGVzL21vY2stZnMvbGliL2RpcmVjdG9yeS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG5cbmNvbnN0IEl0ZW0gPSByZXF1aXJlKCcuL2l0ZW0nKTtcblxuY29uc3QgY29uc3RhbnRzID0gcmVxdWlyZSgnY29uc3RhbnRzJyk7XG5cbi8qKlxuICogQSBkaXJlY3RvcnkuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gRGlyZWN0b3J5KCkge1xuICBJdGVtLmNhbGwodGhpcyk7XG5cbiAgLyoqXG4gICAqIEl0ZW1zIGluIHRoaXMgZGlyZWN0b3J5LlxuICAgKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsIEl0ZW0+fVxuICAgKi9cbiAgdGhpcy5faXRlbXMgPSB7fTtcblxuICAvKipcbiAgICogUGVybWlzc2lvbnMuXG4gICAqL1xuICB0aGlzLl9tb2RlID0gNTExOyAvLyAwNzc3XG59XG51dGlsLmluaGVyaXRzKERpcmVjdG9yeSwgSXRlbSk7XG5cbi8qKlxuICogQWRkIGFuIGl0ZW0gdG8gdGhlIGRpcmVjdG9yeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBuYW1lIHRvIGdpdmUgdGhlIGl0ZW0uXG4gKiBAcGFyYW0ge0l0ZW19IGl0ZW0gVGhlIGl0ZW0gdG8gYWRkLlxuICogQHJldHVybiB7SXRlbX0gVGhlIGFkZGVkIGl0ZW0uXG4gKi9cbkRpcmVjdG9yeS5wcm90b3R5cGUuYWRkSXRlbSA9IGZ1bmN0aW9uKG5hbWUsIGl0ZW0pIHtcbiAgaWYgKHRoaXMuX2l0ZW1zLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJdGVtIHdpdGggdGhlIHNhbWUgbmFtZSBhbHJlYWR5IGV4aXN0czogJyArIG5hbWUpO1xuICB9XG4gIHRoaXMuX2l0ZW1zW25hbWVdID0gaXRlbTtcbiAgKytpdGVtLmxpbmtzO1xuICBpZiAoaXRlbSBpbnN0YW5jZW9mIERpcmVjdG9yeSkge1xuICAgIC8vIGZvciAnLicgZW50cnlcbiAgICArK2l0ZW0ubGlua3M7XG4gICAgLy8gZm9yIHN1YmRpcmVjdG9yeVxuICAgICsrdGhpcy5saW5rcztcbiAgfVxuICB0aGlzLnNldE1UaW1lKG5ldyBEYXRlKCkpO1xuICByZXR1cm4gaXRlbTtcbn07XG5cbi8qKlxuICogR2V0IGEgbmFtZWQgaXRlbS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIEl0ZW0gbmFtZS5cbiAqIEByZXR1cm4ge0l0ZW19IFRoZSBuYW1lZCBpdGVtIChvciBudWxsIGlmIG5vbmUpLlxuICovXG5EaXJlY3RvcnkucHJvdG90eXBlLmdldEl0ZW0gPSBmdW5jdGlvbihuYW1lKSB7XG4gIGxldCBpdGVtID0gbnVsbDtcbiAgaWYgKHRoaXMuX2l0ZW1zLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgaXRlbSA9IHRoaXMuX2l0ZW1zW25hbWVdO1xuICB9XG4gIHJldHVybiBpdGVtO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgYW4gaXRlbS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE5hbWUgb2YgaXRlbSB0byByZW1vdmUuXG4gKiBAcmV0dXJuIHtJdGVtfSBUaGUgb3JwaGFuIGl0ZW0uXG4gKi9cbkRpcmVjdG9yeS5wcm90b3R5cGUucmVtb3ZlSXRlbSA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgaWYgKCF0aGlzLl9pdGVtcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSXRlbSBkb2VzIG5vdCBleGlzdCBpbiBkaXJlY3Rvcnk6ICcgKyBuYW1lKTtcbiAgfVxuICBjb25zdCBpdGVtID0gdGhpcy5faXRlbXNbbmFtZV07XG4gIGRlbGV0ZSB0aGlzLl9pdGVtc1tuYW1lXTtcbiAgLS1pdGVtLmxpbmtzO1xuICBpZiAoaXRlbSBpbnN0YW5jZW9mIERpcmVjdG9yeSkge1xuICAgIC8vIGZvciAnLicgZW50cnlcbiAgICAtLWl0ZW0ubGlua3M7XG4gICAgLy8gZm9yIHN1YmRpcmVjdG9yeVxuICAgIC0tdGhpcy5saW5rcztcbiAgfVxuICB0aGlzLnNldE1UaW1lKG5ldyBEYXRlKCkpO1xuICByZXR1cm4gaXRlbTtcbn07XG5cbi8qKlxuICogR2V0IGxpc3Qgb2YgaXRlbSBuYW1lcyBpbiB0aGlzIGRpcmVjdG9yeS5cbiAqIEByZXR1cm4ge0FycmF5LjxzdHJpbmc+fSBJdGVtIG5hbWVzLlxuICovXG5EaXJlY3RvcnkucHJvdG90eXBlLmxpc3QgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuX2l0ZW1zKS5zb3J0KCk7XG59O1xuXG4vKipcbiAqIEdldCBkaXJlY3Rvcnkgc3RhdHMuXG4gKiBAcmV0dXJuIHtPYmplY3R9IFN0YXRzIHByb3BlcnRpZXMuXG4gKi9cbkRpcmVjdG9yeS5wcm90b3R5cGUuZ2V0U3RhdHMgPSBmdW5jdGlvbigpIHtcbiAgY29uc3Qgc3RhdHMgPSBJdGVtLnByb3RvdHlwZS5nZXRTdGF0cy5jYWxsKHRoaXMpO1xuICBzdGF0cy5tb2RlID0gdGhpcy5nZXRNb2RlKCkgfCBjb25zdGFudHMuU19JRkRJUjtcbiAgc3RhdHMuc2l6ZSA9IDE7XG4gIHN0YXRzLmJsb2NrcyA9IDE7XG4gIHJldHVybiBzdGF0cztcbn07XG5cbi8qKlxuICogRXhwb3J0IHRoZSBjb25zdHJ1Y3Rvci5cbiAqIEB0eXBlIHtmdW5jdGlvbigpfVxuICovXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBEaXJlY3Rvcnk7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/mock-fs/lib/directory.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/mock-fs/lib/error.js":
/*!***********************************************!*\
  !*** ../../node_modules/mock-fs/lib/error.js ***!
  \***********************************************/
/***/ ((module, exports) => {

"use strict";
eval("\n\nconst uvBinding = process.binding('uv');\n/**\n * Error codes from libuv.\n * @enum {number}\n */\nconst codes = {};\n\nif (uvBinding.errmap) {\n  // nodejs v8+\n  uvBinding.errmap.forEach(function(value, errno) {\n    const code = value[0];\n    const message = value[1];\n    codes[code] = {errno: errno, message: message};\n  });\n} else {\n  // nodejs v4 and v6\n  Object.keys(uvBinding).forEach(function(key) {\n    if (key.startsWith('UV_')) {\n      const code = key.slice(3);\n      const errno = uvBinding[key];\n      codes[code] = {errno: errno, message: key};\n    }\n  });\n}\n\n/**\n * Create an error.\n * @param {string} code Error code.\n * @param {string} path Path (optional).\n * @constructor\n */\nfunction FSError(code, path) {\n  if (!codes.hasOwnProperty(code)) {\n    throw new Error('Programmer error, invalid error code: ' + code);\n  }\n  Error.call(this);\n  const details = codes[code];\n  let message = code + ', ' + details.message;\n  if (path) {\n    message += \" '\" + path + \"'\";\n  }\n  this.message = message;\n  this.code = code;\n  this.errno = details.errno;\n  if (path !== undefined) {\n    this.path = path;\n  }\n  Error.captureStackTrace(this, FSError);\n}\nFSError.prototype = new Error();\nFSError.codes = codes;\n\n/**\n * Error constructor.\n */\nexports = module.exports = FSError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL21vY2stZnMvbGliL2Vycm9yLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIsR0FBRztBQUNILEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9iYXJiL2FhL0Fzc29jaWF0ZWRBY2NvdW50cy9ub2RlX21vZHVsZXMvbW9jay1mcy9saWIvZXJyb3IuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB1dkJpbmRpbmcgPSBwcm9jZXNzLmJpbmRpbmcoJ3V2Jyk7XG4vKipcbiAqIEVycm9yIGNvZGVzIGZyb20gbGlidXYuXG4gKiBAZW51bSB7bnVtYmVyfVxuICovXG5jb25zdCBjb2RlcyA9IHt9O1xuXG5pZiAodXZCaW5kaW5nLmVycm1hcCkge1xuICAvLyBub2RlanMgdjgrXG4gIHV2QmluZGluZy5lcnJtYXAuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwgZXJybm8pIHtcbiAgICBjb25zdCBjb2RlID0gdmFsdWVbMF07XG4gICAgY29uc3QgbWVzc2FnZSA9IHZhbHVlWzFdO1xuICAgIGNvZGVzW2NvZGVdID0ge2Vycm5vOiBlcnJubywgbWVzc2FnZTogbWVzc2FnZX07XG4gIH0pO1xufSBlbHNlIHtcbiAgLy8gbm9kZWpzIHY0IGFuZCB2NlxuICBPYmplY3Qua2V5cyh1dkJpbmRpbmcpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgaWYgKGtleS5zdGFydHNXaXRoKCdVVl8nKSkge1xuICAgICAgY29uc3QgY29kZSA9IGtleS5zbGljZSgzKTtcbiAgICAgIGNvbnN0IGVycm5vID0gdXZCaW5kaW5nW2tleV07XG4gICAgICBjb2Rlc1tjb2RlXSA9IHtlcnJubzogZXJybm8sIG1lc3NhZ2U6IGtleX07XG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYW4gZXJyb3IuXG4gKiBAcGFyYW0ge3N0cmluZ30gY29kZSBFcnJvciBjb2RlLlxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGggUGF0aCAob3B0aW9uYWwpLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIEZTRXJyb3IoY29kZSwgcGF0aCkge1xuICBpZiAoIWNvZGVzLmhhc093blByb3BlcnR5KGNvZGUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdQcm9ncmFtbWVyIGVycm9yLCBpbnZhbGlkIGVycm9yIGNvZGU6ICcgKyBjb2RlKTtcbiAgfVxuICBFcnJvci5jYWxsKHRoaXMpO1xuICBjb25zdCBkZXRhaWxzID0gY29kZXNbY29kZV07XG4gIGxldCBtZXNzYWdlID0gY29kZSArICcsICcgKyBkZXRhaWxzLm1lc3NhZ2U7XG4gIGlmIChwYXRoKSB7XG4gICAgbWVzc2FnZSArPSBcIiAnXCIgKyBwYXRoICsgXCInXCI7XG4gIH1cbiAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgdGhpcy5jb2RlID0gY29kZTtcbiAgdGhpcy5lcnJubyA9IGRldGFpbHMuZXJybm87XG4gIGlmIChwYXRoICE9PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzLnBhdGggPSBwYXRoO1xuICB9XG4gIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIEZTRXJyb3IpO1xufVxuRlNFcnJvci5wcm90b3R5cGUgPSBuZXcgRXJyb3IoKTtcbkZTRXJyb3IuY29kZXMgPSBjb2RlcztcblxuLyoqXG4gKiBFcnJvciBjb25zdHJ1Y3Rvci5cbiAqL1xuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gRlNFcnJvcjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/mock-fs/lib/error.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/mock-fs/lib/file.js":
/*!**********************************************!*\
  !*** ../../node_modules/mock-fs/lib/file.js ***!
  \**********************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\n\nconst util = __webpack_require__(/*! util */ \"util\");\n\nconst Item = __webpack_require__(/*! ./item */ \"(rsc)/../../node_modules/mock-fs/lib/item.js\");\nconst bufferFrom = (__webpack_require__(/*! ./buffer */ \"(rsc)/../../node_modules/mock-fs/lib/buffer.js\").from);\nconst bufferAlloc = (__webpack_require__(/*! ./buffer */ \"(rsc)/../../node_modules/mock-fs/lib/buffer.js\").alloc);\n\nconst EMPTY = bufferAlloc(0);\nconst constants = __webpack_require__(/*! constants */ \"constants\");\n\n/**\n * A file.\n * @constructor\n */\nfunction File() {\n  Item.call(this);\n\n  /**\n   * File content.\n   * @type {Buffer}\n   */\n  this._content = EMPTY;\n}\nutil.inherits(File, Item);\n\n/**\n * Get the file contents.\n * @return {Buffer} File contents.\n */\nFile.prototype.getContent = function() {\n  this.setATime(new Date());\n  return this._content;\n};\n\n/**\n * Set the file contents.\n * @param {string|Buffer} content File contents.\n */\nFile.prototype.setContent = function(content) {\n  if (typeof content === 'string') {\n    content = bufferFrom(content);\n  } else if (!Buffer.isBuffer(content)) {\n    throw new Error('File content must be a string or buffer');\n  }\n  this._content = content;\n  const now = Date.now();\n  this.setCTime(new Date(now));\n  this.setMTime(new Date(now));\n};\n\n/**\n * Get file stats.\n * @return {Object} Stats properties.\n */\nFile.prototype.getStats = function() {\n  const size = this._content.length;\n  const stats = Item.prototype.getStats.call(this);\n  stats.mode = this.getMode() | constants.S_IFREG;\n  stats.size = size;\n  stats.blocks = Math.ceil(size / 512);\n  return stats;\n};\n\n/**\n * Export the constructor.\n * @type {function()}\n */\nexports = module.exports = File;\n\n/**\n * Standard input.\n * @constructor\n */\nfunction StandardInput() {\n  File.call(this);\n  this.setMode(438); // 0666\n}\nutil.inherits(StandardInput, File);\n\nexports.StandardInput = StandardInput;\n\n/**\n * Standard output.\n * @constructor\n */\nfunction StandardOutput() {\n  File.call(this);\n  this.setMode(438); // 0666\n}\nutil.inherits(StandardOutput, File);\n\n/**\n * Write the contents to stdout.\n * @param {string|Buffer} content File contents.\n */\nStandardOutput.prototype.setContent = function(content) {\n  if (process.stdout.isTTY) {\n    process.stdout.write(content);\n  }\n};\n\nexports.StandardOutput = StandardOutput;\n\n/**\n * Standard error.\n * @constructor\n */\nfunction StandardError() {\n  File.call(this);\n  this.setMode(438); // 0666\n}\nutil.inherits(StandardError, File);\n\n/**\n * Write the contents to stderr.\n * @param {string|Buffer} content File contents.\n */\nStandardError.prototype.setContent = function(content) {\n  if (process.stderr.isTTY) {\n    process.stderr.write(content);\n  }\n};\n\nexports.StandardError = StandardError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL21vY2stZnMvbGliL2ZpbGUuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsYUFBYSxtQkFBTyxDQUFDLGtCQUFNOztBQUUzQixhQUFhLG1CQUFPLENBQUMsNERBQVE7QUFDN0IsbUJBQW1CLDRGQUF3QjtBQUMzQyxvQkFBb0IsNkZBQXlCOztBQUU3QztBQUNBLGtCQUFrQixtQkFBTyxDQUFDLDRCQUFXOztBQUVyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7O0FBRUEscUJBQXFCOztBQUVyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0I7O0FBRXRCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLGVBQWU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFCQUFxQiIsInNvdXJjZXMiOlsiL2hvbWUvYmFyYi9hYS9Bc3NvY2lhdGVkQWNjb3VudHMvbm9kZV9tb2R1bGVzL21vY2stZnMvbGliL2ZpbGUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xuXG5jb25zdCBJdGVtID0gcmVxdWlyZSgnLi9pdGVtJyk7XG5jb25zdCBidWZmZXJGcm9tID0gcmVxdWlyZSgnLi9idWZmZXInKS5mcm9tO1xuY29uc3QgYnVmZmVyQWxsb2MgPSByZXF1aXJlKCcuL2J1ZmZlcicpLmFsbG9jO1xuXG5jb25zdCBFTVBUWSA9IGJ1ZmZlckFsbG9jKDApO1xuY29uc3QgY29uc3RhbnRzID0gcmVxdWlyZSgnY29uc3RhbnRzJyk7XG5cbi8qKlxuICogQSBmaWxlLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIEZpbGUoKSB7XG4gIEl0ZW0uY2FsbCh0aGlzKTtcblxuICAvKipcbiAgICogRmlsZSBjb250ZW50LlxuICAgKiBAdHlwZSB7QnVmZmVyfVxuICAgKi9cbiAgdGhpcy5fY29udGVudCA9IEVNUFRZO1xufVxudXRpbC5pbmhlcml0cyhGaWxlLCBJdGVtKTtcblxuLyoqXG4gKiBHZXQgdGhlIGZpbGUgY29udGVudHMuXG4gKiBAcmV0dXJuIHtCdWZmZXJ9IEZpbGUgY29udGVudHMuXG4gKi9cbkZpbGUucHJvdG90eXBlLmdldENvbnRlbnQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5zZXRBVGltZShuZXcgRGF0ZSgpKTtcbiAgcmV0dXJuIHRoaXMuX2NvbnRlbnQ7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgZmlsZSBjb250ZW50cy5cbiAqIEBwYXJhbSB7c3RyaW5nfEJ1ZmZlcn0gY29udGVudCBGaWxlIGNvbnRlbnRzLlxuICovXG5GaWxlLnByb3RvdHlwZS5zZXRDb250ZW50ID0gZnVuY3Rpb24oY29udGVudCkge1xuICBpZiAodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgY29udGVudCA9IGJ1ZmZlckZyb20oY29udGVudCk7XG4gIH0gZWxzZSBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihjb250ZW50KSkge1xuICAgIHRocm93IG5ldyBFcnJvcignRmlsZSBjb250ZW50IG11c3QgYmUgYSBzdHJpbmcgb3IgYnVmZmVyJyk7XG4gIH1cbiAgdGhpcy5fY29udGVudCA9IGNvbnRlbnQ7XG4gIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gIHRoaXMuc2V0Q1RpbWUobmV3IERhdGUobm93KSk7XG4gIHRoaXMuc2V0TVRpbWUobmV3IERhdGUobm93KSk7XG59O1xuXG4vKipcbiAqIEdldCBmaWxlIHN0YXRzLlxuICogQHJldHVybiB7T2JqZWN0fSBTdGF0cyBwcm9wZXJ0aWVzLlxuICovXG5GaWxlLnByb3RvdHlwZS5nZXRTdGF0cyA9IGZ1bmN0aW9uKCkge1xuICBjb25zdCBzaXplID0gdGhpcy5fY29udGVudC5sZW5ndGg7XG4gIGNvbnN0IHN0YXRzID0gSXRlbS5wcm90b3R5cGUuZ2V0U3RhdHMuY2FsbCh0aGlzKTtcbiAgc3RhdHMubW9kZSA9IHRoaXMuZ2V0TW9kZSgpIHwgY29uc3RhbnRzLlNfSUZSRUc7XG4gIHN0YXRzLnNpemUgPSBzaXplO1xuICBzdGF0cy5ibG9ja3MgPSBNYXRoLmNlaWwoc2l6ZSAvIDUxMik7XG4gIHJldHVybiBzdGF0cztcbn07XG5cbi8qKlxuICogRXhwb3J0IHRoZSBjb25zdHJ1Y3Rvci5cbiAqIEB0eXBlIHtmdW5jdGlvbigpfVxuICovXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBGaWxlO1xuXG4vKipcbiAqIFN0YW5kYXJkIGlucHV0LlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIFN0YW5kYXJkSW5wdXQoKSB7XG4gIEZpbGUuY2FsbCh0aGlzKTtcbiAgdGhpcy5zZXRNb2RlKDQzOCk7IC8vIDA2NjZcbn1cbnV0aWwuaW5oZXJpdHMoU3RhbmRhcmRJbnB1dCwgRmlsZSk7XG5cbmV4cG9ydHMuU3RhbmRhcmRJbnB1dCA9IFN0YW5kYXJkSW5wdXQ7XG5cbi8qKlxuICogU3RhbmRhcmQgb3V0cHV0LlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIFN0YW5kYXJkT3V0cHV0KCkge1xuICBGaWxlLmNhbGwodGhpcyk7XG4gIHRoaXMuc2V0TW9kZSg0MzgpOyAvLyAwNjY2XG59XG51dGlsLmluaGVyaXRzKFN0YW5kYXJkT3V0cHV0LCBGaWxlKTtcblxuLyoqXG4gKiBXcml0ZSB0aGUgY29udGVudHMgdG8gc3Rkb3V0LlxuICogQHBhcmFtIHtzdHJpbmd8QnVmZmVyfSBjb250ZW50IEZpbGUgY29udGVudHMuXG4gKi9cblN0YW5kYXJkT3V0cHV0LnByb3RvdHlwZS5zZXRDb250ZW50ID0gZnVuY3Rpb24oY29udGVudCkge1xuICBpZiAocHJvY2Vzcy5zdGRvdXQuaXNUVFkpIHtcbiAgICBwcm9jZXNzLnN0ZG91dC53cml0ZShjb250ZW50KTtcbiAgfVxufTtcblxuZXhwb3J0cy5TdGFuZGFyZE91dHB1dCA9IFN0YW5kYXJkT3V0cHV0O1xuXG4vKipcbiAqIFN0YW5kYXJkIGVycm9yLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIFN0YW5kYXJkRXJyb3IoKSB7XG4gIEZpbGUuY2FsbCh0aGlzKTtcbiAgdGhpcy5zZXRNb2RlKDQzOCk7IC8vIDA2NjZcbn1cbnV0aWwuaW5oZXJpdHMoU3RhbmRhcmRFcnJvciwgRmlsZSk7XG5cbi8qKlxuICogV3JpdGUgdGhlIGNvbnRlbnRzIHRvIHN0ZGVyci5cbiAqIEBwYXJhbSB7c3RyaW5nfEJ1ZmZlcn0gY29udGVudCBGaWxlIGNvbnRlbnRzLlxuICovXG5TdGFuZGFyZEVycm9yLnByb3RvdHlwZS5zZXRDb250ZW50ID0gZnVuY3Rpb24oY29udGVudCkge1xuICBpZiAocHJvY2Vzcy5zdGRlcnIuaXNUVFkpIHtcbiAgICBwcm9jZXNzLnN0ZGVyci53cml0ZShjb250ZW50KTtcbiAgfVxufTtcblxuZXhwb3J0cy5TdGFuZGFyZEVycm9yID0gU3RhbmRhcmRFcnJvcjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/mock-fs/lib/file.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/mock-fs/lib/filesystem.js":
/*!****************************************************!*\
  !*** ../../node_modules/mock-fs/lib/filesystem.js ***!
  \****************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\n\nconst os = __webpack_require__(/*! os */ \"os\");\nconst path = __webpack_require__(/*! path */ \"path\");\n\nconst Directory = __webpack_require__(/*! ./directory */ \"(rsc)/../../node_modules/mock-fs/lib/directory.js\");\nconst File = __webpack_require__(/*! ./file */ \"(rsc)/../../node_modules/mock-fs/lib/file.js\");\nconst FSError = __webpack_require__(/*! ./error */ \"(rsc)/../../node_modules/mock-fs/lib/error.js\");\nconst SymbolicLink = __webpack_require__(/*! ./symlink */ \"(rsc)/../../node_modules/mock-fs/lib/symlink.js\");\n\nconst isWindows = process.platform === 'win32';\n\nfunction toNamespacedPath(filePath) {\n  return path.toNamespacedPath\n    ? path.toNamespacedPath(filePath)\n    : path._makeLong(filePath);\n}\n\nfunction getPathParts(filepath) {\n  const parts = toNamespacedPath(path.resolve(filepath)).split(path.sep);\n  parts.shift();\n  if (isWindows) {\n    // parts currently looks like ['', '?', 'c:', ...]\n    parts.shift();\n    const q = parts.shift(); // should be '?'\n    const base = '\\\\\\\\' + q + '\\\\' + parts.shift().toLowerCase();\n    parts.unshift(base);\n  }\n  if (parts[parts.length - 1] === '') {\n    parts.pop();\n  }\n  return parts;\n}\n\n/**\n * Create a new file system.\n * @param {Object} options Any filesystem options.\n * @param {boolean} options.createCwd Create a directory for `process.cwd()`\n *     (defaults to `true`).\n * @param {boolean} options.createTmp Create a directory for `os.tmpdir()`\n *     (defaults to `true`).\n * @constructor\n */\nfunction FileSystem(options) {\n  options = options || {};\n\n  const createCwd = 'createCwd' in options ? options.createCwd : true;\n  const createTmp = 'createTmp' in options ? options.createTmp : true;\n\n  const root = new Directory();\n\n  // populate with default directories\n  const defaults = [];\n  if (createCwd) {\n    defaults.push(process.cwd());\n  }\n\n  if (createTmp) {\n    defaults.push((os.tmpdir && os.tmpdir()) || os.tmpDir());\n  }\n\n  defaults.forEach(function(dir) {\n    const parts = getPathParts(dir);\n    let directory = root;\n    for (let i = 0, ii = parts.length; i < ii; ++i) {\n      const name = parts[i];\n      const candidate = directory.getItem(name);\n      if (!candidate) {\n        directory = directory.addItem(name, new Directory());\n      } else if (candidate instanceof Directory) {\n        directory = candidate;\n      } else {\n        throw new Error('Failed to create directory: ' + dir);\n      }\n    }\n  });\n\n  /**\n   * Root directory.\n   * @type {Directory}\n   */\n  this._root = root;\n}\n\n/**\n * Get the root directory.\n * @return {Directory} The root directory.\n */\nFileSystem.prototype.getRoot = function() {\n  return this._root;\n};\n\n/**\n * Get a file system item.\n * @param {string} filepath Path to item.\n * @return {Item} The item (or null if not found).\n */\nFileSystem.prototype.getItem = function(filepath) {\n  const parts = getPathParts(filepath);\n  const currentParts = getPathParts(process.cwd());\n  let item = this._root;\n  let itemPath = '/';\n  for (let i = 0, ii = parts.length; i < ii; ++i) {\n    const name = parts[i];\n    while (item instanceof SymbolicLink) {\n      // Symbolic link being traversed as a directory --- If link targets\n      // another symbolic link, resolve target's path relative to the original\n      // link's target, otherwise relative to the current item.\n      itemPath = path.resolve(path.dirname(itemPath), item.getPath());\n      item = this.getItem(itemPath);\n    }\n    if (item) {\n      if (item instanceof Directory && name !== currentParts[i]) {\n        // make sure traversal is allowed\n        // This fails for Windows directories which do not have execute permission, by default. It may be a good idea\n        // to change this logic to windows-friendly. See notes in mock.createDirectoryInfoFromPaths()\n        if (!item.canExecute()) {\n          throw new FSError('EACCES', filepath);\n        }\n      }\n      if (item instanceof File) {\n        throw new FSError('ENOTDIR', filepath);\n      }\n      item = item.getItem(name);\n    }\n    if (!item) {\n      break;\n    }\n    itemPath = path.resolve(itemPath, name);\n  }\n  return item;\n};\n\n/**\n * Populate a directory with an item.\n * @param {Directory} directory The directory to populate.\n * @param {string} name The name of the item.\n * @param {string|Buffer|function|Object} obj Instructions for creating the\n *     item.\n */\nfunction populate(directory, name, obj) {\n  let item;\n  if (typeof obj === 'string' || Buffer.isBuffer(obj)) {\n    // contents for a file\n    item = new File();\n    item.setContent(obj);\n  } else if (typeof obj === 'function') {\n    // item factory\n    item = obj();\n  } else if (typeof obj === 'object') {\n    // directory with more to populate\n    item = new Directory();\n    for (const key in obj) {\n      populate(item, key, obj[key]);\n    }\n  } else {\n    throw new Error('Unsupported type: ' + typeof obj + ' of item ' + name);\n  }\n\n  /**\n   * Special exception for redundant adding of empty directories.\n   */\n  if (\n    item instanceof Directory &&\n    item.list().length === 0 &&\n    directory.getItem(name) instanceof Directory\n  ) {\n    // pass\n  } else {\n    directory.addItem(name, item);\n  }\n}\n\n/**\n * Configure a mock file system.\n * @param {Object} paths Config object.\n * @param {Object} options Any filesystem options.\n * @param {boolean} options.createCwd Create a directory for `process.cwd()`\n *     (defaults to `true`).\n * @param {boolean} options.createTmp Create a directory for `os.tmpdir()`\n *     (defaults to `true`).\n * @return {FileSystem} Mock file system.\n */\nFileSystem.create = function(paths, options) {\n  const system = new FileSystem(options);\n\n  for (const filepath in paths) {\n    const parts = getPathParts(filepath);\n    let directory = system._root;\n    for (let i = 0, ii = parts.length - 1; i < ii; ++i) {\n      const name = parts[i];\n      const candidate = directory.getItem(name);\n      if (!candidate) {\n        directory = directory.addItem(name, new Directory());\n      } else if (candidate instanceof Directory) {\n        directory = candidate;\n      } else {\n        throw new Error('Failed to create directory: ' + filepath);\n      }\n    }\n    populate(directory, parts[parts.length - 1], paths[filepath]);\n  }\n\n  return system;\n};\n\n/**\n * Generate a factory for new files.\n * @param {Object} config File config.\n * @return {function():File} Factory that creates a new file.\n */\nFileSystem.file = function(config) {\n  config = config || {};\n  return function() {\n    const file = new File();\n    if (config.hasOwnProperty('content')) {\n      file.setContent(config.content);\n    }\n    if (config.hasOwnProperty('mode')) {\n      file.setMode(config.mode);\n    } else {\n      file.setMode(438); // 0666\n    }\n    if (config.hasOwnProperty('uid')) {\n      file.setUid(config.uid);\n    }\n    if (config.hasOwnProperty('gid')) {\n      file.setGid(config.gid);\n    }\n    if (config.hasOwnProperty('atime')) {\n      file.setATime(config.atime);\n    }\n    if (config.hasOwnProperty('ctime')) {\n      file.setCTime(config.ctime);\n    }\n    if (config.hasOwnProperty('mtime')) {\n      file.setMTime(config.mtime);\n    }\n    if (config.hasOwnProperty('birthtime')) {\n      file.setBirthtime(config.birthtime);\n    }\n    return file;\n  };\n};\n\n/**\n * Generate a factory for new symbolic links.\n * @param {Object} config File config.\n * @return {function():File} Factory that creates a new symbolic link.\n */\nFileSystem.symlink = function(config) {\n  config = config || {};\n  return function() {\n    const link = new SymbolicLink();\n    if (config.hasOwnProperty('mode')) {\n      link.setMode(config.mode);\n    } else {\n      link.setMode(438); // 0666\n    }\n    if (config.hasOwnProperty('uid')) {\n      link.setUid(config.uid);\n    }\n    if (config.hasOwnProperty('gid')) {\n      link.setGid(config.gid);\n    }\n    if (config.hasOwnProperty('path')) {\n      link.setPath(config.path);\n    } else {\n      throw new Error('Missing \"path\" property');\n    }\n    if (config.hasOwnProperty('atime')) {\n      link.setATime(config.atime);\n    }\n    if (config.hasOwnProperty('ctime')) {\n      link.setCTime(config.ctime);\n    }\n    if (config.hasOwnProperty('mtime')) {\n      link.setMTime(config.mtime);\n    }\n    if (config.hasOwnProperty('birthtime')) {\n      link.setBirthtime(config.birthtime);\n    }\n    return link;\n  };\n};\n\n/**\n * Generate a factory for new directories.\n * @param {Object} config File config.\n * @return {function():Directory} Factory that creates a new directory.\n */\nFileSystem.directory = function(config) {\n  config = config || {};\n  return function() {\n    const dir = new Directory();\n    if (config.hasOwnProperty('mode')) {\n      dir.setMode(config.mode);\n    }\n    if (config.hasOwnProperty('uid')) {\n      dir.setUid(config.uid);\n    }\n    if (config.hasOwnProperty('gid')) {\n      dir.setGid(config.gid);\n    }\n    if (config.hasOwnProperty('items')) {\n      for (const name in config.items) {\n        populate(dir, name, config.items[name]);\n      }\n    }\n    if (config.hasOwnProperty('atime')) {\n      dir.setATime(config.atime);\n    }\n    if (config.hasOwnProperty('ctime')) {\n      dir.setCTime(config.ctime);\n    }\n    if (config.hasOwnProperty('mtime')) {\n      dir.setMTime(config.mtime);\n    }\n    if (config.hasOwnProperty('birthtime')) {\n      dir.setBirthtime(config.birthtime);\n    }\n    return dir;\n  };\n};\n\n/**\n * Module exports.\n * @type {function}\n */\nexports = module.exports = FileSystem;\nexports.getPathParts = getPathParts;\nexports.toNamespacedPath = toNamespacedPath;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL21vY2stZnMvbGliL2ZpbGVzeXN0ZW0uanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsV0FBVyxtQkFBTyxDQUFDLGNBQUk7QUFDdkIsYUFBYSxtQkFBTyxDQUFDLGtCQUFNOztBQUUzQixrQkFBa0IsbUJBQU8sQ0FBQyxzRUFBYTtBQUN2QyxhQUFhLG1CQUFPLENBQUMsNERBQVE7QUFDN0IsZ0JBQWdCLG1CQUFPLENBQUMsOERBQVM7QUFDakMscUJBQXFCLG1CQUFPLENBQUMsa0VBQVc7O0FBRXhDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEI7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxRQUFRO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksV0FBVztBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVksTUFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsUUFBUTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFdBQVc7QUFDdEIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsK0JBQStCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEI7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQSxZQUFZLFlBQVk7QUFDeEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxRQUFRO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVksaUJBQWlCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVksaUJBQWlCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVksc0JBQXNCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQix3QkFBd0IiLCJzb3VyY2VzIjpbIi9ob21lL2JhcmIvYWEvQXNzb2NpYXRlZEFjY291bnRzL25vZGVfbW9kdWxlcy9tb2NrLWZzL2xpYi9maWxlc3lzdGVtLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3Qgb3MgPSByZXF1aXJlKCdvcycpO1xuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcblxuY29uc3QgRGlyZWN0b3J5ID0gcmVxdWlyZSgnLi9kaXJlY3RvcnknKTtcbmNvbnN0IEZpbGUgPSByZXF1aXJlKCcuL2ZpbGUnKTtcbmNvbnN0IEZTRXJyb3IgPSByZXF1aXJlKCcuL2Vycm9yJyk7XG5jb25zdCBTeW1ib2xpY0xpbmsgPSByZXF1aXJlKCcuL3N5bWxpbmsnKTtcblxuY29uc3QgaXNXaW5kb3dzID0gcHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJztcblxuZnVuY3Rpb24gdG9OYW1lc3BhY2VkUGF0aChmaWxlUGF0aCkge1xuICByZXR1cm4gcGF0aC50b05hbWVzcGFjZWRQYXRoXG4gICAgPyBwYXRoLnRvTmFtZXNwYWNlZFBhdGgoZmlsZVBhdGgpXG4gICAgOiBwYXRoLl9tYWtlTG9uZyhmaWxlUGF0aCk7XG59XG5cbmZ1bmN0aW9uIGdldFBhdGhQYXJ0cyhmaWxlcGF0aCkge1xuICBjb25zdCBwYXJ0cyA9IHRvTmFtZXNwYWNlZFBhdGgocGF0aC5yZXNvbHZlKGZpbGVwYXRoKSkuc3BsaXQocGF0aC5zZXApO1xuICBwYXJ0cy5zaGlmdCgpO1xuICBpZiAoaXNXaW5kb3dzKSB7XG4gICAgLy8gcGFydHMgY3VycmVudGx5IGxvb2tzIGxpa2UgWycnLCAnPycsICdjOicsIC4uLl1cbiAgICBwYXJ0cy5zaGlmdCgpO1xuICAgIGNvbnN0IHEgPSBwYXJ0cy5zaGlmdCgpOyAvLyBzaG91bGQgYmUgJz8nXG4gICAgY29uc3QgYmFzZSA9ICdcXFxcXFxcXCcgKyBxICsgJ1xcXFwnICsgcGFydHMuc2hpZnQoKS50b0xvd2VyQ2FzZSgpO1xuICAgIHBhcnRzLnVuc2hpZnQoYmFzZSk7XG4gIH1cbiAgaWYgKHBhcnRzW3BhcnRzLmxlbmd0aCAtIDFdID09PSAnJykge1xuICAgIHBhcnRzLnBvcCgpO1xuICB9XG4gIHJldHVybiBwYXJ0cztcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgZmlsZSBzeXN0ZW0uXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBBbnkgZmlsZXN5c3RlbSBvcHRpb25zLlxuICogQHBhcmFtIHtib29sZWFufSBvcHRpb25zLmNyZWF0ZUN3ZCBDcmVhdGUgYSBkaXJlY3RvcnkgZm9yIGBwcm9jZXNzLmN3ZCgpYFxuICogICAgIChkZWZhdWx0cyB0byBgdHJ1ZWApLlxuICogQHBhcmFtIHtib29sZWFufSBvcHRpb25zLmNyZWF0ZVRtcCBDcmVhdGUgYSBkaXJlY3RvcnkgZm9yIGBvcy50bXBkaXIoKWBcbiAqICAgICAoZGVmYXVsdHMgdG8gYHRydWVgKS5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBGaWxlU3lzdGVtKG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgY29uc3QgY3JlYXRlQ3dkID0gJ2NyZWF0ZUN3ZCcgaW4gb3B0aW9ucyA/IG9wdGlvbnMuY3JlYXRlQ3dkIDogdHJ1ZTtcbiAgY29uc3QgY3JlYXRlVG1wID0gJ2NyZWF0ZVRtcCcgaW4gb3B0aW9ucyA/IG9wdGlvbnMuY3JlYXRlVG1wIDogdHJ1ZTtcblxuICBjb25zdCByb290ID0gbmV3IERpcmVjdG9yeSgpO1xuXG4gIC8vIHBvcHVsYXRlIHdpdGggZGVmYXVsdCBkaXJlY3Rvcmllc1xuICBjb25zdCBkZWZhdWx0cyA9IFtdO1xuICBpZiAoY3JlYXRlQ3dkKSB7XG4gICAgZGVmYXVsdHMucHVzaChwcm9jZXNzLmN3ZCgpKTtcbiAgfVxuXG4gIGlmIChjcmVhdGVUbXApIHtcbiAgICBkZWZhdWx0cy5wdXNoKChvcy50bXBkaXIgJiYgb3MudG1wZGlyKCkpIHx8IG9zLnRtcERpcigpKTtcbiAgfVxuXG4gIGRlZmF1bHRzLmZvckVhY2goZnVuY3Rpb24oZGlyKSB7XG4gICAgY29uc3QgcGFydHMgPSBnZXRQYXRoUGFydHMoZGlyKTtcbiAgICBsZXQgZGlyZWN0b3J5ID0gcm9vdDtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBwYXJ0cy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICBjb25zdCBuYW1lID0gcGFydHNbaV07XG4gICAgICBjb25zdCBjYW5kaWRhdGUgPSBkaXJlY3RvcnkuZ2V0SXRlbShuYW1lKTtcbiAgICAgIGlmICghY2FuZGlkYXRlKSB7XG4gICAgICAgIGRpcmVjdG9yeSA9IGRpcmVjdG9yeS5hZGRJdGVtKG5hbWUsIG5ldyBEaXJlY3RvcnkoKSk7XG4gICAgICB9IGVsc2UgaWYgKGNhbmRpZGF0ZSBpbnN0YW5jZW9mIERpcmVjdG9yeSkge1xuICAgICAgICBkaXJlY3RvcnkgPSBjYW5kaWRhdGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBjcmVhdGUgZGlyZWN0b3J5OiAnICsgZGlyKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBSb290IGRpcmVjdG9yeS5cbiAgICogQHR5cGUge0RpcmVjdG9yeX1cbiAgICovXG4gIHRoaXMuX3Jvb3QgPSByb290O1xufVxuXG4vKipcbiAqIEdldCB0aGUgcm9vdCBkaXJlY3RvcnkuXG4gKiBAcmV0dXJuIHtEaXJlY3Rvcnl9IFRoZSByb290IGRpcmVjdG9yeS5cbiAqL1xuRmlsZVN5c3RlbS5wcm90b3R5cGUuZ2V0Um9vdCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fcm9vdDtcbn07XG5cbi8qKlxuICogR2V0IGEgZmlsZSBzeXN0ZW0gaXRlbS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBmaWxlcGF0aCBQYXRoIHRvIGl0ZW0uXG4gKiBAcmV0dXJuIHtJdGVtfSBUaGUgaXRlbSAob3IgbnVsbCBpZiBub3QgZm91bmQpLlxuICovXG5GaWxlU3lzdGVtLnByb3RvdHlwZS5nZXRJdGVtID0gZnVuY3Rpb24oZmlsZXBhdGgpIHtcbiAgY29uc3QgcGFydHMgPSBnZXRQYXRoUGFydHMoZmlsZXBhdGgpO1xuICBjb25zdCBjdXJyZW50UGFydHMgPSBnZXRQYXRoUGFydHMocHJvY2Vzcy5jd2QoKSk7XG4gIGxldCBpdGVtID0gdGhpcy5fcm9vdDtcbiAgbGV0IGl0ZW1QYXRoID0gJy8nO1xuICBmb3IgKGxldCBpID0gMCwgaWkgPSBwYXJ0cy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgY29uc3QgbmFtZSA9IHBhcnRzW2ldO1xuICAgIHdoaWxlIChpdGVtIGluc3RhbmNlb2YgU3ltYm9saWNMaW5rKSB7XG4gICAgICAvLyBTeW1ib2xpYyBsaW5rIGJlaW5nIHRyYXZlcnNlZCBhcyBhIGRpcmVjdG9yeSAtLS0gSWYgbGluayB0YXJnZXRzXG4gICAgICAvLyBhbm90aGVyIHN5bWJvbGljIGxpbmssIHJlc29sdmUgdGFyZ2V0J3MgcGF0aCByZWxhdGl2ZSB0byB0aGUgb3JpZ2luYWxcbiAgICAgIC8vIGxpbmsncyB0YXJnZXQsIG90aGVyd2lzZSByZWxhdGl2ZSB0byB0aGUgY3VycmVudCBpdGVtLlxuICAgICAgaXRlbVBhdGggPSBwYXRoLnJlc29sdmUocGF0aC5kaXJuYW1lKGl0ZW1QYXRoKSwgaXRlbS5nZXRQYXRoKCkpO1xuICAgICAgaXRlbSA9IHRoaXMuZ2V0SXRlbShpdGVtUGF0aCk7XG4gICAgfVxuICAgIGlmIChpdGVtKSB7XG4gICAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIERpcmVjdG9yeSAmJiBuYW1lICE9PSBjdXJyZW50UGFydHNbaV0pIHtcbiAgICAgICAgLy8gbWFrZSBzdXJlIHRyYXZlcnNhbCBpcyBhbGxvd2VkXG4gICAgICAgIC8vIFRoaXMgZmFpbHMgZm9yIFdpbmRvd3MgZGlyZWN0b3JpZXMgd2hpY2ggZG8gbm90IGhhdmUgZXhlY3V0ZSBwZXJtaXNzaW9uLCBieSBkZWZhdWx0LiBJdCBtYXkgYmUgYSBnb29kIGlkZWFcbiAgICAgICAgLy8gdG8gY2hhbmdlIHRoaXMgbG9naWMgdG8gd2luZG93cy1mcmllbmRseS4gU2VlIG5vdGVzIGluIG1vY2suY3JlYXRlRGlyZWN0b3J5SW5mb0Zyb21QYXRocygpXG4gICAgICAgIGlmICghaXRlbS5jYW5FeGVjdXRlKCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlNFcnJvcignRUFDQ0VTJywgZmlsZXBhdGgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIEZpbGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEZTRXJyb3IoJ0VOT1RESVInLCBmaWxlcGF0aCk7XG4gICAgICB9XG4gICAgICBpdGVtID0gaXRlbS5nZXRJdGVtKG5hbWUpO1xuICAgIH1cbiAgICBpZiAoIWl0ZW0pIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpdGVtUGF0aCA9IHBhdGgucmVzb2x2ZShpdGVtUGF0aCwgbmFtZSk7XG4gIH1cbiAgcmV0dXJuIGl0ZW07XG59O1xuXG4vKipcbiAqIFBvcHVsYXRlIGEgZGlyZWN0b3J5IHdpdGggYW4gaXRlbS5cbiAqIEBwYXJhbSB7RGlyZWN0b3J5fSBkaXJlY3RvcnkgVGhlIGRpcmVjdG9yeSB0byBwb3B1bGF0ZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBpdGVtLlxuICogQHBhcmFtIHtzdHJpbmd8QnVmZmVyfGZ1bmN0aW9ufE9iamVjdH0gb2JqIEluc3RydWN0aW9ucyBmb3IgY3JlYXRpbmcgdGhlXG4gKiAgICAgaXRlbS5cbiAqL1xuZnVuY3Rpb24gcG9wdWxhdGUoZGlyZWN0b3J5LCBuYW1lLCBvYmopIHtcbiAgbGV0IGl0ZW07XG4gIGlmICh0eXBlb2Ygb2JqID09PSAnc3RyaW5nJyB8fCBCdWZmZXIuaXNCdWZmZXIob2JqKSkge1xuICAgIC8vIGNvbnRlbnRzIGZvciBhIGZpbGVcbiAgICBpdGVtID0gbmV3IEZpbGUoKTtcbiAgICBpdGVtLnNldENvbnRlbnQob2JqKTtcbiAgfSBlbHNlIGlmICh0eXBlb2Ygb2JqID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gaXRlbSBmYWN0b3J5XG4gICAgaXRlbSA9IG9iaigpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnKSB7XG4gICAgLy8gZGlyZWN0b3J5IHdpdGggbW9yZSB0byBwb3B1bGF0ZVxuICAgIGl0ZW0gPSBuZXcgRGlyZWN0b3J5KCk7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XG4gICAgICBwb3B1bGF0ZShpdGVtLCBrZXksIG9ialtrZXldKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCB0eXBlOiAnICsgdHlwZW9mIG9iaiArICcgb2YgaXRlbSAnICsgbmFtZSk7XG4gIH1cblxuICAvKipcbiAgICogU3BlY2lhbCBleGNlcHRpb24gZm9yIHJlZHVuZGFudCBhZGRpbmcgb2YgZW1wdHkgZGlyZWN0b3JpZXMuXG4gICAqL1xuICBpZiAoXG4gICAgaXRlbSBpbnN0YW5jZW9mIERpcmVjdG9yeSAmJlxuICAgIGl0ZW0ubGlzdCgpLmxlbmd0aCA9PT0gMCAmJlxuICAgIGRpcmVjdG9yeS5nZXRJdGVtKG5hbWUpIGluc3RhbmNlb2YgRGlyZWN0b3J5XG4gICkge1xuICAgIC8vIHBhc3NcbiAgfSBlbHNlIHtcbiAgICBkaXJlY3RvcnkuYWRkSXRlbShuYW1lLCBpdGVtKTtcbiAgfVxufVxuXG4vKipcbiAqIENvbmZpZ3VyZSBhIG1vY2sgZmlsZSBzeXN0ZW0uXG4gKiBAcGFyYW0ge09iamVjdH0gcGF0aHMgQ29uZmlnIG9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIEFueSBmaWxlc3lzdGVtIG9wdGlvbnMuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMuY3JlYXRlQ3dkIENyZWF0ZSBhIGRpcmVjdG9yeSBmb3IgYHByb2Nlc3MuY3dkKClgXG4gKiAgICAgKGRlZmF1bHRzIHRvIGB0cnVlYCkuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMuY3JlYXRlVG1wIENyZWF0ZSBhIGRpcmVjdG9yeSBmb3IgYG9zLnRtcGRpcigpYFxuICogICAgIChkZWZhdWx0cyB0byBgdHJ1ZWApLlxuICogQHJldHVybiB7RmlsZVN5c3RlbX0gTW9jayBmaWxlIHN5c3RlbS5cbiAqL1xuRmlsZVN5c3RlbS5jcmVhdGUgPSBmdW5jdGlvbihwYXRocywgb3B0aW9ucykge1xuICBjb25zdCBzeXN0ZW0gPSBuZXcgRmlsZVN5c3RlbShvcHRpb25zKTtcblxuICBmb3IgKGNvbnN0IGZpbGVwYXRoIGluIHBhdGhzKSB7XG4gICAgY29uc3QgcGFydHMgPSBnZXRQYXRoUGFydHMoZmlsZXBhdGgpO1xuICAgIGxldCBkaXJlY3RvcnkgPSBzeXN0ZW0uX3Jvb3Q7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gcGFydHMubGVuZ3RoIC0gMTsgaSA8IGlpOyArK2kpIHtcbiAgICAgIGNvbnN0IG5hbWUgPSBwYXJ0c1tpXTtcbiAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IGRpcmVjdG9yeS5nZXRJdGVtKG5hbWUpO1xuICAgICAgaWYgKCFjYW5kaWRhdGUpIHtcbiAgICAgICAgZGlyZWN0b3J5ID0gZGlyZWN0b3J5LmFkZEl0ZW0obmFtZSwgbmV3IERpcmVjdG9yeSgpKTtcbiAgICAgIH0gZWxzZSBpZiAoY2FuZGlkYXRlIGluc3RhbmNlb2YgRGlyZWN0b3J5KSB7XG4gICAgICAgIGRpcmVjdG9yeSA9IGNhbmRpZGF0ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGNyZWF0ZSBkaXJlY3Rvcnk6ICcgKyBmaWxlcGF0aCk7XG4gICAgICB9XG4gICAgfVxuICAgIHBvcHVsYXRlKGRpcmVjdG9yeSwgcGFydHNbcGFydHMubGVuZ3RoIC0gMV0sIHBhdGhzW2ZpbGVwYXRoXSk7XG4gIH1cblxuICByZXR1cm4gc3lzdGVtO1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZSBhIGZhY3RvcnkgZm9yIG5ldyBmaWxlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgRmlsZSBjb25maWcuXG4gKiBAcmV0dXJuIHtmdW5jdGlvbigpOkZpbGV9IEZhY3RvcnkgdGhhdCBjcmVhdGVzIGEgbmV3IGZpbGUuXG4gKi9cbkZpbGVTeXN0ZW0uZmlsZSA9IGZ1bmN0aW9uKGNvbmZpZykge1xuICBjb25maWcgPSBjb25maWcgfHwge307XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICBjb25zdCBmaWxlID0gbmV3IEZpbGUoKTtcbiAgICBpZiAoY29uZmlnLmhhc093blByb3BlcnR5KCdjb250ZW50JykpIHtcbiAgICAgIGZpbGUuc2V0Q29udGVudChjb25maWcuY29udGVudCk7XG4gICAgfVxuICAgIGlmIChjb25maWcuaGFzT3duUHJvcGVydHkoJ21vZGUnKSkge1xuICAgICAgZmlsZS5zZXRNb2RlKGNvbmZpZy5tb2RlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZmlsZS5zZXRNb2RlKDQzOCk7IC8vIDA2NjZcbiAgICB9XG4gICAgaWYgKGNvbmZpZy5oYXNPd25Qcm9wZXJ0eSgndWlkJykpIHtcbiAgICAgIGZpbGUuc2V0VWlkKGNvbmZpZy51aWQpO1xuICAgIH1cbiAgICBpZiAoY29uZmlnLmhhc093blByb3BlcnR5KCdnaWQnKSkge1xuICAgICAgZmlsZS5zZXRHaWQoY29uZmlnLmdpZCk7XG4gICAgfVxuICAgIGlmIChjb25maWcuaGFzT3duUHJvcGVydHkoJ2F0aW1lJykpIHtcbiAgICAgIGZpbGUuc2V0QVRpbWUoY29uZmlnLmF0aW1lKTtcbiAgICB9XG4gICAgaWYgKGNvbmZpZy5oYXNPd25Qcm9wZXJ0eSgnY3RpbWUnKSkge1xuICAgICAgZmlsZS5zZXRDVGltZShjb25maWcuY3RpbWUpO1xuICAgIH1cbiAgICBpZiAoY29uZmlnLmhhc093blByb3BlcnR5KCdtdGltZScpKSB7XG4gICAgICBmaWxlLnNldE1UaW1lKGNvbmZpZy5tdGltZSk7XG4gICAgfVxuICAgIGlmIChjb25maWcuaGFzT3duUHJvcGVydHkoJ2JpcnRodGltZScpKSB7XG4gICAgICBmaWxlLnNldEJpcnRodGltZShjb25maWcuYmlydGh0aW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIGZpbGU7XG4gIH07XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlIGEgZmFjdG9yeSBmb3IgbmV3IHN5bWJvbGljIGxpbmtzLlxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBGaWxlIGNvbmZpZy5cbiAqIEByZXR1cm4ge2Z1bmN0aW9uKCk6RmlsZX0gRmFjdG9yeSB0aGF0IGNyZWF0ZXMgYSBuZXcgc3ltYm9saWMgbGluay5cbiAqL1xuRmlsZVN5c3RlbS5zeW1saW5rID0gZnVuY3Rpb24oY29uZmlnKSB7XG4gIGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIGNvbnN0IGxpbmsgPSBuZXcgU3ltYm9saWNMaW5rKCk7XG4gICAgaWYgKGNvbmZpZy5oYXNPd25Qcm9wZXJ0eSgnbW9kZScpKSB7XG4gICAgICBsaW5rLnNldE1vZGUoY29uZmlnLm1vZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsaW5rLnNldE1vZGUoNDM4KTsgLy8gMDY2NlxuICAgIH1cbiAgICBpZiAoY29uZmlnLmhhc093blByb3BlcnR5KCd1aWQnKSkge1xuICAgICAgbGluay5zZXRVaWQoY29uZmlnLnVpZCk7XG4gICAgfVxuICAgIGlmIChjb25maWcuaGFzT3duUHJvcGVydHkoJ2dpZCcpKSB7XG4gICAgICBsaW5rLnNldEdpZChjb25maWcuZ2lkKTtcbiAgICB9XG4gICAgaWYgKGNvbmZpZy5oYXNPd25Qcm9wZXJ0eSgncGF0aCcpKSB7XG4gICAgICBsaW5rLnNldFBhdGgoY29uZmlnLnBhdGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgXCJwYXRoXCIgcHJvcGVydHknKTtcbiAgICB9XG4gICAgaWYgKGNvbmZpZy5oYXNPd25Qcm9wZXJ0eSgnYXRpbWUnKSkge1xuICAgICAgbGluay5zZXRBVGltZShjb25maWcuYXRpbWUpO1xuICAgIH1cbiAgICBpZiAoY29uZmlnLmhhc093blByb3BlcnR5KCdjdGltZScpKSB7XG4gICAgICBsaW5rLnNldENUaW1lKGNvbmZpZy5jdGltZSk7XG4gICAgfVxuICAgIGlmIChjb25maWcuaGFzT3duUHJvcGVydHkoJ210aW1lJykpIHtcbiAgICAgIGxpbmsuc2V0TVRpbWUoY29uZmlnLm10aW1lKTtcbiAgICB9XG4gICAgaWYgKGNvbmZpZy5oYXNPd25Qcm9wZXJ0eSgnYmlydGh0aW1lJykpIHtcbiAgICAgIGxpbmsuc2V0QmlydGh0aW1lKGNvbmZpZy5iaXJ0aHRpbWUpO1xuICAgIH1cbiAgICByZXR1cm4gbGluaztcbiAgfTtcbn07XG5cbi8qKlxuICogR2VuZXJhdGUgYSBmYWN0b3J5IGZvciBuZXcgZGlyZWN0b3JpZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIEZpbGUgY29uZmlnLlxuICogQHJldHVybiB7ZnVuY3Rpb24oKTpEaXJlY3Rvcnl9IEZhY3RvcnkgdGhhdCBjcmVhdGVzIGEgbmV3IGRpcmVjdG9yeS5cbiAqL1xuRmlsZVN5c3RlbS5kaXJlY3RvcnkgPSBmdW5jdGlvbihjb25maWcpIHtcbiAgY29uZmlnID0gY29uZmlnIHx8IHt9O1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgY29uc3QgZGlyID0gbmV3IERpcmVjdG9yeSgpO1xuICAgIGlmIChjb25maWcuaGFzT3duUHJvcGVydHkoJ21vZGUnKSkge1xuICAgICAgZGlyLnNldE1vZGUoY29uZmlnLm1vZGUpO1xuICAgIH1cbiAgICBpZiAoY29uZmlnLmhhc093blByb3BlcnR5KCd1aWQnKSkge1xuICAgICAgZGlyLnNldFVpZChjb25maWcudWlkKTtcbiAgICB9XG4gICAgaWYgKGNvbmZpZy5oYXNPd25Qcm9wZXJ0eSgnZ2lkJykpIHtcbiAgICAgIGRpci5zZXRHaWQoY29uZmlnLmdpZCk7XG4gICAgfVxuICAgIGlmIChjb25maWcuaGFzT3duUHJvcGVydHkoJ2l0ZW1zJykpIHtcbiAgICAgIGZvciAoY29uc3QgbmFtZSBpbiBjb25maWcuaXRlbXMpIHtcbiAgICAgICAgcG9wdWxhdGUoZGlyLCBuYW1lLCBjb25maWcuaXRlbXNbbmFtZV0pO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoY29uZmlnLmhhc093blByb3BlcnR5KCdhdGltZScpKSB7XG4gICAgICBkaXIuc2V0QVRpbWUoY29uZmlnLmF0aW1lKTtcbiAgICB9XG4gICAgaWYgKGNvbmZpZy5oYXNPd25Qcm9wZXJ0eSgnY3RpbWUnKSkge1xuICAgICAgZGlyLnNldENUaW1lKGNvbmZpZy5jdGltZSk7XG4gICAgfVxuICAgIGlmIChjb25maWcuaGFzT3duUHJvcGVydHkoJ210aW1lJykpIHtcbiAgICAgIGRpci5zZXRNVGltZShjb25maWcubXRpbWUpO1xuICAgIH1cbiAgICBpZiAoY29uZmlnLmhhc093blByb3BlcnR5KCdiaXJ0aHRpbWUnKSkge1xuICAgICAgZGlyLnNldEJpcnRodGltZShjb25maWcuYmlydGh0aW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIGRpcjtcbiAgfTtcbn07XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKiBAdHlwZSB7ZnVuY3Rpb259XG4gKi9cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IEZpbGVTeXN0ZW07XG5leHBvcnRzLmdldFBhdGhQYXJ0cyA9IGdldFBhdGhQYXJ0cztcbmV4cG9ydHMudG9OYW1lc3BhY2VkUGF0aCA9IHRvTmFtZXNwYWNlZFBhdGg7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/mock-fs/lib/filesystem.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/mock-fs/lib/index.js":
/*!***********************************************!*\
  !*** ../../node_modules/mock-fs/lib/index.js ***!
  \***********************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\n\nconst Binding = __webpack_require__(/*! ./binding */ \"(rsc)/../../node_modules/mock-fs/lib/binding.js\");\nconst FSError = __webpack_require__(/*! ./error */ \"(rsc)/../../node_modules/mock-fs/lib/error.js\");\nconst FileSystem = __webpack_require__(/*! ./filesystem */ \"(rsc)/../../node_modules/mock-fs/lib/filesystem.js\");\nconst realBinding = process.binding('fs');\nconst path = __webpack_require__(/*! path */ \"path\");\nconst loader = __webpack_require__(/*! ./loader */ \"(rsc)/../../node_modules/mock-fs/lib/loader.js\");\nconst bypass = __webpack_require__(/*! ./bypass */ \"(rsc)/../../node_modules/mock-fs/lib/bypass.js\");\nconst fs = __webpack_require__(/*! fs */ \"fs\");\n\nconst toNamespacedPath = FileSystem.toNamespacedPath;\n\nconst realProcessProps = {\n  cwd: process.cwd,\n  chdir: process.chdir\n};\nconst realCreateWriteStream = fs.createWriteStream;\nconst realStats = realBinding.Stats;\nconst realStatWatcher = realBinding.StatWatcher;\n\n/**\n * Pre-patch fs binding.\n * This allows mock-fs to work properly under nodejs v10+ readFile\n * As ReadFileContext nodejs v10+ implementation traps original binding methods:\n * const { FSReqWrap, close, read } = process.binding('fs');\n * Note this patch only solves issue for readFile, as the require of\n * ReadFileContext is delayed by readFile implementation.\n * if (!ReadFileContext) ReadFileContext = require('internal/fs/read_file_context')\n *\n * @param {string} key Property name.\n */\nfunction patch(key) {\n  const existingMethod = realBinding[key];\n  realBinding[key] = function() {\n    if (this._mockedBinding) {\n      return this._mockedBinding[key].apply(this._mockedBinding, arguments);\n    } else {\n      return existingMethod.apply(this, arguments);\n    }\n  }.bind(realBinding);\n}\n\nfor (const key in Binding.prototype) {\n  if (typeof realBinding[key] === 'function') {\n    // Stats and StatWatcher are constructors\n    if (key !== 'Stats' && key !== 'StatWatcher') {\n      patch(key);\n    }\n  }\n}\n\nfunction overrideBinding(binding) {\n  realBinding._mockedBinding = binding;\n}\n\nfunction overrideProcess(cwd, chdir) {\n  process.cwd = cwd;\n  process.chdir = chdir;\n}\n\n/**\n * Have to disable write stream _writev on nodejs v10+.\n *\n * nodejs v8 lib/fs.js\n * note binding.writeBuffers will use mock-fs patched writeBuffers.\n *\n *   const binding = process.binding('fs');\n *   function writev(fd, chunks, position, callback) {\n *     // ...\n *     binding.writeBuffers(fd, chunks, position, req);\n *   }\n *\n * nodejs v10+ lib/internal/fs/streams.js\n * note it uses original writeBuffers, bypassed mock-fs patched writeBuffers.\n *\n *  const {writeBuffers} = internalBinding('fs');\n *  function writev(fd, chunks, position, callback) {\n *    // ...\n *    writeBuffers(fd, chunks, position, req);\n *  }\n *\n * Luckily _writev is an optional method on Writeable stream implementation.\n * When _writev is missing, it will fall back to make multiple _write calls.\n */\nfunction overrideCreateWriteStream() {\n  fs.createWriteStream = function(path, options) {\n    const output = realCreateWriteStream(path, options);\n    // disable _writev, this will over shadow WriteStream.prototype._writev\n    if (realBinding._mockedBinding) {\n      output._writev = undefined;\n    }\n    return output;\n  };\n}\n\nfunction restoreBinding() {\n  delete realBinding._mockedBinding;\n  realBinding.Stats = realStats;\n  realBinding.StatWatcher = realStatWatcher;\n}\n\nfunction restoreProcess() {\n  for (const key in realProcessProps) {\n    process[key] = realProcessProps[key];\n  }\n}\n\nfunction restoreCreateWriteStream() {\n  fs.createWriteStream = realCreateWriteStream;\n}\n\n/**\n * Swap out the fs bindings for a mock file system.\n * @param {Object} config Mock file system configuration.\n * @param {Object} options Any filesystem options.\n * @param {boolean} options.createCwd Create a directory for `process.cwd()`\n *     (defaults to `true`).\n * @param {boolean} options.createTmp Create a directory for `os.tmpdir()`\n *     (defaults to `true`).\n */\nexports = module.exports = function mock(config, options) {\n  const system = FileSystem.create(config, options);\n  const binding = new Binding(system);\n\n  overrideBinding(binding);\n\n  let currentPath = process.cwd();\n  overrideProcess(\n    function cwd() {\n      if (realBinding._mockedBinding) {\n        return currentPath;\n      }\n      return realProcessProps.cwd();\n    },\n    function chdir(directory) {\n      if (realBinding._mockedBinding) {\n        if (!binding.stat(toNamespacedPath(directory)).isDirectory()) {\n          throw new FSError('ENOTDIR');\n        }\n        currentPath = path.resolve(currentPath, directory);\n      } else {\n        return realProcessProps.chdir(directory);\n      }\n    }\n  );\n\n  overrideCreateWriteStream();\n};\n\n/**\n * Get hold of the mocked filesystem's 'root'\n * If fs hasn't currently been replaced, this will return an empty object\n */\nexports.getMockRoot = function() {\n  if (realBinding._mockedBinding) {\n    return realBinding._mockedBinding.getSystem().getRoot();\n  } else {\n    return {};\n  }\n};\n\n/**\n * Restore the fs bindings for the real file system.\n */\nexports.restore = function() {\n  restoreBinding();\n  restoreProcess();\n  restoreCreateWriteStream();\n};\n\n/**\n * Create a file factory.\n */\nexports.file = FileSystem.file;\n\n/**\n * Create a directory factory.\n */\nexports.directory = FileSystem.directory;\n\n/**\n * Create a symbolic link factory.\n */\nexports.symlink = FileSystem.symlink;\n\n/**\n * Automatically maps specified paths (for use with `mock()`)\n */\nexports.load = loader.load;\n\n/**\n * Perform action, bypassing mock FS\n * @example\n * // This file exists on the real FS, not on the mocked FS\n * const filePath = '/path/file.json';\n * const data = mock.bypass(() => fs.readFileSync(filePath, 'utf-8'));\n */\nexports.bypass = bypass;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL21vY2stZnMvbGliL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLGdCQUFnQixtQkFBTyxDQUFDLGtFQUFXO0FBQ25DLGdCQUFnQixtQkFBTyxDQUFDLDhEQUFTO0FBQ2pDLG1CQUFtQixtQkFBTyxDQUFDLHdFQUFjO0FBQ3pDO0FBQ0EsYUFBYSxtQkFBTyxDQUFDLGtCQUFNO0FBQzNCLGVBQWUsbUJBQU8sQ0FBQyxnRUFBVTtBQUNqQyxlQUFlLG1CQUFPLENBQUMsZ0VBQVU7QUFDakMsV0FBVyxtQkFBTyxDQUFDLGNBQUk7O0FBRXZCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx5QkFBeUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQjtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZOztBQUVaO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0EsZUFBZTs7QUFFZjtBQUNBO0FBQ0E7QUFDQSxZQUFZOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyIsInNvdXJjZXMiOlsiL2hvbWUvYmFyYi9hYS9Bc3NvY2lhdGVkQWNjb3VudHMvbm9kZV9tb2R1bGVzL21vY2stZnMvbGliL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQmluZGluZyA9IHJlcXVpcmUoJy4vYmluZGluZycpO1xuY29uc3QgRlNFcnJvciA9IHJlcXVpcmUoJy4vZXJyb3InKTtcbmNvbnN0IEZpbGVTeXN0ZW0gPSByZXF1aXJlKCcuL2ZpbGVzeXN0ZW0nKTtcbmNvbnN0IHJlYWxCaW5kaW5nID0gcHJvY2Vzcy5iaW5kaW5nKCdmcycpO1xuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcbmNvbnN0IGxvYWRlciA9IHJlcXVpcmUoJy4vbG9hZGVyJyk7XG5jb25zdCBieXBhc3MgPSByZXF1aXJlKCcuL2J5cGFzcycpO1xuY29uc3QgZnMgPSByZXF1aXJlKCdmcycpO1xuXG5jb25zdCB0b05hbWVzcGFjZWRQYXRoID0gRmlsZVN5c3RlbS50b05hbWVzcGFjZWRQYXRoO1xuXG5jb25zdCByZWFsUHJvY2Vzc1Byb3BzID0ge1xuICBjd2Q6IHByb2Nlc3MuY3dkLFxuICBjaGRpcjogcHJvY2Vzcy5jaGRpclxufTtcbmNvbnN0IHJlYWxDcmVhdGVXcml0ZVN0cmVhbSA9IGZzLmNyZWF0ZVdyaXRlU3RyZWFtO1xuY29uc3QgcmVhbFN0YXRzID0gcmVhbEJpbmRpbmcuU3RhdHM7XG5jb25zdCByZWFsU3RhdFdhdGNoZXIgPSByZWFsQmluZGluZy5TdGF0V2F0Y2hlcjtcblxuLyoqXG4gKiBQcmUtcGF0Y2ggZnMgYmluZGluZy5cbiAqIFRoaXMgYWxsb3dzIG1vY2stZnMgdG8gd29yayBwcm9wZXJseSB1bmRlciBub2RlanMgdjEwKyByZWFkRmlsZVxuICogQXMgUmVhZEZpbGVDb250ZXh0IG5vZGVqcyB2MTArIGltcGxlbWVudGF0aW9uIHRyYXBzIG9yaWdpbmFsIGJpbmRpbmcgbWV0aG9kczpcbiAqIGNvbnN0IHsgRlNSZXFXcmFwLCBjbG9zZSwgcmVhZCB9ID0gcHJvY2Vzcy5iaW5kaW5nKCdmcycpO1xuICogTm90ZSB0aGlzIHBhdGNoIG9ubHkgc29sdmVzIGlzc3VlIGZvciByZWFkRmlsZSwgYXMgdGhlIHJlcXVpcmUgb2ZcbiAqIFJlYWRGaWxlQ29udGV4dCBpcyBkZWxheWVkIGJ5IHJlYWRGaWxlIGltcGxlbWVudGF0aW9uLlxuICogaWYgKCFSZWFkRmlsZUNvbnRleHQpIFJlYWRGaWxlQ29udGV4dCA9IHJlcXVpcmUoJ2ludGVybmFsL2ZzL3JlYWRfZmlsZV9jb250ZXh0JylcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFByb3BlcnR5IG5hbWUuXG4gKi9cbmZ1bmN0aW9uIHBhdGNoKGtleSkge1xuICBjb25zdCBleGlzdGluZ01ldGhvZCA9IHJlYWxCaW5kaW5nW2tleV07XG4gIHJlYWxCaW5kaW5nW2tleV0gPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5fbW9ja2VkQmluZGluZykge1xuICAgICAgcmV0dXJuIHRoaXMuX21vY2tlZEJpbmRpbmdba2V5XS5hcHBseSh0aGlzLl9tb2NrZWRCaW5kaW5nLCBhcmd1bWVudHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZXhpc3RpbmdNZXRob2QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gIH0uYmluZChyZWFsQmluZGluZyk7XG59XG5cbmZvciAoY29uc3Qga2V5IGluIEJpbmRpbmcucHJvdG90eXBlKSB7XG4gIGlmICh0eXBlb2YgcmVhbEJpbmRpbmdba2V5XSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIFN0YXRzIGFuZCBTdGF0V2F0Y2hlciBhcmUgY29uc3RydWN0b3JzXG4gICAgaWYgKGtleSAhPT0gJ1N0YXRzJyAmJiBrZXkgIT09ICdTdGF0V2F0Y2hlcicpIHtcbiAgICAgIHBhdGNoKGtleSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG92ZXJyaWRlQmluZGluZyhiaW5kaW5nKSB7XG4gIHJlYWxCaW5kaW5nLl9tb2NrZWRCaW5kaW5nID0gYmluZGluZztcbn1cblxuZnVuY3Rpb24gb3ZlcnJpZGVQcm9jZXNzKGN3ZCwgY2hkaXIpIHtcbiAgcHJvY2Vzcy5jd2QgPSBjd2Q7XG4gIHByb2Nlc3MuY2hkaXIgPSBjaGRpcjtcbn1cblxuLyoqXG4gKiBIYXZlIHRvIGRpc2FibGUgd3JpdGUgc3RyZWFtIF93cml0ZXYgb24gbm9kZWpzIHYxMCsuXG4gKlxuICogbm9kZWpzIHY4IGxpYi9mcy5qc1xuICogbm90ZSBiaW5kaW5nLndyaXRlQnVmZmVycyB3aWxsIHVzZSBtb2NrLWZzIHBhdGNoZWQgd3JpdGVCdWZmZXJzLlxuICpcbiAqICAgY29uc3QgYmluZGluZyA9IHByb2Nlc3MuYmluZGluZygnZnMnKTtcbiAqICAgZnVuY3Rpb24gd3JpdGV2KGZkLCBjaHVua3MsIHBvc2l0aW9uLCBjYWxsYmFjaykge1xuICogICAgIC8vIC4uLlxuICogICAgIGJpbmRpbmcud3JpdGVCdWZmZXJzKGZkLCBjaHVua3MsIHBvc2l0aW9uLCByZXEpO1xuICogICB9XG4gKlxuICogbm9kZWpzIHYxMCsgbGliL2ludGVybmFsL2ZzL3N0cmVhbXMuanNcbiAqIG5vdGUgaXQgdXNlcyBvcmlnaW5hbCB3cml0ZUJ1ZmZlcnMsIGJ5cGFzc2VkIG1vY2stZnMgcGF0Y2hlZCB3cml0ZUJ1ZmZlcnMuXG4gKlxuICogIGNvbnN0IHt3cml0ZUJ1ZmZlcnN9ID0gaW50ZXJuYWxCaW5kaW5nKCdmcycpO1xuICogIGZ1bmN0aW9uIHdyaXRldihmZCwgY2h1bmtzLCBwb3NpdGlvbiwgY2FsbGJhY2spIHtcbiAqICAgIC8vIC4uLlxuICogICAgd3JpdGVCdWZmZXJzKGZkLCBjaHVua3MsIHBvc2l0aW9uLCByZXEpO1xuICogIH1cbiAqXG4gKiBMdWNraWx5IF93cml0ZXYgaXMgYW4gb3B0aW9uYWwgbWV0aG9kIG9uIFdyaXRlYWJsZSBzdHJlYW0gaW1wbGVtZW50YXRpb24uXG4gKiBXaGVuIF93cml0ZXYgaXMgbWlzc2luZywgaXQgd2lsbCBmYWxsIGJhY2sgdG8gbWFrZSBtdWx0aXBsZSBfd3JpdGUgY2FsbHMuXG4gKi9cbmZ1bmN0aW9uIG92ZXJyaWRlQ3JlYXRlV3JpdGVTdHJlYW0oKSB7XG4gIGZzLmNyZWF0ZVdyaXRlU3RyZWFtID0gZnVuY3Rpb24ocGF0aCwgb3B0aW9ucykge1xuICAgIGNvbnN0IG91dHB1dCA9IHJlYWxDcmVhdGVXcml0ZVN0cmVhbShwYXRoLCBvcHRpb25zKTtcbiAgICAvLyBkaXNhYmxlIF93cml0ZXYsIHRoaXMgd2lsbCBvdmVyIHNoYWRvdyBXcml0ZVN0cmVhbS5wcm90b3R5cGUuX3dyaXRldlxuICAgIGlmIChyZWFsQmluZGluZy5fbW9ja2VkQmluZGluZykge1xuICAgICAgb3V0cHV0Ll93cml0ZXYgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiBvdXRwdXQ7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHJlc3RvcmVCaW5kaW5nKCkge1xuICBkZWxldGUgcmVhbEJpbmRpbmcuX21vY2tlZEJpbmRpbmc7XG4gIHJlYWxCaW5kaW5nLlN0YXRzID0gcmVhbFN0YXRzO1xuICByZWFsQmluZGluZy5TdGF0V2F0Y2hlciA9IHJlYWxTdGF0V2F0Y2hlcjtcbn1cblxuZnVuY3Rpb24gcmVzdG9yZVByb2Nlc3MoKSB7XG4gIGZvciAoY29uc3Qga2V5IGluIHJlYWxQcm9jZXNzUHJvcHMpIHtcbiAgICBwcm9jZXNzW2tleV0gPSByZWFsUHJvY2Vzc1Byb3BzW2tleV07XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzdG9yZUNyZWF0ZVdyaXRlU3RyZWFtKCkge1xuICBmcy5jcmVhdGVXcml0ZVN0cmVhbSA9IHJlYWxDcmVhdGVXcml0ZVN0cmVhbTtcbn1cblxuLyoqXG4gKiBTd2FwIG91dCB0aGUgZnMgYmluZGluZ3MgZm9yIGEgbW9jayBmaWxlIHN5c3RlbS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgTW9jayBmaWxlIHN5c3RlbSBjb25maWd1cmF0aW9uLlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgQW55IGZpbGVzeXN0ZW0gb3B0aW9ucy5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5jcmVhdGVDd2QgQ3JlYXRlIGEgZGlyZWN0b3J5IGZvciBgcHJvY2Vzcy5jd2QoKWBcbiAqICAgICAoZGVmYXVsdHMgdG8gYHRydWVgKS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5jcmVhdGVUbXAgQ3JlYXRlIGEgZGlyZWN0b3J5IGZvciBgb3MudG1wZGlyKClgXG4gKiAgICAgKGRlZmF1bHRzIHRvIGB0cnVlYCkuXG4gKi9cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIG1vY2soY29uZmlnLCBvcHRpb25zKSB7XG4gIGNvbnN0IHN5c3RlbSA9IEZpbGVTeXN0ZW0uY3JlYXRlKGNvbmZpZywgb3B0aW9ucyk7XG4gIGNvbnN0IGJpbmRpbmcgPSBuZXcgQmluZGluZyhzeXN0ZW0pO1xuXG4gIG92ZXJyaWRlQmluZGluZyhiaW5kaW5nKTtcblxuICBsZXQgY3VycmVudFBhdGggPSBwcm9jZXNzLmN3ZCgpO1xuICBvdmVycmlkZVByb2Nlc3MoXG4gICAgZnVuY3Rpb24gY3dkKCkge1xuICAgICAgaWYgKHJlYWxCaW5kaW5nLl9tb2NrZWRCaW5kaW5nKSB7XG4gICAgICAgIHJldHVybiBjdXJyZW50UGF0aDtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZWFsUHJvY2Vzc1Byb3BzLmN3ZCgpO1xuICAgIH0sXG4gICAgZnVuY3Rpb24gY2hkaXIoZGlyZWN0b3J5KSB7XG4gICAgICBpZiAocmVhbEJpbmRpbmcuX21vY2tlZEJpbmRpbmcpIHtcbiAgICAgICAgaWYgKCFiaW5kaW5nLnN0YXQodG9OYW1lc3BhY2VkUGF0aChkaXJlY3RvcnkpKS5pc0RpcmVjdG9yeSgpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTRXJyb3IoJ0VOT1RESVInKTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50UGF0aCA9IHBhdGgucmVzb2x2ZShjdXJyZW50UGF0aCwgZGlyZWN0b3J5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiByZWFsUHJvY2Vzc1Byb3BzLmNoZGlyKGRpcmVjdG9yeSk7XG4gICAgICB9XG4gICAgfVxuICApO1xuXG4gIG92ZXJyaWRlQ3JlYXRlV3JpdGVTdHJlYW0oKTtcbn07XG5cbi8qKlxuICogR2V0IGhvbGQgb2YgdGhlIG1vY2tlZCBmaWxlc3lzdGVtJ3MgJ3Jvb3QnXG4gKiBJZiBmcyBoYXNuJ3QgY3VycmVudGx5IGJlZW4gcmVwbGFjZWQsIHRoaXMgd2lsbCByZXR1cm4gYW4gZW1wdHkgb2JqZWN0XG4gKi9cbmV4cG9ydHMuZ2V0TW9ja1Jvb3QgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHJlYWxCaW5kaW5nLl9tb2NrZWRCaW5kaW5nKSB7XG4gICAgcmV0dXJuIHJlYWxCaW5kaW5nLl9tb2NrZWRCaW5kaW5nLmdldFN5c3RlbSgpLmdldFJvb3QoKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4ge307XG4gIH1cbn07XG5cbi8qKlxuICogUmVzdG9yZSB0aGUgZnMgYmluZGluZ3MgZm9yIHRoZSByZWFsIGZpbGUgc3lzdGVtLlxuICovXG5leHBvcnRzLnJlc3RvcmUgPSBmdW5jdGlvbigpIHtcbiAgcmVzdG9yZUJpbmRpbmcoKTtcbiAgcmVzdG9yZVByb2Nlc3MoKTtcbiAgcmVzdG9yZUNyZWF0ZVdyaXRlU3RyZWFtKCk7XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhIGZpbGUgZmFjdG9yeS5cbiAqL1xuZXhwb3J0cy5maWxlID0gRmlsZVN5c3RlbS5maWxlO1xuXG4vKipcbiAqIENyZWF0ZSBhIGRpcmVjdG9yeSBmYWN0b3J5LlxuICovXG5leHBvcnRzLmRpcmVjdG9yeSA9IEZpbGVTeXN0ZW0uZGlyZWN0b3J5O1xuXG4vKipcbiAqIENyZWF0ZSBhIHN5bWJvbGljIGxpbmsgZmFjdG9yeS5cbiAqL1xuZXhwb3J0cy5zeW1saW5rID0gRmlsZVN5c3RlbS5zeW1saW5rO1xuXG4vKipcbiAqIEF1dG9tYXRpY2FsbHkgbWFwcyBzcGVjaWZpZWQgcGF0aHMgKGZvciB1c2Ugd2l0aCBgbW9jaygpYClcbiAqL1xuZXhwb3J0cy5sb2FkID0gbG9hZGVyLmxvYWQ7XG5cbi8qKlxuICogUGVyZm9ybSBhY3Rpb24sIGJ5cGFzc2luZyBtb2NrIEZTXG4gKiBAZXhhbXBsZVxuICogLy8gVGhpcyBmaWxlIGV4aXN0cyBvbiB0aGUgcmVhbCBGUywgbm90IG9uIHRoZSBtb2NrZWQgRlNcbiAqIGNvbnN0IGZpbGVQYXRoID0gJy9wYXRoL2ZpbGUuanNvbic7XG4gKiBjb25zdCBkYXRhID0gbW9jay5ieXBhc3MoKCkgPT4gZnMucmVhZEZpbGVTeW5jKGZpbGVQYXRoLCAndXRmLTgnKSk7XG4gKi9cbmV4cG9ydHMuYnlwYXNzID0gYnlwYXNzO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/mock-fs/lib/index.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/mock-fs/lib/item.js":
/*!**********************************************!*\
  !*** ../../node_modules/mock-fs/lib/item.js ***!
  \**********************************************/
/***/ ((module, exports) => {

"use strict";
eval("\n\nlet counter = 0;\n\n/**\n * Permissions.\n * @enum {number}\n */\nconst permissions = {\n  USER_READ: 256, // 0400\n  USER_WRITE: 128, // 0200\n  USER_EXEC: 64, // 0100\n  GROUP_READ: 32, // 0040\n  GROUP_WRITE: 16, // 0020\n  GROUP_EXEC: 8, // 0010\n  OTHER_READ: 4, // 0004\n  OTHER_WRITE: 2, // 0002\n  OTHER_EXEC: 1 // 0001\n};\n\nfunction getUid() {\n  // force NaN on windows.\n  return process.getuid ? process.getuid() : NaN;\n}\n\nfunction getGid() {\n  // force NaN on windows.\n  return process.getgid ? process.getgid() : NaN;\n}\n\n/**\n * A filesystem item.\n * @constructor\n */\nfunction Item() {\n  const now = Date.now();\n\n  /**\n   * Access time.\n   * @type {Date}\n   */\n  this._atime = new Date(now);\n\n  /**\n   * Change time.\n   * @type {Date}\n   */\n  this._ctime = new Date(now);\n\n  /**\n   * Birth time.\n   * @type {Date}\n   */\n  this._birthtime = new Date(now);\n\n  /**\n   * Modification time.\n   * @type {Date}\n   */\n  this._mtime = new Date(now);\n\n  /**\n   * Permissions.\n   */\n  this._mode = 438; // 0666\n\n  /**\n   * User id.\n   * @type {number}\n   */\n  this._uid = getUid();\n\n  /**\n   * Group id.\n   * @type {number}\n   */\n  this._gid = getGid();\n\n  /**\n   * Item number.\n   * @type {number}\n   */\n  this._id = ++counter;\n\n  /**\n   * Number of links to this item.\n   */\n  this.links = 0;\n}\n\n/**\n * Add execute if read allowed\n * See notes in index.js -> mapping#addDir\n */\nItem.fixWin32Permissions = mode =>\n  process.platform !== 'win32'\n    ? mode\n    : mode |\n      (mode & permissions.USER_READ && permissions.USER_EXEC) |\n      (mode & permissions.GROUP_READ && permissions.GROUP_EXEC) |\n      (mode & permissions.OTHER_READ && permissions.OTHER_EXEC);\n\n/**\n * Determine if the current user has read permission.\n * @return {boolean} The current user can read.\n */\nItem.prototype.canRead = function() {\n  const uid = getUid();\n  const gid = getGid();\n  let can = false;\n  if (uid === 0) {\n    can = true;\n  } else if (uid === this._uid || uid !== uid) {\n    // (uid !== uid) means uid is NaN, only for windows\n    can = (permissions.USER_READ & this._mode) === permissions.USER_READ;\n  } else if (gid === this._gid) {\n    can = (permissions.GROUP_READ & this._mode) === permissions.GROUP_READ;\n  } else {\n    can = (permissions.OTHER_READ & this._mode) === permissions.OTHER_READ;\n  }\n  return can;\n};\n\n/**\n * Determine if the current user has write permission.\n * @return {boolean} The current user can write.\n */\nItem.prototype.canWrite = function() {\n  const uid = getUid();\n  const gid = getGid();\n  let can = false;\n  if (uid === 0) {\n    can = true;\n  } else if (uid === this._uid || uid !== uid) {\n    // (uid !== uid) means uid is NaN, only for windows\n    can = (permissions.USER_WRITE & this._mode) === permissions.USER_WRITE;\n  } else if (gid === this._gid) {\n    can = (permissions.GROUP_WRITE & this._mode) === permissions.GROUP_WRITE;\n  } else {\n    can = (permissions.OTHER_WRITE & this._mode) === permissions.OTHER_WRITE;\n  }\n  return can;\n};\n\n/**\n * Determine if the current user has execute permission.\n * @return {boolean} The current user can execute.\n */\nItem.prototype.canExecute = function() {\n  const uid = getUid();\n  const gid = getGid();\n  let can = false;\n  if (uid === 0) {\n    can = true;\n  } else if (uid === this._uid || isNaN(uid)) {\n    // NaN occurs on windows\n    can = (permissions.USER_EXEC & this._mode) === permissions.USER_EXEC;\n  } else if (gid === this._gid) {\n    can = (permissions.GROUP_EXEC & this._mode) === permissions.GROUP_EXEC;\n  } else {\n    can = (permissions.OTHER_EXEC & this._mode) === permissions.OTHER_EXEC;\n  }\n  return can;\n};\n\n/**\n * Get access time.\n * @return {Date} Access time.\n */\nItem.prototype.getATime = function() {\n  return this._atime;\n};\n\n/**\n * Set access time.\n * @param {Date} atime Access time.\n */\nItem.prototype.setATime = function(atime) {\n  this._atime = atime;\n};\n\n/**\n * Get change time.\n * @return {Date} Change time.\n */\nItem.prototype.getCTime = function() {\n  return this._ctime;\n};\n\n/**\n * Set change time.\n * @param {Date} ctime Change time.\n */\nItem.prototype.setCTime = function(ctime) {\n  this._ctime = ctime;\n};\n\n/**\n * Get birth time.\n * @return {Date} Birth time.\n */\nItem.prototype.getBirthtime = function() {\n  return this._birthtime;\n};\n\n/**\n * Set change time.\n * @param {Date} birthtime Birth time.\n */\nItem.prototype.setBirthtime = function(birthtime) {\n  this._birthtime = birthtime;\n};\n\n/**\n * Get modification time.\n * @return {Date} Modification time.\n */\nItem.prototype.getMTime = function() {\n  return this._mtime;\n};\n\n/**\n * Set modification time.\n * @param {Date} mtime Modification time.\n */\nItem.prototype.setMTime = function(mtime) {\n  this._mtime = mtime;\n};\n\n/**\n * Get mode (permission only, e.g 0666).\n * @return {number} Mode.\n */\nItem.prototype.getMode = function() {\n  return this._mode;\n};\n\n/**\n * Set mode (permission only, e.g 0666).\n * @param {Date} mode Mode.\n */\nItem.prototype.setMode = function(mode) {\n  this.setCTime(new Date());\n  this._mode = mode;\n};\n\n/**\n * Get user id.\n * @return {number} User id.\n */\nItem.prototype.getUid = function() {\n  return this._uid;\n};\n\n/**\n * Set user id.\n * @param {number} uid User id.\n */\nItem.prototype.setUid = function(uid) {\n  this.setCTime(new Date());\n  this._uid = uid;\n};\n\n/**\n * Get group id.\n * @return {number} Group id.\n */\nItem.prototype.getGid = function() {\n  return this._gid;\n};\n\n/**\n * Set group id.\n * @param {number} gid Group id.\n */\nItem.prototype.setGid = function(gid) {\n  this.setCTime(new Date());\n  this._gid = gid;\n};\n\n/**\n * Get item stats.\n * @return {Object} Stats properties.\n */\nItem.prototype.getStats = function() {\n  return {\n    dev: 8675309,\n    nlink: this.links,\n    uid: this.getUid(),\n    gid: this.getGid(),\n    rdev: 0,\n    blksize: 4096,\n    ino: this._id,\n    atime: this.getATime(),\n    mtime: this.getMTime(),\n    ctime: this.getCTime(),\n    birthtime: this.getBirthtime(),\n    atimeMs: +this.getATime(),\n    mtimeMs: +this.getMTime(),\n    ctimeMs: +this.getCTime(),\n    birthtimeMs: +this.getBirthtime()\n  };\n};\n\n/**\n * Get the item's string representation.\n * @return {string} String representation.\n */\nItem.prototype.toString = function() {\n  return '[' + this.constructor.name + ']';\n};\n\n/**\n * Export the constructor.\n * @type {function()}\n */\nexports = module.exports = Item;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL21vY2stZnMvbGliL2l0ZW0uanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7O0FBRXBCO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksTUFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLE1BQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9iYXJiL2FhL0Fzc29jaWF0ZWRBY2NvdW50cy9ub2RlX21vZHVsZXMvbW9jay1mcy9saWIvaXRlbS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmxldCBjb3VudGVyID0gMDtcblxuLyoqXG4gKiBQZXJtaXNzaW9ucy5cbiAqIEBlbnVtIHtudW1iZXJ9XG4gKi9cbmNvbnN0IHBlcm1pc3Npb25zID0ge1xuICBVU0VSX1JFQUQ6IDI1NiwgLy8gMDQwMFxuICBVU0VSX1dSSVRFOiAxMjgsIC8vIDAyMDBcbiAgVVNFUl9FWEVDOiA2NCwgLy8gMDEwMFxuICBHUk9VUF9SRUFEOiAzMiwgLy8gMDA0MFxuICBHUk9VUF9XUklURTogMTYsIC8vIDAwMjBcbiAgR1JPVVBfRVhFQzogOCwgLy8gMDAxMFxuICBPVEhFUl9SRUFEOiA0LCAvLyAwMDA0XG4gIE9USEVSX1dSSVRFOiAyLCAvLyAwMDAyXG4gIE9USEVSX0VYRUM6IDEgLy8gMDAwMVxufTtcblxuZnVuY3Rpb24gZ2V0VWlkKCkge1xuICAvLyBmb3JjZSBOYU4gb24gd2luZG93cy5cbiAgcmV0dXJuIHByb2Nlc3MuZ2V0dWlkID8gcHJvY2Vzcy5nZXR1aWQoKSA6IE5hTjtcbn1cblxuZnVuY3Rpb24gZ2V0R2lkKCkge1xuICAvLyBmb3JjZSBOYU4gb24gd2luZG93cy5cbiAgcmV0dXJuIHByb2Nlc3MuZ2V0Z2lkID8gcHJvY2Vzcy5nZXRnaWQoKSA6IE5hTjtcbn1cblxuLyoqXG4gKiBBIGZpbGVzeXN0ZW0gaXRlbS5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBJdGVtKCkge1xuICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuXG4gIC8qKlxuICAgKiBBY2Nlc3MgdGltZS5cbiAgICogQHR5cGUge0RhdGV9XG4gICAqL1xuICB0aGlzLl9hdGltZSA9IG5ldyBEYXRlKG5vdyk7XG5cbiAgLyoqXG4gICAqIENoYW5nZSB0aW1lLlxuICAgKiBAdHlwZSB7RGF0ZX1cbiAgICovXG4gIHRoaXMuX2N0aW1lID0gbmV3IERhdGUobm93KTtcblxuICAvKipcbiAgICogQmlydGggdGltZS5cbiAgICogQHR5cGUge0RhdGV9XG4gICAqL1xuICB0aGlzLl9iaXJ0aHRpbWUgPSBuZXcgRGF0ZShub3cpO1xuXG4gIC8qKlxuICAgKiBNb2RpZmljYXRpb24gdGltZS5cbiAgICogQHR5cGUge0RhdGV9XG4gICAqL1xuICB0aGlzLl9tdGltZSA9IG5ldyBEYXRlKG5vdyk7XG5cbiAgLyoqXG4gICAqIFBlcm1pc3Npb25zLlxuICAgKi9cbiAgdGhpcy5fbW9kZSA9IDQzODsgLy8gMDY2NlxuXG4gIC8qKlxuICAgKiBVc2VyIGlkLlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgdGhpcy5fdWlkID0gZ2V0VWlkKCk7XG5cbiAgLyoqXG4gICAqIEdyb3VwIGlkLlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgdGhpcy5fZ2lkID0gZ2V0R2lkKCk7XG5cbiAgLyoqXG4gICAqIEl0ZW0gbnVtYmVyLlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgdGhpcy5faWQgPSArK2NvdW50ZXI7XG5cbiAgLyoqXG4gICAqIE51bWJlciBvZiBsaW5rcyB0byB0aGlzIGl0ZW0uXG4gICAqL1xuICB0aGlzLmxpbmtzID0gMDtcbn1cblxuLyoqXG4gKiBBZGQgZXhlY3V0ZSBpZiByZWFkIGFsbG93ZWRcbiAqIFNlZSBub3RlcyBpbiBpbmRleC5qcyAtPiBtYXBwaW5nI2FkZERpclxuICovXG5JdGVtLmZpeFdpbjMyUGVybWlzc2lvbnMgPSBtb2RlID0+XG4gIHByb2Nlc3MucGxhdGZvcm0gIT09ICd3aW4zMidcbiAgICA/IG1vZGVcbiAgICA6IG1vZGUgfFxuICAgICAgKG1vZGUgJiBwZXJtaXNzaW9ucy5VU0VSX1JFQUQgJiYgcGVybWlzc2lvbnMuVVNFUl9FWEVDKSB8XG4gICAgICAobW9kZSAmIHBlcm1pc3Npb25zLkdST1VQX1JFQUQgJiYgcGVybWlzc2lvbnMuR1JPVVBfRVhFQykgfFxuICAgICAgKG1vZGUgJiBwZXJtaXNzaW9ucy5PVEhFUl9SRUFEICYmIHBlcm1pc3Npb25zLk9USEVSX0VYRUMpO1xuXG4vKipcbiAqIERldGVybWluZSBpZiB0aGUgY3VycmVudCB1c2VyIGhhcyByZWFkIHBlcm1pc3Npb24uXG4gKiBAcmV0dXJuIHtib29sZWFufSBUaGUgY3VycmVudCB1c2VyIGNhbiByZWFkLlxuICovXG5JdGVtLnByb3RvdHlwZS5jYW5SZWFkID0gZnVuY3Rpb24oKSB7XG4gIGNvbnN0IHVpZCA9IGdldFVpZCgpO1xuICBjb25zdCBnaWQgPSBnZXRHaWQoKTtcbiAgbGV0IGNhbiA9IGZhbHNlO1xuICBpZiAodWlkID09PSAwKSB7XG4gICAgY2FuID0gdHJ1ZTtcbiAgfSBlbHNlIGlmICh1aWQgPT09IHRoaXMuX3VpZCB8fCB1aWQgIT09IHVpZCkge1xuICAgIC8vICh1aWQgIT09IHVpZCkgbWVhbnMgdWlkIGlzIE5hTiwgb25seSBmb3Igd2luZG93c1xuICAgIGNhbiA9IChwZXJtaXNzaW9ucy5VU0VSX1JFQUQgJiB0aGlzLl9tb2RlKSA9PT0gcGVybWlzc2lvbnMuVVNFUl9SRUFEO1xuICB9IGVsc2UgaWYgKGdpZCA9PT0gdGhpcy5fZ2lkKSB7XG4gICAgY2FuID0gKHBlcm1pc3Npb25zLkdST1VQX1JFQUQgJiB0aGlzLl9tb2RlKSA9PT0gcGVybWlzc2lvbnMuR1JPVVBfUkVBRDtcbiAgfSBlbHNlIHtcbiAgICBjYW4gPSAocGVybWlzc2lvbnMuT1RIRVJfUkVBRCAmIHRoaXMuX21vZGUpID09PSBwZXJtaXNzaW9ucy5PVEhFUl9SRUFEO1xuICB9XG4gIHJldHVybiBjYW47XG59O1xuXG4vKipcbiAqIERldGVybWluZSBpZiB0aGUgY3VycmVudCB1c2VyIGhhcyB3cml0ZSBwZXJtaXNzaW9uLlxuICogQHJldHVybiB7Ym9vbGVhbn0gVGhlIGN1cnJlbnQgdXNlciBjYW4gd3JpdGUuXG4gKi9cbkl0ZW0ucHJvdG90eXBlLmNhbldyaXRlID0gZnVuY3Rpb24oKSB7XG4gIGNvbnN0IHVpZCA9IGdldFVpZCgpO1xuICBjb25zdCBnaWQgPSBnZXRHaWQoKTtcbiAgbGV0IGNhbiA9IGZhbHNlO1xuICBpZiAodWlkID09PSAwKSB7XG4gICAgY2FuID0gdHJ1ZTtcbiAgfSBlbHNlIGlmICh1aWQgPT09IHRoaXMuX3VpZCB8fCB1aWQgIT09IHVpZCkge1xuICAgIC8vICh1aWQgIT09IHVpZCkgbWVhbnMgdWlkIGlzIE5hTiwgb25seSBmb3Igd2luZG93c1xuICAgIGNhbiA9IChwZXJtaXNzaW9ucy5VU0VSX1dSSVRFICYgdGhpcy5fbW9kZSkgPT09IHBlcm1pc3Npb25zLlVTRVJfV1JJVEU7XG4gIH0gZWxzZSBpZiAoZ2lkID09PSB0aGlzLl9naWQpIHtcbiAgICBjYW4gPSAocGVybWlzc2lvbnMuR1JPVVBfV1JJVEUgJiB0aGlzLl9tb2RlKSA9PT0gcGVybWlzc2lvbnMuR1JPVVBfV1JJVEU7XG4gIH0gZWxzZSB7XG4gICAgY2FuID0gKHBlcm1pc3Npb25zLk9USEVSX1dSSVRFICYgdGhpcy5fbW9kZSkgPT09IHBlcm1pc3Npb25zLk9USEVSX1dSSVRFO1xuICB9XG4gIHJldHVybiBjYW47XG59O1xuXG4vKipcbiAqIERldGVybWluZSBpZiB0aGUgY3VycmVudCB1c2VyIGhhcyBleGVjdXRlIHBlcm1pc3Npb24uXG4gKiBAcmV0dXJuIHtib29sZWFufSBUaGUgY3VycmVudCB1c2VyIGNhbiBleGVjdXRlLlxuICovXG5JdGVtLnByb3RvdHlwZS5jYW5FeGVjdXRlID0gZnVuY3Rpb24oKSB7XG4gIGNvbnN0IHVpZCA9IGdldFVpZCgpO1xuICBjb25zdCBnaWQgPSBnZXRHaWQoKTtcbiAgbGV0IGNhbiA9IGZhbHNlO1xuICBpZiAodWlkID09PSAwKSB7XG4gICAgY2FuID0gdHJ1ZTtcbiAgfSBlbHNlIGlmICh1aWQgPT09IHRoaXMuX3VpZCB8fCBpc05hTih1aWQpKSB7XG4gICAgLy8gTmFOIG9jY3VycyBvbiB3aW5kb3dzXG4gICAgY2FuID0gKHBlcm1pc3Npb25zLlVTRVJfRVhFQyAmIHRoaXMuX21vZGUpID09PSBwZXJtaXNzaW9ucy5VU0VSX0VYRUM7XG4gIH0gZWxzZSBpZiAoZ2lkID09PSB0aGlzLl9naWQpIHtcbiAgICBjYW4gPSAocGVybWlzc2lvbnMuR1JPVVBfRVhFQyAmIHRoaXMuX21vZGUpID09PSBwZXJtaXNzaW9ucy5HUk9VUF9FWEVDO1xuICB9IGVsc2Uge1xuICAgIGNhbiA9IChwZXJtaXNzaW9ucy5PVEhFUl9FWEVDICYgdGhpcy5fbW9kZSkgPT09IHBlcm1pc3Npb25zLk9USEVSX0VYRUM7XG4gIH1cbiAgcmV0dXJuIGNhbjtcbn07XG5cbi8qKlxuICogR2V0IGFjY2VzcyB0aW1lLlxuICogQHJldHVybiB7RGF0ZX0gQWNjZXNzIHRpbWUuXG4gKi9cbkl0ZW0ucHJvdG90eXBlLmdldEFUaW1lID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9hdGltZTtcbn07XG5cbi8qKlxuICogU2V0IGFjY2VzcyB0aW1lLlxuICogQHBhcmFtIHtEYXRlfSBhdGltZSBBY2Nlc3MgdGltZS5cbiAqL1xuSXRlbS5wcm90b3R5cGUuc2V0QVRpbWUgPSBmdW5jdGlvbihhdGltZSkge1xuICB0aGlzLl9hdGltZSA9IGF0aW1lO1xufTtcblxuLyoqXG4gKiBHZXQgY2hhbmdlIHRpbWUuXG4gKiBAcmV0dXJuIHtEYXRlfSBDaGFuZ2UgdGltZS5cbiAqL1xuSXRlbS5wcm90b3R5cGUuZ2V0Q1RpbWUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2N0aW1lO1xufTtcblxuLyoqXG4gKiBTZXQgY2hhbmdlIHRpbWUuXG4gKiBAcGFyYW0ge0RhdGV9IGN0aW1lIENoYW5nZSB0aW1lLlxuICovXG5JdGVtLnByb3RvdHlwZS5zZXRDVGltZSA9IGZ1bmN0aW9uKGN0aW1lKSB7XG4gIHRoaXMuX2N0aW1lID0gY3RpbWU7XG59O1xuXG4vKipcbiAqIEdldCBiaXJ0aCB0aW1lLlxuICogQHJldHVybiB7RGF0ZX0gQmlydGggdGltZS5cbiAqL1xuSXRlbS5wcm90b3R5cGUuZ2V0QmlydGh0aW1lID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9iaXJ0aHRpbWU7XG59O1xuXG4vKipcbiAqIFNldCBjaGFuZ2UgdGltZS5cbiAqIEBwYXJhbSB7RGF0ZX0gYmlydGh0aW1lIEJpcnRoIHRpbWUuXG4gKi9cbkl0ZW0ucHJvdG90eXBlLnNldEJpcnRodGltZSA9IGZ1bmN0aW9uKGJpcnRodGltZSkge1xuICB0aGlzLl9iaXJ0aHRpbWUgPSBiaXJ0aHRpbWU7XG59O1xuXG4vKipcbiAqIEdldCBtb2RpZmljYXRpb24gdGltZS5cbiAqIEByZXR1cm4ge0RhdGV9IE1vZGlmaWNhdGlvbiB0aW1lLlxuICovXG5JdGVtLnByb3RvdHlwZS5nZXRNVGltZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fbXRpbWU7XG59O1xuXG4vKipcbiAqIFNldCBtb2RpZmljYXRpb24gdGltZS5cbiAqIEBwYXJhbSB7RGF0ZX0gbXRpbWUgTW9kaWZpY2F0aW9uIHRpbWUuXG4gKi9cbkl0ZW0ucHJvdG90eXBlLnNldE1UaW1lID0gZnVuY3Rpb24obXRpbWUpIHtcbiAgdGhpcy5fbXRpbWUgPSBtdGltZTtcbn07XG5cbi8qKlxuICogR2V0IG1vZGUgKHBlcm1pc3Npb24gb25seSwgZS5nIDA2NjYpLlxuICogQHJldHVybiB7bnVtYmVyfSBNb2RlLlxuICovXG5JdGVtLnByb3RvdHlwZS5nZXRNb2RlID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9tb2RlO1xufTtcblxuLyoqXG4gKiBTZXQgbW9kZSAocGVybWlzc2lvbiBvbmx5LCBlLmcgMDY2NikuXG4gKiBAcGFyYW0ge0RhdGV9IG1vZGUgTW9kZS5cbiAqL1xuSXRlbS5wcm90b3R5cGUuc2V0TW9kZSA9IGZ1bmN0aW9uKG1vZGUpIHtcbiAgdGhpcy5zZXRDVGltZShuZXcgRGF0ZSgpKTtcbiAgdGhpcy5fbW9kZSA9IG1vZGU7XG59O1xuXG4vKipcbiAqIEdldCB1c2VyIGlkLlxuICogQHJldHVybiB7bnVtYmVyfSBVc2VyIGlkLlxuICovXG5JdGVtLnByb3RvdHlwZS5nZXRVaWQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX3VpZDtcbn07XG5cbi8qKlxuICogU2V0IHVzZXIgaWQuXG4gKiBAcGFyYW0ge251bWJlcn0gdWlkIFVzZXIgaWQuXG4gKi9cbkl0ZW0ucHJvdG90eXBlLnNldFVpZCA9IGZ1bmN0aW9uKHVpZCkge1xuICB0aGlzLnNldENUaW1lKG5ldyBEYXRlKCkpO1xuICB0aGlzLl91aWQgPSB1aWQ7XG59O1xuXG4vKipcbiAqIEdldCBncm91cCBpZC5cbiAqIEByZXR1cm4ge251bWJlcn0gR3JvdXAgaWQuXG4gKi9cbkl0ZW0ucHJvdG90eXBlLmdldEdpZCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fZ2lkO1xufTtcblxuLyoqXG4gKiBTZXQgZ3JvdXAgaWQuXG4gKiBAcGFyYW0ge251bWJlcn0gZ2lkIEdyb3VwIGlkLlxuICovXG5JdGVtLnByb3RvdHlwZS5zZXRHaWQgPSBmdW5jdGlvbihnaWQpIHtcbiAgdGhpcy5zZXRDVGltZShuZXcgRGF0ZSgpKTtcbiAgdGhpcy5fZ2lkID0gZ2lkO1xufTtcblxuLyoqXG4gKiBHZXQgaXRlbSBzdGF0cy5cbiAqIEByZXR1cm4ge09iamVjdH0gU3RhdHMgcHJvcGVydGllcy5cbiAqL1xuSXRlbS5wcm90b3R5cGUuZ2V0U3RhdHMgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHtcbiAgICBkZXY6IDg2NzUzMDksXG4gICAgbmxpbms6IHRoaXMubGlua3MsXG4gICAgdWlkOiB0aGlzLmdldFVpZCgpLFxuICAgIGdpZDogdGhpcy5nZXRHaWQoKSxcbiAgICByZGV2OiAwLFxuICAgIGJsa3NpemU6IDQwOTYsXG4gICAgaW5vOiB0aGlzLl9pZCxcbiAgICBhdGltZTogdGhpcy5nZXRBVGltZSgpLFxuICAgIG10aW1lOiB0aGlzLmdldE1UaW1lKCksXG4gICAgY3RpbWU6IHRoaXMuZ2V0Q1RpbWUoKSxcbiAgICBiaXJ0aHRpbWU6IHRoaXMuZ2V0QmlydGh0aW1lKCksXG4gICAgYXRpbWVNczogK3RoaXMuZ2V0QVRpbWUoKSxcbiAgICBtdGltZU1zOiArdGhpcy5nZXRNVGltZSgpLFxuICAgIGN0aW1lTXM6ICt0aGlzLmdldENUaW1lKCksXG4gICAgYmlydGh0aW1lTXM6ICt0aGlzLmdldEJpcnRodGltZSgpXG4gIH07XG59O1xuXG4vKipcbiAqIEdldCB0aGUgaXRlbSdzIHN0cmluZyByZXByZXNlbnRhdGlvbi5cbiAqIEByZXR1cm4ge3N0cmluZ30gU3RyaW5nIHJlcHJlc2VudGF0aW9uLlxuICovXG5JdGVtLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gJ1snICsgdGhpcy5jb25zdHJ1Y3Rvci5uYW1lICsgJ10nO1xufTtcblxuLyoqXG4gKiBFeHBvcnQgdGhlIGNvbnN0cnVjdG9yLlxuICogQHR5cGUge2Z1bmN0aW9uKCl9XG4gKi9cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IEl0ZW07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/mock-fs/lib/item.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/mock-fs/lib/loader.js":
/*!************************************************!*\
  !*** ../../node_modules/mock-fs/lib/loader.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("const {fixWin32Permissions} = __webpack_require__(/*! ./item */ \"(rsc)/../../node_modules/mock-fs/lib/item.js\");\nconst path = __webpack_require__(/*! path */ \"path\");\nconst FileSystem = __webpack_require__(/*! ./filesystem */ \"(rsc)/../../node_modules/mock-fs/lib/filesystem.js\");\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst bypass = __webpack_require__(/*! ./bypass */ \"(rsc)/../../node_modules/mock-fs/lib/bypass.js\");\n\nconst createContext = ({output, options = {}, target}, newContext) =>\n  Object.assign(\n    {\n      // Assign options and set defaults if needed\n      options: {\n        recursive: options.recursive !== false,\n        lazy: options.lazy !== false\n      },\n      output,\n      target\n    },\n    newContext\n  );\n\nfunction addFile(context, stats, isRoot) {\n  const {output, target} = context;\n  const {lazy} = context.options;\n\n  if (!stats.isFile()) {\n    throw new Error(`${target} is not a valid file!`);\n  }\n\n  const outputPropKey = isRoot ? target : path.basename(target);\n\n  output[outputPropKey] = () => {\n    const content = !lazy ? fs.readFileSync(target) : '';\n    const file = FileSystem.file(Object.assign({}, stats, {content}))();\n\n    if (lazy) {\n      Object.defineProperty(file, '_content', {\n        get() {\n          const res = bypass(() => fs.readFileSync(target));\n          Object.defineProperty(file, '_content', {\n            value: res,\n            writable: true\n          });\n          return res;\n        },\n        set(data) {\n          Object.defineProperty(file, '_content', {\n            value: data,\n            writable: true\n          });\n        },\n        configurable: true\n      });\n    }\n\n    return file;\n  };\n\n  return output[outputPropKey];\n}\n\nfunction addDir(context, stats, isRoot) {\n  const {target, output} = context;\n  const {recursive} = context.options;\n\n  if (!stats.isDirectory()) {\n    throw new Error(`${target} is not a valid directory!`);\n  }\n\n  stats = Object.assign({}, stats);\n  const outputPropKey = isRoot ? target : path.basename(target);\n\n  // On windows platforms, directories do not have the executable flag, which causes FileSystem.prototype.getItem\n  // to think that the directory cannot be traversed. This is a workaround, however, a better solution may be to\n  // re-think the logic in FileSystem.prototype.getItem\n  // This workaround adds executable privileges if read privileges are found\n  stats.mode = fixWin32Permissions(stats.mode);\n\n  // Create directory factory\n  const directoryItems = {};\n  output[outputPropKey] = FileSystem.directory(\n    Object.assign(stats, {items: directoryItems})\n  );\n\n  fs.readdirSync(target).forEach(p => {\n    const absPath = path.join(target, p);\n    const stats = fs.statSync(absPath);\n    const newContext = createContext(context, {\n      target: absPath,\n      output: directoryItems\n    });\n\n    if (recursive && stats.isDirectory()) {\n      addDir(newContext, stats);\n    } else if (stats.isFile()) {\n      addFile(newContext, stats);\n    }\n  });\n\n  return output[outputPropKey];\n}\n\n/**\n * Load directory or file from real FS\n */\nexports.load = function(p, options) {\n  return bypass(() => {\n    p = path.resolve(p);\n\n    const stats = fs.statSync(p);\n    const context = createContext({output: {}, options, target: p});\n\n    if (stats.isDirectory()) {\n      return addDir(context, stats, true);\n    } else if (stats.isFile()) {\n      return addFile(context, stats, true);\n    }\n  });\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL21vY2stZnMvbGliL2xvYWRlci5qcyIsIm1hcHBpbmdzIjoiQUFBQSxPQUFPLHFCQUFxQixFQUFFLG1CQUFPLENBQUMsNERBQVE7QUFDOUMsYUFBYSxtQkFBTyxDQUFDLGtCQUFNO0FBQzNCLG1CQUFtQixtQkFBTyxDQUFDLHdFQUFjO0FBQ3pDLFdBQVcsbUJBQU8sQ0FBQyxjQUFJO0FBQ3ZCLGVBQWUsbUJBQU8sQ0FBQyxnRUFBVTs7QUFFakMsd0JBQXdCLG9CQUFvQixTQUFTO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSxTQUFTLGdCQUFnQjtBQUN6QixTQUFTLE1BQU07O0FBRWY7QUFDQSx1QkFBdUIsUUFBUTtBQUMvQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsaURBQWlELFVBQVUsUUFBUTs7QUFFbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFNBQVMsZ0JBQWdCO0FBQ3pCLFNBQVMsV0FBVzs7QUFFcEI7QUFDQSx1QkFBdUIsUUFBUTtBQUMvQjs7QUFFQSwwQkFBMEI7QUFDMUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsc0JBQXNCO0FBQ2hEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0EsbUNBQW1DLFVBQVUscUJBQXFCOztBQUVsRTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0giLCJzb3VyY2VzIjpbIi9ob21lL2JhcmIvYWEvQXNzb2NpYXRlZEFjY291bnRzL25vZGVfbW9kdWxlcy9tb2NrLWZzL2xpYi9sb2FkZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3Qge2ZpeFdpbjMyUGVybWlzc2lvbnN9ID0gcmVxdWlyZSgnLi9pdGVtJyk7XG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xuY29uc3QgRmlsZVN5c3RlbSA9IHJlcXVpcmUoJy4vZmlsZXN5c3RlbScpO1xuY29uc3QgZnMgPSByZXF1aXJlKCdmcycpO1xuY29uc3QgYnlwYXNzID0gcmVxdWlyZSgnLi9ieXBhc3MnKTtcblxuY29uc3QgY3JlYXRlQ29udGV4dCA9ICh7b3V0cHV0LCBvcHRpb25zID0ge30sIHRhcmdldH0sIG5ld0NvbnRleHQpID0+XG4gIE9iamVjdC5hc3NpZ24oXG4gICAge1xuICAgICAgLy8gQXNzaWduIG9wdGlvbnMgYW5kIHNldCBkZWZhdWx0cyBpZiBuZWVkZWRcbiAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgcmVjdXJzaXZlOiBvcHRpb25zLnJlY3Vyc2l2ZSAhPT0gZmFsc2UsXG4gICAgICAgIGxhenk6IG9wdGlvbnMubGF6eSAhPT0gZmFsc2VcbiAgICAgIH0sXG4gICAgICBvdXRwdXQsXG4gICAgICB0YXJnZXRcbiAgICB9LFxuICAgIG5ld0NvbnRleHRcbiAgKTtcblxuZnVuY3Rpb24gYWRkRmlsZShjb250ZXh0LCBzdGF0cywgaXNSb290KSB7XG4gIGNvbnN0IHtvdXRwdXQsIHRhcmdldH0gPSBjb250ZXh0O1xuICBjb25zdCB7bGF6eX0gPSBjb250ZXh0Lm9wdGlvbnM7XG5cbiAgaWYgKCFzdGF0cy5pc0ZpbGUoKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgJHt0YXJnZXR9IGlzIG5vdCBhIHZhbGlkIGZpbGUhYCk7XG4gIH1cblxuICBjb25zdCBvdXRwdXRQcm9wS2V5ID0gaXNSb290ID8gdGFyZ2V0IDogcGF0aC5iYXNlbmFtZSh0YXJnZXQpO1xuXG4gIG91dHB1dFtvdXRwdXRQcm9wS2V5XSA9ICgpID0+IHtcbiAgICBjb25zdCBjb250ZW50ID0gIWxhenkgPyBmcy5yZWFkRmlsZVN5bmModGFyZ2V0KSA6ICcnO1xuICAgIGNvbnN0IGZpbGUgPSBGaWxlU3lzdGVtLmZpbGUoT2JqZWN0LmFzc2lnbih7fSwgc3RhdHMsIHtjb250ZW50fSkpKCk7XG5cbiAgICBpZiAobGF6eSkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGZpbGUsICdfY29udGVudCcsIHtcbiAgICAgICAgZ2V0KCkge1xuICAgICAgICAgIGNvbnN0IHJlcyA9IGJ5cGFzcygoKSA9PiBmcy5yZWFkRmlsZVN5bmModGFyZ2V0KSk7XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGZpbGUsICdfY29udGVudCcsIHtcbiAgICAgICAgICAgIHZhbHVlOiByZXMsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH0sXG4gICAgICAgIHNldChkYXRhKSB7XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGZpbGUsICdfY29udGVudCcsIHtcbiAgICAgICAgICAgIHZhbHVlOiBkYXRhLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmlsZTtcbiAgfTtcblxuICByZXR1cm4gb3V0cHV0W291dHB1dFByb3BLZXldO1xufVxuXG5mdW5jdGlvbiBhZGREaXIoY29udGV4dCwgc3RhdHMsIGlzUm9vdCkge1xuICBjb25zdCB7dGFyZ2V0LCBvdXRwdXR9ID0gY29udGV4dDtcbiAgY29uc3Qge3JlY3Vyc2l2ZX0gPSBjb250ZXh0Lm9wdGlvbnM7XG5cbiAgaWYgKCFzdGF0cy5pc0RpcmVjdG9yeSgpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGAke3RhcmdldH0gaXMgbm90IGEgdmFsaWQgZGlyZWN0b3J5IWApO1xuICB9XG5cbiAgc3RhdHMgPSBPYmplY3QuYXNzaWduKHt9LCBzdGF0cyk7XG4gIGNvbnN0IG91dHB1dFByb3BLZXkgPSBpc1Jvb3QgPyB0YXJnZXQgOiBwYXRoLmJhc2VuYW1lKHRhcmdldCk7XG5cbiAgLy8gT24gd2luZG93cyBwbGF0Zm9ybXMsIGRpcmVjdG9yaWVzIGRvIG5vdCBoYXZlIHRoZSBleGVjdXRhYmxlIGZsYWcsIHdoaWNoIGNhdXNlcyBGaWxlU3lzdGVtLnByb3RvdHlwZS5nZXRJdGVtXG4gIC8vIHRvIHRoaW5rIHRoYXQgdGhlIGRpcmVjdG9yeSBjYW5ub3QgYmUgdHJhdmVyc2VkLiBUaGlzIGlzIGEgd29ya2Fyb3VuZCwgaG93ZXZlciwgYSBiZXR0ZXIgc29sdXRpb24gbWF5IGJlIHRvXG4gIC8vIHJlLXRoaW5rIHRoZSBsb2dpYyBpbiBGaWxlU3lzdGVtLnByb3RvdHlwZS5nZXRJdGVtXG4gIC8vIFRoaXMgd29ya2Fyb3VuZCBhZGRzIGV4ZWN1dGFibGUgcHJpdmlsZWdlcyBpZiByZWFkIHByaXZpbGVnZXMgYXJlIGZvdW5kXG4gIHN0YXRzLm1vZGUgPSBmaXhXaW4zMlBlcm1pc3Npb25zKHN0YXRzLm1vZGUpO1xuXG4gIC8vIENyZWF0ZSBkaXJlY3RvcnkgZmFjdG9yeVxuICBjb25zdCBkaXJlY3RvcnlJdGVtcyA9IHt9O1xuICBvdXRwdXRbb3V0cHV0UHJvcEtleV0gPSBGaWxlU3lzdGVtLmRpcmVjdG9yeShcbiAgICBPYmplY3QuYXNzaWduKHN0YXRzLCB7aXRlbXM6IGRpcmVjdG9yeUl0ZW1zfSlcbiAgKTtcblxuICBmcy5yZWFkZGlyU3luYyh0YXJnZXQpLmZvckVhY2gocCA9PiB7XG4gICAgY29uc3QgYWJzUGF0aCA9IHBhdGguam9pbih0YXJnZXQsIHApO1xuICAgIGNvbnN0IHN0YXRzID0gZnMuc3RhdFN5bmMoYWJzUGF0aCk7XG4gICAgY29uc3QgbmV3Q29udGV4dCA9IGNyZWF0ZUNvbnRleHQoY29udGV4dCwge1xuICAgICAgdGFyZ2V0OiBhYnNQYXRoLFxuICAgICAgb3V0cHV0OiBkaXJlY3RvcnlJdGVtc1xuICAgIH0pO1xuXG4gICAgaWYgKHJlY3Vyc2l2ZSAmJiBzdGF0cy5pc0RpcmVjdG9yeSgpKSB7XG4gICAgICBhZGREaXIobmV3Q29udGV4dCwgc3RhdHMpO1xuICAgIH0gZWxzZSBpZiAoc3RhdHMuaXNGaWxlKCkpIHtcbiAgICAgIGFkZEZpbGUobmV3Q29udGV4dCwgc3RhdHMpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIG91dHB1dFtvdXRwdXRQcm9wS2V5XTtcbn1cblxuLyoqXG4gKiBMb2FkIGRpcmVjdG9yeSBvciBmaWxlIGZyb20gcmVhbCBGU1xuICovXG5leHBvcnRzLmxvYWQgPSBmdW5jdGlvbihwLCBvcHRpb25zKSB7XG4gIHJldHVybiBieXBhc3MoKCkgPT4ge1xuICAgIHAgPSBwYXRoLnJlc29sdmUocCk7XG5cbiAgICBjb25zdCBzdGF0cyA9IGZzLnN0YXRTeW5jKHApO1xuICAgIGNvbnN0IGNvbnRleHQgPSBjcmVhdGVDb250ZXh0KHtvdXRwdXQ6IHt9LCBvcHRpb25zLCB0YXJnZXQ6IHB9KTtcblxuICAgIGlmIChzdGF0cy5pc0RpcmVjdG9yeSgpKSB7XG4gICAgICByZXR1cm4gYWRkRGlyKGNvbnRleHQsIHN0YXRzLCB0cnVlKTtcbiAgICB9IGVsc2UgaWYgKHN0YXRzLmlzRmlsZSgpKSB7XG4gICAgICByZXR1cm4gYWRkRmlsZShjb250ZXh0LCBzdGF0cywgdHJ1ZSk7XG4gICAgfVxuICB9KTtcbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/mock-fs/lib/loader.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/mock-fs/lib/symlink.js":
/*!*************************************************!*\
  !*** ../../node_modules/mock-fs/lib/symlink.js ***!
  \*************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\n\nconst util = __webpack_require__(/*! util */ \"util\");\n\nconst Item = __webpack_require__(/*! ./item */ \"(rsc)/../../node_modules/mock-fs/lib/item.js\");\n\nconst constants = __webpack_require__(/*! constants */ \"constants\");\n\n/**\n * A directory.\n * @constructor\n */\nfunction SymbolicLink() {\n  Item.call(this);\n\n  /**\n   * Relative path to source.\n   * @type {string}\n   */\n  this._path = undefined;\n}\nutil.inherits(SymbolicLink, Item);\n\n/**\n * Set the path to the source.\n * @param {string} pathname Path to source.\n */\nSymbolicLink.prototype.setPath = function(pathname) {\n  this._path = pathname;\n};\n\n/**\n * Get the path to the source.\n * @return {string} Path to source.\n */\nSymbolicLink.prototype.getPath = function() {\n  return this._path;\n};\n\n/**\n * Get symbolic link stats.\n * @return {Object} Stats properties.\n */\nSymbolicLink.prototype.getStats = function() {\n  const size = this._path.length;\n  const stats = Item.prototype.getStats.call(this);\n  stats.mode = this.getMode() | constants.S_IFLNK;\n  stats.size = size;\n  stats.blocks = Math.ceil(size / 512);\n  return stats;\n};\n\n/**\n * Export the constructor.\n * @type {function()}\n */\nexports = module.exports = SymbolicLink;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL21vY2stZnMvbGliL3N5bWxpbmsuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsYUFBYSxtQkFBTyxDQUFDLGtCQUFNOztBQUUzQixhQUFhLG1CQUFPLENBQUMsNERBQVE7O0FBRTdCLGtCQUFrQixtQkFBTyxDQUFDLDRCQUFXOztBQUVyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9iYXJiL2FhL0Fzc29jaWF0ZWRBY2NvdW50cy9ub2RlX21vZHVsZXMvbW9jay1mcy9saWIvc3ltbGluay5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG5cbmNvbnN0IEl0ZW0gPSByZXF1aXJlKCcuL2l0ZW0nKTtcblxuY29uc3QgY29uc3RhbnRzID0gcmVxdWlyZSgnY29uc3RhbnRzJyk7XG5cbi8qKlxuICogQSBkaXJlY3RvcnkuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gU3ltYm9saWNMaW5rKCkge1xuICBJdGVtLmNhbGwodGhpcyk7XG5cbiAgLyoqXG4gICAqIFJlbGF0aXZlIHBhdGggdG8gc291cmNlLlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgdGhpcy5fcGF0aCA9IHVuZGVmaW5lZDtcbn1cbnV0aWwuaW5oZXJpdHMoU3ltYm9saWNMaW5rLCBJdGVtKTtcblxuLyoqXG4gKiBTZXQgdGhlIHBhdGggdG8gdGhlIHNvdXJjZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRobmFtZSBQYXRoIHRvIHNvdXJjZS5cbiAqL1xuU3ltYm9saWNMaW5rLnByb3RvdHlwZS5zZXRQYXRoID0gZnVuY3Rpb24ocGF0aG5hbWUpIHtcbiAgdGhpcy5fcGF0aCA9IHBhdGhuYW1lO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIHBhdGggdG8gdGhlIHNvdXJjZS5cbiAqIEByZXR1cm4ge3N0cmluZ30gUGF0aCB0byBzb3VyY2UuXG4gKi9cblN5bWJvbGljTGluay5wcm90b3R5cGUuZ2V0UGF0aCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fcGF0aDtcbn07XG5cbi8qKlxuICogR2V0IHN5bWJvbGljIGxpbmsgc3RhdHMuXG4gKiBAcmV0dXJuIHtPYmplY3R9IFN0YXRzIHByb3BlcnRpZXMuXG4gKi9cblN5bWJvbGljTGluay5wcm90b3R5cGUuZ2V0U3RhdHMgPSBmdW5jdGlvbigpIHtcbiAgY29uc3Qgc2l6ZSA9IHRoaXMuX3BhdGgubGVuZ3RoO1xuICBjb25zdCBzdGF0cyA9IEl0ZW0ucHJvdG90eXBlLmdldFN0YXRzLmNhbGwodGhpcyk7XG4gIHN0YXRzLm1vZGUgPSB0aGlzLmdldE1vZGUoKSB8IGNvbnN0YW50cy5TX0lGTE5LO1xuICBzdGF0cy5zaXplID0gc2l6ZTtcbiAgc3RhdHMuYmxvY2tzID0gTWF0aC5jZWlsKHNpemUgLyA1MTIpO1xuICByZXR1cm4gc3RhdHM7XG59O1xuXG4vKipcbiAqIEV4cG9ydCB0aGUgY29uc3RydWN0b3IuXG4gKiBAdHlwZSB7ZnVuY3Rpb24oKX1cbiAqL1xuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gU3ltYm9saWNMaW5rO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/mock-fs/lib/symlink.js\n");

/***/ })

};
;