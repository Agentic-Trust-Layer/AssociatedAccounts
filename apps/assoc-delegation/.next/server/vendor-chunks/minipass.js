"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/minipass";
exports.ids = ["vendor-chunks/minipass"];
exports.modules = {

/***/ "(rsc)/../../node_modules/minipass/index.js":
/*!********************************************!*\
  !*** ../../node_modules/minipass/index.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst EE = __webpack_require__(/*! events */ \"events\")\nconst Yallist = __webpack_require__(/*! yallist */ \"(rsc)/../../node_modules/yallist/yallist.js\")\nconst SD = (__webpack_require__(/*! string_decoder */ \"string_decoder\").StringDecoder)\n\nconst EOF = Symbol('EOF')\nconst MAYBE_EMIT_END = Symbol('maybeEmitEnd')\nconst EMITTED_END = Symbol('emittedEnd')\nconst EMITTING_END = Symbol('emittingEnd')\nconst CLOSED = Symbol('closed')\nconst READ = Symbol('read')\nconst FLUSH = Symbol('flush')\nconst FLUSHCHUNK = Symbol('flushChunk')\nconst ENCODING = Symbol('encoding')\nconst DECODER = Symbol('decoder')\nconst FLOWING = Symbol('flowing')\nconst PAUSED = Symbol('paused')\nconst RESUME = Symbol('resume')\nconst BUFFERLENGTH = Symbol('bufferLength')\nconst BUFFERPUSH = Symbol('bufferPush')\nconst BUFFERSHIFT = Symbol('bufferShift')\nconst OBJECTMODE = Symbol('objectMode')\nconst DESTROYED = Symbol('destroyed')\n\n// TODO remove when Node v8 support drops\nconst doIter = global._MP_NO_ITERATOR_SYMBOLS_  !== '1'\nconst ASYNCITERATOR = doIter && Symbol.asyncIterator\n  || Symbol('asyncIterator not implemented')\nconst ITERATOR = doIter && Symbol.iterator\n  || Symbol('iterator not implemented')\n\n// Buffer in node 4.x < 4.5.0 doesn't have working Buffer.from\n// or Buffer.alloc, and Buffer in node 10 deprecated the ctor.\n// .M, this is fine .\\^/M..\nconst B = Buffer.alloc ? Buffer\n  : /* istanbul ignore next */ (__webpack_require__(/*! safe-buffer */ \"(rsc)/../../node_modules/safe-buffer/index.js\").Buffer)\n\n// events that mean 'the stream is over'\n// these are treated specially, and re-emitted\n// if they are listened for after emitting.\nconst isEndish = ev =>\n  ev === 'end' ||\n  ev === 'finish' ||\n  ev === 'prefinish'\n\nconst isArrayBuffer = b => b instanceof ArrayBuffer ||\n  typeof b === 'object' &&\n  b.constructor &&\n  b.constructor.name === 'ArrayBuffer' &&\n  b.byteLength >= 0\n\nconst isArrayBufferView = b => !B.isBuffer(b) && ArrayBuffer.isView(b)\n\nmodule.exports = class Minipass extends EE {\n  constructor (options) {\n    super()\n    this[FLOWING] = false\n    // whether we're explicitly paused\n    this[PAUSED] = false\n    this.pipes = new Yallist()\n    this.buffer = new Yallist()\n    this[OBJECTMODE] = options && options.objectMode || false\n    if (this[OBJECTMODE])\n      this[ENCODING] = null\n    else\n      this[ENCODING] = options && options.encoding || null\n    if (this[ENCODING] === 'buffer')\n      this[ENCODING] = null\n    this[DECODER] = this[ENCODING] ? new SD(this[ENCODING]) : null\n    this[EOF] = false\n    this[EMITTED_END] = false\n    this[EMITTING_END] = false\n    this[CLOSED] = false\n    this.writable = true\n    this.readable = true\n    this[BUFFERLENGTH] = 0\n    this[DESTROYED] = false\n  }\n\n  get bufferLength () { return this[BUFFERLENGTH] }\n\n  get encoding () { return this[ENCODING] }\n  set encoding (enc) {\n    if (this[OBJECTMODE])\n      throw new Error('cannot set encoding in objectMode')\n\n    if (this[ENCODING] && enc !== this[ENCODING] &&\n        (this[DECODER] && this[DECODER].lastNeed || this[BUFFERLENGTH]))\n      throw new Error('cannot change encoding')\n\n    if (this[ENCODING] !== enc) {\n      this[DECODER] = enc ? new SD(enc) : null\n      if (this.buffer.length)\n        this.buffer = this.buffer.map(chunk => this[DECODER].write(chunk))\n    }\n\n    this[ENCODING] = enc\n  }\n\n  setEncoding (enc) {\n    this.encoding = enc\n  }\n\n  get objectMode () { return this[OBJECTMODE] }\n  set objectMode (ॐ ) { this[OBJECTMODE] = this[OBJECTMODE] || !!ॐ  }\n\n  write (chunk, encoding, cb) {\n    if (this[EOF])\n      throw new Error('write after end')\n\n    if (this[DESTROYED]) {\n      this.emit('error', Object.assign(\n        new Error('Cannot call write after a stream was destroyed'),\n        { code: 'ERR_STREAM_DESTROYED' }\n      ))\n      return true\n    }\n\n    if (typeof encoding === 'function')\n      cb = encoding, encoding = 'utf8'\n\n    if (!encoding)\n      encoding = 'utf8'\n\n    // convert array buffers and typed array views into buffers\n    // at some point in the future, we may want to do the opposite!\n    // leave strings and buffers as-is\n    // anything else switches us into object mode\n    if (!this[OBJECTMODE] && !B.isBuffer(chunk)) {\n      if (isArrayBufferView(chunk))\n        chunk = B.from(chunk.buffer, chunk.byteOffset, chunk.byteLength)\n      else if (isArrayBuffer(chunk))\n        chunk = B.from(chunk)\n      else if (typeof chunk !== 'string')\n        // use the setter so we throw if we have encoding set\n        this.objectMode = true\n    }\n\n    // this ensures at this point that the chunk is a buffer or string\n    // don't buffer it up or send it to the decoder\n    if (!this.objectMode && !chunk.length) {\n      const ret = this.flowing\n      if (this[BUFFERLENGTH] !== 0)\n        this.emit('readable')\n      if (cb)\n        cb()\n      return ret\n    }\n\n    // fast-path writing strings of same encoding to a stream with\n    // an empty buffer, skipping the buffer/decoder dance\n    if (typeof chunk === 'string' && !this[OBJECTMODE] &&\n        // unless it is a string already ready for us to use\n        !(encoding === this[ENCODING] && !this[DECODER].lastNeed)) {\n      chunk = B.from(chunk, encoding)\n    }\n\n    if (B.isBuffer(chunk) && this[ENCODING])\n      chunk = this[DECODER].write(chunk)\n\n    try {\n      return this.flowing\n        ? (this.emit('data', chunk), this.flowing)\n        : (this[BUFFERPUSH](chunk), false)\n    } finally {\n      if (this[BUFFERLENGTH] !== 0)\n        this.emit('readable')\n      if (cb)\n        cb()\n    }\n  }\n\n  read (n) {\n    if (this[DESTROYED])\n      return null\n\n    try {\n      if (this[BUFFERLENGTH] === 0 || n === 0 || n > this[BUFFERLENGTH])\n        return null\n\n      if (this[OBJECTMODE])\n        n = null\n\n      if (this.buffer.length > 1 && !this[OBJECTMODE]) {\n        if (this.encoding)\n          this.buffer = new Yallist([\n            Array.from(this.buffer).join('')\n          ])\n        else\n          this.buffer = new Yallist([\n            B.concat(Array.from(this.buffer), this[BUFFERLENGTH])\n          ])\n      }\n\n      return this[READ](n || null, this.buffer.head.value)\n    } finally {\n      this[MAYBE_EMIT_END]()\n    }\n  }\n\n  [READ] (n, chunk) {\n    if (n === chunk.length || n === null)\n      this[BUFFERSHIFT]()\n    else {\n      this.buffer.head.value = chunk.slice(n)\n      chunk = chunk.slice(0, n)\n      this[BUFFERLENGTH] -= n\n    }\n\n    this.emit('data', chunk)\n\n    if (!this.buffer.length && !this[EOF])\n      this.emit('drain')\n\n    return chunk\n  }\n\n  end (chunk, encoding, cb) {\n    if (typeof chunk === 'function')\n      cb = chunk, chunk = null\n    if (typeof encoding === 'function')\n      cb = encoding, encoding = 'utf8'\n    if (chunk)\n      this.write(chunk, encoding)\n    if (cb)\n      this.once('end', cb)\n    this[EOF] = true\n    this.writable = false\n\n    // if we haven't written anything, then go ahead and emit,\n    // even if we're not reading.\n    // we'll re-emit if a new 'end' listener is added anyway.\n    // This makes MP more suitable to write-only use cases.\n    if (this.flowing || !this[PAUSED])\n      this[MAYBE_EMIT_END]()\n    return this\n  }\n\n  // don't let the internal resume be overwritten\n  [RESUME] () {\n    if (this[DESTROYED])\n      return\n\n    this[PAUSED] = false\n    this[FLOWING] = true\n    this.emit('resume')\n    if (this.buffer.length)\n      this[FLUSH]()\n    else if (this[EOF])\n      this[MAYBE_EMIT_END]()\n    else\n      this.emit('drain')\n  }\n\n  resume () {\n    return this[RESUME]()\n  }\n\n  pause () {\n    this[FLOWING] = false\n    this[PAUSED] = true\n  }\n\n  get destroyed () {\n    return this[DESTROYED]\n  }\n\n  get flowing () {\n    return this[FLOWING]\n  }\n\n  get paused () {\n    return this[PAUSED]\n  }\n\n  [BUFFERPUSH] (chunk) {\n    if (this[OBJECTMODE])\n      this[BUFFERLENGTH] += 1\n    else\n      this[BUFFERLENGTH] += chunk.length\n    return this.buffer.push(chunk)\n  }\n\n  [BUFFERSHIFT] () {\n    if (this.buffer.length) {\n      if (this[OBJECTMODE])\n        this[BUFFERLENGTH] -= 1\n      else\n        this[BUFFERLENGTH] -= this.buffer.head.value.length\n    }\n    return this.buffer.shift()\n  }\n\n  [FLUSH] () {\n    do {} while (this[FLUSHCHUNK](this[BUFFERSHIFT]()))\n\n    if (!this.buffer.length && !this[EOF])\n      this.emit('drain')\n  }\n\n  [FLUSHCHUNK] (chunk) {\n    return chunk ? (this.emit('data', chunk), this.flowing) : false\n  }\n\n  pipe (dest, opts) {\n    if (this[DESTROYED])\n      return\n\n    const ended = this[EMITTED_END]\n    opts = opts || {}\n    if (dest === process.stdout || dest === process.stderr)\n      opts.end = false\n    else\n      opts.end = opts.end !== false\n\n    const p = { dest: dest, opts: opts, ondrain: _ => this[RESUME]() }\n    this.pipes.push(p)\n\n    dest.on('drain', p.ondrain)\n    this[RESUME]()\n    // piping an ended stream ends immediately\n    if (ended && p.opts.end)\n      p.dest.end()\n    return dest\n  }\n\n  addListener (ev, fn) {\n    return this.on(ev, fn)\n  }\n\n  on (ev, fn) {\n    try {\n      return super.on(ev, fn)\n    } finally {\n      if (ev === 'data' && !this.pipes.length && !this.flowing)\n        this[RESUME]()\n      else if (isEndish(ev) && this[EMITTED_END]) {\n        super.emit(ev)\n        this.removeAllListeners(ev)\n      }\n    }\n  }\n\n  get emittedEnd () {\n    return this[EMITTED_END]\n  }\n\n  [MAYBE_EMIT_END] () {\n    if (!this[EMITTING_END] &&\n        !this[EMITTED_END] &&\n        !this[DESTROYED] &&\n        this.buffer.length === 0 &&\n        this[EOF]) {\n      this[EMITTING_END] = true\n      this.emit('end')\n      this.emit('prefinish')\n      this.emit('finish')\n      if (this[CLOSED])\n        this.emit('close')\n      this[EMITTING_END] = false\n    }\n  }\n\n  emit (ev, data) {\n    // error and close are only events allowed after calling destroy()\n    if (ev !== 'error' && ev !== 'close' && ev !== DESTROYED && this[DESTROYED])\n      return\n    else if (ev === 'data') {\n      if (!data)\n        return\n\n      if (this.pipes.length)\n        this.pipes.forEach(p =>\n          p.dest.write(data) === false && this.pause())\n    } else if (ev === 'end') {\n      // only actual end gets this treatment\n      if (this[EMITTED_END] === true)\n        return\n\n      this[EMITTED_END] = true\n      this.readable = false\n\n      if (this[DECODER]) {\n        data = this[DECODER].end()\n        if (data) {\n          this.pipes.forEach(p => p.dest.write(data))\n          super.emit('data', data)\n        }\n      }\n\n      this.pipes.forEach(p => {\n        p.dest.removeListener('drain', p.ondrain)\n        if (p.opts.end)\n          p.dest.end()\n      })\n    } else if (ev === 'close') {\n      this[CLOSED] = true\n      // don't emit close before 'end' and 'finish'\n      if (!this[EMITTED_END] && !this[DESTROYED])\n        return\n    }\n\n    // TODO: replace with a spread operator when Node v4 support drops\n    const args = new Array(arguments.length)\n    args[0] = ev\n    args[1] = data\n    if (arguments.length > 2) {\n      for (let i = 2; i < arguments.length; i++) {\n        args[i] = arguments[i]\n      }\n    }\n\n    try {\n      return super.emit.apply(this, args)\n    } finally {\n      if (!isEndish(ev))\n        this[MAYBE_EMIT_END]()\n      else\n        this.removeAllListeners(ev)\n    }\n  }\n\n  // const all = await stream.collect()\n  collect () {\n    const buf = []\n    buf.dataLength = 0\n    this.on('data', c => {\n      buf.push(c)\n      buf.dataLength += c.length\n    })\n    return this.promise().then(() => buf)\n  }\n\n  // const data = await stream.concat()\n  concat () {\n    return this[OBJECTMODE]\n      ? Promise.reject(new Error('cannot concat in objectMode'))\n      : this.collect().then(buf =>\n          this[OBJECTMODE]\n            ? Promise.reject(new Error('cannot concat in objectMode'))\n            : this[ENCODING] ? buf.join('') : B.concat(buf, buf.dataLength))\n  }\n\n  // stream.promise().then(() => done, er => emitted error)\n  promise () {\n    return new Promise((resolve, reject) => {\n      this.on(DESTROYED, () => reject(new Error('stream destroyed')))\n      this.on('end', () => resolve())\n      this.on('error', er => reject(er))\n    })\n  }\n\n  // for await (let chunk of stream)\n  [ASYNCITERATOR] () {\n    const next = () => {\n      const res = this.read()\n      if (res !== null)\n        return Promise.resolve({ done: false, value: res })\n\n      if (this[EOF])\n        return Promise.resolve({ done: true })\n\n      let resolve = null\n      let reject = null\n      const onerr = er => {\n        this.removeListener('data', ondata)\n        this.removeListener('end', onend)\n        reject(er)\n      }\n      const ondata = value => {\n        this.removeListener('error', onerr)\n        this.removeListener('end', onend)\n        this.pause()\n        resolve({ value: value, done: !!this[EOF] })\n      }\n      const onend = () => {\n        this.removeListener('error', onerr)\n        this.removeListener('data', ondata)\n        resolve({ done: true })\n      }\n      const ondestroy = () => onerr(new Error('stream destroyed'))\n      return new Promise((res, rej) => {\n        reject = rej\n        resolve = res\n        this.once(DESTROYED, ondestroy)\n        this.once('error', onerr)\n        this.once('end', onend)\n        this.once('data', ondata)\n      })\n    }\n\n    return { next }\n  }\n\n  // for (let chunk of stream)\n  [ITERATOR] () {\n    const next = () => {\n      const value = this.read()\n      const done = value === null\n      return { value, done }\n    }\n    return { next }\n  }\n\n  destroy (er) {\n    if (this[DESTROYED]) {\n      if (er)\n        this.emit('error', er)\n      else\n        this.emit(DESTROYED)\n      return this\n    }\n\n    this[DESTROYED] = true\n\n    // throw away all buffered data, it's never coming out\n    this.buffer = new Yallist()\n    this[BUFFERLENGTH] = 0\n\n    if (typeof this.close === 'function' && !this[CLOSED])\n      this.close()\n\n    if (er)\n      this.emit('error', er)\n    else // if no error to emit, still reject pending promises\n      this.emit(DESTROYED)\n\n    return this\n  }\n\n  static isStream (s) {\n    return !!s && (s instanceof Minipass || s instanceof EE && (\n      typeof s.pipe === 'function' || // readable\n      (typeof s.write === 'function' && typeof s.end === 'function') // writable\n    ))\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL21pbmlwYXNzL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFZO0FBQ1osV0FBVyxtQkFBTyxDQUFDLHNCQUFRO0FBQzNCLGdCQUFnQixtQkFBTyxDQUFDLDREQUFTO0FBQ2pDLFdBQVcsMkVBQXVDOztBQUVsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGdHQUE2Qjs7QUFFNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0I7O0FBRXhCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCO0FBQ3RCLHdCQUF3Qjs7QUFFeEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVOztBQUVWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0I7QUFDaEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isc0JBQXNCO0FBQzVDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyx5QkFBeUI7O0FBRTFEO0FBQ0EsaUNBQWlDLFlBQVk7O0FBRTdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsaUNBQWlDO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFlBQVk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvYmFyYi9hYS9Bc3NvY2lhdGVkQWNjb3VudHMvbm9kZV9tb2R1bGVzL21pbmlwYXNzL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuY29uc3QgRUUgPSByZXF1aXJlKCdldmVudHMnKVxuY29uc3QgWWFsbGlzdCA9IHJlcXVpcmUoJ3lhbGxpc3QnKVxuY29uc3QgU0QgPSByZXF1aXJlKCdzdHJpbmdfZGVjb2RlcicpLlN0cmluZ0RlY29kZXJcblxuY29uc3QgRU9GID0gU3ltYm9sKCdFT0YnKVxuY29uc3QgTUFZQkVfRU1JVF9FTkQgPSBTeW1ib2woJ21heWJlRW1pdEVuZCcpXG5jb25zdCBFTUlUVEVEX0VORCA9IFN5bWJvbCgnZW1pdHRlZEVuZCcpXG5jb25zdCBFTUlUVElOR19FTkQgPSBTeW1ib2woJ2VtaXR0aW5nRW5kJylcbmNvbnN0IENMT1NFRCA9IFN5bWJvbCgnY2xvc2VkJylcbmNvbnN0IFJFQUQgPSBTeW1ib2woJ3JlYWQnKVxuY29uc3QgRkxVU0ggPSBTeW1ib2woJ2ZsdXNoJylcbmNvbnN0IEZMVVNIQ0hVTksgPSBTeW1ib2woJ2ZsdXNoQ2h1bmsnKVxuY29uc3QgRU5DT0RJTkcgPSBTeW1ib2woJ2VuY29kaW5nJylcbmNvbnN0IERFQ09ERVIgPSBTeW1ib2woJ2RlY29kZXInKVxuY29uc3QgRkxPV0lORyA9IFN5bWJvbCgnZmxvd2luZycpXG5jb25zdCBQQVVTRUQgPSBTeW1ib2woJ3BhdXNlZCcpXG5jb25zdCBSRVNVTUUgPSBTeW1ib2woJ3Jlc3VtZScpXG5jb25zdCBCVUZGRVJMRU5HVEggPSBTeW1ib2woJ2J1ZmZlckxlbmd0aCcpXG5jb25zdCBCVUZGRVJQVVNIID0gU3ltYm9sKCdidWZmZXJQdXNoJylcbmNvbnN0IEJVRkZFUlNISUZUID0gU3ltYm9sKCdidWZmZXJTaGlmdCcpXG5jb25zdCBPQkpFQ1RNT0RFID0gU3ltYm9sKCdvYmplY3RNb2RlJylcbmNvbnN0IERFU1RST1lFRCA9IFN5bWJvbCgnZGVzdHJveWVkJylcblxuLy8gVE9ETyByZW1vdmUgd2hlbiBOb2RlIHY4IHN1cHBvcnQgZHJvcHNcbmNvbnN0IGRvSXRlciA9IGdsb2JhbC5fTVBfTk9fSVRFUkFUT1JfU1lNQk9MU18gICE9PSAnMSdcbmNvbnN0IEFTWU5DSVRFUkFUT1IgPSBkb0l0ZXIgJiYgU3ltYm9sLmFzeW5jSXRlcmF0b3JcbiAgfHwgU3ltYm9sKCdhc3luY0l0ZXJhdG9yIG5vdCBpbXBsZW1lbnRlZCcpXG5jb25zdCBJVEVSQVRPUiA9IGRvSXRlciAmJiBTeW1ib2wuaXRlcmF0b3JcbiAgfHwgU3ltYm9sKCdpdGVyYXRvciBub3QgaW1wbGVtZW50ZWQnKVxuXG4vLyBCdWZmZXIgaW4gbm9kZSA0LnggPCA0LjUuMCBkb2Vzbid0IGhhdmUgd29ya2luZyBCdWZmZXIuZnJvbVxuLy8gb3IgQnVmZmVyLmFsbG9jLCBhbmQgQnVmZmVyIGluIG5vZGUgMTAgZGVwcmVjYXRlZCB0aGUgY3Rvci5cbi8vIC5NLCB0aGlzIGlzIGZpbmUgLlxcXi9NLi5cbmNvbnN0IEIgPSBCdWZmZXIuYWxsb2MgPyBCdWZmZXJcbiAgOiAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlclxuXG4vLyBldmVudHMgdGhhdCBtZWFuICd0aGUgc3RyZWFtIGlzIG92ZXInXG4vLyB0aGVzZSBhcmUgdHJlYXRlZCBzcGVjaWFsbHksIGFuZCByZS1lbWl0dGVkXG4vLyBpZiB0aGV5IGFyZSBsaXN0ZW5lZCBmb3IgYWZ0ZXIgZW1pdHRpbmcuXG5jb25zdCBpc0VuZGlzaCA9IGV2ID0+XG4gIGV2ID09PSAnZW5kJyB8fFxuICBldiA9PT0gJ2ZpbmlzaCcgfHxcbiAgZXYgPT09ICdwcmVmaW5pc2gnXG5cbmNvbnN0IGlzQXJyYXlCdWZmZXIgPSBiID0+IGIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciB8fFxuICB0eXBlb2YgYiA9PT0gJ29iamVjdCcgJiZcbiAgYi5jb25zdHJ1Y3RvciAmJlxuICBiLmNvbnN0cnVjdG9yLm5hbWUgPT09ICdBcnJheUJ1ZmZlcicgJiZcbiAgYi5ieXRlTGVuZ3RoID49IDBcblxuY29uc3QgaXNBcnJheUJ1ZmZlclZpZXcgPSBiID0+ICFCLmlzQnVmZmVyKGIpICYmIEFycmF5QnVmZmVyLmlzVmlldyhiKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIE1pbmlwYXNzIGV4dGVuZHMgRUUge1xuICBjb25zdHJ1Y3RvciAob3B0aW9ucykge1xuICAgIHN1cGVyKClcbiAgICB0aGlzW0ZMT1dJTkddID0gZmFsc2VcbiAgICAvLyB3aGV0aGVyIHdlJ3JlIGV4cGxpY2l0bHkgcGF1c2VkXG4gICAgdGhpc1tQQVVTRURdID0gZmFsc2VcbiAgICB0aGlzLnBpcGVzID0gbmV3IFlhbGxpc3QoKVxuICAgIHRoaXMuYnVmZmVyID0gbmV3IFlhbGxpc3QoKVxuICAgIHRoaXNbT0JKRUNUTU9ERV0gPSBvcHRpb25zICYmIG9wdGlvbnMub2JqZWN0TW9kZSB8fCBmYWxzZVxuICAgIGlmICh0aGlzW09CSkVDVE1PREVdKVxuICAgICAgdGhpc1tFTkNPRElOR10gPSBudWxsXG4gICAgZWxzZVxuICAgICAgdGhpc1tFTkNPRElOR10gPSBvcHRpb25zICYmIG9wdGlvbnMuZW5jb2RpbmcgfHwgbnVsbFxuICAgIGlmICh0aGlzW0VOQ09ESU5HXSA9PT0gJ2J1ZmZlcicpXG4gICAgICB0aGlzW0VOQ09ESU5HXSA9IG51bGxcbiAgICB0aGlzW0RFQ09ERVJdID0gdGhpc1tFTkNPRElOR10gPyBuZXcgU0QodGhpc1tFTkNPRElOR10pIDogbnVsbFxuICAgIHRoaXNbRU9GXSA9IGZhbHNlXG4gICAgdGhpc1tFTUlUVEVEX0VORF0gPSBmYWxzZVxuICAgIHRoaXNbRU1JVFRJTkdfRU5EXSA9IGZhbHNlXG4gICAgdGhpc1tDTE9TRURdID0gZmFsc2VcbiAgICB0aGlzLndyaXRhYmxlID0gdHJ1ZVxuICAgIHRoaXMucmVhZGFibGUgPSB0cnVlXG4gICAgdGhpc1tCVUZGRVJMRU5HVEhdID0gMFxuICAgIHRoaXNbREVTVFJPWUVEXSA9IGZhbHNlXG4gIH1cblxuICBnZXQgYnVmZmVyTGVuZ3RoICgpIHsgcmV0dXJuIHRoaXNbQlVGRkVSTEVOR1RIXSB9XG5cbiAgZ2V0IGVuY29kaW5nICgpIHsgcmV0dXJuIHRoaXNbRU5DT0RJTkddIH1cbiAgc2V0IGVuY29kaW5nIChlbmMpIHtcbiAgICBpZiAodGhpc1tPQkpFQ1RNT0RFXSlcbiAgICAgIHRocm93IG5ldyBFcnJvcignY2Fubm90IHNldCBlbmNvZGluZyBpbiBvYmplY3RNb2RlJylcblxuICAgIGlmICh0aGlzW0VOQ09ESU5HXSAmJiBlbmMgIT09IHRoaXNbRU5DT0RJTkddICYmXG4gICAgICAgICh0aGlzW0RFQ09ERVJdICYmIHRoaXNbREVDT0RFUl0ubGFzdE5lZWQgfHwgdGhpc1tCVUZGRVJMRU5HVEhdKSlcbiAgICAgIHRocm93IG5ldyBFcnJvcignY2Fubm90IGNoYW5nZSBlbmNvZGluZycpXG5cbiAgICBpZiAodGhpc1tFTkNPRElOR10gIT09IGVuYykge1xuICAgICAgdGhpc1tERUNPREVSXSA9IGVuYyA/IG5ldyBTRChlbmMpIDogbnVsbFxuICAgICAgaWYgKHRoaXMuYnVmZmVyLmxlbmd0aClcbiAgICAgICAgdGhpcy5idWZmZXIgPSB0aGlzLmJ1ZmZlci5tYXAoY2h1bmsgPT4gdGhpc1tERUNPREVSXS53cml0ZShjaHVuaykpXG4gICAgfVxuXG4gICAgdGhpc1tFTkNPRElOR10gPSBlbmNcbiAgfVxuXG4gIHNldEVuY29kaW5nIChlbmMpIHtcbiAgICB0aGlzLmVuY29kaW5nID0gZW5jXG4gIH1cblxuICBnZXQgb2JqZWN0TW9kZSAoKSB7IHJldHVybiB0aGlzW09CSkVDVE1PREVdIH1cbiAgc2V0IG9iamVjdE1vZGUgKOClkCApIHsgdGhpc1tPQkpFQ1RNT0RFXSA9IHRoaXNbT0JKRUNUTU9ERV0gfHwgISHgpZAgIH1cblxuICB3cml0ZSAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICAgIGlmICh0aGlzW0VPRl0pXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3dyaXRlIGFmdGVyIGVuZCcpXG5cbiAgICBpZiAodGhpc1tERVNUUk9ZRURdKSB7XG4gICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgT2JqZWN0LmFzc2lnbihcbiAgICAgICAgbmV3IEVycm9yKCdDYW5ub3QgY2FsbCB3cml0ZSBhZnRlciBhIHN0cmVhbSB3YXMgZGVzdHJveWVkJyksXG4gICAgICAgIHsgY29kZTogJ0VSUl9TVFJFQU1fREVTVFJPWUVEJyB9XG4gICAgICApKVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnZnVuY3Rpb24nKVxuICAgICAgY2IgPSBlbmNvZGluZywgZW5jb2RpbmcgPSAndXRmOCdcblxuICAgIGlmICghZW5jb2RpbmcpXG4gICAgICBlbmNvZGluZyA9ICd1dGY4J1xuXG4gICAgLy8gY29udmVydCBhcnJheSBidWZmZXJzIGFuZCB0eXBlZCBhcnJheSB2aWV3cyBpbnRvIGJ1ZmZlcnNcbiAgICAvLyBhdCBzb21lIHBvaW50IGluIHRoZSBmdXR1cmUsIHdlIG1heSB3YW50IHRvIGRvIHRoZSBvcHBvc2l0ZSFcbiAgICAvLyBsZWF2ZSBzdHJpbmdzIGFuZCBidWZmZXJzIGFzLWlzXG4gICAgLy8gYW55dGhpbmcgZWxzZSBzd2l0Y2hlcyB1cyBpbnRvIG9iamVjdCBtb2RlXG4gICAgaWYgKCF0aGlzW09CSkVDVE1PREVdICYmICFCLmlzQnVmZmVyKGNodW5rKSkge1xuICAgICAgaWYgKGlzQXJyYXlCdWZmZXJWaWV3KGNodW5rKSlcbiAgICAgICAgY2h1bmsgPSBCLmZyb20oY2h1bmsuYnVmZmVyLCBjaHVuay5ieXRlT2Zmc2V0LCBjaHVuay5ieXRlTGVuZ3RoKVxuICAgICAgZWxzZSBpZiAoaXNBcnJheUJ1ZmZlcihjaHVuaykpXG4gICAgICAgIGNodW5rID0gQi5mcm9tKGNodW5rKVxuICAgICAgZWxzZSBpZiAodHlwZW9mIGNodW5rICE9PSAnc3RyaW5nJylcbiAgICAgICAgLy8gdXNlIHRoZSBzZXR0ZXIgc28gd2UgdGhyb3cgaWYgd2UgaGF2ZSBlbmNvZGluZyBzZXRcbiAgICAgICAgdGhpcy5vYmplY3RNb2RlID0gdHJ1ZVxuICAgIH1cblxuICAgIC8vIHRoaXMgZW5zdXJlcyBhdCB0aGlzIHBvaW50IHRoYXQgdGhlIGNodW5rIGlzIGEgYnVmZmVyIG9yIHN0cmluZ1xuICAgIC8vIGRvbid0IGJ1ZmZlciBpdCB1cCBvciBzZW5kIGl0IHRvIHRoZSBkZWNvZGVyXG4gICAgaWYgKCF0aGlzLm9iamVjdE1vZGUgJiYgIWNodW5rLmxlbmd0aCkge1xuICAgICAgY29uc3QgcmV0ID0gdGhpcy5mbG93aW5nXG4gICAgICBpZiAodGhpc1tCVUZGRVJMRU5HVEhdICE9PSAwKVxuICAgICAgICB0aGlzLmVtaXQoJ3JlYWRhYmxlJylcbiAgICAgIGlmIChjYilcbiAgICAgICAgY2IoKVxuICAgICAgcmV0dXJuIHJldFxuICAgIH1cblxuICAgIC8vIGZhc3QtcGF0aCB3cml0aW5nIHN0cmluZ3Mgb2Ygc2FtZSBlbmNvZGluZyB0byBhIHN0cmVhbSB3aXRoXG4gICAgLy8gYW4gZW1wdHkgYnVmZmVyLCBza2lwcGluZyB0aGUgYnVmZmVyL2RlY29kZXIgZGFuY2VcbiAgICBpZiAodHlwZW9mIGNodW5rID09PSAnc3RyaW5nJyAmJiAhdGhpc1tPQkpFQ1RNT0RFXSAmJlxuICAgICAgICAvLyB1bmxlc3MgaXQgaXMgYSBzdHJpbmcgYWxyZWFkeSByZWFkeSBmb3IgdXMgdG8gdXNlXG4gICAgICAgICEoZW5jb2RpbmcgPT09IHRoaXNbRU5DT0RJTkddICYmICF0aGlzW0RFQ09ERVJdLmxhc3ROZWVkKSkge1xuICAgICAgY2h1bmsgPSBCLmZyb20oY2h1bmssIGVuY29kaW5nKVxuICAgIH1cblxuICAgIGlmIChCLmlzQnVmZmVyKGNodW5rKSAmJiB0aGlzW0VOQ09ESU5HXSlcbiAgICAgIGNodW5rID0gdGhpc1tERUNPREVSXS53cml0ZShjaHVuaylcblxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gdGhpcy5mbG93aW5nXG4gICAgICAgID8gKHRoaXMuZW1pdCgnZGF0YScsIGNodW5rKSwgdGhpcy5mbG93aW5nKVxuICAgICAgICA6ICh0aGlzW0JVRkZFUlBVU0hdKGNodW5rKSwgZmFsc2UpXG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmICh0aGlzW0JVRkZFUkxFTkdUSF0gIT09IDApXG4gICAgICAgIHRoaXMuZW1pdCgncmVhZGFibGUnKVxuICAgICAgaWYgKGNiKVxuICAgICAgICBjYigpXG4gICAgfVxuICB9XG5cbiAgcmVhZCAobikge1xuICAgIGlmICh0aGlzW0RFU1RST1lFRF0pXG4gICAgICByZXR1cm4gbnVsbFxuXG4gICAgdHJ5IHtcbiAgICAgIGlmICh0aGlzW0JVRkZFUkxFTkdUSF0gPT09IDAgfHwgbiA9PT0gMCB8fCBuID4gdGhpc1tCVUZGRVJMRU5HVEhdKVxuICAgICAgICByZXR1cm4gbnVsbFxuXG4gICAgICBpZiAodGhpc1tPQkpFQ1RNT0RFXSlcbiAgICAgICAgbiA9IG51bGxcblxuICAgICAgaWYgKHRoaXMuYnVmZmVyLmxlbmd0aCA+IDEgJiYgIXRoaXNbT0JKRUNUTU9ERV0pIHtcbiAgICAgICAgaWYgKHRoaXMuZW5jb2RpbmcpXG4gICAgICAgICAgdGhpcy5idWZmZXIgPSBuZXcgWWFsbGlzdChbXG4gICAgICAgICAgICBBcnJheS5mcm9tKHRoaXMuYnVmZmVyKS5qb2luKCcnKVxuICAgICAgICAgIF0pXG4gICAgICAgIGVsc2VcbiAgICAgICAgICB0aGlzLmJ1ZmZlciA9IG5ldyBZYWxsaXN0KFtcbiAgICAgICAgICAgIEIuY29uY2F0KEFycmF5LmZyb20odGhpcy5idWZmZXIpLCB0aGlzW0JVRkZFUkxFTkdUSF0pXG4gICAgICAgICAgXSlcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXNbUkVBRF0obiB8fCBudWxsLCB0aGlzLmJ1ZmZlci5oZWFkLnZhbHVlKVxuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzW01BWUJFX0VNSVRfRU5EXSgpXG4gICAgfVxuICB9XG5cbiAgW1JFQURdIChuLCBjaHVuaykge1xuICAgIGlmIChuID09PSBjaHVuay5sZW5ndGggfHwgbiA9PT0gbnVsbClcbiAgICAgIHRoaXNbQlVGRkVSU0hJRlRdKClcbiAgICBlbHNlIHtcbiAgICAgIHRoaXMuYnVmZmVyLmhlYWQudmFsdWUgPSBjaHVuay5zbGljZShuKVxuICAgICAgY2h1bmsgPSBjaHVuay5zbGljZSgwLCBuKVxuICAgICAgdGhpc1tCVUZGRVJMRU5HVEhdIC09IG5cbiAgICB9XG5cbiAgICB0aGlzLmVtaXQoJ2RhdGEnLCBjaHVuaylcblxuICAgIGlmICghdGhpcy5idWZmZXIubGVuZ3RoICYmICF0aGlzW0VPRl0pXG4gICAgICB0aGlzLmVtaXQoJ2RyYWluJylcblxuICAgIHJldHVybiBjaHVua1xuICB9XG5cbiAgZW5kIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gICAgaWYgKHR5cGVvZiBjaHVuayA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgIGNiID0gY2h1bmssIGNodW5rID0gbnVsbFxuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdmdW5jdGlvbicpXG4gICAgICBjYiA9IGVuY29kaW5nLCBlbmNvZGluZyA9ICd1dGY4J1xuICAgIGlmIChjaHVuaylcbiAgICAgIHRoaXMud3JpdGUoY2h1bmssIGVuY29kaW5nKVxuICAgIGlmIChjYilcbiAgICAgIHRoaXMub25jZSgnZW5kJywgY2IpXG4gICAgdGhpc1tFT0ZdID0gdHJ1ZVxuICAgIHRoaXMud3JpdGFibGUgPSBmYWxzZVxuXG4gICAgLy8gaWYgd2UgaGF2ZW4ndCB3cml0dGVuIGFueXRoaW5nLCB0aGVuIGdvIGFoZWFkIGFuZCBlbWl0LFxuICAgIC8vIGV2ZW4gaWYgd2UncmUgbm90IHJlYWRpbmcuXG4gICAgLy8gd2UnbGwgcmUtZW1pdCBpZiBhIG5ldyAnZW5kJyBsaXN0ZW5lciBpcyBhZGRlZCBhbnl3YXkuXG4gICAgLy8gVGhpcyBtYWtlcyBNUCBtb3JlIHN1aXRhYmxlIHRvIHdyaXRlLW9ubHkgdXNlIGNhc2VzLlxuICAgIGlmICh0aGlzLmZsb3dpbmcgfHwgIXRoaXNbUEFVU0VEXSlcbiAgICAgIHRoaXNbTUFZQkVfRU1JVF9FTkRdKClcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLy8gZG9uJ3QgbGV0IHRoZSBpbnRlcm5hbCByZXN1bWUgYmUgb3ZlcndyaXR0ZW5cbiAgW1JFU1VNRV0gKCkge1xuICAgIGlmICh0aGlzW0RFU1RST1lFRF0pXG4gICAgICByZXR1cm5cblxuICAgIHRoaXNbUEFVU0VEXSA9IGZhbHNlXG4gICAgdGhpc1tGTE9XSU5HXSA9IHRydWVcbiAgICB0aGlzLmVtaXQoJ3Jlc3VtZScpXG4gICAgaWYgKHRoaXMuYnVmZmVyLmxlbmd0aClcbiAgICAgIHRoaXNbRkxVU0hdKClcbiAgICBlbHNlIGlmICh0aGlzW0VPRl0pXG4gICAgICB0aGlzW01BWUJFX0VNSVRfRU5EXSgpXG4gICAgZWxzZVxuICAgICAgdGhpcy5lbWl0KCdkcmFpbicpXG4gIH1cblxuICByZXN1bWUgKCkge1xuICAgIHJldHVybiB0aGlzW1JFU1VNRV0oKVxuICB9XG5cbiAgcGF1c2UgKCkge1xuICAgIHRoaXNbRkxPV0lOR10gPSBmYWxzZVxuICAgIHRoaXNbUEFVU0VEXSA9IHRydWVcbiAgfVxuXG4gIGdldCBkZXN0cm95ZWQgKCkge1xuICAgIHJldHVybiB0aGlzW0RFU1RST1lFRF1cbiAgfVxuXG4gIGdldCBmbG93aW5nICgpIHtcbiAgICByZXR1cm4gdGhpc1tGTE9XSU5HXVxuICB9XG5cbiAgZ2V0IHBhdXNlZCAoKSB7XG4gICAgcmV0dXJuIHRoaXNbUEFVU0VEXVxuICB9XG5cbiAgW0JVRkZFUlBVU0hdIChjaHVuaykge1xuICAgIGlmICh0aGlzW09CSkVDVE1PREVdKVxuICAgICAgdGhpc1tCVUZGRVJMRU5HVEhdICs9IDFcbiAgICBlbHNlXG4gICAgICB0aGlzW0JVRkZFUkxFTkdUSF0gKz0gY2h1bmsubGVuZ3RoXG4gICAgcmV0dXJuIHRoaXMuYnVmZmVyLnB1c2goY2h1bmspXG4gIH1cblxuICBbQlVGRkVSU0hJRlRdICgpIHtcbiAgICBpZiAodGhpcy5idWZmZXIubGVuZ3RoKSB7XG4gICAgICBpZiAodGhpc1tPQkpFQ1RNT0RFXSlcbiAgICAgICAgdGhpc1tCVUZGRVJMRU5HVEhdIC09IDFcbiAgICAgIGVsc2VcbiAgICAgICAgdGhpc1tCVUZGRVJMRU5HVEhdIC09IHRoaXMuYnVmZmVyLmhlYWQudmFsdWUubGVuZ3RoXG4gICAgfVxuICAgIHJldHVybiB0aGlzLmJ1ZmZlci5zaGlmdCgpXG4gIH1cblxuICBbRkxVU0hdICgpIHtcbiAgICBkbyB7fSB3aGlsZSAodGhpc1tGTFVTSENIVU5LXSh0aGlzW0JVRkZFUlNISUZUXSgpKSlcblxuICAgIGlmICghdGhpcy5idWZmZXIubGVuZ3RoICYmICF0aGlzW0VPRl0pXG4gICAgICB0aGlzLmVtaXQoJ2RyYWluJylcbiAgfVxuXG4gIFtGTFVTSENIVU5LXSAoY2h1bmspIHtcbiAgICByZXR1cm4gY2h1bmsgPyAodGhpcy5lbWl0KCdkYXRhJywgY2h1bmspLCB0aGlzLmZsb3dpbmcpIDogZmFsc2VcbiAgfVxuXG4gIHBpcGUgKGRlc3QsIG9wdHMpIHtcbiAgICBpZiAodGhpc1tERVNUUk9ZRURdKVxuICAgICAgcmV0dXJuXG5cbiAgICBjb25zdCBlbmRlZCA9IHRoaXNbRU1JVFRFRF9FTkRdXG4gICAgb3B0cyA9IG9wdHMgfHwge31cbiAgICBpZiAoZGVzdCA9PT0gcHJvY2Vzcy5zdGRvdXQgfHwgZGVzdCA9PT0gcHJvY2Vzcy5zdGRlcnIpXG4gICAgICBvcHRzLmVuZCA9IGZhbHNlXG4gICAgZWxzZVxuICAgICAgb3B0cy5lbmQgPSBvcHRzLmVuZCAhPT0gZmFsc2VcblxuICAgIGNvbnN0IHAgPSB7IGRlc3Q6IGRlc3QsIG9wdHM6IG9wdHMsIG9uZHJhaW46IF8gPT4gdGhpc1tSRVNVTUVdKCkgfVxuICAgIHRoaXMucGlwZXMucHVzaChwKVxuXG4gICAgZGVzdC5vbignZHJhaW4nLCBwLm9uZHJhaW4pXG4gICAgdGhpc1tSRVNVTUVdKClcbiAgICAvLyBwaXBpbmcgYW4gZW5kZWQgc3RyZWFtIGVuZHMgaW1tZWRpYXRlbHlcbiAgICBpZiAoZW5kZWQgJiYgcC5vcHRzLmVuZClcbiAgICAgIHAuZGVzdC5lbmQoKVxuICAgIHJldHVybiBkZXN0XG4gIH1cblxuICBhZGRMaXN0ZW5lciAoZXYsIGZuKSB7XG4gICAgcmV0dXJuIHRoaXMub24oZXYsIGZuKVxuICB9XG5cbiAgb24gKGV2LCBmbikge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gc3VwZXIub24oZXYsIGZuKVxuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAoZXYgPT09ICdkYXRhJyAmJiAhdGhpcy5waXBlcy5sZW5ndGggJiYgIXRoaXMuZmxvd2luZylcbiAgICAgICAgdGhpc1tSRVNVTUVdKClcbiAgICAgIGVsc2UgaWYgKGlzRW5kaXNoKGV2KSAmJiB0aGlzW0VNSVRURURfRU5EXSkge1xuICAgICAgICBzdXBlci5lbWl0KGV2KVxuICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhldilcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBnZXQgZW1pdHRlZEVuZCAoKSB7XG4gICAgcmV0dXJuIHRoaXNbRU1JVFRFRF9FTkRdXG4gIH1cblxuICBbTUFZQkVfRU1JVF9FTkRdICgpIHtcbiAgICBpZiAoIXRoaXNbRU1JVFRJTkdfRU5EXSAmJlxuICAgICAgICAhdGhpc1tFTUlUVEVEX0VORF0gJiZcbiAgICAgICAgIXRoaXNbREVTVFJPWUVEXSAmJlxuICAgICAgICB0aGlzLmJ1ZmZlci5sZW5ndGggPT09IDAgJiZcbiAgICAgICAgdGhpc1tFT0ZdKSB7XG4gICAgICB0aGlzW0VNSVRUSU5HX0VORF0gPSB0cnVlXG4gICAgICB0aGlzLmVtaXQoJ2VuZCcpXG4gICAgICB0aGlzLmVtaXQoJ3ByZWZpbmlzaCcpXG4gICAgICB0aGlzLmVtaXQoJ2ZpbmlzaCcpXG4gICAgICBpZiAodGhpc1tDTE9TRURdKVxuICAgICAgICB0aGlzLmVtaXQoJ2Nsb3NlJylcbiAgICAgIHRoaXNbRU1JVFRJTkdfRU5EXSA9IGZhbHNlXG4gICAgfVxuICB9XG5cbiAgZW1pdCAoZXYsIGRhdGEpIHtcbiAgICAvLyBlcnJvciBhbmQgY2xvc2UgYXJlIG9ubHkgZXZlbnRzIGFsbG93ZWQgYWZ0ZXIgY2FsbGluZyBkZXN0cm95KClcbiAgICBpZiAoZXYgIT09ICdlcnJvcicgJiYgZXYgIT09ICdjbG9zZScgJiYgZXYgIT09IERFU1RST1lFRCAmJiB0aGlzW0RFU1RST1lFRF0pXG4gICAgICByZXR1cm5cbiAgICBlbHNlIGlmIChldiA9PT0gJ2RhdGEnKSB7XG4gICAgICBpZiAoIWRhdGEpXG4gICAgICAgIHJldHVyblxuXG4gICAgICBpZiAodGhpcy5waXBlcy5sZW5ndGgpXG4gICAgICAgIHRoaXMucGlwZXMuZm9yRWFjaChwID0+XG4gICAgICAgICAgcC5kZXN0LndyaXRlKGRhdGEpID09PSBmYWxzZSAmJiB0aGlzLnBhdXNlKCkpXG4gICAgfSBlbHNlIGlmIChldiA9PT0gJ2VuZCcpIHtcbiAgICAgIC8vIG9ubHkgYWN0dWFsIGVuZCBnZXRzIHRoaXMgdHJlYXRtZW50XG4gICAgICBpZiAodGhpc1tFTUlUVEVEX0VORF0gPT09IHRydWUpXG4gICAgICAgIHJldHVyblxuXG4gICAgICB0aGlzW0VNSVRURURfRU5EXSA9IHRydWVcbiAgICAgIHRoaXMucmVhZGFibGUgPSBmYWxzZVxuXG4gICAgICBpZiAodGhpc1tERUNPREVSXSkge1xuICAgICAgICBkYXRhID0gdGhpc1tERUNPREVSXS5lbmQoKVxuICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgIHRoaXMucGlwZXMuZm9yRWFjaChwID0+IHAuZGVzdC53cml0ZShkYXRhKSlcbiAgICAgICAgICBzdXBlci5lbWl0KCdkYXRhJywgZGF0YSlcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLnBpcGVzLmZvckVhY2gocCA9PiB7XG4gICAgICAgIHAuZGVzdC5yZW1vdmVMaXN0ZW5lcignZHJhaW4nLCBwLm9uZHJhaW4pXG4gICAgICAgIGlmIChwLm9wdHMuZW5kKVxuICAgICAgICAgIHAuZGVzdC5lbmQoKVxuICAgICAgfSlcbiAgICB9IGVsc2UgaWYgKGV2ID09PSAnY2xvc2UnKSB7XG4gICAgICB0aGlzW0NMT1NFRF0gPSB0cnVlXG4gICAgICAvLyBkb24ndCBlbWl0IGNsb3NlIGJlZm9yZSAnZW5kJyBhbmQgJ2ZpbmlzaCdcbiAgICAgIGlmICghdGhpc1tFTUlUVEVEX0VORF0gJiYgIXRoaXNbREVTVFJPWUVEXSlcbiAgICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gVE9ETzogcmVwbGFjZSB3aXRoIGEgc3ByZWFkIG9wZXJhdG9yIHdoZW4gTm9kZSB2NCBzdXBwb3J0IGRyb3BzXG4gICAgY29uc3QgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKVxuICAgIGFyZ3NbMF0gPSBldlxuICAgIGFyZ3NbMV0gPSBkYXRhXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAyKSB7XG4gICAgICBmb3IgKGxldCBpID0gMjsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2ldXG4gICAgICB9XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBzdXBlci5lbWl0LmFwcGx5KHRoaXMsIGFyZ3MpXG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmICghaXNFbmRpc2goZXYpKVxuICAgICAgICB0aGlzW01BWUJFX0VNSVRfRU5EXSgpXG4gICAgICBlbHNlXG4gICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGV2KVxuICAgIH1cbiAgfVxuXG4gIC8vIGNvbnN0IGFsbCA9IGF3YWl0IHN0cmVhbS5jb2xsZWN0KClcbiAgY29sbGVjdCAoKSB7XG4gICAgY29uc3QgYnVmID0gW11cbiAgICBidWYuZGF0YUxlbmd0aCA9IDBcbiAgICB0aGlzLm9uKCdkYXRhJywgYyA9PiB7XG4gICAgICBidWYucHVzaChjKVxuICAgICAgYnVmLmRhdGFMZW5ndGggKz0gYy5sZW5ndGhcbiAgICB9KVxuICAgIHJldHVybiB0aGlzLnByb21pc2UoKS50aGVuKCgpID0+IGJ1ZilcbiAgfVxuXG4gIC8vIGNvbnN0IGRhdGEgPSBhd2FpdCBzdHJlYW0uY29uY2F0KClcbiAgY29uY2F0ICgpIHtcbiAgICByZXR1cm4gdGhpc1tPQkpFQ1RNT0RFXVxuICAgICAgPyBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ2Nhbm5vdCBjb25jYXQgaW4gb2JqZWN0TW9kZScpKVxuICAgICAgOiB0aGlzLmNvbGxlY3QoKS50aGVuKGJ1ZiA9PlxuICAgICAgICAgIHRoaXNbT0JKRUNUTU9ERV1cbiAgICAgICAgICAgID8gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdjYW5ub3QgY29uY2F0IGluIG9iamVjdE1vZGUnKSlcbiAgICAgICAgICAgIDogdGhpc1tFTkNPRElOR10gPyBidWYuam9pbignJykgOiBCLmNvbmNhdChidWYsIGJ1Zi5kYXRhTGVuZ3RoKSlcbiAgfVxuXG4gIC8vIHN0cmVhbS5wcm9taXNlKCkudGhlbigoKSA9PiBkb25lLCBlciA9PiBlbWl0dGVkIGVycm9yKVxuICBwcm9taXNlICgpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdGhpcy5vbihERVNUUk9ZRUQsICgpID0+IHJlamVjdChuZXcgRXJyb3IoJ3N0cmVhbSBkZXN0cm95ZWQnKSkpXG4gICAgICB0aGlzLm9uKCdlbmQnLCAoKSA9PiByZXNvbHZlKCkpXG4gICAgICB0aGlzLm9uKCdlcnJvcicsIGVyID0+IHJlamVjdChlcikpXG4gICAgfSlcbiAgfVxuXG4gIC8vIGZvciBhd2FpdCAobGV0IGNodW5rIG9mIHN0cmVhbSlcbiAgW0FTWU5DSVRFUkFUT1JdICgpIHtcbiAgICBjb25zdCBuZXh0ID0gKCkgPT4ge1xuICAgICAgY29uc3QgcmVzID0gdGhpcy5yZWFkKClcbiAgICAgIGlmIChyZXMgIT09IG51bGwpXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoeyBkb25lOiBmYWxzZSwgdmFsdWU6IHJlcyB9KVxuXG4gICAgICBpZiAodGhpc1tFT0ZdKVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHsgZG9uZTogdHJ1ZSB9KVxuXG4gICAgICBsZXQgcmVzb2x2ZSA9IG51bGxcbiAgICAgIGxldCByZWplY3QgPSBudWxsXG4gICAgICBjb25zdCBvbmVyciA9IGVyID0+IHtcbiAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcignZGF0YScsIG9uZGF0YSlcbiAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25lbmQpXG4gICAgICAgIHJlamVjdChlcilcbiAgICAgIH1cbiAgICAgIGNvbnN0IG9uZGF0YSA9IHZhbHVlID0+IHtcbiAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycilcbiAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25lbmQpXG4gICAgICAgIHRoaXMucGF1c2UoKVxuICAgICAgICByZXNvbHZlKHsgdmFsdWU6IHZhbHVlLCBkb25lOiAhIXRoaXNbRU9GXSB9KVxuICAgICAgfVxuICAgICAgY29uc3Qgb25lbmQgPSAoKSA9PiB7XG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnIpXG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBvbmRhdGEpXG4gICAgICAgIHJlc29sdmUoeyBkb25lOiB0cnVlIH0pXG4gICAgICB9XG4gICAgICBjb25zdCBvbmRlc3Ryb3kgPSAoKSA9PiBvbmVycihuZXcgRXJyb3IoJ3N0cmVhbSBkZXN0cm95ZWQnKSlcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzLCByZWopID0+IHtcbiAgICAgICAgcmVqZWN0ID0gcmVqXG4gICAgICAgIHJlc29sdmUgPSByZXNcbiAgICAgICAgdGhpcy5vbmNlKERFU1RST1lFRCwgb25kZXN0cm95KVxuICAgICAgICB0aGlzLm9uY2UoJ2Vycm9yJywgb25lcnIpXG4gICAgICAgIHRoaXMub25jZSgnZW5kJywgb25lbmQpXG4gICAgICAgIHRoaXMub25jZSgnZGF0YScsIG9uZGF0YSlcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgcmV0dXJuIHsgbmV4dCB9XG4gIH1cblxuICAvLyBmb3IgKGxldCBjaHVuayBvZiBzdHJlYW0pXG4gIFtJVEVSQVRPUl0gKCkge1xuICAgIGNvbnN0IG5leHQgPSAoKSA9PiB7XG4gICAgICBjb25zdCB2YWx1ZSA9IHRoaXMucmVhZCgpXG4gICAgICBjb25zdCBkb25lID0gdmFsdWUgPT09IG51bGxcbiAgICAgIHJldHVybiB7IHZhbHVlLCBkb25lIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgbmV4dCB9XG4gIH1cblxuICBkZXN0cm95IChlcikge1xuICAgIGlmICh0aGlzW0RFU1RST1lFRF0pIHtcbiAgICAgIGlmIChlcilcbiAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIGVyKVxuICAgICAgZWxzZVxuICAgICAgICB0aGlzLmVtaXQoREVTVFJPWUVEKVxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICB0aGlzW0RFU1RST1lFRF0gPSB0cnVlXG5cbiAgICAvLyB0aHJvdyBhd2F5IGFsbCBidWZmZXJlZCBkYXRhLCBpdCdzIG5ldmVyIGNvbWluZyBvdXRcbiAgICB0aGlzLmJ1ZmZlciA9IG5ldyBZYWxsaXN0KClcbiAgICB0aGlzW0JVRkZFUkxFTkdUSF0gPSAwXG5cbiAgICBpZiAodHlwZW9mIHRoaXMuY2xvc2UgPT09ICdmdW5jdGlvbicgJiYgIXRoaXNbQ0xPU0VEXSlcbiAgICAgIHRoaXMuY2xvc2UoKVxuXG4gICAgaWYgKGVyKVxuICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIGVyKVxuICAgIGVsc2UgLy8gaWYgbm8gZXJyb3IgdG8gZW1pdCwgc3RpbGwgcmVqZWN0IHBlbmRpbmcgcHJvbWlzZXNcbiAgICAgIHRoaXMuZW1pdChERVNUUk9ZRUQpXG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgc3RhdGljIGlzU3RyZWFtIChzKSB7XG4gICAgcmV0dXJuICEhcyAmJiAocyBpbnN0YW5jZW9mIE1pbmlwYXNzIHx8IHMgaW5zdGFuY2VvZiBFRSAmJiAoXG4gICAgICB0eXBlb2Ygcy5waXBlID09PSAnZnVuY3Rpb24nIHx8IC8vIHJlYWRhYmxlXG4gICAgICAodHlwZW9mIHMud3JpdGUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHMuZW5kID09PSAnZnVuY3Rpb24nKSAvLyB3cml0YWJsZVxuICAgICkpXG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/minipass/index.js\n");

/***/ })

};
;