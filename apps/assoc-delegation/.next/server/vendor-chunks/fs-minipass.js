"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/fs-minipass";
exports.ids = ["vendor-chunks/fs-minipass"];
exports.modules = {

/***/ "(rsc)/../../node_modules/fs-minipass/index.js":
/*!***********************************************!*\
  !*** ../../node_modules/fs-minipass/index.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nconst MiniPass = __webpack_require__(/*! minipass */ \"(rsc)/../../node_modules/minipass/index.js\")\nconst EE = (__webpack_require__(/*! events */ \"events\").EventEmitter)\nconst fs = __webpack_require__(/*! fs */ \"fs\")\n\n// for writev\nconst binding = process.binding('fs')\nconst writeBuffers = binding.writeBuffers\n/* istanbul ignore next */\nconst FSReqWrap = binding.FSReqWrap || binding.FSReqCallback\n\nconst _autoClose = Symbol('_autoClose')\nconst _close = Symbol('_close')\nconst _ended = Symbol('_ended')\nconst _fd = Symbol('_fd')\nconst _finished = Symbol('_finished')\nconst _flags = Symbol('_flags')\nconst _flush = Symbol('_flush')\nconst _handleChunk = Symbol('_handleChunk')\nconst _makeBuf = Symbol('_makeBuf')\nconst _mode = Symbol('_mode')\nconst _needDrain = Symbol('_needDrain')\nconst _onerror = Symbol('_onerror')\nconst _onopen = Symbol('_onopen')\nconst _onread = Symbol('_onread')\nconst _onwrite = Symbol('_onwrite')\nconst _open = Symbol('_open')\nconst _path = Symbol('_path')\nconst _pos = Symbol('_pos')\nconst _queue = Symbol('_queue')\nconst _read = Symbol('_read')\nconst _readSize = Symbol('_readSize')\nconst _reading = Symbol('_reading')\nconst _remain = Symbol('_remain')\nconst _size = Symbol('_size')\nconst _write = Symbol('_write')\nconst _writing = Symbol('_writing')\nconst _defaultFlag = Symbol('_defaultFlag')\n\nclass ReadStream extends MiniPass {\n  constructor (path, opt) {\n    opt = opt || {}\n    super(opt)\n\n    this.writable = false\n\n    if (typeof path !== 'string')\n      throw new TypeError('path must be a string')\n\n    this[_fd] = typeof opt.fd === 'number' ? opt.fd : null\n    this[_path] = path\n    this[_readSize] = opt.readSize || 16*1024*1024\n    this[_reading] = false\n    this[_size] = typeof opt.size === 'number' ? opt.size : Infinity\n    this[_remain] = this[_size]\n    this[_autoClose] = typeof opt.autoClose === 'boolean' ?\n      opt.autoClose : true\n\n    if (typeof this[_fd] === 'number')\n      this[_read]()\n    else\n      this[_open]()\n  }\n\n  get fd () { return this[_fd] }\n  get path () { return this[_path] }\n\n  write () {\n    throw new TypeError('this is a readable stream')\n  }\n\n  end () {\n    throw new TypeError('this is a readable stream')\n  }\n\n  [_open] () {\n    fs.open(this[_path], 'r', (er, fd) => this[_onopen](er, fd))\n  }\n\n  [_onopen] (er, fd) {\n    if (er)\n      this[_onerror](er)\n    else {\n      this[_fd] = fd\n      this.emit('open', fd)\n      this[_read]()\n    }\n  }\n\n  [_makeBuf] () {\n    return Buffer.allocUnsafe(Math.min(this[_readSize], this[_remain]))\n  }\n\n  [_read] () {\n    if (!this[_reading]) {\n      this[_reading] = true\n      const buf = this[_makeBuf]()\n      /* istanbul ignore if */\n      if (buf.length === 0) return process.nextTick(() => this[_onread](null, 0, buf))\n      fs.read(this[_fd], buf, 0, buf.length, null, (er, br, buf) =>\n        this[_onread](er, br, buf))\n    }\n  }\n\n  [_onread] (er, br, buf) {\n    this[_reading] = false\n    if (er)\n      this[_onerror](er)\n    else if (this[_handleChunk](br, buf))\n      this[_read]()\n  }\n\n  [_close] () {\n    if (this[_autoClose] && typeof this[_fd] === 'number') {\n      fs.close(this[_fd], _ => this.emit('close'))\n      this[_fd] = null\n    }\n  }\n\n  [_onerror] (er) {\n    this[_reading] = true\n    this[_close]()\n    this.emit('error', er)\n  }\n\n  [_handleChunk] (br, buf) {\n    let ret = false\n    // no effect if infinite\n    this[_remain] -= br\n    if (br > 0)\n      ret = super.write(br < buf.length ? buf.slice(0, br) : buf)\n\n    if (br === 0 || this[_remain] <= 0) {\n      ret = false\n      this[_close]()\n      super.end()\n    }\n\n    return ret\n  }\n\n  emit (ev, data) {\n    switch (ev) {\n      case 'prefinish':\n      case 'finish':\n        break\n\n      case 'drain':\n        if (typeof this[_fd] === 'number')\n          this[_read]()\n        break\n\n      default:\n        return super.emit(ev, data)\n    }\n  }\n}\n\nclass ReadStreamSync extends ReadStream {\n  [_open] () {\n    let threw = true\n    try {\n      this[_onopen](null, fs.openSync(this[_path], 'r'))\n      threw = false\n    } finally {\n      if (threw)\n        this[_close]()\n    }\n  }\n\n  [_read] () {\n    let threw = true\n    try {\n      if (!this[_reading]) {\n        this[_reading] = true\n        do {\n          const buf = this[_makeBuf]()\n          /* istanbul ignore next */\n          const br = buf.length === 0 ? 0 : fs.readSync(this[_fd], buf, 0, buf.length, null)\n          if (!this[_handleChunk](br, buf))\n            break\n        } while (true)\n        this[_reading] = false\n      }\n      threw = false\n    } finally {\n      if (threw)\n        this[_close]()\n    }\n  }\n\n  [_close] () {\n    if (this[_autoClose] && typeof this[_fd] === 'number') {\n      try {\n        fs.closeSync(this[_fd])\n      } catch (er) {}\n      this[_fd] = null\n      this.emit('close')\n    }\n  }\n}\n\nclass WriteStream extends EE {\n  constructor (path, opt) {\n    opt = opt || {}\n    super(opt)\n    this.readable = false\n    this[_writing] = false\n    this[_ended] = false\n    this[_needDrain] = false\n    this[_queue] = []\n    this[_path] = path\n    this[_fd] = typeof opt.fd === 'number' ? opt.fd : null\n    this[_mode] = opt.mode === undefined ? 0o666 : opt.mode\n    this[_pos] = typeof opt.start === 'number' ? opt.start : null\n    this[_autoClose] = typeof opt.autoClose === 'boolean' ?\n      opt.autoClose : true\n\n    // truncating makes no sense when writing into the middle\n    const defaultFlag = this[_pos] !== null ? 'r+' : 'w'\n    this[_defaultFlag] = opt.flags === undefined\n    this[_flags] = this[_defaultFlag] ? defaultFlag : opt.flags\n\n    if (this[_fd] === null)\n      this[_open]()\n  }\n\n  get fd () { return this[_fd] }\n  get path () { return this[_path] }\n\n  [_onerror] (er) {\n    this[_close]()\n    this[_writing] = true\n    this.emit('error', er)\n  }\n\n  [_open] () {\n    fs.open(this[_path], this[_flags], this[_mode],\n      (er, fd) => this[_onopen](er, fd))\n  }\n\n  [_onopen] (er, fd) {\n    if (this[_defaultFlag] &&\n        this[_flags] === 'r+' &&\n        er && er.code === 'ENOENT') {\n      this[_flags] = 'w'\n      this[_open]()\n    } else if (er)\n      this[_onerror](er)\n    else {\n      this[_fd] = fd\n      this.emit('open', fd)\n      this[_flush]()\n    }\n  }\n\n  end (buf, enc) {\n    if (buf)\n      this.write(buf, enc)\n\n    this[_ended] = true\n\n    // synthetic after-write logic, where drain/finish live\n    if (!this[_writing] && !this[_queue].length &&\n        typeof this[_fd] === 'number')\n      this[_onwrite](null, 0)\n  }\n\n  write (buf, enc) {\n    if (typeof buf === 'string')\n      buf = new Buffer(buf, enc)\n\n    if (this[_ended]) {\n      this.emit('error', new Error('write() after end()'))\n      return false\n    }\n\n    if (this[_fd] === null || this[_writing] || this[_queue].length) {\n      this[_queue].push(buf)\n      this[_needDrain] = true\n      return false\n    }\n\n    this[_writing] = true\n    this[_write](buf)\n    return true\n  }\n\n  [_write] (buf) {\n    fs.write(this[_fd], buf, 0, buf.length, this[_pos], (er, bw) =>\n      this[_onwrite](er, bw))\n  }\n\n  [_onwrite] (er, bw) {\n    if (er)\n      this[_onerror](er)\n    else {\n      if (this[_pos] !== null)\n        this[_pos] += bw\n      if (this[_queue].length)\n        this[_flush]()\n      else {\n        this[_writing] = false\n\n        if (this[_ended] && !this[_finished]) {\n          this[_finished] = true\n          this[_close]()\n          this.emit('finish')\n        } else if (this[_needDrain]) {\n          this[_needDrain] = false\n          this.emit('drain')\n        }\n      }\n    }\n  }\n\n  [_flush] () {\n    if (this[_queue].length === 0) {\n      if (this[_ended])\n        this[_onwrite](null, 0)\n    } else if (this[_queue].length === 1)\n      this[_write](this[_queue].pop())\n    else {\n      const iovec = this[_queue]\n      this[_queue] = []\n      writev(this[_fd], iovec, this[_pos],\n        (er, bw) => this[_onwrite](er, bw))\n    }\n  }\n\n  [_close] () {\n    if (this[_autoClose] && typeof this[_fd] === 'number') {\n      fs.close(this[_fd], _ => this.emit('close'))\n      this[_fd] = null\n    }\n  }\n}\n\nclass WriteStreamSync extends WriteStream {\n  [_open] () {\n    let fd\n    try {\n      fd = fs.openSync(this[_path], this[_flags], this[_mode])\n    } catch (er) {\n      if (this[_defaultFlag] &&\n          this[_flags] === 'r+' &&\n          er && er.code === 'ENOENT') {\n        this[_flags] = 'w'\n        return this[_open]()\n      } else\n        throw er\n    }\n    this[_onopen](null, fd)\n  }\n\n  [_close] () {\n    if (this[_autoClose] && typeof this[_fd] === 'number') {\n      try {\n        fs.closeSync(this[_fd])\n      } catch (er) {}\n      this[_fd] = null\n      this.emit('close')\n    }\n  }\n\n  [_write] (buf) {\n    try {\n      this[_onwrite](null,\n        fs.writeSync(this[_fd], buf, 0, buf.length, this[_pos]))\n    } catch (er) {\n      this[_onwrite](er, 0)\n    }\n  }\n}\n\nconst writev = (fd, iovec, pos, cb) => {\n  const done = (er, bw) => cb(er, bw, iovec)\n  const req = new FSReqWrap()\n  req.oncomplete = done\n  binding.writeBuffers(fd, iovec, pos, req)\n}\n\nexports.ReadStream = ReadStream\nexports.ReadStreamSync = ReadStreamSync\n\nexports.WriteStream = WriteStream\nexports.WriteStreamSync = WriteStreamSync\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2ZzLW1pbmlwYXNzL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFZO0FBQ1osaUJBQWlCLG1CQUFPLENBQUMsNERBQVU7QUFDbkMsV0FBVywwREFBOEI7QUFDekMsV0FBVyxtQkFBTyxDQUFDLGNBQUk7O0FBRXZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGNBQWM7QUFDZCxnQkFBZ0I7O0FBRWhCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjO0FBQ2QsZ0JBQWdCOztBQUVoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQjtBQUNsQixzQkFBc0I7O0FBRXRCLG1CQUFtQjtBQUNuQix1QkFBdUIiLCJzb3VyY2VzIjpbIi9ob21lL2JhcmIvYWEvQXNzb2NpYXRlZEFjY291bnRzL25vZGVfbW9kdWxlcy9mcy1taW5pcGFzcy9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcbmNvbnN0IE1pbmlQYXNzID0gcmVxdWlyZSgnbWluaXBhc3MnKVxuY29uc3QgRUUgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbmNvbnN0IGZzID0gcmVxdWlyZSgnZnMnKVxuXG4vLyBmb3Igd3JpdGV2XG5jb25zdCBiaW5kaW5nID0gcHJvY2Vzcy5iaW5kaW5nKCdmcycpXG5jb25zdCB3cml0ZUJ1ZmZlcnMgPSBiaW5kaW5nLndyaXRlQnVmZmVyc1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmNvbnN0IEZTUmVxV3JhcCA9IGJpbmRpbmcuRlNSZXFXcmFwIHx8IGJpbmRpbmcuRlNSZXFDYWxsYmFja1xuXG5jb25zdCBfYXV0b0Nsb3NlID0gU3ltYm9sKCdfYXV0b0Nsb3NlJylcbmNvbnN0IF9jbG9zZSA9IFN5bWJvbCgnX2Nsb3NlJylcbmNvbnN0IF9lbmRlZCA9IFN5bWJvbCgnX2VuZGVkJylcbmNvbnN0IF9mZCA9IFN5bWJvbCgnX2ZkJylcbmNvbnN0IF9maW5pc2hlZCA9IFN5bWJvbCgnX2ZpbmlzaGVkJylcbmNvbnN0IF9mbGFncyA9IFN5bWJvbCgnX2ZsYWdzJylcbmNvbnN0IF9mbHVzaCA9IFN5bWJvbCgnX2ZsdXNoJylcbmNvbnN0IF9oYW5kbGVDaHVuayA9IFN5bWJvbCgnX2hhbmRsZUNodW5rJylcbmNvbnN0IF9tYWtlQnVmID0gU3ltYm9sKCdfbWFrZUJ1ZicpXG5jb25zdCBfbW9kZSA9IFN5bWJvbCgnX21vZGUnKVxuY29uc3QgX25lZWREcmFpbiA9IFN5bWJvbCgnX25lZWREcmFpbicpXG5jb25zdCBfb25lcnJvciA9IFN5bWJvbCgnX29uZXJyb3InKVxuY29uc3QgX29ub3BlbiA9IFN5bWJvbCgnX29ub3BlbicpXG5jb25zdCBfb25yZWFkID0gU3ltYm9sKCdfb25yZWFkJylcbmNvbnN0IF9vbndyaXRlID0gU3ltYm9sKCdfb253cml0ZScpXG5jb25zdCBfb3BlbiA9IFN5bWJvbCgnX29wZW4nKVxuY29uc3QgX3BhdGggPSBTeW1ib2woJ19wYXRoJylcbmNvbnN0IF9wb3MgPSBTeW1ib2woJ19wb3MnKVxuY29uc3QgX3F1ZXVlID0gU3ltYm9sKCdfcXVldWUnKVxuY29uc3QgX3JlYWQgPSBTeW1ib2woJ19yZWFkJylcbmNvbnN0IF9yZWFkU2l6ZSA9IFN5bWJvbCgnX3JlYWRTaXplJylcbmNvbnN0IF9yZWFkaW5nID0gU3ltYm9sKCdfcmVhZGluZycpXG5jb25zdCBfcmVtYWluID0gU3ltYm9sKCdfcmVtYWluJylcbmNvbnN0IF9zaXplID0gU3ltYm9sKCdfc2l6ZScpXG5jb25zdCBfd3JpdGUgPSBTeW1ib2woJ193cml0ZScpXG5jb25zdCBfd3JpdGluZyA9IFN5bWJvbCgnX3dyaXRpbmcnKVxuY29uc3QgX2RlZmF1bHRGbGFnID0gU3ltYm9sKCdfZGVmYXVsdEZsYWcnKVxuXG5jbGFzcyBSZWFkU3RyZWFtIGV4dGVuZHMgTWluaVBhc3Mge1xuICBjb25zdHJ1Y3RvciAocGF0aCwgb3B0KSB7XG4gICAgb3B0ID0gb3B0IHx8IHt9XG4gICAgc3VwZXIob3B0KVxuXG4gICAgdGhpcy53cml0YWJsZSA9IGZhbHNlXG5cbiAgICBpZiAodHlwZW9mIHBhdGggIT09ICdzdHJpbmcnKVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncGF0aCBtdXN0IGJlIGEgc3RyaW5nJylcblxuICAgIHRoaXNbX2ZkXSA9IHR5cGVvZiBvcHQuZmQgPT09ICdudW1iZXInID8gb3B0LmZkIDogbnVsbFxuICAgIHRoaXNbX3BhdGhdID0gcGF0aFxuICAgIHRoaXNbX3JlYWRTaXplXSA9IG9wdC5yZWFkU2l6ZSB8fCAxNioxMDI0KjEwMjRcbiAgICB0aGlzW19yZWFkaW5nXSA9IGZhbHNlXG4gICAgdGhpc1tfc2l6ZV0gPSB0eXBlb2Ygb3B0LnNpemUgPT09ICdudW1iZXInID8gb3B0LnNpemUgOiBJbmZpbml0eVxuICAgIHRoaXNbX3JlbWFpbl0gPSB0aGlzW19zaXplXVxuICAgIHRoaXNbX2F1dG9DbG9zZV0gPSB0eXBlb2Ygb3B0LmF1dG9DbG9zZSA9PT0gJ2Jvb2xlYW4nID9cbiAgICAgIG9wdC5hdXRvQ2xvc2UgOiB0cnVlXG5cbiAgICBpZiAodHlwZW9mIHRoaXNbX2ZkXSA9PT0gJ251bWJlcicpXG4gICAgICB0aGlzW19yZWFkXSgpXG4gICAgZWxzZVxuICAgICAgdGhpc1tfb3Blbl0oKVxuICB9XG5cbiAgZ2V0IGZkICgpIHsgcmV0dXJuIHRoaXNbX2ZkXSB9XG4gIGdldCBwYXRoICgpIHsgcmV0dXJuIHRoaXNbX3BhdGhdIH1cblxuICB3cml0ZSAoKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndGhpcyBpcyBhIHJlYWRhYmxlIHN0cmVhbScpXG4gIH1cblxuICBlbmQgKCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3RoaXMgaXMgYSByZWFkYWJsZSBzdHJlYW0nKVxuICB9XG5cbiAgW19vcGVuXSAoKSB7XG4gICAgZnMub3Blbih0aGlzW19wYXRoXSwgJ3InLCAoZXIsIGZkKSA9PiB0aGlzW19vbm9wZW5dKGVyLCBmZCkpXG4gIH1cblxuICBbX29ub3Blbl0gKGVyLCBmZCkge1xuICAgIGlmIChlcilcbiAgICAgIHRoaXNbX29uZXJyb3JdKGVyKVxuICAgIGVsc2Uge1xuICAgICAgdGhpc1tfZmRdID0gZmRcbiAgICAgIHRoaXMuZW1pdCgnb3BlbicsIGZkKVxuICAgICAgdGhpc1tfcmVhZF0oKVxuICAgIH1cbiAgfVxuXG4gIFtfbWFrZUJ1Zl0gKCkge1xuICAgIHJldHVybiBCdWZmZXIuYWxsb2NVbnNhZmUoTWF0aC5taW4odGhpc1tfcmVhZFNpemVdLCB0aGlzW19yZW1haW5dKSlcbiAgfVxuXG4gIFtfcmVhZF0gKCkge1xuICAgIGlmICghdGhpc1tfcmVhZGluZ10pIHtcbiAgICAgIHRoaXNbX3JlYWRpbmddID0gdHJ1ZVxuICAgICAgY29uc3QgYnVmID0gdGhpc1tfbWFrZUJ1Zl0oKVxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoYnVmLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soKCkgPT4gdGhpc1tfb25yZWFkXShudWxsLCAwLCBidWYpKVxuICAgICAgZnMucmVhZCh0aGlzW19mZF0sIGJ1ZiwgMCwgYnVmLmxlbmd0aCwgbnVsbCwgKGVyLCBiciwgYnVmKSA9PlxuICAgICAgICB0aGlzW19vbnJlYWRdKGVyLCBiciwgYnVmKSlcbiAgICB9XG4gIH1cblxuICBbX29ucmVhZF0gKGVyLCBiciwgYnVmKSB7XG4gICAgdGhpc1tfcmVhZGluZ10gPSBmYWxzZVxuICAgIGlmIChlcilcbiAgICAgIHRoaXNbX29uZXJyb3JdKGVyKVxuICAgIGVsc2UgaWYgKHRoaXNbX2hhbmRsZUNodW5rXShiciwgYnVmKSlcbiAgICAgIHRoaXNbX3JlYWRdKClcbiAgfVxuXG4gIFtfY2xvc2VdICgpIHtcbiAgICBpZiAodGhpc1tfYXV0b0Nsb3NlXSAmJiB0eXBlb2YgdGhpc1tfZmRdID09PSAnbnVtYmVyJykge1xuICAgICAgZnMuY2xvc2UodGhpc1tfZmRdLCBfID0+IHRoaXMuZW1pdCgnY2xvc2UnKSlcbiAgICAgIHRoaXNbX2ZkXSA9IG51bGxcbiAgICB9XG4gIH1cblxuICBbX29uZXJyb3JdIChlcikge1xuICAgIHRoaXNbX3JlYWRpbmddID0gdHJ1ZVxuICAgIHRoaXNbX2Nsb3NlXSgpXG4gICAgdGhpcy5lbWl0KCdlcnJvcicsIGVyKVxuICB9XG5cbiAgW19oYW5kbGVDaHVua10gKGJyLCBidWYpIHtcbiAgICBsZXQgcmV0ID0gZmFsc2VcbiAgICAvLyBubyBlZmZlY3QgaWYgaW5maW5pdGVcbiAgICB0aGlzW19yZW1haW5dIC09IGJyXG4gICAgaWYgKGJyID4gMClcbiAgICAgIHJldCA9IHN1cGVyLndyaXRlKGJyIDwgYnVmLmxlbmd0aCA/IGJ1Zi5zbGljZSgwLCBicikgOiBidWYpXG5cbiAgICBpZiAoYnIgPT09IDAgfHwgdGhpc1tfcmVtYWluXSA8PSAwKSB7XG4gICAgICByZXQgPSBmYWxzZVxuICAgICAgdGhpc1tfY2xvc2VdKClcbiAgICAgIHN1cGVyLmVuZCgpXG4gICAgfVxuXG4gICAgcmV0dXJuIHJldFxuICB9XG5cbiAgZW1pdCAoZXYsIGRhdGEpIHtcbiAgICBzd2l0Y2ggKGV2KSB7XG4gICAgICBjYXNlICdwcmVmaW5pc2gnOlxuICAgICAgY2FzZSAnZmluaXNoJzpcbiAgICAgICAgYnJlYWtcblxuICAgICAgY2FzZSAnZHJhaW4nOlxuICAgICAgICBpZiAodHlwZW9mIHRoaXNbX2ZkXSA9PT0gJ251bWJlcicpXG4gICAgICAgICAgdGhpc1tfcmVhZF0oKVxuICAgICAgICBicmVha1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gc3VwZXIuZW1pdChldiwgZGF0YSlcbiAgICB9XG4gIH1cbn1cblxuY2xhc3MgUmVhZFN0cmVhbVN5bmMgZXh0ZW5kcyBSZWFkU3RyZWFtIHtcbiAgW19vcGVuXSAoKSB7XG4gICAgbGV0IHRocmV3ID0gdHJ1ZVxuICAgIHRyeSB7XG4gICAgICB0aGlzW19vbm9wZW5dKG51bGwsIGZzLm9wZW5TeW5jKHRoaXNbX3BhdGhdLCAncicpKVxuICAgICAgdGhyZXcgPSBmYWxzZVxuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAodGhyZXcpXG4gICAgICAgIHRoaXNbX2Nsb3NlXSgpXG4gICAgfVxuICB9XG5cbiAgW19yZWFkXSAoKSB7XG4gICAgbGV0IHRocmV3ID0gdHJ1ZVxuICAgIHRyeSB7XG4gICAgICBpZiAoIXRoaXNbX3JlYWRpbmddKSB7XG4gICAgICAgIHRoaXNbX3JlYWRpbmddID0gdHJ1ZVxuICAgICAgICBkbyB7XG4gICAgICAgICAgY29uc3QgYnVmID0gdGhpc1tfbWFrZUJ1Zl0oKVxuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgY29uc3QgYnIgPSBidWYubGVuZ3RoID09PSAwID8gMCA6IGZzLnJlYWRTeW5jKHRoaXNbX2ZkXSwgYnVmLCAwLCBidWYubGVuZ3RoLCBudWxsKVxuICAgICAgICAgIGlmICghdGhpc1tfaGFuZGxlQ2h1bmtdKGJyLCBidWYpKVxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgfSB3aGlsZSAodHJ1ZSlcbiAgICAgICAgdGhpc1tfcmVhZGluZ10gPSBmYWxzZVxuICAgICAgfVxuICAgICAgdGhyZXcgPSBmYWxzZVxuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAodGhyZXcpXG4gICAgICAgIHRoaXNbX2Nsb3NlXSgpXG4gICAgfVxuICB9XG5cbiAgW19jbG9zZV0gKCkge1xuICAgIGlmICh0aGlzW19hdXRvQ2xvc2VdICYmIHR5cGVvZiB0aGlzW19mZF0gPT09ICdudW1iZXInKSB7XG4gICAgICB0cnkge1xuICAgICAgICBmcy5jbG9zZVN5bmModGhpc1tfZmRdKVxuICAgICAgfSBjYXRjaCAoZXIpIHt9XG4gICAgICB0aGlzW19mZF0gPSBudWxsXG4gICAgICB0aGlzLmVtaXQoJ2Nsb3NlJylcbiAgICB9XG4gIH1cbn1cblxuY2xhc3MgV3JpdGVTdHJlYW0gZXh0ZW5kcyBFRSB7XG4gIGNvbnN0cnVjdG9yIChwYXRoLCBvcHQpIHtcbiAgICBvcHQgPSBvcHQgfHwge31cbiAgICBzdXBlcihvcHQpXG4gICAgdGhpcy5yZWFkYWJsZSA9IGZhbHNlXG4gICAgdGhpc1tfd3JpdGluZ10gPSBmYWxzZVxuICAgIHRoaXNbX2VuZGVkXSA9IGZhbHNlXG4gICAgdGhpc1tfbmVlZERyYWluXSA9IGZhbHNlXG4gICAgdGhpc1tfcXVldWVdID0gW11cbiAgICB0aGlzW19wYXRoXSA9IHBhdGhcbiAgICB0aGlzW19mZF0gPSB0eXBlb2Ygb3B0LmZkID09PSAnbnVtYmVyJyA/IG9wdC5mZCA6IG51bGxcbiAgICB0aGlzW19tb2RlXSA9IG9wdC5tb2RlID09PSB1bmRlZmluZWQgPyAwbzY2NiA6IG9wdC5tb2RlXG4gICAgdGhpc1tfcG9zXSA9IHR5cGVvZiBvcHQuc3RhcnQgPT09ICdudW1iZXInID8gb3B0LnN0YXJ0IDogbnVsbFxuICAgIHRoaXNbX2F1dG9DbG9zZV0gPSB0eXBlb2Ygb3B0LmF1dG9DbG9zZSA9PT0gJ2Jvb2xlYW4nID9cbiAgICAgIG9wdC5hdXRvQ2xvc2UgOiB0cnVlXG5cbiAgICAvLyB0cnVuY2F0aW5nIG1ha2VzIG5vIHNlbnNlIHdoZW4gd3JpdGluZyBpbnRvIHRoZSBtaWRkbGVcbiAgICBjb25zdCBkZWZhdWx0RmxhZyA9IHRoaXNbX3Bvc10gIT09IG51bGwgPyAncisnIDogJ3cnXG4gICAgdGhpc1tfZGVmYXVsdEZsYWddID0gb3B0LmZsYWdzID09PSB1bmRlZmluZWRcbiAgICB0aGlzW19mbGFnc10gPSB0aGlzW19kZWZhdWx0RmxhZ10gPyBkZWZhdWx0RmxhZyA6IG9wdC5mbGFnc1xuXG4gICAgaWYgKHRoaXNbX2ZkXSA9PT0gbnVsbClcbiAgICAgIHRoaXNbX29wZW5dKClcbiAgfVxuXG4gIGdldCBmZCAoKSB7IHJldHVybiB0aGlzW19mZF0gfVxuICBnZXQgcGF0aCAoKSB7IHJldHVybiB0aGlzW19wYXRoXSB9XG5cbiAgW19vbmVycm9yXSAoZXIpIHtcbiAgICB0aGlzW19jbG9zZV0oKVxuICAgIHRoaXNbX3dyaXRpbmddID0gdHJ1ZVxuICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlcilcbiAgfVxuXG4gIFtfb3Blbl0gKCkge1xuICAgIGZzLm9wZW4odGhpc1tfcGF0aF0sIHRoaXNbX2ZsYWdzXSwgdGhpc1tfbW9kZV0sXG4gICAgICAoZXIsIGZkKSA9PiB0aGlzW19vbm9wZW5dKGVyLCBmZCkpXG4gIH1cblxuICBbX29ub3Blbl0gKGVyLCBmZCkge1xuICAgIGlmICh0aGlzW19kZWZhdWx0RmxhZ10gJiZcbiAgICAgICAgdGhpc1tfZmxhZ3NdID09PSAncisnICYmXG4gICAgICAgIGVyICYmIGVyLmNvZGUgPT09ICdFTk9FTlQnKSB7XG4gICAgICB0aGlzW19mbGFnc10gPSAndydcbiAgICAgIHRoaXNbX29wZW5dKClcbiAgICB9IGVsc2UgaWYgKGVyKVxuICAgICAgdGhpc1tfb25lcnJvcl0oZXIpXG4gICAgZWxzZSB7XG4gICAgICB0aGlzW19mZF0gPSBmZFxuICAgICAgdGhpcy5lbWl0KCdvcGVuJywgZmQpXG4gICAgICB0aGlzW19mbHVzaF0oKVxuICAgIH1cbiAgfVxuXG4gIGVuZCAoYnVmLCBlbmMpIHtcbiAgICBpZiAoYnVmKVxuICAgICAgdGhpcy53cml0ZShidWYsIGVuYylcblxuICAgIHRoaXNbX2VuZGVkXSA9IHRydWVcblxuICAgIC8vIHN5bnRoZXRpYyBhZnRlci13cml0ZSBsb2dpYywgd2hlcmUgZHJhaW4vZmluaXNoIGxpdmVcbiAgICBpZiAoIXRoaXNbX3dyaXRpbmddICYmICF0aGlzW19xdWV1ZV0ubGVuZ3RoICYmXG4gICAgICAgIHR5cGVvZiB0aGlzW19mZF0gPT09ICdudW1iZXInKVxuICAgICAgdGhpc1tfb253cml0ZV0obnVsbCwgMClcbiAgfVxuXG4gIHdyaXRlIChidWYsIGVuYykge1xuICAgIGlmICh0eXBlb2YgYnVmID09PSAnc3RyaW5nJylcbiAgICAgIGJ1ZiA9IG5ldyBCdWZmZXIoYnVmLCBlbmMpXG5cbiAgICBpZiAodGhpc1tfZW5kZWRdKSB7XG4gICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCd3cml0ZSgpIGFmdGVyIGVuZCgpJykpXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICBpZiAodGhpc1tfZmRdID09PSBudWxsIHx8IHRoaXNbX3dyaXRpbmddIHx8IHRoaXNbX3F1ZXVlXS5sZW5ndGgpIHtcbiAgICAgIHRoaXNbX3F1ZXVlXS5wdXNoKGJ1ZilcbiAgICAgIHRoaXNbX25lZWREcmFpbl0gPSB0cnVlXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICB0aGlzW193cml0aW5nXSA9IHRydWVcbiAgICB0aGlzW193cml0ZV0oYnVmKVxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBbX3dyaXRlXSAoYnVmKSB7XG4gICAgZnMud3JpdGUodGhpc1tfZmRdLCBidWYsIDAsIGJ1Zi5sZW5ndGgsIHRoaXNbX3Bvc10sIChlciwgYncpID0+XG4gICAgICB0aGlzW19vbndyaXRlXShlciwgYncpKVxuICB9XG5cbiAgW19vbndyaXRlXSAoZXIsIGJ3KSB7XG4gICAgaWYgKGVyKVxuICAgICAgdGhpc1tfb25lcnJvcl0oZXIpXG4gICAgZWxzZSB7XG4gICAgICBpZiAodGhpc1tfcG9zXSAhPT0gbnVsbClcbiAgICAgICAgdGhpc1tfcG9zXSArPSBid1xuICAgICAgaWYgKHRoaXNbX3F1ZXVlXS5sZW5ndGgpXG4gICAgICAgIHRoaXNbX2ZsdXNoXSgpXG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhpc1tfd3JpdGluZ10gPSBmYWxzZVxuXG4gICAgICAgIGlmICh0aGlzW19lbmRlZF0gJiYgIXRoaXNbX2ZpbmlzaGVkXSkge1xuICAgICAgICAgIHRoaXNbX2ZpbmlzaGVkXSA9IHRydWVcbiAgICAgICAgICB0aGlzW19jbG9zZV0oKVxuICAgICAgICAgIHRoaXMuZW1pdCgnZmluaXNoJylcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzW19uZWVkRHJhaW5dKSB7XG4gICAgICAgICAgdGhpc1tfbmVlZERyYWluXSA9IGZhbHNlXG4gICAgICAgICAgdGhpcy5lbWl0KCdkcmFpbicpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBbX2ZsdXNoXSAoKSB7XG4gICAgaWYgKHRoaXNbX3F1ZXVlXS5sZW5ndGggPT09IDApIHtcbiAgICAgIGlmICh0aGlzW19lbmRlZF0pXG4gICAgICAgIHRoaXNbX29ud3JpdGVdKG51bGwsIDApXG4gICAgfSBlbHNlIGlmICh0aGlzW19xdWV1ZV0ubGVuZ3RoID09PSAxKVxuICAgICAgdGhpc1tfd3JpdGVdKHRoaXNbX3F1ZXVlXS5wb3AoKSlcbiAgICBlbHNlIHtcbiAgICAgIGNvbnN0IGlvdmVjID0gdGhpc1tfcXVldWVdXG4gICAgICB0aGlzW19xdWV1ZV0gPSBbXVxuICAgICAgd3JpdGV2KHRoaXNbX2ZkXSwgaW92ZWMsIHRoaXNbX3Bvc10sXG4gICAgICAgIChlciwgYncpID0+IHRoaXNbX29ud3JpdGVdKGVyLCBidykpXG4gICAgfVxuICB9XG5cbiAgW19jbG9zZV0gKCkge1xuICAgIGlmICh0aGlzW19hdXRvQ2xvc2VdICYmIHR5cGVvZiB0aGlzW19mZF0gPT09ICdudW1iZXInKSB7XG4gICAgICBmcy5jbG9zZSh0aGlzW19mZF0sIF8gPT4gdGhpcy5lbWl0KCdjbG9zZScpKVxuICAgICAgdGhpc1tfZmRdID0gbnVsbFxuICAgIH1cbiAgfVxufVxuXG5jbGFzcyBXcml0ZVN0cmVhbVN5bmMgZXh0ZW5kcyBXcml0ZVN0cmVhbSB7XG4gIFtfb3Blbl0gKCkge1xuICAgIGxldCBmZFxuICAgIHRyeSB7XG4gICAgICBmZCA9IGZzLm9wZW5TeW5jKHRoaXNbX3BhdGhdLCB0aGlzW19mbGFnc10sIHRoaXNbX21vZGVdKVxuICAgIH0gY2F0Y2ggKGVyKSB7XG4gICAgICBpZiAodGhpc1tfZGVmYXVsdEZsYWddICYmXG4gICAgICAgICAgdGhpc1tfZmxhZ3NdID09PSAncisnICYmXG4gICAgICAgICAgZXIgJiYgZXIuY29kZSA9PT0gJ0VOT0VOVCcpIHtcbiAgICAgICAgdGhpc1tfZmxhZ3NdID0gJ3cnXG4gICAgICAgIHJldHVybiB0aGlzW19vcGVuXSgpXG4gICAgICB9IGVsc2VcbiAgICAgICAgdGhyb3cgZXJcbiAgICB9XG4gICAgdGhpc1tfb25vcGVuXShudWxsLCBmZClcbiAgfVxuXG4gIFtfY2xvc2VdICgpIHtcbiAgICBpZiAodGhpc1tfYXV0b0Nsb3NlXSAmJiB0eXBlb2YgdGhpc1tfZmRdID09PSAnbnVtYmVyJykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZnMuY2xvc2VTeW5jKHRoaXNbX2ZkXSlcbiAgICAgIH0gY2F0Y2ggKGVyKSB7fVxuICAgICAgdGhpc1tfZmRdID0gbnVsbFxuICAgICAgdGhpcy5lbWl0KCdjbG9zZScpXG4gICAgfVxuICB9XG5cbiAgW193cml0ZV0gKGJ1Zikge1xuICAgIHRyeSB7XG4gICAgICB0aGlzW19vbndyaXRlXShudWxsLFxuICAgICAgICBmcy53cml0ZVN5bmModGhpc1tfZmRdLCBidWYsIDAsIGJ1Zi5sZW5ndGgsIHRoaXNbX3Bvc10pKVxuICAgIH0gY2F0Y2ggKGVyKSB7XG4gICAgICB0aGlzW19vbndyaXRlXShlciwgMClcbiAgICB9XG4gIH1cbn1cblxuY29uc3Qgd3JpdGV2ID0gKGZkLCBpb3ZlYywgcG9zLCBjYikgPT4ge1xuICBjb25zdCBkb25lID0gKGVyLCBidykgPT4gY2IoZXIsIGJ3LCBpb3ZlYylcbiAgY29uc3QgcmVxID0gbmV3IEZTUmVxV3JhcCgpXG4gIHJlcS5vbmNvbXBsZXRlID0gZG9uZVxuICBiaW5kaW5nLndyaXRlQnVmZmVycyhmZCwgaW92ZWMsIHBvcywgcmVxKVxufVxuXG5leHBvcnRzLlJlYWRTdHJlYW0gPSBSZWFkU3RyZWFtXG5leHBvcnRzLlJlYWRTdHJlYW1TeW5jID0gUmVhZFN0cmVhbVN5bmNcblxuZXhwb3J0cy5Xcml0ZVN0cmVhbSA9IFdyaXRlU3RyZWFtXG5leHBvcnRzLldyaXRlU3RyZWFtU3luYyA9IFdyaXRlU3RyZWFtU3luY1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/fs-minipass/index.js\n");

/***/ })

};
;