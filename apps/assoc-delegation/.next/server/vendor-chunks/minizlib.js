/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/minizlib";
exports.ids = ["vendor-chunks/minizlib"];
exports.modules = {

/***/ "(rsc)/../../node_modules/minizlib/constants.js":
/*!************************************************!*\
  !*** ../../node_modules/minizlib/constants.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Update with any zlib constants that are added or changed in the future.\n// Node v6 didn't export this, so we just hard code the version and rely\n// on all the other hard-coded values from zlib v4736.  When node v6\n// support drops, we can just export the realZlibConstants object.\nconst realZlibConstants = (__webpack_require__(/*! zlib */ \"zlib\").constants) ||\n  /* istanbul ignore next */ { ZLIB_VERNUM: 4736 }\n\nmodule.exports = Object.freeze(Object.assign(Object.create(null), {\n  Z_NO_FLUSH: 0,\n  Z_PARTIAL_FLUSH: 1,\n  Z_SYNC_FLUSH: 2,\n  Z_FULL_FLUSH: 3,\n  Z_FINISH: 4,\n  Z_BLOCK: 5,\n  Z_OK: 0,\n  Z_STREAM_END: 1,\n  Z_NEED_DICT: 2,\n  Z_ERRNO: -1,\n  Z_STREAM_ERROR: -2,\n  Z_DATA_ERROR: -3,\n  Z_MEM_ERROR: -4,\n  Z_BUF_ERROR: -5,\n  Z_VERSION_ERROR: -6,\n  Z_NO_COMPRESSION: 0,\n  Z_BEST_SPEED: 1,\n  Z_BEST_COMPRESSION: 9,\n  Z_DEFAULT_COMPRESSION: -1,\n  Z_FILTERED: 1,\n  Z_HUFFMAN_ONLY: 2,\n  Z_RLE: 3,\n  Z_FIXED: 4,\n  Z_DEFAULT_STRATEGY: 0,\n  DEFLATE: 1,\n  INFLATE: 2,\n  GZIP: 3,\n  GUNZIP: 4,\n  DEFLATERAW: 5,\n  INFLATERAW: 6,\n  UNZIP: 7,\n  BROTLI_DECODE: 8,\n  BROTLI_ENCODE: 9,\n  Z_MIN_WINDOWBITS: 8,\n  Z_MAX_WINDOWBITS: 15,\n  Z_DEFAULT_WINDOWBITS: 15,\n  Z_MIN_CHUNK: 64,\n  Z_MAX_CHUNK: Infinity,\n  Z_DEFAULT_CHUNK: 16384,\n  Z_MIN_MEMLEVEL: 1,\n  Z_MAX_MEMLEVEL: 9,\n  Z_DEFAULT_MEMLEVEL: 8,\n  Z_MIN_LEVEL: -1,\n  Z_MAX_LEVEL: 9,\n  Z_DEFAULT_LEVEL: -1,\n  BROTLI_OPERATION_PROCESS: 0,\n  BROTLI_OPERATION_FLUSH: 1,\n  BROTLI_OPERATION_FINISH: 2,\n  BROTLI_OPERATION_EMIT_METADATA: 3,\n  BROTLI_MODE_GENERIC: 0,\n  BROTLI_MODE_TEXT: 1,\n  BROTLI_MODE_FONT: 2,\n  BROTLI_DEFAULT_MODE: 0,\n  BROTLI_MIN_QUALITY: 0,\n  BROTLI_MAX_QUALITY: 11,\n  BROTLI_DEFAULT_QUALITY: 11,\n  BROTLI_MIN_WINDOW_BITS: 10,\n  BROTLI_MAX_WINDOW_BITS: 24,\n  BROTLI_LARGE_MAX_WINDOW_BITS: 30,\n  BROTLI_DEFAULT_WINDOW: 22,\n  BROTLI_MIN_INPUT_BLOCK_BITS: 16,\n  BROTLI_MAX_INPUT_BLOCK_BITS: 24,\n  BROTLI_PARAM_MODE: 0,\n  BROTLI_PARAM_QUALITY: 1,\n  BROTLI_PARAM_LGWIN: 2,\n  BROTLI_PARAM_LGBLOCK: 3,\n  BROTLI_PARAM_DISABLE_LITERAL_CONTEXT_MODELING: 4,\n  BROTLI_PARAM_SIZE_HINT: 5,\n  BROTLI_PARAM_LARGE_WINDOW: 6,\n  BROTLI_PARAM_NPOSTFIX: 7,\n  BROTLI_PARAM_NDIRECT: 8,\n  BROTLI_DECODER_RESULT_ERROR: 0,\n  BROTLI_DECODER_RESULT_SUCCESS: 1,\n  BROTLI_DECODER_RESULT_NEEDS_MORE_INPUT: 2,\n  BROTLI_DECODER_RESULT_NEEDS_MORE_OUTPUT: 3,\n  BROTLI_DECODER_PARAM_DISABLE_RING_BUFFER_REALLOCATION: 0,\n  BROTLI_DECODER_PARAM_LARGE_WINDOW: 1,\n  BROTLI_DECODER_NO_ERROR: 0,\n  BROTLI_DECODER_SUCCESS: 1,\n  BROTLI_DECODER_NEEDS_MORE_INPUT: 2,\n  BROTLI_DECODER_NEEDS_MORE_OUTPUT: 3,\n  BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_NIBBLE: -1,\n  BROTLI_DECODER_ERROR_FORMAT_RESERVED: -2,\n  BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_META_NIBBLE: -3,\n  BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_ALPHABET: -4,\n  BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_SAME: -5,\n  BROTLI_DECODER_ERROR_FORMAT_CL_SPACE: -6,\n  BROTLI_DECODER_ERROR_FORMAT_HUFFMAN_SPACE: -7,\n  BROTLI_DECODER_ERROR_FORMAT_CONTEXT_MAP_REPEAT: -8,\n  BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_1: -9,\n  BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_2: -10,\n  BROTLI_DECODER_ERROR_FORMAT_TRANSFORM: -11,\n  BROTLI_DECODER_ERROR_FORMAT_DICTIONARY: -12,\n  BROTLI_DECODER_ERROR_FORMAT_WINDOW_BITS: -13,\n  BROTLI_DECODER_ERROR_FORMAT_PADDING_1: -14,\n  BROTLI_DECODER_ERROR_FORMAT_PADDING_2: -15,\n  BROTLI_DECODER_ERROR_FORMAT_DISTANCE: -16,\n  BROTLI_DECODER_ERROR_DICTIONARY_NOT_SET: -19,\n  BROTLI_DECODER_ERROR_INVALID_ARGUMENTS: -20,\n  BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MODES: -21,\n  BROTLI_DECODER_ERROR_ALLOC_TREE_GROUPS: -22,\n  BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MAP: -25,\n  BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_1: -26,\n  BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_2: -27,\n  BROTLI_DECODER_ERROR_ALLOC_BLOCK_TYPE_TREES: -30,\n  BROTLI_DECODER_ERROR_UNREACHABLE: -31,\n}, realZlibConstants))\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL21pbml6bGliL2NvbnN0YW50cy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixtREFBeUI7QUFDbkQsK0JBQStCOztBQUUvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsiL2hvbWUvYmFyYi9hYS9Bc3NvY2lhdGVkQWNjb3VudHMvbm9kZV9tb2R1bGVzL21pbml6bGliL2NvbnN0YW50cy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBVcGRhdGUgd2l0aCBhbnkgemxpYiBjb25zdGFudHMgdGhhdCBhcmUgYWRkZWQgb3IgY2hhbmdlZCBpbiB0aGUgZnV0dXJlLlxuLy8gTm9kZSB2NiBkaWRuJ3QgZXhwb3J0IHRoaXMsIHNvIHdlIGp1c3QgaGFyZCBjb2RlIHRoZSB2ZXJzaW9uIGFuZCByZWx5XG4vLyBvbiBhbGwgdGhlIG90aGVyIGhhcmQtY29kZWQgdmFsdWVzIGZyb20gemxpYiB2NDczNi4gIFdoZW4gbm9kZSB2NlxuLy8gc3VwcG9ydCBkcm9wcywgd2UgY2FuIGp1c3QgZXhwb3J0IHRoZSByZWFsWmxpYkNvbnN0YW50cyBvYmplY3QuXG5jb25zdCByZWFsWmxpYkNvbnN0YW50cyA9IHJlcXVpcmUoJ3psaWInKS5jb25zdGFudHMgfHxcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8geyBaTElCX1ZFUk5VTTogNDczNiB9XG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmZyZWV6ZShPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUobnVsbCksIHtcbiAgWl9OT19GTFVTSDogMCxcbiAgWl9QQVJUSUFMX0ZMVVNIOiAxLFxuICBaX1NZTkNfRkxVU0g6IDIsXG4gIFpfRlVMTF9GTFVTSDogMyxcbiAgWl9GSU5JU0g6IDQsXG4gIFpfQkxPQ0s6IDUsXG4gIFpfT0s6IDAsXG4gIFpfU1RSRUFNX0VORDogMSxcbiAgWl9ORUVEX0RJQ1Q6IDIsXG4gIFpfRVJSTk86IC0xLFxuICBaX1NUUkVBTV9FUlJPUjogLTIsXG4gIFpfREFUQV9FUlJPUjogLTMsXG4gIFpfTUVNX0VSUk9SOiAtNCxcbiAgWl9CVUZfRVJST1I6IC01LFxuICBaX1ZFUlNJT05fRVJST1I6IC02LFxuICBaX05PX0NPTVBSRVNTSU9OOiAwLFxuICBaX0JFU1RfU1BFRUQ6IDEsXG4gIFpfQkVTVF9DT01QUkVTU0lPTjogOSxcbiAgWl9ERUZBVUxUX0NPTVBSRVNTSU9OOiAtMSxcbiAgWl9GSUxURVJFRDogMSxcbiAgWl9IVUZGTUFOX09OTFk6IDIsXG4gIFpfUkxFOiAzLFxuICBaX0ZJWEVEOiA0LFxuICBaX0RFRkFVTFRfU1RSQVRFR1k6IDAsXG4gIERFRkxBVEU6IDEsXG4gIElORkxBVEU6IDIsXG4gIEdaSVA6IDMsXG4gIEdVTlpJUDogNCxcbiAgREVGTEFURVJBVzogNSxcbiAgSU5GTEFURVJBVzogNixcbiAgVU5aSVA6IDcsXG4gIEJST1RMSV9ERUNPREU6IDgsXG4gIEJST1RMSV9FTkNPREU6IDksXG4gIFpfTUlOX1dJTkRPV0JJVFM6IDgsXG4gIFpfTUFYX1dJTkRPV0JJVFM6IDE1LFxuICBaX0RFRkFVTFRfV0lORE9XQklUUzogMTUsXG4gIFpfTUlOX0NIVU5LOiA2NCxcbiAgWl9NQVhfQ0hVTks6IEluZmluaXR5LFxuICBaX0RFRkFVTFRfQ0hVTks6IDE2Mzg0LFxuICBaX01JTl9NRU1MRVZFTDogMSxcbiAgWl9NQVhfTUVNTEVWRUw6IDksXG4gIFpfREVGQVVMVF9NRU1MRVZFTDogOCxcbiAgWl9NSU5fTEVWRUw6IC0xLFxuICBaX01BWF9MRVZFTDogOSxcbiAgWl9ERUZBVUxUX0xFVkVMOiAtMSxcbiAgQlJPVExJX09QRVJBVElPTl9QUk9DRVNTOiAwLFxuICBCUk9UTElfT1BFUkFUSU9OX0ZMVVNIOiAxLFxuICBCUk9UTElfT1BFUkFUSU9OX0ZJTklTSDogMixcbiAgQlJPVExJX09QRVJBVElPTl9FTUlUX01FVEFEQVRBOiAzLFxuICBCUk9UTElfTU9ERV9HRU5FUklDOiAwLFxuICBCUk9UTElfTU9ERV9URVhUOiAxLFxuICBCUk9UTElfTU9ERV9GT05UOiAyLFxuICBCUk9UTElfREVGQVVMVF9NT0RFOiAwLFxuICBCUk9UTElfTUlOX1FVQUxJVFk6IDAsXG4gIEJST1RMSV9NQVhfUVVBTElUWTogMTEsXG4gIEJST1RMSV9ERUZBVUxUX1FVQUxJVFk6IDExLFxuICBCUk9UTElfTUlOX1dJTkRPV19CSVRTOiAxMCxcbiAgQlJPVExJX01BWF9XSU5ET1dfQklUUzogMjQsXG4gIEJST1RMSV9MQVJHRV9NQVhfV0lORE9XX0JJVFM6IDMwLFxuICBCUk9UTElfREVGQVVMVF9XSU5ET1c6IDIyLFxuICBCUk9UTElfTUlOX0lOUFVUX0JMT0NLX0JJVFM6IDE2LFxuICBCUk9UTElfTUFYX0lOUFVUX0JMT0NLX0JJVFM6IDI0LFxuICBCUk9UTElfUEFSQU1fTU9ERTogMCxcbiAgQlJPVExJX1BBUkFNX1FVQUxJVFk6IDEsXG4gIEJST1RMSV9QQVJBTV9MR1dJTjogMixcbiAgQlJPVExJX1BBUkFNX0xHQkxPQ0s6IDMsXG4gIEJST1RMSV9QQVJBTV9ESVNBQkxFX0xJVEVSQUxfQ09OVEVYVF9NT0RFTElORzogNCxcbiAgQlJPVExJX1BBUkFNX1NJWkVfSElOVDogNSxcbiAgQlJPVExJX1BBUkFNX0xBUkdFX1dJTkRPVzogNixcbiAgQlJPVExJX1BBUkFNX05QT1NURklYOiA3LFxuICBCUk9UTElfUEFSQU1fTkRJUkVDVDogOCxcbiAgQlJPVExJX0RFQ09ERVJfUkVTVUxUX0VSUk9SOiAwLFxuICBCUk9UTElfREVDT0RFUl9SRVNVTFRfU1VDQ0VTUzogMSxcbiAgQlJPVExJX0RFQ09ERVJfUkVTVUxUX05FRURTX01PUkVfSU5QVVQ6IDIsXG4gIEJST1RMSV9ERUNPREVSX1JFU1VMVF9ORUVEU19NT1JFX09VVFBVVDogMyxcbiAgQlJPVExJX0RFQ09ERVJfUEFSQU1fRElTQUJMRV9SSU5HX0JVRkZFUl9SRUFMTE9DQVRJT046IDAsXG4gIEJST1RMSV9ERUNPREVSX1BBUkFNX0xBUkdFX1dJTkRPVzogMSxcbiAgQlJPVExJX0RFQ09ERVJfTk9fRVJST1I6IDAsXG4gIEJST1RMSV9ERUNPREVSX1NVQ0NFU1M6IDEsXG4gIEJST1RMSV9ERUNPREVSX05FRURTX01PUkVfSU5QVVQ6IDIsXG4gIEJST1RMSV9ERUNPREVSX05FRURTX01PUkVfT1VUUFVUOiAzLFxuICBCUk9UTElfREVDT0RFUl9FUlJPUl9GT1JNQVRfRVhVQkVSQU5UX05JQkJMRTogLTEsXG4gIEJST1RMSV9ERUNPREVSX0VSUk9SX0ZPUk1BVF9SRVNFUlZFRDogLTIsXG4gIEJST1RMSV9ERUNPREVSX0VSUk9SX0ZPUk1BVF9FWFVCRVJBTlRfTUVUQV9OSUJCTEU6IC0zLFxuICBCUk9UTElfREVDT0RFUl9FUlJPUl9GT1JNQVRfU0lNUExFX0hVRkZNQU5fQUxQSEFCRVQ6IC00LFxuICBCUk9UTElfREVDT0RFUl9FUlJPUl9GT1JNQVRfU0lNUExFX0hVRkZNQU5fU0FNRTogLTUsXG4gIEJST1RMSV9ERUNPREVSX0VSUk9SX0ZPUk1BVF9DTF9TUEFDRTogLTYsXG4gIEJST1RMSV9ERUNPREVSX0VSUk9SX0ZPUk1BVF9IVUZGTUFOX1NQQUNFOiAtNyxcbiAgQlJPVExJX0RFQ09ERVJfRVJST1JfRk9STUFUX0NPTlRFWFRfTUFQX1JFUEVBVDogLTgsXG4gIEJST1RMSV9ERUNPREVSX0VSUk9SX0ZPUk1BVF9CTE9DS19MRU5HVEhfMTogLTksXG4gIEJST1RMSV9ERUNPREVSX0VSUk9SX0ZPUk1BVF9CTE9DS19MRU5HVEhfMjogLTEwLFxuICBCUk9UTElfREVDT0RFUl9FUlJPUl9GT1JNQVRfVFJBTlNGT1JNOiAtMTEsXG4gIEJST1RMSV9ERUNPREVSX0VSUk9SX0ZPUk1BVF9ESUNUSU9OQVJZOiAtMTIsXG4gIEJST1RMSV9ERUNPREVSX0VSUk9SX0ZPUk1BVF9XSU5ET1dfQklUUzogLTEzLFxuICBCUk9UTElfREVDT0RFUl9FUlJPUl9GT1JNQVRfUEFERElOR18xOiAtMTQsXG4gIEJST1RMSV9ERUNPREVSX0VSUk9SX0ZPUk1BVF9QQURESU5HXzI6IC0xNSxcbiAgQlJPVExJX0RFQ09ERVJfRVJST1JfRk9STUFUX0RJU1RBTkNFOiAtMTYsXG4gIEJST1RMSV9ERUNPREVSX0VSUk9SX0RJQ1RJT05BUllfTk9UX1NFVDogLTE5LFxuICBCUk9UTElfREVDT0RFUl9FUlJPUl9JTlZBTElEX0FSR1VNRU5UUzogLTIwLFxuICBCUk9UTElfREVDT0RFUl9FUlJPUl9BTExPQ19DT05URVhUX01PREVTOiAtMjEsXG4gIEJST1RMSV9ERUNPREVSX0VSUk9SX0FMTE9DX1RSRUVfR1JPVVBTOiAtMjIsXG4gIEJST1RMSV9ERUNPREVSX0VSUk9SX0FMTE9DX0NPTlRFWFRfTUFQOiAtMjUsXG4gIEJST1RMSV9ERUNPREVSX0VSUk9SX0FMTE9DX1JJTkdfQlVGRkVSXzE6IC0yNixcbiAgQlJPVExJX0RFQ09ERVJfRVJST1JfQUxMT0NfUklOR19CVUZGRVJfMjogLTI3LFxuICBCUk9UTElfREVDT0RFUl9FUlJPUl9BTExPQ19CTE9DS19UWVBFX1RSRUVTOiAtMzAsXG4gIEJST1RMSV9ERUNPREVSX0VSUk9SX1VOUkVBQ0hBQkxFOiAtMzEsXG59LCByZWFsWmxpYkNvbnN0YW50cykpXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/minizlib/constants.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/minizlib/index.js":
/*!********************************************!*\
  !*** ../../node_modules/minizlib/index.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nconst assert = __webpack_require__(/*! assert */ \"assert\")\nconst Buffer = (__webpack_require__(/*! buffer */ \"buffer\").Buffer)\nconst realZlib = __webpack_require__(/*! zlib */ \"zlib\")\n\nconst constants = exports.constants = __webpack_require__(/*! ./constants.js */ \"(rsc)/../../node_modules/minizlib/constants.js\")\nconst Minipass = __webpack_require__(/*! minipass */ \"(rsc)/../../node_modules/minipass/index.js\")\n\nconst OriginalBufferConcat = Buffer.concat\n\nclass ZlibError extends Error {\n  constructor (err) {\n    super('zlib: ' + err.message)\n    this.code = err.code\n    this.errno = err.errno\n    /* istanbul ignore if */\n    if (!this.code)\n      this.code = 'ZLIB_ERROR'\n\n    this.message = 'zlib: ' + err.message\n    Error.captureStackTrace(this, this.constructor)\n  }\n\n  get name () {\n    return 'ZlibError'\n  }\n}\n\n// the Zlib class they all inherit from\n// This thing manages the queue of requests, and returns\n// true or false if there is anything in the queue when\n// you call the .write() method.\nconst _opts = Symbol('opts')\nconst _flushFlag = Symbol('flushFlag')\nconst _finishFlushFlag = Symbol('finishFlushFlag')\nconst _fullFlushFlag = Symbol('fullFlushFlag')\nconst _handle = Symbol('handle')\nconst _onError = Symbol('onError')\nconst _sawError = Symbol('sawError')\nconst _level = Symbol('level')\nconst _strategy = Symbol('strategy')\nconst _ended = Symbol('ended')\nconst _defaultFullFlush = Symbol('_defaultFullFlush')\n\nclass ZlibBase extends Minipass {\n  constructor (opts, mode) {\n    if (!opts || typeof opts !== 'object')\n      throw new TypeError('invalid options for ZlibBase constructor')\n\n    super(opts)\n    this[_ended] = false\n    this[_opts] = opts\n\n    this[_flushFlag] = opts.flush\n    this[_finishFlushFlag] = opts.finishFlush\n    // this will throw if any options are invalid for the class selected\n    try {\n      this[_handle] = new realZlib[mode](opts)\n    } catch (er) {\n      // make sure that all errors get decorated properly\n      throw new ZlibError(er)\n    }\n\n    this[_onError] = (err) => {\n      this[_sawError] = true\n      // there is no way to cleanly recover.\n      // continuing only obscures problems.\n      this.close()\n      this.emit('error', err)\n    }\n\n    this[_handle].on('error', er => this[_onError](new ZlibError(er)))\n    this.once('end', () => this.close)\n  }\n\n  close () {\n    if (this[_handle]) {\n      this[_handle].close()\n      this[_handle] = null\n      this.emit('close')\n    }\n  }\n\n  reset () {\n    if (!this[_sawError]) {\n      assert(this[_handle], 'zlib binding closed')\n      return this[_handle].reset()\n    }\n  }\n\n  flush (flushFlag) {\n    if (this.ended)\n      return\n\n    if (typeof flushFlag !== 'number')\n      flushFlag = this[_fullFlushFlag]\n    this.write(Object.assign(Buffer.alloc(0), { [_flushFlag]: flushFlag }))\n  }\n\n  end (chunk, encoding, cb) {\n    if (chunk)\n      this.write(chunk, encoding)\n    this.flush(this[_finishFlushFlag])\n    this[_ended] = true\n    return super.end(null, null, cb)\n  }\n\n  get ended () {\n    return this[_ended]\n  }\n\n  write (chunk, encoding, cb) {\n    // process the chunk using the sync process\n    // then super.write() all the outputted chunks\n    if (typeof encoding === 'function')\n      cb = encoding, encoding = 'utf8'\n\n    if (typeof chunk === 'string')\n      chunk = Buffer.from(chunk, encoding)\n\n    if (this[_sawError])\n      return\n    assert(this[_handle], 'zlib binding closed')\n\n    // _processChunk tries to .close() the native handle after it's done, so we\n    // intercept that by temporarily making it a no-op.\n    const nativeHandle = this[_handle]._handle\n    const originalNativeClose = nativeHandle.close\n    nativeHandle.close = () => {}\n    const originalClose = this[_handle].close\n    this[_handle].close = () => {}\n    // It also calls `Buffer.concat()` at the end, which may be convenient\n    // for some, but which we are not interested in as it slows us down.\n    Buffer.concat = (args) => args\n    let result\n    try {\n      const flushFlag = typeof chunk[_flushFlag] === 'number'\n        ? chunk[_flushFlag] : this[_flushFlag]\n      result = this[_handle]._processChunk(chunk, flushFlag)\n      // if we don't throw, reset it back how it was\n      Buffer.concat = OriginalBufferConcat\n    } catch (err) {\n      // or if we do, put Buffer.concat() back before we emit error\n      // Error events call into user code, which may call Buffer.concat()\n      Buffer.concat = OriginalBufferConcat\n      this[_onError](new ZlibError(err))\n    } finally {\n      if (this[_handle]) {\n        // Core zlib resets `_handle` to null after attempting to close the\n        // native handle. Our no-op handler prevented actual closure, but we\n        // need to restore the `._handle` property.\n        this[_handle]._handle = nativeHandle\n        nativeHandle.close = originalNativeClose\n        this[_handle].close = originalClose\n        // `_processChunk()` adds an 'error' listener. If we don't remove it\n        // after each call, these handlers start piling up.\n        this[_handle].removeAllListeners('error')\n      }\n    }\n\n    let writeReturn\n    if (result) {\n      if (Array.isArray(result) && result.length > 0) {\n        // The first buffer is always `handle._outBuffer`, which would be\n        // re-used for later invocations; so, we always have to copy that one.\n        writeReturn = super.write(Buffer.from(result[0]))\n        for (let i = 1; i < result.length; i++) {\n          writeReturn = super.write(result[i])\n        }\n      } else {\n        writeReturn = super.write(Buffer.from(result))\n      }\n    }\n\n    if (cb)\n      cb()\n    return writeReturn\n  }\n}\n\nclass Zlib extends ZlibBase {\n  constructor (opts, mode) {\n    opts = opts || {}\n\n    opts.flush = opts.flush || constants.Z_NO_FLUSH\n    opts.finishFlush = opts.finishFlush || constants.Z_FINISH\n    super(opts, mode)\n\n    this[_fullFlushFlag] = constants.Z_FULL_FLUSH\n    this[_level] = opts.level\n    this[_strategy] = opts.strategy\n  }\n\n  params (level, strategy) {\n    if (this[_sawError])\n      return\n\n    if (!this[_handle])\n      throw new Error('cannot switch params when binding is closed')\n\n    // no way to test this without also not supporting params at all\n    /* istanbul ignore if */\n    if (!this[_handle].params)\n      throw new Error('not supported in this implementation')\n\n    if (this[_level] !== level || this[_strategy] !== strategy) {\n      this.flush(constants.Z_SYNC_FLUSH)\n      assert(this[_handle], 'zlib binding closed')\n      // .params() calls .flush(), but the latter is always async in the\n      // core zlib. We override .flush() temporarily to intercept that and\n      // flush synchronously.\n      const origFlush = this[_handle].flush\n      this[_handle].flush = (flushFlag, cb) => {\n        this.flush(flushFlag)\n        cb()\n      }\n      try {\n        this[_handle].params(level, strategy)\n      } finally {\n        this[_handle].flush = origFlush\n      }\n      /* istanbul ignore else */\n      if (this[_handle]) {\n        this[_level] = level\n        this[_strategy] = strategy\n      }\n    }\n  }\n}\n\n// minimal 2-byte header\nclass Deflate extends Zlib {\n  constructor (opts) {\n    super(opts, 'Deflate')\n  }\n}\n\nclass Inflate extends Zlib {\n  constructor (opts) {\n    super(opts, 'Inflate')\n  }\n}\n\n// gzip - bigger header, same deflate compression\nclass Gzip extends Zlib {\n  constructor (opts) {\n    super(opts, 'Gzip')\n  }\n}\n\nclass Gunzip extends Zlib {\n  constructor (opts) {\n    super(opts, 'Gunzip')\n  }\n}\n\n// raw - no header\nclass DeflateRaw extends Zlib {\n  constructor (opts) {\n    super(opts, 'DeflateRaw')\n  }\n}\n\nclass InflateRaw extends Zlib {\n  constructor (opts) {\n    super(opts, 'InflateRaw')\n  }\n}\n\n// auto-detect header.\nclass Unzip extends Zlib {\n  constructor (opts) {\n    super(opts, 'Unzip')\n  }\n}\n\nclass Brotli extends ZlibBase {\n  constructor (opts, mode) {\n    opts = opts || {}\n\n    opts.flush = opts.flush || constants.BROTLI_OPERATION_PROCESS\n    opts.finishFlush = opts.finishFlush || constants.BROTLI_OPERATION_FINISH\n\n    super(opts, mode)\n\n    this[_fullFlushFlag] = constants.BROTLI_OPERATION_FLUSH\n  }\n}\n\nclass BrotliCompress extends Brotli {\n  constructor (opts) {\n    super(opts, 'BrotliCompress')\n  }\n}\n\nclass BrotliDecompress extends Brotli {\n  constructor (opts) {\n    super(opts, 'BrotliDecompress')\n  }\n}\n\nexports.Deflate = Deflate\nexports.Inflate = Inflate\nexports.Gzip = Gzip\nexports.Gunzip = Gunzip\nexports.DeflateRaw = DeflateRaw\nexports.InflateRaw = InflateRaw\nexports.Unzip = Unzip\n/* istanbul ignore else */\nif (typeof realZlib.BrotliCompress === 'function') {\n  exports.BrotliCompress = BrotliCompress\n  exports.BrotliDecompress = BrotliDecompress\n} else {\n  exports.BrotliCompress = exports.BrotliDecompress = class {\n    constructor () {\n      throw new Error('Brotli is not supported in this version of Node.js')\n    }\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL21pbml6bGliL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLGVBQWUsbUJBQU8sQ0FBQyxzQkFBUTtBQUMvQixlQUFlLG9EQUF3QjtBQUN2QyxpQkFBaUIsbUJBQU8sQ0FBQyxrQkFBTTs7QUFFL0Isa0JBQWtCLCtHQUE2QztBQUMvRCxpQkFBaUIsbUJBQU8sQ0FBQyw0REFBVTs7QUFFbkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0RBQWdELHlCQUF5QjtBQUN6RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBLHdCQUF3QixtQkFBbUI7QUFDM0M7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWU7QUFDZixlQUFlO0FBQ2YsWUFBWTtBQUNaLGNBQWM7QUFDZCxrQkFBa0I7QUFDbEIsa0JBQWtCO0FBQ2xCLGFBQWE7QUFDYjtBQUNBO0FBQ0EsRUFBRSxzQkFBc0I7QUFDeEIsRUFBRSx3QkFBd0I7QUFDMUIsRUFBRTtBQUNGLEVBQUUsc0JBQXNCLEdBQUcsd0JBQXdCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL2JhcmIvYWEvQXNzb2NpYXRlZEFjY291bnRzL25vZGVfbW9kdWxlcy9taW5pemxpYi9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0JylcbmNvbnN0IEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlclxuY29uc3QgcmVhbFpsaWIgPSByZXF1aXJlKCd6bGliJylcblxuY29uc3QgY29uc3RhbnRzID0gZXhwb3J0cy5jb25zdGFudHMgPSByZXF1aXJlKCcuL2NvbnN0YW50cy5qcycpXG5jb25zdCBNaW5pcGFzcyA9IHJlcXVpcmUoJ21pbmlwYXNzJylcblxuY29uc3QgT3JpZ2luYWxCdWZmZXJDb25jYXQgPSBCdWZmZXIuY29uY2F0XG5cbmNsYXNzIFpsaWJFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IgKGVycikge1xuICAgIHN1cGVyKCd6bGliOiAnICsgZXJyLm1lc3NhZ2UpXG4gICAgdGhpcy5jb2RlID0gZXJyLmNvZGVcbiAgICB0aGlzLmVycm5vID0gZXJyLmVycm5vXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCF0aGlzLmNvZGUpXG4gICAgICB0aGlzLmNvZGUgPSAnWkxJQl9FUlJPUidcblxuICAgIHRoaXMubWVzc2FnZSA9ICd6bGliOiAnICsgZXJyLm1lc3NhZ2VcbiAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCB0aGlzLmNvbnN0cnVjdG9yKVxuICB9XG5cbiAgZ2V0IG5hbWUgKCkge1xuICAgIHJldHVybiAnWmxpYkVycm9yJ1xuICB9XG59XG5cbi8vIHRoZSBabGliIGNsYXNzIHRoZXkgYWxsIGluaGVyaXQgZnJvbVxuLy8gVGhpcyB0aGluZyBtYW5hZ2VzIHRoZSBxdWV1ZSBvZiByZXF1ZXN0cywgYW5kIHJldHVybnNcbi8vIHRydWUgb3IgZmFsc2UgaWYgdGhlcmUgaXMgYW55dGhpbmcgaW4gdGhlIHF1ZXVlIHdoZW5cbi8vIHlvdSBjYWxsIHRoZSAud3JpdGUoKSBtZXRob2QuXG5jb25zdCBfb3B0cyA9IFN5bWJvbCgnb3B0cycpXG5jb25zdCBfZmx1c2hGbGFnID0gU3ltYm9sKCdmbHVzaEZsYWcnKVxuY29uc3QgX2ZpbmlzaEZsdXNoRmxhZyA9IFN5bWJvbCgnZmluaXNoRmx1c2hGbGFnJylcbmNvbnN0IF9mdWxsRmx1c2hGbGFnID0gU3ltYm9sKCdmdWxsRmx1c2hGbGFnJylcbmNvbnN0IF9oYW5kbGUgPSBTeW1ib2woJ2hhbmRsZScpXG5jb25zdCBfb25FcnJvciA9IFN5bWJvbCgnb25FcnJvcicpXG5jb25zdCBfc2F3RXJyb3IgPSBTeW1ib2woJ3Nhd0Vycm9yJylcbmNvbnN0IF9sZXZlbCA9IFN5bWJvbCgnbGV2ZWwnKVxuY29uc3QgX3N0cmF0ZWd5ID0gU3ltYm9sKCdzdHJhdGVneScpXG5jb25zdCBfZW5kZWQgPSBTeW1ib2woJ2VuZGVkJylcbmNvbnN0IF9kZWZhdWx0RnVsbEZsdXNoID0gU3ltYm9sKCdfZGVmYXVsdEZ1bGxGbHVzaCcpXG5cbmNsYXNzIFpsaWJCYXNlIGV4dGVuZHMgTWluaXBhc3Mge1xuICBjb25zdHJ1Y3RvciAob3B0cywgbW9kZSkge1xuICAgIGlmICghb3B0cyB8fCB0eXBlb2Ygb3B0cyAhPT0gJ29iamVjdCcpXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIG9wdGlvbnMgZm9yIFpsaWJCYXNlIGNvbnN0cnVjdG9yJylcblxuICAgIHN1cGVyKG9wdHMpXG4gICAgdGhpc1tfZW5kZWRdID0gZmFsc2VcbiAgICB0aGlzW19vcHRzXSA9IG9wdHNcblxuICAgIHRoaXNbX2ZsdXNoRmxhZ10gPSBvcHRzLmZsdXNoXG4gICAgdGhpc1tfZmluaXNoRmx1c2hGbGFnXSA9IG9wdHMuZmluaXNoRmx1c2hcbiAgICAvLyB0aGlzIHdpbGwgdGhyb3cgaWYgYW55IG9wdGlvbnMgYXJlIGludmFsaWQgZm9yIHRoZSBjbGFzcyBzZWxlY3RlZFxuICAgIHRyeSB7XG4gICAgICB0aGlzW19oYW5kbGVdID0gbmV3IHJlYWxabGliW21vZGVdKG9wdHMpXG4gICAgfSBjYXRjaCAoZXIpIHtcbiAgICAgIC8vIG1ha2Ugc3VyZSB0aGF0IGFsbCBlcnJvcnMgZ2V0IGRlY29yYXRlZCBwcm9wZXJseVxuICAgICAgdGhyb3cgbmV3IFpsaWJFcnJvcihlcilcbiAgICB9XG5cbiAgICB0aGlzW19vbkVycm9yXSA9IChlcnIpID0+IHtcbiAgICAgIHRoaXNbX3Nhd0Vycm9yXSA9IHRydWVcbiAgICAgIC8vIHRoZXJlIGlzIG5vIHdheSB0byBjbGVhbmx5IHJlY292ZXIuXG4gICAgICAvLyBjb250aW51aW5nIG9ubHkgb2JzY3VyZXMgcHJvYmxlbXMuXG4gICAgICB0aGlzLmNsb3NlKClcbiAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpXG4gICAgfVxuXG4gICAgdGhpc1tfaGFuZGxlXS5vbignZXJyb3InLCBlciA9PiB0aGlzW19vbkVycm9yXShuZXcgWmxpYkVycm9yKGVyKSkpXG4gICAgdGhpcy5vbmNlKCdlbmQnLCAoKSA9PiB0aGlzLmNsb3NlKVxuICB9XG5cbiAgY2xvc2UgKCkge1xuICAgIGlmICh0aGlzW19oYW5kbGVdKSB7XG4gICAgICB0aGlzW19oYW5kbGVdLmNsb3NlKClcbiAgICAgIHRoaXNbX2hhbmRsZV0gPSBudWxsXG4gICAgICB0aGlzLmVtaXQoJ2Nsb3NlJylcbiAgICB9XG4gIH1cblxuICByZXNldCAoKSB7XG4gICAgaWYgKCF0aGlzW19zYXdFcnJvcl0pIHtcbiAgICAgIGFzc2VydCh0aGlzW19oYW5kbGVdLCAnemxpYiBiaW5kaW5nIGNsb3NlZCcpXG4gICAgICByZXR1cm4gdGhpc1tfaGFuZGxlXS5yZXNldCgpXG4gICAgfVxuICB9XG5cbiAgZmx1c2ggKGZsdXNoRmxhZykge1xuICAgIGlmICh0aGlzLmVuZGVkKVxuICAgICAgcmV0dXJuXG5cbiAgICBpZiAodHlwZW9mIGZsdXNoRmxhZyAhPT0gJ251bWJlcicpXG4gICAgICBmbHVzaEZsYWcgPSB0aGlzW19mdWxsRmx1c2hGbGFnXVxuICAgIHRoaXMud3JpdGUoT2JqZWN0LmFzc2lnbihCdWZmZXIuYWxsb2MoMCksIHsgW19mbHVzaEZsYWddOiBmbHVzaEZsYWcgfSkpXG4gIH1cblxuICBlbmQgKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgICBpZiAoY2h1bmspXG4gICAgICB0aGlzLndyaXRlKGNodW5rLCBlbmNvZGluZylcbiAgICB0aGlzLmZsdXNoKHRoaXNbX2ZpbmlzaEZsdXNoRmxhZ10pXG4gICAgdGhpc1tfZW5kZWRdID0gdHJ1ZVxuICAgIHJldHVybiBzdXBlci5lbmQobnVsbCwgbnVsbCwgY2IpXG4gIH1cblxuICBnZXQgZW5kZWQgKCkge1xuICAgIHJldHVybiB0aGlzW19lbmRlZF1cbiAgfVxuXG4gIHdyaXRlIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gICAgLy8gcHJvY2VzcyB0aGUgY2h1bmsgdXNpbmcgdGhlIHN5bmMgcHJvY2Vzc1xuICAgIC8vIHRoZW4gc3VwZXIud3JpdGUoKSBhbGwgdGhlIG91dHB1dHRlZCBjaHVua3NcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnZnVuY3Rpb24nKVxuICAgICAgY2IgPSBlbmNvZGluZywgZW5jb2RpbmcgPSAndXRmOCdcblxuICAgIGlmICh0eXBlb2YgY2h1bmsgPT09ICdzdHJpbmcnKVxuICAgICAgY2h1bmsgPSBCdWZmZXIuZnJvbShjaHVuaywgZW5jb2RpbmcpXG5cbiAgICBpZiAodGhpc1tfc2F3RXJyb3JdKVxuICAgICAgcmV0dXJuXG4gICAgYXNzZXJ0KHRoaXNbX2hhbmRsZV0sICd6bGliIGJpbmRpbmcgY2xvc2VkJylcblxuICAgIC8vIF9wcm9jZXNzQ2h1bmsgdHJpZXMgdG8gLmNsb3NlKCkgdGhlIG5hdGl2ZSBoYW5kbGUgYWZ0ZXIgaXQncyBkb25lLCBzbyB3ZVxuICAgIC8vIGludGVyY2VwdCB0aGF0IGJ5IHRlbXBvcmFyaWx5IG1ha2luZyBpdCBhIG5vLW9wLlxuICAgIGNvbnN0IG5hdGl2ZUhhbmRsZSA9IHRoaXNbX2hhbmRsZV0uX2hhbmRsZVxuICAgIGNvbnN0IG9yaWdpbmFsTmF0aXZlQ2xvc2UgPSBuYXRpdmVIYW5kbGUuY2xvc2VcbiAgICBuYXRpdmVIYW5kbGUuY2xvc2UgPSAoKSA9PiB7fVxuICAgIGNvbnN0IG9yaWdpbmFsQ2xvc2UgPSB0aGlzW19oYW5kbGVdLmNsb3NlXG4gICAgdGhpc1tfaGFuZGxlXS5jbG9zZSA9ICgpID0+IHt9XG4gICAgLy8gSXQgYWxzbyBjYWxscyBgQnVmZmVyLmNvbmNhdCgpYCBhdCB0aGUgZW5kLCB3aGljaCBtYXkgYmUgY29udmVuaWVudFxuICAgIC8vIGZvciBzb21lLCBidXQgd2hpY2ggd2UgYXJlIG5vdCBpbnRlcmVzdGVkIGluIGFzIGl0IHNsb3dzIHVzIGRvd24uXG4gICAgQnVmZmVyLmNvbmNhdCA9IChhcmdzKSA9PiBhcmdzXG4gICAgbGV0IHJlc3VsdFxuICAgIHRyeSB7XG4gICAgICBjb25zdCBmbHVzaEZsYWcgPSB0eXBlb2YgY2h1bmtbX2ZsdXNoRmxhZ10gPT09ICdudW1iZXInXG4gICAgICAgID8gY2h1bmtbX2ZsdXNoRmxhZ10gOiB0aGlzW19mbHVzaEZsYWddXG4gICAgICByZXN1bHQgPSB0aGlzW19oYW5kbGVdLl9wcm9jZXNzQ2h1bmsoY2h1bmssIGZsdXNoRmxhZylcbiAgICAgIC8vIGlmIHdlIGRvbid0IHRocm93LCByZXNldCBpdCBiYWNrIGhvdyBpdCB3YXNcbiAgICAgIEJ1ZmZlci5jb25jYXQgPSBPcmlnaW5hbEJ1ZmZlckNvbmNhdFxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgLy8gb3IgaWYgd2UgZG8sIHB1dCBCdWZmZXIuY29uY2F0KCkgYmFjayBiZWZvcmUgd2UgZW1pdCBlcnJvclxuICAgICAgLy8gRXJyb3IgZXZlbnRzIGNhbGwgaW50byB1c2VyIGNvZGUsIHdoaWNoIG1heSBjYWxsIEJ1ZmZlci5jb25jYXQoKVxuICAgICAgQnVmZmVyLmNvbmNhdCA9IE9yaWdpbmFsQnVmZmVyQ29uY2F0XG4gICAgICB0aGlzW19vbkVycm9yXShuZXcgWmxpYkVycm9yKGVycikpXG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmICh0aGlzW19oYW5kbGVdKSB7XG4gICAgICAgIC8vIENvcmUgemxpYiByZXNldHMgYF9oYW5kbGVgIHRvIG51bGwgYWZ0ZXIgYXR0ZW1wdGluZyB0byBjbG9zZSB0aGVcbiAgICAgICAgLy8gbmF0aXZlIGhhbmRsZS4gT3VyIG5vLW9wIGhhbmRsZXIgcHJldmVudGVkIGFjdHVhbCBjbG9zdXJlLCBidXQgd2VcbiAgICAgICAgLy8gbmVlZCB0byByZXN0b3JlIHRoZSBgLl9oYW5kbGVgIHByb3BlcnR5LlxuICAgICAgICB0aGlzW19oYW5kbGVdLl9oYW5kbGUgPSBuYXRpdmVIYW5kbGVcbiAgICAgICAgbmF0aXZlSGFuZGxlLmNsb3NlID0gb3JpZ2luYWxOYXRpdmVDbG9zZVxuICAgICAgICB0aGlzW19oYW5kbGVdLmNsb3NlID0gb3JpZ2luYWxDbG9zZVxuICAgICAgICAvLyBgX3Byb2Nlc3NDaHVuaygpYCBhZGRzIGFuICdlcnJvcicgbGlzdGVuZXIuIElmIHdlIGRvbid0IHJlbW92ZSBpdFxuICAgICAgICAvLyBhZnRlciBlYWNoIGNhbGwsIHRoZXNlIGhhbmRsZXJzIHN0YXJ0IHBpbGluZyB1cC5cbiAgICAgICAgdGhpc1tfaGFuZGxlXS5yZW1vdmVBbGxMaXN0ZW5lcnMoJ2Vycm9yJylcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgd3JpdGVSZXR1cm5cbiAgICBpZiAocmVzdWx0KSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShyZXN1bHQpICYmIHJlc3VsdC5sZW5ndGggPiAwKSB7XG4gICAgICAgIC8vIFRoZSBmaXJzdCBidWZmZXIgaXMgYWx3YXlzIGBoYW5kbGUuX291dEJ1ZmZlcmAsIHdoaWNoIHdvdWxkIGJlXG4gICAgICAgIC8vIHJlLXVzZWQgZm9yIGxhdGVyIGludm9jYXRpb25zOyBzbywgd2UgYWx3YXlzIGhhdmUgdG8gY29weSB0aGF0IG9uZS5cbiAgICAgICAgd3JpdGVSZXR1cm4gPSBzdXBlci53cml0ZShCdWZmZXIuZnJvbShyZXN1bHRbMF0pKVxuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHJlc3VsdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHdyaXRlUmV0dXJuID0gc3VwZXIud3JpdGUocmVzdWx0W2ldKVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3cml0ZVJldHVybiA9IHN1cGVyLndyaXRlKEJ1ZmZlci5mcm9tKHJlc3VsdCkpXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNiKVxuICAgICAgY2IoKVxuICAgIHJldHVybiB3cml0ZVJldHVyblxuICB9XG59XG5cbmNsYXNzIFpsaWIgZXh0ZW5kcyBabGliQmFzZSB7XG4gIGNvbnN0cnVjdG9yIChvcHRzLCBtb2RlKSB7XG4gICAgb3B0cyA9IG9wdHMgfHwge31cblxuICAgIG9wdHMuZmx1c2ggPSBvcHRzLmZsdXNoIHx8IGNvbnN0YW50cy5aX05PX0ZMVVNIXG4gICAgb3B0cy5maW5pc2hGbHVzaCA9IG9wdHMuZmluaXNoRmx1c2ggfHwgY29uc3RhbnRzLlpfRklOSVNIXG4gICAgc3VwZXIob3B0cywgbW9kZSlcblxuICAgIHRoaXNbX2Z1bGxGbHVzaEZsYWddID0gY29uc3RhbnRzLlpfRlVMTF9GTFVTSFxuICAgIHRoaXNbX2xldmVsXSA9IG9wdHMubGV2ZWxcbiAgICB0aGlzW19zdHJhdGVneV0gPSBvcHRzLnN0cmF0ZWd5XG4gIH1cblxuICBwYXJhbXMgKGxldmVsLCBzdHJhdGVneSkge1xuICAgIGlmICh0aGlzW19zYXdFcnJvcl0pXG4gICAgICByZXR1cm5cblxuICAgIGlmICghdGhpc1tfaGFuZGxlXSlcbiAgICAgIHRocm93IG5ldyBFcnJvcignY2Fubm90IHN3aXRjaCBwYXJhbXMgd2hlbiBiaW5kaW5nIGlzIGNsb3NlZCcpXG5cbiAgICAvLyBubyB3YXkgdG8gdGVzdCB0aGlzIHdpdGhvdXQgYWxzbyBub3Qgc3VwcG9ydGluZyBwYXJhbXMgYXQgYWxsXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCF0aGlzW19oYW5kbGVdLnBhcmFtcylcbiAgICAgIHRocm93IG5ldyBFcnJvcignbm90IHN1cHBvcnRlZCBpbiB0aGlzIGltcGxlbWVudGF0aW9uJylcblxuICAgIGlmICh0aGlzW19sZXZlbF0gIT09IGxldmVsIHx8IHRoaXNbX3N0cmF0ZWd5XSAhPT0gc3RyYXRlZ3kpIHtcbiAgICAgIHRoaXMuZmx1c2goY29uc3RhbnRzLlpfU1lOQ19GTFVTSClcbiAgICAgIGFzc2VydCh0aGlzW19oYW5kbGVdLCAnemxpYiBiaW5kaW5nIGNsb3NlZCcpXG4gICAgICAvLyAucGFyYW1zKCkgY2FsbHMgLmZsdXNoKCksIGJ1dCB0aGUgbGF0dGVyIGlzIGFsd2F5cyBhc3luYyBpbiB0aGVcbiAgICAgIC8vIGNvcmUgemxpYi4gV2Ugb3ZlcnJpZGUgLmZsdXNoKCkgdGVtcG9yYXJpbHkgdG8gaW50ZXJjZXB0IHRoYXQgYW5kXG4gICAgICAvLyBmbHVzaCBzeW5jaHJvbm91c2x5LlxuICAgICAgY29uc3Qgb3JpZ0ZsdXNoID0gdGhpc1tfaGFuZGxlXS5mbHVzaFxuICAgICAgdGhpc1tfaGFuZGxlXS5mbHVzaCA9IChmbHVzaEZsYWcsIGNiKSA9PiB7XG4gICAgICAgIHRoaXMuZmx1c2goZmx1c2hGbGFnKVxuICAgICAgICBjYigpXG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzW19oYW5kbGVdLnBhcmFtcyhsZXZlbCwgc3RyYXRlZ3kpXG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0aGlzW19oYW5kbGVdLmZsdXNoID0gb3JpZ0ZsdXNoXG4gICAgICB9XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgaWYgKHRoaXNbX2hhbmRsZV0pIHtcbiAgICAgICAgdGhpc1tfbGV2ZWxdID0gbGV2ZWxcbiAgICAgICAgdGhpc1tfc3RyYXRlZ3ldID0gc3RyYXRlZ3lcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLy8gbWluaW1hbCAyLWJ5dGUgaGVhZGVyXG5jbGFzcyBEZWZsYXRlIGV4dGVuZHMgWmxpYiB7XG4gIGNvbnN0cnVjdG9yIChvcHRzKSB7XG4gICAgc3VwZXIob3B0cywgJ0RlZmxhdGUnKVxuICB9XG59XG5cbmNsYXNzIEluZmxhdGUgZXh0ZW5kcyBabGliIHtcbiAgY29uc3RydWN0b3IgKG9wdHMpIHtcbiAgICBzdXBlcihvcHRzLCAnSW5mbGF0ZScpXG4gIH1cbn1cblxuLy8gZ3ppcCAtIGJpZ2dlciBoZWFkZXIsIHNhbWUgZGVmbGF0ZSBjb21wcmVzc2lvblxuY2xhc3MgR3ppcCBleHRlbmRzIFpsaWIge1xuICBjb25zdHJ1Y3RvciAob3B0cykge1xuICAgIHN1cGVyKG9wdHMsICdHemlwJylcbiAgfVxufVxuXG5jbGFzcyBHdW56aXAgZXh0ZW5kcyBabGliIHtcbiAgY29uc3RydWN0b3IgKG9wdHMpIHtcbiAgICBzdXBlcihvcHRzLCAnR3VuemlwJylcbiAgfVxufVxuXG4vLyByYXcgLSBubyBoZWFkZXJcbmNsYXNzIERlZmxhdGVSYXcgZXh0ZW5kcyBabGliIHtcbiAgY29uc3RydWN0b3IgKG9wdHMpIHtcbiAgICBzdXBlcihvcHRzLCAnRGVmbGF0ZVJhdycpXG4gIH1cbn1cblxuY2xhc3MgSW5mbGF0ZVJhdyBleHRlbmRzIFpsaWIge1xuICBjb25zdHJ1Y3RvciAob3B0cykge1xuICAgIHN1cGVyKG9wdHMsICdJbmZsYXRlUmF3JylcbiAgfVxufVxuXG4vLyBhdXRvLWRldGVjdCBoZWFkZXIuXG5jbGFzcyBVbnppcCBleHRlbmRzIFpsaWIge1xuICBjb25zdHJ1Y3RvciAob3B0cykge1xuICAgIHN1cGVyKG9wdHMsICdVbnppcCcpXG4gIH1cbn1cblxuY2xhc3MgQnJvdGxpIGV4dGVuZHMgWmxpYkJhc2Uge1xuICBjb25zdHJ1Y3RvciAob3B0cywgbW9kZSkge1xuICAgIG9wdHMgPSBvcHRzIHx8IHt9XG5cbiAgICBvcHRzLmZsdXNoID0gb3B0cy5mbHVzaCB8fCBjb25zdGFudHMuQlJPVExJX09QRVJBVElPTl9QUk9DRVNTXG4gICAgb3B0cy5maW5pc2hGbHVzaCA9IG9wdHMuZmluaXNoRmx1c2ggfHwgY29uc3RhbnRzLkJST1RMSV9PUEVSQVRJT05fRklOSVNIXG5cbiAgICBzdXBlcihvcHRzLCBtb2RlKVxuXG4gICAgdGhpc1tfZnVsbEZsdXNoRmxhZ10gPSBjb25zdGFudHMuQlJPVExJX09QRVJBVElPTl9GTFVTSFxuICB9XG59XG5cbmNsYXNzIEJyb3RsaUNvbXByZXNzIGV4dGVuZHMgQnJvdGxpIHtcbiAgY29uc3RydWN0b3IgKG9wdHMpIHtcbiAgICBzdXBlcihvcHRzLCAnQnJvdGxpQ29tcHJlc3MnKVxuICB9XG59XG5cbmNsYXNzIEJyb3RsaURlY29tcHJlc3MgZXh0ZW5kcyBCcm90bGkge1xuICBjb25zdHJ1Y3RvciAob3B0cykge1xuICAgIHN1cGVyKG9wdHMsICdCcm90bGlEZWNvbXByZXNzJylcbiAgfVxufVxuXG5leHBvcnRzLkRlZmxhdGUgPSBEZWZsYXRlXG5leHBvcnRzLkluZmxhdGUgPSBJbmZsYXRlXG5leHBvcnRzLkd6aXAgPSBHemlwXG5leHBvcnRzLkd1bnppcCA9IEd1bnppcFxuZXhwb3J0cy5EZWZsYXRlUmF3ID0gRGVmbGF0ZVJhd1xuZXhwb3J0cy5JbmZsYXRlUmF3ID0gSW5mbGF0ZVJhd1xuZXhwb3J0cy5VbnppcCA9IFVuemlwXG4vKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuaWYgKHR5cGVvZiByZWFsWmxpYi5Ccm90bGlDb21wcmVzcyA9PT0gJ2Z1bmN0aW9uJykge1xuICBleHBvcnRzLkJyb3RsaUNvbXByZXNzID0gQnJvdGxpQ29tcHJlc3NcbiAgZXhwb3J0cy5Ccm90bGlEZWNvbXByZXNzID0gQnJvdGxpRGVjb21wcmVzc1xufSBlbHNlIHtcbiAgZXhwb3J0cy5Ccm90bGlDb21wcmVzcyA9IGV4cG9ydHMuQnJvdGxpRGVjb21wcmVzcyA9IGNsYXNzIHtcbiAgICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Jyb3RsaSBpcyBub3Qgc3VwcG9ydGVkIGluIHRoaXMgdmVyc2lvbiBvZiBOb2RlLmpzJylcbiAgICB9XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/minizlib/index.js\n");

/***/ })

};
;