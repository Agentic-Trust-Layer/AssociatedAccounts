/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/web3-providers-ws";
exports.ids = ["vendor-chunks/web3-providers-ws"];
exports.modules = {

/***/ "(rsc)/../../node_modules/web3-providers-ws/lib/helpers.js":
/*!***********************************************************!*\
  !*** ../../node_modules/web3-providers-ws/lib/helpers.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var isNode = Object.prototype.toString.call(typeof process !== 'undefined' ? process : 0) === '[object process]';\nvar isRN = typeof navigator !== 'undefined' && navigator.product === 'ReactNative';\nvar _btoa = null;\nvar helpers = null;\nif (isNode || isRN) {\n    _btoa = function (str) {\n        return Buffer.from(str).toString('base64');\n    };\n    var url = __webpack_require__(/*! url */ \"url\");\n    if (url.URL) {\n        // Use the new Node 6+ API for parsing URLs that supports username/password\n        var newURL = url.URL;\n        helpers = function (url) {\n            return new newURL(url);\n        };\n    }\n    else {\n        // Web3 supports Node.js 5, so fall back to the legacy URL API if necessary\n        helpers = (__webpack_require__(/*! url */ \"url\").parse);\n    }\n}\nelse {\n    _btoa = btoa.bind(typeof globalThis === 'object' ? globalThis : self);\n    helpers = function (url) {\n        return new URL(url);\n    };\n}\nmodule.exports = {\n    parseURL: helpers,\n    btoa: _btoa\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL3dlYjMtcHJvdmlkZXJzLXdzL2xpYi9oZWxwZXJzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLG1CQUFPLENBQUMsZ0JBQUs7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDZDQUFvQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL2JhcmIvYWEvQXNzb2NpYXRlZEFjY291bnRzL25vZGVfbW9kdWxlcy93ZWIzLXByb3ZpZGVycy13cy9saWIvaGVscGVycy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgaXNOb2RlID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyA/IHByb2Nlc3MgOiAwKSA9PT0gJ1tvYmplY3QgcHJvY2Vzc10nO1xudmFyIGlzUk4gPSB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IucHJvZHVjdCA9PT0gJ1JlYWN0TmF0aXZlJztcbnZhciBfYnRvYSA9IG51bGw7XG52YXIgaGVscGVycyA9IG51bGw7XG5pZiAoaXNOb2RlIHx8IGlzUk4pIHtcbiAgICBfYnRvYSA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHN0cikudG9TdHJpbmcoJ2Jhc2U2NCcpO1xuICAgIH07XG4gICAgdmFyIHVybCA9IHJlcXVpcmUoJ3VybCcpO1xuICAgIGlmICh1cmwuVVJMKSB7XG4gICAgICAgIC8vIFVzZSB0aGUgbmV3IE5vZGUgNisgQVBJIGZvciBwYXJzaW5nIFVSTHMgdGhhdCBzdXBwb3J0cyB1c2VybmFtZS9wYXNzd29yZFxuICAgICAgICB2YXIgbmV3VVJMID0gdXJsLlVSTDtcbiAgICAgICAgaGVscGVycyA9IGZ1bmN0aW9uICh1cmwpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgbmV3VVJMKHVybCk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBXZWIzIHN1cHBvcnRzIE5vZGUuanMgNSwgc28gZmFsbCBiYWNrIHRvIHRoZSBsZWdhY3kgVVJMIEFQSSBpZiBuZWNlc3NhcnlcbiAgICAgICAgaGVscGVycyA9IHJlcXVpcmUoJ3VybCcpLnBhcnNlO1xuICAgIH1cbn1cbmVsc2Uge1xuICAgIF9idG9hID0gYnRvYS5iaW5kKHR5cGVvZiBnbG9iYWxUaGlzID09PSAnb2JqZWN0JyA/IGdsb2JhbFRoaXMgOiBzZWxmKTtcbiAgICBoZWxwZXJzID0gZnVuY3Rpb24gKHVybCkge1xuICAgICAgICByZXR1cm4gbmV3IFVSTCh1cmwpO1xuICAgIH07XG59XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBwYXJzZVVSTDogaGVscGVycyxcbiAgICBidG9hOiBfYnRvYVxufTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/web3-providers-ws/lib/helpers.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/web3-providers-ws/lib/index.js":
/*!*********************************************************!*\
  !*** ../../node_modules/web3-providers-ws/lib/index.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*\n This file is part of web3.js.\n\n web3.js is free software: you can redistribute it and/or modify\n it under the terms of the GNU Lesser General Public License as published by\n the Free Software Foundation, either version 3 of the License, or\n (at your option) any later version.\n\n web3.js is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n GNU Lesser General Public License for more details.\n\n You should have received a copy of the GNU Lesser General Public License\n along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n */\n/**\n * @file WebsocketProvider.js\n * @authors: Samuel Furter <samuel@ethereum.org>, Fabian Vogelsteller <fabian@ethereum.org>\n * @date 2019\n */\n\nvar EventEmitter = __webpack_require__(/*! eventemitter3 */ \"(rsc)/../../node_modules/web3-providers-ws/node_modules/eventemitter3/index.js\");\nvar helpers = __webpack_require__(/*! ./helpers.js */ \"(rsc)/../../node_modules/web3-providers-ws/lib/helpers.js\");\nvar errors = (__webpack_require__(/*! web3-core-helpers */ \"(rsc)/../../node_modules/web3-core-helpers/lib/index.js\").errors);\nvar Ws = (__webpack_require__(/*! websocket */ \"websocket\").w3cwebsocket);\n/**\n * @param {string} url\n * @param {Object} options\n *\n * @constructor\n */\nvar WebsocketProvider = function WebsocketProvider(url, options) {\n    EventEmitter.call(this);\n    options = options || {};\n    this.url = url;\n    this._customTimeout = options.timeout || 1000 * 15;\n    this.headers = options.headers || {};\n    this.protocol = options.protocol || undefined;\n    this.reconnectOptions = Object.assign({\n        auto: false,\n        delay: 5000,\n        maxAttempts: false,\n        onTimeout: false\n    }, options.reconnect);\n    this.clientConfig = options.clientConfig || undefined; // Allow a custom client configuration\n    this.requestOptions = options.requestOptions || undefined; // Allow a custom request options (https://github.com/theturtle32/WebSocket-Node/blob/master/docs/WebSocketClient.md#connectrequesturl-requestedprotocols-origin-headers-requestoptions)\n    this.DATA = 'data';\n    this.CLOSE = 'close';\n    this.ERROR = 'error';\n    this.CONNECT = 'connect';\n    this.RECONNECT = 'reconnect';\n    this.connection = null;\n    this.requestQueue = new Map();\n    this.responseQueue = new Map();\n    this.reconnectAttempts = 0;\n    this.reconnecting = false;\n    this.connectFailedDescription = null;\n    // The w3cwebsocket implementation does not support Basic Auth\n    // username/password in the URL. So generate the basic auth header, and\n    // pass through with any additional headers supplied in constructor\n    var parsedURL = helpers.parseURL(url);\n    if (parsedURL.username && parsedURL.password) {\n        this.headers.authorization = 'Basic ' + helpers.btoa(parsedURL.username + ':' + parsedURL.password);\n    }\n    // When all node core implementations that do not have the\n    // WHATWG compatible URL parser go out of service this line can be removed.\n    if (parsedURL.auth) {\n        this.headers.authorization = 'Basic ' + helpers.btoa(parsedURL.auth);\n    }\n    // make property `connected` which will return the current connection status\n    Object.defineProperty(this, 'connected', {\n        get: function () {\n            return this.connection && this.connection.readyState === this.connection.OPEN;\n        },\n        enumerable: true\n    });\n    this.connect();\n};\n// Inherit from EventEmitter\nWebsocketProvider.prototype = Object.create(EventEmitter.prototype);\nWebsocketProvider.prototype.constructor = WebsocketProvider;\n/**\n * Connects to the configured node\n *\n * @method connect\n *\n * @returns {void}\n */\nWebsocketProvider.prototype.connect = function () {\n    this.connection = new Ws(this.url, this.protocol, undefined, this.headers, this.requestOptions, this.clientConfig);\n    this._addSocketListeners();\n};\n/**\n * Listener for the `data` event of the underlying WebSocket object\n *\n * @method _onMessage\n *\n * @returns {void}\n */\nWebsocketProvider.prototype._onMessage = function (e) {\n    var _this = this;\n    this._parseResponse((typeof e.data === 'string') ? e.data : '').forEach(function (result) {\n        if (result.method && result.method.indexOf('_subscription') !== -1) {\n            _this.emit(_this.DATA, result);\n            return;\n        }\n        var id = result.id;\n        // get the id which matches the returned id\n        if (Array.isArray(result)) {\n            id = result[0].id;\n        }\n        if (_this.responseQueue.has(id)) {\n            if (_this.responseQueue.get(id).callback !== undefined) {\n                _this.responseQueue.get(id).callback(false, result);\n            }\n            _this.responseQueue.delete(id);\n        }\n    });\n};\n/**\n * Listener for the `open` event of the underlying WebSocket object\n *\n * @method _onConnect\n *\n * @returns {void}\n */\nWebsocketProvider.prototype._onConnect = function () {\n    this.emit(this.CONNECT);\n    this.reconnectAttempts = 0;\n    this.reconnecting = false;\n    if (this.requestQueue.size > 0) {\n        var _this = this;\n        this.requestQueue.forEach(function (request, key) {\n            _this.send(request.payload, request.callback);\n            _this.requestQueue.delete(key);\n        });\n    }\n};\nWebsocketProvider.prototype._onConnectFailed = function (event) {\n    this.connectFailedDescription = event.toString().split('\\n')[0];\n    var _this = this;\n    if (this.connectFailedDescription) {\n        event.description = this.connectFailedDescription;\n        this.connectFailedDescription = null; // clean the message, so it won't be used in the next connection\n    }\n    event.code = 1006;\n    event.reason = 'connection failed';\n    if (this.reconnectOptions.auto && (![1000, 1001].includes(event.code) || event.wasClean === false)) {\n        this.reconnect();\n        return;\n    }\n    this.emit(this.ERROR, event);\n    if (this.requestQueue.size > 0) {\n        this.requestQueue.forEach(function (request, key) {\n            request.callback(errors.ConnectionNotOpenError(event));\n            _this.requestQueue.delete(key);\n        });\n    }\n    if (this.responseQueue.size > 0) {\n        this.responseQueue.forEach(function (request, key) {\n            request.callback(errors.InvalidConnection('on WS', event));\n            _this.responseQueue.delete(key);\n        });\n    }\n    //clean connection on our own\n    if (this.connection._connection) {\n        this.connection._connection.removeAllListeners();\n    }\n    this.connection._client.removeAllListeners();\n    this.connection._readyState = 3; // set readyState to CLOSED\n    this.emit(this.CLOSE, event);\n};\n/**\n * Listener for the `close` event of the underlying WebSocket object\n *\n * @method _onClose\n *\n * @returns {void}\n */\nWebsocketProvider.prototype._onClose = function (event) {\n    var _this = this;\n    if (this.reconnectOptions.auto && (![1000, 1001].includes(event.code) || event.wasClean === false)) {\n        this.reconnect();\n        return;\n    }\n    this.emit(this.CLOSE, event);\n    if (this.requestQueue.size > 0) {\n        this.requestQueue.forEach(function (request, key) {\n            request.callback(errors.ConnectionNotOpenError(event));\n            _this.requestQueue.delete(key);\n        });\n    }\n    if (this.responseQueue.size > 0) {\n        this.responseQueue.forEach(function (request, key) {\n            request.callback(errors.InvalidConnection('on WS', event));\n            _this.responseQueue.delete(key);\n        });\n    }\n    this._removeSocketListeners();\n    this.removeAllListeners();\n};\n/**\n * Will add the required socket listeners\n *\n * @method _addSocketListeners\n *\n * @returns {void}\n */\nWebsocketProvider.prototype._addSocketListeners = function () {\n    this.connection.addEventListener('message', this._onMessage.bind(this));\n    this.connection.addEventListener('open', this._onConnect.bind(this));\n    this.connection.addEventListener('close', this._onClose.bind(this));\n    if (this.connection._client) {\n        this.connection._client.removeAllListeners('connectFailed'); //Override the internal listeners, so they don't trigger a `close` event. We want to trigger `_onClose` manually with a description.\n        this.connection._client.on('connectFailed', this._onConnectFailed.bind(this));\n    }\n};\n/**\n * Will remove all socket listeners\n *\n * @method _removeSocketListeners\n *\n * @returns {void}\n */\nWebsocketProvider.prototype._removeSocketListeners = function () {\n    this.connection.removeEventListener('message', this._onMessage);\n    this.connection.removeEventListener('open', this._onConnect);\n    this.connection.removeEventListener('close', this._onClose);\n    if (this.connection._connection)\n        this.connection._client.removeListener('connectFailed', this._onConnectFailed);\n};\n/**\n * Will parse the response and make an array out of it.\n *\n * @method _parseResponse\n *\n * @param {String} data\n *\n * @returns {Array}\n */\nWebsocketProvider.prototype._parseResponse = function (data) {\n    var _this = this, returnValues = [];\n    // DE-CHUNKER\n    var dechunkedData = data\n        .replace(/\\}[\\n\\r]?\\{/g, '}|--|{') // }{\n        .replace(/\\}\\][\\n\\r]?\\[\\{/g, '}]|--|[{') // }][{\n        .replace(/\\}[\\n\\r]?\\[\\{/g, '}|--|[{') // }[{\n        .replace(/\\}\\][\\n\\r]?\\{/g, '}]|--|{') // }]{\n        .split('|--|');\n    dechunkedData.forEach(function (data) {\n        // prepend the last chunk\n        if (_this.lastChunk)\n            data = _this.lastChunk + data;\n        var result = null;\n        try {\n            result = JSON.parse(data);\n        }\n        catch (e) {\n            _this.lastChunk = data;\n            // start timeout to cancel all requests\n            clearTimeout(_this.lastChunkTimeout);\n            _this.lastChunkTimeout = setTimeout(function () {\n                if (_this.reconnectOptions.auto && _this.reconnectOptions.onTimeout) {\n                    _this.reconnect();\n                    return;\n                }\n                _this.emit(_this.ERROR, errors.ConnectionTimeout(_this._customTimeout));\n                if (_this.requestQueue.size > 0) {\n                    _this.requestQueue.forEach(function (request, key) {\n                        request.callback(errors.ConnectionTimeout(_this._customTimeout));\n                        _this.requestQueue.delete(key);\n                    });\n                }\n            }, _this._customTimeout);\n            return;\n        }\n        // cancel timeout and set chunk to null\n        clearTimeout(_this.lastChunkTimeout);\n        _this.lastChunk = null;\n        if (result)\n            returnValues.push(result);\n    });\n    return returnValues;\n};\n/**\n * Does check if the provider is connecting and will add it to the queue or will send it directly\n *\n * @method send\n *\n * @param {Object} payload\n * @param {Function} callback\n *\n * @returns {void}\n */\nWebsocketProvider.prototype.send = function (payload, callback) {\n    var _this = this;\n    var id = payload.id;\n    var request = { payload: payload, callback: callback };\n    if (Array.isArray(payload)) {\n        id = payload[0].id;\n    }\n    if (this.connection.readyState === this.connection.CONNECTING || this.reconnecting) {\n        this.requestQueue.set(id, request);\n        return;\n    }\n    if (this.connection.readyState !== this.connection.OPEN) {\n        this.requestQueue.delete(id);\n        this.emit(this.ERROR, errors.ConnectionNotOpenError());\n        request.callback(errors.ConnectionNotOpenError());\n        return;\n    }\n    this.responseQueue.set(id, request);\n    this.requestQueue.delete(id);\n    try {\n        this.connection.send(JSON.stringify(request.payload));\n    }\n    catch (error) {\n        request.callback(error);\n        _this.responseQueue.delete(id);\n    }\n};\n/**\n * Resets the providers, clears all callbacks\n *\n * @method reset\n *\n * @returns {void}\n */\nWebsocketProvider.prototype.reset = function () {\n    this.responseQueue.clear();\n    this.requestQueue.clear();\n    this.removeAllListeners();\n    this._removeSocketListeners();\n    this._addSocketListeners();\n};\n/**\n * Closes the current connection with the given code and reason arguments\n *\n * @method disconnect\n *\n * @param {number} code\n * @param {string} reason\n *\n * @returns {void}\n */\nWebsocketProvider.prototype.disconnect = function (code, reason) {\n    this._removeSocketListeners();\n    this.connection.close(code || 1000, reason);\n};\n/**\n * Returns the desired boolean.\n *\n * @method supportsSubscriptions\n *\n * @returns {boolean}\n */\nWebsocketProvider.prototype.supportsSubscriptions = function () {\n    return true;\n};\n/**\n * Removes the listeners and reconnects to the socket.\n *\n * @method reconnect\n *\n * @returns {void}\n */\nWebsocketProvider.prototype.reconnect = function () {\n    var _this = this;\n    this.reconnecting = true;\n    if (this.responseQueue.size > 0) {\n        this.responseQueue.forEach(function (request, key) {\n            try {\n                _this.responseQueue.delete(key);\n                request.callback(errors.PendingRequestsOnReconnectingError());\n            }\n            catch (e) {\n                console.error(\"Error encountered in reconnect: \", e);\n            }\n        });\n    }\n    if (!this.reconnectOptions.maxAttempts ||\n        this.reconnectAttempts < this.reconnectOptions.maxAttempts) {\n        setTimeout(function () {\n            _this.reconnectAttempts++;\n            _this._removeSocketListeners();\n            _this.emit(_this.RECONNECT, _this.reconnectAttempts);\n            _this.connect();\n        }, this.reconnectOptions.delay);\n        return;\n    }\n    this.emit(this.ERROR, errors.MaxAttemptsReachedOnReconnectingError());\n    this.reconnecting = false;\n    if (this.requestQueue.size > 0) {\n        this.requestQueue.forEach(function (request, key) {\n            request.callback(errors.MaxAttemptsReachedOnReconnectingError());\n            _this.requestQueue.delete(key);\n        });\n    }\n};\nmodule.exports = WebsocketProvider;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL3dlYjMtcHJvdmlkZXJzLXdzL2xpYi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhO0FBQ2IsbUJBQW1CLG1CQUFPLENBQUMscUdBQWU7QUFDMUMsY0FBYyxtQkFBTyxDQUFDLCtFQUFjO0FBQ3BDLGFBQWEsZ0hBQW1DO0FBQ2hELFNBQVMsZ0VBQWlDO0FBQzFDO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsMkRBQTJEO0FBQzNELCtEQUErRDtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTLE1BQU0sS0FBSztBQUN4QyxvQkFBb0IsYUFBYSxNQUFNLE9BQU8sT0FBTztBQUNyRCxvQkFBb0IsV0FBVyxNQUFNLE1BQU0sT0FBTztBQUNsRCxvQkFBb0IsV0FBVyxNQUFNLE1BQU0sT0FBTztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsVUFBVTtBQUNyQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL2JhcmIvYWEvQXNzb2NpYXRlZEFjY291bnRzL25vZGVfbW9kdWxlcy93ZWIzLXByb3ZpZGVycy13cy9saWIvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiBUaGlzIGZpbGUgaXMgcGFydCBvZiB3ZWIzLmpzLlxuXG4gd2ViMy5qcyBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gd2ViMy5qcyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gYWxvbmcgd2l0aCB3ZWIzLmpzLiAgSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuICovXG4vKipcbiAqIEBmaWxlIFdlYnNvY2tldFByb3ZpZGVyLmpzXG4gKiBAYXV0aG9yczogU2FtdWVsIEZ1cnRlciA8c2FtdWVsQGV0aGVyZXVtLm9yZz4sIEZhYmlhbiBWb2dlbHN0ZWxsZXIgPGZhYmlhbkBldGhlcmV1bS5vcmc+XG4gKiBAZGF0ZSAyMDE5XG4gKi9cbid1c2Ugc3RyaWN0JztcbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudGVtaXR0ZXIzJyk7XG52YXIgaGVscGVycyA9IHJlcXVpcmUoJy4vaGVscGVycy5qcycpO1xudmFyIGVycm9ycyA9IHJlcXVpcmUoJ3dlYjMtY29yZS1oZWxwZXJzJykuZXJyb3JzO1xudmFyIFdzID0gcmVxdWlyZSgnd2Vic29ja2V0JykudzNjd2Vic29ja2V0O1xuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICpcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgV2Vic29ja2V0UHJvdmlkZXIgPSBmdW5jdGlvbiBXZWJzb2NrZXRQcm92aWRlcih1cmwsIG9wdGlvbnMpIHtcbiAgICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB0aGlzLnVybCA9IHVybDtcbiAgICB0aGlzLl9jdXN0b21UaW1lb3V0ID0gb3B0aW9ucy50aW1lb3V0IHx8IDEwMDAgKiAxNTtcbiAgICB0aGlzLmhlYWRlcnMgPSBvcHRpb25zLmhlYWRlcnMgfHwge307XG4gICAgdGhpcy5wcm90b2NvbCA9IG9wdGlvbnMucHJvdG9jb2wgfHwgdW5kZWZpbmVkO1xuICAgIHRoaXMucmVjb25uZWN0T3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICBhdXRvOiBmYWxzZSxcbiAgICAgICAgZGVsYXk6IDUwMDAsXG4gICAgICAgIG1heEF0dGVtcHRzOiBmYWxzZSxcbiAgICAgICAgb25UaW1lb3V0OiBmYWxzZVxuICAgIH0sIG9wdGlvbnMucmVjb25uZWN0KTtcbiAgICB0aGlzLmNsaWVudENvbmZpZyA9IG9wdGlvbnMuY2xpZW50Q29uZmlnIHx8IHVuZGVmaW5lZDsgLy8gQWxsb3cgYSBjdXN0b20gY2xpZW50IGNvbmZpZ3VyYXRpb25cbiAgICB0aGlzLnJlcXVlc3RPcHRpb25zID0gb3B0aW9ucy5yZXF1ZXN0T3B0aW9ucyB8fCB1bmRlZmluZWQ7IC8vIEFsbG93IGEgY3VzdG9tIHJlcXVlc3Qgb3B0aW9ucyAoaHR0cHM6Ly9naXRodWIuY29tL3RoZXR1cnRsZTMyL1dlYlNvY2tldC1Ob2RlL2Jsb2IvbWFzdGVyL2RvY3MvV2ViU29ja2V0Q2xpZW50Lm1kI2Nvbm5lY3RyZXF1ZXN0dXJsLXJlcXVlc3RlZHByb3RvY29scy1vcmlnaW4taGVhZGVycy1yZXF1ZXN0b3B0aW9ucylcbiAgICB0aGlzLkRBVEEgPSAnZGF0YSc7XG4gICAgdGhpcy5DTE9TRSA9ICdjbG9zZSc7XG4gICAgdGhpcy5FUlJPUiA9ICdlcnJvcic7XG4gICAgdGhpcy5DT05ORUNUID0gJ2Nvbm5lY3QnO1xuICAgIHRoaXMuUkVDT05ORUNUID0gJ3JlY29ubmVjdCc7XG4gICAgdGhpcy5jb25uZWN0aW9uID0gbnVsbDtcbiAgICB0aGlzLnJlcXVlc3RRdWV1ZSA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLnJlc3BvbnNlUXVldWUgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5yZWNvbm5lY3RBdHRlbXB0cyA9IDA7XG4gICAgdGhpcy5yZWNvbm5lY3RpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmNvbm5lY3RGYWlsZWREZXNjcmlwdGlvbiA9IG51bGw7XG4gICAgLy8gVGhlIHczY3dlYnNvY2tldCBpbXBsZW1lbnRhdGlvbiBkb2VzIG5vdCBzdXBwb3J0IEJhc2ljIEF1dGhcbiAgICAvLyB1c2VybmFtZS9wYXNzd29yZCBpbiB0aGUgVVJMLiBTbyBnZW5lcmF0ZSB0aGUgYmFzaWMgYXV0aCBoZWFkZXIsIGFuZFxuICAgIC8vIHBhc3MgdGhyb3VnaCB3aXRoIGFueSBhZGRpdGlvbmFsIGhlYWRlcnMgc3VwcGxpZWQgaW4gY29uc3RydWN0b3JcbiAgICB2YXIgcGFyc2VkVVJMID0gaGVscGVycy5wYXJzZVVSTCh1cmwpO1xuICAgIGlmIChwYXJzZWRVUkwudXNlcm5hbWUgJiYgcGFyc2VkVVJMLnBhc3N3b3JkKSB7XG4gICAgICAgIHRoaXMuaGVhZGVycy5hdXRob3JpemF0aW9uID0gJ0Jhc2ljICcgKyBoZWxwZXJzLmJ0b2EocGFyc2VkVVJMLnVzZXJuYW1lICsgJzonICsgcGFyc2VkVVJMLnBhc3N3b3JkKTtcbiAgICB9XG4gICAgLy8gV2hlbiBhbGwgbm9kZSBjb3JlIGltcGxlbWVudGF0aW9ucyB0aGF0IGRvIG5vdCBoYXZlIHRoZVxuICAgIC8vIFdIQVRXRyBjb21wYXRpYmxlIFVSTCBwYXJzZXIgZ28gb3V0IG9mIHNlcnZpY2UgdGhpcyBsaW5lIGNhbiBiZSByZW1vdmVkLlxuICAgIGlmIChwYXJzZWRVUkwuYXV0aCkge1xuICAgICAgICB0aGlzLmhlYWRlcnMuYXV0aG9yaXphdGlvbiA9ICdCYXNpYyAnICsgaGVscGVycy5idG9hKHBhcnNlZFVSTC5hdXRoKTtcbiAgICB9XG4gICAgLy8gbWFrZSBwcm9wZXJ0eSBgY29ubmVjdGVkYCB3aGljaCB3aWxsIHJldHVybiB0aGUgY3VycmVudCBjb25uZWN0aW9uIHN0YXR1c1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnY29ubmVjdGVkJywge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbm5lY3Rpb24gJiYgdGhpcy5jb25uZWN0aW9uLnJlYWR5U3RhdGUgPT09IHRoaXMuY29ubmVjdGlvbi5PUEVOO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgdGhpcy5jb25uZWN0KCk7XG59O1xuLy8gSW5oZXJpdCBmcm9tIEV2ZW50RW1pdHRlclxuV2Vic29ja2V0UHJvdmlkZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFdmVudEVtaXR0ZXIucHJvdG90eXBlKTtcbldlYnNvY2tldFByb3ZpZGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFdlYnNvY2tldFByb3ZpZGVyO1xuLyoqXG4gKiBDb25uZWN0cyB0byB0aGUgY29uZmlndXJlZCBub2RlXG4gKlxuICogQG1ldGhvZCBjb25uZWN0XG4gKlxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbldlYnNvY2tldFByb3ZpZGVyLnByb3RvdHlwZS5jb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuY29ubmVjdGlvbiA9IG5ldyBXcyh0aGlzLnVybCwgdGhpcy5wcm90b2NvbCwgdW5kZWZpbmVkLCB0aGlzLmhlYWRlcnMsIHRoaXMucmVxdWVzdE9wdGlvbnMsIHRoaXMuY2xpZW50Q29uZmlnKTtcbiAgICB0aGlzLl9hZGRTb2NrZXRMaXN0ZW5lcnMoKTtcbn07XG4vKipcbiAqIExpc3RlbmVyIGZvciB0aGUgYGRhdGFgIGV2ZW50IG9mIHRoZSB1bmRlcmx5aW5nIFdlYlNvY2tldCBvYmplY3RcbiAqXG4gKiBAbWV0aG9kIF9vbk1lc3NhZ2VcbiAqXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuV2Vic29ja2V0UHJvdmlkZXIucHJvdG90eXBlLl9vbk1lc3NhZ2UgPSBmdW5jdGlvbiAoZSkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgdGhpcy5fcGFyc2VSZXNwb25zZSgodHlwZW9mIGUuZGF0YSA9PT0gJ3N0cmluZycpID8gZS5kYXRhIDogJycpLmZvckVhY2goZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICBpZiAocmVzdWx0Lm1ldGhvZCAmJiByZXN1bHQubWV0aG9kLmluZGV4T2YoJ19zdWJzY3JpcHRpb24nKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIF90aGlzLmVtaXQoX3RoaXMuREFUQSwgcmVzdWx0KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaWQgPSByZXN1bHQuaWQ7XG4gICAgICAgIC8vIGdldCB0aGUgaWQgd2hpY2ggbWF0Y2hlcyB0aGUgcmV0dXJuZWQgaWRcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVzdWx0KSkge1xuICAgICAgICAgICAgaWQgPSByZXN1bHRbMF0uaWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKF90aGlzLnJlc3BvbnNlUXVldWUuaGFzKGlkKSkge1xuICAgICAgICAgICAgaWYgKF90aGlzLnJlc3BvbnNlUXVldWUuZ2V0KGlkKS5jYWxsYmFjayAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMucmVzcG9uc2VRdWV1ZS5nZXQoaWQpLmNhbGxiYWNrKGZhbHNlLCByZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMucmVzcG9uc2VRdWV1ZS5kZWxldGUoaWQpO1xuICAgICAgICB9XG4gICAgfSk7XG59O1xuLyoqXG4gKiBMaXN0ZW5lciBmb3IgdGhlIGBvcGVuYCBldmVudCBvZiB0aGUgdW5kZXJseWluZyBXZWJTb2NrZXQgb2JqZWN0XG4gKlxuICogQG1ldGhvZCBfb25Db25uZWN0XG4gKlxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbldlYnNvY2tldFByb3ZpZGVyLnByb3RvdHlwZS5fb25Db25uZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZW1pdCh0aGlzLkNPTk5FQ1QpO1xuICAgIHRoaXMucmVjb25uZWN0QXR0ZW1wdHMgPSAwO1xuICAgIHRoaXMucmVjb25uZWN0aW5nID0gZmFsc2U7XG4gICAgaWYgKHRoaXMucmVxdWVzdFF1ZXVlLnNpemUgPiAwKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMucmVxdWVzdFF1ZXVlLmZvckVhY2goZnVuY3Rpb24gKHJlcXVlc3QsIGtleSkge1xuICAgICAgICAgICAgX3RoaXMuc2VuZChyZXF1ZXN0LnBheWxvYWQsIHJlcXVlc3QuY2FsbGJhY2spO1xuICAgICAgICAgICAgX3RoaXMucmVxdWVzdFF1ZXVlLmRlbGV0ZShrZXkpO1xuICAgICAgICB9KTtcbiAgICB9XG59O1xuV2Vic29ja2V0UHJvdmlkZXIucHJvdG90eXBlLl9vbkNvbm5lY3RGYWlsZWQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB0aGlzLmNvbm5lY3RGYWlsZWREZXNjcmlwdGlvbiA9IGV2ZW50LnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpWzBdO1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgaWYgKHRoaXMuY29ubmVjdEZhaWxlZERlc2NyaXB0aW9uKSB7XG4gICAgICAgIGV2ZW50LmRlc2NyaXB0aW9uID0gdGhpcy5jb25uZWN0RmFpbGVkRGVzY3JpcHRpb247XG4gICAgICAgIHRoaXMuY29ubmVjdEZhaWxlZERlc2NyaXB0aW9uID0gbnVsbDsgLy8gY2xlYW4gdGhlIG1lc3NhZ2UsIHNvIGl0IHdvbid0IGJlIHVzZWQgaW4gdGhlIG5leHQgY29ubmVjdGlvblxuICAgIH1cbiAgICBldmVudC5jb2RlID0gMTAwNjtcbiAgICBldmVudC5yZWFzb24gPSAnY29ubmVjdGlvbiBmYWlsZWQnO1xuICAgIGlmICh0aGlzLnJlY29ubmVjdE9wdGlvbnMuYXV0byAmJiAoIVsxMDAwLCAxMDAxXS5pbmNsdWRlcyhldmVudC5jb2RlKSB8fCBldmVudC53YXNDbGVhbiA9PT0gZmFsc2UpKSB7XG4gICAgICAgIHRoaXMucmVjb25uZWN0KCk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5lbWl0KHRoaXMuRVJST1IsIGV2ZW50KTtcbiAgICBpZiAodGhpcy5yZXF1ZXN0UXVldWUuc2l6ZSA+IDApIHtcbiAgICAgICAgdGhpcy5yZXF1ZXN0UXVldWUuZm9yRWFjaChmdW5jdGlvbiAocmVxdWVzdCwga2V5KSB7XG4gICAgICAgICAgICByZXF1ZXN0LmNhbGxiYWNrKGVycm9ycy5Db25uZWN0aW9uTm90T3BlbkVycm9yKGV2ZW50KSk7XG4gICAgICAgICAgICBfdGhpcy5yZXF1ZXN0UXVldWUuZGVsZXRlKGtleSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAodGhpcy5yZXNwb25zZVF1ZXVlLnNpemUgPiAwKSB7XG4gICAgICAgIHRoaXMucmVzcG9uc2VRdWV1ZS5mb3JFYWNoKGZ1bmN0aW9uIChyZXF1ZXN0LCBrZXkpIHtcbiAgICAgICAgICAgIHJlcXVlc3QuY2FsbGJhY2soZXJyb3JzLkludmFsaWRDb25uZWN0aW9uKCdvbiBXUycsIGV2ZW50KSk7XG4gICAgICAgICAgICBfdGhpcy5yZXNwb25zZVF1ZXVlLmRlbGV0ZShrZXkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy9jbGVhbiBjb25uZWN0aW9uIG9uIG91ciBvd25cbiAgICBpZiAodGhpcy5jb25uZWN0aW9uLl9jb25uZWN0aW9uKSB7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbi5fY29ubmVjdGlvbi5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICB9XG4gICAgdGhpcy5jb25uZWN0aW9uLl9jbGllbnQucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgdGhpcy5jb25uZWN0aW9uLl9yZWFkeVN0YXRlID0gMzsgLy8gc2V0IHJlYWR5U3RhdGUgdG8gQ0xPU0VEXG4gICAgdGhpcy5lbWl0KHRoaXMuQ0xPU0UsIGV2ZW50KTtcbn07XG4vKipcbiAqIExpc3RlbmVyIGZvciB0aGUgYGNsb3NlYCBldmVudCBvZiB0aGUgdW5kZXJseWluZyBXZWJTb2NrZXQgb2JqZWN0XG4gKlxuICogQG1ldGhvZCBfb25DbG9zZVxuICpcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5XZWJzb2NrZXRQcm92aWRlci5wcm90b3R5cGUuX29uQ2xvc2UgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIGlmICh0aGlzLnJlY29ubmVjdE9wdGlvbnMuYXV0byAmJiAoIVsxMDAwLCAxMDAxXS5pbmNsdWRlcyhldmVudC5jb2RlKSB8fCBldmVudC53YXNDbGVhbiA9PT0gZmFsc2UpKSB7XG4gICAgICAgIHRoaXMucmVjb25uZWN0KCk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5lbWl0KHRoaXMuQ0xPU0UsIGV2ZW50KTtcbiAgICBpZiAodGhpcy5yZXF1ZXN0UXVldWUuc2l6ZSA+IDApIHtcbiAgICAgICAgdGhpcy5yZXF1ZXN0UXVldWUuZm9yRWFjaChmdW5jdGlvbiAocmVxdWVzdCwga2V5KSB7XG4gICAgICAgICAgICByZXF1ZXN0LmNhbGxiYWNrKGVycm9ycy5Db25uZWN0aW9uTm90T3BlbkVycm9yKGV2ZW50KSk7XG4gICAgICAgICAgICBfdGhpcy5yZXF1ZXN0UXVldWUuZGVsZXRlKGtleSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAodGhpcy5yZXNwb25zZVF1ZXVlLnNpemUgPiAwKSB7XG4gICAgICAgIHRoaXMucmVzcG9uc2VRdWV1ZS5mb3JFYWNoKGZ1bmN0aW9uIChyZXF1ZXN0LCBrZXkpIHtcbiAgICAgICAgICAgIHJlcXVlc3QuY2FsbGJhY2soZXJyb3JzLkludmFsaWRDb25uZWN0aW9uKCdvbiBXUycsIGV2ZW50KSk7XG4gICAgICAgICAgICBfdGhpcy5yZXNwb25zZVF1ZXVlLmRlbGV0ZShrZXkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5fcmVtb3ZlU29ja2V0TGlzdGVuZXJzKCk7XG4gICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbn07XG4vKipcbiAqIFdpbGwgYWRkIHRoZSByZXF1aXJlZCBzb2NrZXQgbGlzdGVuZXJzXG4gKlxuICogQG1ldGhvZCBfYWRkU29ja2V0TGlzdGVuZXJzXG4gKlxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbldlYnNvY2tldFByb3ZpZGVyLnByb3RvdHlwZS5fYWRkU29ja2V0TGlzdGVuZXJzID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuY29ubmVjdGlvbi5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgdGhpcy5fb25NZXNzYWdlLmJpbmQodGhpcykpO1xuICAgIHRoaXMuY29ubmVjdGlvbi5hZGRFdmVudExpc3RlbmVyKCdvcGVuJywgdGhpcy5fb25Db25uZWN0LmJpbmQodGhpcykpO1xuICAgIHRoaXMuY29ubmVjdGlvbi5hZGRFdmVudExpc3RlbmVyKCdjbG9zZScsIHRoaXMuX29uQ2xvc2UuYmluZCh0aGlzKSk7XG4gICAgaWYgKHRoaXMuY29ubmVjdGlvbi5fY2xpZW50KSB7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbi5fY2xpZW50LnJlbW92ZUFsbExpc3RlbmVycygnY29ubmVjdEZhaWxlZCcpOyAvL092ZXJyaWRlIHRoZSBpbnRlcm5hbCBsaXN0ZW5lcnMsIHNvIHRoZXkgZG9uJ3QgdHJpZ2dlciBhIGBjbG9zZWAgZXZlbnQuIFdlIHdhbnQgdG8gdHJpZ2dlciBgX29uQ2xvc2VgIG1hbnVhbGx5IHdpdGggYSBkZXNjcmlwdGlvbi5cbiAgICAgICAgdGhpcy5jb25uZWN0aW9uLl9jbGllbnQub24oJ2Nvbm5lY3RGYWlsZWQnLCB0aGlzLl9vbkNvbm5lY3RGYWlsZWQuYmluZCh0aGlzKSk7XG4gICAgfVxufTtcbi8qKlxuICogV2lsbCByZW1vdmUgYWxsIHNvY2tldCBsaXN0ZW5lcnNcbiAqXG4gKiBAbWV0aG9kIF9yZW1vdmVTb2NrZXRMaXN0ZW5lcnNcbiAqXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuV2Vic29ja2V0UHJvdmlkZXIucHJvdG90eXBlLl9yZW1vdmVTb2NrZXRMaXN0ZW5lcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5jb25uZWN0aW9uLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCB0aGlzLl9vbk1lc3NhZ2UpO1xuICAgIHRoaXMuY29ubmVjdGlvbi5yZW1vdmVFdmVudExpc3RlbmVyKCdvcGVuJywgdGhpcy5fb25Db25uZWN0KTtcbiAgICB0aGlzLmNvbm5lY3Rpb24ucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xvc2UnLCB0aGlzLl9vbkNsb3NlKTtcbiAgICBpZiAodGhpcy5jb25uZWN0aW9uLl9jb25uZWN0aW9uKVxuICAgICAgICB0aGlzLmNvbm5lY3Rpb24uX2NsaWVudC5yZW1vdmVMaXN0ZW5lcignY29ubmVjdEZhaWxlZCcsIHRoaXMuX29uQ29ubmVjdEZhaWxlZCk7XG59O1xuLyoqXG4gKiBXaWxsIHBhcnNlIHRoZSByZXNwb25zZSBhbmQgbWFrZSBhbiBhcnJheSBvdXQgb2YgaXQuXG4gKlxuICogQG1ldGhvZCBfcGFyc2VSZXNwb25zZVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhXG4gKlxuICogQHJldHVybnMge0FycmF5fVxuICovXG5XZWJzb2NrZXRQcm92aWRlci5wcm90b3R5cGUuX3BhcnNlUmVzcG9uc2UgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHZhciBfdGhpcyA9IHRoaXMsIHJldHVyblZhbHVlcyA9IFtdO1xuICAgIC8vIERFLUNIVU5LRVJcbiAgICB2YXIgZGVjaHVua2VkRGF0YSA9IGRhdGFcbiAgICAgICAgLnJlcGxhY2UoL1xcfVtcXG5cXHJdP1xcey9nLCAnfXwtLXx7JykgLy8gfXtcbiAgICAgICAgLnJlcGxhY2UoL1xcfVxcXVtcXG5cXHJdP1xcW1xcey9nLCAnfV18LS18W3snKSAvLyB9XVt7XG4gICAgICAgIC5yZXBsYWNlKC9cXH1bXFxuXFxyXT9cXFtcXHsvZywgJ318LS18W3snKSAvLyB9W3tcbiAgICAgICAgLnJlcGxhY2UoL1xcfVxcXVtcXG5cXHJdP1xcey9nLCAnfV18LS18eycpIC8vIH1de1xuICAgICAgICAuc3BsaXQoJ3wtLXwnKTtcbiAgICBkZWNodW5rZWREYXRhLmZvckVhY2goZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgLy8gcHJlcGVuZCB0aGUgbGFzdCBjaHVua1xuICAgICAgICBpZiAoX3RoaXMubGFzdENodW5rKVxuICAgICAgICAgICAgZGF0YSA9IF90aGlzLmxhc3RDaHVuayArIGRhdGE7XG4gICAgICAgIHZhciByZXN1bHQgPSBudWxsO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzdWx0ID0gSlNPTi5wYXJzZShkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgX3RoaXMubGFzdENodW5rID0gZGF0YTtcbiAgICAgICAgICAgIC8vIHN0YXJ0IHRpbWVvdXQgdG8gY2FuY2VsIGFsbCByZXF1ZXN0c1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KF90aGlzLmxhc3RDaHVua1RpbWVvdXQpO1xuICAgICAgICAgICAgX3RoaXMubGFzdENodW5rVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5yZWNvbm5lY3RPcHRpb25zLmF1dG8gJiYgX3RoaXMucmVjb25uZWN0T3B0aW9ucy5vblRpbWVvdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMucmVjb25uZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX3RoaXMuZW1pdChfdGhpcy5FUlJPUiwgZXJyb3JzLkNvbm5lY3Rpb25UaW1lb3V0KF90aGlzLl9jdXN0b21UaW1lb3V0KSk7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLnJlcXVlc3RRdWV1ZS5zaXplID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5yZXF1ZXN0UXVldWUuZm9yRWFjaChmdW5jdGlvbiAocmVxdWVzdCwga2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LmNhbGxiYWNrKGVycm9ycy5Db25uZWN0aW9uVGltZW91dChfdGhpcy5fY3VzdG9tVGltZW91dCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMucmVxdWVzdFF1ZXVlLmRlbGV0ZShrZXkpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBfdGhpcy5fY3VzdG9tVGltZW91dCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gY2FuY2VsIHRpbWVvdXQgYW5kIHNldCBjaHVuayB0byBudWxsXG4gICAgICAgIGNsZWFyVGltZW91dChfdGhpcy5sYXN0Q2h1bmtUaW1lb3V0KTtcbiAgICAgICAgX3RoaXMubGFzdENodW5rID0gbnVsbDtcbiAgICAgICAgaWYgKHJlc3VsdClcbiAgICAgICAgICAgIHJldHVyblZhbHVlcy5wdXNoKHJlc3VsdCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJldHVyblZhbHVlcztcbn07XG4vKipcbiAqIERvZXMgY2hlY2sgaWYgdGhlIHByb3ZpZGVyIGlzIGNvbm5lY3RpbmcgYW5kIHdpbGwgYWRkIGl0IHRvIHRoZSBxdWV1ZSBvciB3aWxsIHNlbmQgaXQgZGlyZWN0bHlcbiAqXG4gKiBAbWV0aG9kIHNlbmRcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGF5bG9hZFxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuV2Vic29ja2V0UHJvdmlkZXIucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbiAocGF5bG9hZCwgY2FsbGJhY2spIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHZhciBpZCA9IHBheWxvYWQuaWQ7XG4gICAgdmFyIHJlcXVlc3QgPSB7IHBheWxvYWQ6IHBheWxvYWQsIGNhbGxiYWNrOiBjYWxsYmFjayB9O1xuICAgIGlmIChBcnJheS5pc0FycmF5KHBheWxvYWQpKSB7XG4gICAgICAgIGlkID0gcGF5bG9hZFswXS5pZDtcbiAgICB9XG4gICAgaWYgKHRoaXMuY29ubmVjdGlvbi5yZWFkeVN0YXRlID09PSB0aGlzLmNvbm5lY3Rpb24uQ09OTkVDVElORyB8fCB0aGlzLnJlY29ubmVjdGluZykge1xuICAgICAgICB0aGlzLnJlcXVlc3RRdWV1ZS5zZXQoaWQsIHJlcXVlc3QpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLmNvbm5lY3Rpb24ucmVhZHlTdGF0ZSAhPT0gdGhpcy5jb25uZWN0aW9uLk9QRU4pIHtcbiAgICAgICAgdGhpcy5yZXF1ZXN0UXVldWUuZGVsZXRlKGlkKTtcbiAgICAgICAgdGhpcy5lbWl0KHRoaXMuRVJST1IsIGVycm9ycy5Db25uZWN0aW9uTm90T3BlbkVycm9yKCkpO1xuICAgICAgICByZXF1ZXN0LmNhbGxiYWNrKGVycm9ycy5Db25uZWN0aW9uTm90T3BlbkVycm9yKCkpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMucmVzcG9uc2VRdWV1ZS5zZXQoaWQsIHJlcXVlc3QpO1xuICAgIHRoaXMucmVxdWVzdFF1ZXVlLmRlbGV0ZShpZCk7XG4gICAgdHJ5IHtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uLnNlbmQoSlNPTi5zdHJpbmdpZnkocmVxdWVzdC5wYXlsb2FkKSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICByZXF1ZXN0LmNhbGxiYWNrKGVycm9yKTtcbiAgICAgICAgX3RoaXMucmVzcG9uc2VRdWV1ZS5kZWxldGUoaWQpO1xuICAgIH1cbn07XG4vKipcbiAqIFJlc2V0cyB0aGUgcHJvdmlkZXJzLCBjbGVhcnMgYWxsIGNhbGxiYWNrc1xuICpcbiAqIEBtZXRob2QgcmVzZXRcbiAqXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuV2Vic29ja2V0UHJvdmlkZXIucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMucmVzcG9uc2VRdWV1ZS5jbGVhcigpO1xuICAgIHRoaXMucmVxdWVzdFF1ZXVlLmNsZWFyKCk7XG4gICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICB0aGlzLl9yZW1vdmVTb2NrZXRMaXN0ZW5lcnMoKTtcbiAgICB0aGlzLl9hZGRTb2NrZXRMaXN0ZW5lcnMoKTtcbn07XG4vKipcbiAqIENsb3NlcyB0aGUgY3VycmVudCBjb25uZWN0aW9uIHdpdGggdGhlIGdpdmVuIGNvZGUgYW5kIHJlYXNvbiBhcmd1bWVudHNcbiAqXG4gKiBAbWV0aG9kIGRpc2Nvbm5lY3RcbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gY29kZVxuICogQHBhcmFtIHtzdHJpbmd9IHJlYXNvblxuICpcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5XZWJzb2NrZXRQcm92aWRlci5wcm90b3R5cGUuZGlzY29ubmVjdCA9IGZ1bmN0aW9uIChjb2RlLCByZWFzb24pIHtcbiAgICB0aGlzLl9yZW1vdmVTb2NrZXRMaXN0ZW5lcnMoKTtcbiAgICB0aGlzLmNvbm5lY3Rpb24uY2xvc2UoY29kZSB8fCAxMDAwLCByZWFzb24pO1xufTtcbi8qKlxuICogUmV0dXJucyB0aGUgZGVzaXJlZCBib29sZWFuLlxuICpcbiAqIEBtZXRob2Qgc3VwcG9ydHNTdWJzY3JpcHRpb25zXG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbldlYnNvY2tldFByb3ZpZGVyLnByb3RvdHlwZS5zdXBwb3J0c1N1YnNjcmlwdGlvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG4gKiBSZW1vdmVzIHRoZSBsaXN0ZW5lcnMgYW5kIHJlY29ubmVjdHMgdG8gdGhlIHNvY2tldC5cbiAqXG4gKiBAbWV0aG9kIHJlY29ubmVjdFxuICpcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5XZWJzb2NrZXRQcm92aWRlci5wcm90b3R5cGUucmVjb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgdGhpcy5yZWNvbm5lY3RpbmcgPSB0cnVlO1xuICAgIGlmICh0aGlzLnJlc3BvbnNlUXVldWUuc2l6ZSA+IDApIHtcbiAgICAgICAgdGhpcy5yZXNwb25zZVF1ZXVlLmZvckVhY2goZnVuY3Rpb24gKHJlcXVlc3QsIGtleSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBfdGhpcy5yZXNwb25zZVF1ZXVlLmRlbGV0ZShrZXkpO1xuICAgICAgICAgICAgICAgIHJlcXVlc3QuY2FsbGJhY2soZXJyb3JzLlBlbmRpbmdSZXF1ZXN0c09uUmVjb25uZWN0aW5nRXJyb3IoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBlbmNvdW50ZXJlZCBpbiByZWNvbm5lY3Q6IFwiLCBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmICghdGhpcy5yZWNvbm5lY3RPcHRpb25zLm1heEF0dGVtcHRzIHx8XG4gICAgICAgIHRoaXMucmVjb25uZWN0QXR0ZW1wdHMgPCB0aGlzLnJlY29ubmVjdE9wdGlvbnMubWF4QXR0ZW1wdHMpIHtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5yZWNvbm5lY3RBdHRlbXB0cysrO1xuICAgICAgICAgICAgX3RoaXMuX3JlbW92ZVNvY2tldExpc3RlbmVycygpO1xuICAgICAgICAgICAgX3RoaXMuZW1pdChfdGhpcy5SRUNPTk5FQ1QsIF90aGlzLnJlY29ubmVjdEF0dGVtcHRzKTtcbiAgICAgICAgICAgIF90aGlzLmNvbm5lY3QoKTtcbiAgICAgICAgfSwgdGhpcy5yZWNvbm5lY3RPcHRpb25zLmRlbGF5KTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmVtaXQodGhpcy5FUlJPUiwgZXJyb3JzLk1heEF0dGVtcHRzUmVhY2hlZE9uUmVjb25uZWN0aW5nRXJyb3IoKSk7XG4gICAgdGhpcy5yZWNvbm5lY3RpbmcgPSBmYWxzZTtcbiAgICBpZiAodGhpcy5yZXF1ZXN0UXVldWUuc2l6ZSA+IDApIHtcbiAgICAgICAgdGhpcy5yZXF1ZXN0UXVldWUuZm9yRWFjaChmdW5jdGlvbiAocmVxdWVzdCwga2V5KSB7XG4gICAgICAgICAgICByZXF1ZXN0LmNhbGxiYWNrKGVycm9ycy5NYXhBdHRlbXB0c1JlYWNoZWRPblJlY29ubmVjdGluZ0Vycm9yKCkpO1xuICAgICAgICAgICAgX3RoaXMucmVxdWVzdFF1ZXVlLmRlbGV0ZShrZXkpO1xuICAgICAgICB9KTtcbiAgICB9XG59O1xubW9kdWxlLmV4cG9ydHMgPSBXZWJzb2NrZXRQcm92aWRlcjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/web3-providers-ws/lib/index.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/web3-providers-ws/node_modules/eventemitter3/index.js":
/*!********************************************************************************!*\
  !*** ../../node_modules/web3-providers-ws/node_modules/eventemitter3/index.js ***!
  \********************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nvar has = Object.prototype.hasOwnProperty\n  , prefix = '~';\n\n/**\n * Constructor to create a storage for our `EE` objects.\n * An `Events` instance is a plain object whose properties are event names.\n *\n * @constructor\n * @private\n */\nfunction Events() {}\n\n//\n// We try to not inherit from `Object.prototype`. In some engines creating an\n// instance in this way is faster than calling `Object.create(null)` directly.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// character to make sure that the built-in object properties are not\n// overridden or used as an attack vector.\n//\nif (Object.create) {\n  Events.prototype = Object.create(null);\n\n  //\n  // This hack is needed because the `__proto__` property is still inherited in\n  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n  //\n  if (!new Events().__proto__) prefix = false;\n}\n\n/**\n * Representation of a single event listener.\n *\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n * @constructor\n * @private\n */\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n\n/**\n * Add a listener for a given event.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} once Specify if the listener is a one-time listener.\n * @returns {EventEmitter}\n * @private\n */\nfunction addListener(emitter, event, fn, context, once) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('The listener must be a function');\n  }\n\n  var listener = new EE(fn, context || emitter, once)\n    , evt = prefix ? prefix + event : event;\n\n  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;\n  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);\n  else emitter._events[evt] = [emitter._events[evt], listener];\n\n  return emitter;\n}\n\n/**\n * Clear event by name.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} evt The Event name.\n * @private\n */\nfunction clearEvent(emitter, evt) {\n  if (--emitter._eventsCount === 0) emitter._events = new Events();\n  else delete emitter._events[evt];\n}\n\n/**\n * Minimal `EventEmitter` interface that is molded against the Node.js\n * `EventEmitter` interface.\n *\n * @constructor\n * @public\n */\nfunction EventEmitter() {\n  this._events = new Events();\n  this._eventsCount = 0;\n}\n\n/**\n * Return an array listing the events for which the emitter has registered\n * listeners.\n *\n * @returns {Array}\n * @public\n */\nEventEmitter.prototype.eventNames = function eventNames() {\n  var names = []\n    , events\n    , name;\n\n  if (this._eventsCount === 0) return names;\n\n  for (name in (events = this._events)) {\n    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n  }\n\n  if (Object.getOwnPropertySymbols) {\n    return names.concat(Object.getOwnPropertySymbols(events));\n  }\n\n  return names;\n};\n\n/**\n * Return the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Array} The registered listeners.\n * @public\n */\nEventEmitter.prototype.listeners = function listeners(event) {\n  var evt = prefix ? prefix + event : event\n    , handlers = this._events[evt];\n\n  if (!handlers) return [];\n  if (handlers.fn) return [handlers.fn];\n\n  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {\n    ee[i] = handlers[i].fn;\n  }\n\n  return ee;\n};\n\n/**\n * Return the number of listeners listening to a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Number} The number of listeners.\n * @public\n */\nEventEmitter.prototype.listenerCount = function listenerCount(event) {\n  var evt = prefix ? prefix + event : event\n    , listeners = this._events[evt];\n\n  if (!listeners) return 0;\n  if (listeners.fn) return 1;\n  return listeners.length;\n};\n\n/**\n * Calls each of the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Boolean} `true` if the event had listeners, else `false`.\n * @public\n */\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return false;\n\n  var listeners = this._events[evt]\n    , len = arguments.length\n    , args\n    , i;\n\n  if (listeners.fn) {\n    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n    switch (len) {\n      case 1: return listeners.fn.call(listeners.context), true;\n      case 2: return listeners.fn.call(listeners.context, a1), true;\n      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len -1); i < len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    listeners.fn.apply(listeners.context, args);\n  } else {\n    var length = listeners.length\n      , j;\n\n    for (i = 0; i < length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n      switch (len) {\n        case 1: listeners[i].fn.call(listeners[i].context); break;\n        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;\n        default:\n          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n            args[j - 1] = arguments[j];\n          }\n\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Add a listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.on = function on(event, fn, context) {\n  return addListener(this, event, fn, context, false);\n};\n\n/**\n * Add a one-time listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.once = function once(event, fn, context) {\n  return addListener(this, event, fn, context, true);\n};\n\n/**\n * Remove the listeners of a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn Only remove the listeners that match this function.\n * @param {*} context Only remove the listeners that have this context.\n * @param {Boolean} once Only remove one-time listeners.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return this;\n  if (!fn) {\n    clearEvent(this, evt);\n    return this;\n  }\n\n  var listeners = this._events[evt];\n\n  if (listeners.fn) {\n    if (\n      listeners.fn === fn &&\n      (!once || listeners.once) &&\n      (!context || listeners.context === context)\n    ) {\n      clearEvent(this, evt);\n    }\n  } else {\n    for (var i = 0, events = [], length = listeners.length; i < length; i++) {\n      if (\n        listeners[i].fn !== fn ||\n        (once && !listeners[i].once) ||\n        (context && listeners[i].context !== context)\n      ) {\n        events.push(listeners[i]);\n      }\n    }\n\n    //\n    // Reset the array, or remove it completely if we have no more listeners.\n    //\n    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;\n    else clearEvent(this, evt);\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners, or those of the specified event.\n *\n * @param {(String|Symbol)} [event] The event name.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  var evt;\n\n  if (event) {\n    evt = prefix ? prefix + event : event;\n    if (this._events[evt]) clearEvent(this, evt);\n  } else {\n    this._events = new Events();\n    this._eventsCount = 0;\n  }\n\n  return this;\n};\n\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// Expose the prefix.\n//\nEventEmitter.prefixed = prefix;\n\n//\n// Allow `EventEmitter` to be imported as module namespace.\n//\nEventEmitter.EventEmitter = EventEmitter;\n\n//\n// Expose the module.\n//\nif (true) {\n  module.exports = EventEmitter;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL3dlYjMtcHJvdmlkZXJzLXdzL25vZGVfbW9kdWxlcy9ldmVudGVtaXR0ZXIzL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixXQUFXLEdBQUc7QUFDZCxXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekIsV0FBVyxpQkFBaUI7QUFDNUIsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsR0FBRztBQUNkLFdBQVcsU0FBUztBQUNwQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsaUJBQWlCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxpQkFBaUI7QUFDNUIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwwREFBMEQsT0FBTztBQUNqRTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxpQkFBaUI7QUFDNUIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxpQkFBaUI7QUFDNUIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQ0FBMEMsU0FBUztBQUNuRDtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUEsZ0JBQWdCLFlBQVk7QUFDNUI7O0FBRUE7QUFDQSw0REFBNEQ7QUFDNUQsZ0VBQWdFO0FBQ2hFLG9FQUFvRTtBQUNwRSx3RUFBd0U7QUFDeEU7QUFDQSwyREFBMkQsU0FBUztBQUNwRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxpQkFBaUI7QUFDNUIsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsR0FBRztBQUNkLGFBQWEsY0FBYztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsaUJBQWlCO0FBQzVCLFdBQVcsVUFBVTtBQUNyQixXQUFXLEdBQUc7QUFDZCxhQUFhLGNBQWM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlCQUFpQjtBQUM1QixXQUFXLFVBQVU7QUFDckIsV0FBVyxHQUFHO0FBQ2QsV0FBVyxTQUFTO0FBQ3BCLGFBQWEsY0FBYztBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osNERBQTRELFlBQVk7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlCQUFpQjtBQUM1QixhQUFhLGNBQWM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSSxJQUE2QjtBQUNqQztBQUNBIiwic291cmNlcyI6WyIvaG9tZS9iYXJiL2FhL0Fzc29jaWF0ZWRBY2NvdW50cy9ub2RlX21vZHVsZXMvd2ViMy1wcm92aWRlcnMtd3Mvbm9kZV9tb2R1bGVzL2V2ZW50ZW1pdHRlcjMvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaGFzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eVxuICAsIHByZWZpeCA9ICd+JztcblxuLyoqXG4gKiBDb25zdHJ1Y3RvciB0byBjcmVhdGUgYSBzdG9yYWdlIGZvciBvdXIgYEVFYCBvYmplY3RzLlxuICogQW4gYEV2ZW50c2AgaW5zdGFuY2UgaXMgYSBwbGFpbiBvYmplY3Qgd2hvc2UgcHJvcGVydGllcyBhcmUgZXZlbnQgbmFtZXMuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBFdmVudHMoKSB7fVxuXG4vL1xuLy8gV2UgdHJ5IHRvIG5vdCBpbmhlcml0IGZyb20gYE9iamVjdC5wcm90b3R5cGVgLiBJbiBzb21lIGVuZ2luZXMgY3JlYXRpbmcgYW5cbi8vIGluc3RhbmNlIGluIHRoaXMgd2F5IGlzIGZhc3RlciB0aGFuIGNhbGxpbmcgYE9iamVjdC5jcmVhdGUobnVsbClgIGRpcmVjdGx5LlxuLy8gSWYgYE9iamVjdC5jcmVhdGUobnVsbClgIGlzIG5vdCBzdXBwb3J0ZWQgd2UgcHJlZml4IHRoZSBldmVudCBuYW1lcyB3aXRoIGFcbi8vIGNoYXJhY3RlciB0byBtYWtlIHN1cmUgdGhhdCB0aGUgYnVpbHQtaW4gb2JqZWN0IHByb3BlcnRpZXMgYXJlIG5vdFxuLy8gb3ZlcnJpZGRlbiBvciB1c2VkIGFzIGFuIGF0dGFjayB2ZWN0b3IuXG4vL1xuaWYgKE9iamVjdC5jcmVhdGUpIHtcbiAgRXZlbnRzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgLy9cbiAgLy8gVGhpcyBoYWNrIGlzIG5lZWRlZCBiZWNhdXNlIHRoZSBgX19wcm90b19fYCBwcm9wZXJ0eSBpcyBzdGlsbCBpbmhlcml0ZWQgaW5cbiAgLy8gc29tZSBvbGQgYnJvd3NlcnMgbGlrZSBBbmRyb2lkIDQsIGlQaG9uZSA1LjEsIE9wZXJhIDExIGFuZCBTYWZhcmkgNS5cbiAgLy9cbiAgaWYgKCFuZXcgRXZlbnRzKCkuX19wcm90b19fKSBwcmVmaXggPSBmYWxzZTtcbn1cblxuLyoqXG4gKiBSZXByZXNlbnRhdGlvbiBvZiBhIHNpbmdsZSBldmVudCBsaXN0ZW5lci5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgbGlzdGVuZXIgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IGNvbnRleHQgVGhlIGNvbnRleHQgdG8gaW52b2tlIHRoZSBsaXN0ZW5lciB3aXRoLlxuICogQHBhcmFtIHtCb29sZWFufSBbb25jZT1mYWxzZV0gU3BlY2lmeSBpZiB0aGUgbGlzdGVuZXIgaXMgYSBvbmUtdGltZSBsaXN0ZW5lci5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gRUUoZm4sIGNvbnRleHQsIG9uY2UpIHtcbiAgdGhpcy5mbiA9IGZuO1xuICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICB0aGlzLm9uY2UgPSBvbmNlIHx8IGZhbHNlO1xufVxuXG4vKipcbiAqIEFkZCBhIGxpc3RlbmVyIGZvciBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7RXZlbnRFbWl0dGVyfSBlbWl0dGVyIFJlZmVyZW5jZSB0byB0aGUgYEV2ZW50RW1pdHRlcmAgaW5zdGFuY2UuXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgbGlzdGVuZXIgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IGNvbnRleHQgVGhlIGNvbnRleHQgdG8gaW52b2tlIHRoZSBsaXN0ZW5lciB3aXRoLlxuICogQHBhcmFtIHtCb29sZWFufSBvbmNlIFNwZWNpZnkgaWYgdGhlIGxpc3RlbmVyIGlzIGEgb25lLXRpbWUgbGlzdGVuZXIuXG4gKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gYWRkTGlzdGVuZXIoZW1pdHRlciwgZXZlbnQsIGZuLCBjb250ZXh0LCBvbmNlKSB7XG4gIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gIH1cblxuICB2YXIgbGlzdGVuZXIgPSBuZXcgRUUoZm4sIGNvbnRleHQgfHwgZW1pdHRlciwgb25jZSlcbiAgICAsIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnQ7XG5cbiAgaWYgKCFlbWl0dGVyLl9ldmVudHNbZXZ0XSkgZW1pdHRlci5fZXZlbnRzW2V2dF0gPSBsaXN0ZW5lciwgZW1pdHRlci5fZXZlbnRzQ291bnQrKztcbiAgZWxzZSBpZiAoIWVtaXR0ZXIuX2V2ZW50c1tldnRdLmZuKSBlbWl0dGVyLl9ldmVudHNbZXZ0XS5wdXNoKGxpc3RlbmVyKTtcbiAgZWxzZSBlbWl0dGVyLl9ldmVudHNbZXZ0XSA9IFtlbWl0dGVyLl9ldmVudHNbZXZ0XSwgbGlzdGVuZXJdO1xuXG4gIHJldHVybiBlbWl0dGVyO1xufVxuXG4vKipcbiAqIENsZWFyIGV2ZW50IGJ5IG5hbWUuXG4gKlxuICogQHBhcmFtIHtFdmVudEVtaXR0ZXJ9IGVtaXR0ZXIgUmVmZXJlbmNlIHRvIHRoZSBgRXZlbnRFbWl0dGVyYCBpbnN0YW5jZS5cbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldnQgVGhlIEV2ZW50IG5hbWUuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjbGVhckV2ZW50KGVtaXR0ZXIsIGV2dCkge1xuICBpZiAoLS1lbWl0dGVyLl9ldmVudHNDb3VudCA9PT0gMCkgZW1pdHRlci5fZXZlbnRzID0gbmV3IEV2ZW50cygpO1xuICBlbHNlIGRlbGV0ZSBlbWl0dGVyLl9ldmVudHNbZXZ0XTtcbn1cblxuLyoqXG4gKiBNaW5pbWFsIGBFdmVudEVtaXR0ZXJgIGludGVyZmFjZSB0aGF0IGlzIG1vbGRlZCBhZ2FpbnN0IHRoZSBOb2RlLmpzXG4gKiBgRXZlbnRFbWl0dGVyYCBpbnRlcmZhY2UuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgdGhpcy5fZXZlbnRzID0gbmV3IEV2ZW50cygpO1xuICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG59XG5cbi8qKlxuICogUmV0dXJuIGFuIGFycmF5IGxpc3RpbmcgdGhlIGV2ZW50cyBmb3Igd2hpY2ggdGhlIGVtaXR0ZXIgaGFzIHJlZ2lzdGVyZWRcbiAqIGxpc3RlbmVycy5cbiAqXG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZXZlbnROYW1lcyA9IGZ1bmN0aW9uIGV2ZW50TmFtZXMoKSB7XG4gIHZhciBuYW1lcyA9IFtdXG4gICAgLCBldmVudHNcbiAgICAsIG5hbWU7XG5cbiAgaWYgKHRoaXMuX2V2ZW50c0NvdW50ID09PSAwKSByZXR1cm4gbmFtZXM7XG5cbiAgZm9yIChuYW1lIGluIChldmVudHMgPSB0aGlzLl9ldmVudHMpKSB7XG4gICAgaWYgKGhhcy5jYWxsKGV2ZW50cywgbmFtZSkpIG5hbWVzLnB1c2gocHJlZml4ID8gbmFtZS5zbGljZSgxKSA6IG5hbWUpO1xuICB9XG5cbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICByZXR1cm4gbmFtZXMuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZXZlbnRzKSk7XG4gIH1cblxuICByZXR1cm4gbmFtZXM7XG59O1xuXG4vKipcbiAqIFJldHVybiB0aGUgbGlzdGVuZXJzIHJlZ2lzdGVyZWQgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHJldHVybnMge0FycmF5fSBUaGUgcmVnaXN0ZXJlZCBsaXN0ZW5lcnMuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24gbGlzdGVuZXJzKGV2ZW50KSB7XG4gIHZhciBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50XG4gICAgLCBoYW5kbGVycyA9IHRoaXMuX2V2ZW50c1tldnRdO1xuXG4gIGlmICghaGFuZGxlcnMpIHJldHVybiBbXTtcbiAgaWYgKGhhbmRsZXJzLmZuKSByZXR1cm4gW2hhbmRsZXJzLmZuXTtcblxuICBmb3IgKHZhciBpID0gMCwgbCA9IGhhbmRsZXJzLmxlbmd0aCwgZWUgPSBuZXcgQXJyYXkobCk7IGkgPCBsOyBpKyspIHtcbiAgICBlZVtpXSA9IGhhbmRsZXJzW2ldLmZuO1xuICB9XG5cbiAgcmV0dXJuIGVlO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gdGhlIG51bWJlciBvZiBsaXN0ZW5lcnMgbGlzdGVuaW5nIHRvIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHJldHVybnMge051bWJlcn0gVGhlIG51bWJlciBvZiBsaXN0ZW5lcnMuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uIGxpc3RlbmVyQ291bnQoZXZlbnQpIHtcbiAgdmFyIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnRcbiAgICAsIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1tldnRdO1xuXG4gIGlmICghbGlzdGVuZXJzKSByZXR1cm4gMDtcbiAgaWYgKGxpc3RlbmVycy5mbikgcmV0dXJuIDE7XG4gIHJldHVybiBsaXN0ZW5lcnMubGVuZ3RoO1xufTtcblxuLyoqXG4gKiBDYWxscyBlYWNoIG9mIHRoZSBsaXN0ZW5lcnMgcmVnaXN0ZXJlZCBmb3IgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gYHRydWVgIGlmIHRoZSBldmVudCBoYWQgbGlzdGVuZXJzLCBlbHNlIGBmYWxzZWAuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIGVtaXQoZXZlbnQsIGExLCBhMiwgYTMsIGE0LCBhNSkge1xuICB2YXIgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudDtcblxuICBpZiAoIXRoaXMuX2V2ZW50c1tldnRdKSByZXR1cm4gZmFsc2U7XG5cbiAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1tldnRdXG4gICAgLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoXG4gICAgLCBhcmdzXG4gICAgLCBpO1xuXG4gIGlmIChsaXN0ZW5lcnMuZm4pIHtcbiAgICBpZiAobGlzdGVuZXJzLm9uY2UpIHRoaXMucmVtb3ZlTGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVycy5mbiwgdW5kZWZpbmVkLCB0cnVlKTtcblxuICAgIHN3aXRjaCAobGVuKSB7XG4gICAgICBjYXNlIDE6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCksIHRydWU7XG4gICAgICBjYXNlIDI6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEpLCB0cnVlO1xuICAgICAgY2FzZSAzOiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExLCBhMiksIHRydWU7XG4gICAgICBjYXNlIDQ6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEsIGEyLCBhMyksIHRydWU7XG4gICAgICBjYXNlIDU6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEsIGEyLCBhMywgYTQpLCB0cnVlO1xuICAgICAgY2FzZSA2OiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExLCBhMiwgYTMsIGE0LCBhNSksIHRydWU7XG4gICAgfVxuXG4gICAgZm9yIChpID0gMSwgYXJncyA9IG5ldyBBcnJheShsZW4gLTEpOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgIH1cblxuICAgIGxpc3RlbmVycy5mbi5hcHBseShsaXN0ZW5lcnMuY29udGV4dCwgYXJncyk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGxlbmd0aCA9IGxpc3RlbmVycy5sZW5ndGhcbiAgICAgICwgajtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGxpc3RlbmVyc1tpXS5vbmNlKSB0aGlzLnJlbW92ZUxpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lcnNbaV0uZm4sIHVuZGVmaW5lZCwgdHJ1ZSk7XG5cbiAgICAgIHN3aXRjaCAobGVuKSB7XG4gICAgICAgIGNhc2UgMTogbGlzdGVuZXJzW2ldLmZuLmNhbGwobGlzdGVuZXJzW2ldLmNvbnRleHQpOyBicmVhaztcbiAgICAgICAgY2FzZSAyOiBsaXN0ZW5lcnNbaV0uZm4uY2FsbChsaXN0ZW5lcnNbaV0uY29udGV4dCwgYTEpOyBicmVhaztcbiAgICAgICAgY2FzZSAzOiBsaXN0ZW5lcnNbaV0uZm4uY2FsbChsaXN0ZW5lcnNbaV0uY29udGV4dCwgYTEsIGEyKTsgYnJlYWs7XG4gICAgICAgIGNhc2UgNDogbGlzdGVuZXJzW2ldLmZuLmNhbGwobGlzdGVuZXJzW2ldLmNvbnRleHQsIGExLCBhMiwgYTMpOyBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBpZiAoIWFyZ3MpIGZvciAoaiA9IDEsIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0xKTsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgICBhcmdzW2ogLSAxXSA9IGFyZ3VtZW50c1tqXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsaXN0ZW5lcnNbaV0uZm4uYXBwbHkobGlzdGVuZXJzW2ldLmNvbnRleHQsIGFyZ3MpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBBZGQgYSBsaXN0ZW5lciBmb3IgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgbGlzdGVuZXIgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IFtjb250ZXh0PXRoaXNdIFRoZSBjb250ZXh0IHRvIGludm9rZSB0aGUgbGlzdGVuZXIgd2l0aC5cbiAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9IGB0aGlzYC5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIG9uKGV2ZW50LCBmbiwgY29udGV4dCkge1xuICByZXR1cm4gYWRkTGlzdGVuZXIodGhpcywgZXZlbnQsIGZuLCBjb250ZXh0LCBmYWxzZSk7XG59O1xuXG4vKipcbiAqIEFkZCBhIG9uZS10aW1lIGxpc3RlbmVyIGZvciBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBsaXN0ZW5lciBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gW2NvbnRleHQ9dGhpc10gVGhlIGNvbnRleHQgdG8gaW52b2tlIHRoZSBsaXN0ZW5lciB3aXRoLlxuICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gYHRoaXNgLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbiBvbmNlKGV2ZW50LCBmbiwgY29udGV4dCkge1xuICByZXR1cm4gYWRkTGlzdGVuZXIodGhpcywgZXZlbnQsIGZuLCBjb250ZXh0LCB0cnVlKTtcbn07XG5cbi8qKlxuICogUmVtb3ZlIHRoZSBsaXN0ZW5lcnMgb2YgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBPbmx5IHJlbW92ZSB0aGUgbGlzdGVuZXJzIHRoYXQgbWF0Y2ggdGhpcyBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gY29udGV4dCBPbmx5IHJlbW92ZSB0aGUgbGlzdGVuZXJzIHRoYXQgaGF2ZSB0aGlzIGNvbnRleHQuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IG9uY2UgT25seSByZW1vdmUgb25lLXRpbWUgbGlzdGVuZXJzLlxuICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gYHRoaXNgLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIoZXZlbnQsIGZuLCBjb250ZXh0LCBvbmNlKSB7XG4gIHZhciBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50O1xuXG4gIGlmICghdGhpcy5fZXZlbnRzW2V2dF0pIHJldHVybiB0aGlzO1xuICBpZiAoIWZuKSB7XG4gICAgY2xlYXJFdmVudCh0aGlzLCBldnQpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1tldnRdO1xuXG4gIGlmIChsaXN0ZW5lcnMuZm4pIHtcbiAgICBpZiAoXG4gICAgICBsaXN0ZW5lcnMuZm4gPT09IGZuICYmXG4gICAgICAoIW9uY2UgfHwgbGlzdGVuZXJzLm9uY2UpICYmXG4gICAgICAoIWNvbnRleHQgfHwgbGlzdGVuZXJzLmNvbnRleHQgPT09IGNvbnRleHQpXG4gICAgKSB7XG4gICAgICBjbGVhckV2ZW50KHRoaXMsIGV2dCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIGkgPSAwLCBldmVudHMgPSBbXSwgbGVuZ3RoID0gbGlzdGVuZXJzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoXG4gICAgICAgIGxpc3RlbmVyc1tpXS5mbiAhPT0gZm4gfHxcbiAgICAgICAgKG9uY2UgJiYgIWxpc3RlbmVyc1tpXS5vbmNlKSB8fFxuICAgICAgICAoY29udGV4dCAmJiBsaXN0ZW5lcnNbaV0uY29udGV4dCAhPT0gY29udGV4dClcbiAgICAgICkge1xuICAgICAgICBldmVudHMucHVzaChsaXN0ZW5lcnNbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vXG4gICAgLy8gUmVzZXQgdGhlIGFycmF5LCBvciByZW1vdmUgaXQgY29tcGxldGVseSBpZiB3ZSBoYXZlIG5vIG1vcmUgbGlzdGVuZXJzLlxuICAgIC8vXG4gICAgaWYgKGV2ZW50cy5sZW5ndGgpIHRoaXMuX2V2ZW50c1tldnRdID0gZXZlbnRzLmxlbmd0aCA9PT0gMSA/IGV2ZW50c1swXSA6IGV2ZW50cztcbiAgICBlbHNlIGNsZWFyRXZlbnQodGhpcywgZXZ0KTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgYWxsIGxpc3RlbmVycywgb3IgdGhvc2Ugb2YgdGhlIHNwZWNpZmllZCBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gW2V2ZW50XSBUaGUgZXZlbnQgbmFtZS5cbiAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9IGB0aGlzYC5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbiByZW1vdmVBbGxMaXN0ZW5lcnMoZXZlbnQpIHtcbiAgdmFyIGV2dDtcblxuICBpZiAoZXZlbnQpIHtcbiAgICBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50O1xuICAgIGlmICh0aGlzLl9ldmVudHNbZXZ0XSkgY2xlYXJFdmVudCh0aGlzLCBldnQpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuX2V2ZW50cyA9IG5ldyBFdmVudHMoKTtcbiAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vXG4vLyBBbGlhcyBtZXRob2RzIG5hbWVzIGJlY2F1c2UgcGVvcGxlIHJvbGwgbGlrZSB0aGF0LlxuLy9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub2ZmID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lcjtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uO1xuXG4vL1xuLy8gRXhwb3NlIHRoZSBwcmVmaXguXG4vL1xuRXZlbnRFbWl0dGVyLnByZWZpeGVkID0gcHJlZml4O1xuXG4vL1xuLy8gQWxsb3cgYEV2ZW50RW1pdHRlcmAgdG8gYmUgaW1wb3J0ZWQgYXMgbW9kdWxlIG5hbWVzcGFjZS5cbi8vXG5FdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuXG4vL1xuLy8gRXhwb3NlIHRoZSBtb2R1bGUuXG4vL1xuaWYgKCd1bmRlZmluZWQnICE9PSB0eXBlb2YgbW9kdWxlKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/web3-providers-ws/node_modules/eventemitter3/index.js\n");

/***/ })

};
;