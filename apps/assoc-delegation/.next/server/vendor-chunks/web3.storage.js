"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/web3.storage";
exports.ids = ["vendor-chunks/web3.storage"];
exports.modules = {

/***/ "(rsc)/../../node_modules/web3.storage/src/lib.js":
/*!**************************************************!*\
  !*** ../../node_modules/web3.storage/src/lib.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Blob: () => (/* reexport safe */ _platform_js__WEBPACK_IMPORTED_MODULE_9__.Blob),\n/* harmony export */   File: () => (/* reexport safe */ _platform_js__WEBPACK_IMPORTED_MODULE_9__.File),\n/* harmony export */   Web3Storage: () => (/* binding */ Web3Storage),\n/* harmony export */   createRateLimiter: () => (/* binding */ createRateLimiter),\n/* harmony export */   filesFromPath: () => (/* reexport safe */ files_from_path__WEBPACK_IMPORTED_MODULE_7__.filesFromPath),\n/* harmony export */   getFilesFromPath: () => (/* reexport safe */ files_from_path__WEBPACK_IMPORTED_MODULE_7__.getFilesFromPath)\n/* harmony export */ });\n/* harmony import */ var streaming_iterables__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! streaming-iterables */ \"(rsc)/../../node_modules/streaming-iterables/dist/index.mjs\");\n/* harmony import */ var p_retry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! p-retry */ \"(rsc)/../../node_modules/p-retry/index.js\");\n/* harmony import */ var ipfs_car_pack__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ipfs-car/pack */ \"(rsc)/../../node_modules/ipfs-car/dist/esm/pack/index.js\");\n/* harmony import */ var _web3_storage_parse_link_header__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @web3-storage/parse-link-header */ \"(rsc)/../../node_modules/@web3-storage/parse-link-header/index.js\");\n/* harmony import */ var ipfs_car_unpack__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ipfs-car/unpack */ \"(rsc)/../../node_modules/ipfs-car/dist/esm/unpack/index.js\");\n/* harmony import */ var carbites_treewalk__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! carbites/treewalk */ \"(rsc)/../../node_modules/carbites/esm/lib/treewalk/index.js\");\n/* harmony import */ var _ipld_car__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @ipld/car */ \"(rsc)/../../node_modules/@ipld/car/esm/car.js\");\n/* harmony import */ var files_from_path__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! files-from-path */ \"(rsc)/../../node_modules/files-from-path/esm/src/index.js\");\n/* harmony import */ var throttled_queue__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! throttled-queue */ \"(rsc)/../../node_modules/throttled-queue/dist/throttledQueue.js\");\n/* harmony import */ var _platform_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./platform.js */ \"(rsc)/../../node_modules/web3.storage/src/platform.js\");\n/**\n * A client library for the https://web3.storage/ service. It provides a convenient\n * interface for working with the [Raw HTTP API](https://web3.storage/#api-docs)\n * from a web browser or [Node.js](https://nodejs.org/) and comes bundled with\n * TS for out-of-the box type inference and better IntelliSense.\n *\n * @example\n * ```js\n * import { Web3Storage, File } from 'web3.storage'\n * const client = new Web3Storage({ token: API_TOKEN })\n *\n * const cid = await client.put([new File(['hello world'], 'hello.txt', { type: 'text/plain' })])\n * ```\n * @module\n */\n\n\n\n\n\n\n\n\n\n\n\nconst MAX_PUT_RETRIES = 5\nconst MAX_CONCURRENT_UPLOADS = 3\nconst DEFAULT_CHUNK_SIZE = 1024 * 1024 * 50 // chunk to ~50MB CARs\nconst MAX_BLOCK_SIZE = 1048576\nconst MAX_CHUNK_SIZE = 104857600\n// These match what is enforced server-side\nconst RATE_LIMIT_REQUESTS = 30\nconst RATE_LIMIT_PERIOD = 10 * 1000\n\n/** @typedef { import('./lib/interface.js').API } API */\n/** @typedef { import('./lib/interface.js').Status} Status */\n/** @typedef { import('./lib/interface.js').Upload} Upload */\n/** @typedef { import('./lib/interface.js').Deal} Deal */\n/** @typedef { import('./lib/interface.js').Pin} Pin */\n/** @typedef { import('./lib/interface.js').Service } Service */\n/** @typedef { import('./lib/interface.js').Web3File} Web3File */\n/** @typedef { import('./lib/interface.js').Filelike } Filelike */\n/** @typedef { import('./lib/interface.js').CIDString} CIDString */\n/** @typedef { import('./lib/interface.js').RequestOptions} RequestOptions */\n/** @typedef { import('./lib/interface.js').PutOptions} PutOptions */\n/** @typedef { import('./lib/interface.js').PutCarOptions} PutCarOptions */\n/** @typedef { import('./lib/interface.js').ListOptions} ListOptions */\n/** @typedef { import('./lib/interface.js').RateLimiter } RateLimiter */\n/** @typedef { import('./lib/interface.js').UnixFSEntry} UnixFSEntry */\n/** @typedef { import('./lib/interface.js').Web3Response} Web3Response */\n\n/**\n * Creates a rate limiter which limits at the same rate as is enforced\n * server-side, to allow the client to avoid exceeding the requests limit and\n * being blocked for 30 seconds.\n * @returns {RateLimiter}\n */\nfunction createRateLimiter () {\n  const throttle = throttled_queue__WEBPACK_IMPORTED_MODULE_8__(RATE_LIMIT_REQUESTS, RATE_LIMIT_PERIOD)\n  return () => throttle(() => {})\n}\n\n/**\n * Rate limiter used by static API if no rate limiter is passed. Note that each\n * instance of the Web3Storage class gets it's own limiter if none is passed.\n * This is because rate limits are enforced per API token.\n */\nconst globalRateLimiter = createRateLimiter()\n\n/**\n * @implements Service\n */\nclass Web3Storage {\n  /**\n   * Constructs a client bound to the given `options.token` and\n   * `options.endpoint`.\n   *\n   * @example\n   * ```js\n   * import { Web3Storage } from 'web3.storage'\n   * const client = new Web3Storage({ token: API_TOKEN })\n   * ```\n   *\n    @param {Service} options\n   */\n  constructor ({\n    token,\n    endpoint = new URL('https://api.web3.storage'),\n    rateLimiter,\n    fetch = _platform_js__WEBPACK_IMPORTED_MODULE_9__.fetch\n  }) {\n    /**\n     * Authorization token.\n     *\n     * @readonly\n     */\n    this.token = token\n    /**\n     * Service API endpoint `URL`.\n     * @readonly\n     */\n    this.endpoint = endpoint\n    /**\n     * @readonly\n     */\n    this.rateLimiter = rateLimiter || createRateLimiter()\n    /**\n     * Optional custom fetch function. Defaults to global fetch in browsers or @web-std/fetch on node.\n     * @readonly\n     */\n    this.fetch = fetch\n  }\n\n  /**\n   * @hidden\n   * @param {string} token\n   * @returns {Record<string, string>}\n   */\n  static headers (token) {\n    if (!token) throw new Error('missing token')\n    return {\n      Authorization: `Bearer ${token}`,\n      'X-Client': 'web3.storage/js'\n    }\n  }\n\n  /**\n   * @param {Service} service\n   * @param {Iterable<Filelike>} files\n   * @param {PutOptions} [options]\n   * @returns {Promise<CIDString>}\n   */\n  static async put ({ endpoint, token, rateLimiter = globalRateLimiter, fetch = _platform_js__WEBPACK_IMPORTED_MODULE_9__.fetch }, files, {\n    onRootCidReady,\n    onStoredChunk,\n    maxRetries = MAX_PUT_RETRIES,\n    maxChunkSize = DEFAULT_CHUNK_SIZE,\n    wrapWithDirectory = true,\n    name,\n    signal\n  } = {}) {\n    if (maxChunkSize >= MAX_CHUNK_SIZE || maxChunkSize < MAX_BLOCK_SIZE) {\n      throw new Error('maximum chunk size must be less than 100MiB and greater than or equal to 1MB')\n    }\n    const blockstore = new _platform_js__WEBPACK_IMPORTED_MODULE_9__.Blockstore()\n    try {\n      const { out, root } = await (0,ipfs_car_pack__WEBPACK_IMPORTED_MODULE_2__.pack)({\n        input: Array.from(files).map(toImportCandidate),\n        blockstore,\n        wrapWithDirectory,\n        maxChunkSize: MAX_BLOCK_SIZE,\n        maxChildrenPerNode: 1024\n      })\n      onRootCidReady && onRootCidReady(root.toString())\n      const car = await _ipld_car__WEBPACK_IMPORTED_MODULE_6__.CarReader.fromIterable(out)\n      return await Web3Storage.putCar({ endpoint, token, rateLimiter, fetch }, car, { onStoredChunk, maxRetries, maxChunkSize, name, signal })\n    } finally {\n      await blockstore.close()\n    }\n  }\n\n  /**\n   * @param {Service} service\n   * @param {import('@ipld/car/api').CarReader} car\n   * @param {PutCarOptions} [options]\n   * @returns {Promise<CIDString>}\n   */\n  static async putCar ({ endpoint, token, rateLimiter = globalRateLimiter, fetch = _platform_js__WEBPACK_IMPORTED_MODULE_9__.fetch }, car, {\n    name,\n    onStoredChunk,\n    maxRetries = MAX_PUT_RETRIES,\n    maxChunkSize = DEFAULT_CHUNK_SIZE,\n    decoders,\n    signal\n  } = {}) {\n    if (maxChunkSize >= MAX_CHUNK_SIZE || maxChunkSize < MAX_BLOCK_SIZE) {\n      throw new Error('maximum chunk size must be less than 100MiB and greater than or equal to 1MB')\n    }\n    const targetSize = maxChunkSize\n    const url = new URL('car', endpoint)\n    const headers = {\n      ...Web3Storage.headers(token),\n      'Content-Type': 'application/vnd.ipld.car',\n      ...(name ? { 'X-Name': encodeURIComponent(name) } : {})\n    }\n\n    const roots = await car.getRoots()\n    if (roots[0] == null) {\n      throw new Error('missing root CID')\n    }\n    if (roots.length > 1) {\n      throw new Error('too many roots')\n    }\n\n    const carRoot = roots[0].toString()\n    const splitter = new carbites_treewalk__WEBPACK_IMPORTED_MODULE_5__.TreewalkCarSplitter(car, targetSize, { decoders })\n\n    /**\n     * @param {AsyncIterable<Uint8Array>} car\n     * @returns {Promise<CIDString>}\n     */\n    const onCarChunk = async car => {\n      const carParts = []\n      for await (const part of car) {\n        carParts.push(part)\n      }\n\n      const carFile = new _platform_js__WEBPACK_IMPORTED_MODULE_9__.Blob(carParts, { type: 'application/vnd.ipld.car' })\n\n      /** @type {Blob|ArrayBuffer} */\n      let body = carFile\n      // FIXME: should not be necessary to await arrayBuffer()!\n      // Node.js 20 hangs reading the stream (it never ends) but in\n      // older node versions and the browser it is fine to pass a blob.\n      /* c8 ignore next 3 */\n      if (parseInt(globalThis.process?.versions?.node) > 18) {\n        body = await body.arrayBuffer()\n      }\n\n      const res = await p_retry__WEBPACK_IMPORTED_MODULE_1__(\n        async () => {\n          await rateLimiter()\n          /** @type {Response} */\n          let response\n          try {\n            response = await fetch(url.toString(), {\n              method: 'POST',\n              headers,\n              body,\n              signal\n            })\n          } catch (/** @type {any} */err) {\n            throw signal && signal.aborted ? new p_retry__WEBPACK_IMPORTED_MODULE_1__.AbortError(err) : err\n          }\n          /* c8 ignore next 3 */\n          if (response.status === 429) {\n            throw new Error('rate limited')\n          }\n          const res = await response.json()\n          if (!response.ok) {\n            throw new Error(res.message)\n          }\n\n          if (res.cid !== carRoot) {\n            throw new Error(`root CID mismatch, expected: ${carRoot}, received: ${res.cid}`)\n          }\n          return res.cid\n        },\n        { retries: maxRetries }\n      )\n\n      onStoredChunk && onStoredChunk(carFile.size)\n      return res\n    }\n\n    const upload = (0,streaming_iterables__WEBPACK_IMPORTED_MODULE_0__.transform)(MAX_CONCURRENT_UPLOADS, onCarChunk)\n    for await (const _ of upload(splitter.cars())) {} // eslint-disable-line\n    return carRoot\n  }\n\n  /**\n   * @param {Service} service\n   * @param {CIDString} cid\n   * @param {RequestOptions} [options]\n   * @returns {Promise<Web3Response | null>}\n   */\n  static async get ({ endpoint, token, rateLimiter = globalRateLimiter, fetch = _platform_js__WEBPACK_IMPORTED_MODULE_9__.fetch }, cid, options = {}) {\n    const url = new URL(`car/${cid}`, endpoint)\n    await rateLimiter()\n    const res = await fetch(url.toString(), {\n      method: 'GET',\n      headers: Web3Storage.headers(token),\n      signal: options.signal\n    })\n    /* c8 ignore next 3 */\n    if (res.status === 429) {\n      throw new Error('rate limited')\n    }\n    return toWeb3Response(res)\n  }\n\n  /**\n   * @param {Service} service\n   * @param {CIDString} cid\n   * @param {RequestOptions} [options]\n   * @returns {Promise<CIDString>}\n   */\n  /* c8 ignore next 4 */\n  static async delete ({ endpoint, token, rateLimiter = globalRateLimiter }, cid, options = {}) {\n    console.log('Not deleting', cid, endpoint, token, rateLimiter, options)\n    throw Error('.delete not implemented yet')\n  }\n\n  /**\n   * @param {Service} service\n   * @param {CIDString} cid\n   * @param {RequestOptions} [options]\n   * @returns {Promise<Status | undefined>}\n   */\n  static async status ({ endpoint, token, rateLimiter = globalRateLimiter, fetch = _platform_js__WEBPACK_IMPORTED_MODULE_9__.fetch }, cid, options = {}) {\n    const url = new URL(`status/${cid}`, endpoint)\n    await rateLimiter()\n    const res = await fetch(url.toString(), {\n      method: 'GET',\n      headers: Web3Storage.headers(token),\n      signal: options.signal\n    })\n    /* c8 ignore next 3 */\n    if (res.status === 429) {\n      throw new Error('rate limited')\n    }\n    if (res.status === 404) {\n      return undefined\n    }\n    if (!res.ok) {\n      throw new Error(res.statusText)\n    }\n    return res.json()\n  }\n\n  /**\n   * @param {Service} service\n   * @param {ListOptions} [opts]\n   * @returns {AsyncIterable<Upload>}\n   */\n  static async * list (service, { before = new Date().toISOString(), maxResults = Infinity, signal } = {}) {\n    /**\n     * @param {Service} service\n     * @param {{before: string, size: number}} opts\n     * @returns {Promise<Response>}\n     */\n    async function listPage ({ endpoint, token, rateLimiter = globalRateLimiter, fetch = _platform_js__WEBPACK_IMPORTED_MODULE_9__.fetch }, { before, size }) {\n      const search = new URLSearchParams({ before, size: size.toString() })\n      const url = new URL(`user/uploads?${search}`, endpoint)\n      await rateLimiter()\n      return fetch(url.toString(), {\n        method: 'GET',\n        headers: {\n          ...Web3Storage.headers(token),\n          'Access-Control-Request-Headers': 'Link'\n        },\n        signal\n      })\n    }\n    let count = 0\n    const size = maxResults > 100 ? 100 : maxResults\n    for await (const res of paginator(listPage, service, { before, size })) {\n      if (!res.ok) {\n        /* c8 ignore next 3 */\n        if (res.status === 429) {\n          throw new Error('rate limited')\n        }\n\n        /* c8 ignore next 2 */\n        const errorMessage = await res.json()\n        throw new Error(`${res.status} ${res.statusText} ${errorMessage ? '- ' + errorMessage.message : ''}`)\n      }\n      const page = await res.json()\n      for (const upload of page) {\n        if (++count > maxResults) {\n          return\n        }\n        yield upload\n      }\n    }\n  }\n\n  // Just a sugar so you don't have to pass around endpoint and token around.\n\n  /**\n   * Uploads files to web3.storage. Files are hashed in the client and uploaded as a single\n   * [Content Addressed Archive(CAR)](https://github.com/ipld/specs/blob/master/block-layer/content-addressable-archives.md).\n   * Takes a [Blob](https://developer.mozilla.org/en-US/docs/Web/API/Blob/Blob)\n   *\n   * Returns the corresponding Content Identifier (CID).\n   *\n   * @example\n   * ```js\n   * const file = new File(['hello world'], 'hello.txt', { type: 'text/plain' })\n   * const cid = await client.put([file])\n   * ```\n   * @param {Iterable<Filelike>} files\n   * @param {PutOptions} [options]\n   */\n  put (files, options) {\n    return Web3Storage.put(this, files, options)\n  }\n\n  /**\n   * Uploads a CAR ([Content Addressed Archive](https://github.com/ipld/specs/blob/master/block-layer/content-addressable-archives.md)) file to web3.storage.\n   * Takes a CarReader interface from @ipld/car\n   *\n   * Returns the corresponding Content Identifier (CID).\n   *\n   * @example\n   * ```js\n   * import fs from 'fs'\n   * import { Readable } from 'stream'\n   * import { CarReader, CarWriter } from '@ipld/car'\n   * import * as raw from 'multiformats/codecs/raw'\n   * import { CID } from 'multiformats/cid'\n   * import { sha256 } from 'multiformats/hashes/sha2'\n   *\n   * async function getCar() {\n   *    const bytes = new TextEncoder().encode('random meaningless bytes')\n   *    const hash = await sha256.digest(raw.encode(bytes))\n   *    const cid = CID.create(1, raw.code, hash)\n   *\n   *    // create the writer and set the header with a single root\n   *    const { writer, out } = await CarWriter.create([cid])\n   *    Readable.from(out).pipe(fs.createWriteStream('example.car'))\n\n   *    // store a new block, creates a new file entry in the CAR archive\n   *    await writer.put({ cid, bytes })\n   *    await writer.close()\n\n   *    const inStream = fs.createReadStream('example.car')\n   *    // read and parse the entire stream in one go, this will cache the contents of\n   *    // the car in memory so is not suitable for large files.\n   *    const reader = await CarReader.fromIterable(inStream)\n   *    return reader\n   * }\n   *\n   * const car = await getCar()\n   * const cid = await client.putCar(car)\n   * ```\n   * @param {import('@ipld/car/api').CarReader} car\n   * @param {PutCarOptions} [options]\n   */\n  putCar (car, options) {\n    return Web3Storage.putCar(this, car, options)\n  }\n\n  /**\n   * Fetch the Content Addressed Archive by its root CID.\n   * @param {CIDString} cid\n   * @param {RequestOptions} [options]\n   */\n  get (cid, options) {\n    return Web3Storage.get(this, cid, options)\n  }\n\n  /**\n   * @param {CIDString} cid\n   * @param {RequestOptions} [options]\n   */\n  /* c8 ignore next 3 */\n  delete (cid, options) {\n    return Web3Storage.delete(this, cid, options)\n  }\n\n  /**\n   * Fetch info on Filecoin deals and IPFS pins that a given CID is replicated in.\n   * @param {CIDString} cid\n   * @param {RequestOptions} [options]\n   */\n  status (cid, options) {\n    return Web3Storage.status(this, cid, options)\n  }\n\n  /**\n   * Find all uploads for this account. Use a `for await...of` loop to fetch them all.\n   * @example\n   * Fetch all the uploads\n   * ```js\n   * const uploads = []\n   * for await (const item of client.list()) {\n   *    uploads.push(item)\n   * }\n   * ```\n   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for-await...of\n   * @param {ListOptions} [opts]\n   * @returns {AsyncIterable<Upload>}\n   */\n  list (opts) {\n    return Web3Storage.list(this, opts)\n  }\n}\n\n/**\n * Map a UnixFSEntry to a File with a cid property.\n *\n * @param {UnixFSEntry} entry\n * @returns {Promise<Web3File>}\n */\nasync function toWeb3File ({ content, path, cid }) {\n  const chunks = []\n  for await (const chunk of content()) {\n    chunks.push(chunk)\n  }\n  const file = new _platform_js__WEBPACK_IMPORTED_MODULE_9__.File(chunks, toFilenameWithPath(path))\n  return Object.assign(file, { cid: cid.toString() })\n}\n\n/**\n * Trim the root cid from the path if there is anyting after it.\n * bafy...ic2q/path/to/pinpie.jpg => path/to/pinpie.jpg\n *         bafy...ic2q/pinpie.jpg => pinpie.jpg\n *                    bafk...52zy => bafk...52zy\n * @param {string} unixFsPath\n * @returns {string}\n */\nfunction toFilenameWithPath (unixFsPath) {\n  const slashIndex = unixFsPath.indexOf('/')\n  return slashIndex === -1 ? unixFsPath : unixFsPath.substring(slashIndex + 1)\n}\n\n/**\n * Add car unpacking smarts to the response object,\n * @param {Response} res\n * @returns {Web3Response}\n */\nfunction toWeb3Response (res) {\n  const response = Object.assign(res, {\n    unixFsIterator: async function * () {\n      if (!res.ok) {\n        throw new Error(`Response was not ok: ${res.status} ${res.statusText} - Check for { \"ok\": false } on the Response object before calling .unixFsIterator`)\n      }\n      /* c8 ignore next 3 */\n      if (!res.body) {\n        throw new Error('No body on response')\n      }\n      const blockstore = new _platform_js__WEBPACK_IMPORTED_MODULE_9__.Blockstore()\n      try {\n        for await (const entry of (0,ipfs_car_unpack__WEBPACK_IMPORTED_MODULE_4__.unpackStream)(res.body, { blockstore })) {\n          yield entry\n        }\n      } finally {\n        await blockstore.close()\n      }\n    },\n    files: async () => {\n      if (!res.ok) {\n        throw new Error(`Response was not ok: ${res.status} ${res.statusText} - Check for { \"ok\": false } on the Response object before calling .files`)\n      }\n      const files = []\n      // @ts-ignore we're using the enriched response here\n      for await (const entry of response.unixFsIterator()) {\n        if (entry.type === 'directory') {\n          continue\n        }\n        const file = await toWeb3File(entry)\n        files.push(file)\n      }\n      return files\n    }\n  })\n  return response\n}\n\n/**\n * Convert the passed file to an \"import candidate\" - an object suitable for\n * passing to the ipfs-unixfs-importer. Note: content is an accessor so that\n * the stream is only created when needed.\n *\n * @param {Filelike} file\n */\nfunction toImportCandidate (file) {\n  /** @type {ReadableStream} */\n  let stream\n  return {\n    path: file.name,\n    get content () {\n      stream = stream || file.stream()\n      return stream\n    }\n  }\n}\n\n/**\n * Follow Link headers on a Response, to fetch all the things.\n *\n * @param {(service: Service, opts: any) => Promise<Response>} fn\n * @param {Service} service\n * @param {{}} opts\n */\nasync function * paginator (fn, service, opts) {\n  let res = await fn(service, opts)\n  yield res\n  let link = (0,_web3_storage_parse_link_header__WEBPACK_IMPORTED_MODULE_3__.parseLinkHeader)(res.headers.get('Link') || '')\n  // @ts-ignore\n  while (link && link.next) {\n    // @ts-ignore\n    res = await fn(service, link.next)\n    yield res\n    link = (0,_web3_storage_parse_link_header__WEBPACK_IMPORTED_MODULE_3__.parseLinkHeader)(res.headers.get('Link') || '')\n  }\n}\n\n\n\n/**\n * Just to verify API compatibility.\n * TODO: convert lib to a regular class that can be type checked.\n * @type {API}\n */\nconst api = Web3Storage\nvoid api // eslint-disable-line no-void\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL3dlYjMuc3RvcmFnZS9zcmMvbGliLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxvQkFBb0I7QUFDaEMsb0NBQW9DLGtCQUFrQjtBQUN0RDtBQUNBLDBFQUEwRSxvQkFBb0I7QUFDOUY7QUFDQTtBQUNBO0FBQytDO0FBQ0g7QUFDUjtBQUM2QjtBQUNuQjtBQUNTO0FBQ2xCO0FBQzRCO0FBQ3JCO0FBTXRCOztBQUV0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWUsbUNBQW1DO0FBQ2xELGVBQWUscUNBQXFDO0FBQ3BELGVBQWUscUNBQXFDO0FBQ3BELGVBQWUsbUNBQW1DO0FBQ2xELGVBQWUsa0NBQWtDO0FBQ2pELGVBQWUsdUNBQXVDO0FBQ3RELGVBQWUsdUNBQXVDO0FBQ3RELGVBQWUsd0NBQXdDO0FBQ3ZELGVBQWUsd0NBQXdDO0FBQ3ZELGVBQWUsNkNBQTZDO0FBQzVELGVBQWUseUNBQXlDO0FBQ3hELGVBQWUsNENBQTRDO0FBQzNELGVBQWUsMENBQTBDO0FBQ3pELGVBQWUsMkNBQTJDO0FBQzFELGVBQWUsMENBQTBDO0FBQ3pELGVBQWUsMkNBQTJDOztBQUUxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNPO0FBQ1AsbUJBQW1CLDRDQUFjO0FBQ2pDLGdDQUFnQztBQUNoQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGNBQWM7QUFDNUIsc0NBQXNDLGtCQUFrQjtBQUN4RDtBQUNBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLCtDQUFNO0FBQ2xCLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFD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LGdCQUFnQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxvREFBb0Q7QUFDL0QsV0FBVyxTQUFTO0FBQ3BCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZ0ZBQWU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZ0ZBQWU7QUFDMUI7QUFDQTs7QUFFbUU7O0FBRW5FO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL2JhcmIvYWEvQXNzb2NpYXRlZEFjY291bnRzL25vZGVfbW9kdWxlcy93ZWIzLnN0b3JhZ2Uvc3JjL2xpYi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEEgY2xpZW50IGxpYnJhcnkgZm9yIHRoZSBodHRwczovL3dlYjMuc3RvcmFnZS8gc2VydmljZS4gSXQgcHJvdmlkZXMgYSBjb252ZW5pZW50XG4gKiBpbnRlcmZhY2UgZm9yIHdvcmtpbmcgd2l0aCB0aGUgW1JhdyBIVFRQIEFQSV0oaHR0cHM6Ly93ZWIzLnN0b3JhZ2UvI2FwaS1kb2NzKVxuICogZnJvbSBhIHdlYiBicm93c2VyIG9yIFtOb2RlLmpzXShodHRwczovL25vZGVqcy5vcmcvKSBhbmQgY29tZXMgYnVuZGxlZCB3aXRoXG4gKiBUUyBmb3Igb3V0LW9mLXRoZSBib3ggdHlwZSBpbmZlcmVuY2UgYW5kIGJldHRlciBJbnRlbGxpU2Vuc2UuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGpzXG4gKiBpbXBvcnQgeyBXZWIzU3RvcmFnZSwgRmlsZSB9IGZyb20gJ3dlYjMuc3RvcmFnZSdcbiAqIGNvbnN0IGNsaWVudCA9IG5ldyBXZWIzU3RvcmFnZSh7IHRva2VuOiBBUElfVE9LRU4gfSlcbiAqXG4gKiBjb25zdCBjaWQgPSBhd2FpdCBjbGllbnQucHV0KFtuZXcgRmlsZShbJ2hlbGxvIHdvcmxkJ10sICdoZWxsby50eHQnLCB7IHR5cGU6ICd0ZXh0L3BsYWluJyB9KV0pXG4gKiBgYGBcbiAqIEBtb2R1bGVcbiAqL1xuaW1wb3J0IHsgdHJhbnNmb3JtIH0gZnJvbSAnc3RyZWFtaW5nLWl0ZXJhYmxlcydcbmltcG9ydCBwUmV0cnksIHsgQWJvcnRFcnJvciB9IGZyb20gJ3AtcmV0cnknXG5pbXBvcnQgeyBwYWNrIH0gZnJvbSAnaXBmcy1jYXIvcGFjaydcbmltcG9ydCB7IHBhcnNlTGlua0hlYWRlciB9IGZyb20gJ0B3ZWIzLXN0b3JhZ2UvcGFyc2UtbGluay1oZWFkZXInXG5pbXBvcnQgeyB1bnBhY2tTdHJlYW0gfSBmcm9tICdpcGZzLWNhci91bnBhY2snXG5pbXBvcnQgeyBUcmVld2Fsa0NhclNwbGl0dGVyIH0gZnJvbSAnY2FyYml0ZXMvdHJlZXdhbGsnXG5pbXBvcnQgeyBDYXJSZWFkZXIgfSBmcm9tICdAaXBsZC9jYXInXG5pbXBvcnQgeyBmaWxlc0Zyb21QYXRoLCBnZXRGaWxlc0Zyb21QYXRoIH0gZnJvbSAnZmlsZXMtZnJvbS1wYXRoJ1xuaW1wb3J0IHRocm90dGxlZFF1ZXVlIGZyb20gJ3Rocm90dGxlZC1xdWV1ZSdcbmltcG9ydCB7XG4gIGZldGNoIGFzIF9mZXRjaCxcbiAgRmlsZSxcbiAgQmxvYixcbiAgQmxvY2tzdG9yZVxufSBmcm9tICcuL3BsYXRmb3JtLmpzJ1xuXG5jb25zdCBNQVhfUFVUX1JFVFJJRVMgPSA1XG5jb25zdCBNQVhfQ09OQ1VSUkVOVF9VUExPQURTID0gM1xuY29uc3QgREVGQVVMVF9DSFVOS19TSVpFID0gMTAyNCAqIDEwMjQgKiA1MCAvLyBjaHVuayB0byB+NTBNQiBDQVJzXG5jb25zdCBNQVhfQkxPQ0tfU0laRSA9IDEwNDg1NzZcbmNvbnN0IE1BWF9DSFVOS19TSVpFID0gMTA0ODU3NjAwXG4vLyBUaGVzZSBtYXRjaCB3aGF0IGlzIGVuZm9yY2VkIHNlcnZlci1zaWRlXG5jb25zdCBSQVRFX0xJTUlUX1JFUVVFU1RTID0gMzBcbmNvbnN0IFJBVEVfTElNSVRfUEVSSU9EID0gMTAgKiAxMDAwXG5cbi8qKiBAdHlwZWRlZiB7IGltcG9ydCgnLi9saWIvaW50ZXJmYWNlLmpzJykuQVBJIH0gQVBJICovXG4vKiogQHR5cGVkZWYgeyBpbXBvcnQoJy4vbGliL2ludGVyZmFjZS5qcycpLlN0YXR1c30gU3RhdHVzICovXG4vKiogQHR5cGVkZWYgeyBpbXBvcnQoJy4vbGliL2ludGVyZmFjZS5qcycpLlVwbG9hZH0gVXBsb2FkICovXG4vKiogQHR5cGVkZWYgeyBpbXBvcnQoJy4vbGliL2ludGVyZmFjZS5qcycpLkRlYWx9IERlYWwgKi9cbi8qKiBAdHlwZWRlZiB7IGltcG9ydCgnLi9saWIvaW50ZXJmYWNlLmpzJykuUGlufSBQaW4gKi9cbi8qKiBAdHlwZWRlZiB7IGltcG9ydCgnLi9saWIvaW50ZXJmYWNlLmpzJykuU2VydmljZSB9IFNlcnZpY2UgKi9cbi8qKiBAdHlwZWRlZiB7IGltcG9ydCgnLi9saWIvaW50ZXJmYWNlLmpzJykuV2ViM0ZpbGV9IFdlYjNGaWxlICovXG4vKiogQHR5cGVkZWYgeyBpbXBvcnQoJy4vbGliL2ludGVyZmFjZS5qcycpLkZpbGVsaWtlIH0gRmlsZWxpa2UgKi9cbi8qKiBAdHlwZWRlZiB7IGltcG9ydCgnLi9saWIvaW50ZXJmYWNlLmpzJykuQ0lEU3RyaW5nfSBDSURTdHJpbmcgKi9cbi8qKiBAdHlwZWRlZiB7IGltcG9ydCgnLi9saWIvaW50ZXJmYWNlLmpzJykuUmVxdWVzdE9wdGlvbnN9IFJlcXVlc3RPcHRpb25zICovXG4vKiogQHR5cGVkZWYgeyBpbXBvcnQoJy4vbGliL2ludGVyZmFjZS5qcycpLlB1dE9wdGlvbnN9IFB1dE9wdGlvbnMgKi9cbi8qKiBAdHlwZWRlZiB7IGltcG9ydCgnLi9saWIvaW50ZXJmYWNlLmpzJykuUHV0Q2FyT3B0aW9uc30gUHV0Q2FyT3B0aW9ucyAqL1xuLyoqIEB0eXBlZGVmIHsgaW1wb3J0KCcuL2xpYi9pbnRlcmZhY2UuanMnKS5MaXN0T3B0aW9uc30gTGlzdE9wdGlvbnMgKi9cbi8qKiBAdHlwZWRlZiB7IGltcG9ydCgnLi9saWIvaW50ZXJmYWNlLmpzJykuUmF0ZUxpbWl0ZXIgfSBSYXRlTGltaXRlciAqL1xuLyoqIEB0eXBlZGVmIHsgaW1wb3J0KCcuL2xpYi9pbnRlcmZhY2UuanMnKS5Vbml4RlNFbnRyeX0gVW5peEZTRW50cnkgKi9cbi8qKiBAdHlwZWRlZiB7IGltcG9ydCgnLi9saWIvaW50ZXJmYWNlLmpzJykuV2ViM1Jlc3BvbnNlfSBXZWIzUmVzcG9uc2UgKi9cblxuLyoqXG4gKiBDcmVhdGVzIGEgcmF0ZSBsaW1pdGVyIHdoaWNoIGxpbWl0cyBhdCB0aGUgc2FtZSByYXRlIGFzIGlzIGVuZm9yY2VkXG4gKiBzZXJ2ZXItc2lkZSwgdG8gYWxsb3cgdGhlIGNsaWVudCB0byBhdm9pZCBleGNlZWRpbmcgdGhlIHJlcXVlc3RzIGxpbWl0IGFuZFxuICogYmVpbmcgYmxvY2tlZCBmb3IgMzAgc2Vjb25kcy5cbiAqIEByZXR1cm5zIHtSYXRlTGltaXRlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVJhdGVMaW1pdGVyICgpIHtcbiAgY29uc3QgdGhyb3R0bGUgPSB0aHJvdHRsZWRRdWV1ZShSQVRFX0xJTUlUX1JFUVVFU1RTLCBSQVRFX0xJTUlUX1BFUklPRClcbiAgcmV0dXJuICgpID0+IHRocm90dGxlKCgpID0+IHt9KVxufVxuXG4vKipcbiAqIFJhdGUgbGltaXRlciB1c2VkIGJ5IHN0YXRpYyBBUEkgaWYgbm8gcmF0ZSBsaW1pdGVyIGlzIHBhc3NlZC4gTm90ZSB0aGF0IGVhY2hcbiAqIGluc3RhbmNlIG9mIHRoZSBXZWIzU3RvcmFnZSBjbGFzcyBnZXRzIGl0J3Mgb3duIGxpbWl0ZXIgaWYgbm9uZSBpcyBwYXNzZWQuXG4gKiBUaGlzIGlzIGJlY2F1c2UgcmF0ZSBsaW1pdHMgYXJlIGVuZm9yY2VkIHBlciBBUEkgdG9rZW4uXG4gKi9cbmNvbnN0IGdsb2JhbFJhdGVMaW1pdGVyID0gY3JlYXRlUmF0ZUxpbWl0ZXIoKVxuXG4vKipcbiAqIEBpbXBsZW1lbnRzIFNlcnZpY2VcbiAqL1xuY2xhc3MgV2ViM1N0b3JhZ2Uge1xuICAvKipcbiAgICogQ29uc3RydWN0cyBhIGNsaWVudCBib3VuZCB0byB0aGUgZ2l2ZW4gYG9wdGlvbnMudG9rZW5gIGFuZFxuICAgKiBgb3B0aW9ucy5lbmRwb2ludGAuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGpzXG4gICAqIGltcG9ydCB7IFdlYjNTdG9yYWdlIH0gZnJvbSAnd2ViMy5zdG9yYWdlJ1xuICAgKiBjb25zdCBjbGllbnQgPSBuZXcgV2ViM1N0b3JhZ2UoeyB0b2tlbjogQVBJX1RPS0VOIH0pXG4gICAqIGBgYFxuICAgKlxuICAgIEBwYXJhbSB7U2VydmljZX0gb3B0aW9uc1xuICAgKi9cbiAgY29uc3RydWN0b3IgKHtcbiAgICB0b2tlbixcbiAgICBlbmRwb2ludCA9IG5ldyBVUkwoJ2h0dHBzOi8vYXBpLndlYjMuc3RvcmFnZScpLFxuICAgIHJhdGVMaW1pdGVyLFxuICAgIGZldGNoID0gX2ZldGNoXG4gIH0pIHtcbiAgICAvKipcbiAgICAgKiBBdXRob3JpemF0aW9uIHRva2VuLlxuICAgICAqXG4gICAgICogQHJlYWRvbmx5XG4gICAgICovXG4gICAgdGhpcy50b2tlbiA9IHRva2VuXG4gICAgLyoqXG4gICAgICogU2VydmljZSBBUEkgZW5kcG9pbnQgYFVSTGAuXG4gICAgICogQHJlYWRvbmx5XG4gICAgICovXG4gICAgdGhpcy5lbmRwb2ludCA9IGVuZHBvaW50XG4gICAgLyoqXG4gICAgICogQHJlYWRvbmx5XG4gICAgICovXG4gICAgdGhpcy5yYXRlTGltaXRlciA9IHJhdGVMaW1pdGVyIHx8IGNyZWF0ZVJhdGVMaW1pdGVyKClcbiAgICAvKipcbiAgICAgKiBPcHRpb25hbCBjdXN0b20gZmV0Y2ggZnVuY3Rpb24uIERlZmF1bHRzIHRvIGdsb2JhbCBmZXRjaCBpbiBicm93c2VycyBvciBAd2ViLXN0ZC9mZXRjaCBvbiBub2RlLlxuICAgICAqIEByZWFkb25seVxuICAgICAqL1xuICAgIHRoaXMuZmV0Y2ggPSBmZXRjaFxuICB9XG5cbiAgLyoqXG4gICAqIEBoaWRkZW5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHRva2VuXG4gICAqIEByZXR1cm5zIHtSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+fVxuICAgKi9cbiAgc3RhdGljIGhlYWRlcnMgKHRva2VuKSB7XG4gICAgaWYgKCF0b2tlbikgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIHRva2VuJylcbiAgICByZXR1cm4ge1xuICAgICAgQXV0aG9yaXphdGlvbjogYEJlYXJlciAke3Rva2VufWAsXG4gICAgICAnWC1DbGllbnQnOiAnd2ViMy5zdG9yYWdlL2pzJ1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1NlcnZpY2V9IHNlcnZpY2VcbiAgICogQHBhcmFtIHtJdGVyYWJsZTxGaWxlbGlrZT59IGZpbGVzXG4gICAqIEBwYXJhbSB7UHV0T3B0aW9uc30gW29wdGlvbnNdXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPENJRFN0cmluZz59XG4gICAqL1xuICBzdGF0aWMgYXN5bmMgcHV0ICh7IGVuZHBvaW50LCB0b2tlbiwgcmF0ZUxpbWl0ZXIgPSBnbG9iYWxSYXRlTGltaXRlciwgZmV0Y2ggPSBfZmV0Y2ggfSwgZmlsZXMsIHtcbiAgICBvblJvb3RDaWRSZWFkeSxcbiAgICBvblN0b3JlZENodW5rLFxuICAgIG1heFJldHJpZXMgPSBNQVhfUFVUX1JFVFJJRVMsXG4gICAgbWF4Q2h1bmtTaXplID0gREVGQVVMVF9DSFVOS19TSVpFLFxuICAgIHdyYXBXaXRoRGlyZWN0b3J5ID0gdHJ1ZSxcbiAgICBuYW1lLFxuICAgIHNpZ25hbFxuICB9ID0ge30pIHtcbiAgICBpZiAobWF4Q2h1bmtTaXplID49IE1BWF9DSFVOS19TSVpFIHx8IG1heENodW5rU2l6ZSA8IE1BWF9CTE9DS19TSVpFKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ21heGltdW0gY2h1bmsgc2l6ZSBtdXN0IGJlIGxlc3MgdGhhbiAxMDBNaUIgYW5kIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAxTUInKVxuICAgIH1cbiAgICBjb25zdCBibG9ja3N0b3JlID0gbmV3IEJsb2Nrc3RvcmUoKVxuICAgIHRyeSB7XG4gICAgICBjb25zdCB7IG91dCwgcm9vdCB9ID0gYXdhaXQgcGFjayh7XG4gICAgICAgIGlucHV0OiBBcnJheS5mcm9tKGZpbGVzKS5tYXAodG9JbXBvcnRDYW5kaWRhdGUpLFxuICAgICAgICBibG9ja3N0b3JlLFxuICAgICAgICB3cmFwV2l0aERpcmVjdG9yeSxcbiAgICAgICAgbWF4Q2h1bmtTaXplOiBNQVhfQkxPQ0tfU0laRSxcbiAgICAgICAgbWF4Q2hpbGRyZW5QZXJOb2RlOiAxMDI0XG4gICAgICB9KVxuICAgICAgb25Sb290Q2lkUmVhZHkgJiYgb25Sb290Q2lkUmVhZHkocm9vdC50b1N0cmluZygpKVxuICAgICAgY29uc3QgY2FyID0gYXdhaXQgQ2FyUmVhZGVyLmZyb21JdGVyYWJsZShvdXQpXG4gICAgICByZXR1cm4gYXdhaXQgV2ViM1N0b3JhZ2UucHV0Q2FyKHsgZW5kcG9pbnQsIHRva2VuLCByYXRlTGltaXRlciwgZmV0Y2ggfSwgY2FyLCB7IG9uU3RvcmVkQ2h1bmssIG1heFJldHJpZXMsIG1heENodW5rU2l6ZSwgbmFtZSwgc2lnbmFsIH0pXG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGF3YWl0IGJsb2Nrc3RvcmUuY2xvc2UoKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1NlcnZpY2V9IHNlcnZpY2VcbiAgICogQHBhcmFtIHtpbXBvcnQoJ0BpcGxkL2Nhci9hcGknKS5DYXJSZWFkZXJ9IGNhclxuICAgKiBAcGFyYW0ge1B1dENhck9wdGlvbnN9IFtvcHRpb25zXVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxDSURTdHJpbmc+fVxuICAgKi9cbiAgc3RhdGljIGFzeW5jIHB1dENhciAoeyBlbmRwb2ludCwgdG9rZW4sIHJhdGVMaW1pdGVyID0gZ2xvYmFsUmF0ZUxpbWl0ZXIsIGZldGNoID0gX2ZldGNoIH0sIGNhciwge1xuICAgIG5hbWUsXG4gICAgb25TdG9yZWRDaHVuayxcbiAgICBtYXhSZXRyaWVzID0gTUFYX1BVVF9SRVRSSUVTLFxuICAgIG1heENodW5rU2l6ZSA9IERFRkFVTFRfQ0hVTktfU0laRSxcbiAgICBkZWNvZGVycyxcbiAgICBzaWduYWxcbiAgfSA9IHt9KSB7XG4gICAgaWYgKG1heENodW5rU2l6ZSA+PSBNQVhfQ0hVTktfU0laRSB8fCBtYXhDaHVua1NpemUgPCBNQVhfQkxPQ0tfU0laRSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtYXhpbXVtIGNodW5rIHNpemUgbXVzdCBiZSBsZXNzIHRoYW4gMTAwTWlCIGFuZCBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMU1CJylcbiAgICB9XG4gICAgY29uc3QgdGFyZ2V0U2l6ZSA9IG1heENodW5rU2l6ZVxuICAgIGNvbnN0IHVybCA9IG5ldyBVUkwoJ2NhcicsIGVuZHBvaW50KVxuICAgIGNvbnN0IGhlYWRlcnMgPSB7XG4gICAgICAuLi5XZWIzU3RvcmFnZS5oZWFkZXJzKHRva2VuKSxcbiAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vdm5kLmlwbGQuY2FyJyxcbiAgICAgIC4uLihuYW1lID8geyAnWC1OYW1lJzogZW5jb2RlVVJJQ29tcG9uZW50KG5hbWUpIH0gOiB7fSlcbiAgICB9XG5cbiAgICBjb25zdCByb290cyA9IGF3YWl0IGNhci5nZXRSb290cygpXG4gICAgaWYgKHJvb3RzWzBdID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyByb290IENJRCcpXG4gICAgfVxuICAgIGlmIChyb290cy5sZW5ndGggPiAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RvbyBtYW55IHJvb3RzJylcbiAgICB9XG5cbiAgICBjb25zdCBjYXJSb290ID0gcm9vdHNbMF0udG9TdHJpbmcoKVxuICAgIGNvbnN0IHNwbGl0dGVyID0gbmV3IFRyZWV3YWxrQ2FyU3BsaXR0ZXIoY2FyLCB0YXJnZXRTaXplLCB7IGRlY29kZXJzIH0pXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0FzeW5jSXRlcmFibGU8VWludDhBcnJheT59IGNhclxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPENJRFN0cmluZz59XG4gICAgICovXG4gICAgY29uc3Qgb25DYXJDaHVuayA9IGFzeW5jIGNhciA9PiB7XG4gICAgICBjb25zdCBjYXJQYXJ0cyA9IFtdXG4gICAgICBmb3IgYXdhaXQgKGNvbnN0IHBhcnQgb2YgY2FyKSB7XG4gICAgICAgIGNhclBhcnRzLnB1c2gocGFydClcbiAgICAgIH1cblxuICAgICAgY29uc3QgY2FyRmlsZSA9IG5ldyBCbG9iKGNhclBhcnRzLCB7IHR5cGU6ICdhcHBsaWNhdGlvbi92bmQuaXBsZC5jYXInIH0pXG5cbiAgICAgIC8qKiBAdHlwZSB7QmxvYnxBcnJheUJ1ZmZlcn0gKi9cbiAgICAgIGxldCBib2R5ID0gY2FyRmlsZVxuICAgICAgLy8gRklYTUU6IHNob3VsZCBub3QgYmUgbmVjZXNzYXJ5IHRvIGF3YWl0IGFycmF5QnVmZmVyKCkhXG4gICAgICAvLyBOb2RlLmpzIDIwIGhhbmdzIHJlYWRpbmcgdGhlIHN0cmVhbSAoaXQgbmV2ZXIgZW5kcykgYnV0IGluXG4gICAgICAvLyBvbGRlciBub2RlIHZlcnNpb25zIGFuZCB0aGUgYnJvd3NlciBpdCBpcyBmaW5lIHRvIHBhc3MgYSBibG9iLlxuICAgICAgLyogYzggaWdub3JlIG5leHQgMyAqL1xuICAgICAgaWYgKHBhcnNlSW50KGdsb2JhbFRoaXMucHJvY2Vzcz8udmVyc2lvbnM/Lm5vZGUpID4gMTgpIHtcbiAgICAgICAgYm9keSA9IGF3YWl0IGJvZHkuYXJyYXlCdWZmZXIoKVxuICAgICAgfVxuXG4gICAgICBjb25zdCByZXMgPSBhd2FpdCBwUmV0cnkoXG4gICAgICAgIGFzeW5jICgpID0+IHtcbiAgICAgICAgICBhd2FpdCByYXRlTGltaXRlcigpXG4gICAgICAgICAgLyoqIEB0eXBlIHtSZXNwb25zZX0gKi9cbiAgICAgICAgICBsZXQgcmVzcG9uc2VcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwudG9TdHJpbmcoKSwge1xuICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICAgICAgYm9keSxcbiAgICAgICAgICAgICAgc2lnbmFsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0gY2F0Y2ggKC8qKiBAdHlwZSB7YW55fSAqL2Vycikge1xuICAgICAgICAgICAgdGhyb3cgc2lnbmFsICYmIHNpZ25hbC5hYm9ydGVkID8gbmV3IEFib3J0RXJyb3IoZXJyKSA6IGVyclxuICAgICAgICAgIH1cbiAgICAgICAgICAvKiBjOCBpZ25vcmUgbmV4dCAzICovXG4gICAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNDI5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JhdGUgbGltaXRlZCcpXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKVxuICAgICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihyZXMubWVzc2FnZSlcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAocmVzLmNpZCAhPT0gY2FyUm9vdCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGByb290IENJRCBtaXNtYXRjaCwgZXhwZWN0ZWQ6ICR7Y2FyUm9vdH0sIHJlY2VpdmVkOiAke3Jlcy5jaWR9YClcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlcy5jaWRcbiAgICAgICAgfSxcbiAgICAgICAgeyByZXRyaWVzOiBtYXhSZXRyaWVzIH1cbiAgICAgIClcblxuICAgICAgb25TdG9yZWRDaHVuayAmJiBvblN0b3JlZENodW5rKGNhckZpbGUuc2l6ZSlcbiAgICAgIHJldHVybiByZXNcbiAgICB9XG5cbiAgICBjb25zdCB1cGxvYWQgPSB0cmFuc2Zvcm0oTUFYX0NPTkNVUlJFTlRfVVBMT0FEUywgb25DYXJDaHVuaylcbiAgICBmb3IgYXdhaXQgKGNvbnN0IF8gb2YgdXBsb2FkKHNwbGl0dGVyLmNhcnMoKSkpIHt9IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICByZXR1cm4gY2FyUm9vdFxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7U2VydmljZX0gc2VydmljZVxuICAgKiBAcGFyYW0ge0NJRFN0cmluZ30gY2lkXG4gICAqIEBwYXJhbSB7UmVxdWVzdE9wdGlvbnN9IFtvcHRpb25zXVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxXZWIzUmVzcG9uc2UgfCBudWxsPn1cbiAgICovXG4gIHN0YXRpYyBhc3luYyBnZXQgKHsgZW5kcG9pbnQsIHRva2VuLCByYXRlTGltaXRlciA9IGdsb2JhbFJhdGVMaW1pdGVyLCBmZXRjaCA9IF9mZXRjaCB9LCBjaWQsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHVybCA9IG5ldyBVUkwoYGNhci8ke2NpZH1gLCBlbmRwb2ludClcbiAgICBhd2FpdCByYXRlTGltaXRlcigpXG4gICAgY29uc3QgcmVzID0gYXdhaXQgZmV0Y2godXJsLnRvU3RyaW5nKCksIHtcbiAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICBoZWFkZXJzOiBXZWIzU3RvcmFnZS5oZWFkZXJzKHRva2VuKSxcbiAgICAgIHNpZ25hbDogb3B0aW9ucy5zaWduYWxcbiAgICB9KVxuICAgIC8qIGM4IGlnbm9yZSBuZXh0IDMgKi9cbiAgICBpZiAocmVzLnN0YXR1cyA9PT0gNDI5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JhdGUgbGltaXRlZCcpXG4gICAgfVxuICAgIHJldHVybiB0b1dlYjNSZXNwb25zZShyZXMpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtTZXJ2aWNlfSBzZXJ2aWNlXG4gICAqIEBwYXJhbSB7Q0lEU3RyaW5nfSBjaWRcbiAgICogQHBhcmFtIHtSZXF1ZXN0T3B0aW9uc30gW29wdGlvbnNdXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPENJRFN0cmluZz59XG4gICAqL1xuICAvKiBjOCBpZ25vcmUgbmV4dCA0ICovXG4gIHN0YXRpYyBhc3luYyBkZWxldGUgKHsgZW5kcG9pbnQsIHRva2VuLCByYXRlTGltaXRlciA9IGdsb2JhbFJhdGVMaW1pdGVyIH0sIGNpZCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc29sZS5sb2coJ05vdCBkZWxldGluZycsIGNpZCwgZW5kcG9pbnQsIHRva2VuLCByYXRlTGltaXRlciwgb3B0aW9ucylcbiAgICB0aHJvdyBFcnJvcignLmRlbGV0ZSBub3QgaW1wbGVtZW50ZWQgeWV0JylcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1NlcnZpY2V9IHNlcnZpY2VcbiAgICogQHBhcmFtIHtDSURTdHJpbmd9IGNpZFxuICAgKiBAcGFyYW0ge1JlcXVlc3RPcHRpb25zfSBbb3B0aW9uc11cbiAgICogQHJldHVybnMge1Byb21pc2U8U3RhdHVzIHwgdW5kZWZpbmVkPn1cbiAgICovXG4gIHN0YXRpYyBhc3luYyBzdGF0dXMgKHsgZW5kcG9pbnQsIHRva2VuLCByYXRlTGltaXRlciA9IGdsb2JhbFJhdGVMaW1pdGVyLCBmZXRjaCA9IF9mZXRjaCB9LCBjaWQsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHVybCA9IG5ldyBVUkwoYHN0YXR1cy8ke2NpZH1gLCBlbmRwb2ludClcbiAgICBhd2FpdCByYXRlTGltaXRlcigpXG4gICAgY29uc3QgcmVzID0gYXdhaXQgZmV0Y2godXJsLnRvU3RyaW5nKCksIHtcbiAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICBoZWFkZXJzOiBXZWIzU3RvcmFnZS5oZWFkZXJzKHRva2VuKSxcbiAgICAgIHNpZ25hbDogb3B0aW9ucy5zaWduYWxcbiAgICB9KVxuICAgIC8qIGM4IGlnbm9yZSBuZXh0IDMgKi9cbiAgICBpZiAocmVzLnN0YXR1cyA9PT0gNDI5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JhdGUgbGltaXRlZCcpXG4gICAgfVxuICAgIGlmIChyZXMuc3RhdHVzID09PSA0MDQpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWRcbiAgICB9XG4gICAgaWYgKCFyZXMub2spIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihyZXMuc3RhdHVzVGV4dClcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5qc29uKClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1NlcnZpY2V9IHNlcnZpY2VcbiAgICogQHBhcmFtIHtMaXN0T3B0aW9uc30gW29wdHNdXG4gICAqIEByZXR1cm5zIHtBc3luY0l0ZXJhYmxlPFVwbG9hZD59XG4gICAqL1xuICBzdGF0aWMgYXN5bmMgKiBsaXN0IChzZXJ2aWNlLCB7IGJlZm9yZSA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSwgbWF4UmVzdWx0cyA9IEluZmluaXR5LCBzaWduYWwgfSA9IHt9KSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTZXJ2aWNlfSBzZXJ2aWNlXG4gICAgICogQHBhcmFtIHt7YmVmb3JlOiBzdHJpbmcsIHNpemU6IG51bWJlcn19IG9wdHNcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxSZXNwb25zZT59XG4gICAgICovXG4gICAgYXN5bmMgZnVuY3Rpb24gbGlzdFBhZ2UgKHsgZW5kcG9pbnQsIHRva2VuLCByYXRlTGltaXRlciA9IGdsb2JhbFJhdGVMaW1pdGVyLCBmZXRjaCA9IF9mZXRjaCB9LCB7IGJlZm9yZSwgc2l6ZSB9KSB7XG4gICAgICBjb25zdCBzZWFyY2ggPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHsgYmVmb3JlLCBzaXplOiBzaXplLnRvU3RyaW5nKCkgfSlcbiAgICAgIGNvbnN0IHVybCA9IG5ldyBVUkwoYHVzZXIvdXBsb2Fkcz8ke3NlYXJjaH1gLCBlbmRwb2ludClcbiAgICAgIGF3YWl0IHJhdGVMaW1pdGVyKClcbiAgICAgIHJldHVybiBmZXRjaCh1cmwudG9TdHJpbmcoKSwge1xuICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgLi4uV2ViM1N0b3JhZ2UuaGVhZGVycyh0b2tlbiksXG4gICAgICAgICAgJ0FjY2Vzcy1Db250cm9sLVJlcXVlc3QtSGVhZGVycyc6ICdMaW5rJ1xuICAgICAgICB9LFxuICAgICAgICBzaWduYWxcbiAgICAgIH0pXG4gICAgfVxuICAgIGxldCBjb3VudCA9IDBcbiAgICBjb25zdCBzaXplID0gbWF4UmVzdWx0cyA+IDEwMCA/IDEwMCA6IG1heFJlc3VsdHNcbiAgICBmb3IgYXdhaXQgKGNvbnN0IHJlcyBvZiBwYWdpbmF0b3IobGlzdFBhZ2UsIHNlcnZpY2UsIHsgYmVmb3JlLCBzaXplIH0pKSB7XG4gICAgICBpZiAoIXJlcy5vaykge1xuICAgICAgICAvKiBjOCBpZ25vcmUgbmV4dCAzICovXG4gICAgICAgIGlmIChyZXMuc3RhdHVzID09PSA0MjkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JhdGUgbGltaXRlZCcpXG4gICAgICAgIH1cblxuICAgICAgICAvKiBjOCBpZ25vcmUgbmV4dCAyICovXG4gICAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IGF3YWl0IHJlcy5qc29uKClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3Jlcy5zdGF0dXN9ICR7cmVzLnN0YXR1c1RleHR9ICR7ZXJyb3JNZXNzYWdlID8gJy0gJyArIGVycm9yTWVzc2FnZS5tZXNzYWdlIDogJyd9YClcbiAgICAgIH1cbiAgICAgIGNvbnN0IHBhZ2UgPSBhd2FpdCByZXMuanNvbigpXG4gICAgICBmb3IgKGNvbnN0IHVwbG9hZCBvZiBwYWdlKSB7XG4gICAgICAgIGlmICgrK2NvdW50ID4gbWF4UmVzdWx0cykge1xuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIHlpZWxkIHVwbG9hZFxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIEp1c3QgYSBzdWdhciBzbyB5b3UgZG9uJ3QgaGF2ZSB0byBwYXNzIGFyb3VuZCBlbmRwb2ludCBhbmQgdG9rZW4gYXJvdW5kLlxuXG4gIC8qKlxuICAgKiBVcGxvYWRzIGZpbGVzIHRvIHdlYjMuc3RvcmFnZS4gRmlsZXMgYXJlIGhhc2hlZCBpbiB0aGUgY2xpZW50IGFuZCB1cGxvYWRlZCBhcyBhIHNpbmdsZVxuICAgKiBbQ29udGVudCBBZGRyZXNzZWQgQXJjaGl2ZShDQVIpXShodHRwczovL2dpdGh1Yi5jb20vaXBsZC9zcGVjcy9ibG9iL21hc3Rlci9ibG9jay1sYXllci9jb250ZW50LWFkZHJlc3NhYmxlLWFyY2hpdmVzLm1kKS5cbiAgICogVGFrZXMgYSBbQmxvYl0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0Jsb2IvQmxvYilcbiAgICpcbiAgICogUmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyBDb250ZW50IElkZW50aWZpZXIgKENJRCkuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGpzXG4gICAqIGNvbnN0IGZpbGUgPSBuZXcgRmlsZShbJ2hlbGxvIHdvcmxkJ10sICdoZWxsby50eHQnLCB7IHR5cGU6ICd0ZXh0L3BsYWluJyB9KVxuICAgKiBjb25zdCBjaWQgPSBhd2FpdCBjbGllbnQucHV0KFtmaWxlXSlcbiAgICogYGBgXG4gICAqIEBwYXJhbSB7SXRlcmFibGU8RmlsZWxpa2U+fSBmaWxlc1xuICAgKiBAcGFyYW0ge1B1dE9wdGlvbnN9IFtvcHRpb25zXVxuICAgKi9cbiAgcHV0IChmaWxlcywgb3B0aW9ucykge1xuICAgIHJldHVybiBXZWIzU3RvcmFnZS5wdXQodGhpcywgZmlsZXMsIG9wdGlvbnMpXG4gIH1cblxuICAvKipcbiAgICogVXBsb2FkcyBhIENBUiAoW0NvbnRlbnQgQWRkcmVzc2VkIEFyY2hpdmVdKGh0dHBzOi8vZ2l0aHViLmNvbS9pcGxkL3NwZWNzL2Jsb2IvbWFzdGVyL2Jsb2NrLWxheWVyL2NvbnRlbnQtYWRkcmVzc2FibGUtYXJjaGl2ZXMubWQpKSBmaWxlIHRvIHdlYjMuc3RvcmFnZS5cbiAgICogVGFrZXMgYSBDYXJSZWFkZXIgaW50ZXJmYWNlIGZyb20gQGlwbGQvY2FyXG4gICAqXG4gICAqIFJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgQ29udGVudCBJZGVudGlmaWVyIChDSUQpLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqc1xuICAgKiBpbXBvcnQgZnMgZnJvbSAnZnMnXG4gICAqIGltcG9ydCB7IFJlYWRhYmxlIH0gZnJvbSAnc3RyZWFtJ1xuICAgKiBpbXBvcnQgeyBDYXJSZWFkZXIsIENhcldyaXRlciB9IGZyb20gJ0BpcGxkL2NhcidcbiAgICogaW1wb3J0ICogYXMgcmF3IGZyb20gJ211bHRpZm9ybWF0cy9jb2RlY3MvcmF3J1xuICAgKiBpbXBvcnQgeyBDSUQgfSBmcm9tICdtdWx0aWZvcm1hdHMvY2lkJ1xuICAgKiBpbXBvcnQgeyBzaGEyNTYgfSBmcm9tICdtdWx0aWZvcm1hdHMvaGFzaGVzL3NoYTInXG4gICAqXG4gICAqIGFzeW5jIGZ1bmN0aW9uIGdldENhcigpIHtcbiAgICogICAgY29uc3QgYnl0ZXMgPSBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoJ3JhbmRvbSBtZWFuaW5nbGVzcyBieXRlcycpXG4gICAqICAgIGNvbnN0IGhhc2ggPSBhd2FpdCBzaGEyNTYuZGlnZXN0KHJhdy5lbmNvZGUoYnl0ZXMpKVxuICAgKiAgICBjb25zdCBjaWQgPSBDSUQuY3JlYXRlKDEsIHJhdy5jb2RlLCBoYXNoKVxuICAgKlxuICAgKiAgICAvLyBjcmVhdGUgdGhlIHdyaXRlciBhbmQgc2V0IHRoZSBoZWFkZXIgd2l0aCBhIHNpbmdsZSByb290XG4gICAqICAgIGNvbnN0IHsgd3JpdGVyLCBvdXQgfSA9IGF3YWl0IENhcldyaXRlci5jcmVhdGUoW2NpZF0pXG4gICAqICAgIFJlYWRhYmxlLmZyb20ob3V0KS5waXBlKGZzLmNyZWF0ZVdyaXRlU3RyZWFtKCdleGFtcGxlLmNhcicpKVxuXG4gICAqICAgIC8vIHN0b3JlIGEgbmV3IGJsb2NrLCBjcmVhdGVzIGEgbmV3IGZpbGUgZW50cnkgaW4gdGhlIENBUiBhcmNoaXZlXG4gICAqICAgIGF3YWl0IHdyaXRlci5wdXQoeyBjaWQsIGJ5dGVzIH0pXG4gICAqICAgIGF3YWl0IHdyaXRlci5jbG9zZSgpXG5cbiAgICogICAgY29uc3QgaW5TdHJlYW0gPSBmcy5jcmVhdGVSZWFkU3RyZWFtKCdleGFtcGxlLmNhcicpXG4gICAqICAgIC8vIHJlYWQgYW5kIHBhcnNlIHRoZSBlbnRpcmUgc3RyZWFtIGluIG9uZSBnbywgdGhpcyB3aWxsIGNhY2hlIHRoZSBjb250ZW50cyBvZlxuICAgKiAgICAvLyB0aGUgY2FyIGluIG1lbW9yeSBzbyBpcyBub3Qgc3VpdGFibGUgZm9yIGxhcmdlIGZpbGVzLlxuICAgKiAgICBjb25zdCByZWFkZXIgPSBhd2FpdCBDYXJSZWFkZXIuZnJvbUl0ZXJhYmxlKGluU3RyZWFtKVxuICAgKiAgICByZXR1cm4gcmVhZGVyXG4gICAqIH1cbiAgICpcbiAgICogY29uc3QgY2FyID0gYXdhaXQgZ2V0Q2FyKClcbiAgICogY29uc3QgY2lkID0gYXdhaXQgY2xpZW50LnB1dENhcihjYXIpXG4gICAqIGBgYFxuICAgKiBAcGFyYW0ge2ltcG9ydCgnQGlwbGQvY2FyL2FwaScpLkNhclJlYWRlcn0gY2FyXG4gICAqIEBwYXJhbSB7UHV0Q2FyT3B0aW9uc30gW29wdGlvbnNdXG4gICAqL1xuICBwdXRDYXIgKGNhciwgb3B0aW9ucykge1xuICAgIHJldHVybiBXZWIzU3RvcmFnZS5wdXRDYXIodGhpcywgY2FyLCBvcHRpb25zKVxuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHRoZSBDb250ZW50IEFkZHJlc3NlZCBBcmNoaXZlIGJ5IGl0cyByb290IENJRC5cbiAgICogQHBhcmFtIHtDSURTdHJpbmd9IGNpZFxuICAgKiBAcGFyYW0ge1JlcXVlc3RPcHRpb25zfSBbb3B0aW9uc11cbiAgICovXG4gIGdldCAoY2lkLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIFdlYjNTdG9yYWdlLmdldCh0aGlzLCBjaWQsIG9wdGlvbnMpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtDSURTdHJpbmd9IGNpZFxuICAgKiBAcGFyYW0ge1JlcXVlc3RPcHRpb25zfSBbb3B0aW9uc11cbiAgICovXG4gIC8qIGM4IGlnbm9yZSBuZXh0IDMgKi9cbiAgZGVsZXRlIChjaWQsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gV2ViM1N0b3JhZ2UuZGVsZXRlKHRoaXMsIGNpZCwgb3B0aW9ucylcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCBpbmZvIG9uIEZpbGVjb2luIGRlYWxzIGFuZCBJUEZTIHBpbnMgdGhhdCBhIGdpdmVuIENJRCBpcyByZXBsaWNhdGVkIGluLlxuICAgKiBAcGFyYW0ge0NJRFN0cmluZ30gY2lkXG4gICAqIEBwYXJhbSB7UmVxdWVzdE9wdGlvbnN9IFtvcHRpb25zXVxuICAgKi9cbiAgc3RhdHVzIChjaWQsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gV2ViM1N0b3JhZ2Uuc3RhdHVzKHRoaXMsIGNpZCwgb3B0aW9ucylcbiAgfVxuXG4gIC8qKlxuICAgKiBGaW5kIGFsbCB1cGxvYWRzIGZvciB0aGlzIGFjY291bnQuIFVzZSBhIGBmb3IgYXdhaXQuLi5vZmAgbG9vcCB0byBmZXRjaCB0aGVtIGFsbC5cbiAgICogQGV4YW1wbGVcbiAgICogRmV0Y2ggYWxsIHRoZSB1cGxvYWRzXG4gICAqIGBgYGpzXG4gICAqIGNvbnN0IHVwbG9hZHMgPSBbXVxuICAgKiBmb3IgYXdhaXQgKGNvbnN0IGl0ZW0gb2YgY2xpZW50Lmxpc3QoKSkge1xuICAgKiAgICB1cGxvYWRzLnB1c2goaXRlbSlcbiAgICogfVxuICAgKiBgYGBcbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9TdGF0ZW1lbnRzL2Zvci1hd2FpdC4uLm9mXG4gICAqIEBwYXJhbSB7TGlzdE9wdGlvbnN9IFtvcHRzXVxuICAgKiBAcmV0dXJucyB7QXN5bmNJdGVyYWJsZTxVcGxvYWQ+fVxuICAgKi9cbiAgbGlzdCAob3B0cykge1xuICAgIHJldHVybiBXZWIzU3RvcmFnZS5saXN0KHRoaXMsIG9wdHMpXG4gIH1cbn1cblxuLyoqXG4gKiBNYXAgYSBVbml4RlNFbnRyeSB0byBhIEZpbGUgd2l0aCBhIGNpZCBwcm9wZXJ0eS5cbiAqXG4gKiBAcGFyYW0ge1VuaXhGU0VudHJ5fSBlbnRyeVxuICogQHJldHVybnMge1Byb21pc2U8V2ViM0ZpbGU+fVxuICovXG5hc3luYyBmdW5jdGlvbiB0b1dlYjNGaWxlICh7IGNvbnRlbnQsIHBhdGgsIGNpZCB9KSB7XG4gIGNvbnN0IGNodW5rcyA9IFtdXG4gIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2YgY29udGVudCgpKSB7XG4gICAgY2h1bmtzLnB1c2goY2h1bmspXG4gIH1cbiAgY29uc3QgZmlsZSA9IG5ldyBGaWxlKGNodW5rcywgdG9GaWxlbmFtZVdpdGhQYXRoKHBhdGgpKVxuICByZXR1cm4gT2JqZWN0LmFzc2lnbihmaWxlLCB7IGNpZDogY2lkLnRvU3RyaW5nKCkgfSlcbn1cblxuLyoqXG4gKiBUcmltIHRoZSByb290IGNpZCBmcm9tIHRoZSBwYXRoIGlmIHRoZXJlIGlzIGFueXRpbmcgYWZ0ZXIgaXQuXG4gKiBiYWZ5Li4uaWMycS9wYXRoL3RvL3BpbnBpZS5qcGcgPT4gcGF0aC90by9waW5waWUuanBnXG4gKiAgICAgICAgIGJhZnkuLi5pYzJxL3BpbnBpZS5qcGcgPT4gcGlucGllLmpwZ1xuICogICAgICAgICAgICAgICAgICAgIGJhZmsuLi41Mnp5ID0+IGJhZmsuLi41Mnp5XG4gKiBAcGFyYW0ge3N0cmluZ30gdW5peEZzUGF0aFxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gdG9GaWxlbmFtZVdpdGhQYXRoICh1bml4RnNQYXRoKSB7XG4gIGNvbnN0IHNsYXNoSW5kZXggPSB1bml4RnNQYXRoLmluZGV4T2YoJy8nKVxuICByZXR1cm4gc2xhc2hJbmRleCA9PT0gLTEgPyB1bml4RnNQYXRoIDogdW5peEZzUGF0aC5zdWJzdHJpbmcoc2xhc2hJbmRleCArIDEpXG59XG5cbi8qKlxuICogQWRkIGNhciB1bnBhY2tpbmcgc21hcnRzIHRvIHRoZSByZXNwb25zZSBvYmplY3QsXG4gKiBAcGFyYW0ge1Jlc3BvbnNlfSByZXNcbiAqIEByZXR1cm5zIHtXZWIzUmVzcG9uc2V9XG4gKi9cbmZ1bmN0aW9uIHRvV2ViM1Jlc3BvbnNlIChyZXMpIHtcbiAgY29uc3QgcmVzcG9uc2UgPSBPYmplY3QuYXNzaWduKHJlcywge1xuICAgIHVuaXhGc0l0ZXJhdG9yOiBhc3luYyBmdW5jdGlvbiAqICgpIHtcbiAgICAgIGlmICghcmVzLm9rKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgUmVzcG9uc2Ugd2FzIG5vdCBvazogJHtyZXMuc3RhdHVzfSAke3Jlcy5zdGF0dXNUZXh0fSAtIENoZWNrIGZvciB7IFwib2tcIjogZmFsc2UgfSBvbiB0aGUgUmVzcG9uc2Ugb2JqZWN0IGJlZm9yZSBjYWxsaW5nIC51bml4RnNJdGVyYXRvcmApXG4gICAgICB9XG4gICAgICAvKiBjOCBpZ25vcmUgbmV4dCAzICovXG4gICAgICBpZiAoIXJlcy5ib2R5KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gYm9keSBvbiByZXNwb25zZScpXG4gICAgICB9XG4gICAgICBjb25zdCBibG9ja3N0b3JlID0gbmV3IEJsb2Nrc3RvcmUoKVxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIGF3YWl0IChjb25zdCBlbnRyeSBvZiB1bnBhY2tTdHJlYW0ocmVzLmJvZHksIHsgYmxvY2tzdG9yZSB9KSkge1xuICAgICAgICAgIHlpZWxkIGVudHJ5XG4gICAgICAgIH1cbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGF3YWl0IGJsb2Nrc3RvcmUuY2xvc2UoKVxuICAgICAgfVxuICAgIH0sXG4gICAgZmlsZXM6IGFzeW5jICgpID0+IHtcbiAgICAgIGlmICghcmVzLm9rKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgUmVzcG9uc2Ugd2FzIG5vdCBvazogJHtyZXMuc3RhdHVzfSAke3Jlcy5zdGF0dXNUZXh0fSAtIENoZWNrIGZvciB7IFwib2tcIjogZmFsc2UgfSBvbiB0aGUgUmVzcG9uc2Ugb2JqZWN0IGJlZm9yZSBjYWxsaW5nIC5maWxlc2ApXG4gICAgICB9XG4gICAgICBjb25zdCBmaWxlcyA9IFtdXG4gICAgICAvLyBAdHMtaWdub3JlIHdlJ3JlIHVzaW5nIHRoZSBlbnJpY2hlZCByZXNwb25zZSBoZXJlXG4gICAgICBmb3IgYXdhaXQgKGNvbnN0IGVudHJ5IG9mIHJlc3BvbnNlLnVuaXhGc0l0ZXJhdG9yKCkpIHtcbiAgICAgICAgaWYgKGVudHJ5LnR5cGUgPT09ICdkaXJlY3RvcnknKSB7XG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmaWxlID0gYXdhaXQgdG9XZWIzRmlsZShlbnRyeSlcbiAgICAgICAgZmlsZXMucHVzaChmaWxlKVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZpbGVzXG4gICAgfVxuICB9KVxuICByZXR1cm4gcmVzcG9uc2Vcbn1cblxuLyoqXG4gKiBDb252ZXJ0IHRoZSBwYXNzZWQgZmlsZSB0byBhbiBcImltcG9ydCBjYW5kaWRhdGVcIiAtIGFuIG9iamVjdCBzdWl0YWJsZSBmb3JcbiAqIHBhc3NpbmcgdG8gdGhlIGlwZnMtdW5peGZzLWltcG9ydGVyLiBOb3RlOiBjb250ZW50IGlzIGFuIGFjY2Vzc29yIHNvIHRoYXRcbiAqIHRoZSBzdHJlYW0gaXMgb25seSBjcmVhdGVkIHdoZW4gbmVlZGVkLlxuICpcbiAqIEBwYXJhbSB7RmlsZWxpa2V9IGZpbGVcbiAqL1xuZnVuY3Rpb24gdG9JbXBvcnRDYW5kaWRhdGUgKGZpbGUpIHtcbiAgLyoqIEB0eXBlIHtSZWFkYWJsZVN0cmVhbX0gKi9cbiAgbGV0IHN0cmVhbVxuICByZXR1cm4ge1xuICAgIHBhdGg6IGZpbGUubmFtZSxcbiAgICBnZXQgY29udGVudCAoKSB7XG4gICAgICBzdHJlYW0gPSBzdHJlYW0gfHwgZmlsZS5zdHJlYW0oKVxuICAgICAgcmV0dXJuIHN0cmVhbVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEZvbGxvdyBMaW5rIGhlYWRlcnMgb24gYSBSZXNwb25zZSwgdG8gZmV0Y2ggYWxsIHRoZSB0aGluZ3MuXG4gKlxuICogQHBhcmFtIHsoc2VydmljZTogU2VydmljZSwgb3B0czogYW55KSA9PiBQcm9taXNlPFJlc3BvbnNlPn0gZm5cbiAqIEBwYXJhbSB7U2VydmljZX0gc2VydmljZVxuICogQHBhcmFtIHt7fX0gb3B0c1xuICovXG5hc3luYyBmdW5jdGlvbiAqIHBhZ2luYXRvciAoZm4sIHNlcnZpY2UsIG9wdHMpIHtcbiAgbGV0IHJlcyA9IGF3YWl0IGZuKHNlcnZpY2UsIG9wdHMpXG4gIHlpZWxkIHJlc1xuICBsZXQgbGluayA9IHBhcnNlTGlua0hlYWRlcihyZXMuaGVhZGVycy5nZXQoJ0xpbmsnKSB8fCAnJylcbiAgLy8gQHRzLWlnbm9yZVxuICB3aGlsZSAobGluayAmJiBsaW5rLm5leHQpIHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgcmVzID0gYXdhaXQgZm4oc2VydmljZSwgbGluay5uZXh0KVxuICAgIHlpZWxkIHJlc1xuICAgIGxpbmsgPSBwYXJzZUxpbmtIZWFkZXIocmVzLmhlYWRlcnMuZ2V0KCdMaW5rJykgfHwgJycpXG4gIH1cbn1cblxuZXhwb3J0IHsgV2ViM1N0b3JhZ2UsIEZpbGUsIEJsb2IsIGZpbGVzRnJvbVBhdGgsIGdldEZpbGVzRnJvbVBhdGggfVxuXG4vKipcbiAqIEp1c3QgdG8gdmVyaWZ5IEFQSSBjb21wYXRpYmlsaXR5LlxuICogVE9ETzogY29udmVydCBsaWIgdG8gYSByZWd1bGFyIGNsYXNzIHRoYXQgY2FuIGJlIHR5cGUgY2hlY2tlZC5cbiAqIEB0eXBlIHtBUEl9XG4gKi9cbmNvbnN0IGFwaSA9IFdlYjNTdG9yYWdlXG52b2lkIGFwaSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXZvaWRcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/web3.storage/src/lib.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/web3.storage/src/platform.js":
/*!*******************************************************!*\
  !*** ../../node_modules/web3.storage/src/platform.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Blob: () => (/* reexport safe */ _web_std_blob__WEBPACK_IMPORTED_MODULE_0__.Blob),\n/* harmony export */   Blockstore: () => (/* reexport safe */ ipfs_car_blockstore_fs__WEBPACK_IMPORTED_MODULE_2__.FsBlockStore),\n/* harmony export */   File: () => (/* reexport safe */ _web_std_file__WEBPACK_IMPORTED_MODULE_1__.File),\n/* harmony export */   Headers: () => (/* reexport safe */ _web_std_fetch__WEBPACK_IMPORTED_MODULE_3__.Headers),\n/* harmony export */   Request: () => (/* reexport safe */ _web_std_fetch__WEBPACK_IMPORTED_MODULE_3__.Request),\n/* harmony export */   Response: () => (/* reexport safe */ _web_std_fetch__WEBPACK_IMPORTED_MODULE_3__.Response),\n/* harmony export */   fetch: () => (/* reexport safe */ _web_std_fetch__WEBPACK_IMPORTED_MODULE_3__[\"default\"])\n/* harmony export */ });\n/* harmony import */ var _web_std_fetch__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @web-std/fetch */ \"(rsc)/../../node_modules/@web-std/fetch/src/lib.node.js\");\n/* harmony import */ var _web_std_blob__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @web-std/blob */ \"(rsc)/../../node_modules/@web-std/blob/src/lib.node.js\");\n/* harmony import */ var _web_std_file__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @web-std/file */ \"(rsc)/../../node_modules/@web-std/file/src/lib.node.js\");\n/* harmony import */ var ipfs_car_blockstore_fs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ipfs-car/blockstore/fs */ \"(rsc)/../../node_modules/ipfs-car/dist/esm/blockstore/fs.js\");\n\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL3dlYjMuc3RvcmFnZS9zcmMvcGxhdGZvcm0uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBa0U7QUFDOUI7QUFDQTtBQUMrQjs7QUFVbEUiLCJzb3VyY2VzIjpbIi9ob21lL2JhcmIvYWEvQXNzb2NpYXRlZEFjY291bnRzL25vZGVfbW9kdWxlcy93ZWIzLnN0b3JhZ2Uvc3JjL3BsYXRmb3JtLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBmZXRjaCwgeyBSZXF1ZXN0LCBSZXNwb25zZSwgSGVhZGVycyB9IGZyb20gJ0B3ZWItc3RkL2ZldGNoJ1xuaW1wb3J0IHsgQmxvYiB9IGZyb20gJ0B3ZWItc3RkL2Jsb2InXG5pbXBvcnQgeyBGaWxlIH0gZnJvbSAnQHdlYi1zdGQvZmlsZSdcbmltcG9ydCB7IEZzQmxvY2tTdG9yZSBhcyBCbG9ja3N0b3JlIH0gZnJvbSAnaXBmcy1jYXIvYmxvY2tzdG9yZS9mcydcblxuZXhwb3J0IHtcbiAgZmV0Y2gsXG4gIFJlcXVlc3QsXG4gIFJlc3BvbnNlLFxuICBIZWFkZXJzLFxuICBCbG9iLFxuICBGaWxlLFxuICBCbG9ja3N0b3JlXG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/web3.storage/src/platform.js\n");

/***/ })

};
;