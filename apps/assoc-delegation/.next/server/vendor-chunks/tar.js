/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/tar";
exports.ids = ["vendor-chunks/tar"];
exports.modules = {

/***/ "(rsc)/../../node_modules/tar/index.js":
/*!***************************************!*\
  !*** ../../node_modules/tar/index.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\n// high-level commands\nexports.c = exports.create = __webpack_require__(/*! ./lib/create.js */ \"(rsc)/../../node_modules/tar/lib/create.js\")\nexports.r = exports.replace = __webpack_require__(/*! ./lib/replace.js */ \"(rsc)/../../node_modules/tar/lib/replace.js\")\nexports.t = exports.list = __webpack_require__(/*! ./lib/list.js */ \"(rsc)/../../node_modules/tar/lib/list.js\")\nexports.u = exports.update = __webpack_require__(/*! ./lib/update.js */ \"(rsc)/../../node_modules/tar/lib/update.js\")\nexports.x = exports.extract = __webpack_require__(/*! ./lib/extract.js */ \"(rsc)/../../node_modules/tar/lib/extract.js\")\n\n// classes\nexports.Pack = __webpack_require__(/*! ./lib/pack.js */ \"(rsc)/../../node_modules/tar/lib/pack.js\")\nexports.Unpack = __webpack_require__(/*! ./lib/unpack.js */ \"(rsc)/../../node_modules/tar/lib/unpack.js\")\nexports.Parse = __webpack_require__(/*! ./lib/parse.js */ \"(rsc)/../../node_modules/tar/lib/parse.js\")\nexports.ReadEntry = __webpack_require__(/*! ./lib/read-entry.js */ \"(rsc)/../../node_modules/tar/lib/read-entry.js\")\nexports.WriteEntry = __webpack_require__(/*! ./lib/write-entry.js */ \"(rsc)/../../node_modules/tar/lib/write-entry.js\")\nexports.Header = __webpack_require__(/*! ./lib/header.js */ \"(rsc)/../../node_modules/tar/lib/header.js\")\nexports.Pax = __webpack_require__(/*! ./lib/pax.js */ \"(rsc)/../../node_modules/tar/lib/pax.js\")\nexports.types = __webpack_require__(/*! ./lib/types.js */ \"(rsc)/../../node_modules/tar/lib/types.js\")\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL3Rhci9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWjtBQUNBLFNBQVMsR0FBRyx5R0FBMkM7QUFDdkQsU0FBUyxHQUFHLDRHQUE2QztBQUN6RCxTQUFTLEdBQUcsbUdBQXVDO0FBQ25ELFNBQVMsR0FBRyx5R0FBMkM7QUFDdkQsU0FBUyxHQUFHLDRHQUE2Qzs7QUFFekQ7QUFDQSxtR0FBdUM7QUFDdkMseUdBQTJDO0FBQzNDLHNHQUF5QztBQUN6QyxvSEFBa0Q7QUFDbEQsdUhBQW9EO0FBQ3BELHlHQUEyQztBQUMzQyxnR0FBcUM7QUFDckMsc0dBQXlDIiwic291cmNlcyI6WyIvaG9tZS9iYXJiL2FhL0Fzc29jaWF0ZWRBY2NvdW50cy9ub2RlX21vZHVsZXMvdGFyL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG4vLyBoaWdoLWxldmVsIGNvbW1hbmRzXG5leHBvcnRzLmMgPSBleHBvcnRzLmNyZWF0ZSA9IHJlcXVpcmUoJy4vbGliL2NyZWF0ZS5qcycpXG5leHBvcnRzLnIgPSBleHBvcnRzLnJlcGxhY2UgPSByZXF1aXJlKCcuL2xpYi9yZXBsYWNlLmpzJylcbmV4cG9ydHMudCA9IGV4cG9ydHMubGlzdCA9IHJlcXVpcmUoJy4vbGliL2xpc3QuanMnKVxuZXhwb3J0cy51ID0gZXhwb3J0cy51cGRhdGUgPSByZXF1aXJlKCcuL2xpYi91cGRhdGUuanMnKVxuZXhwb3J0cy54ID0gZXhwb3J0cy5leHRyYWN0ID0gcmVxdWlyZSgnLi9saWIvZXh0cmFjdC5qcycpXG5cbi8vIGNsYXNzZXNcbmV4cG9ydHMuUGFjayA9IHJlcXVpcmUoJy4vbGliL3BhY2suanMnKVxuZXhwb3J0cy5VbnBhY2sgPSByZXF1aXJlKCcuL2xpYi91bnBhY2suanMnKVxuZXhwb3J0cy5QYXJzZSA9IHJlcXVpcmUoJy4vbGliL3BhcnNlLmpzJylcbmV4cG9ydHMuUmVhZEVudHJ5ID0gcmVxdWlyZSgnLi9saWIvcmVhZC1lbnRyeS5qcycpXG5leHBvcnRzLldyaXRlRW50cnkgPSByZXF1aXJlKCcuL2xpYi93cml0ZS1lbnRyeS5qcycpXG5leHBvcnRzLkhlYWRlciA9IHJlcXVpcmUoJy4vbGliL2hlYWRlci5qcycpXG5leHBvcnRzLlBheCA9IHJlcXVpcmUoJy4vbGliL3BheC5qcycpXG5leHBvcnRzLnR5cGVzID0gcmVxdWlyZSgnLi9saWIvdHlwZXMuanMnKVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/tar/index.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/tar/lib/buffer.js":
/*!********************************************!*\
  !*** ../../node_modules/tar/lib/buffer.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n// Buffer in node 4.x < 4.5.0 doesn't have working Buffer.from\n// or Buffer.alloc, and Buffer in node 10 deprecated the ctor.\n// .M, this is fine .\\^/M..\nlet B = Buffer\n/* istanbul ignore next */\nif (!B.alloc) {\n  B = (__webpack_require__(/*! safe-buffer */ \"(rsc)/../../node_modules/safe-buffer/index.js\").Buffer)\n}\nmodule.exports = B\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL3Rhci9saWIvYnVmZmVyLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sZ0dBQTZCO0FBQ25DO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL2JhcmIvYWEvQXNzb2NpYXRlZEFjY291bnRzL25vZGVfbW9kdWxlcy90YXIvbGliL2J1ZmZlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuLy8gQnVmZmVyIGluIG5vZGUgNC54IDwgNC41LjAgZG9lc24ndCBoYXZlIHdvcmtpbmcgQnVmZmVyLmZyb21cbi8vIG9yIEJ1ZmZlci5hbGxvYywgYW5kIEJ1ZmZlciBpbiBub2RlIDEwIGRlcHJlY2F0ZWQgdGhlIGN0b3IuXG4vLyAuTSwgdGhpcyBpcyBmaW5lIC5cXF4vTS4uXG5sZXQgQiA9IEJ1ZmZlclxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmlmICghQi5hbGxvYykge1xuICBCID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcbn1cbm1vZHVsZS5leHBvcnRzID0gQlxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/tar/lib/buffer.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/tar/lib/create.js":
/*!********************************************!*\
  !*** ../../node_modules/tar/lib/create.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n// tar -c\nconst hlo = __webpack_require__(/*! ./high-level-opt.js */ \"(rsc)/../../node_modules/tar/lib/high-level-opt.js\")\n\nconst Pack = __webpack_require__(/*! ./pack.js */ \"(rsc)/../../node_modules/tar/lib/pack.js\")\nconst fs = __webpack_require__(/*! fs */ \"fs\")\nconst fsm = __webpack_require__(/*! fs-minipass */ \"(rsc)/../../node_modules/fs-minipass/index.js\")\nconst t = __webpack_require__(/*! ./list.js */ \"(rsc)/../../node_modules/tar/lib/list.js\")\nconst path = __webpack_require__(/*! path */ \"path\")\n\nconst c = module.exports = (opt_, files, cb) => {\n  if (typeof files === 'function')\n    cb = files\n\n  if (Array.isArray(opt_))\n    files = opt_, opt_ = {}\n\n  if (!files || !Array.isArray(files) || !files.length)\n    throw new TypeError('no files or directories specified')\n\n  files = Array.from(files)\n\n  const opt = hlo(opt_)\n\n  if (opt.sync && typeof cb === 'function')\n    throw new TypeError('callback not supported for sync tar functions')\n\n  if (!opt.file && typeof cb === 'function')\n    throw new TypeError('callback only supported with file option')\n\n  return opt.file && opt.sync ? createFileSync(opt, files)\n    : opt.file ? createFile(opt, files, cb)\n    : opt.sync ? createSync(opt, files)\n    : create(opt, files)\n}\n\nconst createFileSync = (opt, files) => {\n  const p = new Pack.Sync(opt)\n  const stream = new fsm.WriteStreamSync(opt.file, {\n    mode: opt.mode || 0o666\n  })\n  p.pipe(stream)\n  addFilesSync(p, files)\n}\n\nconst createFile = (opt, files, cb) => {\n  const p = new Pack(opt)\n  const stream = new fsm.WriteStream(opt.file, {\n    mode: opt.mode || 0o666\n  })\n  p.pipe(stream)\n\n  const promise = new Promise((res, rej) => {\n    stream.on('error', rej)\n    stream.on('close', res)\n    p.on('error', rej)\n  })\n\n  addFilesAsync(p, files)\n\n  return cb ? promise.then(cb, cb) : promise\n}\n\nconst addFilesSync = (p, files) => {\n  files.forEach(file => {\n    if (file.charAt(0) === '@')\n      t({\n        file: path.resolve(p.cwd, file.substr(1)),\n        sync: true,\n        noResume: true,\n        onentry: entry => p.add(entry)\n      })\n    else\n      p.add(file)\n  })\n  p.end()\n}\n\nconst addFilesAsync = (p, files) => {\n  while (files.length) {\n    const file = files.shift()\n    if (file.charAt(0) === '@')\n      return t({\n        file: path.resolve(p.cwd, file.substr(1)),\n        noResume: true,\n        onentry: entry => p.add(entry)\n      }).then(_ => addFilesAsync(p, files))\n    else\n      p.add(file)\n  }\n  p.end()\n}\n\nconst createSync = (opt, files) => {\n  const p = new Pack.Sync(opt)\n  addFilesSync(p, files)\n  return p\n}\n\nconst create = (opt, files) => {\n  const p = new Pack(opt)\n  addFilesAsync(p, files)\n  return p\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL3Rhci9saWIvY3JlYXRlLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaO0FBQ0EsWUFBWSxtQkFBTyxDQUFDLCtFQUFxQjs7QUFFekMsYUFBYSxtQkFBTyxDQUFDLDJEQUFXO0FBQ2hDLFdBQVcsbUJBQU8sQ0FBQyxjQUFJO0FBQ3ZCLFlBQVksbUJBQU8sQ0FBQyxrRUFBYTtBQUNqQyxVQUFVLG1CQUFPLENBQUMsMkRBQVc7QUFDN0IsYUFBYSxtQkFBTyxDQUFDLGtCQUFNOztBQUUzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9iYXJiL2FhL0Fzc29jaWF0ZWRBY2NvdW50cy9ub2RlX21vZHVsZXMvdGFyL2xpYi9jcmVhdGUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbi8vIHRhciAtY1xuY29uc3QgaGxvID0gcmVxdWlyZSgnLi9oaWdoLWxldmVsLW9wdC5qcycpXG5cbmNvbnN0IFBhY2sgPSByZXF1aXJlKCcuL3BhY2suanMnKVxuY29uc3QgZnMgPSByZXF1aXJlKCdmcycpXG5jb25zdCBmc20gPSByZXF1aXJlKCdmcy1taW5pcGFzcycpXG5jb25zdCB0ID0gcmVxdWlyZSgnLi9saXN0LmpzJylcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJylcblxuY29uc3QgYyA9IG1vZHVsZS5leHBvcnRzID0gKG9wdF8sIGZpbGVzLCBjYikgPT4ge1xuICBpZiAodHlwZW9mIGZpbGVzID09PSAnZnVuY3Rpb24nKVxuICAgIGNiID0gZmlsZXNcblxuICBpZiAoQXJyYXkuaXNBcnJheShvcHRfKSlcbiAgICBmaWxlcyA9IG9wdF8sIG9wdF8gPSB7fVxuXG4gIGlmICghZmlsZXMgfHwgIUFycmF5LmlzQXJyYXkoZmlsZXMpIHx8ICFmaWxlcy5sZW5ndGgpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbm8gZmlsZXMgb3IgZGlyZWN0b3JpZXMgc3BlY2lmaWVkJylcblxuICBmaWxlcyA9IEFycmF5LmZyb20oZmlsZXMpXG5cbiAgY29uc3Qgb3B0ID0gaGxvKG9wdF8pXG5cbiAgaWYgKG9wdC5zeW5jICYmIHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJylcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdjYWxsYmFjayBub3Qgc3VwcG9ydGVkIGZvciBzeW5jIHRhciBmdW5jdGlvbnMnKVxuXG4gIGlmICghb3B0LmZpbGUgJiYgdHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2NhbGxiYWNrIG9ubHkgc3VwcG9ydGVkIHdpdGggZmlsZSBvcHRpb24nKVxuXG4gIHJldHVybiBvcHQuZmlsZSAmJiBvcHQuc3luYyA/IGNyZWF0ZUZpbGVTeW5jKG9wdCwgZmlsZXMpXG4gICAgOiBvcHQuZmlsZSA/IGNyZWF0ZUZpbGUob3B0LCBmaWxlcywgY2IpXG4gICAgOiBvcHQuc3luYyA/IGNyZWF0ZVN5bmMob3B0LCBmaWxlcylcbiAgICA6IGNyZWF0ZShvcHQsIGZpbGVzKVxufVxuXG5jb25zdCBjcmVhdGVGaWxlU3luYyA9IChvcHQsIGZpbGVzKSA9PiB7XG4gIGNvbnN0IHAgPSBuZXcgUGFjay5TeW5jKG9wdClcbiAgY29uc3Qgc3RyZWFtID0gbmV3IGZzbS5Xcml0ZVN0cmVhbVN5bmMob3B0LmZpbGUsIHtcbiAgICBtb2RlOiBvcHQubW9kZSB8fCAwbzY2NlxuICB9KVxuICBwLnBpcGUoc3RyZWFtKVxuICBhZGRGaWxlc1N5bmMocCwgZmlsZXMpXG59XG5cbmNvbnN0IGNyZWF0ZUZpbGUgPSAob3B0LCBmaWxlcywgY2IpID0+IHtcbiAgY29uc3QgcCA9IG5ldyBQYWNrKG9wdClcbiAgY29uc3Qgc3RyZWFtID0gbmV3IGZzbS5Xcml0ZVN0cmVhbShvcHQuZmlsZSwge1xuICAgIG1vZGU6IG9wdC5tb2RlIHx8IDBvNjY2XG4gIH0pXG4gIHAucGlwZShzdHJlYW0pXG5cbiAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXMsIHJlaikgPT4ge1xuICAgIHN0cmVhbS5vbignZXJyb3InLCByZWopXG4gICAgc3RyZWFtLm9uKCdjbG9zZScsIHJlcylcbiAgICBwLm9uKCdlcnJvcicsIHJlailcbiAgfSlcblxuICBhZGRGaWxlc0FzeW5jKHAsIGZpbGVzKVxuXG4gIHJldHVybiBjYiA/IHByb21pc2UudGhlbihjYiwgY2IpIDogcHJvbWlzZVxufVxuXG5jb25zdCBhZGRGaWxlc1N5bmMgPSAocCwgZmlsZXMpID0+IHtcbiAgZmlsZXMuZm9yRWFjaChmaWxlID0+IHtcbiAgICBpZiAoZmlsZS5jaGFyQXQoMCkgPT09ICdAJylcbiAgICAgIHQoe1xuICAgICAgICBmaWxlOiBwYXRoLnJlc29sdmUocC5jd2QsIGZpbGUuc3Vic3RyKDEpKSxcbiAgICAgICAgc3luYzogdHJ1ZSxcbiAgICAgICAgbm9SZXN1bWU6IHRydWUsXG4gICAgICAgIG9uZW50cnk6IGVudHJ5ID0+IHAuYWRkKGVudHJ5KVxuICAgICAgfSlcbiAgICBlbHNlXG4gICAgICBwLmFkZChmaWxlKVxuICB9KVxuICBwLmVuZCgpXG59XG5cbmNvbnN0IGFkZEZpbGVzQXN5bmMgPSAocCwgZmlsZXMpID0+IHtcbiAgd2hpbGUgKGZpbGVzLmxlbmd0aCkge1xuICAgIGNvbnN0IGZpbGUgPSBmaWxlcy5zaGlmdCgpXG4gICAgaWYgKGZpbGUuY2hhckF0KDApID09PSAnQCcpXG4gICAgICByZXR1cm4gdCh7XG4gICAgICAgIGZpbGU6IHBhdGgucmVzb2x2ZShwLmN3ZCwgZmlsZS5zdWJzdHIoMSkpLFxuICAgICAgICBub1Jlc3VtZTogdHJ1ZSxcbiAgICAgICAgb25lbnRyeTogZW50cnkgPT4gcC5hZGQoZW50cnkpXG4gICAgICB9KS50aGVuKF8gPT4gYWRkRmlsZXNBc3luYyhwLCBmaWxlcykpXG4gICAgZWxzZVxuICAgICAgcC5hZGQoZmlsZSlcbiAgfVxuICBwLmVuZCgpXG59XG5cbmNvbnN0IGNyZWF0ZVN5bmMgPSAob3B0LCBmaWxlcykgPT4ge1xuICBjb25zdCBwID0gbmV3IFBhY2suU3luYyhvcHQpXG4gIGFkZEZpbGVzU3luYyhwLCBmaWxlcylcbiAgcmV0dXJuIHBcbn1cblxuY29uc3QgY3JlYXRlID0gKG9wdCwgZmlsZXMpID0+IHtcbiAgY29uc3QgcCA9IG5ldyBQYWNrKG9wdClcbiAgYWRkRmlsZXNBc3luYyhwLCBmaWxlcylcbiAgcmV0dXJuIHBcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/tar/lib/create.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/tar/lib/extract.js":
/*!*********************************************!*\
  !*** ../../node_modules/tar/lib/extract.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n// tar -x\nconst hlo = __webpack_require__(/*! ./high-level-opt.js */ \"(rsc)/../../node_modules/tar/lib/high-level-opt.js\")\nconst Unpack = __webpack_require__(/*! ./unpack.js */ \"(rsc)/../../node_modules/tar/lib/unpack.js\")\nconst fs = __webpack_require__(/*! fs */ \"fs\")\nconst fsm = __webpack_require__(/*! fs-minipass */ \"(rsc)/../../node_modules/fs-minipass/index.js\")\nconst path = __webpack_require__(/*! path */ \"path\")\nconst stripSlash = __webpack_require__(/*! ./strip-trailing-slashes.js */ \"(rsc)/../../node_modules/tar/lib/strip-trailing-slashes.js\")\n\nconst x = module.exports = (opt_, files, cb) => {\n  if (typeof opt_ === 'function')\n    cb = opt_, files = null, opt_ = {}\n  else if (Array.isArray(opt_))\n    files = opt_, opt_ = {}\n\n  if (typeof files === 'function')\n    cb = files, files = null\n\n  if (!files)\n    files = []\n  else\n    files = Array.from(files)\n\n  const opt = hlo(opt_)\n\n  if (opt.sync && typeof cb === 'function')\n    throw new TypeError('callback not supported for sync tar functions')\n\n  if (!opt.file && typeof cb === 'function')\n    throw new TypeError('callback only supported with file option')\n\n  if (files.length)\n    filesFilter(opt, files)\n\n  return opt.file && opt.sync ? extractFileSync(opt)\n    : opt.file ? extractFile(opt, cb)\n    : opt.sync ? extractSync(opt)\n    : extract(opt)\n}\n\n// construct a filter that limits the file entries listed\n// include child entries if a dir is included\nconst filesFilter = (opt, files) => {\n  const map = new Map(files.map(f => [stripSlash(f), true]))\n  const filter = opt.filter\n\n  const mapHas = (file, r) => {\n    const root = r || path.parse(file).root || '.'\n    const ret = file === root ? false\n      : map.has(file) ? map.get(file)\n      : mapHas(path.dirname(file), root)\n\n    map.set(file, ret)\n    return ret\n  }\n\n  opt.filter = filter\n    ? (file, entry) => filter(file, entry) && mapHas(stripSlash(file))\n    : file => mapHas(stripSlash(file))\n}\n\nconst extractFileSync = opt => {\n  const u = new Unpack.Sync(opt)\n\n  const file = opt.file\n  let threw = true\n  let fd\n  const stat = fs.statSync(file)\n  // This trades a zero-byte read() syscall for a stat\n  // However, it will usually result in less memory allocation\n  const readSize = opt.maxReadSize || 16*1024*1024\n  const stream = new fsm.ReadStreamSync(file, {\n    readSize: readSize,\n    size: stat.size\n  })\n  stream.pipe(u)\n}\n\nconst extractFile = (opt, cb) => {\n  const u = new Unpack(opt)\n  const readSize = opt.maxReadSize || 16*1024*1024\n\n  const file = opt.file\n  const p = new Promise((resolve, reject) => {\n    u.on('error', reject)\n    u.on('close', resolve)\n\n    // This trades a zero-byte read() syscall for a stat\n    // However, it will usually result in less memory allocation\n    fs.stat(file, (er, stat) => {\n      if (er)\n        reject(er)\n      else {\n        const stream = new fsm.ReadStream(file, {\n          readSize: readSize,\n          size: stat.size\n        })\n        stream.on('error', reject)\n        stream.pipe(u)\n      }\n    })\n  })\n  return cb ? p.then(cb, cb) : p\n}\n\nconst extractSync = opt => {\n  return new Unpack.Sync(opt)\n}\n\nconst extract = opt => {\n  return new Unpack(opt)\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL3Rhci9saWIvZXh0cmFjdC5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWjtBQUNBLFlBQVksbUJBQU8sQ0FBQywrRUFBcUI7QUFDekMsZUFBZSxtQkFBTyxDQUFDLCtEQUFhO0FBQ3BDLFdBQVcsbUJBQU8sQ0FBQyxjQUFJO0FBQ3ZCLFlBQVksbUJBQU8sQ0FBQyxrRUFBYTtBQUNqQyxhQUFhLG1CQUFPLENBQUMsa0JBQU07QUFDM0IsbUJBQW1CLG1CQUFPLENBQUMsK0ZBQTZCOztBQUV4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9iYXJiL2FhL0Fzc29jaWF0ZWRBY2NvdW50cy9ub2RlX21vZHVsZXMvdGFyL2xpYi9leHRyYWN0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG4vLyB0YXIgLXhcbmNvbnN0IGhsbyA9IHJlcXVpcmUoJy4vaGlnaC1sZXZlbC1vcHQuanMnKVxuY29uc3QgVW5wYWNrID0gcmVxdWlyZSgnLi91bnBhY2suanMnKVxuY29uc3QgZnMgPSByZXF1aXJlKCdmcycpXG5jb25zdCBmc20gPSByZXF1aXJlKCdmcy1taW5pcGFzcycpXG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpXG5jb25zdCBzdHJpcFNsYXNoID0gcmVxdWlyZSgnLi9zdHJpcC10cmFpbGluZy1zbGFzaGVzLmpzJylcblxuY29uc3QgeCA9IG1vZHVsZS5leHBvcnRzID0gKG9wdF8sIGZpbGVzLCBjYikgPT4ge1xuICBpZiAodHlwZW9mIG9wdF8gPT09ICdmdW5jdGlvbicpXG4gICAgY2IgPSBvcHRfLCBmaWxlcyA9IG51bGwsIG9wdF8gPSB7fVxuICBlbHNlIGlmIChBcnJheS5pc0FycmF5KG9wdF8pKVxuICAgIGZpbGVzID0gb3B0Xywgb3B0XyA9IHt9XG5cbiAgaWYgKHR5cGVvZiBmaWxlcyA9PT0gJ2Z1bmN0aW9uJylcbiAgICBjYiA9IGZpbGVzLCBmaWxlcyA9IG51bGxcblxuICBpZiAoIWZpbGVzKVxuICAgIGZpbGVzID0gW11cbiAgZWxzZVxuICAgIGZpbGVzID0gQXJyYXkuZnJvbShmaWxlcylcblxuICBjb25zdCBvcHQgPSBobG8ob3B0XylcblxuICBpZiAob3B0LnN5bmMgJiYgdHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2NhbGxiYWNrIG5vdCBzdXBwb3J0ZWQgZm9yIHN5bmMgdGFyIGZ1bmN0aW9ucycpXG5cbiAgaWYgKCFvcHQuZmlsZSAmJiB0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignY2FsbGJhY2sgb25seSBzdXBwb3J0ZWQgd2l0aCBmaWxlIG9wdGlvbicpXG5cbiAgaWYgKGZpbGVzLmxlbmd0aClcbiAgICBmaWxlc0ZpbHRlcihvcHQsIGZpbGVzKVxuXG4gIHJldHVybiBvcHQuZmlsZSAmJiBvcHQuc3luYyA/IGV4dHJhY3RGaWxlU3luYyhvcHQpXG4gICAgOiBvcHQuZmlsZSA/IGV4dHJhY3RGaWxlKG9wdCwgY2IpXG4gICAgOiBvcHQuc3luYyA/IGV4dHJhY3RTeW5jKG9wdClcbiAgICA6IGV4dHJhY3Qob3B0KVxufVxuXG4vLyBjb25zdHJ1Y3QgYSBmaWx0ZXIgdGhhdCBsaW1pdHMgdGhlIGZpbGUgZW50cmllcyBsaXN0ZWRcbi8vIGluY2x1ZGUgY2hpbGQgZW50cmllcyBpZiBhIGRpciBpcyBpbmNsdWRlZFxuY29uc3QgZmlsZXNGaWx0ZXIgPSAob3B0LCBmaWxlcykgPT4ge1xuICBjb25zdCBtYXAgPSBuZXcgTWFwKGZpbGVzLm1hcChmID0+IFtzdHJpcFNsYXNoKGYpLCB0cnVlXSkpXG4gIGNvbnN0IGZpbHRlciA9IG9wdC5maWx0ZXJcblxuICBjb25zdCBtYXBIYXMgPSAoZmlsZSwgcikgPT4ge1xuICAgIGNvbnN0IHJvb3QgPSByIHx8IHBhdGgucGFyc2UoZmlsZSkucm9vdCB8fCAnLidcbiAgICBjb25zdCByZXQgPSBmaWxlID09PSByb290ID8gZmFsc2VcbiAgICAgIDogbWFwLmhhcyhmaWxlKSA/IG1hcC5nZXQoZmlsZSlcbiAgICAgIDogbWFwSGFzKHBhdGguZGlybmFtZShmaWxlKSwgcm9vdClcblxuICAgIG1hcC5zZXQoZmlsZSwgcmV0KVxuICAgIHJldHVybiByZXRcbiAgfVxuXG4gIG9wdC5maWx0ZXIgPSBmaWx0ZXJcbiAgICA/IChmaWxlLCBlbnRyeSkgPT4gZmlsdGVyKGZpbGUsIGVudHJ5KSAmJiBtYXBIYXMoc3RyaXBTbGFzaChmaWxlKSlcbiAgICA6IGZpbGUgPT4gbWFwSGFzKHN0cmlwU2xhc2goZmlsZSkpXG59XG5cbmNvbnN0IGV4dHJhY3RGaWxlU3luYyA9IG9wdCA9PiB7XG4gIGNvbnN0IHUgPSBuZXcgVW5wYWNrLlN5bmMob3B0KVxuXG4gIGNvbnN0IGZpbGUgPSBvcHQuZmlsZVxuICBsZXQgdGhyZXcgPSB0cnVlXG4gIGxldCBmZFxuICBjb25zdCBzdGF0ID0gZnMuc3RhdFN5bmMoZmlsZSlcbiAgLy8gVGhpcyB0cmFkZXMgYSB6ZXJvLWJ5dGUgcmVhZCgpIHN5c2NhbGwgZm9yIGEgc3RhdFxuICAvLyBIb3dldmVyLCBpdCB3aWxsIHVzdWFsbHkgcmVzdWx0IGluIGxlc3MgbWVtb3J5IGFsbG9jYXRpb25cbiAgY29uc3QgcmVhZFNpemUgPSBvcHQubWF4UmVhZFNpemUgfHwgMTYqMTAyNCoxMDI0XG4gIGNvbnN0IHN0cmVhbSA9IG5ldyBmc20uUmVhZFN0cmVhbVN5bmMoZmlsZSwge1xuICAgIHJlYWRTaXplOiByZWFkU2l6ZSxcbiAgICBzaXplOiBzdGF0LnNpemVcbiAgfSlcbiAgc3RyZWFtLnBpcGUodSlcbn1cblxuY29uc3QgZXh0cmFjdEZpbGUgPSAob3B0LCBjYikgPT4ge1xuICBjb25zdCB1ID0gbmV3IFVucGFjayhvcHQpXG4gIGNvbnN0IHJlYWRTaXplID0gb3B0Lm1heFJlYWRTaXplIHx8IDE2KjEwMjQqMTAyNFxuXG4gIGNvbnN0IGZpbGUgPSBvcHQuZmlsZVxuICBjb25zdCBwID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHUub24oJ2Vycm9yJywgcmVqZWN0KVxuICAgIHUub24oJ2Nsb3NlJywgcmVzb2x2ZSlcblxuICAgIC8vIFRoaXMgdHJhZGVzIGEgemVyby1ieXRlIHJlYWQoKSBzeXNjYWxsIGZvciBhIHN0YXRcbiAgICAvLyBIb3dldmVyLCBpdCB3aWxsIHVzdWFsbHkgcmVzdWx0IGluIGxlc3MgbWVtb3J5IGFsbG9jYXRpb25cbiAgICBmcy5zdGF0KGZpbGUsIChlciwgc3RhdCkgPT4ge1xuICAgICAgaWYgKGVyKVxuICAgICAgICByZWplY3QoZXIpXG4gICAgICBlbHNlIHtcbiAgICAgICAgY29uc3Qgc3RyZWFtID0gbmV3IGZzbS5SZWFkU3RyZWFtKGZpbGUsIHtcbiAgICAgICAgICByZWFkU2l6ZTogcmVhZFNpemUsXG4gICAgICAgICAgc2l6ZTogc3RhdC5zaXplXG4gICAgICAgIH0pXG4gICAgICAgIHN0cmVhbS5vbignZXJyb3InLCByZWplY3QpXG4gICAgICAgIHN0cmVhbS5waXBlKHUpXG4gICAgICB9XG4gICAgfSlcbiAgfSlcbiAgcmV0dXJuIGNiID8gcC50aGVuKGNiLCBjYikgOiBwXG59XG5cbmNvbnN0IGV4dHJhY3RTeW5jID0gb3B0ID0+IHtcbiAgcmV0dXJuIG5ldyBVbnBhY2suU3luYyhvcHQpXG59XG5cbmNvbnN0IGV4dHJhY3QgPSBvcHQgPT4ge1xuICByZXR1cm4gbmV3IFVucGFjayhvcHQpXG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/tar/lib/extract.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/tar/lib/header.js":
/*!********************************************!*\
  !*** ../../node_modules/tar/lib/header.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n// parse a 512-byte header block to a data object, or vice-versa\n// encode returns `true` if a pax extended header is needed, because\n// the data could not be faithfully encoded in a simple header.\n// (Also, check header.needPax to see if it needs a pax header.)\n\nconst Buffer = __webpack_require__(/*! ./buffer.js */ \"(rsc)/../../node_modules/tar/lib/buffer.js\")\nconst types = __webpack_require__(/*! ./types.js */ \"(rsc)/../../node_modules/tar/lib/types.js\")\nconst pathModule = (__webpack_require__(/*! path */ \"path\").posix)\nconst large = __webpack_require__(/*! ./large-numbers.js */ \"(rsc)/../../node_modules/tar/lib/large-numbers.js\")\n\nconst SLURP = Symbol('slurp')\nconst TYPE = Symbol('type')\n\nclass Header {\n  constructor (data, off, ex, gex) {\n    this.cksumValid = false\n    this.needPax = false\n    this.nullBlock = false\n\n    this.block = null\n    this.path = null\n    this.mode = null\n    this.uid = null\n    this.gid = null\n    this.size = null\n    this.mtime = null\n    this.cksum = null\n    this[TYPE] = '0'\n    this.linkpath = null\n    this.uname = null\n    this.gname = null\n    this.devmaj = 0\n    this.devmin = 0\n    this.atime = null\n    this.ctime = null\n\n    if (Buffer.isBuffer(data))\n      this.decode(data, off || 0, ex, gex)\n    else if (data)\n      this.set(data)\n  }\n\n  decode (buf, off, ex, gex) {\n    if (!off)\n      off = 0\n\n    if (!buf || !(buf.length >= off + 512))\n      throw new Error('need 512 bytes for header')\n\n    this.path = decString(buf, off, 100)\n    this.mode = decNumber(buf, off + 100, 8)\n    this.uid = decNumber(buf, off + 108, 8)\n    this.gid = decNumber(buf, off + 116, 8)\n    this.size = decNumber(buf, off + 124, 12)\n    this.mtime = decDate(buf, off + 136, 12)\n    this.cksum = decNumber(buf, off + 148, 12)\n\n    // if we have extended or global extended headers, apply them now\n    // See https://github.com/npm/node-tar/pull/187\n    this[SLURP](ex)\n    this[SLURP](gex, true)\n\n    // old tar versions marked dirs as a file with a trailing /\n    this[TYPE] = decString(buf, off + 156, 1)\n    if (this[TYPE] === '')\n      this[TYPE] = '0'\n    if (this[TYPE] === '0' && this.path.substr(-1) === '/')\n      this[TYPE] = '5'\n\n    // tar implementations sometimes incorrectly put the stat(dir).size\n    // as the size in the tarball, even though Directory entries are\n    // not able to have any body at all.  In the very rare chance that\n    // it actually DOES have a body, we weren't going to do anything with\n    // it anyway, and it'll just be a warning about an invalid header.\n    if (this[TYPE] === '5')\n      this.size = 0\n\n    this.linkpath = decString(buf, off + 157, 100)\n    if (buf.slice(off + 257, off + 265).toString() === 'ustar\\u000000') {\n      this.uname = decString(buf, off + 265, 32)\n      this.gname = decString(buf, off + 297, 32)\n      this.devmaj = decNumber(buf, off + 329, 8)\n      this.devmin = decNumber(buf, off + 337, 8)\n      if (buf[off + 475] !== 0) {\n        // definitely a prefix, definitely >130 chars.\n        const prefix = decString(buf, off + 345, 155)\n        this.path = prefix + '/' + this.path\n      } else {\n        const prefix = decString(buf, off + 345, 130)\n        if (prefix)\n          this.path = prefix + '/' + this.path\n        this.atime = decDate(buf, off + 476, 12)\n        this.ctime = decDate(buf, off + 488, 12)\n      }\n    }\n\n    let sum = 8 * 0x20\n    for (let i = off; i < off + 148; i++) {\n      sum += buf[i]\n    }\n    for (let i = off + 156; i < off + 512; i++) {\n      sum += buf[i]\n    }\n    this.cksumValid = sum === this.cksum\n    if (this.cksum === null && sum === 8 * 0x20)\n      this.nullBlock = true\n  }\n\n  [SLURP] (ex, global) {\n    for (let k in ex) {\n      // we slurp in everything except for the path attribute in\n      // a global extended header, because that's weird.\n      if (ex[k] !== null && ex[k] !== undefined &&\n          !(global && k === 'path'))\n        this[k] = ex[k]\n    }\n  }\n\n  encode (buf, off) {\n    if (!buf) {\n      buf = this.block = Buffer.alloc(512)\n      off = 0\n    }\n\n    if (!off)\n      off = 0\n\n    if (!(buf.length >= off + 512))\n      throw new Error('need 512 bytes for header')\n\n    const prefixSize = this.ctime || this.atime ? 130 : 155\n    const split = splitPrefix(this.path || '', prefixSize)\n    const path = split[0]\n    const prefix = split[1]\n    this.needPax = split[2]\n\n    this.needPax = encString(buf, off, 100, path) || this.needPax\n    this.needPax = encNumber(buf, off + 100, 8, this.mode) || this.needPax\n    this.needPax = encNumber(buf, off + 108, 8, this.uid) || this.needPax\n    this.needPax = encNumber(buf, off + 116, 8, this.gid) || this.needPax\n    this.needPax = encNumber(buf, off + 124, 12, this.size) || this.needPax\n    this.needPax = encDate(buf, off + 136, 12, this.mtime) || this.needPax\n    buf[off + 156] = this[TYPE].charCodeAt(0)\n    this.needPax = encString(buf, off + 157, 100, this.linkpath) || this.needPax\n    buf.write('ustar\\u000000', off + 257, 8)\n    this.needPax = encString(buf, off + 265, 32, this.uname) || this.needPax\n    this.needPax = encString(buf, off + 297, 32, this.gname) || this.needPax\n    this.needPax = encNumber(buf, off + 329, 8, this.devmaj) || this.needPax\n    this.needPax = encNumber(buf, off + 337, 8, this.devmin) || this.needPax\n    this.needPax = encString(buf, off + 345, prefixSize, prefix) || this.needPax\n    if (buf[off + 475] !== 0)\n      this.needPax = encString(buf, off + 345, 155, prefix) || this.needPax\n    else {\n      this.needPax = encString(buf, off + 345, 130, prefix) || this.needPax\n      this.needPax = encDate(buf, off + 476, 12, this.atime) || this.needPax\n      this.needPax = encDate(buf, off + 488, 12, this.ctime) || this.needPax\n    }\n\n    let sum = 8 * 0x20\n    for (let i = off; i < off + 148; i++) {\n      sum += buf[i]\n    }\n    for (let i = off + 156; i < off + 512; i++) {\n      sum += buf[i]\n    }\n    this.cksum = sum\n    encNumber(buf, off + 148, 8, this.cksum)\n    this.cksumValid = true\n\n    return this.needPax\n  }\n\n  set (data) {\n    for (let i in data) {\n      if (data[i] !== null && data[i] !== undefined)\n        this[i] = data[i]\n    }\n  }\n\n  get type () {\n    return types.name.get(this[TYPE]) || this[TYPE]\n  }\n\n  get typeKey () {\n    return this[TYPE]\n  }\n\n  set type (type) {\n    if (types.code.has(type))\n      this[TYPE] = types.code.get(type)\n    else\n      this[TYPE] = type\n  }\n}\n\nconst splitPrefix = (p, prefixSize) => {\n  const pathSize = 100\n  let pp = p\n  let prefix = ''\n  let ret\n  const root = pathModule.parse(p).root || '.'\n\n  if (Buffer.byteLength(pp) < pathSize)\n    ret = [pp, prefix, false]\n  else {\n    // first set prefix to the dir, and path to the base\n    prefix = pathModule.dirname(pp)\n    pp = pathModule.basename(pp)\n\n    do {\n      // both fit!\n      if (Buffer.byteLength(pp) <= pathSize &&\n          Buffer.byteLength(prefix) <= prefixSize)\n        ret = [pp, prefix, false]\n\n      // prefix fits in prefix, but path doesn't fit in path\n      else if (Buffer.byteLength(pp) > pathSize &&\n          Buffer.byteLength(prefix) <= prefixSize)\n        ret = [pp.substr(0, pathSize - 1), prefix, true]\n\n      else {\n        // make path take a bit from prefix\n        pp = pathModule.join(pathModule.basename(prefix), pp)\n        prefix = pathModule.dirname(prefix)\n      }\n    } while (prefix !== root && !ret)\n\n    // at this point, found no resolution, just truncate\n    if (!ret)\n      ret = [p.substr(0, pathSize - 1), '', true]\n  }\n  return ret\n}\n\nconst decString = (buf, off, size) =>\n  buf.slice(off, off + size).toString('utf8').replace(/\\0.*/, '')\n\nconst decDate = (buf, off, size) =>\n  numToDate(decNumber(buf, off, size))\n\nconst numToDate = num => num === null ? null : new Date(num * 1000)\n\nconst decNumber = (buf, off, size) =>\n  buf[off] & 0x80 ? large.parse(buf.slice(off, off + size))\n    : decSmallNumber(buf, off, size)\n\nconst nanNull = value => isNaN(value) ? null : value\n\nconst decSmallNumber = (buf, off, size) =>\n  nanNull(parseInt(\n    buf.slice(off, off + size)\n      .toString('utf8').replace(/\\0.*$/, '').trim(), 8))\n\n// the maximum encodable as a null-terminated octal, by field size\nconst MAXNUM = {\n  12: 0o77777777777,\n  8 : 0o7777777\n}\n\nconst encNumber = (buf, off, size, number) =>\n  number === null ? false :\n  number > MAXNUM[size] || number < 0\n    ? (large.encode(number, buf.slice(off, off + size)), true)\n    : (encSmallNumber(buf, off, size, number), false)\n\nconst encSmallNumber = (buf, off, size, number) =>\n  buf.write(octalString(number, size), off, size, 'ascii')\n\nconst octalString = (number, size) =>\n  padOctal(Math.floor(number).toString(8), size)\n\nconst padOctal = (string, size) =>\n  (string.length === size - 1 ? string\n  : new Array(size - string.length - 1).join('0') + string + ' ') + '\\0'\n\nconst encDate = (buf, off, size, date) =>\n  date === null ? false :\n  encNumber(buf, off, size, date.getTime() / 1000)\n\n// enough to fill the longest string we've got\nconst NULLS = new Array(156).join('\\0')\n// pad with nulls, return true if it's longer or non-ascii\nconst encString = (buf, off, size, string) =>\n  string === null ? false :\n  (buf.write(string + NULLS, off, size, 'utf8'),\n   string.length !== Buffer.byteLength(string) || string.length > size)\n\nmodule.exports = Header\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL3Rhci9saWIvaGVhZGVyLmpzIiwibWFwcGluZ3MiOiJBQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZSxtQkFBTyxDQUFDLCtEQUFhO0FBQ3BDLGNBQWMsbUJBQU8sQ0FBQyw2REFBWTtBQUNsQyxtQkFBbUIsK0NBQXFCO0FBQ3hDLGNBQWMsbUJBQU8sQ0FBQyw2RUFBb0I7O0FBRTFDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQixlQUFlO0FBQ3JDO0FBQ0E7QUFDQSw0QkFBNEIsZUFBZTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCLGVBQWU7QUFDckM7QUFDQTtBQUNBLDRCQUE0QixlQUFlO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyIvaG9tZS9iYXJiL2FhL0Fzc29jaWF0ZWRBY2NvdW50cy9ub2RlX21vZHVsZXMvdGFyL2xpYi9oZWFkZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG4vLyBwYXJzZSBhIDUxMi1ieXRlIGhlYWRlciBibG9jayB0byBhIGRhdGEgb2JqZWN0LCBvciB2aWNlLXZlcnNhXG4vLyBlbmNvZGUgcmV0dXJucyBgdHJ1ZWAgaWYgYSBwYXggZXh0ZW5kZWQgaGVhZGVyIGlzIG5lZWRlZCwgYmVjYXVzZVxuLy8gdGhlIGRhdGEgY291bGQgbm90IGJlIGZhaXRoZnVsbHkgZW5jb2RlZCBpbiBhIHNpbXBsZSBoZWFkZXIuXG4vLyAoQWxzbywgY2hlY2sgaGVhZGVyLm5lZWRQYXggdG8gc2VlIGlmIGl0IG5lZWRzIGEgcGF4IGhlYWRlci4pXG5cbmNvbnN0IEJ1ZmZlciA9IHJlcXVpcmUoJy4vYnVmZmVyLmpzJylcbmNvbnN0IHR5cGVzID0gcmVxdWlyZSgnLi90eXBlcy5qcycpXG5jb25zdCBwYXRoTW9kdWxlID0gcmVxdWlyZSgncGF0aCcpLnBvc2l4XG5jb25zdCBsYXJnZSA9IHJlcXVpcmUoJy4vbGFyZ2UtbnVtYmVycy5qcycpXG5cbmNvbnN0IFNMVVJQID0gU3ltYm9sKCdzbHVycCcpXG5jb25zdCBUWVBFID0gU3ltYm9sKCd0eXBlJylcblxuY2xhc3MgSGVhZGVyIHtcbiAgY29uc3RydWN0b3IgKGRhdGEsIG9mZiwgZXgsIGdleCkge1xuICAgIHRoaXMuY2tzdW1WYWxpZCA9IGZhbHNlXG4gICAgdGhpcy5uZWVkUGF4ID0gZmFsc2VcbiAgICB0aGlzLm51bGxCbG9jayA9IGZhbHNlXG5cbiAgICB0aGlzLmJsb2NrID0gbnVsbFxuICAgIHRoaXMucGF0aCA9IG51bGxcbiAgICB0aGlzLm1vZGUgPSBudWxsXG4gICAgdGhpcy51aWQgPSBudWxsXG4gICAgdGhpcy5naWQgPSBudWxsXG4gICAgdGhpcy5zaXplID0gbnVsbFxuICAgIHRoaXMubXRpbWUgPSBudWxsXG4gICAgdGhpcy5ja3N1bSA9IG51bGxcbiAgICB0aGlzW1RZUEVdID0gJzAnXG4gICAgdGhpcy5saW5rcGF0aCA9IG51bGxcbiAgICB0aGlzLnVuYW1lID0gbnVsbFxuICAgIHRoaXMuZ25hbWUgPSBudWxsXG4gICAgdGhpcy5kZXZtYWogPSAwXG4gICAgdGhpcy5kZXZtaW4gPSAwXG4gICAgdGhpcy5hdGltZSA9IG51bGxcbiAgICB0aGlzLmN0aW1lID0gbnVsbFxuXG4gICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihkYXRhKSlcbiAgICAgIHRoaXMuZGVjb2RlKGRhdGEsIG9mZiB8fCAwLCBleCwgZ2V4KVxuICAgIGVsc2UgaWYgKGRhdGEpXG4gICAgICB0aGlzLnNldChkYXRhKVxuICB9XG5cbiAgZGVjb2RlIChidWYsIG9mZiwgZXgsIGdleCkge1xuICAgIGlmICghb2ZmKVxuICAgICAgb2ZmID0gMFxuXG4gICAgaWYgKCFidWYgfHwgIShidWYubGVuZ3RoID49IG9mZiArIDUxMikpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ25lZWQgNTEyIGJ5dGVzIGZvciBoZWFkZXInKVxuXG4gICAgdGhpcy5wYXRoID0gZGVjU3RyaW5nKGJ1Ziwgb2ZmLCAxMDApXG4gICAgdGhpcy5tb2RlID0gZGVjTnVtYmVyKGJ1Ziwgb2ZmICsgMTAwLCA4KVxuICAgIHRoaXMudWlkID0gZGVjTnVtYmVyKGJ1Ziwgb2ZmICsgMTA4LCA4KVxuICAgIHRoaXMuZ2lkID0gZGVjTnVtYmVyKGJ1Ziwgb2ZmICsgMTE2LCA4KVxuICAgIHRoaXMuc2l6ZSA9IGRlY051bWJlcihidWYsIG9mZiArIDEyNCwgMTIpXG4gICAgdGhpcy5tdGltZSA9IGRlY0RhdGUoYnVmLCBvZmYgKyAxMzYsIDEyKVxuICAgIHRoaXMuY2tzdW0gPSBkZWNOdW1iZXIoYnVmLCBvZmYgKyAxNDgsIDEyKVxuXG4gICAgLy8gaWYgd2UgaGF2ZSBleHRlbmRlZCBvciBnbG9iYWwgZXh0ZW5kZWQgaGVhZGVycywgYXBwbHkgdGhlbSBub3dcbiAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL25wbS9ub2RlLXRhci9wdWxsLzE4N1xuICAgIHRoaXNbU0xVUlBdKGV4KVxuICAgIHRoaXNbU0xVUlBdKGdleCwgdHJ1ZSlcblxuICAgIC8vIG9sZCB0YXIgdmVyc2lvbnMgbWFya2VkIGRpcnMgYXMgYSBmaWxlIHdpdGggYSB0cmFpbGluZyAvXG4gICAgdGhpc1tUWVBFXSA9IGRlY1N0cmluZyhidWYsIG9mZiArIDE1NiwgMSlcbiAgICBpZiAodGhpc1tUWVBFXSA9PT0gJycpXG4gICAgICB0aGlzW1RZUEVdID0gJzAnXG4gICAgaWYgKHRoaXNbVFlQRV0gPT09ICcwJyAmJiB0aGlzLnBhdGguc3Vic3RyKC0xKSA9PT0gJy8nKVxuICAgICAgdGhpc1tUWVBFXSA9ICc1J1xuXG4gICAgLy8gdGFyIGltcGxlbWVudGF0aW9ucyBzb21ldGltZXMgaW5jb3JyZWN0bHkgcHV0IHRoZSBzdGF0KGRpcikuc2l6ZVxuICAgIC8vIGFzIHRoZSBzaXplIGluIHRoZSB0YXJiYWxsLCBldmVuIHRob3VnaCBEaXJlY3RvcnkgZW50cmllcyBhcmVcbiAgICAvLyBub3QgYWJsZSB0byBoYXZlIGFueSBib2R5IGF0IGFsbC4gIEluIHRoZSB2ZXJ5IHJhcmUgY2hhbmNlIHRoYXRcbiAgICAvLyBpdCBhY3R1YWxseSBET0VTIGhhdmUgYSBib2R5LCB3ZSB3ZXJlbid0IGdvaW5nIHRvIGRvIGFueXRoaW5nIHdpdGhcbiAgICAvLyBpdCBhbnl3YXksIGFuZCBpdCdsbCBqdXN0IGJlIGEgd2FybmluZyBhYm91dCBhbiBpbnZhbGlkIGhlYWRlci5cbiAgICBpZiAodGhpc1tUWVBFXSA9PT0gJzUnKVxuICAgICAgdGhpcy5zaXplID0gMFxuXG4gICAgdGhpcy5saW5rcGF0aCA9IGRlY1N0cmluZyhidWYsIG9mZiArIDE1NywgMTAwKVxuICAgIGlmIChidWYuc2xpY2Uob2ZmICsgMjU3LCBvZmYgKyAyNjUpLnRvU3RyaW5nKCkgPT09ICd1c3RhclxcdTAwMDAwMCcpIHtcbiAgICAgIHRoaXMudW5hbWUgPSBkZWNTdHJpbmcoYnVmLCBvZmYgKyAyNjUsIDMyKVxuICAgICAgdGhpcy5nbmFtZSA9IGRlY1N0cmluZyhidWYsIG9mZiArIDI5NywgMzIpXG4gICAgICB0aGlzLmRldm1haiA9IGRlY051bWJlcihidWYsIG9mZiArIDMyOSwgOClcbiAgICAgIHRoaXMuZGV2bWluID0gZGVjTnVtYmVyKGJ1Ziwgb2ZmICsgMzM3LCA4KVxuICAgICAgaWYgKGJ1ZltvZmYgKyA0NzVdICE9PSAwKSB7XG4gICAgICAgIC8vIGRlZmluaXRlbHkgYSBwcmVmaXgsIGRlZmluaXRlbHkgPjEzMCBjaGFycy5cbiAgICAgICAgY29uc3QgcHJlZml4ID0gZGVjU3RyaW5nKGJ1Ziwgb2ZmICsgMzQ1LCAxNTUpXG4gICAgICAgIHRoaXMucGF0aCA9IHByZWZpeCArICcvJyArIHRoaXMucGF0aFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgcHJlZml4ID0gZGVjU3RyaW5nKGJ1Ziwgb2ZmICsgMzQ1LCAxMzApXG4gICAgICAgIGlmIChwcmVmaXgpXG4gICAgICAgICAgdGhpcy5wYXRoID0gcHJlZml4ICsgJy8nICsgdGhpcy5wYXRoXG4gICAgICAgIHRoaXMuYXRpbWUgPSBkZWNEYXRlKGJ1Ziwgb2ZmICsgNDc2LCAxMilcbiAgICAgICAgdGhpcy5jdGltZSA9IGRlY0RhdGUoYnVmLCBvZmYgKyA0ODgsIDEyKVxuICAgICAgfVxuICAgIH1cblxuICAgIGxldCBzdW0gPSA4ICogMHgyMFxuICAgIGZvciAobGV0IGkgPSBvZmY7IGkgPCBvZmYgKyAxNDg7IGkrKykge1xuICAgICAgc3VtICs9IGJ1ZltpXVxuICAgIH1cbiAgICBmb3IgKGxldCBpID0gb2ZmICsgMTU2OyBpIDwgb2ZmICsgNTEyOyBpKyspIHtcbiAgICAgIHN1bSArPSBidWZbaV1cbiAgICB9XG4gICAgdGhpcy5ja3N1bVZhbGlkID0gc3VtID09PSB0aGlzLmNrc3VtXG4gICAgaWYgKHRoaXMuY2tzdW0gPT09IG51bGwgJiYgc3VtID09PSA4ICogMHgyMClcbiAgICAgIHRoaXMubnVsbEJsb2NrID0gdHJ1ZVxuICB9XG5cbiAgW1NMVVJQXSAoZXgsIGdsb2JhbCkge1xuICAgIGZvciAobGV0IGsgaW4gZXgpIHtcbiAgICAgIC8vIHdlIHNsdXJwIGluIGV2ZXJ5dGhpbmcgZXhjZXB0IGZvciB0aGUgcGF0aCBhdHRyaWJ1dGUgaW5cbiAgICAgIC8vIGEgZ2xvYmFsIGV4dGVuZGVkIGhlYWRlciwgYmVjYXVzZSB0aGF0J3Mgd2VpcmQuXG4gICAgICBpZiAoZXhba10gIT09IG51bGwgJiYgZXhba10gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICEoZ2xvYmFsICYmIGsgPT09ICdwYXRoJykpXG4gICAgICAgIHRoaXNba10gPSBleFtrXVxuICAgIH1cbiAgfVxuXG4gIGVuY29kZSAoYnVmLCBvZmYpIHtcbiAgICBpZiAoIWJ1Zikge1xuICAgICAgYnVmID0gdGhpcy5ibG9jayA9IEJ1ZmZlci5hbGxvYyg1MTIpXG4gICAgICBvZmYgPSAwXG4gICAgfVxuXG4gICAgaWYgKCFvZmYpXG4gICAgICBvZmYgPSAwXG5cbiAgICBpZiAoIShidWYubGVuZ3RoID49IG9mZiArIDUxMikpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ25lZWQgNTEyIGJ5dGVzIGZvciBoZWFkZXInKVxuXG4gICAgY29uc3QgcHJlZml4U2l6ZSA9IHRoaXMuY3RpbWUgfHwgdGhpcy5hdGltZSA/IDEzMCA6IDE1NVxuICAgIGNvbnN0IHNwbGl0ID0gc3BsaXRQcmVmaXgodGhpcy5wYXRoIHx8ICcnLCBwcmVmaXhTaXplKVxuICAgIGNvbnN0IHBhdGggPSBzcGxpdFswXVxuICAgIGNvbnN0IHByZWZpeCA9IHNwbGl0WzFdXG4gICAgdGhpcy5uZWVkUGF4ID0gc3BsaXRbMl1cblxuICAgIHRoaXMubmVlZFBheCA9IGVuY1N0cmluZyhidWYsIG9mZiwgMTAwLCBwYXRoKSB8fCB0aGlzLm5lZWRQYXhcbiAgICB0aGlzLm5lZWRQYXggPSBlbmNOdW1iZXIoYnVmLCBvZmYgKyAxMDAsIDgsIHRoaXMubW9kZSkgfHwgdGhpcy5uZWVkUGF4XG4gICAgdGhpcy5uZWVkUGF4ID0gZW5jTnVtYmVyKGJ1Ziwgb2ZmICsgMTA4LCA4LCB0aGlzLnVpZCkgfHwgdGhpcy5uZWVkUGF4XG4gICAgdGhpcy5uZWVkUGF4ID0gZW5jTnVtYmVyKGJ1Ziwgb2ZmICsgMTE2LCA4LCB0aGlzLmdpZCkgfHwgdGhpcy5uZWVkUGF4XG4gICAgdGhpcy5uZWVkUGF4ID0gZW5jTnVtYmVyKGJ1Ziwgb2ZmICsgMTI0LCAxMiwgdGhpcy5zaXplKSB8fCB0aGlzLm5lZWRQYXhcbiAgICB0aGlzLm5lZWRQYXggPSBlbmNEYXRlKGJ1Ziwgb2ZmICsgMTM2LCAxMiwgdGhpcy5tdGltZSkgfHwgdGhpcy5uZWVkUGF4XG4gICAgYnVmW29mZiArIDE1Nl0gPSB0aGlzW1RZUEVdLmNoYXJDb2RlQXQoMClcbiAgICB0aGlzLm5lZWRQYXggPSBlbmNTdHJpbmcoYnVmLCBvZmYgKyAxNTcsIDEwMCwgdGhpcy5saW5rcGF0aCkgfHwgdGhpcy5uZWVkUGF4XG4gICAgYnVmLndyaXRlKCd1c3RhclxcdTAwMDAwMCcsIG9mZiArIDI1NywgOClcbiAgICB0aGlzLm5lZWRQYXggPSBlbmNTdHJpbmcoYnVmLCBvZmYgKyAyNjUsIDMyLCB0aGlzLnVuYW1lKSB8fCB0aGlzLm5lZWRQYXhcbiAgICB0aGlzLm5lZWRQYXggPSBlbmNTdHJpbmcoYnVmLCBvZmYgKyAyOTcsIDMyLCB0aGlzLmduYW1lKSB8fCB0aGlzLm5lZWRQYXhcbiAgICB0aGlzLm5lZWRQYXggPSBlbmNOdW1iZXIoYnVmLCBvZmYgKyAzMjksIDgsIHRoaXMuZGV2bWFqKSB8fCB0aGlzLm5lZWRQYXhcbiAgICB0aGlzLm5lZWRQYXggPSBlbmNOdW1iZXIoYnVmLCBvZmYgKyAzMzcsIDgsIHRoaXMuZGV2bWluKSB8fCB0aGlzLm5lZWRQYXhcbiAgICB0aGlzLm5lZWRQYXggPSBlbmNTdHJpbmcoYnVmLCBvZmYgKyAzNDUsIHByZWZpeFNpemUsIHByZWZpeCkgfHwgdGhpcy5uZWVkUGF4XG4gICAgaWYgKGJ1ZltvZmYgKyA0NzVdICE9PSAwKVxuICAgICAgdGhpcy5uZWVkUGF4ID0gZW5jU3RyaW5nKGJ1Ziwgb2ZmICsgMzQ1LCAxNTUsIHByZWZpeCkgfHwgdGhpcy5uZWVkUGF4XG4gICAgZWxzZSB7XG4gICAgICB0aGlzLm5lZWRQYXggPSBlbmNTdHJpbmcoYnVmLCBvZmYgKyAzNDUsIDEzMCwgcHJlZml4KSB8fCB0aGlzLm5lZWRQYXhcbiAgICAgIHRoaXMubmVlZFBheCA9IGVuY0RhdGUoYnVmLCBvZmYgKyA0NzYsIDEyLCB0aGlzLmF0aW1lKSB8fCB0aGlzLm5lZWRQYXhcbiAgICAgIHRoaXMubmVlZFBheCA9IGVuY0RhdGUoYnVmLCBvZmYgKyA0ODgsIDEyLCB0aGlzLmN0aW1lKSB8fCB0aGlzLm5lZWRQYXhcbiAgICB9XG5cbiAgICBsZXQgc3VtID0gOCAqIDB4MjBcbiAgICBmb3IgKGxldCBpID0gb2ZmOyBpIDwgb2ZmICsgMTQ4OyBpKyspIHtcbiAgICAgIHN1bSArPSBidWZbaV1cbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IG9mZiArIDE1NjsgaSA8IG9mZiArIDUxMjsgaSsrKSB7XG4gICAgICBzdW0gKz0gYnVmW2ldXG4gICAgfVxuICAgIHRoaXMuY2tzdW0gPSBzdW1cbiAgICBlbmNOdW1iZXIoYnVmLCBvZmYgKyAxNDgsIDgsIHRoaXMuY2tzdW0pXG4gICAgdGhpcy5ja3N1bVZhbGlkID0gdHJ1ZVxuXG4gICAgcmV0dXJuIHRoaXMubmVlZFBheFxuICB9XG5cbiAgc2V0IChkYXRhKSB7XG4gICAgZm9yIChsZXQgaSBpbiBkYXRhKSB7XG4gICAgICBpZiAoZGF0YVtpXSAhPT0gbnVsbCAmJiBkYXRhW2ldICE9PSB1bmRlZmluZWQpXG4gICAgICAgIHRoaXNbaV0gPSBkYXRhW2ldXG4gICAgfVxuICB9XG5cbiAgZ2V0IHR5cGUgKCkge1xuICAgIHJldHVybiB0eXBlcy5uYW1lLmdldCh0aGlzW1RZUEVdKSB8fCB0aGlzW1RZUEVdXG4gIH1cblxuICBnZXQgdHlwZUtleSAoKSB7XG4gICAgcmV0dXJuIHRoaXNbVFlQRV1cbiAgfVxuXG4gIHNldCB0eXBlICh0eXBlKSB7XG4gICAgaWYgKHR5cGVzLmNvZGUuaGFzKHR5cGUpKVxuICAgICAgdGhpc1tUWVBFXSA9IHR5cGVzLmNvZGUuZ2V0KHR5cGUpXG4gICAgZWxzZVxuICAgICAgdGhpc1tUWVBFXSA9IHR5cGVcbiAgfVxufVxuXG5jb25zdCBzcGxpdFByZWZpeCA9IChwLCBwcmVmaXhTaXplKSA9PiB7XG4gIGNvbnN0IHBhdGhTaXplID0gMTAwXG4gIGxldCBwcCA9IHBcbiAgbGV0IHByZWZpeCA9ICcnXG4gIGxldCByZXRcbiAgY29uc3Qgcm9vdCA9IHBhdGhNb2R1bGUucGFyc2UocCkucm9vdCB8fCAnLidcblxuICBpZiAoQnVmZmVyLmJ5dGVMZW5ndGgocHApIDwgcGF0aFNpemUpXG4gICAgcmV0ID0gW3BwLCBwcmVmaXgsIGZhbHNlXVxuICBlbHNlIHtcbiAgICAvLyBmaXJzdCBzZXQgcHJlZml4IHRvIHRoZSBkaXIsIGFuZCBwYXRoIHRvIHRoZSBiYXNlXG4gICAgcHJlZml4ID0gcGF0aE1vZHVsZS5kaXJuYW1lKHBwKVxuICAgIHBwID0gcGF0aE1vZHVsZS5iYXNlbmFtZShwcClcblxuICAgIGRvIHtcbiAgICAgIC8vIGJvdGggZml0IVxuICAgICAgaWYgKEJ1ZmZlci5ieXRlTGVuZ3RoKHBwKSA8PSBwYXRoU2l6ZSAmJlxuICAgICAgICAgIEJ1ZmZlci5ieXRlTGVuZ3RoKHByZWZpeCkgPD0gcHJlZml4U2l6ZSlcbiAgICAgICAgcmV0ID0gW3BwLCBwcmVmaXgsIGZhbHNlXVxuXG4gICAgICAvLyBwcmVmaXggZml0cyBpbiBwcmVmaXgsIGJ1dCBwYXRoIGRvZXNuJ3QgZml0IGluIHBhdGhcbiAgICAgIGVsc2UgaWYgKEJ1ZmZlci5ieXRlTGVuZ3RoKHBwKSA+IHBhdGhTaXplICYmXG4gICAgICAgICAgQnVmZmVyLmJ5dGVMZW5ndGgocHJlZml4KSA8PSBwcmVmaXhTaXplKVxuICAgICAgICByZXQgPSBbcHAuc3Vic3RyKDAsIHBhdGhTaXplIC0gMSksIHByZWZpeCwgdHJ1ZV1cblxuICAgICAgZWxzZSB7XG4gICAgICAgIC8vIG1ha2UgcGF0aCB0YWtlIGEgYml0IGZyb20gcHJlZml4XG4gICAgICAgIHBwID0gcGF0aE1vZHVsZS5qb2luKHBhdGhNb2R1bGUuYmFzZW5hbWUocHJlZml4KSwgcHApXG4gICAgICAgIHByZWZpeCA9IHBhdGhNb2R1bGUuZGlybmFtZShwcmVmaXgpXG4gICAgICB9XG4gICAgfSB3aGlsZSAocHJlZml4ICE9PSByb290ICYmICFyZXQpXG5cbiAgICAvLyBhdCB0aGlzIHBvaW50LCBmb3VuZCBubyByZXNvbHV0aW9uLCBqdXN0IHRydW5jYXRlXG4gICAgaWYgKCFyZXQpXG4gICAgICByZXQgPSBbcC5zdWJzdHIoMCwgcGF0aFNpemUgLSAxKSwgJycsIHRydWVdXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5jb25zdCBkZWNTdHJpbmcgPSAoYnVmLCBvZmYsIHNpemUpID0+XG4gIGJ1Zi5zbGljZShvZmYsIG9mZiArIHNpemUpLnRvU3RyaW5nKCd1dGY4JykucmVwbGFjZSgvXFwwLiovLCAnJylcblxuY29uc3QgZGVjRGF0ZSA9IChidWYsIG9mZiwgc2l6ZSkgPT5cbiAgbnVtVG9EYXRlKGRlY051bWJlcihidWYsIG9mZiwgc2l6ZSkpXG5cbmNvbnN0IG51bVRvRGF0ZSA9IG51bSA9PiBudW0gPT09IG51bGwgPyBudWxsIDogbmV3IERhdGUobnVtICogMTAwMClcblxuY29uc3QgZGVjTnVtYmVyID0gKGJ1Ziwgb2ZmLCBzaXplKSA9PlxuICBidWZbb2ZmXSAmIDB4ODAgPyBsYXJnZS5wYXJzZShidWYuc2xpY2Uob2ZmLCBvZmYgKyBzaXplKSlcbiAgICA6IGRlY1NtYWxsTnVtYmVyKGJ1Ziwgb2ZmLCBzaXplKVxuXG5jb25zdCBuYW5OdWxsID0gdmFsdWUgPT4gaXNOYU4odmFsdWUpID8gbnVsbCA6IHZhbHVlXG5cbmNvbnN0IGRlY1NtYWxsTnVtYmVyID0gKGJ1Ziwgb2ZmLCBzaXplKSA9PlxuICBuYW5OdWxsKHBhcnNlSW50KFxuICAgIGJ1Zi5zbGljZShvZmYsIG9mZiArIHNpemUpXG4gICAgICAudG9TdHJpbmcoJ3V0ZjgnKS5yZXBsYWNlKC9cXDAuKiQvLCAnJykudHJpbSgpLCA4KSlcblxuLy8gdGhlIG1heGltdW0gZW5jb2RhYmxlIGFzIGEgbnVsbC10ZXJtaW5hdGVkIG9jdGFsLCBieSBmaWVsZCBzaXplXG5jb25zdCBNQVhOVU0gPSB7XG4gIDEyOiAwbzc3Nzc3Nzc3Nzc3LFxuICA4IDogMG83Nzc3Nzc3XG59XG5cbmNvbnN0IGVuY051bWJlciA9IChidWYsIG9mZiwgc2l6ZSwgbnVtYmVyKSA9PlxuICBudW1iZXIgPT09IG51bGwgPyBmYWxzZSA6XG4gIG51bWJlciA+IE1BWE5VTVtzaXplXSB8fCBudW1iZXIgPCAwXG4gICAgPyAobGFyZ2UuZW5jb2RlKG51bWJlciwgYnVmLnNsaWNlKG9mZiwgb2ZmICsgc2l6ZSkpLCB0cnVlKVxuICAgIDogKGVuY1NtYWxsTnVtYmVyKGJ1Ziwgb2ZmLCBzaXplLCBudW1iZXIpLCBmYWxzZSlcblxuY29uc3QgZW5jU21hbGxOdW1iZXIgPSAoYnVmLCBvZmYsIHNpemUsIG51bWJlcikgPT5cbiAgYnVmLndyaXRlKG9jdGFsU3RyaW5nKG51bWJlciwgc2l6ZSksIG9mZiwgc2l6ZSwgJ2FzY2lpJylcblxuY29uc3Qgb2N0YWxTdHJpbmcgPSAobnVtYmVyLCBzaXplKSA9PlxuICBwYWRPY3RhbChNYXRoLmZsb29yKG51bWJlcikudG9TdHJpbmcoOCksIHNpemUpXG5cbmNvbnN0IHBhZE9jdGFsID0gKHN0cmluZywgc2l6ZSkgPT5cbiAgKHN0cmluZy5sZW5ndGggPT09IHNpemUgLSAxID8gc3RyaW5nXG4gIDogbmV3IEFycmF5KHNpemUgLSBzdHJpbmcubGVuZ3RoIC0gMSkuam9pbignMCcpICsgc3RyaW5nICsgJyAnKSArICdcXDAnXG5cbmNvbnN0IGVuY0RhdGUgPSAoYnVmLCBvZmYsIHNpemUsIGRhdGUpID0+XG4gIGRhdGUgPT09IG51bGwgPyBmYWxzZSA6XG4gIGVuY051bWJlcihidWYsIG9mZiwgc2l6ZSwgZGF0ZS5nZXRUaW1lKCkgLyAxMDAwKVxuXG4vLyBlbm91Z2ggdG8gZmlsbCB0aGUgbG9uZ2VzdCBzdHJpbmcgd2UndmUgZ290XG5jb25zdCBOVUxMUyA9IG5ldyBBcnJheSgxNTYpLmpvaW4oJ1xcMCcpXG4vLyBwYWQgd2l0aCBudWxscywgcmV0dXJuIHRydWUgaWYgaXQncyBsb25nZXIgb3Igbm9uLWFzY2lpXG5jb25zdCBlbmNTdHJpbmcgPSAoYnVmLCBvZmYsIHNpemUsIHN0cmluZykgPT5cbiAgc3RyaW5nID09PSBudWxsID8gZmFsc2UgOlxuICAoYnVmLndyaXRlKHN0cmluZyArIE5VTExTLCBvZmYsIHNpemUsICd1dGY4JyksXG4gICBzdHJpbmcubGVuZ3RoICE9PSBCdWZmZXIuYnl0ZUxlbmd0aChzdHJpbmcpIHx8IHN0cmluZy5sZW5ndGggPiBzaXplKVxuXG5tb2R1bGUuZXhwb3J0cyA9IEhlYWRlclxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/tar/lib/header.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/tar/lib/high-level-opt.js":
/*!****************************************************!*\
  !*** ../../node_modules/tar/lib/high-level-opt.js ***!
  \****************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n// turn tar(1) style args like `C` into the more verbose things like `cwd`\n\nconst argmap = new Map([\n  ['C', 'cwd'],\n  ['f', 'file'],\n  ['z', 'gzip'],\n  ['P', 'preservePaths'],\n  ['U', 'unlink'],\n  ['strip-components', 'strip'],\n  ['stripComponents', 'strip'],\n  ['keep-newer', 'newer'],\n  ['keepNewer', 'newer'],\n  ['keep-newer-files', 'newer'],\n  ['keepNewerFiles', 'newer'],\n  ['k', 'keep'],\n  ['keep-existing', 'keep'],\n  ['keepExisting', 'keep'],\n  ['m', 'noMtime'],\n  ['no-mtime', 'noMtime'],\n  ['p', 'preserveOwner'],\n  ['L', 'follow'],\n  ['h', 'follow']\n])\n\nconst parse = module.exports = opt => opt ? Object.keys(opt).map(k => [\n  argmap.has(k) ? argmap.get(k) : k, opt[k]\n]).reduce((set, kv) => (set[kv[0]] = kv[1], set), Object.create(null)) : {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL3Rhci9saWIvaGlnaC1sZXZlbC1vcHQuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVo7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvYmFyYi9hYS9Bc3NvY2lhdGVkQWNjb3VudHMvbm9kZV9tb2R1bGVzL3Rhci9saWIvaGlnaC1sZXZlbC1vcHQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbi8vIHR1cm4gdGFyKDEpIHN0eWxlIGFyZ3MgbGlrZSBgQ2AgaW50byB0aGUgbW9yZSB2ZXJib3NlIHRoaW5ncyBsaWtlIGBjd2RgXG5cbmNvbnN0IGFyZ21hcCA9IG5ldyBNYXAoW1xuICBbJ0MnLCAnY3dkJ10sXG4gIFsnZicsICdmaWxlJ10sXG4gIFsneicsICdnemlwJ10sXG4gIFsnUCcsICdwcmVzZXJ2ZVBhdGhzJ10sXG4gIFsnVScsICd1bmxpbmsnXSxcbiAgWydzdHJpcC1jb21wb25lbnRzJywgJ3N0cmlwJ10sXG4gIFsnc3RyaXBDb21wb25lbnRzJywgJ3N0cmlwJ10sXG4gIFsna2VlcC1uZXdlcicsICduZXdlciddLFxuICBbJ2tlZXBOZXdlcicsICduZXdlciddLFxuICBbJ2tlZXAtbmV3ZXItZmlsZXMnLCAnbmV3ZXInXSxcbiAgWydrZWVwTmV3ZXJGaWxlcycsICduZXdlciddLFxuICBbJ2snLCAna2VlcCddLFxuICBbJ2tlZXAtZXhpc3RpbmcnLCAna2VlcCddLFxuICBbJ2tlZXBFeGlzdGluZycsICdrZWVwJ10sXG4gIFsnbScsICdub010aW1lJ10sXG4gIFsnbm8tbXRpbWUnLCAnbm9NdGltZSddLFxuICBbJ3AnLCAncHJlc2VydmVPd25lciddLFxuICBbJ0wnLCAnZm9sbG93J10sXG4gIFsnaCcsICdmb2xsb3cnXVxuXSlcblxuY29uc3QgcGFyc2UgPSBtb2R1bGUuZXhwb3J0cyA9IG9wdCA9PiBvcHQgPyBPYmplY3Qua2V5cyhvcHQpLm1hcChrID0+IFtcbiAgYXJnbWFwLmhhcyhrKSA/IGFyZ21hcC5nZXQoaykgOiBrLCBvcHRba11cbl0pLnJlZHVjZSgoc2V0LCBrdikgPT4gKHNldFtrdlswXV0gPSBrdlsxXSwgc2V0KSwgT2JqZWN0LmNyZWF0ZShudWxsKSkgOiB7fVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/tar/lib/high-level-opt.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/tar/lib/large-numbers.js":
/*!***************************************************!*\
  !*** ../../node_modules/tar/lib/large-numbers.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n// Tar can encode large and negative numbers using a leading byte of\n// 0xff for negative, and 0x80 for positive.\n\nconst encode = exports.encode = (num, buf) => {\n  if (!Number.isSafeInteger(num))\n    // The number is so large that javascript cannot represent it with integer\n    // precision.\n    throw TypeError('cannot encode number outside of javascript safe integer range')\n  else if (num < 0)\n    encodeNegative(num, buf)\n  else\n    encodePositive(num, buf)\n  return buf\n}\n\nconst encodePositive = (num, buf) => {\n  buf[0] = 0x80\n\n  for (var i = buf.length; i > 1; i--) {\n    buf[i-1] = num & 0xff\n    num = Math.floor(num / 0x100)\n  }\n}\n\nconst encodeNegative = (num, buf) => {\n  buf[0] = 0xff\n  var flipped = false\n  num = num * -1\n  for (var i = buf.length; i > 1; i--) {\n    var byte = num & 0xff\n    num = Math.floor(num / 0x100)\n    if (flipped)\n      buf[i-1] = onesComp(byte)\n    else if (byte === 0)\n      buf[i-1] = 0\n    else {\n      flipped = true\n      buf[i-1] = twosComp(byte)\n    }\n  }\n}\n\nconst parse = exports.parse = (buf) => {\n  var post = buf[buf.length - 1]\n  var pre = buf[0]\n  var value;\n  if (pre === 0x80)\n    value = pos(buf.slice(1, buf.length))\n  else if (pre === 0xff)\n    value = twos(buf)\n  else\n    throw TypeError('invalid base256 encoding')\n\n  if (!Number.isSafeInteger(value))\n    // The number is so large that javascript cannot represent it with integer\n    // precision.\n    throw TypeError('parsed number outside of javascript safe integer range')\n\n  return value\n}\n\nconst twos = (buf) => {\n  var len = buf.length\n  var sum = 0\n  var flipped = false\n  for (var i = len - 1; i > -1; i--) {\n    var byte = buf[i]\n    var f\n    if (flipped)\n      f = onesComp(byte)\n    else if (byte === 0)\n      f = byte\n    else {\n      flipped = true\n      f = twosComp(byte)\n    }\n    if (f !== 0)\n      sum -= f * Math.pow(256, len - i - 1)\n  }\n  return sum\n}\n\nconst pos = (buf) => {\n  var len = buf.length\n  var sum = 0\n  for (var i = len - 1; i > -1; i--) {\n    var byte = buf[i]\n    if (byte !== 0)\n      sum += byte * Math.pow(256, len - i - 1)\n  }\n  return sum\n}\n\nconst onesComp = byte => (0xff ^ byte) & 0xff\n\nconst twosComp = byte => ((0xff ^ byte) + 1) & 0xff\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL3Rhci9saWIvbGFyZ2UtbnVtYmVycy5qcyIsIm1hcHBpbmdzIjoiQUFBWTtBQUNaO0FBQ0E7O0FBRUEsZUFBZSxjQUFjO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsMkJBQTJCLE9BQU87QUFDbEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsT0FBTztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYyxhQUFhO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSIsInNvdXJjZXMiOlsiL2hvbWUvYmFyYi9hYS9Bc3NvY2lhdGVkQWNjb3VudHMvbm9kZV9tb2R1bGVzL3Rhci9saWIvbGFyZ2UtbnVtYmVycy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcbi8vIFRhciBjYW4gZW5jb2RlIGxhcmdlIGFuZCBuZWdhdGl2ZSBudW1iZXJzIHVzaW5nIGEgbGVhZGluZyBieXRlIG9mXG4vLyAweGZmIGZvciBuZWdhdGl2ZSwgYW5kIDB4ODAgZm9yIHBvc2l0aXZlLlxuXG5jb25zdCBlbmNvZGUgPSBleHBvcnRzLmVuY29kZSA9IChudW0sIGJ1ZikgPT4ge1xuICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKG51bSkpXG4gICAgLy8gVGhlIG51bWJlciBpcyBzbyBsYXJnZSB0aGF0IGphdmFzY3JpcHQgY2Fubm90IHJlcHJlc2VudCBpdCB3aXRoIGludGVnZXJcbiAgICAvLyBwcmVjaXNpb24uXG4gICAgdGhyb3cgVHlwZUVycm9yKCdjYW5ub3QgZW5jb2RlIG51bWJlciBvdXRzaWRlIG9mIGphdmFzY3JpcHQgc2FmZSBpbnRlZ2VyIHJhbmdlJylcbiAgZWxzZSBpZiAobnVtIDwgMClcbiAgICBlbmNvZGVOZWdhdGl2ZShudW0sIGJ1ZilcbiAgZWxzZVxuICAgIGVuY29kZVBvc2l0aXZlKG51bSwgYnVmKVxuICByZXR1cm4gYnVmXG59XG5cbmNvbnN0IGVuY29kZVBvc2l0aXZlID0gKG51bSwgYnVmKSA9PiB7XG4gIGJ1ZlswXSA9IDB4ODBcblxuICBmb3IgKHZhciBpID0gYnVmLmxlbmd0aDsgaSA+IDE7IGktLSkge1xuICAgIGJ1ZltpLTFdID0gbnVtICYgMHhmZlxuICAgIG51bSA9IE1hdGguZmxvb3IobnVtIC8gMHgxMDApXG4gIH1cbn1cblxuY29uc3QgZW5jb2RlTmVnYXRpdmUgPSAobnVtLCBidWYpID0+IHtcbiAgYnVmWzBdID0gMHhmZlxuICB2YXIgZmxpcHBlZCA9IGZhbHNlXG4gIG51bSA9IG51bSAqIC0xXG4gIGZvciAodmFyIGkgPSBidWYubGVuZ3RoOyBpID4gMTsgaS0tKSB7XG4gICAgdmFyIGJ5dGUgPSBudW0gJiAweGZmXG4gICAgbnVtID0gTWF0aC5mbG9vcihudW0gLyAweDEwMClcbiAgICBpZiAoZmxpcHBlZClcbiAgICAgIGJ1ZltpLTFdID0gb25lc0NvbXAoYnl0ZSlcbiAgICBlbHNlIGlmIChieXRlID09PSAwKVxuICAgICAgYnVmW2ktMV0gPSAwXG4gICAgZWxzZSB7XG4gICAgICBmbGlwcGVkID0gdHJ1ZVxuICAgICAgYnVmW2ktMV0gPSB0d29zQ29tcChieXRlKVxuICAgIH1cbiAgfVxufVxuXG5jb25zdCBwYXJzZSA9IGV4cG9ydHMucGFyc2UgPSAoYnVmKSA9PiB7XG4gIHZhciBwb3N0ID0gYnVmW2J1Zi5sZW5ndGggLSAxXVxuICB2YXIgcHJlID0gYnVmWzBdXG4gIHZhciB2YWx1ZTtcbiAgaWYgKHByZSA9PT0gMHg4MClcbiAgICB2YWx1ZSA9IHBvcyhidWYuc2xpY2UoMSwgYnVmLmxlbmd0aCkpXG4gIGVsc2UgaWYgKHByZSA9PT0gMHhmZilcbiAgICB2YWx1ZSA9IHR3b3MoYnVmKVxuICBlbHNlXG4gICAgdGhyb3cgVHlwZUVycm9yKCdpbnZhbGlkIGJhc2UyNTYgZW5jb2RpbmcnKVxuXG4gIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIodmFsdWUpKVxuICAgIC8vIFRoZSBudW1iZXIgaXMgc28gbGFyZ2UgdGhhdCBqYXZhc2NyaXB0IGNhbm5vdCByZXByZXNlbnQgaXQgd2l0aCBpbnRlZ2VyXG4gICAgLy8gcHJlY2lzaW9uLlxuICAgIHRocm93IFR5cGVFcnJvcigncGFyc2VkIG51bWJlciBvdXRzaWRlIG9mIGphdmFzY3JpcHQgc2FmZSBpbnRlZ2VyIHJhbmdlJylcblxuICByZXR1cm4gdmFsdWVcbn1cblxuY29uc3QgdHdvcyA9IChidWYpID0+IHtcbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcbiAgdmFyIHN1bSA9IDBcbiAgdmFyIGZsaXBwZWQgPSBmYWxzZVxuICBmb3IgKHZhciBpID0gbGVuIC0gMTsgaSA+IC0xOyBpLS0pIHtcbiAgICB2YXIgYnl0ZSA9IGJ1ZltpXVxuICAgIHZhciBmXG4gICAgaWYgKGZsaXBwZWQpXG4gICAgICBmID0gb25lc0NvbXAoYnl0ZSlcbiAgICBlbHNlIGlmIChieXRlID09PSAwKVxuICAgICAgZiA9IGJ5dGVcbiAgICBlbHNlIHtcbiAgICAgIGZsaXBwZWQgPSB0cnVlXG4gICAgICBmID0gdHdvc0NvbXAoYnl0ZSlcbiAgICB9XG4gICAgaWYgKGYgIT09IDApXG4gICAgICBzdW0gLT0gZiAqIE1hdGgucG93KDI1NiwgbGVuIC0gaSAtIDEpXG4gIH1cbiAgcmV0dXJuIHN1bVxufVxuXG5jb25zdCBwb3MgPSAoYnVmKSA9PiB7XG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG4gIHZhciBzdW0gPSAwXG4gIGZvciAodmFyIGkgPSBsZW4gLSAxOyBpID4gLTE7IGktLSkge1xuICAgIHZhciBieXRlID0gYnVmW2ldXG4gICAgaWYgKGJ5dGUgIT09IDApXG4gICAgICBzdW0gKz0gYnl0ZSAqIE1hdGgucG93KDI1NiwgbGVuIC0gaSAtIDEpXG4gIH1cbiAgcmV0dXJuIHN1bVxufVxuXG5jb25zdCBvbmVzQ29tcCA9IGJ5dGUgPT4gKDB4ZmYgXiBieXRlKSAmIDB4ZmZcblxuY29uc3QgdHdvc0NvbXAgPSBieXRlID0+ICgoMHhmZiBeIGJ5dGUpICsgMSkgJiAweGZmXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/tar/lib/large-numbers.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/tar/lib/list.js":
/*!******************************************!*\
  !*** ../../node_modules/tar/lib/list.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst Buffer = __webpack_require__(/*! ./buffer.js */ \"(rsc)/../../node_modules/tar/lib/buffer.js\")\n\n// XXX: This shares a lot in common with extract.js\n// maybe some DRY opportunity here?\n\n// tar -t\nconst hlo = __webpack_require__(/*! ./high-level-opt.js */ \"(rsc)/../../node_modules/tar/lib/high-level-opt.js\")\nconst Parser = __webpack_require__(/*! ./parse.js */ \"(rsc)/../../node_modules/tar/lib/parse.js\")\nconst fs = __webpack_require__(/*! fs */ \"fs\")\nconst fsm = __webpack_require__(/*! fs-minipass */ \"(rsc)/../../node_modules/fs-minipass/index.js\")\nconst path = __webpack_require__(/*! path */ \"path\")\nconst stripSlash = __webpack_require__(/*! ./strip-trailing-slashes.js */ \"(rsc)/../../node_modules/tar/lib/strip-trailing-slashes.js\")\n\nconst t = module.exports = (opt_, files, cb) => {\n  if (typeof opt_ === 'function')\n    cb = opt_, files = null, opt_ = {}\n  else if (Array.isArray(opt_))\n    files = opt_, opt_ = {}\n\n  if (typeof files === 'function')\n    cb = files, files = null\n\n  if (!files)\n    files = []\n  else\n    files = Array.from(files)\n\n  const opt = hlo(opt_)\n\n  if (opt.sync && typeof cb === 'function')\n    throw new TypeError('callback not supported for sync tar functions')\n\n  if (!opt.file && typeof cb === 'function')\n    throw new TypeError('callback only supported with file option')\n\n  if (files.length)\n    filesFilter(opt, files)\n\n  if (!opt.noResume)\n    onentryFunction(opt)\n\n  return opt.file && opt.sync ? listFileSync(opt)\n    : opt.file ? listFile(opt, cb)\n    : list(opt)\n}\n\nconst onentryFunction = opt => {\n  const onentry = opt.onentry\n  opt.onentry = onentry ? e => {\n    onentry(e)\n    e.resume()\n  } : e => e.resume()\n}\n\n// construct a filter that limits the file entries listed\n// include child entries if a dir is included\nconst filesFilter = (opt, files) => {\n  const map = new Map(files.map(f => [stripSlash(f), true]))\n  const filter = opt.filter\n\n  const mapHas = (file, r) => {\n    const root = r || path.parse(file).root || '.'\n    const ret = file === root ? false\n      : map.has(file) ? map.get(file)\n      : mapHas(path.dirname(file), root)\n\n    map.set(file, ret)\n    return ret\n  }\n\n  opt.filter = filter\n    ? (file, entry) => filter(file, entry) && mapHas(stripSlash(file))\n    : file => mapHas(stripSlash(file))\n}\n\nconst listFileSync = opt => {\n  const p = list(opt)\n  const file = opt.file\n  let threw = true\n  let fd\n  try {\n    const stat = fs.statSync(file)\n    const readSize = opt.maxReadSize || 16*1024*1024\n    if (stat.size < readSize) {\n      p.end(fs.readFileSync(file))\n    } else {\n      let pos = 0\n      const buf = Buffer.allocUnsafe(readSize)\n      fd = fs.openSync(file, 'r')\n      while (pos < stat.size) {\n        let bytesRead = fs.readSync(fd, buf, 0, readSize, pos)\n        pos += bytesRead\n        p.write(buf.slice(0, bytesRead))\n      }\n      p.end()\n    }\n    threw = false\n  } finally {\n    if (threw && fd)\n      try { fs.closeSync(fd) } catch (er) {}\n  }\n}\n\nconst listFile = (opt, cb) => {\n  const parse = new Parser(opt)\n  const readSize = opt.maxReadSize || 16*1024*1024\n\n  const file = opt.file\n  const p = new Promise((resolve, reject) => {\n    parse.on('error', reject)\n    parse.on('end', resolve)\n\n    fs.stat(file, (er, stat) => {\n      if (er)\n        reject(er)\n      else {\n        const stream = new fsm.ReadStream(file, {\n          readSize: readSize,\n          size: stat.size\n        })\n        stream.on('error', reject)\n        stream.pipe(parse)\n      }\n    })\n  })\n  return cb ? p.then(cb, cb) : p\n}\n\nconst list = opt => new Parser(opt)\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL3Rhci9saWIvbGlzdC5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixlQUFlLG1CQUFPLENBQUMsK0RBQWE7O0FBRXBDO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLG1CQUFPLENBQUMsK0VBQXFCO0FBQ3pDLGVBQWUsbUJBQU8sQ0FBQyw2REFBWTtBQUNuQyxXQUFXLG1CQUFPLENBQUMsY0FBSTtBQUN2QixZQUFZLG1CQUFPLENBQUMsa0VBQWE7QUFDakMsYUFBYSxtQkFBTyxDQUFDLGtCQUFNO0FBQzNCLG1CQUFtQixtQkFBTyxDQUFDLCtGQUE2Qjs7QUFFeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxZQUFZLG1CQUFtQjtBQUMvQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIi9ob21lL2JhcmIvYWEvQXNzb2NpYXRlZEFjY291bnRzL25vZGVfbW9kdWxlcy90YXIvbGliL2xpc3QuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IEJ1ZmZlciA9IHJlcXVpcmUoJy4vYnVmZmVyLmpzJylcblxuLy8gWFhYOiBUaGlzIHNoYXJlcyBhIGxvdCBpbiBjb21tb24gd2l0aCBleHRyYWN0LmpzXG4vLyBtYXliZSBzb21lIERSWSBvcHBvcnR1bml0eSBoZXJlP1xuXG4vLyB0YXIgLXRcbmNvbnN0IGhsbyA9IHJlcXVpcmUoJy4vaGlnaC1sZXZlbC1vcHQuanMnKVxuY29uc3QgUGFyc2VyID0gcmVxdWlyZSgnLi9wYXJzZS5qcycpXG5jb25zdCBmcyA9IHJlcXVpcmUoJ2ZzJylcbmNvbnN0IGZzbSA9IHJlcXVpcmUoJ2ZzLW1pbmlwYXNzJylcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJylcbmNvbnN0IHN0cmlwU2xhc2ggPSByZXF1aXJlKCcuL3N0cmlwLXRyYWlsaW5nLXNsYXNoZXMuanMnKVxuXG5jb25zdCB0ID0gbW9kdWxlLmV4cG9ydHMgPSAob3B0XywgZmlsZXMsIGNiKSA9PiB7XG4gIGlmICh0eXBlb2Ygb3B0XyA9PT0gJ2Z1bmN0aW9uJylcbiAgICBjYiA9IG9wdF8sIGZpbGVzID0gbnVsbCwgb3B0XyA9IHt9XG4gIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkob3B0XykpXG4gICAgZmlsZXMgPSBvcHRfLCBvcHRfID0ge31cblxuICBpZiAodHlwZW9mIGZpbGVzID09PSAnZnVuY3Rpb24nKVxuICAgIGNiID0gZmlsZXMsIGZpbGVzID0gbnVsbFxuXG4gIGlmICghZmlsZXMpXG4gICAgZmlsZXMgPSBbXVxuICBlbHNlXG4gICAgZmlsZXMgPSBBcnJheS5mcm9tKGZpbGVzKVxuXG4gIGNvbnN0IG9wdCA9IGhsbyhvcHRfKVxuXG4gIGlmIChvcHQuc3luYyAmJiB0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignY2FsbGJhY2sgbm90IHN1cHBvcnRlZCBmb3Igc3luYyB0YXIgZnVuY3Rpb25zJylcblxuICBpZiAoIW9wdC5maWxlICYmIHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJylcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdjYWxsYmFjayBvbmx5IHN1cHBvcnRlZCB3aXRoIGZpbGUgb3B0aW9uJylcblxuICBpZiAoZmlsZXMubGVuZ3RoKVxuICAgIGZpbGVzRmlsdGVyKG9wdCwgZmlsZXMpXG5cbiAgaWYgKCFvcHQubm9SZXN1bWUpXG4gICAgb25lbnRyeUZ1bmN0aW9uKG9wdClcblxuICByZXR1cm4gb3B0LmZpbGUgJiYgb3B0LnN5bmMgPyBsaXN0RmlsZVN5bmMob3B0KVxuICAgIDogb3B0LmZpbGUgPyBsaXN0RmlsZShvcHQsIGNiKVxuICAgIDogbGlzdChvcHQpXG59XG5cbmNvbnN0IG9uZW50cnlGdW5jdGlvbiA9IG9wdCA9PiB7XG4gIGNvbnN0IG9uZW50cnkgPSBvcHQub25lbnRyeVxuICBvcHQub25lbnRyeSA9IG9uZW50cnkgPyBlID0+IHtcbiAgICBvbmVudHJ5KGUpXG4gICAgZS5yZXN1bWUoKVxuICB9IDogZSA9PiBlLnJlc3VtZSgpXG59XG5cbi8vIGNvbnN0cnVjdCBhIGZpbHRlciB0aGF0IGxpbWl0cyB0aGUgZmlsZSBlbnRyaWVzIGxpc3RlZFxuLy8gaW5jbHVkZSBjaGlsZCBlbnRyaWVzIGlmIGEgZGlyIGlzIGluY2x1ZGVkXG5jb25zdCBmaWxlc0ZpbHRlciA9IChvcHQsIGZpbGVzKSA9PiB7XG4gIGNvbnN0IG1hcCA9IG5ldyBNYXAoZmlsZXMubWFwKGYgPT4gW3N0cmlwU2xhc2goZiksIHRydWVdKSlcbiAgY29uc3QgZmlsdGVyID0gb3B0LmZpbHRlclxuXG4gIGNvbnN0IG1hcEhhcyA9IChmaWxlLCByKSA9PiB7XG4gICAgY29uc3Qgcm9vdCA9IHIgfHwgcGF0aC5wYXJzZShmaWxlKS5yb290IHx8ICcuJ1xuICAgIGNvbnN0IHJldCA9IGZpbGUgPT09IHJvb3QgPyBmYWxzZVxuICAgICAgOiBtYXAuaGFzKGZpbGUpID8gbWFwLmdldChmaWxlKVxuICAgICAgOiBtYXBIYXMocGF0aC5kaXJuYW1lKGZpbGUpLCByb290KVxuXG4gICAgbWFwLnNldChmaWxlLCByZXQpXG4gICAgcmV0dXJuIHJldFxuICB9XG5cbiAgb3B0LmZpbHRlciA9IGZpbHRlclxuICAgID8gKGZpbGUsIGVudHJ5KSA9PiBmaWx0ZXIoZmlsZSwgZW50cnkpICYmIG1hcEhhcyhzdHJpcFNsYXNoKGZpbGUpKVxuICAgIDogZmlsZSA9PiBtYXBIYXMoc3RyaXBTbGFzaChmaWxlKSlcbn1cblxuY29uc3QgbGlzdEZpbGVTeW5jID0gb3B0ID0+IHtcbiAgY29uc3QgcCA9IGxpc3Qob3B0KVxuICBjb25zdCBmaWxlID0gb3B0LmZpbGVcbiAgbGV0IHRocmV3ID0gdHJ1ZVxuICBsZXQgZmRcbiAgdHJ5IHtcbiAgICBjb25zdCBzdGF0ID0gZnMuc3RhdFN5bmMoZmlsZSlcbiAgICBjb25zdCByZWFkU2l6ZSA9IG9wdC5tYXhSZWFkU2l6ZSB8fCAxNioxMDI0KjEwMjRcbiAgICBpZiAoc3RhdC5zaXplIDwgcmVhZFNpemUpIHtcbiAgICAgIHAuZW5kKGZzLnJlYWRGaWxlU3luYyhmaWxlKSlcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IHBvcyA9IDBcbiAgICAgIGNvbnN0IGJ1ZiA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShyZWFkU2l6ZSlcbiAgICAgIGZkID0gZnMub3BlblN5bmMoZmlsZSwgJ3InKVxuICAgICAgd2hpbGUgKHBvcyA8IHN0YXQuc2l6ZSkge1xuICAgICAgICBsZXQgYnl0ZXNSZWFkID0gZnMucmVhZFN5bmMoZmQsIGJ1ZiwgMCwgcmVhZFNpemUsIHBvcylcbiAgICAgICAgcG9zICs9IGJ5dGVzUmVhZFxuICAgICAgICBwLndyaXRlKGJ1Zi5zbGljZSgwLCBieXRlc1JlYWQpKVxuICAgICAgfVxuICAgICAgcC5lbmQoKVxuICAgIH1cbiAgICB0aHJldyA9IGZhbHNlXG4gIH0gZmluYWxseSB7XG4gICAgaWYgKHRocmV3ICYmIGZkKVxuICAgICAgdHJ5IHsgZnMuY2xvc2VTeW5jKGZkKSB9IGNhdGNoIChlcikge31cbiAgfVxufVxuXG5jb25zdCBsaXN0RmlsZSA9IChvcHQsIGNiKSA9PiB7XG4gIGNvbnN0IHBhcnNlID0gbmV3IFBhcnNlcihvcHQpXG4gIGNvbnN0IHJlYWRTaXplID0gb3B0Lm1heFJlYWRTaXplIHx8IDE2KjEwMjQqMTAyNFxuXG4gIGNvbnN0IGZpbGUgPSBvcHQuZmlsZVxuICBjb25zdCBwID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHBhcnNlLm9uKCdlcnJvcicsIHJlamVjdClcbiAgICBwYXJzZS5vbignZW5kJywgcmVzb2x2ZSlcblxuICAgIGZzLnN0YXQoZmlsZSwgKGVyLCBzdGF0KSA9PiB7XG4gICAgICBpZiAoZXIpXG4gICAgICAgIHJlamVjdChlcilcbiAgICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBzdHJlYW0gPSBuZXcgZnNtLlJlYWRTdHJlYW0oZmlsZSwge1xuICAgICAgICAgIHJlYWRTaXplOiByZWFkU2l6ZSxcbiAgICAgICAgICBzaXplOiBzdGF0LnNpemVcbiAgICAgICAgfSlcbiAgICAgICAgc3RyZWFtLm9uKCdlcnJvcicsIHJlamVjdClcbiAgICAgICAgc3RyZWFtLnBpcGUocGFyc2UpXG4gICAgICB9XG4gICAgfSlcbiAgfSlcbiAgcmV0dXJuIGNiID8gcC50aGVuKGNiLCBjYikgOiBwXG59XG5cbmNvbnN0IGxpc3QgPSBvcHQgPT4gbmV3IFBhcnNlcihvcHQpXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/tar/lib/list.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/tar/lib/mkdir.js":
/*!*******************************************!*\
  !*** ../../node_modules/tar/lib/mkdir.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n// wrapper around mkdirp for tar's needs.\n\n// TODO: This should probably be a class, not functionally\n// passing around state in a gazillion args.\n\nconst mkdirp = __webpack_require__(/*! mkdirp */ \"(rsc)/../../node_modules/tar/node_modules/mkdirp/index.js\")\nconst fs = __webpack_require__(/*! fs */ \"fs\")\nconst path = __webpack_require__(/*! path */ \"path\")\nconst chownr = __webpack_require__(/*! chownr */ \"(rsc)/../../node_modules/chownr/chownr.js\")\nconst normPath = __webpack_require__(/*! ./normalize-windows-path.js */ \"(rsc)/../../node_modules/tar/lib/normalize-windows-path.js\")\n\nclass SymlinkError extends Error {\n  constructor (symlink, path) {\n    super('Cannot extract through symbolic link')\n    this.path = path\n    this.symlink = symlink\n  }\n\n  get name () {\n    return 'SylinkError'\n  }\n}\n\nclass CwdError extends Error {\n  constructor (path, code) {\n    super(code + ': Cannot cd into \\'' + path + '\\'')\n    this.path = path\n    this.code = code\n  }\n\n  get name () {\n    return 'CwdError'\n  }\n}\n\nconst cGet = (cache, key) => cache.get(normPath(key))\nconst cSet = (cache, key, val) => cache.set(normPath(key), val)\n\nconst checkCwd = (dir, cb) => {\n  fs.stat(dir, (er, st) => {\n    if (er || !st.isDirectory())\n      er = new CwdError(dir, er && er.code || 'ENOTDIR')\n    cb(er)\n  })\n}\n\nmodule.exports = (dir, opt, cb) => {\n  dir = normPath(dir)\n\n  // if there's any overlap between mask and mode,\n  // then we'll need an explicit chmod\n  const umask = opt.umask\n  const mode = opt.mode | 0o0700\n  const needChmod = (mode & umask) !== 0\n\n  const uid = opt.uid\n  const gid = opt.gid\n  const doChown = typeof uid === 'number' &&\n    typeof gid === 'number' &&\n    ( uid !== opt.processUid || gid !== opt.processGid )\n\n  const preserve = opt.preserve\n  const unlink = opt.unlink\n  const cache = opt.cache\n  const cwd = normPath(opt.cwd)\n\n  const done = (er, created) => {\n    if (er)\n      cb(er)\n    else {\n      cSet(cache, dir, true)\n      if (created && doChown)\n        chownr(created, uid, gid, er => done(er))\n      else if (needChmod)\n        fs.chmod(dir, mode, cb)\n      else\n        cb()\n    }\n  }\n\n  if (cache && cGet(cache, dir) === true)\n    return done()\n\n  if (dir === cwd)\n    return checkCwd(dir, done)\n\n  if (preserve)\n    return mkdirp(dir, mode, done)\n\n  const sub = normPath(path.relative(cwd, dir))\n  const parts = sub.split('/')\n  mkdir_(cwd, parts, mode, cache, unlink, cwd, null, done)\n}\n\nconst mkdir_ = (base, parts, mode, cache, unlink, cwd, created, cb) => {\n  if (!parts.length)\n    return cb(null, created)\n  const p = parts.shift()\n  const part = normPath(path.resolve(base + '/' + p))\n  if (cGet(cache, part))\n    return mkdir_(part, parts, mode, cache, unlink, cwd, created, cb)\n  fs.mkdir(part, mode, onmkdir(part, parts, mode, cache, unlink, cwd, created, cb))\n}\n\nconst onmkdir = (part, parts, mode, cache, unlink, cwd, created, cb) => er => {\n  if (er) {\n    fs.lstat(part, (statEr, st) => {\n      if (statEr) {\n        statEr.path = statEr.path && normPath(statEr.path)\n        cb(statEr)\n      } else if (st.isDirectory())\n        mkdir_(part, parts, mode, cache, unlink, cwd, created, cb)\n      else if (unlink)\n        fs.unlink(part, er => {\n          if (er)\n            return cb(er)\n          fs.mkdir(part, mode, onmkdir(part, parts, mode, cache, unlink, cwd, created, cb))\n        })\n      else if (st.isSymbolicLink())\n        return cb(new SymlinkError(part, part + '/' + parts.join('/')))\n      else\n        cb(er)\n    })\n  } else {\n    created = created || part\n    mkdir_(part, parts, mode, cache, unlink, cwd, created, cb)\n  }\n}\n\nconst checkCwdSync = dir => {\n  let ok = false\n  let code = 'ENOTDIR'\n  try {\n    ok = fs.statSync(dir).isDirectory()\n  } catch (er) {\n    code = er.code\n  } finally {\n    if (!ok)\n      throw new CwdError(dir, code)\n  }\n}\n\nmodule.exports.sync = (dir, opt) => {\n  dir = normPath(dir)\n  // if there's any overlap between mask and mode,\n  // then we'll need an explicit chmod\n  const umask = opt.umask\n  const mode = opt.mode | 0o0700\n  const needChmod = (mode & umask) !== 0\n\n  const uid = opt.uid\n  const gid = opt.gid\n  const doChown = typeof uid === 'number' &&\n    typeof gid === 'number' &&\n    ( uid !== opt.processUid || gid !== opt.processGid )\n\n  const preserve = opt.preserve\n  const unlink = opt.unlink\n  const cache = opt.cache\n  const cwd = normPath(opt.cwd)\n\n  const done = (created) => {\n    cSet(cache, dir, true)\n    if (created && doChown)\n      chownr.sync(created, uid, gid)\n    if (needChmod)\n      fs.chmodSync(dir, mode)\n  }\n\n  if (cache && cGet(cache, dir) === true)\n    return done()\n\n  if (dir === cwd) {\n    checkCwdSync(cwd)\n    return done()\n  }\n\n  if (preserve)\n    return done(mkdirp.sync(dir, mode))\n\n  const sub = normPath(path.relative(cwd, dir))\n  const parts = sub.split('/')\n  let created = null\n  for (let p = parts.shift(), part = cwd;\n    p && (part += '/' + p);\n    p = parts.shift()) {\n    part = normPath(path.resolve(part))\n    if (cGet(cache, part))\n      continue\n\n    try {\n      fs.mkdirSync(part, mode)\n      created = created || part\n      cSet(cache, part, true)\n    } catch (er) {\n      const st = fs.lstatSync(part)\n      if (st.isDirectory()) {\n        cSet(cache, part, true)\n        continue\n      } else if (unlink) {\n        fs.unlinkSync(part)\n        fs.mkdirSync(part, mode)\n        created = created || part\n        cSet(cache, part, true)\n        continue\n      } else if (st.isSymbolicLink())\n        return new SymlinkError(part, part + '/' + parts.join('/'))\n    }\n  }\n\n  return done(created)\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL3Rhci9saWIvbWtkaXIuanMiLCJtYXBwaW5ncyI6IkFBQVk7QUFDWjs7QUFFQTtBQUNBOztBQUVBLGVBQWUsbUJBQU8sQ0FBQyx5RUFBUTtBQUMvQixXQUFXLG1CQUFPLENBQUMsY0FBSTtBQUN2QixhQUFhLG1CQUFPLENBQUMsa0JBQU07QUFDM0IsZUFBZSxtQkFBTyxDQUFDLHlEQUFRO0FBQy9CLGlCQUFpQixtQkFBTyxDQUFDLCtGQUE2Qjs7QUFFdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvYmFyYi9hYS9Bc3NvY2lhdGVkQWNjb3VudHMvbm9kZV9tb2R1bGVzL3Rhci9saWIvbWtkaXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG4vLyB3cmFwcGVyIGFyb3VuZCBta2RpcnAgZm9yIHRhcidzIG5lZWRzLlxuXG4vLyBUT0RPOiBUaGlzIHNob3VsZCBwcm9iYWJseSBiZSBhIGNsYXNzLCBub3QgZnVuY3Rpb25hbGx5XG4vLyBwYXNzaW5nIGFyb3VuZCBzdGF0ZSBpbiBhIGdhemlsbGlvbiBhcmdzLlxuXG5jb25zdCBta2RpcnAgPSByZXF1aXJlKCdta2RpcnAnKVxuY29uc3QgZnMgPSByZXF1aXJlKCdmcycpXG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpXG5jb25zdCBjaG93bnIgPSByZXF1aXJlKCdjaG93bnInKVxuY29uc3Qgbm9ybVBhdGggPSByZXF1aXJlKCcuL25vcm1hbGl6ZS13aW5kb3dzLXBhdGguanMnKVxuXG5jbGFzcyBTeW1saW5rRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yIChzeW1saW5rLCBwYXRoKSB7XG4gICAgc3VwZXIoJ0Nhbm5vdCBleHRyYWN0IHRocm91Z2ggc3ltYm9saWMgbGluaycpXG4gICAgdGhpcy5wYXRoID0gcGF0aFxuICAgIHRoaXMuc3ltbGluayA9IHN5bWxpbmtcbiAgfVxuXG4gIGdldCBuYW1lICgpIHtcbiAgICByZXR1cm4gJ1N5bGlua0Vycm9yJ1xuICB9XG59XG5cbmNsYXNzIEN3ZEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvciAocGF0aCwgY29kZSkge1xuICAgIHN1cGVyKGNvZGUgKyAnOiBDYW5ub3QgY2QgaW50byBcXCcnICsgcGF0aCArICdcXCcnKVxuICAgIHRoaXMucGF0aCA9IHBhdGhcbiAgICB0aGlzLmNvZGUgPSBjb2RlXG4gIH1cblxuICBnZXQgbmFtZSAoKSB7XG4gICAgcmV0dXJuICdDd2RFcnJvcidcbiAgfVxufVxuXG5jb25zdCBjR2V0ID0gKGNhY2hlLCBrZXkpID0+IGNhY2hlLmdldChub3JtUGF0aChrZXkpKVxuY29uc3QgY1NldCA9IChjYWNoZSwga2V5LCB2YWwpID0+IGNhY2hlLnNldChub3JtUGF0aChrZXkpLCB2YWwpXG5cbmNvbnN0IGNoZWNrQ3dkID0gKGRpciwgY2IpID0+IHtcbiAgZnMuc3RhdChkaXIsIChlciwgc3QpID0+IHtcbiAgICBpZiAoZXIgfHwgIXN0LmlzRGlyZWN0b3J5KCkpXG4gICAgICBlciA9IG5ldyBDd2RFcnJvcihkaXIsIGVyICYmIGVyLmNvZGUgfHwgJ0VOT1RESVInKVxuICAgIGNiKGVyKVxuICB9KVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IChkaXIsIG9wdCwgY2IpID0+IHtcbiAgZGlyID0gbm9ybVBhdGgoZGlyKVxuXG4gIC8vIGlmIHRoZXJlJ3MgYW55IG92ZXJsYXAgYmV0d2VlbiBtYXNrIGFuZCBtb2RlLFxuICAvLyB0aGVuIHdlJ2xsIG5lZWQgYW4gZXhwbGljaXQgY2htb2RcbiAgY29uc3QgdW1hc2sgPSBvcHQudW1hc2tcbiAgY29uc3QgbW9kZSA9IG9wdC5tb2RlIHwgMG8wNzAwXG4gIGNvbnN0IG5lZWRDaG1vZCA9IChtb2RlICYgdW1hc2spICE9PSAwXG5cbiAgY29uc3QgdWlkID0gb3B0LnVpZFxuICBjb25zdCBnaWQgPSBvcHQuZ2lkXG4gIGNvbnN0IGRvQ2hvd24gPSB0eXBlb2YgdWlkID09PSAnbnVtYmVyJyAmJlxuICAgIHR5cGVvZiBnaWQgPT09ICdudW1iZXInICYmXG4gICAgKCB1aWQgIT09IG9wdC5wcm9jZXNzVWlkIHx8IGdpZCAhPT0gb3B0LnByb2Nlc3NHaWQgKVxuXG4gIGNvbnN0IHByZXNlcnZlID0gb3B0LnByZXNlcnZlXG4gIGNvbnN0IHVubGluayA9IG9wdC51bmxpbmtcbiAgY29uc3QgY2FjaGUgPSBvcHQuY2FjaGVcbiAgY29uc3QgY3dkID0gbm9ybVBhdGgob3B0LmN3ZClcblxuICBjb25zdCBkb25lID0gKGVyLCBjcmVhdGVkKSA9PiB7XG4gICAgaWYgKGVyKVxuICAgICAgY2IoZXIpXG4gICAgZWxzZSB7XG4gICAgICBjU2V0KGNhY2hlLCBkaXIsIHRydWUpXG4gICAgICBpZiAoY3JlYXRlZCAmJiBkb0Nob3duKVxuICAgICAgICBjaG93bnIoY3JlYXRlZCwgdWlkLCBnaWQsIGVyID0+IGRvbmUoZXIpKVxuICAgICAgZWxzZSBpZiAobmVlZENobW9kKVxuICAgICAgICBmcy5jaG1vZChkaXIsIG1vZGUsIGNiKVxuICAgICAgZWxzZVxuICAgICAgICBjYigpXG4gICAgfVxuICB9XG5cbiAgaWYgKGNhY2hlICYmIGNHZXQoY2FjaGUsIGRpcikgPT09IHRydWUpXG4gICAgcmV0dXJuIGRvbmUoKVxuXG4gIGlmIChkaXIgPT09IGN3ZClcbiAgICByZXR1cm4gY2hlY2tDd2QoZGlyLCBkb25lKVxuXG4gIGlmIChwcmVzZXJ2ZSlcbiAgICByZXR1cm4gbWtkaXJwKGRpciwgbW9kZSwgZG9uZSlcblxuICBjb25zdCBzdWIgPSBub3JtUGF0aChwYXRoLnJlbGF0aXZlKGN3ZCwgZGlyKSlcbiAgY29uc3QgcGFydHMgPSBzdWIuc3BsaXQoJy8nKVxuICBta2Rpcl8oY3dkLCBwYXJ0cywgbW9kZSwgY2FjaGUsIHVubGluaywgY3dkLCBudWxsLCBkb25lKVxufVxuXG5jb25zdCBta2Rpcl8gPSAoYmFzZSwgcGFydHMsIG1vZGUsIGNhY2hlLCB1bmxpbmssIGN3ZCwgY3JlYXRlZCwgY2IpID0+IHtcbiAgaWYgKCFwYXJ0cy5sZW5ndGgpXG4gICAgcmV0dXJuIGNiKG51bGwsIGNyZWF0ZWQpXG4gIGNvbnN0IHAgPSBwYXJ0cy5zaGlmdCgpXG4gIGNvbnN0IHBhcnQgPSBub3JtUGF0aChwYXRoLnJlc29sdmUoYmFzZSArICcvJyArIHApKVxuICBpZiAoY0dldChjYWNoZSwgcGFydCkpXG4gICAgcmV0dXJuIG1rZGlyXyhwYXJ0LCBwYXJ0cywgbW9kZSwgY2FjaGUsIHVubGluaywgY3dkLCBjcmVhdGVkLCBjYilcbiAgZnMubWtkaXIocGFydCwgbW9kZSwgb25ta2RpcihwYXJ0LCBwYXJ0cywgbW9kZSwgY2FjaGUsIHVubGluaywgY3dkLCBjcmVhdGVkLCBjYikpXG59XG5cbmNvbnN0IG9ubWtkaXIgPSAocGFydCwgcGFydHMsIG1vZGUsIGNhY2hlLCB1bmxpbmssIGN3ZCwgY3JlYXRlZCwgY2IpID0+IGVyID0+IHtcbiAgaWYgKGVyKSB7XG4gICAgZnMubHN0YXQocGFydCwgKHN0YXRFciwgc3QpID0+IHtcbiAgICAgIGlmIChzdGF0RXIpIHtcbiAgICAgICAgc3RhdEVyLnBhdGggPSBzdGF0RXIucGF0aCAmJiBub3JtUGF0aChzdGF0RXIucGF0aClcbiAgICAgICAgY2Ioc3RhdEVyKVxuICAgICAgfSBlbHNlIGlmIChzdC5pc0RpcmVjdG9yeSgpKVxuICAgICAgICBta2Rpcl8ocGFydCwgcGFydHMsIG1vZGUsIGNhY2hlLCB1bmxpbmssIGN3ZCwgY3JlYXRlZCwgY2IpXG4gICAgICBlbHNlIGlmICh1bmxpbmspXG4gICAgICAgIGZzLnVubGluayhwYXJ0LCBlciA9PiB7XG4gICAgICAgICAgaWYgKGVyKVxuICAgICAgICAgICAgcmV0dXJuIGNiKGVyKVxuICAgICAgICAgIGZzLm1rZGlyKHBhcnQsIG1vZGUsIG9ubWtkaXIocGFydCwgcGFydHMsIG1vZGUsIGNhY2hlLCB1bmxpbmssIGN3ZCwgY3JlYXRlZCwgY2IpKVxuICAgICAgICB9KVxuICAgICAgZWxzZSBpZiAoc3QuaXNTeW1ib2xpY0xpbmsoKSlcbiAgICAgICAgcmV0dXJuIGNiKG5ldyBTeW1saW5rRXJyb3IocGFydCwgcGFydCArICcvJyArIHBhcnRzLmpvaW4oJy8nKSkpXG4gICAgICBlbHNlXG4gICAgICAgIGNiKGVyKVxuICAgIH0pXG4gIH0gZWxzZSB7XG4gICAgY3JlYXRlZCA9IGNyZWF0ZWQgfHwgcGFydFxuICAgIG1rZGlyXyhwYXJ0LCBwYXJ0cywgbW9kZSwgY2FjaGUsIHVubGluaywgY3dkLCBjcmVhdGVkLCBjYilcbiAgfVxufVxuXG5jb25zdCBjaGVja0N3ZFN5bmMgPSBkaXIgPT4ge1xuICBsZXQgb2sgPSBmYWxzZVxuICBsZXQgY29kZSA9ICdFTk9URElSJ1xuICB0cnkge1xuICAgIG9rID0gZnMuc3RhdFN5bmMoZGlyKS5pc0RpcmVjdG9yeSgpXG4gIH0gY2F0Y2ggKGVyKSB7XG4gICAgY29kZSA9IGVyLmNvZGVcbiAgfSBmaW5hbGx5IHtcbiAgICBpZiAoIW9rKVxuICAgICAgdGhyb3cgbmV3IEN3ZEVycm9yKGRpciwgY29kZSlcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cy5zeW5jID0gKGRpciwgb3B0KSA9PiB7XG4gIGRpciA9IG5vcm1QYXRoKGRpcilcbiAgLy8gaWYgdGhlcmUncyBhbnkgb3ZlcmxhcCBiZXR3ZWVuIG1hc2sgYW5kIG1vZGUsXG4gIC8vIHRoZW4gd2UnbGwgbmVlZCBhbiBleHBsaWNpdCBjaG1vZFxuICBjb25zdCB1bWFzayA9IG9wdC51bWFza1xuICBjb25zdCBtb2RlID0gb3B0Lm1vZGUgfCAwbzA3MDBcbiAgY29uc3QgbmVlZENobW9kID0gKG1vZGUgJiB1bWFzaykgIT09IDBcblxuICBjb25zdCB1aWQgPSBvcHQudWlkXG4gIGNvbnN0IGdpZCA9IG9wdC5naWRcbiAgY29uc3QgZG9DaG93biA9IHR5cGVvZiB1aWQgPT09ICdudW1iZXInICYmXG4gICAgdHlwZW9mIGdpZCA9PT0gJ251bWJlcicgJiZcbiAgICAoIHVpZCAhPT0gb3B0LnByb2Nlc3NVaWQgfHwgZ2lkICE9PSBvcHQucHJvY2Vzc0dpZCApXG5cbiAgY29uc3QgcHJlc2VydmUgPSBvcHQucHJlc2VydmVcbiAgY29uc3QgdW5saW5rID0gb3B0LnVubGlua1xuICBjb25zdCBjYWNoZSA9IG9wdC5jYWNoZVxuICBjb25zdCBjd2QgPSBub3JtUGF0aChvcHQuY3dkKVxuXG4gIGNvbnN0IGRvbmUgPSAoY3JlYXRlZCkgPT4ge1xuICAgIGNTZXQoY2FjaGUsIGRpciwgdHJ1ZSlcbiAgICBpZiAoY3JlYXRlZCAmJiBkb0Nob3duKVxuICAgICAgY2hvd25yLnN5bmMoY3JlYXRlZCwgdWlkLCBnaWQpXG4gICAgaWYgKG5lZWRDaG1vZClcbiAgICAgIGZzLmNobW9kU3luYyhkaXIsIG1vZGUpXG4gIH1cblxuICBpZiAoY2FjaGUgJiYgY0dldChjYWNoZSwgZGlyKSA9PT0gdHJ1ZSlcbiAgICByZXR1cm4gZG9uZSgpXG5cbiAgaWYgKGRpciA9PT0gY3dkKSB7XG4gICAgY2hlY2tDd2RTeW5jKGN3ZClcbiAgICByZXR1cm4gZG9uZSgpXG4gIH1cblxuICBpZiAocHJlc2VydmUpXG4gICAgcmV0dXJuIGRvbmUobWtkaXJwLnN5bmMoZGlyLCBtb2RlKSlcblxuICBjb25zdCBzdWIgPSBub3JtUGF0aChwYXRoLnJlbGF0aXZlKGN3ZCwgZGlyKSlcbiAgY29uc3QgcGFydHMgPSBzdWIuc3BsaXQoJy8nKVxuICBsZXQgY3JlYXRlZCA9IG51bGxcbiAgZm9yIChsZXQgcCA9IHBhcnRzLnNoaWZ0KCksIHBhcnQgPSBjd2Q7XG4gICAgcCAmJiAocGFydCArPSAnLycgKyBwKTtcbiAgICBwID0gcGFydHMuc2hpZnQoKSkge1xuICAgIHBhcnQgPSBub3JtUGF0aChwYXRoLnJlc29sdmUocGFydCkpXG4gICAgaWYgKGNHZXQoY2FjaGUsIHBhcnQpKVxuICAgICAgY29udGludWVcblxuICAgIHRyeSB7XG4gICAgICBmcy5ta2RpclN5bmMocGFydCwgbW9kZSlcbiAgICAgIGNyZWF0ZWQgPSBjcmVhdGVkIHx8IHBhcnRcbiAgICAgIGNTZXQoY2FjaGUsIHBhcnQsIHRydWUpXG4gICAgfSBjYXRjaCAoZXIpIHtcbiAgICAgIGNvbnN0IHN0ID0gZnMubHN0YXRTeW5jKHBhcnQpXG4gICAgICBpZiAoc3QuaXNEaXJlY3RvcnkoKSkge1xuICAgICAgICBjU2V0KGNhY2hlLCBwYXJ0LCB0cnVlKVxuICAgICAgICBjb250aW51ZVxuICAgICAgfSBlbHNlIGlmICh1bmxpbmspIHtcbiAgICAgICAgZnMudW5saW5rU3luYyhwYXJ0KVxuICAgICAgICBmcy5ta2RpclN5bmMocGFydCwgbW9kZSlcbiAgICAgICAgY3JlYXRlZCA9IGNyZWF0ZWQgfHwgcGFydFxuICAgICAgICBjU2V0KGNhY2hlLCBwYXJ0LCB0cnVlKVxuICAgICAgICBjb250aW51ZVxuICAgICAgfSBlbHNlIGlmIChzdC5pc1N5bWJvbGljTGluaygpKVxuICAgICAgICByZXR1cm4gbmV3IFN5bWxpbmtFcnJvcihwYXJ0LCBwYXJ0ICsgJy8nICsgcGFydHMuam9pbignLycpKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBkb25lKGNyZWF0ZWQpXG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/tar/lib/mkdir.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/tar/lib/mode-fix.js":
/*!**********************************************!*\
  !*** ../../node_modules/tar/lib/mode-fix.js ***!
  \**********************************************/
/***/ ((module) => {

"use strict";
eval("\nmodule.exports = (mode, isDir) => {\n  mode &= 0o7777\n  // if dirs are readable, then they should be listable\n  if (isDir) {\n    if (mode & 0o400)\n      mode |= 0o100\n    if (mode & 0o40)\n      mode |= 0o10\n    if (mode & 0o4)\n      mode |= 0o1\n  }\n  return mode\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL3Rhci9saWIvbW9kZS1maXguanMiLCJtYXBwaW5ncyI6IkFBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvYmFyYi9hYS9Bc3NvY2lhdGVkQWNjb3VudHMvbm9kZV9tb2R1bGVzL3Rhci9saWIvbW9kZS1maXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5tb2R1bGUuZXhwb3J0cyA9IChtb2RlLCBpc0RpcikgPT4ge1xuICBtb2RlICY9IDBvNzc3N1xuICAvLyBpZiBkaXJzIGFyZSByZWFkYWJsZSwgdGhlbiB0aGV5IHNob3VsZCBiZSBsaXN0YWJsZVxuICBpZiAoaXNEaXIpIHtcbiAgICBpZiAobW9kZSAmIDBvNDAwKVxuICAgICAgbW9kZSB8PSAwbzEwMFxuICAgIGlmIChtb2RlICYgMG80MClcbiAgICAgIG1vZGUgfD0gMG8xMFxuICAgIGlmIChtb2RlICYgMG80KVxuICAgICAgbW9kZSB8PSAwbzFcbiAgfVxuICByZXR1cm4gbW9kZVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/tar/lib/mode-fix.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/tar/lib/normalize-windows-path.js":
/*!************************************************************!*\
  !*** ../../node_modules/tar/lib/normalize-windows-path.js ***!
  \************************************************************/
/***/ ((module) => {

eval("// on windows, either \\ or / are valid directory separators.\n// on unix, \\ is a valid character in filenames.\n// so, on windows, and only on windows, we replace all \\ chars with /,\n// so that we can use / as our one and only directory separator char.\n\nconst platform = process.env.TESTING_TAR_FAKE_PLATFORM || process.platform\nmodule.exports = platform !== 'win32' ? p => p\n  : p => p && p.replace(/\\\\/g, '/')\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL3Rhci9saWIvbm9ybWFsaXplLXdpbmRvd3MtcGF0aC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL2JhcmIvYWEvQXNzb2NpYXRlZEFjY291bnRzL25vZGVfbW9kdWxlcy90YXIvbGliL25vcm1hbGl6ZS13aW5kb3dzLXBhdGguanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gb24gd2luZG93cywgZWl0aGVyIFxcIG9yIC8gYXJlIHZhbGlkIGRpcmVjdG9yeSBzZXBhcmF0b3JzLlxuLy8gb24gdW5peCwgXFwgaXMgYSB2YWxpZCBjaGFyYWN0ZXIgaW4gZmlsZW5hbWVzLlxuLy8gc28sIG9uIHdpbmRvd3MsIGFuZCBvbmx5IG9uIHdpbmRvd3MsIHdlIHJlcGxhY2UgYWxsIFxcIGNoYXJzIHdpdGggLyxcbi8vIHNvIHRoYXQgd2UgY2FuIHVzZSAvIGFzIG91ciBvbmUgYW5kIG9ubHkgZGlyZWN0b3J5IHNlcGFyYXRvciBjaGFyLlxuXG5jb25zdCBwbGF0Zm9ybSA9IHByb2Nlc3MuZW52LlRFU1RJTkdfVEFSX0ZBS0VfUExBVEZPUk0gfHwgcHJvY2Vzcy5wbGF0Zm9ybVxubW9kdWxlLmV4cG9ydHMgPSBwbGF0Zm9ybSAhPT0gJ3dpbjMyJyA/IHAgPT4gcFxuICA6IHAgPT4gcCAmJiBwLnJlcGxhY2UoL1xcXFwvZywgJy8nKVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/tar/lib/normalize-windows-path.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/tar/lib/pack.js":
/*!******************************************!*\
  !*** ../../node_modules/tar/lib/pack.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst Buffer = __webpack_require__(/*! ./buffer.js */ \"(rsc)/../../node_modules/tar/lib/buffer.js\")\n\n// A readable tar stream creator\n// Technically, this is a transform stream that you write paths into,\n// and tar format comes out of.\n// The `add()` method is like `write()` but returns this,\n// and end() return `this` as well, so you can\n// do `new Pack(opt).add('files').add('dir').end().pipe(output)\n// You could also do something like:\n// streamOfPaths().pipe(new Pack()).pipe(new fs.WriteStream('out.tar'))\n\nclass PackJob {\n  constructor (path, absolute) {\n    this.path = path || './'\n    this.absolute = absolute\n    this.entry = null\n    this.stat = null\n    this.readdir = null\n    this.pending = false\n    this.ignore = false\n    this.piped = false\n  }\n}\n\nconst MiniPass = __webpack_require__(/*! minipass */ \"(rsc)/../../node_modules/minipass/index.js\")\nconst zlib = __webpack_require__(/*! minizlib */ \"(rsc)/../../node_modules/minizlib/index.js\")\nconst ReadEntry = __webpack_require__(/*! ./read-entry.js */ \"(rsc)/../../node_modules/tar/lib/read-entry.js\")\nconst WriteEntry = __webpack_require__(/*! ./write-entry.js */ \"(rsc)/../../node_modules/tar/lib/write-entry.js\")\nconst WriteEntrySync = WriteEntry.Sync\nconst WriteEntryTar = WriteEntry.Tar\nconst Yallist = __webpack_require__(/*! yallist */ \"(rsc)/../../node_modules/yallist/yallist.js\")\nconst EOF = Buffer.alloc(1024)\nconst ONSTAT = Symbol('onStat')\nconst ENDED = Symbol('ended')\nconst QUEUE = Symbol('queue')\nconst CURRENT = Symbol('current')\nconst PROCESS = Symbol('process')\nconst PROCESSING = Symbol('processing')\nconst PROCESSJOB = Symbol('processJob')\nconst JOBS = Symbol('jobs')\nconst JOBDONE = Symbol('jobDone')\nconst ADDFSENTRY = Symbol('addFSEntry')\nconst ADDTARENTRY = Symbol('addTarEntry')\nconst STAT = Symbol('stat')\nconst READDIR = Symbol('readdir')\nconst ONREADDIR = Symbol('onreaddir')\nconst PIPE = Symbol('pipe')\nconst ENTRY = Symbol('entry')\nconst ENTRYOPT = Symbol('entryOpt')\nconst WRITEENTRYCLASS = Symbol('writeEntryClass')\nconst WRITE = Symbol('write')\nconst ONDRAIN = Symbol('ondrain')\n\nconst fs = __webpack_require__(/*! fs */ \"fs\")\nconst path = __webpack_require__(/*! path */ \"path\")\nconst warner = __webpack_require__(/*! ./warn-mixin.js */ \"(rsc)/../../node_modules/tar/lib/warn-mixin.js\")\nconst normPath = __webpack_require__(/*! ./normalize-windows-path.js */ \"(rsc)/../../node_modules/tar/lib/normalize-windows-path.js\")\n\nconst Pack = warner(class Pack extends MiniPass {\n  constructor (opt) {\n    super(opt)\n    opt = opt || Object.create(null)\n    this.opt = opt\n    this.cwd = opt.cwd || process.cwd()\n    this.maxReadSize = opt.maxReadSize\n    this.preservePaths = !!opt.preservePaths\n    this.strict = !!opt.strict\n    this.noPax = !!opt.noPax\n    this.prefix = normPath(opt.prefix || '')\n    this.linkCache = opt.linkCache || new Map()\n    this.statCache = opt.statCache || new Map()\n    this.readdirCache = opt.readdirCache || new Map()\n\n    this[WRITEENTRYCLASS] = WriteEntry\n    if (typeof opt.onwarn === 'function')\n      this.on('warn', opt.onwarn)\n\n    this.zip = null\n    if (opt.gzip) {\n      if (typeof opt.gzip !== 'object')\n        opt.gzip = {}\n      this.zip = new zlib.Gzip(opt.gzip)\n      this.zip.on('data', chunk => super.write(chunk))\n      this.zip.on('end', _ => super.end())\n      this.zip.on('drain', _ => this[ONDRAIN]())\n      this.on('resume', _ => this.zip.resume())\n    } else\n      this.on('drain', this[ONDRAIN])\n\n    this.portable = !!opt.portable\n    this.noDirRecurse = !!opt.noDirRecurse\n    this.follow = !!opt.follow\n    this.noMtime = !!opt.noMtime\n    this.mtime = opt.mtime || null\n\n    this.filter = typeof opt.filter === 'function' ? opt.filter : _ => true\n\n    this[QUEUE] = new Yallist\n    this[JOBS] = 0\n    this.jobs = +opt.jobs || 4\n    this[PROCESSING] = false\n    this[ENDED] = false\n  }\n\n  [WRITE] (chunk) {\n    return super.write(chunk)\n  }\n\n  add (path) {\n    this.write(path)\n    return this\n  }\n\n  end (path) {\n    if (path)\n      this.write(path)\n    this[ENDED] = true\n    this[PROCESS]()\n    return this\n  }\n\n  write (path) {\n    if (this[ENDED])\n      throw new Error('write after end')\n\n    if (path instanceof ReadEntry)\n      this[ADDTARENTRY](path)\n    else\n      this[ADDFSENTRY](path)\n    return this.flowing\n  }\n\n  [ADDTARENTRY] (p) {\n    const absolute = normPath(path.resolve(this.cwd, p.path))\n    // in this case, we don't have to wait for the stat\n    if (!this.filter(p.path, p))\n      p.resume()\n    else {\n      const job = new PackJob(p.path, absolute, false)\n      job.entry = new WriteEntryTar(p, this[ENTRYOPT](job))\n      job.entry.on('end', _ => this[JOBDONE](job))\n      this[JOBS] += 1\n      this[QUEUE].push(job)\n    }\n\n    this[PROCESS]()\n  }\n\n  [ADDFSENTRY] (p) {\n    const absolute = normPath(path.resolve(this.cwd, p))\n    this[QUEUE].push(new PackJob(p, absolute))\n    this[PROCESS]()\n  }\n\n  [STAT] (job) {\n    job.pending = true\n    this[JOBS] += 1\n    const stat = this.follow ? 'stat' : 'lstat'\n    fs[stat](job.absolute, (er, stat) => {\n      job.pending = false\n      this[JOBS] -= 1\n      if (er)\n        this.emit('error', er)\n      else\n        this[ONSTAT](job, stat)\n    })\n  }\n\n  [ONSTAT] (job, stat) {\n    this.statCache.set(job.absolute, stat)\n    job.stat = stat\n\n    // now we have the stat, we can filter it.\n    if (!this.filter(job.path, stat))\n      job.ignore = true\n\n    this[PROCESS]()\n  }\n\n  [READDIR] (job) {\n    job.pending = true\n    this[JOBS] += 1\n    fs.readdir(job.absolute, (er, entries) => {\n      job.pending = false\n      this[JOBS] -= 1\n      if (er)\n        return this.emit('error', er)\n      this[ONREADDIR](job, entries)\n    })\n  }\n\n  [ONREADDIR] (job, entries) {\n    this.readdirCache.set(job.absolute, entries)\n    job.readdir = entries\n    this[PROCESS]()\n  }\n\n  [PROCESS] () {\n    if (this[PROCESSING])\n      return\n\n    this[PROCESSING] = true\n    for (let w = this[QUEUE].head;\n         w !== null && this[JOBS] < this.jobs;\n         w = w.next) {\n      this[PROCESSJOB](w.value)\n      if (w.value.ignore) {\n        const p = w.next\n        this[QUEUE].removeNode(w)\n        w.next = p\n      }\n    }\n\n    this[PROCESSING] = false\n\n    if (this[ENDED] && !this[QUEUE].length && this[JOBS] === 0) {\n      if (this.zip)\n        this.zip.end(EOF)\n      else {\n        super.write(EOF)\n        super.end()\n      }\n    }\n  }\n\n  get [CURRENT] () {\n    return this[QUEUE] && this[QUEUE].head && this[QUEUE].head.value\n  }\n\n  [JOBDONE] (job) {\n    this[QUEUE].shift()\n    this[JOBS] -= 1\n    this[PROCESS]()\n  }\n\n  [PROCESSJOB] (job) {\n    if (job.pending)\n      return\n\n    if (job.entry) {\n      if (job === this[CURRENT] && !job.piped)\n        this[PIPE](job)\n      return\n    }\n\n    if (!job.stat) {\n      if (this.statCache.has(job.absolute))\n        this[ONSTAT](job, this.statCache.get(job.absolute))\n      else\n        this[STAT](job)\n    }\n    if (!job.stat)\n      return\n\n    // filtered out!\n    if (job.ignore)\n      return\n\n    if (!this.noDirRecurse && job.stat.isDirectory() && !job.readdir) {\n      if (this.readdirCache.has(job.absolute))\n        this[ONREADDIR](job, this.readdirCache.get(job.absolute))\n      else\n        this[READDIR](job)\n      if (!job.readdir)\n        return\n    }\n\n    // we know it doesn't have an entry, because that got checked above\n    job.entry = this[ENTRY](job)\n    if (!job.entry) {\n      job.ignore = true\n      return\n    }\n\n    if (job === this[CURRENT] && !job.piped)\n      this[PIPE](job)\n  }\n\n  [ENTRYOPT] (job) {\n    return {\n      onwarn: (msg, data) => {\n        this.warn(msg, data)\n      },\n      noPax: this.noPax,\n      cwd: this.cwd,\n      absolute: job.absolute,\n      preservePaths: this.preservePaths,\n      maxReadSize: this.maxReadSize,\n      strict: this.strict,\n      portable: this.portable,\n      linkCache: this.linkCache,\n      statCache: this.statCache,\n      noMtime: this.noMtime,\n      mtime: this.mtime,\n      prefix: this.prefix,\n    }\n  }\n\n  [ENTRY] (job) {\n    this[JOBS] += 1\n    try {\n      return new this[WRITEENTRYCLASS](job.path, this[ENTRYOPT](job))\n        .on('end', () => this[JOBDONE](job))\n        .on('error', er => this.emit('error', er))\n    } catch (er) {\n      this.emit('error', er)\n    }\n  }\n\n  [ONDRAIN] () {\n    if (this[CURRENT] && this[CURRENT].entry)\n      this[CURRENT].entry.resume()\n  }\n\n  // like .pipe() but using super, because our write() is special\n  [PIPE] (job) {\n    job.piped = true\n\n    if (job.readdir)\n      job.readdir.forEach(entry => {\n        const p = job.path\n        const base = p === './' ? '' : p.replace(/\\/*$/, '/')\n        this[ADDFSENTRY](base + entry)\n      })\n\n    const source = job.entry\n    const zip = this.zip\n\n    if (zip)\n      source.on('data', chunk => {\n        if (!zip.write(chunk))\n          source.pause()\n      })\n    else\n      source.on('data', chunk => {\n        if (!super.write(chunk))\n          source.pause()\n      })\n  }\n\n  pause () {\n    if (this.zip)\n      this.zip.pause()\n    return super.pause()\n  }\n})\n\nclass PackSync extends Pack {\n  constructor (opt) {\n    super(opt)\n    this[WRITEENTRYCLASS] = WriteEntrySync\n  }\n\n  // pause/resume are no-ops in sync streams.\n  pause () {}\n  resume () {}\n\n  [STAT] (job) {\n    const stat = this.follow ? 'statSync' : 'lstatSync'\n    this[ONSTAT](job, fs[stat](job.absolute))\n  }\n\n  [READDIR] (job, stat) {\n    this[ONREADDIR](job, fs.readdirSync(job.absolute))\n  }\n\n  // gotta get it all in this tick\n  [PIPE] (job) {\n    const source = job.entry\n    const zip = this.zip\n\n    if (job.readdir)\n      job.readdir.forEach(entry => {\n        const p = job.path\n        const base = p === './' ? '' : p.replace(/\\/*$/, '/')\n        this[ADDFSENTRY](base + entry)\n      })\n\n    if (zip)\n      source.on('data', chunk => {\n        zip.write(chunk)\n      })\n    else\n      source.on('data', chunk => {\n        super[WRITE](chunk)\n      })\n  }\n}\n\nPack.Sync = PackSync\n\nmodule.exports = Pack\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL3Rhci9saWIvcGFjay5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixlQUFlLG1CQUFPLENBQUMsK0RBQWE7O0FBRXBDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixtQkFBTyxDQUFDLDREQUFVO0FBQ25DLGFBQWEsbUJBQU8sQ0FBQyw0REFBVTtBQUMvQixrQkFBa0IsbUJBQU8sQ0FBQyx1RUFBaUI7QUFDM0MsbUJBQW1CLG1CQUFPLENBQUMseUVBQWtCO0FBQzdDO0FBQ0E7QUFDQSxnQkFBZ0IsbUJBQU8sQ0FBQyw0REFBUztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsV0FBVyxtQkFBTyxDQUFDLGNBQUk7QUFDdkIsYUFBYSxtQkFBTyxDQUFDLGtCQUFNO0FBQzNCLGVBQWUsbUJBQU8sQ0FBQyx1RUFBaUI7QUFDeEMsaUJBQWlCLG1CQUFPLENBQUMsK0ZBQTZCOztBQUV0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBIiwic291cmNlcyI6WyIvaG9tZS9iYXJiL2FhL0Fzc29jaWF0ZWRBY2NvdW50cy9ub2RlX21vZHVsZXMvdGFyL2xpYi9wYWNrLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBCdWZmZXIgPSByZXF1aXJlKCcuL2J1ZmZlci5qcycpXG5cbi8vIEEgcmVhZGFibGUgdGFyIHN0cmVhbSBjcmVhdG9yXG4vLyBUZWNobmljYWxseSwgdGhpcyBpcyBhIHRyYW5zZm9ybSBzdHJlYW0gdGhhdCB5b3Ugd3JpdGUgcGF0aHMgaW50byxcbi8vIGFuZCB0YXIgZm9ybWF0IGNvbWVzIG91dCBvZi5cbi8vIFRoZSBgYWRkKClgIG1ldGhvZCBpcyBsaWtlIGB3cml0ZSgpYCBidXQgcmV0dXJucyB0aGlzLFxuLy8gYW5kIGVuZCgpIHJldHVybiBgdGhpc2AgYXMgd2VsbCwgc28geW91IGNhblxuLy8gZG8gYG5ldyBQYWNrKG9wdCkuYWRkKCdmaWxlcycpLmFkZCgnZGlyJykuZW5kKCkucGlwZShvdXRwdXQpXG4vLyBZb3UgY291bGQgYWxzbyBkbyBzb21ldGhpbmcgbGlrZTpcbi8vIHN0cmVhbU9mUGF0aHMoKS5waXBlKG5ldyBQYWNrKCkpLnBpcGUobmV3IGZzLldyaXRlU3RyZWFtKCdvdXQudGFyJykpXG5cbmNsYXNzIFBhY2tKb2Ige1xuICBjb25zdHJ1Y3RvciAocGF0aCwgYWJzb2x1dGUpIHtcbiAgICB0aGlzLnBhdGggPSBwYXRoIHx8ICcuLydcbiAgICB0aGlzLmFic29sdXRlID0gYWJzb2x1dGVcbiAgICB0aGlzLmVudHJ5ID0gbnVsbFxuICAgIHRoaXMuc3RhdCA9IG51bGxcbiAgICB0aGlzLnJlYWRkaXIgPSBudWxsXG4gICAgdGhpcy5wZW5kaW5nID0gZmFsc2VcbiAgICB0aGlzLmlnbm9yZSA9IGZhbHNlXG4gICAgdGhpcy5waXBlZCA9IGZhbHNlXG4gIH1cbn1cblxuY29uc3QgTWluaVBhc3MgPSByZXF1aXJlKCdtaW5pcGFzcycpXG5jb25zdCB6bGliID0gcmVxdWlyZSgnbWluaXpsaWInKVxuY29uc3QgUmVhZEVudHJ5ID0gcmVxdWlyZSgnLi9yZWFkLWVudHJ5LmpzJylcbmNvbnN0IFdyaXRlRW50cnkgPSByZXF1aXJlKCcuL3dyaXRlLWVudHJ5LmpzJylcbmNvbnN0IFdyaXRlRW50cnlTeW5jID0gV3JpdGVFbnRyeS5TeW5jXG5jb25zdCBXcml0ZUVudHJ5VGFyID0gV3JpdGVFbnRyeS5UYXJcbmNvbnN0IFlhbGxpc3QgPSByZXF1aXJlKCd5YWxsaXN0JylcbmNvbnN0IEVPRiA9IEJ1ZmZlci5hbGxvYygxMDI0KVxuY29uc3QgT05TVEFUID0gU3ltYm9sKCdvblN0YXQnKVxuY29uc3QgRU5ERUQgPSBTeW1ib2woJ2VuZGVkJylcbmNvbnN0IFFVRVVFID0gU3ltYm9sKCdxdWV1ZScpXG5jb25zdCBDVVJSRU5UID0gU3ltYm9sKCdjdXJyZW50JylcbmNvbnN0IFBST0NFU1MgPSBTeW1ib2woJ3Byb2Nlc3MnKVxuY29uc3QgUFJPQ0VTU0lORyA9IFN5bWJvbCgncHJvY2Vzc2luZycpXG5jb25zdCBQUk9DRVNTSk9CID0gU3ltYm9sKCdwcm9jZXNzSm9iJylcbmNvbnN0IEpPQlMgPSBTeW1ib2woJ2pvYnMnKVxuY29uc3QgSk9CRE9ORSA9IFN5bWJvbCgnam9iRG9uZScpXG5jb25zdCBBRERGU0VOVFJZID0gU3ltYm9sKCdhZGRGU0VudHJ5JylcbmNvbnN0IEFERFRBUkVOVFJZID0gU3ltYm9sKCdhZGRUYXJFbnRyeScpXG5jb25zdCBTVEFUID0gU3ltYm9sKCdzdGF0JylcbmNvbnN0IFJFQURESVIgPSBTeW1ib2woJ3JlYWRkaXInKVxuY29uc3QgT05SRUFERElSID0gU3ltYm9sKCdvbnJlYWRkaXInKVxuY29uc3QgUElQRSA9IFN5bWJvbCgncGlwZScpXG5jb25zdCBFTlRSWSA9IFN5bWJvbCgnZW50cnknKVxuY29uc3QgRU5UUllPUFQgPSBTeW1ib2woJ2VudHJ5T3B0JylcbmNvbnN0IFdSSVRFRU5UUllDTEFTUyA9IFN5bWJvbCgnd3JpdGVFbnRyeUNsYXNzJylcbmNvbnN0IFdSSVRFID0gU3ltYm9sKCd3cml0ZScpXG5jb25zdCBPTkRSQUlOID0gU3ltYm9sKCdvbmRyYWluJylcblxuY29uc3QgZnMgPSByZXF1aXJlKCdmcycpXG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpXG5jb25zdCB3YXJuZXIgPSByZXF1aXJlKCcuL3dhcm4tbWl4aW4uanMnKVxuY29uc3Qgbm9ybVBhdGggPSByZXF1aXJlKCcuL25vcm1hbGl6ZS13aW5kb3dzLXBhdGguanMnKVxuXG5jb25zdCBQYWNrID0gd2FybmVyKGNsYXNzIFBhY2sgZXh0ZW5kcyBNaW5pUGFzcyB7XG4gIGNvbnN0cnVjdG9yIChvcHQpIHtcbiAgICBzdXBlcihvcHQpXG4gICAgb3B0ID0gb3B0IHx8IE9iamVjdC5jcmVhdGUobnVsbClcbiAgICB0aGlzLm9wdCA9IG9wdFxuICAgIHRoaXMuY3dkID0gb3B0LmN3ZCB8fCBwcm9jZXNzLmN3ZCgpXG4gICAgdGhpcy5tYXhSZWFkU2l6ZSA9IG9wdC5tYXhSZWFkU2l6ZVxuICAgIHRoaXMucHJlc2VydmVQYXRocyA9ICEhb3B0LnByZXNlcnZlUGF0aHNcbiAgICB0aGlzLnN0cmljdCA9ICEhb3B0LnN0cmljdFxuICAgIHRoaXMubm9QYXggPSAhIW9wdC5ub1BheFxuICAgIHRoaXMucHJlZml4ID0gbm9ybVBhdGgob3B0LnByZWZpeCB8fCAnJylcbiAgICB0aGlzLmxpbmtDYWNoZSA9IG9wdC5saW5rQ2FjaGUgfHwgbmV3IE1hcCgpXG4gICAgdGhpcy5zdGF0Q2FjaGUgPSBvcHQuc3RhdENhY2hlIHx8IG5ldyBNYXAoKVxuICAgIHRoaXMucmVhZGRpckNhY2hlID0gb3B0LnJlYWRkaXJDYWNoZSB8fCBuZXcgTWFwKClcblxuICAgIHRoaXNbV1JJVEVFTlRSWUNMQVNTXSA9IFdyaXRlRW50cnlcbiAgICBpZiAodHlwZW9mIG9wdC5vbndhcm4gPT09ICdmdW5jdGlvbicpXG4gICAgICB0aGlzLm9uKCd3YXJuJywgb3B0Lm9ud2FybilcblxuICAgIHRoaXMuemlwID0gbnVsbFxuICAgIGlmIChvcHQuZ3ppcCkge1xuICAgICAgaWYgKHR5cGVvZiBvcHQuZ3ppcCAhPT0gJ29iamVjdCcpXG4gICAgICAgIG9wdC5nemlwID0ge31cbiAgICAgIHRoaXMuemlwID0gbmV3IHpsaWIuR3ppcChvcHQuZ3ppcClcbiAgICAgIHRoaXMuemlwLm9uKCdkYXRhJywgY2h1bmsgPT4gc3VwZXIud3JpdGUoY2h1bmspKVxuICAgICAgdGhpcy56aXAub24oJ2VuZCcsIF8gPT4gc3VwZXIuZW5kKCkpXG4gICAgICB0aGlzLnppcC5vbignZHJhaW4nLCBfID0+IHRoaXNbT05EUkFJTl0oKSlcbiAgICAgIHRoaXMub24oJ3Jlc3VtZScsIF8gPT4gdGhpcy56aXAucmVzdW1lKCkpXG4gICAgfSBlbHNlXG4gICAgICB0aGlzLm9uKCdkcmFpbicsIHRoaXNbT05EUkFJTl0pXG5cbiAgICB0aGlzLnBvcnRhYmxlID0gISFvcHQucG9ydGFibGVcbiAgICB0aGlzLm5vRGlyUmVjdXJzZSA9ICEhb3B0Lm5vRGlyUmVjdXJzZVxuICAgIHRoaXMuZm9sbG93ID0gISFvcHQuZm9sbG93XG4gICAgdGhpcy5ub010aW1lID0gISFvcHQubm9NdGltZVxuICAgIHRoaXMubXRpbWUgPSBvcHQubXRpbWUgfHwgbnVsbFxuXG4gICAgdGhpcy5maWx0ZXIgPSB0eXBlb2Ygb3B0LmZpbHRlciA9PT0gJ2Z1bmN0aW9uJyA/IG9wdC5maWx0ZXIgOiBfID0+IHRydWVcblxuICAgIHRoaXNbUVVFVUVdID0gbmV3IFlhbGxpc3RcbiAgICB0aGlzW0pPQlNdID0gMFxuICAgIHRoaXMuam9icyA9ICtvcHQuam9icyB8fCA0XG4gICAgdGhpc1tQUk9DRVNTSU5HXSA9IGZhbHNlXG4gICAgdGhpc1tFTkRFRF0gPSBmYWxzZVxuICB9XG5cbiAgW1dSSVRFXSAoY2h1bmspIHtcbiAgICByZXR1cm4gc3VwZXIud3JpdGUoY2h1bmspXG4gIH1cblxuICBhZGQgKHBhdGgpIHtcbiAgICB0aGlzLndyaXRlKHBhdGgpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIGVuZCAocGF0aCkge1xuICAgIGlmIChwYXRoKVxuICAgICAgdGhpcy53cml0ZShwYXRoKVxuICAgIHRoaXNbRU5ERURdID0gdHJ1ZVxuICAgIHRoaXNbUFJPQ0VTU10oKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICB3cml0ZSAocGF0aCkge1xuICAgIGlmICh0aGlzW0VOREVEXSlcbiAgICAgIHRocm93IG5ldyBFcnJvcignd3JpdGUgYWZ0ZXIgZW5kJylcblxuICAgIGlmIChwYXRoIGluc3RhbmNlb2YgUmVhZEVudHJ5KVxuICAgICAgdGhpc1tBRERUQVJFTlRSWV0ocGF0aClcbiAgICBlbHNlXG4gICAgICB0aGlzW0FEREZTRU5UUlldKHBhdGgpXG4gICAgcmV0dXJuIHRoaXMuZmxvd2luZ1xuICB9XG5cbiAgW0FERFRBUkVOVFJZXSAocCkge1xuICAgIGNvbnN0IGFic29sdXRlID0gbm9ybVBhdGgocGF0aC5yZXNvbHZlKHRoaXMuY3dkLCBwLnBhdGgpKVxuICAgIC8vIGluIHRoaXMgY2FzZSwgd2UgZG9uJ3QgaGF2ZSB0byB3YWl0IGZvciB0aGUgc3RhdFxuICAgIGlmICghdGhpcy5maWx0ZXIocC5wYXRoLCBwKSlcbiAgICAgIHAucmVzdW1lKClcbiAgICBlbHNlIHtcbiAgICAgIGNvbnN0IGpvYiA9IG5ldyBQYWNrSm9iKHAucGF0aCwgYWJzb2x1dGUsIGZhbHNlKVxuICAgICAgam9iLmVudHJ5ID0gbmV3IFdyaXRlRW50cnlUYXIocCwgdGhpc1tFTlRSWU9QVF0oam9iKSlcbiAgICAgIGpvYi5lbnRyeS5vbignZW5kJywgXyA9PiB0aGlzW0pPQkRPTkVdKGpvYikpXG4gICAgICB0aGlzW0pPQlNdICs9IDFcbiAgICAgIHRoaXNbUVVFVUVdLnB1c2goam9iKVxuICAgIH1cblxuICAgIHRoaXNbUFJPQ0VTU10oKVxuICB9XG5cbiAgW0FEREZTRU5UUlldIChwKSB7XG4gICAgY29uc3QgYWJzb2x1dGUgPSBub3JtUGF0aChwYXRoLnJlc29sdmUodGhpcy5jd2QsIHApKVxuICAgIHRoaXNbUVVFVUVdLnB1c2gobmV3IFBhY2tKb2IocCwgYWJzb2x1dGUpKVxuICAgIHRoaXNbUFJPQ0VTU10oKVxuICB9XG5cbiAgW1NUQVRdIChqb2IpIHtcbiAgICBqb2IucGVuZGluZyA9IHRydWVcbiAgICB0aGlzW0pPQlNdICs9IDFcbiAgICBjb25zdCBzdGF0ID0gdGhpcy5mb2xsb3cgPyAnc3RhdCcgOiAnbHN0YXQnXG4gICAgZnNbc3RhdF0oam9iLmFic29sdXRlLCAoZXIsIHN0YXQpID0+IHtcbiAgICAgIGpvYi5wZW5kaW5nID0gZmFsc2VcbiAgICAgIHRoaXNbSk9CU10gLT0gMVxuICAgICAgaWYgKGVyKVxuICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXIpXG4gICAgICBlbHNlXG4gICAgICAgIHRoaXNbT05TVEFUXShqb2IsIHN0YXQpXG4gICAgfSlcbiAgfVxuXG4gIFtPTlNUQVRdIChqb2IsIHN0YXQpIHtcbiAgICB0aGlzLnN0YXRDYWNoZS5zZXQoam9iLmFic29sdXRlLCBzdGF0KVxuICAgIGpvYi5zdGF0ID0gc3RhdFxuXG4gICAgLy8gbm93IHdlIGhhdmUgdGhlIHN0YXQsIHdlIGNhbiBmaWx0ZXIgaXQuXG4gICAgaWYgKCF0aGlzLmZpbHRlcihqb2IucGF0aCwgc3RhdCkpXG4gICAgICBqb2IuaWdub3JlID0gdHJ1ZVxuXG4gICAgdGhpc1tQUk9DRVNTXSgpXG4gIH1cblxuICBbUkVBRERJUl0gKGpvYikge1xuICAgIGpvYi5wZW5kaW5nID0gdHJ1ZVxuICAgIHRoaXNbSk9CU10gKz0gMVxuICAgIGZzLnJlYWRkaXIoam9iLmFic29sdXRlLCAoZXIsIGVudHJpZXMpID0+IHtcbiAgICAgIGpvYi5wZW5kaW5nID0gZmFsc2VcbiAgICAgIHRoaXNbSk9CU10gLT0gMVxuICAgICAgaWYgKGVyKVxuICAgICAgICByZXR1cm4gdGhpcy5lbWl0KCdlcnJvcicsIGVyKVxuICAgICAgdGhpc1tPTlJFQURESVJdKGpvYiwgZW50cmllcylcbiAgICB9KVxuICB9XG5cbiAgW09OUkVBRERJUl0gKGpvYiwgZW50cmllcykge1xuICAgIHRoaXMucmVhZGRpckNhY2hlLnNldChqb2IuYWJzb2x1dGUsIGVudHJpZXMpXG4gICAgam9iLnJlYWRkaXIgPSBlbnRyaWVzXG4gICAgdGhpc1tQUk9DRVNTXSgpXG4gIH1cblxuICBbUFJPQ0VTU10gKCkge1xuICAgIGlmICh0aGlzW1BST0NFU1NJTkddKVxuICAgICAgcmV0dXJuXG5cbiAgICB0aGlzW1BST0NFU1NJTkddID0gdHJ1ZVxuICAgIGZvciAobGV0IHcgPSB0aGlzW1FVRVVFXS5oZWFkO1xuICAgICAgICAgdyAhPT0gbnVsbCAmJiB0aGlzW0pPQlNdIDwgdGhpcy5qb2JzO1xuICAgICAgICAgdyA9IHcubmV4dCkge1xuICAgICAgdGhpc1tQUk9DRVNTSk9CXSh3LnZhbHVlKVxuICAgICAgaWYgKHcudmFsdWUuaWdub3JlKSB7XG4gICAgICAgIGNvbnN0IHAgPSB3Lm5leHRcbiAgICAgICAgdGhpc1tRVUVVRV0ucmVtb3ZlTm9kZSh3KVxuICAgICAgICB3Lm5leHQgPSBwXG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpc1tQUk9DRVNTSU5HXSA9IGZhbHNlXG5cbiAgICBpZiAodGhpc1tFTkRFRF0gJiYgIXRoaXNbUVVFVUVdLmxlbmd0aCAmJiB0aGlzW0pPQlNdID09PSAwKSB7XG4gICAgICBpZiAodGhpcy56aXApXG4gICAgICAgIHRoaXMuemlwLmVuZChFT0YpXG4gICAgICBlbHNlIHtcbiAgICAgICAgc3VwZXIud3JpdGUoRU9GKVxuICAgICAgICBzdXBlci5lbmQoKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGdldCBbQ1VSUkVOVF0gKCkge1xuICAgIHJldHVybiB0aGlzW1FVRVVFXSAmJiB0aGlzW1FVRVVFXS5oZWFkICYmIHRoaXNbUVVFVUVdLmhlYWQudmFsdWVcbiAgfVxuXG4gIFtKT0JET05FXSAoam9iKSB7XG4gICAgdGhpc1tRVUVVRV0uc2hpZnQoKVxuICAgIHRoaXNbSk9CU10gLT0gMVxuICAgIHRoaXNbUFJPQ0VTU10oKVxuICB9XG5cbiAgW1BST0NFU1NKT0JdIChqb2IpIHtcbiAgICBpZiAoam9iLnBlbmRpbmcpXG4gICAgICByZXR1cm5cblxuICAgIGlmIChqb2IuZW50cnkpIHtcbiAgICAgIGlmIChqb2IgPT09IHRoaXNbQ1VSUkVOVF0gJiYgIWpvYi5waXBlZClcbiAgICAgICAgdGhpc1tQSVBFXShqb2IpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAoIWpvYi5zdGF0KSB7XG4gICAgICBpZiAodGhpcy5zdGF0Q2FjaGUuaGFzKGpvYi5hYnNvbHV0ZSkpXG4gICAgICAgIHRoaXNbT05TVEFUXShqb2IsIHRoaXMuc3RhdENhY2hlLmdldChqb2IuYWJzb2x1dGUpKVxuICAgICAgZWxzZVxuICAgICAgICB0aGlzW1NUQVRdKGpvYilcbiAgICB9XG4gICAgaWYgKCFqb2Iuc3RhdClcbiAgICAgIHJldHVyblxuXG4gICAgLy8gZmlsdGVyZWQgb3V0IVxuICAgIGlmIChqb2IuaWdub3JlKVxuICAgICAgcmV0dXJuXG5cbiAgICBpZiAoIXRoaXMubm9EaXJSZWN1cnNlICYmIGpvYi5zdGF0LmlzRGlyZWN0b3J5KCkgJiYgIWpvYi5yZWFkZGlyKSB7XG4gICAgICBpZiAodGhpcy5yZWFkZGlyQ2FjaGUuaGFzKGpvYi5hYnNvbHV0ZSkpXG4gICAgICAgIHRoaXNbT05SRUFERElSXShqb2IsIHRoaXMucmVhZGRpckNhY2hlLmdldChqb2IuYWJzb2x1dGUpKVxuICAgICAgZWxzZVxuICAgICAgICB0aGlzW1JFQURESVJdKGpvYilcbiAgICAgIGlmICgham9iLnJlYWRkaXIpXG4gICAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIHdlIGtub3cgaXQgZG9lc24ndCBoYXZlIGFuIGVudHJ5LCBiZWNhdXNlIHRoYXQgZ290IGNoZWNrZWQgYWJvdmVcbiAgICBqb2IuZW50cnkgPSB0aGlzW0VOVFJZXShqb2IpXG4gICAgaWYgKCFqb2IuZW50cnkpIHtcbiAgICAgIGpvYi5pZ25vcmUgPSB0cnVlXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAoam9iID09PSB0aGlzW0NVUlJFTlRdICYmICFqb2IucGlwZWQpXG4gICAgICB0aGlzW1BJUEVdKGpvYilcbiAgfVxuXG4gIFtFTlRSWU9QVF0gKGpvYikge1xuICAgIHJldHVybiB7XG4gICAgICBvbndhcm46IChtc2csIGRhdGEpID0+IHtcbiAgICAgICAgdGhpcy53YXJuKG1zZywgZGF0YSlcbiAgICAgIH0sXG4gICAgICBub1BheDogdGhpcy5ub1BheCxcbiAgICAgIGN3ZDogdGhpcy5jd2QsXG4gICAgICBhYnNvbHV0ZTogam9iLmFic29sdXRlLFxuICAgICAgcHJlc2VydmVQYXRoczogdGhpcy5wcmVzZXJ2ZVBhdGhzLFxuICAgICAgbWF4UmVhZFNpemU6IHRoaXMubWF4UmVhZFNpemUsXG4gICAgICBzdHJpY3Q6IHRoaXMuc3RyaWN0LFxuICAgICAgcG9ydGFibGU6IHRoaXMucG9ydGFibGUsXG4gICAgICBsaW5rQ2FjaGU6IHRoaXMubGlua0NhY2hlLFxuICAgICAgc3RhdENhY2hlOiB0aGlzLnN0YXRDYWNoZSxcbiAgICAgIG5vTXRpbWU6IHRoaXMubm9NdGltZSxcbiAgICAgIG10aW1lOiB0aGlzLm10aW1lLFxuICAgICAgcHJlZml4OiB0aGlzLnByZWZpeCxcbiAgICB9XG4gIH1cblxuICBbRU5UUlldIChqb2IpIHtcbiAgICB0aGlzW0pPQlNdICs9IDFcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIG5ldyB0aGlzW1dSSVRFRU5UUllDTEFTU10oam9iLnBhdGgsIHRoaXNbRU5UUllPUFRdKGpvYikpXG4gICAgICAgIC5vbignZW5kJywgKCkgPT4gdGhpc1tKT0JET05FXShqb2IpKVxuICAgICAgICAub24oJ2Vycm9yJywgZXIgPT4gdGhpcy5lbWl0KCdlcnJvcicsIGVyKSlcbiAgICB9IGNhdGNoIChlcikge1xuICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIGVyKVxuICAgIH1cbiAgfVxuXG4gIFtPTkRSQUlOXSAoKSB7XG4gICAgaWYgKHRoaXNbQ1VSUkVOVF0gJiYgdGhpc1tDVVJSRU5UXS5lbnRyeSlcbiAgICAgIHRoaXNbQ1VSUkVOVF0uZW50cnkucmVzdW1lKClcbiAgfVxuXG4gIC8vIGxpa2UgLnBpcGUoKSBidXQgdXNpbmcgc3VwZXIsIGJlY2F1c2Ugb3VyIHdyaXRlKCkgaXMgc3BlY2lhbFxuICBbUElQRV0gKGpvYikge1xuICAgIGpvYi5waXBlZCA9IHRydWVcblxuICAgIGlmIChqb2IucmVhZGRpcilcbiAgICAgIGpvYi5yZWFkZGlyLmZvckVhY2goZW50cnkgPT4ge1xuICAgICAgICBjb25zdCBwID0gam9iLnBhdGhcbiAgICAgICAgY29uc3QgYmFzZSA9IHAgPT09ICcuLycgPyAnJyA6IHAucmVwbGFjZSgvXFwvKiQvLCAnLycpXG4gICAgICAgIHRoaXNbQURERlNFTlRSWV0oYmFzZSArIGVudHJ5KVxuICAgICAgfSlcblxuICAgIGNvbnN0IHNvdXJjZSA9IGpvYi5lbnRyeVxuICAgIGNvbnN0IHppcCA9IHRoaXMuemlwXG5cbiAgICBpZiAoemlwKVxuICAgICAgc291cmNlLm9uKCdkYXRhJywgY2h1bmsgPT4ge1xuICAgICAgICBpZiAoIXppcC53cml0ZShjaHVuaykpXG4gICAgICAgICAgc291cmNlLnBhdXNlKClcbiAgICAgIH0pXG4gICAgZWxzZVxuICAgICAgc291cmNlLm9uKCdkYXRhJywgY2h1bmsgPT4ge1xuICAgICAgICBpZiAoIXN1cGVyLndyaXRlKGNodW5rKSlcbiAgICAgICAgICBzb3VyY2UucGF1c2UoKVxuICAgICAgfSlcbiAgfVxuXG4gIHBhdXNlICgpIHtcbiAgICBpZiAodGhpcy56aXApXG4gICAgICB0aGlzLnppcC5wYXVzZSgpXG4gICAgcmV0dXJuIHN1cGVyLnBhdXNlKClcbiAgfVxufSlcblxuY2xhc3MgUGFja1N5bmMgZXh0ZW5kcyBQYWNrIHtcbiAgY29uc3RydWN0b3IgKG9wdCkge1xuICAgIHN1cGVyKG9wdClcbiAgICB0aGlzW1dSSVRFRU5UUllDTEFTU10gPSBXcml0ZUVudHJ5U3luY1xuICB9XG5cbiAgLy8gcGF1c2UvcmVzdW1lIGFyZSBuby1vcHMgaW4gc3luYyBzdHJlYW1zLlxuICBwYXVzZSAoKSB7fVxuICByZXN1bWUgKCkge31cblxuICBbU1RBVF0gKGpvYikge1xuICAgIGNvbnN0IHN0YXQgPSB0aGlzLmZvbGxvdyA/ICdzdGF0U3luYycgOiAnbHN0YXRTeW5jJ1xuICAgIHRoaXNbT05TVEFUXShqb2IsIGZzW3N0YXRdKGpvYi5hYnNvbHV0ZSkpXG4gIH1cblxuICBbUkVBRERJUl0gKGpvYiwgc3RhdCkge1xuICAgIHRoaXNbT05SRUFERElSXShqb2IsIGZzLnJlYWRkaXJTeW5jKGpvYi5hYnNvbHV0ZSkpXG4gIH1cblxuICAvLyBnb3R0YSBnZXQgaXQgYWxsIGluIHRoaXMgdGlja1xuICBbUElQRV0gKGpvYikge1xuICAgIGNvbnN0IHNvdXJjZSA9IGpvYi5lbnRyeVxuICAgIGNvbnN0IHppcCA9IHRoaXMuemlwXG5cbiAgICBpZiAoam9iLnJlYWRkaXIpXG4gICAgICBqb2IucmVhZGRpci5mb3JFYWNoKGVudHJ5ID0+IHtcbiAgICAgICAgY29uc3QgcCA9IGpvYi5wYXRoXG4gICAgICAgIGNvbnN0IGJhc2UgPSBwID09PSAnLi8nID8gJycgOiBwLnJlcGxhY2UoL1xcLyokLywgJy8nKVxuICAgICAgICB0aGlzW0FEREZTRU5UUlldKGJhc2UgKyBlbnRyeSlcbiAgICAgIH0pXG5cbiAgICBpZiAoemlwKVxuICAgICAgc291cmNlLm9uKCdkYXRhJywgY2h1bmsgPT4ge1xuICAgICAgICB6aXAud3JpdGUoY2h1bmspXG4gICAgICB9KVxuICAgIGVsc2VcbiAgICAgIHNvdXJjZS5vbignZGF0YScsIGNodW5rID0+IHtcbiAgICAgICAgc3VwZXJbV1JJVEVdKGNodW5rKVxuICAgICAgfSlcbiAgfVxufVxuXG5QYWNrLlN5bmMgPSBQYWNrU3luY1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBhY2tcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/tar/lib/pack.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/tar/lib/parse.js":
/*!*******************************************!*\
  !*** ../../node_modules/tar/lib/parse.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n// this[BUFFER] is the remainder of a chunk if we're waiting for\n// the full 512 bytes of a header to come in.  We will Buffer.concat()\n// it to the next write(), which is a mem copy, but a small one.\n//\n// this[QUEUE] is a Yallist of entries that haven't been emitted\n// yet this can only get filled up if the user keeps write()ing after\n// a write() returns false, or does a write() with more than one entry\n//\n// We don't buffer chunks, we always parse them and either create an\n// entry, or push it into the active entry.  The ReadEntry class knows\n// to throw data away if .ignore=true\n//\n// Shift entry off the buffer when it emits 'end', and emit 'entry' for\n// the next one in the list.\n//\n// At any time, we're pushing body chunks into the entry at WRITEENTRY,\n// and waiting for 'end' on the entry at READENTRY\n//\n// ignored entries get .resume() called on them straight away\n\nconst warner = __webpack_require__(/*! ./warn-mixin.js */ \"(rsc)/../../node_modules/tar/lib/warn-mixin.js\")\nconst path = __webpack_require__(/*! path */ \"path\")\nconst Header = __webpack_require__(/*! ./header.js */ \"(rsc)/../../node_modules/tar/lib/header.js\")\nconst EE = __webpack_require__(/*! events */ \"events\")\nconst Yallist = __webpack_require__(/*! yallist */ \"(rsc)/../../node_modules/yallist/yallist.js\")\nconst maxMetaEntrySize = 1024 * 1024\nconst Entry = __webpack_require__(/*! ./read-entry.js */ \"(rsc)/../../node_modules/tar/lib/read-entry.js\")\nconst Pax = __webpack_require__(/*! ./pax.js */ \"(rsc)/../../node_modules/tar/lib/pax.js\")\nconst zlib = __webpack_require__(/*! minizlib */ \"(rsc)/../../node_modules/minizlib/index.js\")\nconst Buffer = __webpack_require__(/*! ./buffer.js */ \"(rsc)/../../node_modules/tar/lib/buffer.js\")\n\nconst gzipHeader = Buffer.from([0x1f, 0x8b])\nconst STATE = Symbol('state')\nconst WRITEENTRY = Symbol('writeEntry')\nconst READENTRY = Symbol('readEntry')\nconst NEXTENTRY = Symbol('nextEntry')\nconst PROCESSENTRY = Symbol('processEntry')\nconst EX = Symbol('extendedHeader')\nconst GEX = Symbol('globalExtendedHeader')\nconst META = Symbol('meta')\nconst EMITMETA = Symbol('emitMeta')\nconst BUFFER = Symbol('buffer')\nconst QUEUE = Symbol('queue')\nconst ENDED = Symbol('ended')\nconst EMITTEDEND = Symbol('emittedEnd')\nconst EMIT = Symbol('emit')\nconst UNZIP = Symbol('unzip')\nconst CONSUMECHUNK = Symbol('consumeChunk')\nconst CONSUMECHUNKSUB = Symbol('consumeChunkSub')\nconst CONSUMEBODY = Symbol('consumeBody')\nconst CONSUMEMETA = Symbol('consumeMeta')\nconst CONSUMEHEADER = Symbol('consumeHeader')\nconst CONSUMING = Symbol('consuming')\nconst BUFFERCONCAT = Symbol('bufferConcat')\nconst MAYBEEND = Symbol('maybeEnd')\nconst WRITING = Symbol('writing')\nconst ABORTED = Symbol('aborted')\nconst DONE = Symbol('onDone')\n\nconst noop = _ => true\n\nmodule.exports = warner(class Parser extends EE {\n  constructor (opt) {\n    opt = opt || {}\n    super(opt)\n\n    if (opt.ondone)\n      this.on(DONE, opt.ondone)\n    else\n      this.on(DONE, _ => {\n        this.emit('prefinish')\n        this.emit('finish')\n        this.emit('end')\n        this.emit('close')\n      })\n\n    this.strict = !!opt.strict\n    this.maxMetaEntrySize = opt.maxMetaEntrySize || maxMetaEntrySize\n    this.filter = typeof opt.filter === 'function' ? opt.filter : noop\n\n    // have to set this so that streams are ok piping into it\n    this.writable = true\n    this.readable = false\n\n    this[QUEUE] = new Yallist()\n    this[BUFFER] = null\n    this[READENTRY] = null\n    this[WRITEENTRY] = null\n    this[STATE] = 'begin'\n    this[META] = ''\n    this[EX] = null\n    this[GEX] = null\n    this[ENDED] = false\n    this[UNZIP] = null\n    this[ABORTED] = false\n    if (typeof opt.onwarn === 'function')\n      this.on('warn', opt.onwarn)\n    if (typeof opt.onentry === 'function')\n      this.on('entry', opt.onentry)\n  }\n\n  [CONSUMEHEADER] (chunk, position) {\n    let header\n    try {\n      header = new Header(chunk, position, this[EX], this[GEX])\n    } catch (er) {\n      return this.warn('invalid entry', er)\n    }\n\n    if (header.nullBlock)\n      this[EMIT]('nullBlock')\n    else if (!header.cksumValid)\n      this.warn('invalid entry', header)\n    else if (!header.path)\n      this.warn('invalid: path is required', header)\n    else {\n      const type = header.type\n      if (/^(Symbolic)?Link$/.test(type) && !header.linkpath)\n        this.warn('invalid: linkpath required', header)\n      else if (!/^(Symbolic)?Link$/.test(type) && header.linkpath)\n        this.warn('invalid: linkpath forbidden', header)\n      else {\n        const entry = this[WRITEENTRY] = new Entry(header, this[EX], this[GEX])\n\n        if (entry.meta) {\n          if (entry.size > this.maxMetaEntrySize) {\n            entry.ignore = true\n            this[EMIT]('ignoredEntry', entry)\n            this[STATE] = 'ignore'\n          } else if (entry.size > 0) {\n            this[META] = ''\n            entry.on('data', c => this[META] += c)\n            this[STATE] = 'meta'\n          }\n        } else {\n\n          this[EX] = null\n          entry.ignore = entry.ignore || !this.filter(entry.path, entry)\n          if (entry.ignore) {\n            this[EMIT]('ignoredEntry', entry)\n            this[STATE] = entry.remain ? 'ignore' : 'begin'\n          } else {\n            if (entry.remain)\n              this[STATE] = 'body'\n            else {\n              this[STATE] = 'begin'\n              entry.end()\n            }\n\n            if (!this[READENTRY]) {\n              this[QUEUE].push(entry)\n              this[NEXTENTRY]()\n            } else\n              this[QUEUE].push(entry)\n          }\n        }\n      }\n    }\n  }\n\n  [PROCESSENTRY] (entry) {\n    let go = true\n\n    if (!entry) {\n      this[READENTRY] = null\n      go = false\n    } else if (Array.isArray(entry))\n      this.emit.apply(this, entry)\n    else {\n      this[READENTRY] = entry\n      this.emit('entry', entry)\n      if (!entry.emittedEnd) {\n        entry.on('end', _ => this[NEXTENTRY]())\n        go = false\n      }\n    }\n\n    return go\n  }\n\n  [NEXTENTRY] () {\n    do {} while (this[PROCESSENTRY](this[QUEUE].shift()))\n\n    if (!this[QUEUE].length) {\n      // At this point, there's nothing in the queue, but we may have an\n      // entry which is being consumed (readEntry).\n      // If we don't, then we definitely can handle more data.\n      // If we do, and either it's flowing, or it has never had any data\n      // written to it, then it needs more.\n      // The only other possibility is that it has returned false from a\n      // write() call, so we wait for the next drain to continue.\n      const re = this[READENTRY]\n      const drainNow = !re || re.flowing || re.size === re.remain\n      if (drainNow) {\n        if (!this[WRITING])\n          this.emit('drain')\n      } else\n        re.once('drain', _ => this.emit('drain'))\n     }\n  }\n\n  [CONSUMEBODY] (chunk, position) {\n    // write up to but no  more than writeEntry.blockRemain\n    const entry = this[WRITEENTRY]\n    const br = entry.blockRemain\n    const c = (br >= chunk.length && position === 0) ? chunk\n      : chunk.slice(position, position + br)\n\n    entry.write(c)\n\n    if (!entry.blockRemain) {\n      this[STATE] = 'begin'\n      this[WRITEENTRY] = null\n      entry.end()\n    }\n\n    return c.length\n  }\n\n  [CONSUMEMETA] (chunk, position) {\n    const entry = this[WRITEENTRY]\n    const ret = this[CONSUMEBODY](chunk, position)\n\n    // if we finished, then the entry is reset\n    if (!this[WRITEENTRY])\n      this[EMITMETA](entry)\n\n    return ret\n  }\n\n  [EMIT] (ev, data, extra) {\n    if (!this[QUEUE].length && !this[READENTRY])\n      this.emit(ev, data, extra)\n    else\n      this[QUEUE].push([ev, data, extra])\n  }\n\n  [EMITMETA] (entry) {\n    this[EMIT]('meta', this[META])\n    switch (entry.type) {\n      case 'ExtendedHeader':\n      case 'OldExtendedHeader':\n        this[EX] = Pax.parse(this[META], this[EX], false)\n        break\n\n      case 'GlobalExtendedHeader':\n        this[GEX] = Pax.parse(this[META], this[GEX], true)\n        break\n\n      case 'NextFileHasLongPath':\n      case 'OldGnuLongPath':\n        this[EX] = this[EX] || Object.create(null)\n        this[EX].path = this[META].replace(/\\0.*/, '')\n        break\n\n      case 'NextFileHasLongLinkpath':\n        this[EX] = this[EX] || Object.create(null)\n        this[EX].linkpath = this[META].replace(/\\0.*/, '')\n        break\n\n      /* istanbul ignore next */\n      default: throw new Error('unknown meta: ' + entry.type)\n    }\n  }\n\n  abort (msg, error) {\n    this[ABORTED] = true\n    this.warn(msg, error)\n    this.emit('abort', error)\n    this.emit('error', error)\n  }\n\n  write (chunk) {\n    if (this[ABORTED])\n      return\n\n    // first write, might be gzipped\n    if (this[UNZIP] === null && chunk) {\n      if (this[BUFFER]) {\n        chunk = Buffer.concat([this[BUFFER], chunk])\n        this[BUFFER] = null\n      }\n      if (chunk.length < gzipHeader.length) {\n        this[BUFFER] = chunk\n        return true\n      }\n      for (let i = 0; this[UNZIP] === null && i < gzipHeader.length; i++) {\n        if (chunk[i] !== gzipHeader[i])\n          this[UNZIP] = false\n      }\n      if (this[UNZIP] === null) {\n        const ended = this[ENDED]\n        this[ENDED] = false\n        this[UNZIP] = new zlib.Unzip()\n        this[UNZIP].on('data', chunk => this[CONSUMECHUNK](chunk))\n        this[UNZIP].on('error', er =>\n          this.abort(er.message, er))\n        this[UNZIP].on('end', _ => {\n          this[ENDED] = true\n          this[CONSUMECHUNK]()\n        })\n        this[WRITING] = true\n        const ret = this[UNZIP][ended ? 'end' : 'write' ](chunk)\n        this[WRITING] = false\n        return ret\n      }\n    }\n\n    this[WRITING] = true\n    if (this[UNZIP])\n      this[UNZIP].write(chunk)\n    else\n      this[CONSUMECHUNK](chunk)\n    this[WRITING] = false\n\n    // return false if there's a queue, or if the current entry isn't flowing\n    const ret =\n      this[QUEUE].length ? false :\n      this[READENTRY] ? this[READENTRY].flowing :\n      true\n\n    // if we have no queue, then that means a clogged READENTRY\n    if (!ret && !this[QUEUE].length)\n      this[READENTRY].once('drain', _ => this.emit('drain'))\n\n    return ret\n  }\n\n  [BUFFERCONCAT] (c) {\n    if (c && !this[ABORTED])\n      this[BUFFER] = this[BUFFER] ? Buffer.concat([this[BUFFER], c]) : c\n  }\n\n  [MAYBEEND] () {\n    if (this[ENDED] &&\n        !this[EMITTEDEND] &&\n        !this[ABORTED] &&\n        !this[CONSUMING]) {\n      this[EMITTEDEND] = true\n      const entry = this[WRITEENTRY]\n      if (entry && entry.blockRemain) {\n        const have = this[BUFFER] ? this[BUFFER].length : 0\n        this.warn('Truncated input (needed ' + entry.blockRemain +\n                  ' more bytes, only ' + have + ' available)', entry)\n        if (this[BUFFER])\n          entry.write(this[BUFFER])\n        entry.end()\n      }\n      this[EMIT](DONE)\n    }\n  }\n\n  [CONSUMECHUNK] (chunk) {\n    if (this[CONSUMING]) {\n      this[BUFFERCONCAT](chunk)\n    } else if (!chunk && !this[BUFFER]) {\n      this[MAYBEEND]()\n    } else {\n      this[CONSUMING] = true\n      if (this[BUFFER]) {\n        this[BUFFERCONCAT](chunk)\n        const c = this[BUFFER]\n        this[BUFFER] = null\n        this[CONSUMECHUNKSUB](c)\n      } else {\n        this[CONSUMECHUNKSUB](chunk)\n      }\n\n      while (this[BUFFER] && this[BUFFER].length >= 512 && !this[ABORTED]) {\n        const c = this[BUFFER]\n        this[BUFFER] = null\n        this[CONSUMECHUNKSUB](c)\n      }\n      this[CONSUMING] = false\n    }\n\n    if (!this[BUFFER] || this[ENDED])\n      this[MAYBEEND]()\n  }\n\n  [CONSUMECHUNKSUB] (chunk) {\n    // we know that we are in CONSUMING mode, so anything written goes into\n    // the buffer.  Advance the position and put any remainder in the buffer.\n    let position = 0\n    let length = chunk.length\n    while (position + 512 <= length && !this[ABORTED]) {\n      switch (this[STATE]) {\n        case 'begin':\n          this[CONSUMEHEADER](chunk, position)\n          position += 512\n          break\n\n        case 'ignore':\n        case 'body':\n          position += this[CONSUMEBODY](chunk, position)\n          break\n\n        case 'meta':\n          position += this[CONSUMEMETA](chunk, position)\n          break\n\n        /* istanbul ignore next */\n        default:\n          throw new Error('invalid state: ' + this[STATE])\n      }\n    }\n\n    if (position < length) {\n      if (this[BUFFER])\n        this[BUFFER] = Buffer.concat([chunk.slice(position), this[BUFFER]])\n      else\n        this[BUFFER] = chunk.slice(position)\n    }\n  }\n\n  end (chunk) {\n    if (!this[ABORTED]) {\n      if (this[UNZIP])\n        this[UNZIP].end(chunk)\n      else {\n        this[ENDED] = true\n        this.write(chunk)\n      }\n    }\n  }\n})\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL3Rhci9saWIvcGFyc2UuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZSxtQkFBTyxDQUFDLHVFQUFpQjtBQUN4QyxhQUFhLG1CQUFPLENBQUMsa0JBQU07QUFDM0IsZUFBZSxtQkFBTyxDQUFDLCtEQUFhO0FBQ3BDLFdBQVcsbUJBQU8sQ0FBQyxzQkFBUTtBQUMzQixnQkFBZ0IsbUJBQU8sQ0FBQyw0REFBUztBQUNqQztBQUNBLGNBQWMsbUJBQU8sQ0FBQyx1RUFBaUI7QUFDdkMsWUFBWSxtQkFBTyxDQUFDLHlEQUFVO0FBQzlCLGFBQWEsbUJBQU8sQ0FBQyw0REFBVTtBQUMvQixlQUFlLG1CQUFPLENBQUMsK0RBQWE7O0FBRXBDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTs7QUFFVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTs7QUFFVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsK0NBQStDO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsiL2hvbWUvYmFyYi9hYS9Bc3NvY2lhdGVkQWNjb3VudHMvbm9kZV9tb2R1bGVzL3Rhci9saWIvcGFyc2UuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbi8vIHRoaXNbQlVGRkVSXSBpcyB0aGUgcmVtYWluZGVyIG9mIGEgY2h1bmsgaWYgd2UncmUgd2FpdGluZyBmb3Jcbi8vIHRoZSBmdWxsIDUxMiBieXRlcyBvZiBhIGhlYWRlciB0byBjb21lIGluLiAgV2Ugd2lsbCBCdWZmZXIuY29uY2F0KClcbi8vIGl0IHRvIHRoZSBuZXh0IHdyaXRlKCksIHdoaWNoIGlzIGEgbWVtIGNvcHksIGJ1dCBhIHNtYWxsIG9uZS5cbi8vXG4vLyB0aGlzW1FVRVVFXSBpcyBhIFlhbGxpc3Qgb2YgZW50cmllcyB0aGF0IGhhdmVuJ3QgYmVlbiBlbWl0dGVkXG4vLyB5ZXQgdGhpcyBjYW4gb25seSBnZXQgZmlsbGVkIHVwIGlmIHRoZSB1c2VyIGtlZXBzIHdyaXRlKClpbmcgYWZ0ZXJcbi8vIGEgd3JpdGUoKSByZXR1cm5zIGZhbHNlLCBvciBkb2VzIGEgd3JpdGUoKSB3aXRoIG1vcmUgdGhhbiBvbmUgZW50cnlcbi8vXG4vLyBXZSBkb24ndCBidWZmZXIgY2h1bmtzLCB3ZSBhbHdheXMgcGFyc2UgdGhlbSBhbmQgZWl0aGVyIGNyZWF0ZSBhblxuLy8gZW50cnksIG9yIHB1c2ggaXQgaW50byB0aGUgYWN0aXZlIGVudHJ5LiAgVGhlIFJlYWRFbnRyeSBjbGFzcyBrbm93c1xuLy8gdG8gdGhyb3cgZGF0YSBhd2F5IGlmIC5pZ25vcmU9dHJ1ZVxuLy9cbi8vIFNoaWZ0IGVudHJ5IG9mZiB0aGUgYnVmZmVyIHdoZW4gaXQgZW1pdHMgJ2VuZCcsIGFuZCBlbWl0ICdlbnRyeScgZm9yXG4vLyB0aGUgbmV4dCBvbmUgaW4gdGhlIGxpc3QuXG4vL1xuLy8gQXQgYW55IHRpbWUsIHdlJ3JlIHB1c2hpbmcgYm9keSBjaHVua3MgaW50byB0aGUgZW50cnkgYXQgV1JJVEVFTlRSWSxcbi8vIGFuZCB3YWl0aW5nIGZvciAnZW5kJyBvbiB0aGUgZW50cnkgYXQgUkVBREVOVFJZXG4vL1xuLy8gaWdub3JlZCBlbnRyaWVzIGdldCAucmVzdW1lKCkgY2FsbGVkIG9uIHRoZW0gc3RyYWlnaHQgYXdheVxuXG5jb25zdCB3YXJuZXIgPSByZXF1aXJlKCcuL3dhcm4tbWl4aW4uanMnKVxuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKVxuY29uc3QgSGVhZGVyID0gcmVxdWlyZSgnLi9oZWFkZXIuanMnKVxuY29uc3QgRUUgPSByZXF1aXJlKCdldmVudHMnKVxuY29uc3QgWWFsbGlzdCA9IHJlcXVpcmUoJ3lhbGxpc3QnKVxuY29uc3QgbWF4TWV0YUVudHJ5U2l6ZSA9IDEwMjQgKiAxMDI0XG5jb25zdCBFbnRyeSA9IHJlcXVpcmUoJy4vcmVhZC1lbnRyeS5qcycpXG5jb25zdCBQYXggPSByZXF1aXJlKCcuL3BheC5qcycpXG5jb25zdCB6bGliID0gcmVxdWlyZSgnbWluaXpsaWInKVxuY29uc3QgQnVmZmVyID0gcmVxdWlyZSgnLi9idWZmZXIuanMnKVxuXG5jb25zdCBnemlwSGVhZGVyID0gQnVmZmVyLmZyb20oWzB4MWYsIDB4OGJdKVxuY29uc3QgU1RBVEUgPSBTeW1ib2woJ3N0YXRlJylcbmNvbnN0IFdSSVRFRU5UUlkgPSBTeW1ib2woJ3dyaXRlRW50cnknKVxuY29uc3QgUkVBREVOVFJZID0gU3ltYm9sKCdyZWFkRW50cnknKVxuY29uc3QgTkVYVEVOVFJZID0gU3ltYm9sKCduZXh0RW50cnknKVxuY29uc3QgUFJPQ0VTU0VOVFJZID0gU3ltYm9sKCdwcm9jZXNzRW50cnknKVxuY29uc3QgRVggPSBTeW1ib2woJ2V4dGVuZGVkSGVhZGVyJylcbmNvbnN0IEdFWCA9IFN5bWJvbCgnZ2xvYmFsRXh0ZW5kZWRIZWFkZXInKVxuY29uc3QgTUVUQSA9IFN5bWJvbCgnbWV0YScpXG5jb25zdCBFTUlUTUVUQSA9IFN5bWJvbCgnZW1pdE1ldGEnKVxuY29uc3QgQlVGRkVSID0gU3ltYm9sKCdidWZmZXInKVxuY29uc3QgUVVFVUUgPSBTeW1ib2woJ3F1ZXVlJylcbmNvbnN0IEVOREVEID0gU3ltYm9sKCdlbmRlZCcpXG5jb25zdCBFTUlUVEVERU5EID0gU3ltYm9sKCdlbWl0dGVkRW5kJylcbmNvbnN0IEVNSVQgPSBTeW1ib2woJ2VtaXQnKVxuY29uc3QgVU5aSVAgPSBTeW1ib2woJ3VuemlwJylcbmNvbnN0IENPTlNVTUVDSFVOSyA9IFN5bWJvbCgnY29uc3VtZUNodW5rJylcbmNvbnN0IENPTlNVTUVDSFVOS1NVQiA9IFN5bWJvbCgnY29uc3VtZUNodW5rU3ViJylcbmNvbnN0IENPTlNVTUVCT0RZID0gU3ltYm9sKCdjb25zdW1lQm9keScpXG5jb25zdCBDT05TVU1FTUVUQSA9IFN5bWJvbCgnY29uc3VtZU1ldGEnKVxuY29uc3QgQ09OU1VNRUhFQURFUiA9IFN5bWJvbCgnY29uc3VtZUhlYWRlcicpXG5jb25zdCBDT05TVU1JTkcgPSBTeW1ib2woJ2NvbnN1bWluZycpXG5jb25zdCBCVUZGRVJDT05DQVQgPSBTeW1ib2woJ2J1ZmZlckNvbmNhdCcpXG5jb25zdCBNQVlCRUVORCA9IFN5bWJvbCgnbWF5YmVFbmQnKVxuY29uc3QgV1JJVElORyA9IFN5bWJvbCgnd3JpdGluZycpXG5jb25zdCBBQk9SVEVEID0gU3ltYm9sKCdhYm9ydGVkJylcbmNvbnN0IERPTkUgPSBTeW1ib2woJ29uRG9uZScpXG5cbmNvbnN0IG5vb3AgPSBfID0+IHRydWVcblxubW9kdWxlLmV4cG9ydHMgPSB3YXJuZXIoY2xhc3MgUGFyc2VyIGV4dGVuZHMgRUUge1xuICBjb25zdHJ1Y3RvciAob3B0KSB7XG4gICAgb3B0ID0gb3B0IHx8IHt9XG4gICAgc3VwZXIob3B0KVxuXG4gICAgaWYgKG9wdC5vbmRvbmUpXG4gICAgICB0aGlzLm9uKERPTkUsIG9wdC5vbmRvbmUpXG4gICAgZWxzZVxuICAgICAgdGhpcy5vbihET05FLCBfID0+IHtcbiAgICAgICAgdGhpcy5lbWl0KCdwcmVmaW5pc2gnKVxuICAgICAgICB0aGlzLmVtaXQoJ2ZpbmlzaCcpXG4gICAgICAgIHRoaXMuZW1pdCgnZW5kJylcbiAgICAgICAgdGhpcy5lbWl0KCdjbG9zZScpXG4gICAgICB9KVxuXG4gICAgdGhpcy5zdHJpY3QgPSAhIW9wdC5zdHJpY3RcbiAgICB0aGlzLm1heE1ldGFFbnRyeVNpemUgPSBvcHQubWF4TWV0YUVudHJ5U2l6ZSB8fCBtYXhNZXRhRW50cnlTaXplXG4gICAgdGhpcy5maWx0ZXIgPSB0eXBlb2Ygb3B0LmZpbHRlciA9PT0gJ2Z1bmN0aW9uJyA/IG9wdC5maWx0ZXIgOiBub29wXG5cbiAgICAvLyBoYXZlIHRvIHNldCB0aGlzIHNvIHRoYXQgc3RyZWFtcyBhcmUgb2sgcGlwaW5nIGludG8gaXRcbiAgICB0aGlzLndyaXRhYmxlID0gdHJ1ZVxuICAgIHRoaXMucmVhZGFibGUgPSBmYWxzZVxuXG4gICAgdGhpc1tRVUVVRV0gPSBuZXcgWWFsbGlzdCgpXG4gICAgdGhpc1tCVUZGRVJdID0gbnVsbFxuICAgIHRoaXNbUkVBREVOVFJZXSA9IG51bGxcbiAgICB0aGlzW1dSSVRFRU5UUlldID0gbnVsbFxuICAgIHRoaXNbU1RBVEVdID0gJ2JlZ2luJ1xuICAgIHRoaXNbTUVUQV0gPSAnJ1xuICAgIHRoaXNbRVhdID0gbnVsbFxuICAgIHRoaXNbR0VYXSA9IG51bGxcbiAgICB0aGlzW0VOREVEXSA9IGZhbHNlXG4gICAgdGhpc1tVTlpJUF0gPSBudWxsXG4gICAgdGhpc1tBQk9SVEVEXSA9IGZhbHNlXG4gICAgaWYgKHR5cGVvZiBvcHQub253YXJuID09PSAnZnVuY3Rpb24nKVxuICAgICAgdGhpcy5vbignd2FybicsIG9wdC5vbndhcm4pXG4gICAgaWYgKHR5cGVvZiBvcHQub25lbnRyeSA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgIHRoaXMub24oJ2VudHJ5Jywgb3B0Lm9uZW50cnkpXG4gIH1cblxuICBbQ09OU1VNRUhFQURFUl0gKGNodW5rLCBwb3NpdGlvbikge1xuICAgIGxldCBoZWFkZXJcbiAgICB0cnkge1xuICAgICAgaGVhZGVyID0gbmV3IEhlYWRlcihjaHVuaywgcG9zaXRpb24sIHRoaXNbRVhdLCB0aGlzW0dFWF0pXG4gICAgfSBjYXRjaCAoZXIpIHtcbiAgICAgIHJldHVybiB0aGlzLndhcm4oJ2ludmFsaWQgZW50cnknLCBlcilcbiAgICB9XG5cbiAgICBpZiAoaGVhZGVyLm51bGxCbG9jaylcbiAgICAgIHRoaXNbRU1JVF0oJ251bGxCbG9jaycpXG4gICAgZWxzZSBpZiAoIWhlYWRlci5ja3N1bVZhbGlkKVxuICAgICAgdGhpcy53YXJuKCdpbnZhbGlkIGVudHJ5JywgaGVhZGVyKVxuICAgIGVsc2UgaWYgKCFoZWFkZXIucGF0aClcbiAgICAgIHRoaXMud2FybignaW52YWxpZDogcGF0aCBpcyByZXF1aXJlZCcsIGhlYWRlcilcbiAgICBlbHNlIHtcbiAgICAgIGNvbnN0IHR5cGUgPSBoZWFkZXIudHlwZVxuICAgICAgaWYgKC9eKFN5bWJvbGljKT9MaW5rJC8udGVzdCh0eXBlKSAmJiAhaGVhZGVyLmxpbmtwYXRoKVxuICAgICAgICB0aGlzLndhcm4oJ2ludmFsaWQ6IGxpbmtwYXRoIHJlcXVpcmVkJywgaGVhZGVyKVxuICAgICAgZWxzZSBpZiAoIS9eKFN5bWJvbGljKT9MaW5rJC8udGVzdCh0eXBlKSAmJiBoZWFkZXIubGlua3BhdGgpXG4gICAgICAgIHRoaXMud2FybignaW52YWxpZDogbGlua3BhdGggZm9yYmlkZGVuJywgaGVhZGVyKVxuICAgICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IGVudHJ5ID0gdGhpc1tXUklURUVOVFJZXSA9IG5ldyBFbnRyeShoZWFkZXIsIHRoaXNbRVhdLCB0aGlzW0dFWF0pXG5cbiAgICAgICAgaWYgKGVudHJ5Lm1ldGEpIHtcbiAgICAgICAgICBpZiAoZW50cnkuc2l6ZSA+IHRoaXMubWF4TWV0YUVudHJ5U2l6ZSkge1xuICAgICAgICAgICAgZW50cnkuaWdub3JlID0gdHJ1ZVxuICAgICAgICAgICAgdGhpc1tFTUlUXSgnaWdub3JlZEVudHJ5JywgZW50cnkpXG4gICAgICAgICAgICB0aGlzW1NUQVRFXSA9ICdpZ25vcmUnXG4gICAgICAgICAgfSBlbHNlIGlmIChlbnRyeS5zaXplID4gMCkge1xuICAgICAgICAgICAgdGhpc1tNRVRBXSA9ICcnXG4gICAgICAgICAgICBlbnRyeS5vbignZGF0YScsIGMgPT4gdGhpc1tNRVRBXSArPSBjKVxuICAgICAgICAgICAgdGhpc1tTVEFURV0gPSAnbWV0YSdcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICB0aGlzW0VYXSA9IG51bGxcbiAgICAgICAgICBlbnRyeS5pZ25vcmUgPSBlbnRyeS5pZ25vcmUgfHwgIXRoaXMuZmlsdGVyKGVudHJ5LnBhdGgsIGVudHJ5KVxuICAgICAgICAgIGlmIChlbnRyeS5pZ25vcmUpIHtcbiAgICAgICAgICAgIHRoaXNbRU1JVF0oJ2lnbm9yZWRFbnRyeScsIGVudHJ5KVxuICAgICAgICAgICAgdGhpc1tTVEFURV0gPSBlbnRyeS5yZW1haW4gPyAnaWdub3JlJyA6ICdiZWdpbidcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGVudHJ5LnJlbWFpbilcbiAgICAgICAgICAgICAgdGhpc1tTVEFURV0gPSAnYm9keSdcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzW1NUQVRFXSA9ICdiZWdpbidcbiAgICAgICAgICAgICAgZW50cnkuZW5kKClcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCF0aGlzW1JFQURFTlRSWV0pIHtcbiAgICAgICAgICAgICAgdGhpc1tRVUVVRV0ucHVzaChlbnRyeSlcbiAgICAgICAgICAgICAgdGhpc1tORVhURU5UUlldKClcbiAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICB0aGlzW1FVRVVFXS5wdXNoKGVudHJ5KVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIFtQUk9DRVNTRU5UUlldIChlbnRyeSkge1xuICAgIGxldCBnbyA9IHRydWVcblxuICAgIGlmICghZW50cnkpIHtcbiAgICAgIHRoaXNbUkVBREVOVFJZXSA9IG51bGxcbiAgICAgIGdvID0gZmFsc2VcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoZW50cnkpKVxuICAgICAgdGhpcy5lbWl0LmFwcGx5KHRoaXMsIGVudHJ5KVxuICAgIGVsc2Uge1xuICAgICAgdGhpc1tSRUFERU5UUlldID0gZW50cnlcbiAgICAgIHRoaXMuZW1pdCgnZW50cnknLCBlbnRyeSlcbiAgICAgIGlmICghZW50cnkuZW1pdHRlZEVuZCkge1xuICAgICAgICBlbnRyeS5vbignZW5kJywgXyA9PiB0aGlzW05FWFRFTlRSWV0oKSlcbiAgICAgICAgZ28gPSBmYWxzZVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBnb1xuICB9XG5cbiAgW05FWFRFTlRSWV0gKCkge1xuICAgIGRvIHt9IHdoaWxlICh0aGlzW1BST0NFU1NFTlRSWV0odGhpc1tRVUVVRV0uc2hpZnQoKSkpXG5cbiAgICBpZiAoIXRoaXNbUVVFVUVdLmxlbmd0aCkge1xuICAgICAgLy8gQXQgdGhpcyBwb2ludCwgdGhlcmUncyBub3RoaW5nIGluIHRoZSBxdWV1ZSwgYnV0IHdlIG1heSBoYXZlIGFuXG4gICAgICAvLyBlbnRyeSB3aGljaCBpcyBiZWluZyBjb25zdW1lZCAocmVhZEVudHJ5KS5cbiAgICAgIC8vIElmIHdlIGRvbid0LCB0aGVuIHdlIGRlZmluaXRlbHkgY2FuIGhhbmRsZSBtb3JlIGRhdGEuXG4gICAgICAvLyBJZiB3ZSBkbywgYW5kIGVpdGhlciBpdCdzIGZsb3dpbmcsIG9yIGl0IGhhcyBuZXZlciBoYWQgYW55IGRhdGFcbiAgICAgIC8vIHdyaXR0ZW4gdG8gaXQsIHRoZW4gaXQgbmVlZHMgbW9yZS5cbiAgICAgIC8vIFRoZSBvbmx5IG90aGVyIHBvc3NpYmlsaXR5IGlzIHRoYXQgaXQgaGFzIHJldHVybmVkIGZhbHNlIGZyb20gYVxuICAgICAgLy8gd3JpdGUoKSBjYWxsLCBzbyB3ZSB3YWl0IGZvciB0aGUgbmV4dCBkcmFpbiB0byBjb250aW51ZS5cbiAgICAgIGNvbnN0IHJlID0gdGhpc1tSRUFERU5UUlldXG4gICAgICBjb25zdCBkcmFpbk5vdyA9ICFyZSB8fCByZS5mbG93aW5nIHx8IHJlLnNpemUgPT09IHJlLnJlbWFpblxuICAgICAgaWYgKGRyYWluTm93KSB7XG4gICAgICAgIGlmICghdGhpc1tXUklUSU5HXSlcbiAgICAgICAgICB0aGlzLmVtaXQoJ2RyYWluJylcbiAgICAgIH0gZWxzZVxuICAgICAgICByZS5vbmNlKCdkcmFpbicsIF8gPT4gdGhpcy5lbWl0KCdkcmFpbicpKVxuICAgICB9XG4gIH1cblxuICBbQ09OU1VNRUJPRFldIChjaHVuaywgcG9zaXRpb24pIHtcbiAgICAvLyB3cml0ZSB1cCB0byBidXQgbm8gIG1vcmUgdGhhbiB3cml0ZUVudHJ5LmJsb2NrUmVtYWluXG4gICAgY29uc3QgZW50cnkgPSB0aGlzW1dSSVRFRU5UUlldXG4gICAgY29uc3QgYnIgPSBlbnRyeS5ibG9ja1JlbWFpblxuICAgIGNvbnN0IGMgPSAoYnIgPj0gY2h1bmsubGVuZ3RoICYmIHBvc2l0aW9uID09PSAwKSA/IGNodW5rXG4gICAgICA6IGNodW5rLnNsaWNlKHBvc2l0aW9uLCBwb3NpdGlvbiArIGJyKVxuXG4gICAgZW50cnkud3JpdGUoYylcblxuICAgIGlmICghZW50cnkuYmxvY2tSZW1haW4pIHtcbiAgICAgIHRoaXNbU1RBVEVdID0gJ2JlZ2luJ1xuICAgICAgdGhpc1tXUklURUVOVFJZXSA9IG51bGxcbiAgICAgIGVudHJ5LmVuZCgpXG4gICAgfVxuXG4gICAgcmV0dXJuIGMubGVuZ3RoXG4gIH1cblxuICBbQ09OU1VNRU1FVEFdIChjaHVuaywgcG9zaXRpb24pIHtcbiAgICBjb25zdCBlbnRyeSA9IHRoaXNbV1JJVEVFTlRSWV1cbiAgICBjb25zdCByZXQgPSB0aGlzW0NPTlNVTUVCT0RZXShjaHVuaywgcG9zaXRpb24pXG5cbiAgICAvLyBpZiB3ZSBmaW5pc2hlZCwgdGhlbiB0aGUgZW50cnkgaXMgcmVzZXRcbiAgICBpZiAoIXRoaXNbV1JJVEVFTlRSWV0pXG4gICAgICB0aGlzW0VNSVRNRVRBXShlbnRyeSlcblxuICAgIHJldHVybiByZXRcbiAgfVxuXG4gIFtFTUlUXSAoZXYsIGRhdGEsIGV4dHJhKSB7XG4gICAgaWYgKCF0aGlzW1FVRVVFXS5sZW5ndGggJiYgIXRoaXNbUkVBREVOVFJZXSlcbiAgICAgIHRoaXMuZW1pdChldiwgZGF0YSwgZXh0cmEpXG4gICAgZWxzZVxuICAgICAgdGhpc1tRVUVVRV0ucHVzaChbZXYsIGRhdGEsIGV4dHJhXSlcbiAgfVxuXG4gIFtFTUlUTUVUQV0gKGVudHJ5KSB7XG4gICAgdGhpc1tFTUlUXSgnbWV0YScsIHRoaXNbTUVUQV0pXG4gICAgc3dpdGNoIChlbnRyeS50eXBlKSB7XG4gICAgICBjYXNlICdFeHRlbmRlZEhlYWRlcic6XG4gICAgICBjYXNlICdPbGRFeHRlbmRlZEhlYWRlcic6XG4gICAgICAgIHRoaXNbRVhdID0gUGF4LnBhcnNlKHRoaXNbTUVUQV0sIHRoaXNbRVhdLCBmYWxzZSlcbiAgICAgICAgYnJlYWtcblxuICAgICAgY2FzZSAnR2xvYmFsRXh0ZW5kZWRIZWFkZXInOlxuICAgICAgICB0aGlzW0dFWF0gPSBQYXgucGFyc2UodGhpc1tNRVRBXSwgdGhpc1tHRVhdLCB0cnVlKVxuICAgICAgICBicmVha1xuXG4gICAgICBjYXNlICdOZXh0RmlsZUhhc0xvbmdQYXRoJzpcbiAgICAgIGNhc2UgJ09sZEdudUxvbmdQYXRoJzpcbiAgICAgICAgdGhpc1tFWF0gPSB0aGlzW0VYXSB8fCBPYmplY3QuY3JlYXRlKG51bGwpXG4gICAgICAgIHRoaXNbRVhdLnBhdGggPSB0aGlzW01FVEFdLnJlcGxhY2UoL1xcMC4qLywgJycpXG4gICAgICAgIGJyZWFrXG5cbiAgICAgIGNhc2UgJ05leHRGaWxlSGFzTG9uZ0xpbmtwYXRoJzpcbiAgICAgICAgdGhpc1tFWF0gPSB0aGlzW0VYXSB8fCBPYmplY3QuY3JlYXRlKG51bGwpXG4gICAgICAgIHRoaXNbRVhdLmxpbmtwYXRoID0gdGhpc1tNRVRBXS5yZXBsYWNlKC9cXDAuKi8sICcnKVxuICAgICAgICBicmVha1xuXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIG1ldGE6ICcgKyBlbnRyeS50eXBlKVxuICAgIH1cbiAgfVxuXG4gIGFib3J0IChtc2csIGVycm9yKSB7XG4gICAgdGhpc1tBQk9SVEVEXSA9IHRydWVcbiAgICB0aGlzLndhcm4obXNnLCBlcnJvcilcbiAgICB0aGlzLmVtaXQoJ2Fib3J0JywgZXJyb3IpXG4gICAgdGhpcy5lbWl0KCdlcnJvcicsIGVycm9yKVxuICB9XG5cbiAgd3JpdGUgKGNodW5rKSB7XG4gICAgaWYgKHRoaXNbQUJPUlRFRF0pXG4gICAgICByZXR1cm5cblxuICAgIC8vIGZpcnN0IHdyaXRlLCBtaWdodCBiZSBnemlwcGVkXG4gICAgaWYgKHRoaXNbVU5aSVBdID09PSBudWxsICYmIGNodW5rKSB7XG4gICAgICBpZiAodGhpc1tCVUZGRVJdKSB7XG4gICAgICAgIGNodW5rID0gQnVmZmVyLmNvbmNhdChbdGhpc1tCVUZGRVJdLCBjaHVua10pXG4gICAgICAgIHRoaXNbQlVGRkVSXSA9IG51bGxcbiAgICAgIH1cbiAgICAgIGlmIChjaHVuay5sZW5ndGggPCBnemlwSGVhZGVyLmxlbmd0aCkge1xuICAgICAgICB0aGlzW0JVRkZFUl0gPSBjaHVua1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgICAgZm9yIChsZXQgaSA9IDA7IHRoaXNbVU5aSVBdID09PSBudWxsICYmIGkgPCBnemlwSGVhZGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChjaHVua1tpXSAhPT0gZ3ppcEhlYWRlcltpXSlcbiAgICAgICAgICB0aGlzW1VOWklQXSA9IGZhbHNlXG4gICAgICB9XG4gICAgICBpZiAodGhpc1tVTlpJUF0gPT09IG51bGwpIHtcbiAgICAgICAgY29uc3QgZW5kZWQgPSB0aGlzW0VOREVEXVxuICAgICAgICB0aGlzW0VOREVEXSA9IGZhbHNlXG4gICAgICAgIHRoaXNbVU5aSVBdID0gbmV3IHpsaWIuVW56aXAoKVxuICAgICAgICB0aGlzW1VOWklQXS5vbignZGF0YScsIGNodW5rID0+IHRoaXNbQ09OU1VNRUNIVU5LXShjaHVuaykpXG4gICAgICAgIHRoaXNbVU5aSVBdLm9uKCdlcnJvcicsIGVyID0+XG4gICAgICAgICAgdGhpcy5hYm9ydChlci5tZXNzYWdlLCBlcikpXG4gICAgICAgIHRoaXNbVU5aSVBdLm9uKCdlbmQnLCBfID0+IHtcbiAgICAgICAgICB0aGlzW0VOREVEXSA9IHRydWVcbiAgICAgICAgICB0aGlzW0NPTlNVTUVDSFVOS10oKVxuICAgICAgICB9KVxuICAgICAgICB0aGlzW1dSSVRJTkddID0gdHJ1ZVxuICAgICAgICBjb25zdCByZXQgPSB0aGlzW1VOWklQXVtlbmRlZCA/ICdlbmQnIDogJ3dyaXRlJyBdKGNodW5rKVxuICAgICAgICB0aGlzW1dSSVRJTkddID0gZmFsc2VcbiAgICAgICAgcmV0dXJuIHJldFxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXNbV1JJVElOR10gPSB0cnVlXG4gICAgaWYgKHRoaXNbVU5aSVBdKVxuICAgICAgdGhpc1tVTlpJUF0ud3JpdGUoY2h1bmspXG4gICAgZWxzZVxuICAgICAgdGhpc1tDT05TVU1FQ0hVTktdKGNodW5rKVxuICAgIHRoaXNbV1JJVElOR10gPSBmYWxzZVxuXG4gICAgLy8gcmV0dXJuIGZhbHNlIGlmIHRoZXJlJ3MgYSBxdWV1ZSwgb3IgaWYgdGhlIGN1cnJlbnQgZW50cnkgaXNuJ3QgZmxvd2luZ1xuICAgIGNvbnN0IHJldCA9XG4gICAgICB0aGlzW1FVRVVFXS5sZW5ndGggPyBmYWxzZSA6XG4gICAgICB0aGlzW1JFQURFTlRSWV0gPyB0aGlzW1JFQURFTlRSWV0uZmxvd2luZyA6XG4gICAgICB0cnVlXG5cbiAgICAvLyBpZiB3ZSBoYXZlIG5vIHF1ZXVlLCB0aGVuIHRoYXQgbWVhbnMgYSBjbG9nZ2VkIFJFQURFTlRSWVxuICAgIGlmICghcmV0ICYmICF0aGlzW1FVRVVFXS5sZW5ndGgpXG4gICAgICB0aGlzW1JFQURFTlRSWV0ub25jZSgnZHJhaW4nLCBfID0+IHRoaXMuZW1pdCgnZHJhaW4nKSlcblxuICAgIHJldHVybiByZXRcbiAgfVxuXG4gIFtCVUZGRVJDT05DQVRdIChjKSB7XG4gICAgaWYgKGMgJiYgIXRoaXNbQUJPUlRFRF0pXG4gICAgICB0aGlzW0JVRkZFUl0gPSB0aGlzW0JVRkZFUl0gPyBCdWZmZXIuY29uY2F0KFt0aGlzW0JVRkZFUl0sIGNdKSA6IGNcbiAgfVxuXG4gIFtNQVlCRUVORF0gKCkge1xuICAgIGlmICh0aGlzW0VOREVEXSAmJlxuICAgICAgICAhdGhpc1tFTUlUVEVERU5EXSAmJlxuICAgICAgICAhdGhpc1tBQk9SVEVEXSAmJlxuICAgICAgICAhdGhpc1tDT05TVU1JTkddKSB7XG4gICAgICB0aGlzW0VNSVRURURFTkRdID0gdHJ1ZVxuICAgICAgY29uc3QgZW50cnkgPSB0aGlzW1dSSVRFRU5UUlldXG4gICAgICBpZiAoZW50cnkgJiYgZW50cnkuYmxvY2tSZW1haW4pIHtcbiAgICAgICAgY29uc3QgaGF2ZSA9IHRoaXNbQlVGRkVSXSA/IHRoaXNbQlVGRkVSXS5sZW5ndGggOiAwXG4gICAgICAgIHRoaXMud2FybignVHJ1bmNhdGVkIGlucHV0IChuZWVkZWQgJyArIGVudHJ5LmJsb2NrUmVtYWluICtcbiAgICAgICAgICAgICAgICAgICcgbW9yZSBieXRlcywgb25seSAnICsgaGF2ZSArICcgYXZhaWxhYmxlKScsIGVudHJ5KVxuICAgICAgICBpZiAodGhpc1tCVUZGRVJdKVxuICAgICAgICAgIGVudHJ5LndyaXRlKHRoaXNbQlVGRkVSXSlcbiAgICAgICAgZW50cnkuZW5kKClcbiAgICAgIH1cbiAgICAgIHRoaXNbRU1JVF0oRE9ORSlcbiAgICB9XG4gIH1cblxuICBbQ09OU1VNRUNIVU5LXSAoY2h1bmspIHtcbiAgICBpZiAodGhpc1tDT05TVU1JTkddKSB7XG4gICAgICB0aGlzW0JVRkZFUkNPTkNBVF0oY2h1bmspXG4gICAgfSBlbHNlIGlmICghY2h1bmsgJiYgIXRoaXNbQlVGRkVSXSkge1xuICAgICAgdGhpc1tNQVlCRUVORF0oKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzW0NPTlNVTUlOR10gPSB0cnVlXG4gICAgICBpZiAodGhpc1tCVUZGRVJdKSB7XG4gICAgICAgIHRoaXNbQlVGRkVSQ09OQ0FUXShjaHVuaylcbiAgICAgICAgY29uc3QgYyA9IHRoaXNbQlVGRkVSXVxuICAgICAgICB0aGlzW0JVRkZFUl0gPSBudWxsXG4gICAgICAgIHRoaXNbQ09OU1VNRUNIVU5LU1VCXShjKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpc1tDT05TVU1FQ0hVTktTVUJdKGNodW5rKVxuICAgICAgfVxuXG4gICAgICB3aGlsZSAodGhpc1tCVUZGRVJdICYmIHRoaXNbQlVGRkVSXS5sZW5ndGggPj0gNTEyICYmICF0aGlzW0FCT1JURURdKSB7XG4gICAgICAgIGNvbnN0IGMgPSB0aGlzW0JVRkZFUl1cbiAgICAgICAgdGhpc1tCVUZGRVJdID0gbnVsbFxuICAgICAgICB0aGlzW0NPTlNVTUVDSFVOS1NVQl0oYylcbiAgICAgIH1cbiAgICAgIHRoaXNbQ09OU1VNSU5HXSA9IGZhbHNlXG4gICAgfVxuXG4gICAgaWYgKCF0aGlzW0JVRkZFUl0gfHwgdGhpc1tFTkRFRF0pXG4gICAgICB0aGlzW01BWUJFRU5EXSgpXG4gIH1cblxuICBbQ09OU1VNRUNIVU5LU1VCXSAoY2h1bmspIHtcbiAgICAvLyB3ZSBrbm93IHRoYXQgd2UgYXJlIGluIENPTlNVTUlORyBtb2RlLCBzbyBhbnl0aGluZyB3cml0dGVuIGdvZXMgaW50b1xuICAgIC8vIHRoZSBidWZmZXIuICBBZHZhbmNlIHRoZSBwb3NpdGlvbiBhbmQgcHV0IGFueSByZW1haW5kZXIgaW4gdGhlIGJ1ZmZlci5cbiAgICBsZXQgcG9zaXRpb24gPSAwXG4gICAgbGV0IGxlbmd0aCA9IGNodW5rLmxlbmd0aFxuICAgIHdoaWxlIChwb3NpdGlvbiArIDUxMiA8PSBsZW5ndGggJiYgIXRoaXNbQUJPUlRFRF0pIHtcbiAgICAgIHN3aXRjaCAodGhpc1tTVEFURV0pIHtcbiAgICAgICAgY2FzZSAnYmVnaW4nOlxuICAgICAgICAgIHRoaXNbQ09OU1VNRUhFQURFUl0oY2h1bmssIHBvc2l0aW9uKVxuICAgICAgICAgIHBvc2l0aW9uICs9IDUxMlxuICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgY2FzZSAnaWdub3JlJzpcbiAgICAgICAgY2FzZSAnYm9keSc6XG4gICAgICAgICAgcG9zaXRpb24gKz0gdGhpc1tDT05TVU1FQk9EWV0oY2h1bmssIHBvc2l0aW9uKVxuICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgY2FzZSAnbWV0YSc6XG4gICAgICAgICAgcG9zaXRpb24gKz0gdGhpc1tDT05TVU1FTUVUQV0oY2h1bmssIHBvc2l0aW9uKVxuICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgc3RhdGU6ICcgKyB0aGlzW1NUQVRFXSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocG9zaXRpb24gPCBsZW5ndGgpIHtcbiAgICAgIGlmICh0aGlzW0JVRkZFUl0pXG4gICAgICAgIHRoaXNbQlVGRkVSXSA9IEJ1ZmZlci5jb25jYXQoW2NodW5rLnNsaWNlKHBvc2l0aW9uKSwgdGhpc1tCVUZGRVJdXSlcbiAgICAgIGVsc2VcbiAgICAgICAgdGhpc1tCVUZGRVJdID0gY2h1bmsuc2xpY2UocG9zaXRpb24pXG4gICAgfVxuICB9XG5cbiAgZW5kIChjaHVuaykge1xuICAgIGlmICghdGhpc1tBQk9SVEVEXSkge1xuICAgICAgaWYgKHRoaXNbVU5aSVBdKVxuICAgICAgICB0aGlzW1VOWklQXS5lbmQoY2h1bmspXG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhpc1tFTkRFRF0gPSB0cnVlXG4gICAgICAgIHRoaXMud3JpdGUoY2h1bmspXG4gICAgICB9XG4gICAgfVxuICB9XG59KVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/tar/lib/parse.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/tar/lib/path-reservations.js":
/*!*******************************************************!*\
  !*** ../../node_modules/tar/lib/path-reservations.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// A path exclusive reservation system\n// reserve([list, of, paths], fn)\n// When the fn is first in line for all its paths, it\n// is called with a cb that clears the reservation.\n//\n// Used by async unpack to avoid clobbering paths in use,\n// while still allowing maximal safe parallelization.\n\nconst assert = __webpack_require__(/*! assert */ \"assert\")\nconst normPath = __webpack_require__(/*! ./normalize-windows-path.js */ \"(rsc)/../../node_modules/tar/lib/normalize-windows-path.js\")\nconst stripSlashes = __webpack_require__(/*! ./strip-trailing-slashes.js */ \"(rsc)/../../node_modules/tar/lib/strip-trailing-slashes.js\")\nconst { join } = __webpack_require__(/*! path */ \"path\")\n\nconst platform = process.env.TESTING_TAR_FAKE_PLATFORM || process.platform\nconst isWindows = platform === 'win32'\n\nmodule.exports = () => {\n  // path => [function or Set]\n  // A Set object means a directory reservation\n  // A fn is a direct reservation on that path\n  const queues = new Map()\n\n  // fn => {paths:[path,...], dirs:[path, ...]}\n  const reservations = new Map()\n\n  // return a set of parent dirs for a given path\n  // '/a/b/c/d' -> ['/', '/a', '/a/b', '/a/b/c', '/a/b/c/d']\n  const getDirs = path => {\n    const dirs = path.split('/').slice(0, -1).reduce((set, path) => {\n      if (set.length)\n        path = normPath(join(set[set.length - 1], path))\n      set.push(path || '/')\n      return set\n    }, [])\n    return dirs\n  }\n\n  // functions currently running\n  const running = new Set()\n\n  // return the queues for each path the function cares about\n  // fn => {paths, dirs}\n  const getQueues = fn => {\n    const res = reservations.get(fn)\n    /* istanbul ignore if - unpossible */\n    if (!res)\n      throw new Error('function does not have any path reservations')\n    return {\n      paths: res.paths.map(path => queues.get(path)),\n      dirs: [...res.dirs].map(path => queues.get(path)),\n    }\n  }\n\n  // check if fn is first in line for all its paths, and is\n  // included in the first set for all its dir queues\n  const check = fn => {\n    const {paths, dirs} = getQueues(fn)\n    return paths.every(q => q[0] === fn) &&\n      dirs.every(q => q[0] instanceof Set && q[0].has(fn))\n  }\n\n  // run the function if it's first in line and not already running\n  const run = fn => {\n    if (running.has(fn) || !check(fn))\n      return false\n    running.add(fn)\n    fn(() => clear(fn))\n    return true\n  }\n\n  const clear = fn => {\n    if (!running.has(fn))\n      return false\n\n    const { paths, dirs } = reservations.get(fn)\n    const next = new Set()\n\n    paths.forEach(path => {\n      const q = queues.get(path)\n      assert.equal(q[0], fn)\n      if (q.length === 1)\n        queues.delete(path)\n      else {\n        q.shift()\n        if (typeof q[0] === 'function')\n          next.add(q[0])\n        else\n          q[0].forEach(fn => next.add(fn))\n      }\n    })\n\n    dirs.forEach(dir => {\n      const q = queues.get(dir)\n      assert(q[0] instanceof Set)\n      if (q[0].size === 1 && q.length === 1) {\n        queues.delete(dir)\n      } else if (q[0].size === 1) {\n        q.shift()\n\n        // must be a function or else the Set would've been reused\n        next.add(q[0])\n      } else\n        q[0].delete(fn)\n    })\n    running.delete(fn)\n\n    next.forEach(fn => run(fn))\n    return true\n  }\n\n  const reserve = (paths, fn) => {\n    // collide on matches across case and unicode normalization\n    // On windows, thanks to the magic of 8.3 shortnames, it is fundamentally\n    // impossible to determine whether two paths refer to the same thing on\n    // disk, without asking the kernel for a shortname.\n    // So, we just pretend that every path matches every other path here,\n    // effectively removing all parallelization on windows.\n    paths = isWindows ? ['win32 parallelization disabled'] : paths.map(p => {\n      return stripSlashes(normPath(join(p)))\n        .normalize('NFKD')\n        .toLowerCase()\n    })\n\n    const dirs = new Set(\n      paths.map(path => getDirs(path)).reduce((a, b) => a.concat(b))\n    )\n    reservations.set(fn, {dirs, paths})\n    paths.forEach(path => {\n      const q = queues.get(path)\n      if (!q)\n        queues.set(path, [fn])\n      else\n        q.push(fn)\n    })\n    dirs.forEach(dir => {\n      const q = queues.get(dir)\n      if (!q)\n        queues.set(dir, [new Set([fn])])\n      else if (q[q.length-1] instanceof Set)\n        q[q.length-1].add(fn)\n      else\n        q.push(new Set([fn]))\n    })\n\n    return run(fn)\n  }\n\n  return { check, reserve }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL3Rhci9saWIvcGF0aC1yZXNlcnZhdGlvbnMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZSxtQkFBTyxDQUFDLHNCQUFRO0FBQy9CLGlCQUFpQixtQkFBTyxDQUFDLCtGQUE2QjtBQUN0RCxxQkFBcUIsbUJBQU8sQ0FBQywrRkFBNkI7QUFDMUQsUUFBUSxPQUFPLEVBQUUsbUJBQU8sQ0FBQyxrQkFBTTs7QUFFL0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGFBQWE7QUFDeEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLFlBQVksY0FBYztBQUMxQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLFlBQVk7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUEsV0FBVztBQUNYIiwic291cmNlcyI6WyIvaG9tZS9iYXJiL2FhL0Fzc29jaWF0ZWRBY2NvdW50cy9ub2RlX21vZHVsZXMvdGFyL2xpYi9wYXRoLXJlc2VydmF0aW9ucy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBBIHBhdGggZXhjbHVzaXZlIHJlc2VydmF0aW9uIHN5c3RlbVxuLy8gcmVzZXJ2ZShbbGlzdCwgb2YsIHBhdGhzXSwgZm4pXG4vLyBXaGVuIHRoZSBmbiBpcyBmaXJzdCBpbiBsaW5lIGZvciBhbGwgaXRzIHBhdGhzLCBpdFxuLy8gaXMgY2FsbGVkIHdpdGggYSBjYiB0aGF0IGNsZWFycyB0aGUgcmVzZXJ2YXRpb24uXG4vL1xuLy8gVXNlZCBieSBhc3luYyB1bnBhY2sgdG8gYXZvaWQgY2xvYmJlcmluZyBwYXRocyBpbiB1c2UsXG4vLyB3aGlsZSBzdGlsbCBhbGxvd2luZyBtYXhpbWFsIHNhZmUgcGFyYWxsZWxpemF0aW9uLlxuXG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKVxuY29uc3Qgbm9ybVBhdGggPSByZXF1aXJlKCcuL25vcm1hbGl6ZS13aW5kb3dzLXBhdGguanMnKVxuY29uc3Qgc3RyaXBTbGFzaGVzID0gcmVxdWlyZSgnLi9zdHJpcC10cmFpbGluZy1zbGFzaGVzLmpzJylcbmNvbnN0IHsgam9pbiB9ID0gcmVxdWlyZSgncGF0aCcpXG5cbmNvbnN0IHBsYXRmb3JtID0gcHJvY2Vzcy5lbnYuVEVTVElOR19UQVJfRkFLRV9QTEFURk9STSB8fCBwcm9jZXNzLnBsYXRmb3JtXG5jb25zdCBpc1dpbmRvd3MgPSBwbGF0Zm9ybSA9PT0gJ3dpbjMyJ1xuXG5tb2R1bGUuZXhwb3J0cyA9ICgpID0+IHtcbiAgLy8gcGF0aCA9PiBbZnVuY3Rpb24gb3IgU2V0XVxuICAvLyBBIFNldCBvYmplY3QgbWVhbnMgYSBkaXJlY3RvcnkgcmVzZXJ2YXRpb25cbiAgLy8gQSBmbiBpcyBhIGRpcmVjdCByZXNlcnZhdGlvbiBvbiB0aGF0IHBhdGhcbiAgY29uc3QgcXVldWVzID0gbmV3IE1hcCgpXG5cbiAgLy8gZm4gPT4ge3BhdGhzOltwYXRoLC4uLl0sIGRpcnM6W3BhdGgsIC4uLl19XG4gIGNvbnN0IHJlc2VydmF0aW9ucyA9IG5ldyBNYXAoKVxuXG4gIC8vIHJldHVybiBhIHNldCBvZiBwYXJlbnQgZGlycyBmb3IgYSBnaXZlbiBwYXRoXG4gIC8vICcvYS9iL2MvZCcgLT4gWycvJywgJy9hJywgJy9hL2InLCAnL2EvYi9jJywgJy9hL2IvYy9kJ11cbiAgY29uc3QgZ2V0RGlycyA9IHBhdGggPT4ge1xuICAgIGNvbnN0IGRpcnMgPSBwYXRoLnNwbGl0KCcvJykuc2xpY2UoMCwgLTEpLnJlZHVjZSgoc2V0LCBwYXRoKSA9PiB7XG4gICAgICBpZiAoc2V0Lmxlbmd0aClcbiAgICAgICAgcGF0aCA9IG5vcm1QYXRoKGpvaW4oc2V0W3NldC5sZW5ndGggLSAxXSwgcGF0aCkpXG4gICAgICBzZXQucHVzaChwYXRoIHx8ICcvJylcbiAgICAgIHJldHVybiBzZXRcbiAgICB9LCBbXSlcbiAgICByZXR1cm4gZGlyc1xuICB9XG5cbiAgLy8gZnVuY3Rpb25zIGN1cnJlbnRseSBydW5uaW5nXG4gIGNvbnN0IHJ1bm5pbmcgPSBuZXcgU2V0KClcblxuICAvLyByZXR1cm4gdGhlIHF1ZXVlcyBmb3IgZWFjaCBwYXRoIHRoZSBmdW5jdGlvbiBjYXJlcyBhYm91dFxuICAvLyBmbiA9PiB7cGF0aHMsIGRpcnN9XG4gIGNvbnN0IGdldFF1ZXVlcyA9IGZuID0+IHtcbiAgICBjb25zdCByZXMgPSByZXNlcnZhdGlvbnMuZ2V0KGZuKVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAtIHVucG9zc2libGUgKi9cbiAgICBpZiAoIXJlcylcbiAgICAgIHRocm93IG5ldyBFcnJvcignZnVuY3Rpb24gZG9lcyBub3QgaGF2ZSBhbnkgcGF0aCByZXNlcnZhdGlvbnMnKVxuICAgIHJldHVybiB7XG4gICAgICBwYXRoczogcmVzLnBhdGhzLm1hcChwYXRoID0+IHF1ZXVlcy5nZXQocGF0aCkpLFxuICAgICAgZGlyczogWy4uLnJlcy5kaXJzXS5tYXAocGF0aCA9PiBxdWV1ZXMuZ2V0KHBhdGgpKSxcbiAgICB9XG4gIH1cblxuICAvLyBjaGVjayBpZiBmbiBpcyBmaXJzdCBpbiBsaW5lIGZvciBhbGwgaXRzIHBhdGhzLCBhbmQgaXNcbiAgLy8gaW5jbHVkZWQgaW4gdGhlIGZpcnN0IHNldCBmb3IgYWxsIGl0cyBkaXIgcXVldWVzXG4gIGNvbnN0IGNoZWNrID0gZm4gPT4ge1xuICAgIGNvbnN0IHtwYXRocywgZGlyc30gPSBnZXRRdWV1ZXMoZm4pXG4gICAgcmV0dXJuIHBhdGhzLmV2ZXJ5KHEgPT4gcVswXSA9PT0gZm4pICYmXG4gICAgICBkaXJzLmV2ZXJ5KHEgPT4gcVswXSBpbnN0YW5jZW9mIFNldCAmJiBxWzBdLmhhcyhmbikpXG4gIH1cblxuICAvLyBydW4gdGhlIGZ1bmN0aW9uIGlmIGl0J3MgZmlyc3QgaW4gbGluZSBhbmQgbm90IGFscmVhZHkgcnVubmluZ1xuICBjb25zdCBydW4gPSBmbiA9PiB7XG4gICAgaWYgKHJ1bm5pbmcuaGFzKGZuKSB8fCAhY2hlY2soZm4pKVxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgcnVubmluZy5hZGQoZm4pXG4gICAgZm4oKCkgPT4gY2xlYXIoZm4pKVxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBjb25zdCBjbGVhciA9IGZuID0+IHtcbiAgICBpZiAoIXJ1bm5pbmcuaGFzKGZuKSlcbiAgICAgIHJldHVybiBmYWxzZVxuXG4gICAgY29uc3QgeyBwYXRocywgZGlycyB9ID0gcmVzZXJ2YXRpb25zLmdldChmbilcbiAgICBjb25zdCBuZXh0ID0gbmV3IFNldCgpXG5cbiAgICBwYXRocy5mb3JFYWNoKHBhdGggPT4ge1xuICAgICAgY29uc3QgcSA9IHF1ZXVlcy5nZXQocGF0aClcbiAgICAgIGFzc2VydC5lcXVhbChxWzBdLCBmbilcbiAgICAgIGlmIChxLmxlbmd0aCA9PT0gMSlcbiAgICAgICAgcXVldWVzLmRlbGV0ZShwYXRoKVxuICAgICAgZWxzZSB7XG4gICAgICAgIHEuc2hpZnQoKVxuICAgICAgICBpZiAodHlwZW9mIHFbMF0gPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgbmV4dC5hZGQocVswXSlcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHFbMF0uZm9yRWFjaChmbiA9PiBuZXh0LmFkZChmbikpXG4gICAgICB9XG4gICAgfSlcblxuICAgIGRpcnMuZm9yRWFjaChkaXIgPT4ge1xuICAgICAgY29uc3QgcSA9IHF1ZXVlcy5nZXQoZGlyKVxuICAgICAgYXNzZXJ0KHFbMF0gaW5zdGFuY2VvZiBTZXQpXG4gICAgICBpZiAocVswXS5zaXplID09PSAxICYmIHEubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHF1ZXVlcy5kZWxldGUoZGlyKVxuICAgICAgfSBlbHNlIGlmIChxWzBdLnNpemUgPT09IDEpIHtcbiAgICAgICAgcS5zaGlmdCgpXG5cbiAgICAgICAgLy8gbXVzdCBiZSBhIGZ1bmN0aW9uIG9yIGVsc2UgdGhlIFNldCB3b3VsZCd2ZSBiZWVuIHJldXNlZFxuICAgICAgICBuZXh0LmFkZChxWzBdKVxuICAgICAgfSBlbHNlXG4gICAgICAgIHFbMF0uZGVsZXRlKGZuKVxuICAgIH0pXG4gICAgcnVubmluZy5kZWxldGUoZm4pXG5cbiAgICBuZXh0LmZvckVhY2goZm4gPT4gcnVuKGZuKSlcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgY29uc3QgcmVzZXJ2ZSA9IChwYXRocywgZm4pID0+IHtcbiAgICAvLyBjb2xsaWRlIG9uIG1hdGNoZXMgYWNyb3NzIGNhc2UgYW5kIHVuaWNvZGUgbm9ybWFsaXphdGlvblxuICAgIC8vIE9uIHdpbmRvd3MsIHRoYW5rcyB0byB0aGUgbWFnaWMgb2YgOC4zIHNob3J0bmFtZXMsIGl0IGlzIGZ1bmRhbWVudGFsbHlcbiAgICAvLyBpbXBvc3NpYmxlIHRvIGRldGVybWluZSB3aGV0aGVyIHR3byBwYXRocyByZWZlciB0byB0aGUgc2FtZSB0aGluZyBvblxuICAgIC8vIGRpc2ssIHdpdGhvdXQgYXNraW5nIHRoZSBrZXJuZWwgZm9yIGEgc2hvcnRuYW1lLlxuICAgIC8vIFNvLCB3ZSBqdXN0IHByZXRlbmQgdGhhdCBldmVyeSBwYXRoIG1hdGNoZXMgZXZlcnkgb3RoZXIgcGF0aCBoZXJlLFxuICAgIC8vIGVmZmVjdGl2ZWx5IHJlbW92aW5nIGFsbCBwYXJhbGxlbGl6YXRpb24gb24gd2luZG93cy5cbiAgICBwYXRocyA9IGlzV2luZG93cyA/IFsnd2luMzIgcGFyYWxsZWxpemF0aW9uIGRpc2FibGVkJ10gOiBwYXRocy5tYXAocCA9PiB7XG4gICAgICByZXR1cm4gc3RyaXBTbGFzaGVzKG5vcm1QYXRoKGpvaW4ocCkpKVxuICAgICAgICAubm9ybWFsaXplKCdORktEJylcbiAgICAgICAgLnRvTG93ZXJDYXNlKClcbiAgICB9KVxuXG4gICAgY29uc3QgZGlycyA9IG5ldyBTZXQoXG4gICAgICBwYXRocy5tYXAocGF0aCA9PiBnZXREaXJzKHBhdGgpKS5yZWR1Y2UoKGEsIGIpID0+IGEuY29uY2F0KGIpKVxuICAgIClcbiAgICByZXNlcnZhdGlvbnMuc2V0KGZuLCB7ZGlycywgcGF0aHN9KVxuICAgIHBhdGhzLmZvckVhY2gocGF0aCA9PiB7XG4gICAgICBjb25zdCBxID0gcXVldWVzLmdldChwYXRoKVxuICAgICAgaWYgKCFxKVxuICAgICAgICBxdWV1ZXMuc2V0KHBhdGgsIFtmbl0pXG4gICAgICBlbHNlXG4gICAgICAgIHEucHVzaChmbilcbiAgICB9KVxuICAgIGRpcnMuZm9yRWFjaChkaXIgPT4ge1xuICAgICAgY29uc3QgcSA9IHF1ZXVlcy5nZXQoZGlyKVxuICAgICAgaWYgKCFxKVxuICAgICAgICBxdWV1ZXMuc2V0KGRpciwgW25ldyBTZXQoW2ZuXSldKVxuICAgICAgZWxzZSBpZiAocVtxLmxlbmd0aC0xXSBpbnN0YW5jZW9mIFNldClcbiAgICAgICAgcVtxLmxlbmd0aC0xXS5hZGQoZm4pXG4gICAgICBlbHNlXG4gICAgICAgIHEucHVzaChuZXcgU2V0KFtmbl0pKVxuICAgIH0pXG5cbiAgICByZXR1cm4gcnVuKGZuKVxuICB9XG5cbiAgcmV0dXJuIHsgY2hlY2ssIHJlc2VydmUgfVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/tar/lib/path-reservations.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/tar/lib/pax.js":
/*!*****************************************!*\
  !*** ../../node_modules/tar/lib/pax.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst Buffer = __webpack_require__(/*! ./buffer.js */ \"(rsc)/../../node_modules/tar/lib/buffer.js\")\nconst Header = __webpack_require__(/*! ./header.js */ \"(rsc)/../../node_modules/tar/lib/header.js\")\nconst path = __webpack_require__(/*! path */ \"path\")\n\nclass Pax {\n  constructor (obj, global) {\n    this.atime = obj.atime || null\n    this.charset = obj.charset || null\n    this.comment = obj.comment || null\n    this.ctime = obj.ctime || null\n    this.gid = obj.gid || null\n    this.gname = obj.gname || null\n    this.linkpath = obj.linkpath || null\n    this.mtime = obj.mtime || null\n    this.path = obj.path || null\n    this.size = obj.size || null\n    this.uid = obj.uid || null\n    this.uname = obj.uname || null\n    this.dev = obj.dev || null\n    this.ino = obj.ino || null\n    this.nlink = obj.nlink || null\n    this.global = global || false\n  }\n\n  encode () {\n    const body = this.encodeBody()\n    if (body === '')\n      return null\n\n    const bodyLen = Buffer.byteLength(body)\n    // round up to 512 bytes\n    // add 512 for header\n    const bufLen = 512 * Math.ceil(1 + bodyLen / 512)\n    const buf = Buffer.allocUnsafe(bufLen)\n\n    // 0-fill the header section, it might not hit every field\n    for (let i = 0; i < 512; i++) {\n      buf[i] = 0\n    }\n\n    new Header({\n      // XXX split the path\n      // then the path should be PaxHeader + basename, but less than 99,\n      // prepend with the dirname\n      path: ('PaxHeader/' + path.basename(this.path)).slice(0, 99),\n      mode: this.mode || 0o644,\n      uid: this.uid || null,\n      gid: this.gid || null,\n      size: bodyLen,\n      mtime: this.mtime || null,\n      type: this.global ? 'GlobalExtendedHeader' : 'ExtendedHeader',\n      linkpath: '',\n      uname: this.uname || '',\n      gname: this.gname || '',\n      devmaj: 0,\n      devmin: 0,\n      atime: this.atime || null,\n      ctime: this.ctime || null\n    }).encode(buf)\n\n    buf.write(body, 512, bodyLen, 'utf8')\n\n    // null pad after the body\n    for (let i = bodyLen + 512; i < buf.length; i++) {\n      buf[i] = 0\n    }\n\n    return buf\n  }\n\n  encodeBody () {\n    return (\n      this.encodeField('path') +\n      this.encodeField('ctime') +\n      this.encodeField('atime') +\n      this.encodeField('dev') +\n      this.encodeField('ino') +\n      this.encodeField('nlink') +\n      this.encodeField('charset') +\n      this.encodeField('comment') +\n      this.encodeField('gid') +\n      this.encodeField('gname') +\n      this.encodeField('linkpath') +\n      this.encodeField('mtime') +\n      this.encodeField('size') +\n      this.encodeField('uid') +\n      this.encodeField('uname')\n    )\n  }\n\n  encodeField (field) {\n    if (this[field] === null || this[field] === undefined)\n      return ''\n    const v = this[field] instanceof Date ? this[field].getTime() / 1000\n      : this[field]\n    const s = ' ' +\n      (field === 'dev' || field === 'ino' || field === 'nlink'\n       ? 'SCHILY.' : '') +\n      field + '=' + v + '\\n'\n    const byteLen = Buffer.byteLength(s)\n    // the digits includes the length of the digits in ascii base-10\n    // so if it's 9 characters, then adding 1 for the 9 makes it 10\n    // which makes it 11 chars.\n    let digits = Math.floor(Math.log(byteLen) / Math.log(10)) + 1\n    if (byteLen + digits >= Math.pow(10, digits))\n      digits += 1\n    const len = digits + byteLen\n    return len + s\n  }\n}\n\nPax.parse = (string, ex, g) => new Pax(merge(parseKV(string), ex), g)\n\nconst merge = (a, b) =>\n  b ? Object.keys(a).reduce((s, k) => (s[k] = a[k], s), b) : a\n\nconst parseKV = string =>\n  string\n    .replace(/\\n$/, '')\n    .split('\\n')\n    .reduce(parseKVLine, Object.create(null))\n\nconst parseKVLine = (set, line) => {\n  const n = parseInt(line, 10)\n\n  // XXX Values with \\n in them will fail this.\n  // Refactor to not be a naive line-by-line parse.\n  if (n !== Buffer.byteLength(line) + 1)\n    return set\n\n  line = line.substr((n + ' ').length)\n  const kv = line.split('=')\n  const k = kv.shift().replace(/^SCHILY\\.(dev|ino|nlink)/, '$1')\n  if (!k)\n    return set\n\n  const v = kv.join('=')\n  set[k] = /^([A-Z]+\\.)?([mac]|birth|creation)time$/.test(k)\n    ?  new Date(v * 1000)\n    : /^[0-9]+$/.test(v) ? +v\n    : v\n  return set\n}\n\nmodule.exports = Pax\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL3Rhci9saWIvcGF4LmpzIiwibWFwcGluZ3MiOiJBQUFZO0FBQ1osZUFBZSxtQkFBTyxDQUFDLCtEQUFhO0FBQ3BDLGVBQWUsbUJBQU8sQ0FBQywrREFBYTtBQUNwQyxhQUFhLG1CQUFPLENBQUMsa0JBQU07O0FBRTNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQSxnQ0FBZ0MsZ0JBQWdCO0FBQ2hEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIi9ob21lL2JhcmIvYWEvQXNzb2NpYXRlZEFjY291bnRzL25vZGVfbW9kdWxlcy90YXIvbGliL3BheC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcbmNvbnN0IEJ1ZmZlciA9IHJlcXVpcmUoJy4vYnVmZmVyLmpzJylcbmNvbnN0IEhlYWRlciA9IHJlcXVpcmUoJy4vaGVhZGVyLmpzJylcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJylcblxuY2xhc3MgUGF4IHtcbiAgY29uc3RydWN0b3IgKG9iaiwgZ2xvYmFsKSB7XG4gICAgdGhpcy5hdGltZSA9IG9iai5hdGltZSB8fCBudWxsXG4gICAgdGhpcy5jaGFyc2V0ID0gb2JqLmNoYXJzZXQgfHwgbnVsbFxuICAgIHRoaXMuY29tbWVudCA9IG9iai5jb21tZW50IHx8IG51bGxcbiAgICB0aGlzLmN0aW1lID0gb2JqLmN0aW1lIHx8IG51bGxcbiAgICB0aGlzLmdpZCA9IG9iai5naWQgfHwgbnVsbFxuICAgIHRoaXMuZ25hbWUgPSBvYmouZ25hbWUgfHwgbnVsbFxuICAgIHRoaXMubGlua3BhdGggPSBvYmoubGlua3BhdGggfHwgbnVsbFxuICAgIHRoaXMubXRpbWUgPSBvYmoubXRpbWUgfHwgbnVsbFxuICAgIHRoaXMucGF0aCA9IG9iai5wYXRoIHx8IG51bGxcbiAgICB0aGlzLnNpemUgPSBvYmouc2l6ZSB8fCBudWxsXG4gICAgdGhpcy51aWQgPSBvYmoudWlkIHx8IG51bGxcbiAgICB0aGlzLnVuYW1lID0gb2JqLnVuYW1lIHx8IG51bGxcbiAgICB0aGlzLmRldiA9IG9iai5kZXYgfHwgbnVsbFxuICAgIHRoaXMuaW5vID0gb2JqLmlubyB8fCBudWxsXG4gICAgdGhpcy5ubGluayA9IG9iai5ubGluayB8fCBudWxsXG4gICAgdGhpcy5nbG9iYWwgPSBnbG9iYWwgfHwgZmFsc2VcbiAgfVxuXG4gIGVuY29kZSAoKSB7XG4gICAgY29uc3QgYm9keSA9IHRoaXMuZW5jb2RlQm9keSgpXG4gICAgaWYgKGJvZHkgPT09ICcnKVxuICAgICAgcmV0dXJuIG51bGxcblxuICAgIGNvbnN0IGJvZHlMZW4gPSBCdWZmZXIuYnl0ZUxlbmd0aChib2R5KVxuICAgIC8vIHJvdW5kIHVwIHRvIDUxMiBieXRlc1xuICAgIC8vIGFkZCA1MTIgZm9yIGhlYWRlclxuICAgIGNvbnN0IGJ1ZkxlbiA9IDUxMiAqIE1hdGguY2VpbCgxICsgYm9keUxlbiAvIDUxMilcbiAgICBjb25zdCBidWYgPSBCdWZmZXIuYWxsb2NVbnNhZmUoYnVmTGVuKVxuXG4gICAgLy8gMC1maWxsIHRoZSBoZWFkZXIgc2VjdGlvbiwgaXQgbWlnaHQgbm90IGhpdCBldmVyeSBmaWVsZFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNTEyOyBpKyspIHtcbiAgICAgIGJ1ZltpXSA9IDBcbiAgICB9XG5cbiAgICBuZXcgSGVhZGVyKHtcbiAgICAgIC8vIFhYWCBzcGxpdCB0aGUgcGF0aFxuICAgICAgLy8gdGhlbiB0aGUgcGF0aCBzaG91bGQgYmUgUGF4SGVhZGVyICsgYmFzZW5hbWUsIGJ1dCBsZXNzIHRoYW4gOTksXG4gICAgICAvLyBwcmVwZW5kIHdpdGggdGhlIGRpcm5hbWVcbiAgICAgIHBhdGg6ICgnUGF4SGVhZGVyLycgKyBwYXRoLmJhc2VuYW1lKHRoaXMucGF0aCkpLnNsaWNlKDAsIDk5KSxcbiAgICAgIG1vZGU6IHRoaXMubW9kZSB8fCAwbzY0NCxcbiAgICAgIHVpZDogdGhpcy51aWQgfHwgbnVsbCxcbiAgICAgIGdpZDogdGhpcy5naWQgfHwgbnVsbCxcbiAgICAgIHNpemU6IGJvZHlMZW4sXG4gICAgICBtdGltZTogdGhpcy5tdGltZSB8fCBudWxsLFxuICAgICAgdHlwZTogdGhpcy5nbG9iYWwgPyAnR2xvYmFsRXh0ZW5kZWRIZWFkZXInIDogJ0V4dGVuZGVkSGVhZGVyJyxcbiAgICAgIGxpbmtwYXRoOiAnJyxcbiAgICAgIHVuYW1lOiB0aGlzLnVuYW1lIHx8ICcnLFxuICAgICAgZ25hbWU6IHRoaXMuZ25hbWUgfHwgJycsXG4gICAgICBkZXZtYWo6IDAsXG4gICAgICBkZXZtaW46IDAsXG4gICAgICBhdGltZTogdGhpcy5hdGltZSB8fCBudWxsLFxuICAgICAgY3RpbWU6IHRoaXMuY3RpbWUgfHwgbnVsbFxuICAgIH0pLmVuY29kZShidWYpXG5cbiAgICBidWYud3JpdGUoYm9keSwgNTEyLCBib2R5TGVuLCAndXRmOCcpXG5cbiAgICAvLyBudWxsIHBhZCBhZnRlciB0aGUgYm9keVxuICAgIGZvciAobGV0IGkgPSBib2R5TGVuICsgNTEyOyBpIDwgYnVmLmxlbmd0aDsgaSsrKSB7XG4gICAgICBidWZbaV0gPSAwXG4gICAgfVxuXG4gICAgcmV0dXJuIGJ1ZlxuICB9XG5cbiAgZW5jb2RlQm9keSAoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIHRoaXMuZW5jb2RlRmllbGQoJ3BhdGgnKSArXG4gICAgICB0aGlzLmVuY29kZUZpZWxkKCdjdGltZScpICtcbiAgICAgIHRoaXMuZW5jb2RlRmllbGQoJ2F0aW1lJykgK1xuICAgICAgdGhpcy5lbmNvZGVGaWVsZCgnZGV2JykgK1xuICAgICAgdGhpcy5lbmNvZGVGaWVsZCgnaW5vJykgK1xuICAgICAgdGhpcy5lbmNvZGVGaWVsZCgnbmxpbmsnKSArXG4gICAgICB0aGlzLmVuY29kZUZpZWxkKCdjaGFyc2V0JykgK1xuICAgICAgdGhpcy5lbmNvZGVGaWVsZCgnY29tbWVudCcpICtcbiAgICAgIHRoaXMuZW5jb2RlRmllbGQoJ2dpZCcpICtcbiAgICAgIHRoaXMuZW5jb2RlRmllbGQoJ2duYW1lJykgK1xuICAgICAgdGhpcy5lbmNvZGVGaWVsZCgnbGlua3BhdGgnKSArXG4gICAgICB0aGlzLmVuY29kZUZpZWxkKCdtdGltZScpICtcbiAgICAgIHRoaXMuZW5jb2RlRmllbGQoJ3NpemUnKSArXG4gICAgICB0aGlzLmVuY29kZUZpZWxkKCd1aWQnKSArXG4gICAgICB0aGlzLmVuY29kZUZpZWxkKCd1bmFtZScpXG4gICAgKVxuICB9XG5cbiAgZW5jb2RlRmllbGQgKGZpZWxkKSB7XG4gICAgaWYgKHRoaXNbZmllbGRdID09PSBudWxsIHx8IHRoaXNbZmllbGRdID09PSB1bmRlZmluZWQpXG4gICAgICByZXR1cm4gJydcbiAgICBjb25zdCB2ID0gdGhpc1tmaWVsZF0gaW5zdGFuY2VvZiBEYXRlID8gdGhpc1tmaWVsZF0uZ2V0VGltZSgpIC8gMTAwMFxuICAgICAgOiB0aGlzW2ZpZWxkXVxuICAgIGNvbnN0IHMgPSAnICcgK1xuICAgICAgKGZpZWxkID09PSAnZGV2JyB8fCBmaWVsZCA9PT0gJ2lubycgfHwgZmllbGQgPT09ICdubGluaydcbiAgICAgICA/ICdTQ0hJTFkuJyA6ICcnKSArXG4gICAgICBmaWVsZCArICc9JyArIHYgKyAnXFxuJ1xuICAgIGNvbnN0IGJ5dGVMZW4gPSBCdWZmZXIuYnl0ZUxlbmd0aChzKVxuICAgIC8vIHRoZSBkaWdpdHMgaW5jbHVkZXMgdGhlIGxlbmd0aCBvZiB0aGUgZGlnaXRzIGluIGFzY2lpIGJhc2UtMTBcbiAgICAvLyBzbyBpZiBpdCdzIDkgY2hhcmFjdGVycywgdGhlbiBhZGRpbmcgMSBmb3IgdGhlIDkgbWFrZXMgaXQgMTBcbiAgICAvLyB3aGljaCBtYWtlcyBpdCAxMSBjaGFycy5cbiAgICBsZXQgZGlnaXRzID0gTWF0aC5mbG9vcihNYXRoLmxvZyhieXRlTGVuKSAvIE1hdGgubG9nKDEwKSkgKyAxXG4gICAgaWYgKGJ5dGVMZW4gKyBkaWdpdHMgPj0gTWF0aC5wb3coMTAsIGRpZ2l0cykpXG4gICAgICBkaWdpdHMgKz0gMVxuICAgIGNvbnN0IGxlbiA9IGRpZ2l0cyArIGJ5dGVMZW5cbiAgICByZXR1cm4gbGVuICsgc1xuICB9XG59XG5cblBheC5wYXJzZSA9IChzdHJpbmcsIGV4LCBnKSA9PiBuZXcgUGF4KG1lcmdlKHBhcnNlS1Yoc3RyaW5nKSwgZXgpLCBnKVxuXG5jb25zdCBtZXJnZSA9IChhLCBiKSA9PlxuICBiID8gT2JqZWN0LmtleXMoYSkucmVkdWNlKChzLCBrKSA9PiAoc1trXSA9IGFba10sIHMpLCBiKSA6IGFcblxuY29uc3QgcGFyc2VLViA9IHN0cmluZyA9PlxuICBzdHJpbmdcbiAgICAucmVwbGFjZSgvXFxuJC8sICcnKVxuICAgIC5zcGxpdCgnXFxuJylcbiAgICAucmVkdWNlKHBhcnNlS1ZMaW5lLCBPYmplY3QuY3JlYXRlKG51bGwpKVxuXG5jb25zdCBwYXJzZUtWTGluZSA9IChzZXQsIGxpbmUpID0+IHtcbiAgY29uc3QgbiA9IHBhcnNlSW50KGxpbmUsIDEwKVxuXG4gIC8vIFhYWCBWYWx1ZXMgd2l0aCBcXG4gaW4gdGhlbSB3aWxsIGZhaWwgdGhpcy5cbiAgLy8gUmVmYWN0b3IgdG8gbm90IGJlIGEgbmFpdmUgbGluZS1ieS1saW5lIHBhcnNlLlxuICBpZiAobiAhPT0gQnVmZmVyLmJ5dGVMZW5ndGgobGluZSkgKyAxKVxuICAgIHJldHVybiBzZXRcblxuICBsaW5lID0gbGluZS5zdWJzdHIoKG4gKyAnICcpLmxlbmd0aClcbiAgY29uc3Qga3YgPSBsaW5lLnNwbGl0KCc9JylcbiAgY29uc3QgayA9IGt2LnNoaWZ0KCkucmVwbGFjZSgvXlNDSElMWVxcLihkZXZ8aW5vfG5saW5rKS8sICckMScpXG4gIGlmICghaylcbiAgICByZXR1cm4gc2V0XG5cbiAgY29uc3QgdiA9IGt2LmpvaW4oJz0nKVxuICBzZXRba10gPSAvXihbQS1aXStcXC4pPyhbbWFjXXxiaXJ0aHxjcmVhdGlvbil0aW1lJC8udGVzdChrKVxuICAgID8gIG5ldyBEYXRlKHYgKiAxMDAwKVxuICAgIDogL15bMC05XSskLy50ZXN0KHYpID8gK3ZcbiAgICA6IHZcbiAgcmV0dXJuIHNldFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFBheFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/tar/lib/pax.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/tar/lib/read-entry.js":
/*!************************************************!*\
  !*** ../../node_modules/tar/lib/read-entry.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst types = __webpack_require__(/*! ./types.js */ \"(rsc)/../../node_modules/tar/lib/types.js\")\nconst MiniPass = __webpack_require__(/*! minipass */ \"(rsc)/../../node_modules/minipass/index.js\")\nconst normPath = __webpack_require__(/*! ./normalize-windows-path.js */ \"(rsc)/../../node_modules/tar/lib/normalize-windows-path.js\")\n\nconst SLURP = Symbol('slurp')\nmodule.exports = class ReadEntry extends MiniPass {\n  constructor (header, ex, gex) {\n    super()\n    // read entries always start life paused.  this is to avoid the\n    // situation where Minipass's auto-ending empty streams results\n    // in an entry ending before we're ready for it.\n    this.pause()\n    this.extended = ex\n    this.globalExtended = gex\n    this.header = header\n    this.startBlockSize = 512 * Math.ceil(header.size / 512)\n    this.blockRemain = this.startBlockSize\n    this.remain = header.size\n    this.type = header.type\n    this.meta = false\n    this.ignore = false\n    switch (this.type) {\n      case 'File':\n      case 'OldFile':\n      case 'Link':\n      case 'SymbolicLink':\n      case 'CharacterDevice':\n      case 'BlockDevice':\n      case 'Directory':\n      case 'FIFO':\n      case 'ContiguousFile':\n      case 'GNUDumpDir':\n        break\n\n      case 'NextFileHasLongLinkpath':\n      case 'NextFileHasLongPath':\n      case 'OldGnuLongPath':\n      case 'GlobalExtendedHeader':\n      case 'ExtendedHeader':\n      case 'OldExtendedHeader':\n        this.meta = true\n        break\n\n      // NOTE: gnutar and bsdtar treat unrecognized types as 'File'\n      // it may be worth doing the same, but with a warning.\n      default:\n        this.ignore = true\n    }\n\n    this.path = normPath(header.path)\n    this.mode = header.mode\n    if (this.mode)\n      this.mode = this.mode & 0o7777\n    this.uid = header.uid\n    this.gid = header.gid\n    this.uname = header.uname\n    this.gname = header.gname\n    this.size = header.size\n    this.mtime = header.mtime\n    this.atime = header.atime\n    this.ctime = header.ctime\n    this.linkpath = normPath(header.linkpath)\n    this.uname = header.uname\n    this.gname = header.gname\n\n    if (ex) this[SLURP](ex)\n    if (gex) this[SLURP](gex, true)\n  }\n\n  write (data) {\n    const writeLen = data.length\n    if (writeLen > this.blockRemain)\n      throw new Error('writing more to entry than is appropriate')\n\n    const r = this.remain\n    const br = this.blockRemain\n    this.remain = Math.max(0, r - writeLen)\n    this.blockRemain = Math.max(0, br - writeLen)\n    if (this.ignore)\n      return true\n\n    if (r >= writeLen)\n      return super.write(data)\n\n    // r < writeLen\n    return super.write(data.slice(0, r))\n  }\n\n  [SLURP] (ex, global) {\n    for (let k in ex) {\n      // we slurp in everything except for the path attribute in\n      // a global extended header, because that's weird.\n      if (ex[k] !== null && ex[k] !== undefined &&\n          !(global && k === 'path'))\n        this[k] = k === 'path' || k === 'linkpath' ? normPath(ex[k]) : ex[k]\n    }\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL3Rhci9saWIvcmVhZC1lbnRyeS5qcyIsIm1hcHBpbmdzIjoiQUFBWTtBQUNaLGNBQWMsbUJBQU8sQ0FBQyw2REFBWTtBQUNsQyxpQkFBaUIsbUJBQU8sQ0FBQyw0REFBVTtBQUNuQyxpQkFBaUIsbUJBQU8sQ0FBQywrRkFBNkI7O0FBRXREO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9iYXJiL2FhL0Fzc29jaWF0ZWRBY2NvdW50cy9ub2RlX21vZHVsZXMvdGFyL2xpYi9yZWFkLWVudHJ5LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuY29uc3QgdHlwZXMgPSByZXF1aXJlKCcuL3R5cGVzLmpzJylcbmNvbnN0IE1pbmlQYXNzID0gcmVxdWlyZSgnbWluaXBhc3MnKVxuY29uc3Qgbm9ybVBhdGggPSByZXF1aXJlKCcuL25vcm1hbGl6ZS13aW5kb3dzLXBhdGguanMnKVxuXG5jb25zdCBTTFVSUCA9IFN5bWJvbCgnc2x1cnAnKVxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBSZWFkRW50cnkgZXh0ZW5kcyBNaW5pUGFzcyB7XG4gIGNvbnN0cnVjdG9yIChoZWFkZXIsIGV4LCBnZXgpIHtcbiAgICBzdXBlcigpXG4gICAgLy8gcmVhZCBlbnRyaWVzIGFsd2F5cyBzdGFydCBsaWZlIHBhdXNlZC4gIHRoaXMgaXMgdG8gYXZvaWQgdGhlXG4gICAgLy8gc2l0dWF0aW9uIHdoZXJlIE1pbmlwYXNzJ3MgYXV0by1lbmRpbmcgZW1wdHkgc3RyZWFtcyByZXN1bHRzXG4gICAgLy8gaW4gYW4gZW50cnkgZW5kaW5nIGJlZm9yZSB3ZSdyZSByZWFkeSBmb3IgaXQuXG4gICAgdGhpcy5wYXVzZSgpXG4gICAgdGhpcy5leHRlbmRlZCA9IGV4XG4gICAgdGhpcy5nbG9iYWxFeHRlbmRlZCA9IGdleFxuICAgIHRoaXMuaGVhZGVyID0gaGVhZGVyXG4gICAgdGhpcy5zdGFydEJsb2NrU2l6ZSA9IDUxMiAqIE1hdGguY2VpbChoZWFkZXIuc2l6ZSAvIDUxMilcbiAgICB0aGlzLmJsb2NrUmVtYWluID0gdGhpcy5zdGFydEJsb2NrU2l6ZVxuICAgIHRoaXMucmVtYWluID0gaGVhZGVyLnNpemVcbiAgICB0aGlzLnR5cGUgPSBoZWFkZXIudHlwZVxuICAgIHRoaXMubWV0YSA9IGZhbHNlXG4gICAgdGhpcy5pZ25vcmUgPSBmYWxzZVxuICAgIHN3aXRjaCAodGhpcy50eXBlKSB7XG4gICAgICBjYXNlICdGaWxlJzpcbiAgICAgIGNhc2UgJ09sZEZpbGUnOlxuICAgICAgY2FzZSAnTGluayc6XG4gICAgICBjYXNlICdTeW1ib2xpY0xpbmsnOlxuICAgICAgY2FzZSAnQ2hhcmFjdGVyRGV2aWNlJzpcbiAgICAgIGNhc2UgJ0Jsb2NrRGV2aWNlJzpcbiAgICAgIGNhc2UgJ0RpcmVjdG9yeSc6XG4gICAgICBjYXNlICdGSUZPJzpcbiAgICAgIGNhc2UgJ0NvbnRpZ3VvdXNGaWxlJzpcbiAgICAgIGNhc2UgJ0dOVUR1bXBEaXInOlxuICAgICAgICBicmVha1xuXG4gICAgICBjYXNlICdOZXh0RmlsZUhhc0xvbmdMaW5rcGF0aCc6XG4gICAgICBjYXNlICdOZXh0RmlsZUhhc0xvbmdQYXRoJzpcbiAgICAgIGNhc2UgJ09sZEdudUxvbmdQYXRoJzpcbiAgICAgIGNhc2UgJ0dsb2JhbEV4dGVuZGVkSGVhZGVyJzpcbiAgICAgIGNhc2UgJ0V4dGVuZGVkSGVhZGVyJzpcbiAgICAgIGNhc2UgJ09sZEV4dGVuZGVkSGVhZGVyJzpcbiAgICAgICAgdGhpcy5tZXRhID0gdHJ1ZVxuICAgICAgICBicmVha1xuXG4gICAgICAvLyBOT1RFOiBnbnV0YXIgYW5kIGJzZHRhciB0cmVhdCB1bnJlY29nbml6ZWQgdHlwZXMgYXMgJ0ZpbGUnXG4gICAgICAvLyBpdCBtYXkgYmUgd29ydGggZG9pbmcgdGhlIHNhbWUsIGJ1dCB3aXRoIGEgd2FybmluZy5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRoaXMuaWdub3JlID0gdHJ1ZVxuICAgIH1cblxuICAgIHRoaXMucGF0aCA9IG5vcm1QYXRoKGhlYWRlci5wYXRoKVxuICAgIHRoaXMubW9kZSA9IGhlYWRlci5tb2RlXG4gICAgaWYgKHRoaXMubW9kZSlcbiAgICAgIHRoaXMubW9kZSA9IHRoaXMubW9kZSAmIDBvNzc3N1xuICAgIHRoaXMudWlkID0gaGVhZGVyLnVpZFxuICAgIHRoaXMuZ2lkID0gaGVhZGVyLmdpZFxuICAgIHRoaXMudW5hbWUgPSBoZWFkZXIudW5hbWVcbiAgICB0aGlzLmduYW1lID0gaGVhZGVyLmduYW1lXG4gICAgdGhpcy5zaXplID0gaGVhZGVyLnNpemVcbiAgICB0aGlzLm10aW1lID0gaGVhZGVyLm10aW1lXG4gICAgdGhpcy5hdGltZSA9IGhlYWRlci5hdGltZVxuICAgIHRoaXMuY3RpbWUgPSBoZWFkZXIuY3RpbWVcbiAgICB0aGlzLmxpbmtwYXRoID0gbm9ybVBhdGgoaGVhZGVyLmxpbmtwYXRoKVxuICAgIHRoaXMudW5hbWUgPSBoZWFkZXIudW5hbWVcbiAgICB0aGlzLmduYW1lID0gaGVhZGVyLmduYW1lXG5cbiAgICBpZiAoZXgpIHRoaXNbU0xVUlBdKGV4KVxuICAgIGlmIChnZXgpIHRoaXNbU0xVUlBdKGdleCwgdHJ1ZSlcbiAgfVxuXG4gIHdyaXRlIChkYXRhKSB7XG4gICAgY29uc3Qgd3JpdGVMZW4gPSBkYXRhLmxlbmd0aFxuICAgIGlmICh3cml0ZUxlbiA+IHRoaXMuYmxvY2tSZW1haW4pXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3dyaXRpbmcgbW9yZSB0byBlbnRyeSB0aGFuIGlzIGFwcHJvcHJpYXRlJylcblxuICAgIGNvbnN0IHIgPSB0aGlzLnJlbWFpblxuICAgIGNvbnN0IGJyID0gdGhpcy5ibG9ja1JlbWFpblxuICAgIHRoaXMucmVtYWluID0gTWF0aC5tYXgoMCwgciAtIHdyaXRlTGVuKVxuICAgIHRoaXMuYmxvY2tSZW1haW4gPSBNYXRoLm1heCgwLCBiciAtIHdyaXRlTGVuKVxuICAgIGlmICh0aGlzLmlnbm9yZSlcbiAgICAgIHJldHVybiB0cnVlXG5cbiAgICBpZiAociA+PSB3cml0ZUxlbilcbiAgICAgIHJldHVybiBzdXBlci53cml0ZShkYXRhKVxuXG4gICAgLy8gciA8IHdyaXRlTGVuXG4gICAgcmV0dXJuIHN1cGVyLndyaXRlKGRhdGEuc2xpY2UoMCwgcikpXG4gIH1cblxuICBbU0xVUlBdIChleCwgZ2xvYmFsKSB7XG4gICAgZm9yIChsZXQgayBpbiBleCkge1xuICAgICAgLy8gd2Ugc2x1cnAgaW4gZXZlcnl0aGluZyBleGNlcHQgZm9yIHRoZSBwYXRoIGF0dHJpYnV0ZSBpblxuICAgICAgLy8gYSBnbG9iYWwgZXh0ZW5kZWQgaGVhZGVyLCBiZWNhdXNlIHRoYXQncyB3ZWlyZC5cbiAgICAgIGlmIChleFtrXSAhPT0gbnVsbCAmJiBleFtrXSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgIShnbG9iYWwgJiYgayA9PT0gJ3BhdGgnKSlcbiAgICAgICAgdGhpc1trXSA9IGsgPT09ICdwYXRoJyB8fCBrID09PSAnbGlua3BhdGgnID8gbm9ybVBhdGgoZXhba10pIDogZXhba11cbiAgICB9XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/tar/lib/read-entry.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/tar/lib/replace.js":
/*!*********************************************!*\
  !*** ../../node_modules/tar/lib/replace.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst Buffer = __webpack_require__(/*! ./buffer.js */ \"(rsc)/../../node_modules/tar/lib/buffer.js\")\n\n// tar -r\nconst hlo = __webpack_require__(/*! ./high-level-opt.js */ \"(rsc)/../../node_modules/tar/lib/high-level-opt.js\")\nconst Pack = __webpack_require__(/*! ./pack.js */ \"(rsc)/../../node_modules/tar/lib/pack.js\")\nconst Parse = __webpack_require__(/*! ./parse.js */ \"(rsc)/../../node_modules/tar/lib/parse.js\")\nconst fs = __webpack_require__(/*! fs */ \"fs\")\nconst fsm = __webpack_require__(/*! fs-minipass */ \"(rsc)/../../node_modules/fs-minipass/index.js\")\nconst t = __webpack_require__(/*! ./list.js */ \"(rsc)/../../node_modules/tar/lib/list.js\")\nconst path = __webpack_require__(/*! path */ \"path\")\n\n// starting at the head of the file, read a Header\n// If the checksum is invalid, that's our position to start writing\n// If it is, jump forward by the specified size (round up to 512)\n// and try again.\n// Write the new Pack stream starting there.\n\nconst Header = __webpack_require__(/*! ./header.js */ \"(rsc)/../../node_modules/tar/lib/header.js\")\n\nconst r = module.exports = (opt_, files, cb) => {\n  const opt = hlo(opt_)\n\n  if (!opt.file)\n    throw new TypeError('file is required')\n\n  if (opt.gzip)\n    throw new TypeError('cannot append to compressed archives')\n\n  if (!files || !Array.isArray(files) || !files.length)\n    throw new TypeError('no files or directories specified')\n\n  files = Array.from(files)\n\n  return opt.sync ? replaceSync(opt, files)\n    : replace(opt, files, cb)\n}\n\nconst replaceSync = (opt, files) => {\n  const p = new Pack.Sync(opt)\n\n  let threw = true\n  let fd\n  let position\n\n  try {\n    try {\n      fd = fs.openSync(opt.file, 'r+')\n    } catch (er) {\n      if (er.code === 'ENOENT')\n        fd = fs.openSync(opt.file, 'w+')\n      else\n        throw er\n    }\n\n    const st = fs.fstatSync(fd)\n    const headBuf = Buffer.alloc(512)\n\n    POSITION: for (position = 0; position < st.size; position += 512) {\n      for (let bufPos = 0, bytes = 0; bufPos < 512; bufPos += bytes) {\n        bytes = fs.readSync(\n          fd, headBuf, bufPos, headBuf.length - bufPos, position + bufPos\n        )\n\n        if (position === 0 && headBuf[0] === 0x1f && headBuf[1] === 0x8b)\n          throw new Error('cannot append to compressed archives')\n\n        if (!bytes)\n          break POSITION\n      }\n\n      let h = new Header(headBuf)\n      if (!h.cksumValid)\n        break\n      let entryBlockSize = 512 * Math.ceil(h.size / 512)\n      if (position + entryBlockSize + 512 > st.size)\n        break\n      // the 512 for the header we just parsed will be added as well\n      // also jump ahead all the blocks for the body\n      position += entryBlockSize\n      if (opt.mtimeCache)\n        opt.mtimeCache.set(h.path, h.mtime)\n    }\n    threw = false\n\n    streamSync(opt, p, position, fd, files)\n  } finally {\n    if (threw)\n      try { fs.closeSync(fd) } catch (er) {}\n  }\n}\n\nconst streamSync = (opt, p, position, fd, files) => {\n  const stream = new fsm.WriteStreamSync(opt.file, {\n    fd: fd,\n    start: position\n  })\n  p.pipe(stream)\n  addFilesSync(p, files)\n}\n\nconst replace = (opt, files, cb) => {\n  files = Array.from(files)\n  const p = new Pack(opt)\n\n  const getPos = (fd, size, cb_) => {\n    const cb = (er, pos) => {\n      if (er)\n        fs.close(fd, _ => cb_(er))\n      else\n        cb_(null, pos)\n    }\n\n    let position = 0\n    if (size === 0)\n      return cb(null, 0)\n\n    let bufPos = 0\n    const headBuf = Buffer.alloc(512)\n    const onread = (er, bytes) => {\n      if (er)\n        return cb(er)\n      bufPos += bytes\n      if (bufPos < 512 && bytes)\n        return fs.read(\n          fd, headBuf, bufPos, headBuf.length - bufPos,\n          position + bufPos, onread\n        )\n\n      if (position === 0 && headBuf[0] === 0x1f && headBuf[1] === 0x8b)\n        return cb(new Error('cannot append to compressed archives'))\n\n      // truncated header\n      if (bufPos < 512)\n        return cb(null, position)\n\n      const h = new Header(headBuf)\n      if (!h.cksumValid)\n        return cb(null, position)\n\n      const entryBlockSize = 512 * Math.ceil(h.size / 512)\n      if (position + entryBlockSize + 512 > size)\n        return cb(null, position)\n\n      position += entryBlockSize + 512\n      if (position >= size)\n        return cb(null, position)\n\n      if (opt.mtimeCache)\n        opt.mtimeCache.set(h.path, h.mtime)\n      bufPos = 0\n      fs.read(fd, headBuf, 0, 512, position, onread)\n    }\n    fs.read(fd, headBuf, 0, 512, position, onread)\n  }\n\n  const promise = new Promise((resolve, reject) => {\n    p.on('error', reject)\n    let flag = 'r+'\n    const onopen = (er, fd) => {\n      if (er && er.code === 'ENOENT' && flag === 'r+') {\n        flag = 'w+'\n        return fs.open(opt.file, flag, onopen)\n      }\n\n      if (er)\n        return reject(er)\n\n      fs.fstat(fd, (er, st) => {\n        if (er)\n          return fs.close(fd, () => reject(er))\n\n        getPos(fd, st.size, (er, position) => {\n          if (er)\n            return reject(er)\n          const stream = new fsm.WriteStream(opt.file, {\n            fd: fd,\n            start: position\n          })\n          p.pipe(stream)\n          stream.on('error', reject)\n          stream.on('close', resolve)\n          addFilesAsync(p, files)\n        })\n      })\n    }\n    fs.open(opt.file, flag, onopen)\n  })\n\n  return cb ? promise.then(cb, cb) : promise\n}\n\nconst addFilesSync = (p, files) => {\n  files.forEach(file => {\n    if (file.charAt(0) === '@')\n      t({\n        file: path.resolve(p.cwd, file.substr(1)),\n        sync: true,\n        noResume: true,\n        onentry: entry => p.add(entry)\n      })\n    else\n      p.add(file)\n  })\n  p.end()\n}\n\nconst addFilesAsync = (p, files) => {\n  while (files.length) {\n    const file = files.shift()\n    if (file.charAt(0) === '@')\n      return t({\n        file: path.resolve(p.cwd, file.substr(1)),\n        noResume: true,\n        onentry: entry => p.add(entry)\n      }).then(_ => addFilesAsync(p, files))\n    else\n      p.add(file)\n  }\n  p.end()\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL3Rhci9saWIvcmVwbGFjZS5qcyIsIm1hcHBpbmdzIjoiQUFBWTtBQUNaLGVBQWUsbUJBQU8sQ0FBQywrREFBYTs7QUFFcEM7QUFDQSxZQUFZLG1CQUFPLENBQUMsK0VBQXFCO0FBQ3pDLGFBQWEsbUJBQU8sQ0FBQywyREFBVztBQUNoQyxjQUFjLG1CQUFPLENBQUMsNkRBQVk7QUFDbEMsV0FBVyxtQkFBTyxDQUFDLGNBQUk7QUFDdkIsWUFBWSxtQkFBTyxDQUFDLGtFQUFhO0FBQ2pDLFVBQVUsbUJBQU8sQ0FBQywyREFBVztBQUM3QixhQUFhLG1CQUFPLENBQUMsa0JBQU07O0FBRTNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZSxtQkFBTyxDQUFDLCtEQUFhOztBQUVwQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGlDQUFpQyxvQkFBb0I7QUFDckQsc0NBQXNDLGNBQWM7QUFDcEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsWUFBWSxtQkFBbUI7QUFDL0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvYmFyYi9hYS9Bc3NvY2lhdGVkQWNjb3VudHMvbm9kZV9tb2R1bGVzL3Rhci9saWIvcmVwbGFjZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcbmNvbnN0IEJ1ZmZlciA9IHJlcXVpcmUoJy4vYnVmZmVyLmpzJylcblxuLy8gdGFyIC1yXG5jb25zdCBobG8gPSByZXF1aXJlKCcuL2hpZ2gtbGV2ZWwtb3B0LmpzJylcbmNvbnN0IFBhY2sgPSByZXF1aXJlKCcuL3BhY2suanMnKVxuY29uc3QgUGFyc2UgPSByZXF1aXJlKCcuL3BhcnNlLmpzJylcbmNvbnN0IGZzID0gcmVxdWlyZSgnZnMnKVxuY29uc3QgZnNtID0gcmVxdWlyZSgnZnMtbWluaXBhc3MnKVxuY29uc3QgdCA9IHJlcXVpcmUoJy4vbGlzdC5qcycpXG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpXG5cbi8vIHN0YXJ0aW5nIGF0IHRoZSBoZWFkIG9mIHRoZSBmaWxlLCByZWFkIGEgSGVhZGVyXG4vLyBJZiB0aGUgY2hlY2tzdW0gaXMgaW52YWxpZCwgdGhhdCdzIG91ciBwb3NpdGlvbiB0byBzdGFydCB3cml0aW5nXG4vLyBJZiBpdCBpcywganVtcCBmb3J3YXJkIGJ5IHRoZSBzcGVjaWZpZWQgc2l6ZSAocm91bmQgdXAgdG8gNTEyKVxuLy8gYW5kIHRyeSBhZ2Fpbi5cbi8vIFdyaXRlIHRoZSBuZXcgUGFjayBzdHJlYW0gc3RhcnRpbmcgdGhlcmUuXG5cbmNvbnN0IEhlYWRlciA9IHJlcXVpcmUoJy4vaGVhZGVyLmpzJylcblxuY29uc3QgciA9IG1vZHVsZS5leHBvcnRzID0gKG9wdF8sIGZpbGVzLCBjYikgPT4ge1xuICBjb25zdCBvcHQgPSBobG8ob3B0XylcblxuICBpZiAoIW9wdC5maWxlKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ZpbGUgaXMgcmVxdWlyZWQnKVxuXG4gIGlmIChvcHQuZ3ppcClcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdjYW5ub3QgYXBwZW5kIHRvIGNvbXByZXNzZWQgYXJjaGl2ZXMnKVxuXG4gIGlmICghZmlsZXMgfHwgIUFycmF5LmlzQXJyYXkoZmlsZXMpIHx8ICFmaWxlcy5sZW5ndGgpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbm8gZmlsZXMgb3IgZGlyZWN0b3JpZXMgc3BlY2lmaWVkJylcblxuICBmaWxlcyA9IEFycmF5LmZyb20oZmlsZXMpXG5cbiAgcmV0dXJuIG9wdC5zeW5jID8gcmVwbGFjZVN5bmMob3B0LCBmaWxlcylcbiAgICA6IHJlcGxhY2Uob3B0LCBmaWxlcywgY2IpXG59XG5cbmNvbnN0IHJlcGxhY2VTeW5jID0gKG9wdCwgZmlsZXMpID0+IHtcbiAgY29uc3QgcCA9IG5ldyBQYWNrLlN5bmMob3B0KVxuXG4gIGxldCB0aHJldyA9IHRydWVcbiAgbGV0IGZkXG4gIGxldCBwb3NpdGlvblxuXG4gIHRyeSB7XG4gICAgdHJ5IHtcbiAgICAgIGZkID0gZnMub3BlblN5bmMob3B0LmZpbGUsICdyKycpXG4gICAgfSBjYXRjaCAoZXIpIHtcbiAgICAgIGlmIChlci5jb2RlID09PSAnRU5PRU5UJylcbiAgICAgICAgZmQgPSBmcy5vcGVuU3luYyhvcHQuZmlsZSwgJ3crJylcbiAgICAgIGVsc2VcbiAgICAgICAgdGhyb3cgZXJcbiAgICB9XG5cbiAgICBjb25zdCBzdCA9IGZzLmZzdGF0U3luYyhmZClcbiAgICBjb25zdCBoZWFkQnVmID0gQnVmZmVyLmFsbG9jKDUxMilcblxuICAgIFBPU0lUSU9OOiBmb3IgKHBvc2l0aW9uID0gMDsgcG9zaXRpb24gPCBzdC5zaXplOyBwb3NpdGlvbiArPSA1MTIpIHtcbiAgICAgIGZvciAobGV0IGJ1ZlBvcyA9IDAsIGJ5dGVzID0gMDsgYnVmUG9zIDwgNTEyOyBidWZQb3MgKz0gYnl0ZXMpIHtcbiAgICAgICAgYnl0ZXMgPSBmcy5yZWFkU3luYyhcbiAgICAgICAgICBmZCwgaGVhZEJ1ZiwgYnVmUG9zLCBoZWFkQnVmLmxlbmd0aCAtIGJ1ZlBvcywgcG9zaXRpb24gKyBidWZQb3NcbiAgICAgICAgKVxuXG4gICAgICAgIGlmIChwb3NpdGlvbiA9PT0gMCAmJiBoZWFkQnVmWzBdID09PSAweDFmICYmIGhlYWRCdWZbMV0gPT09IDB4OGIpXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYW5ub3QgYXBwZW5kIHRvIGNvbXByZXNzZWQgYXJjaGl2ZXMnKVxuXG4gICAgICAgIGlmICghYnl0ZXMpXG4gICAgICAgICAgYnJlYWsgUE9TSVRJT05cbiAgICAgIH1cblxuICAgICAgbGV0IGggPSBuZXcgSGVhZGVyKGhlYWRCdWYpXG4gICAgICBpZiAoIWguY2tzdW1WYWxpZClcbiAgICAgICAgYnJlYWtcbiAgICAgIGxldCBlbnRyeUJsb2NrU2l6ZSA9IDUxMiAqIE1hdGguY2VpbChoLnNpemUgLyA1MTIpXG4gICAgICBpZiAocG9zaXRpb24gKyBlbnRyeUJsb2NrU2l6ZSArIDUxMiA+IHN0LnNpemUpXG4gICAgICAgIGJyZWFrXG4gICAgICAvLyB0aGUgNTEyIGZvciB0aGUgaGVhZGVyIHdlIGp1c3QgcGFyc2VkIHdpbGwgYmUgYWRkZWQgYXMgd2VsbFxuICAgICAgLy8gYWxzbyBqdW1wIGFoZWFkIGFsbCB0aGUgYmxvY2tzIGZvciB0aGUgYm9keVxuICAgICAgcG9zaXRpb24gKz0gZW50cnlCbG9ja1NpemVcbiAgICAgIGlmIChvcHQubXRpbWVDYWNoZSlcbiAgICAgICAgb3B0Lm10aW1lQ2FjaGUuc2V0KGgucGF0aCwgaC5tdGltZSlcbiAgICB9XG4gICAgdGhyZXcgPSBmYWxzZVxuXG4gICAgc3RyZWFtU3luYyhvcHQsIHAsIHBvc2l0aW9uLCBmZCwgZmlsZXMpXG4gIH0gZmluYWxseSB7XG4gICAgaWYgKHRocmV3KVxuICAgICAgdHJ5IHsgZnMuY2xvc2VTeW5jKGZkKSB9IGNhdGNoIChlcikge31cbiAgfVxufVxuXG5jb25zdCBzdHJlYW1TeW5jID0gKG9wdCwgcCwgcG9zaXRpb24sIGZkLCBmaWxlcykgPT4ge1xuICBjb25zdCBzdHJlYW0gPSBuZXcgZnNtLldyaXRlU3RyZWFtU3luYyhvcHQuZmlsZSwge1xuICAgIGZkOiBmZCxcbiAgICBzdGFydDogcG9zaXRpb25cbiAgfSlcbiAgcC5waXBlKHN0cmVhbSlcbiAgYWRkRmlsZXNTeW5jKHAsIGZpbGVzKVxufVxuXG5jb25zdCByZXBsYWNlID0gKG9wdCwgZmlsZXMsIGNiKSA9PiB7XG4gIGZpbGVzID0gQXJyYXkuZnJvbShmaWxlcylcbiAgY29uc3QgcCA9IG5ldyBQYWNrKG9wdClcblxuICBjb25zdCBnZXRQb3MgPSAoZmQsIHNpemUsIGNiXykgPT4ge1xuICAgIGNvbnN0IGNiID0gKGVyLCBwb3MpID0+IHtcbiAgICAgIGlmIChlcilcbiAgICAgICAgZnMuY2xvc2UoZmQsIF8gPT4gY2JfKGVyKSlcbiAgICAgIGVsc2VcbiAgICAgICAgY2JfKG51bGwsIHBvcylcbiAgICB9XG5cbiAgICBsZXQgcG9zaXRpb24gPSAwXG4gICAgaWYgKHNpemUgPT09IDApXG4gICAgICByZXR1cm4gY2IobnVsbCwgMClcblxuICAgIGxldCBidWZQb3MgPSAwXG4gICAgY29uc3QgaGVhZEJ1ZiA9IEJ1ZmZlci5hbGxvYyg1MTIpXG4gICAgY29uc3Qgb25yZWFkID0gKGVyLCBieXRlcykgPT4ge1xuICAgICAgaWYgKGVyKVxuICAgICAgICByZXR1cm4gY2IoZXIpXG4gICAgICBidWZQb3MgKz0gYnl0ZXNcbiAgICAgIGlmIChidWZQb3MgPCA1MTIgJiYgYnl0ZXMpXG4gICAgICAgIHJldHVybiBmcy5yZWFkKFxuICAgICAgICAgIGZkLCBoZWFkQnVmLCBidWZQb3MsIGhlYWRCdWYubGVuZ3RoIC0gYnVmUG9zLFxuICAgICAgICAgIHBvc2l0aW9uICsgYnVmUG9zLCBvbnJlYWRcbiAgICAgICAgKVxuXG4gICAgICBpZiAocG9zaXRpb24gPT09IDAgJiYgaGVhZEJ1ZlswXSA9PT0gMHgxZiAmJiBoZWFkQnVmWzFdID09PSAweDhiKVxuICAgICAgICByZXR1cm4gY2IobmV3IEVycm9yKCdjYW5ub3QgYXBwZW5kIHRvIGNvbXByZXNzZWQgYXJjaGl2ZXMnKSlcblxuICAgICAgLy8gdHJ1bmNhdGVkIGhlYWRlclxuICAgICAgaWYgKGJ1ZlBvcyA8IDUxMilcbiAgICAgICAgcmV0dXJuIGNiKG51bGwsIHBvc2l0aW9uKVxuXG4gICAgICBjb25zdCBoID0gbmV3IEhlYWRlcihoZWFkQnVmKVxuICAgICAgaWYgKCFoLmNrc3VtVmFsaWQpXG4gICAgICAgIHJldHVybiBjYihudWxsLCBwb3NpdGlvbilcblxuICAgICAgY29uc3QgZW50cnlCbG9ja1NpemUgPSA1MTIgKiBNYXRoLmNlaWwoaC5zaXplIC8gNTEyKVxuICAgICAgaWYgKHBvc2l0aW9uICsgZW50cnlCbG9ja1NpemUgKyA1MTIgPiBzaXplKVxuICAgICAgICByZXR1cm4gY2IobnVsbCwgcG9zaXRpb24pXG5cbiAgICAgIHBvc2l0aW9uICs9IGVudHJ5QmxvY2tTaXplICsgNTEyXG4gICAgICBpZiAocG9zaXRpb24gPj0gc2l6ZSlcbiAgICAgICAgcmV0dXJuIGNiKG51bGwsIHBvc2l0aW9uKVxuXG4gICAgICBpZiAob3B0Lm10aW1lQ2FjaGUpXG4gICAgICAgIG9wdC5tdGltZUNhY2hlLnNldChoLnBhdGgsIGgubXRpbWUpXG4gICAgICBidWZQb3MgPSAwXG4gICAgICBmcy5yZWFkKGZkLCBoZWFkQnVmLCAwLCA1MTIsIHBvc2l0aW9uLCBvbnJlYWQpXG4gICAgfVxuICAgIGZzLnJlYWQoZmQsIGhlYWRCdWYsIDAsIDUxMiwgcG9zaXRpb24sIG9ucmVhZClcbiAgfVxuXG4gIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgcC5vbignZXJyb3InLCByZWplY3QpXG4gICAgbGV0IGZsYWcgPSAncisnXG4gICAgY29uc3Qgb25vcGVuID0gKGVyLCBmZCkgPT4ge1xuICAgICAgaWYgKGVyICYmIGVyLmNvZGUgPT09ICdFTk9FTlQnICYmIGZsYWcgPT09ICdyKycpIHtcbiAgICAgICAgZmxhZyA9ICd3KydcbiAgICAgICAgcmV0dXJuIGZzLm9wZW4ob3B0LmZpbGUsIGZsYWcsIG9ub3BlbilcbiAgICAgIH1cblxuICAgICAgaWYgKGVyKVxuICAgICAgICByZXR1cm4gcmVqZWN0KGVyKVxuXG4gICAgICBmcy5mc3RhdChmZCwgKGVyLCBzdCkgPT4ge1xuICAgICAgICBpZiAoZXIpXG4gICAgICAgICAgcmV0dXJuIGZzLmNsb3NlKGZkLCAoKSA9PiByZWplY3QoZXIpKVxuXG4gICAgICAgIGdldFBvcyhmZCwgc3Quc2l6ZSwgKGVyLCBwb3NpdGlvbikgPT4ge1xuICAgICAgICAgIGlmIChlcilcbiAgICAgICAgICAgIHJldHVybiByZWplY3QoZXIpXG4gICAgICAgICAgY29uc3Qgc3RyZWFtID0gbmV3IGZzbS5Xcml0ZVN0cmVhbShvcHQuZmlsZSwge1xuICAgICAgICAgICAgZmQ6IGZkLFxuICAgICAgICAgICAgc3RhcnQ6IHBvc2l0aW9uXG4gICAgICAgICAgfSlcbiAgICAgICAgICBwLnBpcGUoc3RyZWFtKVxuICAgICAgICAgIHN0cmVhbS5vbignZXJyb3InLCByZWplY3QpXG4gICAgICAgICAgc3RyZWFtLm9uKCdjbG9zZScsIHJlc29sdmUpXG4gICAgICAgICAgYWRkRmlsZXNBc3luYyhwLCBmaWxlcylcbiAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgfVxuICAgIGZzLm9wZW4ob3B0LmZpbGUsIGZsYWcsIG9ub3BlbilcbiAgfSlcblxuICByZXR1cm4gY2IgPyBwcm9taXNlLnRoZW4oY2IsIGNiKSA6IHByb21pc2Vcbn1cblxuY29uc3QgYWRkRmlsZXNTeW5jID0gKHAsIGZpbGVzKSA9PiB7XG4gIGZpbGVzLmZvckVhY2goZmlsZSA9PiB7XG4gICAgaWYgKGZpbGUuY2hhckF0KDApID09PSAnQCcpXG4gICAgICB0KHtcbiAgICAgICAgZmlsZTogcGF0aC5yZXNvbHZlKHAuY3dkLCBmaWxlLnN1YnN0cigxKSksXG4gICAgICAgIHN5bmM6IHRydWUsXG4gICAgICAgIG5vUmVzdW1lOiB0cnVlLFxuICAgICAgICBvbmVudHJ5OiBlbnRyeSA9PiBwLmFkZChlbnRyeSlcbiAgICAgIH0pXG4gICAgZWxzZVxuICAgICAgcC5hZGQoZmlsZSlcbiAgfSlcbiAgcC5lbmQoKVxufVxuXG5jb25zdCBhZGRGaWxlc0FzeW5jID0gKHAsIGZpbGVzKSA9PiB7XG4gIHdoaWxlIChmaWxlcy5sZW5ndGgpIHtcbiAgICBjb25zdCBmaWxlID0gZmlsZXMuc2hpZnQoKVxuICAgIGlmIChmaWxlLmNoYXJBdCgwKSA9PT0gJ0AnKVxuICAgICAgcmV0dXJuIHQoe1xuICAgICAgICBmaWxlOiBwYXRoLnJlc29sdmUocC5jd2QsIGZpbGUuc3Vic3RyKDEpKSxcbiAgICAgICAgbm9SZXN1bWU6IHRydWUsXG4gICAgICAgIG9uZW50cnk6IGVudHJ5ID0+IHAuYWRkKGVudHJ5KVxuICAgICAgfSkudGhlbihfID0+IGFkZEZpbGVzQXN5bmMocCwgZmlsZXMpKVxuICAgIGVsc2VcbiAgICAgIHAuYWRkKGZpbGUpXG4gIH1cbiAgcC5lbmQoKVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/tar/lib/replace.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/tar/lib/strip-absolute-path.js":
/*!*********************************************************!*\
  !*** ../../node_modules/tar/lib/strip-absolute-path.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// unix absolute paths are also absolute on win32, so we use this for both\nconst { isAbsolute, parse } = (__webpack_require__(/*! path */ \"path\").win32)\n\n// returns [root, stripped]\n// Note that windows will think that //x/y/z/a has a \"root\" of //x/y, and in\n// those cases, we want to sanitize it to x/y/z/a, not z/a, so we strip /\n// explicitly if it's the first character.\n// drive-specific relative paths on Windows get their root stripped off even\n// though they are not absolute, so `c:../foo` becomes ['c:', '../foo']\nmodule.exports = path => {\n  let r = ''\n\n  let parsed = parse(path)\n  while (isAbsolute(path) || parsed.root) {\n    // windows will think that //x/y/z has a \"root\" of //x/y/\n    // but strip the //?/C:/ off of //?/C:/path\n    const root = path.charAt(0) === '/' && path.slice(0, 4) !== '//?/' ? '/'\n      : parsed.root\n    path = path.substr(root.length)\n    r += root\n    parsed = parse(path)\n  }\n  return [r, path]\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL3Rhci9saWIvc3RyaXAtYWJzb2x1dGUtcGF0aC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLFFBQVEsb0JBQW9CLEVBQUUsK0NBQXFCOztBQUVuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvYmFyYi9hYS9Bc3NvY2lhdGVkQWNjb3VudHMvbm9kZV9tb2R1bGVzL3Rhci9saWIvc3RyaXAtYWJzb2x1dGUtcGF0aC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyB1bml4IGFic29sdXRlIHBhdGhzIGFyZSBhbHNvIGFic29sdXRlIG9uIHdpbjMyLCBzbyB3ZSB1c2UgdGhpcyBmb3IgYm90aFxuY29uc3QgeyBpc0Fic29sdXRlLCBwYXJzZSB9ID0gcmVxdWlyZSgncGF0aCcpLndpbjMyXG5cbi8vIHJldHVybnMgW3Jvb3QsIHN0cmlwcGVkXVxuLy8gTm90ZSB0aGF0IHdpbmRvd3Mgd2lsbCB0aGluayB0aGF0IC8veC95L3ovYSBoYXMgYSBcInJvb3RcIiBvZiAvL3gveSwgYW5kIGluXG4vLyB0aG9zZSBjYXNlcywgd2Ugd2FudCB0byBzYW5pdGl6ZSBpdCB0byB4L3kvei9hLCBub3Qgei9hLCBzbyB3ZSBzdHJpcCAvXG4vLyBleHBsaWNpdGx5IGlmIGl0J3MgdGhlIGZpcnN0IGNoYXJhY3Rlci5cbi8vIGRyaXZlLXNwZWNpZmljIHJlbGF0aXZlIHBhdGhzIG9uIFdpbmRvd3MgZ2V0IHRoZWlyIHJvb3Qgc3RyaXBwZWQgb2ZmIGV2ZW5cbi8vIHRob3VnaCB0aGV5IGFyZSBub3QgYWJzb2x1dGUsIHNvIGBjOi4uL2Zvb2AgYmVjb21lcyBbJ2M6JywgJy4uL2ZvbyddXG5tb2R1bGUuZXhwb3J0cyA9IHBhdGggPT4ge1xuICBsZXQgciA9ICcnXG5cbiAgbGV0IHBhcnNlZCA9IHBhcnNlKHBhdGgpXG4gIHdoaWxlIChpc0Fic29sdXRlKHBhdGgpIHx8IHBhcnNlZC5yb290KSB7XG4gICAgLy8gd2luZG93cyB3aWxsIHRoaW5rIHRoYXQgLy94L3kveiBoYXMgYSBcInJvb3RcIiBvZiAvL3gveS9cbiAgICAvLyBidXQgc3RyaXAgdGhlIC8vPy9DOi8gb2ZmIG9mIC8vPy9DOi9wYXRoXG4gICAgY29uc3Qgcm9vdCA9IHBhdGguY2hhckF0KDApID09PSAnLycgJiYgcGF0aC5zbGljZSgwLCA0KSAhPT0gJy8vPy8nID8gJy8nXG4gICAgICA6IHBhcnNlZC5yb290XG4gICAgcGF0aCA9IHBhdGguc3Vic3RyKHJvb3QubGVuZ3RoKVxuICAgIHIgKz0gcm9vdFxuICAgIHBhcnNlZCA9IHBhcnNlKHBhdGgpXG4gIH1cbiAgcmV0dXJuIFtyLCBwYXRoXVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/tar/lib/strip-absolute-path.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/tar/lib/strip-trailing-slashes.js":
/*!************************************************************!*\
  !*** ../../node_modules/tar/lib/strip-trailing-slashes.js ***!
  \************************************************************/
/***/ ((module) => {

eval("// this is the only approach that was significantly faster than using\n// str.replace(/\\/+$/, '') for strings ending with a lot of / chars and\n// containing multiple / chars.\nconst batchStrings = [\n  '/'.repeat(1024),\n  '/'.repeat(512),\n  '/'.repeat(256),\n  '/'.repeat(128),\n  '/'.repeat(64),\n  '/'.repeat(32),\n  '/'.repeat(16),\n  '/'.repeat(8),\n  '/'.repeat(4),\n  '/'.repeat(2),\n  '/',\n]\n\nmodule.exports = str => {\n  for (const s of batchStrings) {\n    while (str.length >= s.length && str.slice(-1 * s.length) === s)\n      str = str.slice(0, -1 * s.length)\n  }\n  return str\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL3Rhci9saWIvc3RyaXAtdHJhaWxpbmctc2xhc2hlcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvYmFyYi9hYS9Bc3NvY2lhdGVkQWNjb3VudHMvbm9kZV9tb2R1bGVzL3Rhci9saWIvc3RyaXAtdHJhaWxpbmctc2xhc2hlcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyB0aGlzIGlzIHRoZSBvbmx5IGFwcHJvYWNoIHRoYXQgd2FzIHNpZ25pZmljYW50bHkgZmFzdGVyIHRoYW4gdXNpbmdcbi8vIHN0ci5yZXBsYWNlKC9cXC8rJC8sICcnKSBmb3Igc3RyaW5ncyBlbmRpbmcgd2l0aCBhIGxvdCBvZiAvIGNoYXJzIGFuZFxuLy8gY29udGFpbmluZyBtdWx0aXBsZSAvIGNoYXJzLlxuY29uc3QgYmF0Y2hTdHJpbmdzID0gW1xuICAnLycucmVwZWF0KDEwMjQpLFxuICAnLycucmVwZWF0KDUxMiksXG4gICcvJy5yZXBlYXQoMjU2KSxcbiAgJy8nLnJlcGVhdCgxMjgpLFxuICAnLycucmVwZWF0KDY0KSxcbiAgJy8nLnJlcGVhdCgzMiksXG4gICcvJy5yZXBlYXQoMTYpLFxuICAnLycucmVwZWF0KDgpLFxuICAnLycucmVwZWF0KDQpLFxuICAnLycucmVwZWF0KDIpLFxuICAnLycsXG5dXG5cbm1vZHVsZS5leHBvcnRzID0gc3RyID0+IHtcbiAgZm9yIChjb25zdCBzIG9mIGJhdGNoU3RyaW5ncykge1xuICAgIHdoaWxlIChzdHIubGVuZ3RoID49IHMubGVuZ3RoICYmIHN0ci5zbGljZSgtMSAqIHMubGVuZ3RoKSA9PT0gcylcbiAgICAgIHN0ciA9IHN0ci5zbGljZSgwLCAtMSAqIHMubGVuZ3RoKVxuICB9XG4gIHJldHVybiBzdHJcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/tar/lib/strip-trailing-slashes.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/tar/lib/types.js":
/*!*******************************************!*\
  !*** ../../node_modules/tar/lib/types.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n// map types from key to human-friendly name\nexports.name = new Map([\n  ['0', 'File'],\n  // same as File\n  ['', 'OldFile'],\n  ['1', 'Link'],\n  ['2', 'SymbolicLink'],\n  // Devices and FIFOs aren't fully supported\n  // they are parsed, but skipped when unpacking\n  ['3', 'CharacterDevice'],\n  ['4', 'BlockDevice'],\n  ['5', 'Directory'],\n  ['6', 'FIFO'],\n  // same as File\n  ['7', 'ContiguousFile'],\n  // pax headers\n  ['g', 'GlobalExtendedHeader'],\n  ['x', 'ExtendedHeader'],\n  // vendor-specific stuff\n  // skip\n  ['A', 'SolarisACL'],\n  // like 5, but with data, which should be skipped\n  ['D', 'GNUDumpDir'],\n  // metadata only, skip\n  ['I', 'Inode'],\n  // data = link path of next file\n  ['K', 'NextFileHasLongLinkpath'],\n  // data = path of next file\n  ['L', 'NextFileHasLongPath'],\n  // skip\n  ['M', 'ContinuationFile'],\n  // like L\n  ['N', 'OldGnuLongPath'],\n  // skip\n  ['S', 'SparseFile'],\n  // skip\n  ['V', 'TapeVolumeHeader'],\n  // like x\n  ['X', 'OldExtendedHeader']\n])\n\n// map the other direction\nexports.code = new Map(Array.from(exports.name).map(kv => [kv[1], kv[0]]))\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL3Rhci9saWIvdHlwZXMuanMiLCJtYXBwaW5ncyI6IkFBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSIsInNvdXJjZXMiOlsiL2hvbWUvYmFyYi9hYS9Bc3NvY2lhdGVkQWNjb3VudHMvbm9kZV9tb2R1bGVzL3Rhci9saWIvdHlwZXMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG4vLyBtYXAgdHlwZXMgZnJvbSBrZXkgdG8gaHVtYW4tZnJpZW5kbHkgbmFtZVxuZXhwb3J0cy5uYW1lID0gbmV3IE1hcChbXG4gIFsnMCcsICdGaWxlJ10sXG4gIC8vIHNhbWUgYXMgRmlsZVxuICBbJycsICdPbGRGaWxlJ10sXG4gIFsnMScsICdMaW5rJ10sXG4gIFsnMicsICdTeW1ib2xpY0xpbmsnXSxcbiAgLy8gRGV2aWNlcyBhbmQgRklGT3MgYXJlbid0IGZ1bGx5IHN1cHBvcnRlZFxuICAvLyB0aGV5IGFyZSBwYXJzZWQsIGJ1dCBza2lwcGVkIHdoZW4gdW5wYWNraW5nXG4gIFsnMycsICdDaGFyYWN0ZXJEZXZpY2UnXSxcbiAgWyc0JywgJ0Jsb2NrRGV2aWNlJ10sXG4gIFsnNScsICdEaXJlY3RvcnknXSxcbiAgWyc2JywgJ0ZJRk8nXSxcbiAgLy8gc2FtZSBhcyBGaWxlXG4gIFsnNycsICdDb250aWd1b3VzRmlsZSddLFxuICAvLyBwYXggaGVhZGVyc1xuICBbJ2cnLCAnR2xvYmFsRXh0ZW5kZWRIZWFkZXInXSxcbiAgWyd4JywgJ0V4dGVuZGVkSGVhZGVyJ10sXG4gIC8vIHZlbmRvci1zcGVjaWZpYyBzdHVmZlxuICAvLyBza2lwXG4gIFsnQScsICdTb2xhcmlzQUNMJ10sXG4gIC8vIGxpa2UgNSwgYnV0IHdpdGggZGF0YSwgd2hpY2ggc2hvdWxkIGJlIHNraXBwZWRcbiAgWydEJywgJ0dOVUR1bXBEaXInXSxcbiAgLy8gbWV0YWRhdGEgb25seSwgc2tpcFxuICBbJ0knLCAnSW5vZGUnXSxcbiAgLy8gZGF0YSA9IGxpbmsgcGF0aCBvZiBuZXh0IGZpbGVcbiAgWydLJywgJ05leHRGaWxlSGFzTG9uZ0xpbmtwYXRoJ10sXG4gIC8vIGRhdGEgPSBwYXRoIG9mIG5leHQgZmlsZVxuICBbJ0wnLCAnTmV4dEZpbGVIYXNMb25nUGF0aCddLFxuICAvLyBza2lwXG4gIFsnTScsICdDb250aW51YXRpb25GaWxlJ10sXG4gIC8vIGxpa2UgTFxuICBbJ04nLCAnT2xkR251TG9uZ1BhdGgnXSxcbiAgLy8gc2tpcFxuICBbJ1MnLCAnU3BhcnNlRmlsZSddLFxuICAvLyBza2lwXG4gIFsnVicsICdUYXBlVm9sdW1lSGVhZGVyJ10sXG4gIC8vIGxpa2UgeFxuICBbJ1gnLCAnT2xkRXh0ZW5kZWRIZWFkZXInXVxuXSlcblxuLy8gbWFwIHRoZSBvdGhlciBkaXJlY3Rpb25cbmV4cG9ydHMuY29kZSA9IG5ldyBNYXAoQXJyYXkuZnJvbShleHBvcnRzLm5hbWUpLm1hcChrdiA9PiBba3ZbMV0sIGt2WzBdXSkpXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/tar/lib/types.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/tar/lib/unpack.js":
/*!********************************************!*\
  !*** ../../node_modules/tar/lib/unpack.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n// the PEND/UNPEND stuff tracks whether we're ready to emit end/close yet.\n// but the path reservations are required to avoid race conditions where\n// parallelized unpack ops may mess with one another, due to dependencies\n// (like a Link depending on its target) or destructive operations (like\n// clobbering an fs object to create one of a different type.)\n\nconst assert = __webpack_require__(/*! assert */ \"assert\")\nconst EE = (__webpack_require__(/*! events */ \"events\").EventEmitter)\nconst Parser = __webpack_require__(/*! ./parse.js */ \"(rsc)/../../node_modules/tar/lib/parse.js\")\nconst fs = __webpack_require__(/*! fs */ \"fs\")\nconst fsm = __webpack_require__(/*! fs-minipass */ \"(rsc)/../../node_modules/fs-minipass/index.js\")\nconst path = __webpack_require__(/*! path */ \"path\")\nconst mkdir = __webpack_require__(/*! ./mkdir.js */ \"(rsc)/../../node_modules/tar/lib/mkdir.js\")\nconst mkdirSync = mkdir.sync\nconst wc = __webpack_require__(/*! ./winchars.js */ \"(rsc)/../../node_modules/tar/lib/winchars.js\")\nconst stripAbsolutePath = __webpack_require__(/*! ./strip-absolute-path.js */ \"(rsc)/../../node_modules/tar/lib/strip-absolute-path.js\")\nconst pathReservations = __webpack_require__(/*! ./path-reservations.js */ \"(rsc)/../../node_modules/tar/lib/path-reservations.js\")\nconst normPath = __webpack_require__(/*! ./normalize-windows-path.js */ \"(rsc)/../../node_modules/tar/lib/normalize-windows-path.js\")\nconst stripSlash = __webpack_require__(/*! ./strip-trailing-slashes.js */ \"(rsc)/../../node_modules/tar/lib/strip-trailing-slashes.js\")\n\nconst ONENTRY = Symbol('onEntry')\nconst CHECKFS = Symbol('checkFs')\nconst CHECKFS2 = Symbol('checkFs2')\nconst PRUNECACHE = Symbol('pruneCache')\nconst ISREUSABLE = Symbol('isReusable')\nconst MAKEFS = Symbol('makeFs')\nconst FILE = Symbol('file')\nconst DIRECTORY = Symbol('directory')\nconst LINK = Symbol('link')\nconst SYMLINK = Symbol('symlink')\nconst HARDLINK = Symbol('hardlink')\nconst UNSUPPORTED = Symbol('unsupported')\nconst UNKNOWN = Symbol('unknown')\nconst CHECKPATH = Symbol('checkPath')\nconst MKDIR = Symbol('mkdir')\nconst ONERROR = Symbol('onError')\nconst PENDING = Symbol('pending')\nconst PEND = Symbol('pend')\nconst UNPEND = Symbol('unpend')\nconst ENDED = Symbol('ended')\nconst MAYBECLOSE = Symbol('maybeClose')\nconst SKIP = Symbol('skip')\nconst DOCHOWN = Symbol('doChown')\nconst UID = Symbol('uid')\nconst GID = Symbol('gid')\nconst CHECKED_CWD = Symbol('checkedCwd')\nconst crypto = __webpack_require__(/*! crypto */ \"crypto\")\nconst platform = process.env.TESTING_TAR_FAKE_PLATFORM || process.platform\nconst isWindows = platform === 'win32'\n\n// Unlinks on Windows are not atomic.\n//\n// This means that if you have a file entry, followed by another\n// file entry with an identical name, and you cannot re-use the file\n// (because it's a hardlink, or because unlink:true is set, or it's\n// Windows, which does not have useful nlink values), then the unlink\n// will be committed to the disk AFTER the new file has been written\n// over the old one, deleting the new file.\n//\n// To work around this, on Windows systems, we rename the file and then\n// delete the renamed file.  It's a sloppy kludge, but frankly, I do not\n// know of a better way to do this, given windows' non-atomic unlink\n// semantics.\n//\n// See: https://github.com/npm/node-tar/issues/183\n/* istanbul ignore next */\nconst unlinkFile = (path, cb) => {\n  if (!isWindows)\n    return fs.unlink(path, cb)\n\n  const name = path + '.DELETE.' + crypto.randomBytes(16).toString('hex')\n  fs.rename(path, name, er => {\n    if (er)\n      return cb(er)\n    fs.unlink(name, cb)\n  })\n}\n\n/* istanbul ignore next */\nconst unlinkFileSync = path => {\n  if (!isWindows)\n    return fs.unlinkSync(path)\n\n  const name = path + '.DELETE.' + crypto.randomBytes(16).toString('hex')\n  fs.renameSync(path, name)\n  fs.unlinkSync(name)\n}\n\n// this.gid, entry.gid, this.processUid\nconst uint32 = (a, b, c) =>\n  a === a >>> 0 ? a\n  : b === b >>> 0 ? b\n  : c\n\n// clear the cache if it's a case-insensitive unicode-squashing match.\n// we can't know if the current file system is case-sensitive or supports\n// unicode fully, so we check for similarity on the maximally compatible\n// representation.  Err on the side of pruning, since all it's doing is\n// preventing lstats, and it's not the end of the world if we get a false\n// positive.\n// Note that on windows, we always drop the entire cache whenever a\n// symbolic link is encountered, because 8.3 filenames are impossible\n// to reason about, and collisions are hazards rather than just failures.\nconst cacheKeyNormalize = path => stripSlash(normPath(path))\n  .normalize('NFKD')\n  .toLowerCase()\n\nconst pruneCache = (cache, abs) => {\n  abs = cacheKeyNormalize(abs)\n  for (const path of cache.keys()) {\n    const pnorm = cacheKeyNormalize(path)\n    if (pnorm === abs || pnorm.indexOf(abs + '/') === 0)\n      cache.delete(path)\n  }\n}\n\nconst dropCache = cache => {\n  for (const key of cache.keys())\n    cache.delete(key)\n}\n\nclass Unpack extends Parser {\n  constructor (opt) {\n    if (!opt)\n      opt = {}\n\n    opt.ondone = _ => {\n      this[ENDED] = true\n      this[MAYBECLOSE]()\n    }\n\n    super(opt)\n\n    this[CHECKED_CWD] = false\n\n    this.reservations = pathReservations()\n\n    this.transform = typeof opt.transform === 'function' ? opt.transform : null\n\n    this.writable = true\n    this.readable = false\n\n    this[PENDING] = 0\n    this[ENDED] = false\n\n    this.dirCache = opt.dirCache || new Map()\n\n    if (typeof opt.uid === 'number' || typeof opt.gid === 'number') {\n      // need both or neither\n      if (typeof opt.uid !== 'number' || typeof opt.gid !== 'number')\n        throw new TypeError('cannot set owner without number uid and gid')\n      if (opt.preserveOwner)\n        throw new TypeError(\n          'cannot preserve owner in archive and also set owner explicitly')\n      this.uid = opt.uid\n      this.gid = opt.gid\n      this.setOwner = true\n    } else {\n      this.uid = null\n      this.gid = null\n      this.setOwner = false\n    }\n\n    // default true for root\n    if (opt.preserveOwner === undefined && typeof opt.uid !== 'number')\n      this.preserveOwner = process.getuid && process.getuid() === 0\n    else\n      this.preserveOwner = !!opt.preserveOwner\n\n    this.processUid = (this.preserveOwner || this.setOwner) && process.getuid ?\n      process.getuid() : null\n    this.processGid = (this.preserveOwner || this.setOwner) && process.getgid ?\n      process.getgid() : null\n\n    // mostly just for testing, but useful in some cases.\n    // Forcibly trigger a chown on every entry, no matter what\n    this.forceChown = opt.forceChown === true\n\n    // turn ><?| in filenames into 0xf000-higher encoded forms\n    this.win32 = !!opt.win32 || isWindows\n\n    // do not unpack over files that are newer than what's in the archive\n    this.newer = !!opt.newer\n\n    // do not unpack over ANY files\n    this.keep = !!opt.keep\n\n    // do not set mtime/atime of extracted entries\n    this.noMtime = !!opt.noMtime\n\n    // allow .., absolute path entries, and unpacking through symlinks\n    // without this, warn and skip .., relativize absolutes, and error\n    // on symlinks in extraction path\n    this.preservePaths = !!opt.preservePaths\n\n    // unlink files and links before writing. This breaks existing hard\n    // links, and removes symlink directories rather than erroring\n    this.unlink = !!opt.unlink\n\n    this.cwd = normPath(path.resolve(opt.cwd || process.cwd()))\n    this.strip = +opt.strip || 0\n    this.processUmask = process.umask()\n    this.umask = typeof opt.umask === 'number' ? opt.umask : this.processUmask\n    // default mode for dirs created as parents\n    this.dmode = opt.dmode || (0o0777 & (~this.umask))\n    this.fmode = opt.fmode || (0o0666 & (~this.umask))\n    this.on('entry', entry => this[ONENTRY](entry))\n  }\n\n  [MAYBECLOSE] () {\n    if (this[ENDED] && this[PENDING] === 0) {\n      this.emit('prefinish')\n      this.emit('finish')\n      this.emit('end')\n      this.emit('close')\n    }\n  }\n\n  [CHECKPATH] (entry) {\n    if (this.strip) {\n      const parts = normPath(entry.path).split('/')\n      if (parts.length < this.strip)\n        return false\n      entry.path = parts.slice(this.strip).join('/')\n\n      if (entry.type === 'Link') {\n        const linkparts = normPath(entry.linkpath).split('/')\n        if (linkparts.length >= this.strip)\n          entry.linkpath = linkparts.slice(this.strip).join('/')\n        else\n          return false\n      }\n    }\n\n    if (!this.preservePaths) {\n      const p = normPath(entry.path)\n      const parts = p.split('/')\n      if (parts.includes('..') || isWindows && /^[a-z]:\\.\\.$/i.test(parts[0])) {\n        this.warn(`path contains '..'`, p)\n        return false\n      }\n\n      // strip off the root\n      const s = stripAbsolutePath(p)\n      if (s[0]) {\n        entry.path = s[1]\n        this.warn(`stripping ${s[0]} from absolute path`, p)\n      }\n    }\n\n    if (path.isAbsolute(entry.path))\n      entry.absolute = normPath(path.resolve(entry.path))\n    else\n      entry.absolute = normPath(path.resolve(this.cwd, entry.path))\n\n    // if we somehow ended up with a path that escapes the cwd, and we are\n    // not in preservePaths mode, then something is fishy!  This should have\n    // been prevented above, so ignore this for coverage.\n    /* istanbul ignore if - defense in depth */\n    if (!this.preservePaths &&\n        entry.absolute.indexOf(this.cwd + '/') !== 0 &&\n        entry.absolute !== this.cwd) {\n      this.warn('TAR_ENTRY_ERROR', 'path escaped extraction target', {\n        entry,\n        path: normPath(entry.path),\n        resolvedPath: entry.absolute,\n        cwd: this.cwd,\n      })\n      return false\n    }\n\n    // an archive can set properties on the extraction directory, but it\n    // may not replace the cwd with a different kind of thing entirely.\n    if (entry.absolute === this.cwd &&\n        entry.type !== 'Directory' &&\n        entry.type !== 'GNUDumpDir')\n      return false\n\n    // only encode : chars that aren't drive letter indicators\n    if (this.win32) {\n      const { root: aRoot } = path.win32.parse(entry.absolute)\n      entry.absolute = aRoot + wc.encode(entry.absolute.substr(aRoot.length))\n      const { root: pRoot } = path.win32.parse(entry.path)\n      entry.path = pRoot + wc.encode(entry.path.substr(pRoot.length))\n    }\n\n    return true\n  }\n\n  [ONENTRY] (entry) {\n    if (!this[CHECKPATH](entry))\n      return entry.resume()\n\n    assert.equal(typeof entry.absolute, 'string')\n\n    switch (entry.type) {\n      case 'Directory':\n      case 'GNUDumpDir':\n        if (entry.mode)\n          entry.mode = entry.mode | 0o700\n\n      case 'File':\n      case 'OldFile':\n      case 'ContiguousFile':\n      case 'Link':\n      case 'SymbolicLink':\n        return this[CHECKFS](entry)\n\n      case 'CharacterDevice':\n      case 'BlockDevice':\n      case 'FIFO':\n        return this[UNSUPPORTED](entry)\n    }\n  }\n\n  [ONERROR] (er, entry) {\n    // Cwd has to exist, or else nothing works. That's serious.\n    // Other errors are warnings, which raise the error in strict\n    // mode, but otherwise continue on.\n    if (er.name === 'CwdError')\n      this.emit('error', er)\n    else {\n      this.warn(er.message, er)\n      this[UNPEND]()\n      entry.resume()\n    }\n  }\n\n  [MKDIR] (dir, mode, cb) {\n    mkdir(normPath(dir), {\n      uid: this.uid,\n      gid: this.gid,\n      processUid: this.processUid,\n      processGid: this.processGid,\n      umask: this.processUmask,\n      preserve: this.preservePaths,\n      unlink: this.unlink,\n      cache: this.dirCache,\n      cwd: this.cwd,\n      mode: mode\n    }, cb)\n  }\n\n  [DOCHOWN] (entry) {\n    // in preserve owner mode, chown if the entry doesn't match process\n    // in set owner mode, chown if setting doesn't match process\n    return this.forceChown ||\n      this.preserveOwner &&\n      ( typeof entry.uid === 'number' && entry.uid !== this.processUid ||\n        typeof entry.gid === 'number' && entry.gid !== this.processGid )\n      ||\n      ( typeof this.uid === 'number' && this.uid !== this.processUid ||\n        typeof this.gid === 'number' && this.gid !== this.processGid )\n  }\n\n  [UID] (entry) {\n    return uint32(this.uid, entry.uid, this.processUid)\n  }\n\n  [GID] (entry) {\n    return uint32(this.gid, entry.gid, this.processGid)\n  }\n\n  [FILE] (entry, fullyDone) {\n    const mode = entry.mode & 0o7777 || this.fmode\n    const stream = new fsm.WriteStream(entry.absolute, {\n      mode: mode,\n      autoClose: false\n    })\n    stream.on('error', er => {\n      if (stream.fd)\n        fs.close(stream.fd, () => {})\n\n      // flush all the data out so that we aren't left hanging\n      // if the error wasn't actually fatal.  otherwise the parse\n      // is blocked, and we never proceed.\n      /* istanbul ignore next */\n      stream.write = () => true\n      this[ONERROR](er, entry)\n      fullyDone()\n    })\n\n    let actions = 1\n    const done = er => {\n      if (er) {\n        /* istanbul ignore else - we should always have a fd by now */\n        if (stream.fd)\n          fs.close(stream.fd, () => {})\n\n        this[ONERROR](er, entry)\n        fullyDone()\n        return\n      }\n\n      if (--actions === 0) {\n        fs.close(stream.fd, er => {\n          fullyDone()\n          /* istanbul ignore next */\n          er ? this[ONERROR](er, entry) : this[UNPEND]()\n        })\n      }\n    }\n\n    stream.on('finish', _ => {\n      // if futimes fails, try utimes\n      // if utimes fails, fail with the original error\n      // same for fchown/chown\n      const abs = entry.absolute\n      const fd = stream.fd\n\n      if (entry.mtime && !this.noMtime) {\n        actions++\n        const atime = entry.atime || new Date()\n        const mtime = entry.mtime\n        fs.futimes(fd, atime, mtime, er =>\n          er ? fs.utimes(abs, atime, mtime, er2 => done(er2 && er))\n          : done())\n      }\n\n      if (this[DOCHOWN](entry)) {\n        actions++\n        const uid = this[UID](entry)\n        const gid = this[GID](entry)\n        fs.fchown(fd, uid, gid, er =>\n          er ? fs.chown(abs, uid, gid, er2 => done(er2 && er))\n          : done())\n      }\n\n      done()\n    })\n\n    const tx = this.transform ? this.transform(entry) || entry : entry\n    if (tx !== entry) {\n      tx.on('error', er => this[ONERROR](er, entry))\n      entry.pipe(tx)\n    }\n    tx.pipe(stream)\n  }\n\n  [DIRECTORY] (entry, fullyDone) {\n    const mode = entry.mode & 0o7777 || this.dmode\n    this[MKDIR](entry.absolute, mode, er => {\n      if (er) {\n        fullyDone()\n        return this[ONERROR](er, entry)\n      }\n\n      let actions = 1\n      const done = _ => {\n        if (--actions === 0) {\n          fullyDone()\n          this[UNPEND]()\n          entry.resume()\n        }\n      }\n\n      if (entry.mtime && !this.noMtime) {\n        actions++\n        fs.utimes(entry.absolute, entry.atime || new Date(), entry.mtime, done)\n      }\n\n      if (this[DOCHOWN](entry)) {\n        actions++\n        fs.chown(entry.absolute, this[UID](entry), this[GID](entry), done)\n      }\n\n      done()\n    })\n  }\n\n  [UNSUPPORTED] (entry) {\n    this.warn('unsupported entry type: ' + entry.type, entry)\n    entry.resume()\n  }\n\n  [SYMLINK] (entry, done) {\n    this[LINK](entry, entry.linkpath, 'symlink', done)\n  }\n\n  [HARDLINK] (entry, done) {\n    const linkpath = normPath(path.resolve(this.cwd, entry.linkpath))\n    this[LINK](entry, linkpath, 'link', done)\n  }\n\n  [PEND] () {\n    this[PENDING]++\n  }\n\n  [UNPEND] () {\n    this[PENDING]--\n    this[MAYBECLOSE]()\n  }\n\n  [SKIP] (entry) {\n    this[UNPEND]()\n    entry.resume()\n  }\n\n  // Check if we can reuse an existing filesystem entry safely and\n  // overwrite it, rather than unlinking and recreating\n  // Windows doesn't report a useful nlink, so we just never reuse entries\n  [ISREUSABLE] (entry, st) {\n    return entry.type === 'File' &&\n      !this.unlink &&\n      st.isFile() &&\n      st.nlink <= 1 &&\n      !isWindows\n  }\n\n  // check if a thing is there, and if so, try to clobber it\n  [CHECKFS] (entry) {\n    this[PEND]()\n    const paths = [entry.path]\n    if (entry.linkpath)\n      paths.push(entry.linkpath)\n    this.reservations.reserve(paths, done => this[CHECKFS2](entry, done))\n  }\n\n  [PRUNECACHE] (entry) {\n    // if we are not creating a directory, and the path is in the dirCache,\n    // then that means we are about to delete the directory we created\n    // previously, and it is no longer going to be a directory, and neither\n    // is any of its children.\n    // If a symbolic link is encountered, all bets are off.  There is no\n    // reasonable way to sanitize the cache in such a way we will be able to\n    // avoid having filesystem collisions.  If this happens with a non-symlink\n    // entry, it'll just fail to unpack, but a symlink to a directory, using an\n    // 8.3 shortname or certain unicode attacks, can evade detection and lead\n    // to arbitrary writes to anywhere on the system.\n    if (entry.type === 'SymbolicLink')\n      dropCache(this.dirCache)\n    else if (entry.type !== 'Directory')\n      pruneCache(this.dirCache, entry.absolute)\n  }\n\n  [CHECKFS2] (entry, fullyDone) {\n    this[PRUNECACHE](entry)\n\n    const done = er => {\n      this[PRUNECACHE](entry)\n      fullyDone(er)\n    }\n\n    const checkCwd = () => {\n      this[MKDIR](this.cwd, this.dmode, er => {\n        if (er) {\n          this[ONERROR](er, entry)\n          done()\n          return\n        }\n        this[CHECKED_CWD] = true\n        start()\n      })\n    }\n\n    const start = () => {\n      if (entry.absolute !== this.cwd) {\n        const parent = normPath(path.dirname(entry.absolute))\n        if (parent !== this.cwd) {\n          return this[MKDIR](parent, this.dmode, er => {\n            if (er) {\n              this[ONERROR](er, entry)\n              done()\n              return\n            }\n            afterMakeParent()\n          })\n        }\n      }\n      afterMakeParent()\n    }\n\n    const afterMakeParent = () => {\n      fs.lstat(entry.absolute, (lstatEr, st) => {\n        if (st && (this.keep || this.newer && st.mtime > entry.mtime)) {\n          this[SKIP](entry)\n          done()\n          return\n        }\n        if (lstatEr || this[ISREUSABLE](entry, st))\n          return this[MAKEFS](null, entry, done)\n\n        if (st.isDirectory()) {\n          if (entry.type === 'Directory') {\n            const needChmod = !this.noChmod &&\n              entry.mode &&\n              (st.mode & 0o7777) !== entry.mode\n            const afterChmod = er => this[MAKEFS](er, entry, done)\n            if (!needChmod)\n              return afterChmod()\n            return fs.chmod(entry.absolute, entry.mode, afterChmod)\n          }\n          // Not a dir entry, have to remove it.\n          // NB: the only way to end up with an entry that is the cwd\n          // itself, in such a way that == does not detect, is a\n          // tricky windows absolute path with UNC or 8.3 parts (and\n          // preservePaths:true, or else it will have been stripped).\n          // In that case, the user has opted out of path protections\n          // explicitly, so if they blow away the cwd, c'est la vie.\n          if (entry.absolute !== this.cwd) {\n            return fs.rmdir(entry.absolute, er =>\n              this[MAKEFS](er, entry, done))\n          }\n        }\n\n        // not a dir, and not reusable\n        // don't remove if the cwd, we want that error\n        if (entry.absolute === this.cwd)\n          return this[MAKEFS](null, entry, done)\n\n        unlinkFile(entry.absolute, er =>\n          this[MAKEFS](er, entry, done))\n      })\n    }\n\n    if (this[CHECKED_CWD])\n      start()\n    else\n      checkCwd()\n  }\n\n  [MAKEFS] (er, entry, done) {\n    if (er)\n      return this[ONERROR](er, entry)\n\n    switch (entry.type) {\n      case 'File':\n      case 'OldFile':\n      case 'ContiguousFile':\n        return this[FILE](entry, done)\n\n      case 'Link':\n        return this[HARDLINK](entry, done)\n\n      case 'SymbolicLink':\n        return this[SYMLINK](entry, done)\n\n      case 'Directory':\n      case 'GNUDumpDir':\n        return this[DIRECTORY](entry, done)\n    }\n  }\n\n  [LINK] (entry, linkpath, link, done) {\n    // XXX: get the type ('symlink' or 'junction') for windows\n    fs[link](linkpath, entry.absolute, er => {\n      if (er)\n        return this[ONERROR](er, entry)\n      done()\n      this[UNPEND]()\n      entry.resume()\n    })\n  }\n}\n\nconst callSync = fn => {\n  try {\n    return [null, fn()]\n  } catch (er) {\n    return [er, null]\n  }\n}\nclass UnpackSync extends Unpack {\n  [MAKEFS] (er, entry) {\n    return super[MAKEFS](er, entry, /* istanbul ignore next */ () => {})\n  }\n\n  [CHECKFS] (entry) {\n    this[PRUNECACHE](entry)\n\n    if (!this[CHECKED_CWD]) {\n      const er = this[MKDIR](this.cwd, this.dmode)\n      if (er)\n        return this[ONERROR](er, entry)\n      this[CHECKED_CWD] = true\n    }\n\n    // don't bother to make the parent if the current entry is the cwd,\n    // we've already checked it.\n    if (entry.absolute !== this.cwd) {\n      const parent = normPath(path.dirname(entry.absolute))\n      if (parent !== this.cwd) {\n        const mkParent = this[MKDIR](parent, this.dmode)\n        if (mkParent)\n          return this[ONERROR](mkParent, entry)\n      }\n    }\n\n    const [lstatEr, st] = callSync(() => fs.lstatSync(entry.absolute))\n    if (st && (this.keep || this.newer && st.mtime > entry.mtime))\n      return this[SKIP](entry)\n\n    if (lstatEr || this[ISREUSABLE](entry, st))\n      return this[MAKEFS](null, entry)\n\n    if (st.isDirectory()) {\n      if (entry.type === 'Directory') {\n        const needChmod = !this.noChmod &&\n          entry.mode &&\n          (st.mode & 0o7777) !== entry.mode\n        const [er] = needChmod ? callSync(() => {\n          fs.chmodSync(entry.absolute, entry.mode)\n        }) : []\n        return this[MAKEFS](er, entry)\n      }\n      // not a dir entry, have to remove it\n      const [er] = callSync(() => fs.rmdirSync(entry.absolute))\n      this[MAKEFS](er, entry)\n    }\n\n    // not a dir, and not reusable.\n    // don't remove if it's the cwd, since we want that error.\n    const [er] = entry.absolute === this.cwd ? []\n      : callSync(() => unlinkFileSync(entry.absolute))\n    this[MAKEFS](er, entry)\n  }\n\n  [FILE] (entry, done) {\n    const mode = entry.mode & 0o7777 || this.fmode\n\n    const oner = er => {\n      let closeError\n      try {\n        fs.closeSync(fd)\n      } catch (e) {\n        closeError = e\n      }\n      if (er || closeError)\n        this[ONERROR](er || closeError, entry)\n      done()\n    }\n\n    let stream\n    let fd\n    try {\n      fd = fs.openSync(entry.absolute, 'w', mode)\n    } catch (er) {\n      return oner(er)\n    }\n    const tx = this.transform ? this.transform(entry) || entry : entry\n    if (tx !== entry) {\n      tx.on('error', er => this[ONERROR](er, entry))\n      entry.pipe(tx)\n    }\n\n    tx.on('data', chunk => {\n      try {\n        fs.writeSync(fd, chunk, 0, chunk.length)\n      } catch (er) {\n        oner(er)\n      }\n    })\n\n    tx.on('end', _ => {\n      let er = null\n      // try both, falling futimes back to utimes\n      // if either fails, handle the first error\n      if (entry.mtime && !this.noMtime) {\n        const atime = entry.atime || new Date()\n        const mtime = entry.mtime\n        try {\n          fs.futimesSync(fd, atime, mtime)\n        } catch (futimeser) {\n          try {\n            fs.utimesSync(entry.absolute, atime, mtime)\n          } catch (utimeser) {\n            er = futimeser\n          }\n        }\n      }\n\n      if (this[DOCHOWN](entry)) {\n        const uid = this[UID](entry)\n        const gid = this[GID](entry)\n\n        try {\n          fs.fchownSync(fd, uid, gid)\n        } catch (fchowner) {\n          try {\n            fs.chownSync(entry.absolute, uid, gid)\n          } catch (chowner) {\n            er = er || fchowner\n          }\n        }\n      }\n\n      oner(er)\n    })\n  }\n\n  [DIRECTORY] (entry, done) {\n    const mode = entry.mode & 0o7777 || this.dmode\n    const er = this[MKDIR](entry.absolute, mode)\n    if (er) {\n      this[ONERROR](er, entry)\n      done()\n      return\n    }\n    if (entry.mtime && !this.noMtime) {\n      try {\n        fs.utimesSync(entry.absolute, entry.atime || new Date(), entry.mtime)\n      } catch (er) {}\n    }\n    if (this[DOCHOWN](entry)) {\n      try {\n        fs.chownSync(entry.absolute, this[UID](entry), this[GID](entry))\n      } catch (er) {}\n    }\n    done()\n    entry.resume()\n  }\n\n  [MKDIR] (dir, mode) {\n    try {\n      return mkdir.sync(normPath(dir), {\n        uid: this.uid,\n        gid: this.gid,\n        processUid: this.processUid,\n        processGid: this.processGid,\n        umask: this.processUmask,\n        preserve: this.preservePaths,\n        unlink: this.unlink,\n        cache: this.dirCache,\n        cwd: this.cwd,\n        mode: mode\n      })\n    } catch (er) {\n      return er\n    }\n  }\n\n  [LINK] (entry, linkpath, link, done) {\n    try {\n      fs[link + 'Sync'](linkpath, entry.absolute)\n      done()\n      entry.resume()\n    } catch (er) {\n      return this[ONERROR](er, entry)\n    }\n  }\n}\n\nUnpack.Sync = UnpackSync\nmodule.exports = Unpack\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL3Rhci9saWIvdW5wYWNrLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZSxtQkFBTyxDQUFDLHNCQUFRO0FBQy9CLFdBQVcsMERBQThCO0FBQ3pDLGVBQWUsbUJBQU8sQ0FBQyw2REFBWTtBQUNuQyxXQUFXLG1CQUFPLENBQUMsY0FBSTtBQUN2QixZQUFZLG1CQUFPLENBQUMsa0VBQWE7QUFDakMsYUFBYSxtQkFBTyxDQUFDLGtCQUFNO0FBQzNCLGNBQWMsbUJBQU8sQ0FBQyw2REFBWTtBQUNsQztBQUNBLFdBQVcsbUJBQU8sQ0FBQyxtRUFBZTtBQUNsQywwQkFBMEIsbUJBQU8sQ0FBQyx5RkFBMEI7QUFDNUQseUJBQXlCLG1CQUFPLENBQUMscUZBQXdCO0FBQ3pELGlCQUFpQixtQkFBTyxDQUFDLCtGQUE2QjtBQUN0RCxtQkFBbUIsbUJBQU8sQ0FBQywrRkFBNkI7O0FBRXhEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1CQUFPLENBQUMsc0JBQVE7QUFDL0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLE1BQU07QUFDckM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsY0FBYztBQUM1QjtBQUNBLGNBQWMsY0FBYztBQUM1QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxvQ0FBb0M7O0FBRXBDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDOztBQUV0QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RTtBQUN2RTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL2JhcmIvYWEvQXNzb2NpYXRlZEFjY291bnRzL25vZGVfbW9kdWxlcy90YXIvbGliL3VucGFjay5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuLy8gdGhlIFBFTkQvVU5QRU5EIHN0dWZmIHRyYWNrcyB3aGV0aGVyIHdlJ3JlIHJlYWR5IHRvIGVtaXQgZW5kL2Nsb3NlIHlldC5cbi8vIGJ1dCB0aGUgcGF0aCByZXNlcnZhdGlvbnMgYXJlIHJlcXVpcmVkIHRvIGF2b2lkIHJhY2UgY29uZGl0aW9ucyB3aGVyZVxuLy8gcGFyYWxsZWxpemVkIHVucGFjayBvcHMgbWF5IG1lc3Mgd2l0aCBvbmUgYW5vdGhlciwgZHVlIHRvIGRlcGVuZGVuY2llc1xuLy8gKGxpa2UgYSBMaW5rIGRlcGVuZGluZyBvbiBpdHMgdGFyZ2V0KSBvciBkZXN0cnVjdGl2ZSBvcGVyYXRpb25zIChsaWtlXG4vLyBjbG9iYmVyaW5nIGFuIGZzIG9iamVjdCB0byBjcmVhdGUgb25lIG9mIGEgZGlmZmVyZW50IHR5cGUuKVxuXG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKVxuY29uc3QgRUUgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbmNvbnN0IFBhcnNlciA9IHJlcXVpcmUoJy4vcGFyc2UuanMnKVxuY29uc3QgZnMgPSByZXF1aXJlKCdmcycpXG5jb25zdCBmc20gPSByZXF1aXJlKCdmcy1taW5pcGFzcycpXG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpXG5jb25zdCBta2RpciA9IHJlcXVpcmUoJy4vbWtkaXIuanMnKVxuY29uc3QgbWtkaXJTeW5jID0gbWtkaXIuc3luY1xuY29uc3Qgd2MgPSByZXF1aXJlKCcuL3dpbmNoYXJzLmpzJylcbmNvbnN0IHN0cmlwQWJzb2x1dGVQYXRoID0gcmVxdWlyZSgnLi9zdHJpcC1hYnNvbHV0ZS1wYXRoLmpzJylcbmNvbnN0IHBhdGhSZXNlcnZhdGlvbnMgPSByZXF1aXJlKCcuL3BhdGgtcmVzZXJ2YXRpb25zLmpzJylcbmNvbnN0IG5vcm1QYXRoID0gcmVxdWlyZSgnLi9ub3JtYWxpemUtd2luZG93cy1wYXRoLmpzJylcbmNvbnN0IHN0cmlwU2xhc2ggPSByZXF1aXJlKCcuL3N0cmlwLXRyYWlsaW5nLXNsYXNoZXMuanMnKVxuXG5jb25zdCBPTkVOVFJZID0gU3ltYm9sKCdvbkVudHJ5JylcbmNvbnN0IENIRUNLRlMgPSBTeW1ib2woJ2NoZWNrRnMnKVxuY29uc3QgQ0hFQ0tGUzIgPSBTeW1ib2woJ2NoZWNrRnMyJylcbmNvbnN0IFBSVU5FQ0FDSEUgPSBTeW1ib2woJ3BydW5lQ2FjaGUnKVxuY29uc3QgSVNSRVVTQUJMRSA9IFN5bWJvbCgnaXNSZXVzYWJsZScpXG5jb25zdCBNQUtFRlMgPSBTeW1ib2woJ21ha2VGcycpXG5jb25zdCBGSUxFID0gU3ltYm9sKCdmaWxlJylcbmNvbnN0IERJUkVDVE9SWSA9IFN5bWJvbCgnZGlyZWN0b3J5JylcbmNvbnN0IExJTksgPSBTeW1ib2woJ2xpbmsnKVxuY29uc3QgU1lNTElOSyA9IFN5bWJvbCgnc3ltbGluaycpXG5jb25zdCBIQVJETElOSyA9IFN5bWJvbCgnaGFyZGxpbmsnKVxuY29uc3QgVU5TVVBQT1JURUQgPSBTeW1ib2woJ3Vuc3VwcG9ydGVkJylcbmNvbnN0IFVOS05PV04gPSBTeW1ib2woJ3Vua25vd24nKVxuY29uc3QgQ0hFQ0tQQVRIID0gU3ltYm9sKCdjaGVja1BhdGgnKVxuY29uc3QgTUtESVIgPSBTeW1ib2woJ21rZGlyJylcbmNvbnN0IE9ORVJST1IgPSBTeW1ib2woJ29uRXJyb3InKVxuY29uc3QgUEVORElORyA9IFN5bWJvbCgncGVuZGluZycpXG5jb25zdCBQRU5EID0gU3ltYm9sKCdwZW5kJylcbmNvbnN0IFVOUEVORCA9IFN5bWJvbCgndW5wZW5kJylcbmNvbnN0IEVOREVEID0gU3ltYm9sKCdlbmRlZCcpXG5jb25zdCBNQVlCRUNMT1NFID0gU3ltYm9sKCdtYXliZUNsb3NlJylcbmNvbnN0IFNLSVAgPSBTeW1ib2woJ3NraXAnKVxuY29uc3QgRE9DSE9XTiA9IFN5bWJvbCgnZG9DaG93bicpXG5jb25zdCBVSUQgPSBTeW1ib2woJ3VpZCcpXG5jb25zdCBHSUQgPSBTeW1ib2woJ2dpZCcpXG5jb25zdCBDSEVDS0VEX0NXRCA9IFN5bWJvbCgnY2hlY2tlZEN3ZCcpXG5jb25zdCBjcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKVxuY29uc3QgcGxhdGZvcm0gPSBwcm9jZXNzLmVudi5URVNUSU5HX1RBUl9GQUtFX1BMQVRGT1JNIHx8IHByb2Nlc3MucGxhdGZvcm1cbmNvbnN0IGlzV2luZG93cyA9IHBsYXRmb3JtID09PSAnd2luMzInXG5cbi8vIFVubGlua3Mgb24gV2luZG93cyBhcmUgbm90IGF0b21pYy5cbi8vXG4vLyBUaGlzIG1lYW5zIHRoYXQgaWYgeW91IGhhdmUgYSBmaWxlIGVudHJ5LCBmb2xsb3dlZCBieSBhbm90aGVyXG4vLyBmaWxlIGVudHJ5IHdpdGggYW4gaWRlbnRpY2FsIG5hbWUsIGFuZCB5b3UgY2Fubm90IHJlLXVzZSB0aGUgZmlsZVxuLy8gKGJlY2F1c2UgaXQncyBhIGhhcmRsaW5rLCBvciBiZWNhdXNlIHVubGluazp0cnVlIGlzIHNldCwgb3IgaXQnc1xuLy8gV2luZG93cywgd2hpY2ggZG9lcyBub3QgaGF2ZSB1c2VmdWwgbmxpbmsgdmFsdWVzKSwgdGhlbiB0aGUgdW5saW5rXG4vLyB3aWxsIGJlIGNvbW1pdHRlZCB0byB0aGUgZGlzayBBRlRFUiB0aGUgbmV3IGZpbGUgaGFzIGJlZW4gd3JpdHRlblxuLy8gb3ZlciB0aGUgb2xkIG9uZSwgZGVsZXRpbmcgdGhlIG5ldyBmaWxlLlxuLy9cbi8vIFRvIHdvcmsgYXJvdW5kIHRoaXMsIG9uIFdpbmRvd3Mgc3lzdGVtcywgd2UgcmVuYW1lIHRoZSBmaWxlIGFuZCB0aGVuXG4vLyBkZWxldGUgdGhlIHJlbmFtZWQgZmlsZS4gIEl0J3MgYSBzbG9wcHkga2x1ZGdlLCBidXQgZnJhbmtseSwgSSBkbyBub3Rcbi8vIGtub3cgb2YgYSBiZXR0ZXIgd2F5IHRvIGRvIHRoaXMsIGdpdmVuIHdpbmRvd3MnIG5vbi1hdG9taWMgdW5saW5rXG4vLyBzZW1hbnRpY3MuXG4vL1xuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vbnBtL25vZGUtdGFyL2lzc3Vlcy8xODNcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5jb25zdCB1bmxpbmtGaWxlID0gKHBhdGgsIGNiKSA9PiB7XG4gIGlmICghaXNXaW5kb3dzKVxuICAgIHJldHVybiBmcy51bmxpbmsocGF0aCwgY2IpXG5cbiAgY29uc3QgbmFtZSA9IHBhdGggKyAnLkRFTEVURS4nICsgY3J5cHRvLnJhbmRvbUJ5dGVzKDE2KS50b1N0cmluZygnaGV4JylcbiAgZnMucmVuYW1lKHBhdGgsIG5hbWUsIGVyID0+IHtcbiAgICBpZiAoZXIpXG4gICAgICByZXR1cm4gY2IoZXIpXG4gICAgZnMudW5saW5rKG5hbWUsIGNiKVxuICB9KVxufVxuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuY29uc3QgdW5saW5rRmlsZVN5bmMgPSBwYXRoID0+IHtcbiAgaWYgKCFpc1dpbmRvd3MpXG4gICAgcmV0dXJuIGZzLnVubGlua1N5bmMocGF0aClcblxuICBjb25zdCBuYW1lID0gcGF0aCArICcuREVMRVRFLicgKyBjcnlwdG8ucmFuZG9tQnl0ZXMoMTYpLnRvU3RyaW5nKCdoZXgnKVxuICBmcy5yZW5hbWVTeW5jKHBhdGgsIG5hbWUpXG4gIGZzLnVubGlua1N5bmMobmFtZSlcbn1cblxuLy8gdGhpcy5naWQsIGVudHJ5LmdpZCwgdGhpcy5wcm9jZXNzVWlkXG5jb25zdCB1aW50MzIgPSAoYSwgYiwgYykgPT5cbiAgYSA9PT0gYSA+Pj4gMCA/IGFcbiAgOiBiID09PSBiID4+PiAwID8gYlxuICA6IGNcblxuLy8gY2xlYXIgdGhlIGNhY2hlIGlmIGl0J3MgYSBjYXNlLWluc2Vuc2l0aXZlIHVuaWNvZGUtc3F1YXNoaW5nIG1hdGNoLlxuLy8gd2UgY2FuJ3Qga25vdyBpZiB0aGUgY3VycmVudCBmaWxlIHN5c3RlbSBpcyBjYXNlLXNlbnNpdGl2ZSBvciBzdXBwb3J0c1xuLy8gdW5pY29kZSBmdWxseSwgc28gd2UgY2hlY2sgZm9yIHNpbWlsYXJpdHkgb24gdGhlIG1heGltYWxseSBjb21wYXRpYmxlXG4vLyByZXByZXNlbnRhdGlvbi4gIEVyciBvbiB0aGUgc2lkZSBvZiBwcnVuaW5nLCBzaW5jZSBhbGwgaXQncyBkb2luZyBpc1xuLy8gcHJldmVudGluZyBsc3RhdHMsIGFuZCBpdCdzIG5vdCB0aGUgZW5kIG9mIHRoZSB3b3JsZCBpZiB3ZSBnZXQgYSBmYWxzZVxuLy8gcG9zaXRpdmUuXG4vLyBOb3RlIHRoYXQgb24gd2luZG93cywgd2UgYWx3YXlzIGRyb3AgdGhlIGVudGlyZSBjYWNoZSB3aGVuZXZlciBhXG4vLyBzeW1ib2xpYyBsaW5rIGlzIGVuY291bnRlcmVkLCBiZWNhdXNlIDguMyBmaWxlbmFtZXMgYXJlIGltcG9zc2libGVcbi8vIHRvIHJlYXNvbiBhYm91dCwgYW5kIGNvbGxpc2lvbnMgYXJlIGhhemFyZHMgcmF0aGVyIHRoYW4ganVzdCBmYWlsdXJlcy5cbmNvbnN0IGNhY2hlS2V5Tm9ybWFsaXplID0gcGF0aCA9PiBzdHJpcFNsYXNoKG5vcm1QYXRoKHBhdGgpKVxuICAubm9ybWFsaXplKCdORktEJylcbiAgLnRvTG93ZXJDYXNlKClcblxuY29uc3QgcHJ1bmVDYWNoZSA9IChjYWNoZSwgYWJzKSA9PiB7XG4gIGFicyA9IGNhY2hlS2V5Tm9ybWFsaXplKGFicylcbiAgZm9yIChjb25zdCBwYXRoIG9mIGNhY2hlLmtleXMoKSkge1xuICAgIGNvbnN0IHBub3JtID0gY2FjaGVLZXlOb3JtYWxpemUocGF0aClcbiAgICBpZiAocG5vcm0gPT09IGFicyB8fCBwbm9ybS5pbmRleE9mKGFicyArICcvJykgPT09IDApXG4gICAgICBjYWNoZS5kZWxldGUocGF0aClcbiAgfVxufVxuXG5jb25zdCBkcm9wQ2FjaGUgPSBjYWNoZSA9PiB7XG4gIGZvciAoY29uc3Qga2V5IG9mIGNhY2hlLmtleXMoKSlcbiAgICBjYWNoZS5kZWxldGUoa2V5KVxufVxuXG5jbGFzcyBVbnBhY2sgZXh0ZW5kcyBQYXJzZXIge1xuICBjb25zdHJ1Y3RvciAob3B0KSB7XG4gICAgaWYgKCFvcHQpXG4gICAgICBvcHQgPSB7fVxuXG4gICAgb3B0Lm9uZG9uZSA9IF8gPT4ge1xuICAgICAgdGhpc1tFTkRFRF0gPSB0cnVlXG4gICAgICB0aGlzW01BWUJFQ0xPU0VdKClcbiAgICB9XG5cbiAgICBzdXBlcihvcHQpXG5cbiAgICB0aGlzW0NIRUNLRURfQ1dEXSA9IGZhbHNlXG5cbiAgICB0aGlzLnJlc2VydmF0aW9ucyA9IHBhdGhSZXNlcnZhdGlvbnMoKVxuXG4gICAgdGhpcy50cmFuc2Zvcm0gPSB0eXBlb2Ygb3B0LnRyYW5zZm9ybSA9PT0gJ2Z1bmN0aW9uJyA/IG9wdC50cmFuc2Zvcm0gOiBudWxsXG5cbiAgICB0aGlzLndyaXRhYmxlID0gdHJ1ZVxuICAgIHRoaXMucmVhZGFibGUgPSBmYWxzZVxuXG4gICAgdGhpc1tQRU5ESU5HXSA9IDBcbiAgICB0aGlzW0VOREVEXSA9IGZhbHNlXG5cbiAgICB0aGlzLmRpckNhY2hlID0gb3B0LmRpckNhY2hlIHx8IG5ldyBNYXAoKVxuXG4gICAgaWYgKHR5cGVvZiBvcHQudWlkID09PSAnbnVtYmVyJyB8fCB0eXBlb2Ygb3B0LmdpZCA9PT0gJ251bWJlcicpIHtcbiAgICAgIC8vIG5lZWQgYm90aCBvciBuZWl0aGVyXG4gICAgICBpZiAodHlwZW9mIG9wdC51aWQgIT09ICdudW1iZXInIHx8IHR5cGVvZiBvcHQuZ2lkICE9PSAnbnVtYmVyJylcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignY2Fubm90IHNldCBvd25lciB3aXRob3V0IG51bWJlciB1aWQgYW5kIGdpZCcpXG4gICAgICBpZiAob3B0LnByZXNlcnZlT3duZXIpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgJ2Nhbm5vdCBwcmVzZXJ2ZSBvd25lciBpbiBhcmNoaXZlIGFuZCBhbHNvIHNldCBvd25lciBleHBsaWNpdGx5JylcbiAgICAgIHRoaXMudWlkID0gb3B0LnVpZFxuICAgICAgdGhpcy5naWQgPSBvcHQuZ2lkXG4gICAgICB0aGlzLnNldE93bmVyID0gdHJ1ZVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnVpZCA9IG51bGxcbiAgICAgIHRoaXMuZ2lkID0gbnVsbFxuICAgICAgdGhpcy5zZXRPd25lciA9IGZhbHNlXG4gICAgfVxuXG4gICAgLy8gZGVmYXVsdCB0cnVlIGZvciByb290XG4gICAgaWYgKG9wdC5wcmVzZXJ2ZU93bmVyID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9wdC51aWQgIT09ICdudW1iZXInKVxuICAgICAgdGhpcy5wcmVzZXJ2ZU93bmVyID0gcHJvY2Vzcy5nZXR1aWQgJiYgcHJvY2Vzcy5nZXR1aWQoKSA9PT0gMFxuICAgIGVsc2VcbiAgICAgIHRoaXMucHJlc2VydmVPd25lciA9ICEhb3B0LnByZXNlcnZlT3duZXJcblxuICAgIHRoaXMucHJvY2Vzc1VpZCA9ICh0aGlzLnByZXNlcnZlT3duZXIgfHwgdGhpcy5zZXRPd25lcikgJiYgcHJvY2Vzcy5nZXR1aWQgP1xuICAgICAgcHJvY2Vzcy5nZXR1aWQoKSA6IG51bGxcbiAgICB0aGlzLnByb2Nlc3NHaWQgPSAodGhpcy5wcmVzZXJ2ZU93bmVyIHx8IHRoaXMuc2V0T3duZXIpICYmIHByb2Nlc3MuZ2V0Z2lkID9cbiAgICAgIHByb2Nlc3MuZ2V0Z2lkKCkgOiBudWxsXG5cbiAgICAvLyBtb3N0bHkganVzdCBmb3IgdGVzdGluZywgYnV0IHVzZWZ1bCBpbiBzb21lIGNhc2VzLlxuICAgIC8vIEZvcmNpYmx5IHRyaWdnZXIgYSBjaG93biBvbiBldmVyeSBlbnRyeSwgbm8gbWF0dGVyIHdoYXRcbiAgICB0aGlzLmZvcmNlQ2hvd24gPSBvcHQuZm9yY2VDaG93biA9PT0gdHJ1ZVxuXG4gICAgLy8gdHVybiA+PD98IGluIGZpbGVuYW1lcyBpbnRvIDB4ZjAwMC1oaWdoZXIgZW5jb2RlZCBmb3Jtc1xuICAgIHRoaXMud2luMzIgPSAhIW9wdC53aW4zMiB8fCBpc1dpbmRvd3NcblxuICAgIC8vIGRvIG5vdCB1bnBhY2sgb3ZlciBmaWxlcyB0aGF0IGFyZSBuZXdlciB0aGFuIHdoYXQncyBpbiB0aGUgYXJjaGl2ZVxuICAgIHRoaXMubmV3ZXIgPSAhIW9wdC5uZXdlclxuXG4gICAgLy8gZG8gbm90IHVucGFjayBvdmVyIEFOWSBmaWxlc1xuICAgIHRoaXMua2VlcCA9ICEhb3B0LmtlZXBcblxuICAgIC8vIGRvIG5vdCBzZXQgbXRpbWUvYXRpbWUgb2YgZXh0cmFjdGVkIGVudHJpZXNcbiAgICB0aGlzLm5vTXRpbWUgPSAhIW9wdC5ub010aW1lXG5cbiAgICAvLyBhbGxvdyAuLiwgYWJzb2x1dGUgcGF0aCBlbnRyaWVzLCBhbmQgdW5wYWNraW5nIHRocm91Z2ggc3ltbGlua3NcbiAgICAvLyB3aXRob3V0IHRoaXMsIHdhcm4gYW5kIHNraXAgLi4sIHJlbGF0aXZpemUgYWJzb2x1dGVzLCBhbmQgZXJyb3JcbiAgICAvLyBvbiBzeW1saW5rcyBpbiBleHRyYWN0aW9uIHBhdGhcbiAgICB0aGlzLnByZXNlcnZlUGF0aHMgPSAhIW9wdC5wcmVzZXJ2ZVBhdGhzXG5cbiAgICAvLyB1bmxpbmsgZmlsZXMgYW5kIGxpbmtzIGJlZm9yZSB3cml0aW5nLiBUaGlzIGJyZWFrcyBleGlzdGluZyBoYXJkXG4gICAgLy8gbGlua3MsIGFuZCByZW1vdmVzIHN5bWxpbmsgZGlyZWN0b3JpZXMgcmF0aGVyIHRoYW4gZXJyb3JpbmdcbiAgICB0aGlzLnVubGluayA9ICEhb3B0LnVubGlua1xuXG4gICAgdGhpcy5jd2QgPSBub3JtUGF0aChwYXRoLnJlc29sdmUob3B0LmN3ZCB8fCBwcm9jZXNzLmN3ZCgpKSlcbiAgICB0aGlzLnN0cmlwID0gK29wdC5zdHJpcCB8fCAwXG4gICAgdGhpcy5wcm9jZXNzVW1hc2sgPSBwcm9jZXNzLnVtYXNrKClcbiAgICB0aGlzLnVtYXNrID0gdHlwZW9mIG9wdC51bWFzayA9PT0gJ251bWJlcicgPyBvcHQudW1hc2sgOiB0aGlzLnByb2Nlc3NVbWFza1xuICAgIC8vIGRlZmF1bHQgbW9kZSBmb3IgZGlycyBjcmVhdGVkIGFzIHBhcmVudHNcbiAgICB0aGlzLmRtb2RlID0gb3B0LmRtb2RlIHx8ICgwbzA3NzcgJiAofnRoaXMudW1hc2spKVxuICAgIHRoaXMuZm1vZGUgPSBvcHQuZm1vZGUgfHwgKDBvMDY2NiAmICh+dGhpcy51bWFzaykpXG4gICAgdGhpcy5vbignZW50cnknLCBlbnRyeSA9PiB0aGlzW09ORU5UUlldKGVudHJ5KSlcbiAgfVxuXG4gIFtNQVlCRUNMT1NFXSAoKSB7XG4gICAgaWYgKHRoaXNbRU5ERURdICYmIHRoaXNbUEVORElOR10gPT09IDApIHtcbiAgICAgIHRoaXMuZW1pdCgncHJlZmluaXNoJylcbiAgICAgIHRoaXMuZW1pdCgnZmluaXNoJylcbiAgICAgIHRoaXMuZW1pdCgnZW5kJylcbiAgICAgIHRoaXMuZW1pdCgnY2xvc2UnKVxuICAgIH1cbiAgfVxuXG4gIFtDSEVDS1BBVEhdIChlbnRyeSkge1xuICAgIGlmICh0aGlzLnN0cmlwKSB7XG4gICAgICBjb25zdCBwYXJ0cyA9IG5vcm1QYXRoKGVudHJ5LnBhdGgpLnNwbGl0KCcvJylcbiAgICAgIGlmIChwYXJ0cy5sZW5ndGggPCB0aGlzLnN0cmlwKVxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIGVudHJ5LnBhdGggPSBwYXJ0cy5zbGljZSh0aGlzLnN0cmlwKS5qb2luKCcvJylcblxuICAgICAgaWYgKGVudHJ5LnR5cGUgPT09ICdMaW5rJykge1xuICAgICAgICBjb25zdCBsaW5rcGFydHMgPSBub3JtUGF0aChlbnRyeS5saW5rcGF0aCkuc3BsaXQoJy8nKVxuICAgICAgICBpZiAobGlua3BhcnRzLmxlbmd0aCA+PSB0aGlzLnN0cmlwKVxuICAgICAgICAgIGVudHJ5LmxpbmtwYXRoID0gbGlua3BhcnRzLnNsaWNlKHRoaXMuc3RyaXApLmpvaW4oJy8nKVxuICAgICAgICBlbHNlXG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLnByZXNlcnZlUGF0aHMpIHtcbiAgICAgIGNvbnN0IHAgPSBub3JtUGF0aChlbnRyeS5wYXRoKVxuICAgICAgY29uc3QgcGFydHMgPSBwLnNwbGl0KCcvJylcbiAgICAgIGlmIChwYXJ0cy5pbmNsdWRlcygnLi4nKSB8fCBpc1dpbmRvd3MgJiYgL15bYS16XTpcXC5cXC4kL2kudGVzdChwYXJ0c1swXSkpIHtcbiAgICAgICAgdGhpcy53YXJuKGBwYXRoIGNvbnRhaW5zICcuLidgLCBwKVxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cblxuICAgICAgLy8gc3RyaXAgb2ZmIHRoZSByb290XG4gICAgICBjb25zdCBzID0gc3RyaXBBYnNvbHV0ZVBhdGgocClcbiAgICAgIGlmIChzWzBdKSB7XG4gICAgICAgIGVudHJ5LnBhdGggPSBzWzFdXG4gICAgICAgIHRoaXMud2Fybihgc3RyaXBwaW5nICR7c1swXX0gZnJvbSBhYnNvbHV0ZSBwYXRoYCwgcClcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocGF0aC5pc0Fic29sdXRlKGVudHJ5LnBhdGgpKVxuICAgICAgZW50cnkuYWJzb2x1dGUgPSBub3JtUGF0aChwYXRoLnJlc29sdmUoZW50cnkucGF0aCkpXG4gICAgZWxzZVxuICAgICAgZW50cnkuYWJzb2x1dGUgPSBub3JtUGF0aChwYXRoLnJlc29sdmUodGhpcy5jd2QsIGVudHJ5LnBhdGgpKVxuXG4gICAgLy8gaWYgd2Ugc29tZWhvdyBlbmRlZCB1cCB3aXRoIGEgcGF0aCB0aGF0IGVzY2FwZXMgdGhlIGN3ZCwgYW5kIHdlIGFyZVxuICAgIC8vIG5vdCBpbiBwcmVzZXJ2ZVBhdGhzIG1vZGUsIHRoZW4gc29tZXRoaW5nIGlzIGZpc2h5ISAgVGhpcyBzaG91bGQgaGF2ZVxuICAgIC8vIGJlZW4gcHJldmVudGVkIGFib3ZlLCBzbyBpZ25vcmUgdGhpcyBmb3IgY292ZXJhZ2UuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmIC0gZGVmZW5zZSBpbiBkZXB0aCAqL1xuICAgIGlmICghdGhpcy5wcmVzZXJ2ZVBhdGhzICYmXG4gICAgICAgIGVudHJ5LmFic29sdXRlLmluZGV4T2YodGhpcy5jd2QgKyAnLycpICE9PSAwICYmXG4gICAgICAgIGVudHJ5LmFic29sdXRlICE9PSB0aGlzLmN3ZCkge1xuICAgICAgdGhpcy53YXJuKCdUQVJfRU5UUllfRVJST1InLCAncGF0aCBlc2NhcGVkIGV4dHJhY3Rpb24gdGFyZ2V0Jywge1xuICAgICAgICBlbnRyeSxcbiAgICAgICAgcGF0aDogbm9ybVBhdGgoZW50cnkucGF0aCksXG4gICAgICAgIHJlc29sdmVkUGF0aDogZW50cnkuYWJzb2x1dGUsXG4gICAgICAgIGN3ZDogdGhpcy5jd2QsXG4gICAgICB9KVxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgLy8gYW4gYXJjaGl2ZSBjYW4gc2V0IHByb3BlcnRpZXMgb24gdGhlIGV4dHJhY3Rpb24gZGlyZWN0b3J5LCBidXQgaXRcbiAgICAvLyBtYXkgbm90IHJlcGxhY2UgdGhlIGN3ZCB3aXRoIGEgZGlmZmVyZW50IGtpbmQgb2YgdGhpbmcgZW50aXJlbHkuXG4gICAgaWYgKGVudHJ5LmFic29sdXRlID09PSB0aGlzLmN3ZCAmJlxuICAgICAgICBlbnRyeS50eXBlICE9PSAnRGlyZWN0b3J5JyAmJlxuICAgICAgICBlbnRyeS50eXBlICE9PSAnR05VRHVtcERpcicpXG4gICAgICByZXR1cm4gZmFsc2VcblxuICAgIC8vIG9ubHkgZW5jb2RlIDogY2hhcnMgdGhhdCBhcmVuJ3QgZHJpdmUgbGV0dGVyIGluZGljYXRvcnNcbiAgICBpZiAodGhpcy53aW4zMikge1xuICAgICAgY29uc3QgeyByb290OiBhUm9vdCB9ID0gcGF0aC53aW4zMi5wYXJzZShlbnRyeS5hYnNvbHV0ZSlcbiAgICAgIGVudHJ5LmFic29sdXRlID0gYVJvb3QgKyB3Yy5lbmNvZGUoZW50cnkuYWJzb2x1dGUuc3Vic3RyKGFSb290Lmxlbmd0aCkpXG4gICAgICBjb25zdCB7IHJvb3Q6IHBSb290IH0gPSBwYXRoLndpbjMyLnBhcnNlKGVudHJ5LnBhdGgpXG4gICAgICBlbnRyeS5wYXRoID0gcFJvb3QgKyB3Yy5lbmNvZGUoZW50cnkucGF0aC5zdWJzdHIocFJvb3QubGVuZ3RoKSlcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgW09ORU5UUlldIChlbnRyeSkge1xuICAgIGlmICghdGhpc1tDSEVDS1BBVEhdKGVudHJ5KSlcbiAgICAgIHJldHVybiBlbnRyeS5yZXN1bWUoKVxuXG4gICAgYXNzZXJ0LmVxdWFsKHR5cGVvZiBlbnRyeS5hYnNvbHV0ZSwgJ3N0cmluZycpXG5cbiAgICBzd2l0Y2ggKGVudHJ5LnR5cGUpIHtcbiAgICAgIGNhc2UgJ0RpcmVjdG9yeSc6XG4gICAgICBjYXNlICdHTlVEdW1wRGlyJzpcbiAgICAgICAgaWYgKGVudHJ5Lm1vZGUpXG4gICAgICAgICAgZW50cnkubW9kZSA9IGVudHJ5Lm1vZGUgfCAwbzcwMFxuXG4gICAgICBjYXNlICdGaWxlJzpcbiAgICAgIGNhc2UgJ09sZEZpbGUnOlxuICAgICAgY2FzZSAnQ29udGlndW91c0ZpbGUnOlxuICAgICAgY2FzZSAnTGluayc6XG4gICAgICBjYXNlICdTeW1ib2xpY0xpbmsnOlxuICAgICAgICByZXR1cm4gdGhpc1tDSEVDS0ZTXShlbnRyeSlcblxuICAgICAgY2FzZSAnQ2hhcmFjdGVyRGV2aWNlJzpcbiAgICAgIGNhc2UgJ0Jsb2NrRGV2aWNlJzpcbiAgICAgIGNhc2UgJ0ZJRk8nOlxuICAgICAgICByZXR1cm4gdGhpc1tVTlNVUFBPUlRFRF0oZW50cnkpXG4gICAgfVxuICB9XG5cbiAgW09ORVJST1JdIChlciwgZW50cnkpIHtcbiAgICAvLyBDd2QgaGFzIHRvIGV4aXN0LCBvciBlbHNlIG5vdGhpbmcgd29ya3MuIFRoYXQncyBzZXJpb3VzLlxuICAgIC8vIE90aGVyIGVycm9ycyBhcmUgd2FybmluZ3MsIHdoaWNoIHJhaXNlIHRoZSBlcnJvciBpbiBzdHJpY3RcbiAgICAvLyBtb2RlLCBidXQgb3RoZXJ3aXNlIGNvbnRpbnVlIG9uLlxuICAgIGlmIChlci5uYW1lID09PSAnQ3dkRXJyb3InKVxuICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIGVyKVxuICAgIGVsc2Uge1xuICAgICAgdGhpcy53YXJuKGVyLm1lc3NhZ2UsIGVyKVxuICAgICAgdGhpc1tVTlBFTkRdKClcbiAgICAgIGVudHJ5LnJlc3VtZSgpXG4gICAgfVxuICB9XG5cbiAgW01LRElSXSAoZGlyLCBtb2RlLCBjYikge1xuICAgIG1rZGlyKG5vcm1QYXRoKGRpciksIHtcbiAgICAgIHVpZDogdGhpcy51aWQsXG4gICAgICBnaWQ6IHRoaXMuZ2lkLFxuICAgICAgcHJvY2Vzc1VpZDogdGhpcy5wcm9jZXNzVWlkLFxuICAgICAgcHJvY2Vzc0dpZDogdGhpcy5wcm9jZXNzR2lkLFxuICAgICAgdW1hc2s6IHRoaXMucHJvY2Vzc1VtYXNrLFxuICAgICAgcHJlc2VydmU6IHRoaXMucHJlc2VydmVQYXRocyxcbiAgICAgIHVubGluazogdGhpcy51bmxpbmssXG4gICAgICBjYWNoZTogdGhpcy5kaXJDYWNoZSxcbiAgICAgIGN3ZDogdGhpcy5jd2QsXG4gICAgICBtb2RlOiBtb2RlXG4gICAgfSwgY2IpXG4gIH1cblxuICBbRE9DSE9XTl0gKGVudHJ5KSB7XG4gICAgLy8gaW4gcHJlc2VydmUgb3duZXIgbW9kZSwgY2hvd24gaWYgdGhlIGVudHJ5IGRvZXNuJ3QgbWF0Y2ggcHJvY2Vzc1xuICAgIC8vIGluIHNldCBvd25lciBtb2RlLCBjaG93biBpZiBzZXR0aW5nIGRvZXNuJ3QgbWF0Y2ggcHJvY2Vzc1xuICAgIHJldHVybiB0aGlzLmZvcmNlQ2hvd24gfHxcbiAgICAgIHRoaXMucHJlc2VydmVPd25lciAmJlxuICAgICAgKCB0eXBlb2YgZW50cnkudWlkID09PSAnbnVtYmVyJyAmJiBlbnRyeS51aWQgIT09IHRoaXMucHJvY2Vzc1VpZCB8fFxuICAgICAgICB0eXBlb2YgZW50cnkuZ2lkID09PSAnbnVtYmVyJyAmJiBlbnRyeS5naWQgIT09IHRoaXMucHJvY2Vzc0dpZCApXG4gICAgICB8fFxuICAgICAgKCB0eXBlb2YgdGhpcy51aWQgPT09ICdudW1iZXInICYmIHRoaXMudWlkICE9PSB0aGlzLnByb2Nlc3NVaWQgfHxcbiAgICAgICAgdHlwZW9mIHRoaXMuZ2lkID09PSAnbnVtYmVyJyAmJiB0aGlzLmdpZCAhPT0gdGhpcy5wcm9jZXNzR2lkIClcbiAgfVxuXG4gIFtVSURdIChlbnRyeSkge1xuICAgIHJldHVybiB1aW50MzIodGhpcy51aWQsIGVudHJ5LnVpZCwgdGhpcy5wcm9jZXNzVWlkKVxuICB9XG5cbiAgW0dJRF0gKGVudHJ5KSB7XG4gICAgcmV0dXJuIHVpbnQzMih0aGlzLmdpZCwgZW50cnkuZ2lkLCB0aGlzLnByb2Nlc3NHaWQpXG4gIH1cblxuICBbRklMRV0gKGVudHJ5LCBmdWxseURvbmUpIHtcbiAgICBjb25zdCBtb2RlID0gZW50cnkubW9kZSAmIDBvNzc3NyB8fCB0aGlzLmZtb2RlXG4gICAgY29uc3Qgc3RyZWFtID0gbmV3IGZzbS5Xcml0ZVN0cmVhbShlbnRyeS5hYnNvbHV0ZSwge1xuICAgICAgbW9kZTogbW9kZSxcbiAgICAgIGF1dG9DbG9zZTogZmFsc2VcbiAgICB9KVxuICAgIHN0cmVhbS5vbignZXJyb3InLCBlciA9PiB7XG4gICAgICBpZiAoc3RyZWFtLmZkKVxuICAgICAgICBmcy5jbG9zZShzdHJlYW0uZmQsICgpID0+IHt9KVxuXG4gICAgICAvLyBmbHVzaCBhbGwgdGhlIGRhdGEgb3V0IHNvIHRoYXQgd2UgYXJlbid0IGxlZnQgaGFuZ2luZ1xuICAgICAgLy8gaWYgdGhlIGVycm9yIHdhc24ndCBhY3R1YWxseSBmYXRhbC4gIG90aGVyd2lzZSB0aGUgcGFyc2VcbiAgICAgIC8vIGlzIGJsb2NrZWQsIGFuZCB3ZSBuZXZlciBwcm9jZWVkLlxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgIHN0cmVhbS53cml0ZSA9ICgpID0+IHRydWVcbiAgICAgIHRoaXNbT05FUlJPUl0oZXIsIGVudHJ5KVxuICAgICAgZnVsbHlEb25lKClcbiAgICB9KVxuXG4gICAgbGV0IGFjdGlvbnMgPSAxXG4gICAgY29uc3QgZG9uZSA9IGVyID0+IHtcbiAgICAgIGlmIChlcikge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAtIHdlIHNob3VsZCBhbHdheXMgaGF2ZSBhIGZkIGJ5IG5vdyAqL1xuICAgICAgICBpZiAoc3RyZWFtLmZkKVxuICAgICAgICAgIGZzLmNsb3NlKHN0cmVhbS5mZCwgKCkgPT4ge30pXG5cbiAgICAgICAgdGhpc1tPTkVSUk9SXShlciwgZW50cnkpXG4gICAgICAgIGZ1bGx5RG9uZSgpXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBpZiAoLS1hY3Rpb25zID09PSAwKSB7XG4gICAgICAgIGZzLmNsb3NlKHN0cmVhbS5mZCwgZXIgPT4ge1xuICAgICAgICAgIGZ1bGx5RG9uZSgpXG4gICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICBlciA/IHRoaXNbT05FUlJPUl0oZXIsIGVudHJ5KSA6IHRoaXNbVU5QRU5EXSgpXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfVxuXG4gICAgc3RyZWFtLm9uKCdmaW5pc2gnLCBfID0+IHtcbiAgICAgIC8vIGlmIGZ1dGltZXMgZmFpbHMsIHRyeSB1dGltZXNcbiAgICAgIC8vIGlmIHV0aW1lcyBmYWlscywgZmFpbCB3aXRoIHRoZSBvcmlnaW5hbCBlcnJvclxuICAgICAgLy8gc2FtZSBmb3IgZmNob3duL2Nob3duXG4gICAgICBjb25zdCBhYnMgPSBlbnRyeS5hYnNvbHV0ZVxuICAgICAgY29uc3QgZmQgPSBzdHJlYW0uZmRcblxuICAgICAgaWYgKGVudHJ5Lm10aW1lICYmICF0aGlzLm5vTXRpbWUpIHtcbiAgICAgICAgYWN0aW9ucysrXG4gICAgICAgIGNvbnN0IGF0aW1lID0gZW50cnkuYXRpbWUgfHwgbmV3IERhdGUoKVxuICAgICAgICBjb25zdCBtdGltZSA9IGVudHJ5Lm10aW1lXG4gICAgICAgIGZzLmZ1dGltZXMoZmQsIGF0aW1lLCBtdGltZSwgZXIgPT5cbiAgICAgICAgICBlciA/IGZzLnV0aW1lcyhhYnMsIGF0aW1lLCBtdGltZSwgZXIyID0+IGRvbmUoZXIyICYmIGVyKSlcbiAgICAgICAgICA6IGRvbmUoKSlcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXNbRE9DSE9XTl0oZW50cnkpKSB7XG4gICAgICAgIGFjdGlvbnMrK1xuICAgICAgICBjb25zdCB1aWQgPSB0aGlzW1VJRF0oZW50cnkpXG4gICAgICAgIGNvbnN0IGdpZCA9IHRoaXNbR0lEXShlbnRyeSlcbiAgICAgICAgZnMuZmNob3duKGZkLCB1aWQsIGdpZCwgZXIgPT5cbiAgICAgICAgICBlciA/IGZzLmNob3duKGFicywgdWlkLCBnaWQsIGVyMiA9PiBkb25lKGVyMiAmJiBlcikpXG4gICAgICAgICAgOiBkb25lKCkpXG4gICAgICB9XG5cbiAgICAgIGRvbmUoKVxuICAgIH0pXG5cbiAgICBjb25zdCB0eCA9IHRoaXMudHJhbnNmb3JtID8gdGhpcy50cmFuc2Zvcm0oZW50cnkpIHx8IGVudHJ5IDogZW50cnlcbiAgICBpZiAodHggIT09IGVudHJ5KSB7XG4gICAgICB0eC5vbignZXJyb3InLCBlciA9PiB0aGlzW09ORVJST1JdKGVyLCBlbnRyeSkpXG4gICAgICBlbnRyeS5waXBlKHR4KVxuICAgIH1cbiAgICB0eC5waXBlKHN0cmVhbSlcbiAgfVxuXG4gIFtESVJFQ1RPUlldIChlbnRyeSwgZnVsbHlEb25lKSB7XG4gICAgY29uc3QgbW9kZSA9IGVudHJ5Lm1vZGUgJiAwbzc3NzcgfHwgdGhpcy5kbW9kZVxuICAgIHRoaXNbTUtESVJdKGVudHJ5LmFic29sdXRlLCBtb2RlLCBlciA9PiB7XG4gICAgICBpZiAoZXIpIHtcbiAgICAgICAgZnVsbHlEb25lKClcbiAgICAgICAgcmV0dXJuIHRoaXNbT05FUlJPUl0oZXIsIGVudHJ5KVxuICAgICAgfVxuXG4gICAgICBsZXQgYWN0aW9ucyA9IDFcbiAgICAgIGNvbnN0IGRvbmUgPSBfID0+IHtcbiAgICAgICAgaWYgKC0tYWN0aW9ucyA9PT0gMCkge1xuICAgICAgICAgIGZ1bGx5RG9uZSgpXG4gICAgICAgICAgdGhpc1tVTlBFTkRdKClcbiAgICAgICAgICBlbnRyeS5yZXN1bWUoKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChlbnRyeS5tdGltZSAmJiAhdGhpcy5ub010aW1lKSB7XG4gICAgICAgIGFjdGlvbnMrK1xuICAgICAgICBmcy51dGltZXMoZW50cnkuYWJzb2x1dGUsIGVudHJ5LmF0aW1lIHx8IG5ldyBEYXRlKCksIGVudHJ5Lm10aW1lLCBkb25lKVxuICAgICAgfVxuXG4gICAgICBpZiAodGhpc1tET0NIT1dOXShlbnRyeSkpIHtcbiAgICAgICAgYWN0aW9ucysrXG4gICAgICAgIGZzLmNob3duKGVudHJ5LmFic29sdXRlLCB0aGlzW1VJRF0oZW50cnkpLCB0aGlzW0dJRF0oZW50cnkpLCBkb25lKVxuICAgICAgfVxuXG4gICAgICBkb25lKClcbiAgICB9KVxuICB9XG5cbiAgW1VOU1VQUE9SVEVEXSAoZW50cnkpIHtcbiAgICB0aGlzLndhcm4oJ3Vuc3VwcG9ydGVkIGVudHJ5IHR5cGU6ICcgKyBlbnRyeS50eXBlLCBlbnRyeSlcbiAgICBlbnRyeS5yZXN1bWUoKVxuICB9XG5cbiAgW1NZTUxJTktdIChlbnRyeSwgZG9uZSkge1xuICAgIHRoaXNbTElOS10oZW50cnksIGVudHJ5LmxpbmtwYXRoLCAnc3ltbGluaycsIGRvbmUpXG4gIH1cblxuICBbSEFSRExJTktdIChlbnRyeSwgZG9uZSkge1xuICAgIGNvbnN0IGxpbmtwYXRoID0gbm9ybVBhdGgocGF0aC5yZXNvbHZlKHRoaXMuY3dkLCBlbnRyeS5saW5rcGF0aCkpXG4gICAgdGhpc1tMSU5LXShlbnRyeSwgbGlua3BhdGgsICdsaW5rJywgZG9uZSlcbiAgfVxuXG4gIFtQRU5EXSAoKSB7XG4gICAgdGhpc1tQRU5ESU5HXSsrXG4gIH1cblxuICBbVU5QRU5EXSAoKSB7XG4gICAgdGhpc1tQRU5ESU5HXS0tXG4gICAgdGhpc1tNQVlCRUNMT1NFXSgpXG4gIH1cblxuICBbU0tJUF0gKGVudHJ5KSB7XG4gICAgdGhpc1tVTlBFTkRdKClcbiAgICBlbnRyeS5yZXN1bWUoKVxuICB9XG5cbiAgLy8gQ2hlY2sgaWYgd2UgY2FuIHJldXNlIGFuIGV4aXN0aW5nIGZpbGVzeXN0ZW0gZW50cnkgc2FmZWx5IGFuZFxuICAvLyBvdmVyd3JpdGUgaXQsIHJhdGhlciB0aGFuIHVubGlua2luZyBhbmQgcmVjcmVhdGluZ1xuICAvLyBXaW5kb3dzIGRvZXNuJ3QgcmVwb3J0IGEgdXNlZnVsIG5saW5rLCBzbyB3ZSBqdXN0IG5ldmVyIHJldXNlIGVudHJpZXNcbiAgW0lTUkVVU0FCTEVdIChlbnRyeSwgc3QpIHtcbiAgICByZXR1cm4gZW50cnkudHlwZSA9PT0gJ0ZpbGUnICYmXG4gICAgICAhdGhpcy51bmxpbmsgJiZcbiAgICAgIHN0LmlzRmlsZSgpICYmXG4gICAgICBzdC5ubGluayA8PSAxICYmXG4gICAgICAhaXNXaW5kb3dzXG4gIH1cblxuICAvLyBjaGVjayBpZiBhIHRoaW5nIGlzIHRoZXJlLCBhbmQgaWYgc28sIHRyeSB0byBjbG9iYmVyIGl0XG4gIFtDSEVDS0ZTXSAoZW50cnkpIHtcbiAgICB0aGlzW1BFTkRdKClcbiAgICBjb25zdCBwYXRocyA9IFtlbnRyeS5wYXRoXVxuICAgIGlmIChlbnRyeS5saW5rcGF0aClcbiAgICAgIHBhdGhzLnB1c2goZW50cnkubGlua3BhdGgpXG4gICAgdGhpcy5yZXNlcnZhdGlvbnMucmVzZXJ2ZShwYXRocywgZG9uZSA9PiB0aGlzW0NIRUNLRlMyXShlbnRyeSwgZG9uZSkpXG4gIH1cblxuICBbUFJVTkVDQUNIRV0gKGVudHJ5KSB7XG4gICAgLy8gaWYgd2UgYXJlIG5vdCBjcmVhdGluZyBhIGRpcmVjdG9yeSwgYW5kIHRoZSBwYXRoIGlzIGluIHRoZSBkaXJDYWNoZSxcbiAgICAvLyB0aGVuIHRoYXQgbWVhbnMgd2UgYXJlIGFib3V0IHRvIGRlbGV0ZSB0aGUgZGlyZWN0b3J5IHdlIGNyZWF0ZWRcbiAgICAvLyBwcmV2aW91c2x5LCBhbmQgaXQgaXMgbm8gbG9uZ2VyIGdvaW5nIHRvIGJlIGEgZGlyZWN0b3J5LCBhbmQgbmVpdGhlclxuICAgIC8vIGlzIGFueSBvZiBpdHMgY2hpbGRyZW4uXG4gICAgLy8gSWYgYSBzeW1ib2xpYyBsaW5rIGlzIGVuY291bnRlcmVkLCBhbGwgYmV0cyBhcmUgb2ZmLiAgVGhlcmUgaXMgbm9cbiAgICAvLyByZWFzb25hYmxlIHdheSB0byBzYW5pdGl6ZSB0aGUgY2FjaGUgaW4gc3VjaCBhIHdheSB3ZSB3aWxsIGJlIGFibGUgdG9cbiAgICAvLyBhdm9pZCBoYXZpbmcgZmlsZXN5c3RlbSBjb2xsaXNpb25zLiAgSWYgdGhpcyBoYXBwZW5zIHdpdGggYSBub24tc3ltbGlua1xuICAgIC8vIGVudHJ5LCBpdCdsbCBqdXN0IGZhaWwgdG8gdW5wYWNrLCBidXQgYSBzeW1saW5rIHRvIGEgZGlyZWN0b3J5LCB1c2luZyBhblxuICAgIC8vIDguMyBzaG9ydG5hbWUgb3IgY2VydGFpbiB1bmljb2RlIGF0dGFja3MsIGNhbiBldmFkZSBkZXRlY3Rpb24gYW5kIGxlYWRcbiAgICAvLyB0byBhcmJpdHJhcnkgd3JpdGVzIHRvIGFueXdoZXJlIG9uIHRoZSBzeXN0ZW0uXG4gICAgaWYgKGVudHJ5LnR5cGUgPT09ICdTeW1ib2xpY0xpbmsnKVxuICAgICAgZHJvcENhY2hlKHRoaXMuZGlyQ2FjaGUpXG4gICAgZWxzZSBpZiAoZW50cnkudHlwZSAhPT0gJ0RpcmVjdG9yeScpXG4gICAgICBwcnVuZUNhY2hlKHRoaXMuZGlyQ2FjaGUsIGVudHJ5LmFic29sdXRlKVxuICB9XG5cbiAgW0NIRUNLRlMyXSAoZW50cnksIGZ1bGx5RG9uZSkge1xuICAgIHRoaXNbUFJVTkVDQUNIRV0oZW50cnkpXG5cbiAgICBjb25zdCBkb25lID0gZXIgPT4ge1xuICAgICAgdGhpc1tQUlVORUNBQ0hFXShlbnRyeSlcbiAgICAgIGZ1bGx5RG9uZShlcilcbiAgICB9XG5cbiAgICBjb25zdCBjaGVja0N3ZCA9ICgpID0+IHtcbiAgICAgIHRoaXNbTUtESVJdKHRoaXMuY3dkLCB0aGlzLmRtb2RlLCBlciA9PiB7XG4gICAgICAgIGlmIChlcikge1xuICAgICAgICAgIHRoaXNbT05FUlJPUl0oZXIsIGVudHJ5KVxuICAgICAgICAgIGRvbmUoKVxuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIHRoaXNbQ0hFQ0tFRF9DV0RdID0gdHJ1ZVxuICAgICAgICBzdGFydCgpXG4gICAgICB9KVxuICAgIH1cblxuICAgIGNvbnN0IHN0YXJ0ID0gKCkgPT4ge1xuICAgICAgaWYgKGVudHJ5LmFic29sdXRlICE9PSB0aGlzLmN3ZCkge1xuICAgICAgICBjb25zdCBwYXJlbnQgPSBub3JtUGF0aChwYXRoLmRpcm5hbWUoZW50cnkuYWJzb2x1dGUpKVxuICAgICAgICBpZiAocGFyZW50ICE9PSB0aGlzLmN3ZCkge1xuICAgICAgICAgIHJldHVybiB0aGlzW01LRElSXShwYXJlbnQsIHRoaXMuZG1vZGUsIGVyID0+IHtcbiAgICAgICAgICAgIGlmIChlcikge1xuICAgICAgICAgICAgICB0aGlzW09ORVJST1JdKGVyLCBlbnRyeSlcbiAgICAgICAgICAgICAgZG9uZSgpXG4gICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWZ0ZXJNYWtlUGFyZW50KClcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBhZnRlck1ha2VQYXJlbnQoKVxuICAgIH1cblxuICAgIGNvbnN0IGFmdGVyTWFrZVBhcmVudCA9ICgpID0+IHtcbiAgICAgIGZzLmxzdGF0KGVudHJ5LmFic29sdXRlLCAobHN0YXRFciwgc3QpID0+IHtcbiAgICAgICAgaWYgKHN0ICYmICh0aGlzLmtlZXAgfHwgdGhpcy5uZXdlciAmJiBzdC5tdGltZSA+IGVudHJ5Lm10aW1lKSkge1xuICAgICAgICAgIHRoaXNbU0tJUF0oZW50cnkpXG4gICAgICAgICAgZG9uZSgpXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxzdGF0RXIgfHwgdGhpc1tJU1JFVVNBQkxFXShlbnRyeSwgc3QpKVxuICAgICAgICAgIHJldHVybiB0aGlzW01BS0VGU10obnVsbCwgZW50cnksIGRvbmUpXG5cbiAgICAgICAgaWYgKHN0LmlzRGlyZWN0b3J5KCkpIHtcbiAgICAgICAgICBpZiAoZW50cnkudHlwZSA9PT0gJ0RpcmVjdG9yeScpIHtcbiAgICAgICAgICAgIGNvbnN0IG5lZWRDaG1vZCA9ICF0aGlzLm5vQ2htb2QgJiZcbiAgICAgICAgICAgICAgZW50cnkubW9kZSAmJlxuICAgICAgICAgICAgICAoc3QubW9kZSAmIDBvNzc3NykgIT09IGVudHJ5Lm1vZGVcbiAgICAgICAgICAgIGNvbnN0IGFmdGVyQ2htb2QgPSBlciA9PiB0aGlzW01BS0VGU10oZXIsIGVudHJ5LCBkb25lKVxuICAgICAgICAgICAgaWYgKCFuZWVkQ2htb2QpXG4gICAgICAgICAgICAgIHJldHVybiBhZnRlckNobW9kKClcbiAgICAgICAgICAgIHJldHVybiBmcy5jaG1vZChlbnRyeS5hYnNvbHV0ZSwgZW50cnkubW9kZSwgYWZ0ZXJDaG1vZClcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gTm90IGEgZGlyIGVudHJ5LCBoYXZlIHRvIHJlbW92ZSBpdC5cbiAgICAgICAgICAvLyBOQjogdGhlIG9ubHkgd2F5IHRvIGVuZCB1cCB3aXRoIGFuIGVudHJ5IHRoYXQgaXMgdGhlIGN3ZFxuICAgICAgICAgIC8vIGl0c2VsZiwgaW4gc3VjaCBhIHdheSB0aGF0ID09IGRvZXMgbm90IGRldGVjdCwgaXMgYVxuICAgICAgICAgIC8vIHRyaWNreSB3aW5kb3dzIGFic29sdXRlIHBhdGggd2l0aCBVTkMgb3IgOC4zIHBhcnRzIChhbmRcbiAgICAgICAgICAvLyBwcmVzZXJ2ZVBhdGhzOnRydWUsIG9yIGVsc2UgaXQgd2lsbCBoYXZlIGJlZW4gc3RyaXBwZWQpLlxuICAgICAgICAgIC8vIEluIHRoYXQgY2FzZSwgdGhlIHVzZXIgaGFzIG9wdGVkIG91dCBvZiBwYXRoIHByb3RlY3Rpb25zXG4gICAgICAgICAgLy8gZXhwbGljaXRseSwgc28gaWYgdGhleSBibG93IGF3YXkgdGhlIGN3ZCwgYydlc3QgbGEgdmllLlxuICAgICAgICAgIGlmIChlbnRyeS5hYnNvbHV0ZSAhPT0gdGhpcy5jd2QpIHtcbiAgICAgICAgICAgIHJldHVybiBmcy5ybWRpcihlbnRyeS5hYnNvbHV0ZSwgZXIgPT5cbiAgICAgICAgICAgICAgdGhpc1tNQUtFRlNdKGVyLCBlbnRyeSwgZG9uZSkpXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gbm90IGEgZGlyLCBhbmQgbm90IHJldXNhYmxlXG4gICAgICAgIC8vIGRvbid0IHJlbW92ZSBpZiB0aGUgY3dkLCB3ZSB3YW50IHRoYXQgZXJyb3JcbiAgICAgICAgaWYgKGVudHJ5LmFic29sdXRlID09PSB0aGlzLmN3ZClcbiAgICAgICAgICByZXR1cm4gdGhpc1tNQUtFRlNdKG51bGwsIGVudHJ5LCBkb25lKVxuXG4gICAgICAgIHVubGlua0ZpbGUoZW50cnkuYWJzb2x1dGUsIGVyID0+XG4gICAgICAgICAgdGhpc1tNQUtFRlNdKGVyLCBlbnRyeSwgZG9uZSkpXG4gICAgICB9KVxuICAgIH1cblxuICAgIGlmICh0aGlzW0NIRUNLRURfQ1dEXSlcbiAgICAgIHN0YXJ0KClcbiAgICBlbHNlXG4gICAgICBjaGVja0N3ZCgpXG4gIH1cblxuICBbTUFLRUZTXSAoZXIsIGVudHJ5LCBkb25lKSB7XG4gICAgaWYgKGVyKVxuICAgICAgcmV0dXJuIHRoaXNbT05FUlJPUl0oZXIsIGVudHJ5KVxuXG4gICAgc3dpdGNoIChlbnRyeS50eXBlKSB7XG4gICAgICBjYXNlICdGaWxlJzpcbiAgICAgIGNhc2UgJ09sZEZpbGUnOlxuICAgICAgY2FzZSAnQ29udGlndW91c0ZpbGUnOlxuICAgICAgICByZXR1cm4gdGhpc1tGSUxFXShlbnRyeSwgZG9uZSlcblxuICAgICAgY2FzZSAnTGluayc6XG4gICAgICAgIHJldHVybiB0aGlzW0hBUkRMSU5LXShlbnRyeSwgZG9uZSlcblxuICAgICAgY2FzZSAnU3ltYm9saWNMaW5rJzpcbiAgICAgICAgcmV0dXJuIHRoaXNbU1lNTElOS10oZW50cnksIGRvbmUpXG5cbiAgICAgIGNhc2UgJ0RpcmVjdG9yeSc6XG4gICAgICBjYXNlICdHTlVEdW1wRGlyJzpcbiAgICAgICAgcmV0dXJuIHRoaXNbRElSRUNUT1JZXShlbnRyeSwgZG9uZSlcbiAgICB9XG4gIH1cblxuICBbTElOS10gKGVudHJ5LCBsaW5rcGF0aCwgbGluaywgZG9uZSkge1xuICAgIC8vIFhYWDogZ2V0IHRoZSB0eXBlICgnc3ltbGluaycgb3IgJ2p1bmN0aW9uJykgZm9yIHdpbmRvd3NcbiAgICBmc1tsaW5rXShsaW5rcGF0aCwgZW50cnkuYWJzb2x1dGUsIGVyID0+IHtcbiAgICAgIGlmIChlcilcbiAgICAgICAgcmV0dXJuIHRoaXNbT05FUlJPUl0oZXIsIGVudHJ5KVxuICAgICAgZG9uZSgpXG4gICAgICB0aGlzW1VOUEVORF0oKVxuICAgICAgZW50cnkucmVzdW1lKClcbiAgICB9KVxuICB9XG59XG5cbmNvbnN0IGNhbGxTeW5jID0gZm4gPT4ge1xuICB0cnkge1xuICAgIHJldHVybiBbbnVsbCwgZm4oKV1cbiAgfSBjYXRjaCAoZXIpIHtcbiAgICByZXR1cm4gW2VyLCBudWxsXVxuICB9XG59XG5jbGFzcyBVbnBhY2tTeW5jIGV4dGVuZHMgVW5wYWNrIHtcbiAgW01BS0VGU10gKGVyLCBlbnRyeSkge1xuICAgIHJldHVybiBzdXBlcltNQUtFRlNdKGVyLCBlbnRyeSwgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gKCkgPT4ge30pXG4gIH1cblxuICBbQ0hFQ0tGU10gKGVudHJ5KSB7XG4gICAgdGhpc1tQUlVORUNBQ0hFXShlbnRyeSlcblxuICAgIGlmICghdGhpc1tDSEVDS0VEX0NXRF0pIHtcbiAgICAgIGNvbnN0IGVyID0gdGhpc1tNS0RJUl0odGhpcy5jd2QsIHRoaXMuZG1vZGUpXG4gICAgICBpZiAoZXIpXG4gICAgICAgIHJldHVybiB0aGlzW09ORVJST1JdKGVyLCBlbnRyeSlcbiAgICAgIHRoaXNbQ0hFQ0tFRF9DV0RdID0gdHJ1ZVxuICAgIH1cblxuICAgIC8vIGRvbid0IGJvdGhlciB0byBtYWtlIHRoZSBwYXJlbnQgaWYgdGhlIGN1cnJlbnQgZW50cnkgaXMgdGhlIGN3ZCxcbiAgICAvLyB3ZSd2ZSBhbHJlYWR5IGNoZWNrZWQgaXQuXG4gICAgaWYgKGVudHJ5LmFic29sdXRlICE9PSB0aGlzLmN3ZCkge1xuICAgICAgY29uc3QgcGFyZW50ID0gbm9ybVBhdGgocGF0aC5kaXJuYW1lKGVudHJ5LmFic29sdXRlKSlcbiAgICAgIGlmIChwYXJlbnQgIT09IHRoaXMuY3dkKSB7XG4gICAgICAgIGNvbnN0IG1rUGFyZW50ID0gdGhpc1tNS0RJUl0ocGFyZW50LCB0aGlzLmRtb2RlKVxuICAgICAgICBpZiAobWtQYXJlbnQpXG4gICAgICAgICAgcmV0dXJuIHRoaXNbT05FUlJPUl0obWtQYXJlbnQsIGVudHJ5KVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IFtsc3RhdEVyLCBzdF0gPSBjYWxsU3luYygoKSA9PiBmcy5sc3RhdFN5bmMoZW50cnkuYWJzb2x1dGUpKVxuICAgIGlmIChzdCAmJiAodGhpcy5rZWVwIHx8IHRoaXMubmV3ZXIgJiYgc3QubXRpbWUgPiBlbnRyeS5tdGltZSkpXG4gICAgICByZXR1cm4gdGhpc1tTS0lQXShlbnRyeSlcblxuICAgIGlmIChsc3RhdEVyIHx8IHRoaXNbSVNSRVVTQUJMRV0oZW50cnksIHN0KSlcbiAgICAgIHJldHVybiB0aGlzW01BS0VGU10obnVsbCwgZW50cnkpXG5cbiAgICBpZiAoc3QuaXNEaXJlY3RvcnkoKSkge1xuICAgICAgaWYgKGVudHJ5LnR5cGUgPT09ICdEaXJlY3RvcnknKSB7XG4gICAgICAgIGNvbnN0IG5lZWRDaG1vZCA9ICF0aGlzLm5vQ2htb2QgJiZcbiAgICAgICAgICBlbnRyeS5tb2RlICYmXG4gICAgICAgICAgKHN0Lm1vZGUgJiAwbzc3NzcpICE9PSBlbnRyeS5tb2RlXG4gICAgICAgIGNvbnN0IFtlcl0gPSBuZWVkQ2htb2QgPyBjYWxsU3luYygoKSA9PiB7XG4gICAgICAgICAgZnMuY2htb2RTeW5jKGVudHJ5LmFic29sdXRlLCBlbnRyeS5tb2RlKVxuICAgICAgICB9KSA6IFtdXG4gICAgICAgIHJldHVybiB0aGlzW01BS0VGU10oZXIsIGVudHJ5KVxuICAgICAgfVxuICAgICAgLy8gbm90IGEgZGlyIGVudHJ5LCBoYXZlIHRvIHJlbW92ZSBpdFxuICAgICAgY29uc3QgW2VyXSA9IGNhbGxTeW5jKCgpID0+IGZzLnJtZGlyU3luYyhlbnRyeS5hYnNvbHV0ZSkpXG4gICAgICB0aGlzW01BS0VGU10oZXIsIGVudHJ5KVxuICAgIH1cblxuICAgIC8vIG5vdCBhIGRpciwgYW5kIG5vdCByZXVzYWJsZS5cbiAgICAvLyBkb24ndCByZW1vdmUgaWYgaXQncyB0aGUgY3dkLCBzaW5jZSB3ZSB3YW50IHRoYXQgZXJyb3IuXG4gICAgY29uc3QgW2VyXSA9IGVudHJ5LmFic29sdXRlID09PSB0aGlzLmN3ZCA/IFtdXG4gICAgICA6IGNhbGxTeW5jKCgpID0+IHVubGlua0ZpbGVTeW5jKGVudHJ5LmFic29sdXRlKSlcbiAgICB0aGlzW01BS0VGU10oZXIsIGVudHJ5KVxuICB9XG5cbiAgW0ZJTEVdIChlbnRyeSwgZG9uZSkge1xuICAgIGNvbnN0IG1vZGUgPSBlbnRyeS5tb2RlICYgMG83Nzc3IHx8IHRoaXMuZm1vZGVcblxuICAgIGNvbnN0IG9uZXIgPSBlciA9PiB7XG4gICAgICBsZXQgY2xvc2VFcnJvclxuICAgICAgdHJ5IHtcbiAgICAgICAgZnMuY2xvc2VTeW5jKGZkKVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjbG9zZUVycm9yID0gZVxuICAgICAgfVxuICAgICAgaWYgKGVyIHx8IGNsb3NlRXJyb3IpXG4gICAgICAgIHRoaXNbT05FUlJPUl0oZXIgfHwgY2xvc2VFcnJvciwgZW50cnkpXG4gICAgICBkb25lKClcbiAgICB9XG5cbiAgICBsZXQgc3RyZWFtXG4gICAgbGV0IGZkXG4gICAgdHJ5IHtcbiAgICAgIGZkID0gZnMub3BlblN5bmMoZW50cnkuYWJzb2x1dGUsICd3JywgbW9kZSlcbiAgICB9IGNhdGNoIChlcikge1xuICAgICAgcmV0dXJuIG9uZXIoZXIpXG4gICAgfVxuICAgIGNvbnN0IHR4ID0gdGhpcy50cmFuc2Zvcm0gPyB0aGlzLnRyYW5zZm9ybShlbnRyeSkgfHwgZW50cnkgOiBlbnRyeVxuICAgIGlmICh0eCAhPT0gZW50cnkpIHtcbiAgICAgIHR4Lm9uKCdlcnJvcicsIGVyID0+IHRoaXNbT05FUlJPUl0oZXIsIGVudHJ5KSlcbiAgICAgIGVudHJ5LnBpcGUodHgpXG4gICAgfVxuXG4gICAgdHgub24oJ2RhdGEnLCBjaHVuayA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBmcy53cml0ZVN5bmMoZmQsIGNodW5rLCAwLCBjaHVuay5sZW5ndGgpXG4gICAgICB9IGNhdGNoIChlcikge1xuICAgICAgICBvbmVyKGVyKVxuICAgICAgfVxuICAgIH0pXG5cbiAgICB0eC5vbignZW5kJywgXyA9PiB7XG4gICAgICBsZXQgZXIgPSBudWxsXG4gICAgICAvLyB0cnkgYm90aCwgZmFsbGluZyBmdXRpbWVzIGJhY2sgdG8gdXRpbWVzXG4gICAgICAvLyBpZiBlaXRoZXIgZmFpbHMsIGhhbmRsZSB0aGUgZmlyc3QgZXJyb3JcbiAgICAgIGlmIChlbnRyeS5tdGltZSAmJiAhdGhpcy5ub010aW1lKSB7XG4gICAgICAgIGNvbnN0IGF0aW1lID0gZW50cnkuYXRpbWUgfHwgbmV3IERhdGUoKVxuICAgICAgICBjb25zdCBtdGltZSA9IGVudHJ5Lm10aW1lXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZnMuZnV0aW1lc1N5bmMoZmQsIGF0aW1lLCBtdGltZSlcbiAgICAgICAgfSBjYXRjaCAoZnV0aW1lc2VyKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZzLnV0aW1lc1N5bmMoZW50cnkuYWJzb2x1dGUsIGF0aW1lLCBtdGltZSlcbiAgICAgICAgICB9IGNhdGNoICh1dGltZXNlcikge1xuICAgICAgICAgICAgZXIgPSBmdXRpbWVzZXJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXNbRE9DSE9XTl0oZW50cnkpKSB7XG4gICAgICAgIGNvbnN0IHVpZCA9IHRoaXNbVUlEXShlbnRyeSlcbiAgICAgICAgY29uc3QgZ2lkID0gdGhpc1tHSURdKGVudHJ5KVxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZnMuZmNob3duU3luYyhmZCwgdWlkLCBnaWQpXG4gICAgICAgIH0gY2F0Y2ggKGZjaG93bmVyKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZzLmNob3duU3luYyhlbnRyeS5hYnNvbHV0ZSwgdWlkLCBnaWQpXG4gICAgICAgICAgfSBjYXRjaCAoY2hvd25lcikge1xuICAgICAgICAgICAgZXIgPSBlciB8fCBmY2hvd25lclxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBvbmVyKGVyKVxuICAgIH0pXG4gIH1cblxuICBbRElSRUNUT1JZXSAoZW50cnksIGRvbmUpIHtcbiAgICBjb25zdCBtb2RlID0gZW50cnkubW9kZSAmIDBvNzc3NyB8fCB0aGlzLmRtb2RlXG4gICAgY29uc3QgZXIgPSB0aGlzW01LRElSXShlbnRyeS5hYnNvbHV0ZSwgbW9kZSlcbiAgICBpZiAoZXIpIHtcbiAgICAgIHRoaXNbT05FUlJPUl0oZXIsIGVudHJ5KVxuICAgICAgZG9uZSgpXG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgaWYgKGVudHJ5Lm10aW1lICYmICF0aGlzLm5vTXRpbWUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZzLnV0aW1lc1N5bmMoZW50cnkuYWJzb2x1dGUsIGVudHJ5LmF0aW1lIHx8IG5ldyBEYXRlKCksIGVudHJ5Lm10aW1lKVxuICAgICAgfSBjYXRjaCAoZXIpIHt9XG4gICAgfVxuICAgIGlmICh0aGlzW0RPQ0hPV05dKGVudHJ5KSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZnMuY2hvd25TeW5jKGVudHJ5LmFic29sdXRlLCB0aGlzW1VJRF0oZW50cnkpLCB0aGlzW0dJRF0oZW50cnkpKVxuICAgICAgfSBjYXRjaCAoZXIpIHt9XG4gICAgfVxuICAgIGRvbmUoKVxuICAgIGVudHJ5LnJlc3VtZSgpXG4gIH1cblxuICBbTUtESVJdIChkaXIsIG1vZGUpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIG1rZGlyLnN5bmMobm9ybVBhdGgoZGlyKSwge1xuICAgICAgICB1aWQ6IHRoaXMudWlkLFxuICAgICAgICBnaWQ6IHRoaXMuZ2lkLFxuICAgICAgICBwcm9jZXNzVWlkOiB0aGlzLnByb2Nlc3NVaWQsXG4gICAgICAgIHByb2Nlc3NHaWQ6IHRoaXMucHJvY2Vzc0dpZCxcbiAgICAgICAgdW1hc2s6IHRoaXMucHJvY2Vzc1VtYXNrLFxuICAgICAgICBwcmVzZXJ2ZTogdGhpcy5wcmVzZXJ2ZVBhdGhzLFxuICAgICAgICB1bmxpbms6IHRoaXMudW5saW5rLFxuICAgICAgICBjYWNoZTogdGhpcy5kaXJDYWNoZSxcbiAgICAgICAgY3dkOiB0aGlzLmN3ZCxcbiAgICAgICAgbW9kZTogbW9kZVxuICAgICAgfSlcbiAgICB9IGNhdGNoIChlcikge1xuICAgICAgcmV0dXJuIGVyXG4gICAgfVxuICB9XG5cbiAgW0xJTktdIChlbnRyeSwgbGlua3BhdGgsIGxpbmssIGRvbmUpIHtcbiAgICB0cnkge1xuICAgICAgZnNbbGluayArICdTeW5jJ10obGlua3BhdGgsIGVudHJ5LmFic29sdXRlKVxuICAgICAgZG9uZSgpXG4gICAgICBlbnRyeS5yZXN1bWUoKVxuICAgIH0gY2F0Y2ggKGVyKSB7XG4gICAgICByZXR1cm4gdGhpc1tPTkVSUk9SXShlciwgZW50cnkpXG4gICAgfVxuICB9XG59XG5cblVucGFjay5TeW5jID0gVW5wYWNrU3luY1xubW9kdWxlLmV4cG9ydHMgPSBVbnBhY2tcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/tar/lib/unpack.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/tar/lib/update.js":
/*!********************************************!*\
  !*** ../../node_modules/tar/lib/update.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n// tar -u\n\nconst hlo = __webpack_require__(/*! ./high-level-opt.js */ \"(rsc)/../../node_modules/tar/lib/high-level-opt.js\")\nconst r = __webpack_require__(/*! ./replace.js */ \"(rsc)/../../node_modules/tar/lib/replace.js\")\n// just call tar.r with the filter and mtimeCache\n\nconst u = module.exports = (opt_, files, cb) => {\n  const opt = hlo(opt_)\n\n  if (!opt.file)\n    throw new TypeError('file is required')\n\n  if (opt.gzip)\n    throw new TypeError('cannot append to compressed archives')\n\n  if (!files || !Array.isArray(files) || !files.length)\n    throw new TypeError('no files or directories specified')\n\n  files = Array.from(files)\n\n  mtimeFilter(opt)\n  return r(opt, files, cb)\n}\n\nconst mtimeFilter = opt => {\n  const filter = opt.filter\n\n  if (!opt.mtimeCache)\n    opt.mtimeCache = new Map()\n\n  opt.filter = filter ? (path, stat) =>\n    filter(path, stat) && !(opt.mtimeCache.get(path) > stat.mtime)\n    : (path, stat) => !(opt.mtimeCache.get(path) > stat.mtime)\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL3Rhci9saWIvdXBkYXRlLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaOztBQUVBLFlBQVksbUJBQU8sQ0FBQywrRUFBcUI7QUFDekMsVUFBVSxtQkFBTyxDQUFDLGlFQUFjO0FBQ2hDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvYmFyYi9hYS9Bc3NvY2lhdGVkQWNjb3VudHMvbm9kZV9tb2R1bGVzL3Rhci9saWIvdXBkYXRlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG4vLyB0YXIgLXVcblxuY29uc3QgaGxvID0gcmVxdWlyZSgnLi9oaWdoLWxldmVsLW9wdC5qcycpXG5jb25zdCByID0gcmVxdWlyZSgnLi9yZXBsYWNlLmpzJylcbi8vIGp1c3QgY2FsbCB0YXIuciB3aXRoIHRoZSBmaWx0ZXIgYW5kIG10aW1lQ2FjaGVcblxuY29uc3QgdSA9IG1vZHVsZS5leHBvcnRzID0gKG9wdF8sIGZpbGVzLCBjYikgPT4ge1xuICBjb25zdCBvcHQgPSBobG8ob3B0XylcblxuICBpZiAoIW9wdC5maWxlKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ZpbGUgaXMgcmVxdWlyZWQnKVxuXG4gIGlmIChvcHQuZ3ppcClcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdjYW5ub3QgYXBwZW5kIHRvIGNvbXByZXNzZWQgYXJjaGl2ZXMnKVxuXG4gIGlmICghZmlsZXMgfHwgIUFycmF5LmlzQXJyYXkoZmlsZXMpIHx8ICFmaWxlcy5sZW5ndGgpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbm8gZmlsZXMgb3IgZGlyZWN0b3JpZXMgc3BlY2lmaWVkJylcblxuICBmaWxlcyA9IEFycmF5LmZyb20oZmlsZXMpXG5cbiAgbXRpbWVGaWx0ZXIob3B0KVxuICByZXR1cm4gcihvcHQsIGZpbGVzLCBjYilcbn1cblxuY29uc3QgbXRpbWVGaWx0ZXIgPSBvcHQgPT4ge1xuICBjb25zdCBmaWx0ZXIgPSBvcHQuZmlsdGVyXG5cbiAgaWYgKCFvcHQubXRpbWVDYWNoZSlcbiAgICBvcHQubXRpbWVDYWNoZSA9IG5ldyBNYXAoKVxuXG4gIG9wdC5maWx0ZXIgPSBmaWx0ZXIgPyAocGF0aCwgc3RhdCkgPT5cbiAgICBmaWx0ZXIocGF0aCwgc3RhdCkgJiYgIShvcHQubXRpbWVDYWNoZS5nZXQocGF0aCkgPiBzdGF0Lm10aW1lKVxuICAgIDogKHBhdGgsIHN0YXQpID0+ICEob3B0Lm10aW1lQ2FjaGUuZ2V0KHBhdGgpID4gc3RhdC5tdGltZSlcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/tar/lib/update.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/tar/lib/warn-mixin.js":
/*!************************************************!*\
  !*** ../../node_modules/tar/lib/warn-mixin.js ***!
  \************************************************/
/***/ ((module) => {

"use strict";
eval("\nmodule.exports = Base => class extends Base {\n  warn (msg, data) {\n    if (!this.strict)\n      this.emit('warn', msg, data)\n    else if (data instanceof Error)\n      this.emit('error', data)\n    else {\n      const er = new Error(msg)\n      er.data = data\n      this.emit('error', er)\n    }\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL3Rhci9saWIvd2Fybi1taXhpbi5qcyIsIm1hcHBpbmdzIjoiQUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9iYXJiL2FhL0Fzc29jaWF0ZWRBY2NvdW50cy9ub2RlX21vZHVsZXMvdGFyL2xpYi93YXJuLW1peGluLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xubW9kdWxlLmV4cG9ydHMgPSBCYXNlID0+IGNsYXNzIGV4dGVuZHMgQmFzZSB7XG4gIHdhcm4gKG1zZywgZGF0YSkge1xuICAgIGlmICghdGhpcy5zdHJpY3QpXG4gICAgICB0aGlzLmVtaXQoJ3dhcm4nLCBtc2csIGRhdGEpXG4gICAgZWxzZSBpZiAoZGF0YSBpbnN0YW5jZW9mIEVycm9yKVxuICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIGRhdGEpXG4gICAgZWxzZSB7XG4gICAgICBjb25zdCBlciA9IG5ldyBFcnJvcihtc2cpXG4gICAgICBlci5kYXRhID0gZGF0YVxuICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIGVyKVxuICAgIH1cbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/tar/lib/warn-mixin.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/tar/lib/winchars.js":
/*!**********************************************!*\
  !*** ../../node_modules/tar/lib/winchars.js ***!
  \**********************************************/
/***/ ((module) => {

"use strict";
eval("\n\n// When writing files on Windows, translate the characters to their\n// 0xf000 higher-encoded versions.\n\nconst raw = [\n  '|',\n  '<',\n  '>',\n  '?',\n  ':'\n]\n\nconst win = raw.map(char =>\n  String.fromCharCode(0xf000 + char.charCodeAt(0)))\n\nconst toWin = new Map(raw.map((char, i) => [char, win[i]]))\nconst toRaw = new Map(win.map((char, i) => [char, raw[i]]))\n\nmodule.exports = {\n  encode: s => raw.reduce((s, c) => s.split(c).join(toWin.get(c)), s),\n  decode: s => win.reduce((s, c) => s.split(c).join(toRaw.get(c)), s)\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL3Rhci9saWIvd2luY2hhcnMuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVo7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL2JhcmIvYWEvQXNzb2NpYXRlZEFjY291bnRzL25vZGVfbW9kdWxlcy90YXIvbGliL3dpbmNoYXJzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG4vLyBXaGVuIHdyaXRpbmcgZmlsZXMgb24gV2luZG93cywgdHJhbnNsYXRlIHRoZSBjaGFyYWN0ZXJzIHRvIHRoZWlyXG4vLyAweGYwMDAgaGlnaGVyLWVuY29kZWQgdmVyc2lvbnMuXG5cbmNvbnN0IHJhdyA9IFtcbiAgJ3wnLFxuICAnPCcsXG4gICc+JyxcbiAgJz8nLFxuICAnOidcbl1cblxuY29uc3Qgd2luID0gcmF3Lm1hcChjaGFyID0+XG4gIFN0cmluZy5mcm9tQ2hhckNvZGUoMHhmMDAwICsgY2hhci5jaGFyQ29kZUF0KDApKSlcblxuY29uc3QgdG9XaW4gPSBuZXcgTWFwKHJhdy5tYXAoKGNoYXIsIGkpID0+IFtjaGFyLCB3aW5baV1dKSlcbmNvbnN0IHRvUmF3ID0gbmV3IE1hcCh3aW4ubWFwKChjaGFyLCBpKSA9PiBbY2hhciwgcmF3W2ldXSkpXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBlbmNvZGU6IHMgPT4gcmF3LnJlZHVjZSgocywgYykgPT4gcy5zcGxpdChjKS5qb2luKHRvV2luLmdldChjKSksIHMpLFxuICBkZWNvZGU6IHMgPT4gd2luLnJlZHVjZSgocywgYykgPT4gcy5zcGxpdChjKS5qb2luKHRvUmF3LmdldChjKSksIHMpXG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/tar/lib/winchars.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/tar/lib/write-entry.js":
/*!*************************************************!*\
  !*** ../../node_modules/tar/lib/write-entry.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst Buffer = __webpack_require__(/*! ./buffer.js */ \"(rsc)/../../node_modules/tar/lib/buffer.js\")\nconst MiniPass = __webpack_require__(/*! minipass */ \"(rsc)/../../node_modules/minipass/index.js\")\nconst Pax = __webpack_require__(/*! ./pax.js */ \"(rsc)/../../node_modules/tar/lib/pax.js\")\nconst Header = __webpack_require__(/*! ./header.js */ \"(rsc)/../../node_modules/tar/lib/header.js\")\nconst ReadEntry = __webpack_require__(/*! ./read-entry.js */ \"(rsc)/../../node_modules/tar/lib/read-entry.js\")\nconst fs = __webpack_require__(/*! fs */ \"fs\")\nconst path = __webpack_require__(/*! path */ \"path\")\nconst normPath = __webpack_require__(/*! ./normalize-windows-path.js */ \"(rsc)/../../node_modules/tar/lib/normalize-windows-path.js\")\nconst stripSlash = __webpack_require__(/*! ./strip-trailing-slashes.js */ \"(rsc)/../../node_modules/tar/lib/strip-trailing-slashes.js\")\n\nconst prefixPath = (path, prefix) => {\n  if (!prefix)\n    return path\n  path = normPath(path).replace(/^\\.(\\/|$)/, '')\n  return stripSlash(prefix) + '/' + path\n}\n\nconst maxReadSize = 16 * 1024 * 1024\nconst PROCESS = Symbol('process')\nconst FILE = Symbol('file')\nconst DIRECTORY = Symbol('directory')\nconst SYMLINK = Symbol('symlink')\nconst HARDLINK = Symbol('hardlink')\nconst HEADER = Symbol('header')\nconst READ = Symbol('read')\nconst LSTAT = Symbol('lstat')\nconst ONLSTAT = Symbol('onlstat')\nconst ONREAD = Symbol('onread')\nconst ONREADLINK = Symbol('onreadlink')\nconst OPENFILE = Symbol('openfile')\nconst ONOPENFILE = Symbol('onopenfile')\nconst CLOSE = Symbol('close')\nconst MODE = Symbol('mode')\nconst AWAITDRAIN = Symbol('awaitDrain')\nconst ONDRAIN = Symbol('ondrain')\nconst PREFIX = Symbol('prefix')\nconst HAD_ERROR = Symbol('hadError')\nconst warner = __webpack_require__(/*! ./warn-mixin.js */ \"(rsc)/../../node_modules/tar/lib/warn-mixin.js\")\nconst winchars = __webpack_require__(/*! ./winchars.js */ \"(rsc)/../../node_modules/tar/lib/winchars.js\")\nconst stripAbsolutePath = __webpack_require__(/*! ./strip-absolute-path.js */ \"(rsc)/../../node_modules/tar/lib/strip-absolute-path.js\")\n\nconst modeFix = __webpack_require__(/*! ./mode-fix.js */ \"(rsc)/../../node_modules/tar/lib/mode-fix.js\")\n\nconst WriteEntry = warner(class WriteEntry extends MiniPass {\n  constructor (p, opt) {\n    opt = opt || {}\n    super(opt)\n    if (typeof p !== 'string')\n      throw new TypeError('path is required')\n    this.path = normPath(p)\n    // suppress atime, ctime, uid, gid, uname, gname\n    this.portable = !!opt.portable\n    // until node has builtin pwnam functions, this'll have to do\n    this.myuid = process.getuid && process.getuid() || 0\n    this.myuser = process.env.USER || ''\n    this.maxReadSize = opt.maxReadSize || maxReadSize\n    this.linkCache = opt.linkCache || new Map()\n    this.statCache = opt.statCache || new Map()\n    this.preservePaths = !!opt.preservePaths\n    this.cwd = normPath(opt.cwd || process.cwd())\n    this.strict = !!opt.strict\n    this.noPax = !!opt.noPax\n    this.noMtime = !!opt.noMtime\n    this.mtime = opt.mtime || null\n    this.prefix = opt.prefix ? normPath(opt.prefix) : null\n\n    this.fd = null\n    this.blockLen = null\n    this.blockRemain = null\n    this.buf = null\n    this.offset = null\n    this.length = null\n    this.pos = null\n    this.remain = null\n\n    if (typeof opt.onwarn === 'function')\n      this.on('warn', opt.onwarn)\n\n    if (!this.preservePaths) {\n      const s = stripAbsolutePath(this.path)\n      if (s[0]) {\n        this.warn('stripping ' + s[0] + ' from absolute path', this.path)\n        this.path = s[1]\n      }\n    }\n\n    this.win32 = !!opt.win32 || process.platform === 'win32'\n    if (this.win32) {\n      // force the \\ to / normalization, since we might not *actually*\n      // be on windows, but want \\ to be considered a path separator.\n      this.path = winchars.decode(this.path.replace(/\\\\/g, '/'))\n      p = p.replace(/\\\\/g, '/')\n    }\n\n    this.absolute = normPath(opt.absolute || path.resolve(this.cwd, p))\n\n    if (this.path === '')\n      this.path = './'\n\n    if (this.statCache.has(this.absolute))\n      this[ONLSTAT](this.statCache.get(this.absolute))\n    else\n      this[LSTAT]()\n  }\n\n  emit (ev, ...data) {\n    if (ev === 'error')\n      this[HAD_ERROR] = true\n    return super.emit(ev, ...data)\n  }\n\n  [LSTAT] () {\n    fs.lstat(this.absolute, (er, stat) => {\n      if (er)\n        return this.emit('error', er)\n      this[ONLSTAT](stat)\n    })\n  }\n\n  [ONLSTAT] (stat) {\n    this.statCache.set(this.absolute, stat)\n    this.stat = stat\n    if (!stat.isFile())\n      stat.size = 0\n    this.type = getType(stat)\n    this.emit('stat', stat)\n    this[PROCESS]()\n  }\n\n  [PROCESS] () {\n    switch (this.type) {\n      case 'File': return this[FILE]()\n      case 'Directory': return this[DIRECTORY]()\n      case 'SymbolicLink': return this[SYMLINK]()\n      // unsupported types are ignored.\n      default: return this.end()\n    }\n  }\n\n  [MODE] (mode) {\n    return modeFix(mode, this.type === 'Directory')\n  }\n\n  [PREFIX] (path) {\n    return prefixPath(path, this.prefix)\n  }\n\n  [HEADER] () {\n    if (this.type === 'Directory' && this.portable)\n      this.noMtime = true\n\n    this.header = new Header({\n      path: this[PREFIX](this.path),\n      // only apply the prefix to hard links.\n      linkpath: this.type === 'Link' ? this[PREFIX](this.linkpath)\n      : this.linkpath,\n      // only the permissions and setuid/setgid/sticky bitflags\n      // not the higher-order bits that specify file type\n      mode: this[MODE](this.stat.mode),\n      uid: this.portable ? null : this.stat.uid,\n      gid: this.portable ? null : this.stat.gid,\n      size: this.stat.size,\n      mtime: this.noMtime ? null : this.mtime || this.stat.mtime,\n      type: this.type,\n      uname: this.portable ? null :\n        this.stat.uid === this.myuid ? this.myuser : '',\n      atime: this.portable ? null : this.stat.atime,\n      ctime: this.portable ? null : this.stat.ctime\n    })\n\n    if (this.header.encode() && !this.noPax) {\n      super.write(new Pax({\n        atime: this.portable ? null : this.header.atime,\n        ctime: this.portable ? null : this.header.ctime,\n        gid: this.portable ? null : this.header.gid,\n        mtime: this.noMtime ? null : this.mtime || this.header.mtime,\n        path: this[PREFIX](this.path),\n        linkpath: this.type === 'Link' ? this[PREFIX](this.linkpath)\n        : this.linkpath,\n        size: this.header.size,\n        uid: this.portable ? null : this.header.uid,\n        uname: this.portable ? null : this.header.uname,\n        dev: this.portable ? null : this.stat.dev,\n        ino: this.portable ? null : this.stat.ino,\n        nlink: this.portable ? null : this.stat.nlink\n      }).encode())\n    }\n    super.write(this.header.block)\n  }\n\n  [DIRECTORY] () {\n    if (this.path.substr(-1) !== '/')\n      this.path += '/'\n    this.stat.size = 0\n    this[HEADER]()\n    this.end()\n  }\n\n  [SYMLINK] () {\n    fs.readlink(this.absolute, (er, linkpath) => {\n      if (er)\n        return this.emit('error', er)\n      this[ONREADLINK](linkpath)\n    })\n  }\n\n  [ONREADLINK] (linkpath) {\n    this.linkpath = normPath(linkpath)\n    this[HEADER]()\n    this.end()\n  }\n\n  [HARDLINK] (linkpath) {\n    this.type = 'Link'\n    this.linkpath = normPath(path.relative(this.cwd, linkpath))\n    this.stat.size = 0\n    this[HEADER]()\n    this.end()\n  }\n\n  [FILE] () {\n    if (this.stat.nlink > 1) {\n      const linkKey = this.stat.dev + ':' + this.stat.ino\n      if (this.linkCache.has(linkKey)) {\n        const linkpath = this.linkCache.get(linkKey)\n        if (linkpath.indexOf(this.cwd) === 0)\n          return this[HARDLINK](linkpath)\n      }\n      this.linkCache.set(linkKey, this.absolute)\n    }\n\n    this[HEADER]()\n    if (this.stat.size === 0)\n      return this.end()\n\n    this[OPENFILE]()\n  }\n\n  [OPENFILE] () {\n    fs.open(this.absolute, 'r', (er, fd) => {\n      if (er)\n        return this.emit('error', er)\n      this[ONOPENFILE](fd)\n    })\n  }\n\n  [ONOPENFILE] (fd) {\n    this.fd = fd\n    if (this[HAD_ERROR])\n      return this[CLOSE]()\n\n    this.blockLen = 512 * Math.ceil(this.stat.size / 512)\n    this.blockRemain = this.blockLen\n    const bufLen = Math.min(this.blockLen, this.maxReadSize)\n    this.buf = Buffer.allocUnsafe(bufLen)\n    this.offset = 0\n    this.pos = 0\n    this.remain = this.stat.size\n    this.length = this.buf.length\n    this[READ]()\n  }\n\n  [READ] () {\n    const { fd, buf, offset, length, pos } = this\n    fs.read(fd, buf, offset, length, pos, (er, bytesRead) => {\n      if (er) {\n        // ignoring the error from close(2) is a bad practice, but at\n        // this point we already have an error, don't need another one\n        return this[CLOSE](() => this.emit('error', er))\n      }\n      this[ONREAD](bytesRead)\n    })\n  }\n\n  [CLOSE] (cb) {\n    fs.close(this.fd, cb)\n  }\n\n  [ONREAD] (bytesRead) {\n    if (bytesRead <= 0 && this.remain > 0) {\n      const er = new Error('encountered unexpected EOF')\n      er.path = this.absolute\n      er.syscall = 'read'\n      er.code = 'EOF'\n      return this[CLOSE](() => this.emit('error', er))\n    }\n\n    if (bytesRead > this.remain) {\n      const er = new Error('did not encounter expected EOF')\n      er.path = this.absolute\n      er.syscall = 'read'\n      er.code = 'EOF'\n      return this[CLOSE](() => this.emit('error', er))\n    }\n\n    // null out the rest of the buffer, if we could fit the block padding\n    // at the end of this loop, we've incremented bytesRead and this.remain\n    // to be incremented up to the blockRemain level, as if we had expected\n    // to get a null-padded file, and read it until the end.  then we will\n    // decrement both remain and blockRemain by bytesRead, and know that we\n    // reached the expected EOF, without any null buffer to append.\n    if (bytesRead === this.remain) {\n      for (let i = bytesRead; i < this.length && bytesRead < this.blockRemain; i++) {\n        this.buf[i + this.offset] = 0\n        bytesRead++\n        this.remain++\n      }\n    }\n\n    const writeBuf = this.offset === 0 && bytesRead === this.buf.length ?\n      this.buf : this.buf.slice(this.offset, this.offset + bytesRead)\n\n    const flushed = this.write(writeBuf)\n    if (!flushed)\n      this[AWAITDRAIN](() => this[ONDRAIN]())\n    else\n      this[ONDRAIN]()\n  }\n\n  [AWAITDRAIN] (cb) {\n    this.once('drain', cb)\n  }\n\n  write (writeBuf) {\n    if (this.blockRemain < writeBuf.length) {\n      const er = new Error('writing more data than expected')\n      er.path = this.absolute\n      return this.emit('error', er)\n    }\n    this.remain -= writeBuf.length\n    this.blockRemain -= writeBuf.length\n    this.pos += writeBuf.length\n    this.offset += writeBuf.length\n    return super.write(writeBuf)\n  }\n\n  [ONDRAIN] () {\n    if (!this.remain) {\n      if (this.blockRemain)\n        super.write(Buffer.alloc(this.blockRemain))\n      return this[CLOSE](/* istanbul ignore next - legacy */\n        er => er ? this.emit('error', er) : this.end())\n    }\n\n    if (this.offset >= this.length) {\n      // if we only have a smaller bit left to read, alloc a smaller buffer\n      // otherwise, keep it the same length it was before.\n      this.buf = Buffer.allocUnsafe(Math.min(this.blockRemain, this.buf.length))\n      this.offset = 0\n    }\n    this.length = this.buf.length - this.offset\n    this[READ]()\n  }\n})\n\nclass WriteEntrySync extends WriteEntry {\n  constructor (path, opt) {\n    super(path, opt)\n  }\n\n  [LSTAT] () {\n    this[ONLSTAT](fs.lstatSync(this.absolute))\n  }\n\n  [SYMLINK] () {\n    this[ONREADLINK](fs.readlinkSync(this.absolute))\n  }\n\n  [OPENFILE] () {\n    this[ONOPENFILE](fs.openSync(this.absolute, 'r'))\n  }\n\n  [READ] () {\n    let threw = true\n    try {\n      const { fd, buf, offset, length, pos } = this\n      const bytesRead = fs.readSync(fd, buf, offset, length, pos)\n      this[ONREAD](bytesRead)\n      threw = false\n    } finally {\n      // ignoring the error from close(2) is a bad practice, but at\n      // this point we already have an error, don't need another one\n      if (threw) {\n        try {\n          this[CLOSE](() => {})\n        } catch (er) {}\n      }\n    }\n  }\n\n  [AWAITDRAIN] (cb) {\n    cb()\n  }\n\n  [CLOSE] (cb) {\n    fs.closeSync(this.fd)\n    cb()\n  }\n}\n\nconst WriteEntryTar = warner(class WriteEntryTar extends MiniPass {\n  constructor (readEntry, opt) {\n    opt = opt || {}\n    super(opt)\n    this.preservePaths = !!opt.preservePaths\n    this.portable = !!opt.portable\n    this.strict = !!opt.strict\n    this.noPax = !!opt.noPax\n    this.noMtime = !!opt.noMtime\n\n    this.readEntry = readEntry\n    this.type = readEntry.type\n    if (this.type === 'Directory' && this.portable)\n      this.noMtime = true\n\n    this.prefix = opt.prefix || null\n\n    this.path = normPath(readEntry.path)\n    this.mode = this[MODE](readEntry.mode)\n    this.uid = this.portable ? null : readEntry.uid\n    this.gid = this.portable ? null : readEntry.gid\n    this.uname = this.portable ? null : readEntry.uname\n    this.gname = this.portable ? null : readEntry.gname\n    this.size = readEntry.size\n    this.mtime = this.noMtime ? null : opt.mtime || readEntry.mtime\n    this.atime = this.portable ? null : readEntry.atime\n    this.ctime = this.portable ? null : readEntry.ctime\n    this.linkpath = normPath(readEntry.linkpath)\n\n    if (typeof opt.onwarn === 'function')\n      this.on('warn', opt.onwarn)\n\n    if (!this.preservePaths) {\n      const s = stripAbsolutePath(this.path)\n      if (s[0]) {\n        this.warn(\n          'stripping ' + s[0] + ' from absolute path',\n          this.path\n        )\n        this.path = s[1]\n      }\n    }\n\n    this.remain = readEntry.size\n    this.blockRemain = readEntry.startBlockSize\n\n    this.header = new Header({\n      path: this[PREFIX](this.path),\n      linkpath: this.type === 'Link' ? this[PREFIX](this.linkpath)\n      : this.linkpath,\n      // only the permissions and setuid/setgid/sticky bitflags\n      // not the higher-order bits that specify file type\n      mode: this.mode,\n      uid: this.portable ? null : this.uid,\n      gid: this.portable ? null : this.gid,\n      size: this.size,\n      mtime: this.noMtime ? null : this.mtime,\n      type: this.type,\n      uname: this.portable ? null : this.uname,\n      atime: this.portable ? null : this.atime,\n      ctime: this.portable ? null : this.ctime\n    })\n\n    if (this.header.encode() && !this.noPax)\n      super.write(new Pax({\n        atime: this.portable ? null : this.atime,\n        ctime: this.portable ? null : this.ctime,\n        gid: this.portable ? null : this.gid,\n        mtime: this.noMtime ? null : this.mtime,\n        path: this[PREFIX](this.path),\n        linkpath: this.type === 'Link' ? this[PREFIX](this.linkpath)\n        : this.linkpath,\n        size: this.size,\n        uid: this.portable ? null : this.uid,\n        uname: this.portable ? null : this.uname,\n        dev: this.portable ? null : this.readEntry.dev,\n        ino: this.portable ? null : this.readEntry.ino,\n        nlink: this.portable ? null : this.readEntry.nlink\n      }).encode())\n\n    super.write(this.header.block)\n    readEntry.pipe(this)\n  }\n\n  [PREFIX] (path) {\n    return prefixPath(path, this.prefix)\n  }\n\n  [MODE] (mode) {\n    return modeFix(mode, this.type === 'Directory')\n  }\n\n  write (data) {\n    const writeLen = data.length\n    if (writeLen > this.blockRemain)\n      throw new Error('writing more to entry than is appropriate')\n    this.blockRemain -= writeLen\n    return super.write(data)\n  }\n\n  end () {\n    if (this.blockRemain)\n      super.write(Buffer.alloc(this.blockRemain))\n    return super.end()\n  }\n})\n\nWriteEntry.Sync = WriteEntrySync\nWriteEntry.Tar = WriteEntryTar\n\nconst getType = stat =>\n  stat.isFile() ? 'File'\n  : stat.isDirectory() ? 'Directory'\n  : stat.isSymbolicLink() ? 'SymbolicLink'\n  : 'Unsupported'\n\nmodule.exports = WriteEntry\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL3Rhci9saWIvd3JpdGUtZW50cnkuanMiLCJtYXBwaW5ncyI6IkFBQVk7QUFDWixlQUFlLG1CQUFPLENBQUMsK0RBQWE7QUFDcEMsaUJBQWlCLG1CQUFPLENBQUMsNERBQVU7QUFDbkMsWUFBWSxtQkFBTyxDQUFDLHlEQUFVO0FBQzlCLGVBQWUsbUJBQU8sQ0FBQywrREFBYTtBQUNwQyxrQkFBa0IsbUJBQU8sQ0FBQyx1RUFBaUI7QUFDM0MsV0FBVyxtQkFBTyxDQUFDLGNBQUk7QUFDdkIsYUFBYSxtQkFBTyxDQUFDLGtCQUFNO0FBQzNCLGlCQUFpQixtQkFBTyxDQUFDLCtGQUE2QjtBQUN0RCxtQkFBbUIsbUJBQU8sQ0FBQywrRkFBNkI7O0FBRXhEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxtQkFBTyxDQUFDLHVFQUFpQjtBQUN4QyxpQkFBaUIsbUJBQU8sQ0FBQyxtRUFBZTtBQUN4QywwQkFBMEIsbUJBQU8sQ0FBQyx5RkFBMEI7O0FBRTVELGdCQUFnQixtQkFBTyxDQUFDLG1FQUFlOztBQUV2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLCtCQUErQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixpREFBaUQ7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYywrQkFBK0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIi9ob21lL2JhcmIvYWEvQXNzb2NpYXRlZEFjY291bnRzL25vZGVfbW9kdWxlcy90YXIvbGliL3dyaXRlLWVudHJ5LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuY29uc3QgQnVmZmVyID0gcmVxdWlyZSgnLi9idWZmZXIuanMnKVxuY29uc3QgTWluaVBhc3MgPSByZXF1aXJlKCdtaW5pcGFzcycpXG5jb25zdCBQYXggPSByZXF1aXJlKCcuL3BheC5qcycpXG5jb25zdCBIZWFkZXIgPSByZXF1aXJlKCcuL2hlYWRlci5qcycpXG5jb25zdCBSZWFkRW50cnkgPSByZXF1aXJlKCcuL3JlYWQtZW50cnkuanMnKVxuY29uc3QgZnMgPSByZXF1aXJlKCdmcycpXG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpXG5jb25zdCBub3JtUGF0aCA9IHJlcXVpcmUoJy4vbm9ybWFsaXplLXdpbmRvd3MtcGF0aC5qcycpXG5jb25zdCBzdHJpcFNsYXNoID0gcmVxdWlyZSgnLi9zdHJpcC10cmFpbGluZy1zbGFzaGVzLmpzJylcblxuY29uc3QgcHJlZml4UGF0aCA9IChwYXRoLCBwcmVmaXgpID0+IHtcbiAgaWYgKCFwcmVmaXgpXG4gICAgcmV0dXJuIHBhdGhcbiAgcGF0aCA9IG5vcm1QYXRoKHBhdGgpLnJlcGxhY2UoL15cXC4oXFwvfCQpLywgJycpXG4gIHJldHVybiBzdHJpcFNsYXNoKHByZWZpeCkgKyAnLycgKyBwYXRoXG59XG5cbmNvbnN0IG1heFJlYWRTaXplID0gMTYgKiAxMDI0ICogMTAyNFxuY29uc3QgUFJPQ0VTUyA9IFN5bWJvbCgncHJvY2VzcycpXG5jb25zdCBGSUxFID0gU3ltYm9sKCdmaWxlJylcbmNvbnN0IERJUkVDVE9SWSA9IFN5bWJvbCgnZGlyZWN0b3J5JylcbmNvbnN0IFNZTUxJTksgPSBTeW1ib2woJ3N5bWxpbmsnKVxuY29uc3QgSEFSRExJTksgPSBTeW1ib2woJ2hhcmRsaW5rJylcbmNvbnN0IEhFQURFUiA9IFN5bWJvbCgnaGVhZGVyJylcbmNvbnN0IFJFQUQgPSBTeW1ib2woJ3JlYWQnKVxuY29uc3QgTFNUQVQgPSBTeW1ib2woJ2xzdGF0JylcbmNvbnN0IE9OTFNUQVQgPSBTeW1ib2woJ29ubHN0YXQnKVxuY29uc3QgT05SRUFEID0gU3ltYm9sKCdvbnJlYWQnKVxuY29uc3QgT05SRUFETElOSyA9IFN5bWJvbCgnb25yZWFkbGluaycpXG5jb25zdCBPUEVORklMRSA9IFN5bWJvbCgnb3BlbmZpbGUnKVxuY29uc3QgT05PUEVORklMRSA9IFN5bWJvbCgnb25vcGVuZmlsZScpXG5jb25zdCBDTE9TRSA9IFN5bWJvbCgnY2xvc2UnKVxuY29uc3QgTU9ERSA9IFN5bWJvbCgnbW9kZScpXG5jb25zdCBBV0FJVERSQUlOID0gU3ltYm9sKCdhd2FpdERyYWluJylcbmNvbnN0IE9ORFJBSU4gPSBTeW1ib2woJ29uZHJhaW4nKVxuY29uc3QgUFJFRklYID0gU3ltYm9sKCdwcmVmaXgnKVxuY29uc3QgSEFEX0VSUk9SID0gU3ltYm9sKCdoYWRFcnJvcicpXG5jb25zdCB3YXJuZXIgPSByZXF1aXJlKCcuL3dhcm4tbWl4aW4uanMnKVxuY29uc3Qgd2luY2hhcnMgPSByZXF1aXJlKCcuL3dpbmNoYXJzLmpzJylcbmNvbnN0IHN0cmlwQWJzb2x1dGVQYXRoID0gcmVxdWlyZSgnLi9zdHJpcC1hYnNvbHV0ZS1wYXRoLmpzJylcblxuY29uc3QgbW9kZUZpeCA9IHJlcXVpcmUoJy4vbW9kZS1maXguanMnKVxuXG5jb25zdCBXcml0ZUVudHJ5ID0gd2FybmVyKGNsYXNzIFdyaXRlRW50cnkgZXh0ZW5kcyBNaW5pUGFzcyB7XG4gIGNvbnN0cnVjdG9yIChwLCBvcHQpIHtcbiAgICBvcHQgPSBvcHQgfHwge31cbiAgICBzdXBlcihvcHQpXG4gICAgaWYgKHR5cGVvZiBwICE9PSAnc3RyaW5nJylcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3BhdGggaXMgcmVxdWlyZWQnKVxuICAgIHRoaXMucGF0aCA9IG5vcm1QYXRoKHApXG4gICAgLy8gc3VwcHJlc3MgYXRpbWUsIGN0aW1lLCB1aWQsIGdpZCwgdW5hbWUsIGduYW1lXG4gICAgdGhpcy5wb3J0YWJsZSA9ICEhb3B0LnBvcnRhYmxlXG4gICAgLy8gdW50aWwgbm9kZSBoYXMgYnVpbHRpbiBwd25hbSBmdW5jdGlvbnMsIHRoaXMnbGwgaGF2ZSB0byBkb1xuICAgIHRoaXMubXl1aWQgPSBwcm9jZXNzLmdldHVpZCAmJiBwcm9jZXNzLmdldHVpZCgpIHx8IDBcbiAgICB0aGlzLm15dXNlciA9IHByb2Nlc3MuZW52LlVTRVIgfHwgJydcbiAgICB0aGlzLm1heFJlYWRTaXplID0gb3B0Lm1heFJlYWRTaXplIHx8IG1heFJlYWRTaXplXG4gICAgdGhpcy5saW5rQ2FjaGUgPSBvcHQubGlua0NhY2hlIHx8IG5ldyBNYXAoKVxuICAgIHRoaXMuc3RhdENhY2hlID0gb3B0LnN0YXRDYWNoZSB8fCBuZXcgTWFwKClcbiAgICB0aGlzLnByZXNlcnZlUGF0aHMgPSAhIW9wdC5wcmVzZXJ2ZVBhdGhzXG4gICAgdGhpcy5jd2QgPSBub3JtUGF0aChvcHQuY3dkIHx8IHByb2Nlc3MuY3dkKCkpXG4gICAgdGhpcy5zdHJpY3QgPSAhIW9wdC5zdHJpY3RcbiAgICB0aGlzLm5vUGF4ID0gISFvcHQubm9QYXhcbiAgICB0aGlzLm5vTXRpbWUgPSAhIW9wdC5ub010aW1lXG4gICAgdGhpcy5tdGltZSA9IG9wdC5tdGltZSB8fCBudWxsXG4gICAgdGhpcy5wcmVmaXggPSBvcHQucHJlZml4ID8gbm9ybVBhdGgob3B0LnByZWZpeCkgOiBudWxsXG5cbiAgICB0aGlzLmZkID0gbnVsbFxuICAgIHRoaXMuYmxvY2tMZW4gPSBudWxsXG4gICAgdGhpcy5ibG9ja1JlbWFpbiA9IG51bGxcbiAgICB0aGlzLmJ1ZiA9IG51bGxcbiAgICB0aGlzLm9mZnNldCA9IG51bGxcbiAgICB0aGlzLmxlbmd0aCA9IG51bGxcbiAgICB0aGlzLnBvcyA9IG51bGxcbiAgICB0aGlzLnJlbWFpbiA9IG51bGxcblxuICAgIGlmICh0eXBlb2Ygb3B0Lm9ud2FybiA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgIHRoaXMub24oJ3dhcm4nLCBvcHQub253YXJuKVxuXG4gICAgaWYgKCF0aGlzLnByZXNlcnZlUGF0aHMpIHtcbiAgICAgIGNvbnN0IHMgPSBzdHJpcEFic29sdXRlUGF0aCh0aGlzLnBhdGgpXG4gICAgICBpZiAoc1swXSkge1xuICAgICAgICB0aGlzLndhcm4oJ3N0cmlwcGluZyAnICsgc1swXSArICcgZnJvbSBhYnNvbHV0ZSBwYXRoJywgdGhpcy5wYXRoKVxuICAgICAgICB0aGlzLnBhdGggPSBzWzFdXG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy53aW4zMiA9ICEhb3B0LndpbjMyIHx8IHByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMidcbiAgICBpZiAodGhpcy53aW4zMikge1xuICAgICAgLy8gZm9yY2UgdGhlIFxcIHRvIC8gbm9ybWFsaXphdGlvbiwgc2luY2Ugd2UgbWlnaHQgbm90ICphY3R1YWxseSpcbiAgICAgIC8vIGJlIG9uIHdpbmRvd3MsIGJ1dCB3YW50IFxcIHRvIGJlIGNvbnNpZGVyZWQgYSBwYXRoIHNlcGFyYXRvci5cbiAgICAgIHRoaXMucGF0aCA9IHdpbmNoYXJzLmRlY29kZSh0aGlzLnBhdGgucmVwbGFjZSgvXFxcXC9nLCAnLycpKVxuICAgICAgcCA9IHAucmVwbGFjZSgvXFxcXC9nLCAnLycpXG4gICAgfVxuXG4gICAgdGhpcy5hYnNvbHV0ZSA9IG5vcm1QYXRoKG9wdC5hYnNvbHV0ZSB8fCBwYXRoLnJlc29sdmUodGhpcy5jd2QsIHApKVxuXG4gICAgaWYgKHRoaXMucGF0aCA9PT0gJycpXG4gICAgICB0aGlzLnBhdGggPSAnLi8nXG5cbiAgICBpZiAodGhpcy5zdGF0Q2FjaGUuaGFzKHRoaXMuYWJzb2x1dGUpKVxuICAgICAgdGhpc1tPTkxTVEFUXSh0aGlzLnN0YXRDYWNoZS5nZXQodGhpcy5hYnNvbHV0ZSkpXG4gICAgZWxzZVxuICAgICAgdGhpc1tMU1RBVF0oKVxuICB9XG5cbiAgZW1pdCAoZXYsIC4uLmRhdGEpIHtcbiAgICBpZiAoZXYgPT09ICdlcnJvcicpXG4gICAgICB0aGlzW0hBRF9FUlJPUl0gPSB0cnVlXG4gICAgcmV0dXJuIHN1cGVyLmVtaXQoZXYsIC4uLmRhdGEpXG4gIH1cblxuICBbTFNUQVRdICgpIHtcbiAgICBmcy5sc3RhdCh0aGlzLmFic29sdXRlLCAoZXIsIHN0YXQpID0+IHtcbiAgICAgIGlmIChlcilcbiAgICAgICAgcmV0dXJuIHRoaXMuZW1pdCgnZXJyb3InLCBlcilcbiAgICAgIHRoaXNbT05MU1RBVF0oc3RhdClcbiAgICB9KVxuICB9XG5cbiAgW09OTFNUQVRdIChzdGF0KSB7XG4gICAgdGhpcy5zdGF0Q2FjaGUuc2V0KHRoaXMuYWJzb2x1dGUsIHN0YXQpXG4gICAgdGhpcy5zdGF0ID0gc3RhdFxuICAgIGlmICghc3RhdC5pc0ZpbGUoKSlcbiAgICAgIHN0YXQuc2l6ZSA9IDBcbiAgICB0aGlzLnR5cGUgPSBnZXRUeXBlKHN0YXQpXG4gICAgdGhpcy5lbWl0KCdzdGF0Jywgc3RhdClcbiAgICB0aGlzW1BST0NFU1NdKClcbiAgfVxuXG4gIFtQUk9DRVNTXSAoKSB7XG4gICAgc3dpdGNoICh0aGlzLnR5cGUpIHtcbiAgICAgIGNhc2UgJ0ZpbGUnOiByZXR1cm4gdGhpc1tGSUxFXSgpXG4gICAgICBjYXNlICdEaXJlY3RvcnknOiByZXR1cm4gdGhpc1tESVJFQ1RPUlldKClcbiAgICAgIGNhc2UgJ1N5bWJvbGljTGluayc6IHJldHVybiB0aGlzW1NZTUxJTktdKClcbiAgICAgIC8vIHVuc3VwcG9ydGVkIHR5cGVzIGFyZSBpZ25vcmVkLlxuICAgICAgZGVmYXVsdDogcmV0dXJuIHRoaXMuZW5kKClcbiAgICB9XG4gIH1cblxuICBbTU9ERV0gKG1vZGUpIHtcbiAgICByZXR1cm4gbW9kZUZpeChtb2RlLCB0aGlzLnR5cGUgPT09ICdEaXJlY3RvcnknKVxuICB9XG5cbiAgW1BSRUZJWF0gKHBhdGgpIHtcbiAgICByZXR1cm4gcHJlZml4UGF0aChwYXRoLCB0aGlzLnByZWZpeClcbiAgfVxuXG4gIFtIRUFERVJdICgpIHtcbiAgICBpZiAodGhpcy50eXBlID09PSAnRGlyZWN0b3J5JyAmJiB0aGlzLnBvcnRhYmxlKVxuICAgICAgdGhpcy5ub010aW1lID0gdHJ1ZVxuXG4gICAgdGhpcy5oZWFkZXIgPSBuZXcgSGVhZGVyKHtcbiAgICAgIHBhdGg6IHRoaXNbUFJFRklYXSh0aGlzLnBhdGgpLFxuICAgICAgLy8gb25seSBhcHBseSB0aGUgcHJlZml4IHRvIGhhcmQgbGlua3MuXG4gICAgICBsaW5rcGF0aDogdGhpcy50eXBlID09PSAnTGluaycgPyB0aGlzW1BSRUZJWF0odGhpcy5saW5rcGF0aClcbiAgICAgIDogdGhpcy5saW5rcGF0aCxcbiAgICAgIC8vIG9ubHkgdGhlIHBlcm1pc3Npb25zIGFuZCBzZXR1aWQvc2V0Z2lkL3N0aWNreSBiaXRmbGFnc1xuICAgICAgLy8gbm90IHRoZSBoaWdoZXItb3JkZXIgYml0cyB0aGF0IHNwZWNpZnkgZmlsZSB0eXBlXG4gICAgICBtb2RlOiB0aGlzW01PREVdKHRoaXMuc3RhdC5tb2RlKSxcbiAgICAgIHVpZDogdGhpcy5wb3J0YWJsZSA/IG51bGwgOiB0aGlzLnN0YXQudWlkLFxuICAgICAgZ2lkOiB0aGlzLnBvcnRhYmxlID8gbnVsbCA6IHRoaXMuc3RhdC5naWQsXG4gICAgICBzaXplOiB0aGlzLnN0YXQuc2l6ZSxcbiAgICAgIG10aW1lOiB0aGlzLm5vTXRpbWUgPyBudWxsIDogdGhpcy5tdGltZSB8fCB0aGlzLnN0YXQubXRpbWUsXG4gICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICB1bmFtZTogdGhpcy5wb3J0YWJsZSA/IG51bGwgOlxuICAgICAgICB0aGlzLnN0YXQudWlkID09PSB0aGlzLm15dWlkID8gdGhpcy5teXVzZXIgOiAnJyxcbiAgICAgIGF0aW1lOiB0aGlzLnBvcnRhYmxlID8gbnVsbCA6IHRoaXMuc3RhdC5hdGltZSxcbiAgICAgIGN0aW1lOiB0aGlzLnBvcnRhYmxlID8gbnVsbCA6IHRoaXMuc3RhdC5jdGltZVxuICAgIH0pXG5cbiAgICBpZiAodGhpcy5oZWFkZXIuZW5jb2RlKCkgJiYgIXRoaXMubm9QYXgpIHtcbiAgICAgIHN1cGVyLndyaXRlKG5ldyBQYXgoe1xuICAgICAgICBhdGltZTogdGhpcy5wb3J0YWJsZSA/IG51bGwgOiB0aGlzLmhlYWRlci5hdGltZSxcbiAgICAgICAgY3RpbWU6IHRoaXMucG9ydGFibGUgPyBudWxsIDogdGhpcy5oZWFkZXIuY3RpbWUsXG4gICAgICAgIGdpZDogdGhpcy5wb3J0YWJsZSA/IG51bGwgOiB0aGlzLmhlYWRlci5naWQsXG4gICAgICAgIG10aW1lOiB0aGlzLm5vTXRpbWUgPyBudWxsIDogdGhpcy5tdGltZSB8fCB0aGlzLmhlYWRlci5tdGltZSxcbiAgICAgICAgcGF0aDogdGhpc1tQUkVGSVhdKHRoaXMucGF0aCksXG4gICAgICAgIGxpbmtwYXRoOiB0aGlzLnR5cGUgPT09ICdMaW5rJyA/IHRoaXNbUFJFRklYXSh0aGlzLmxpbmtwYXRoKVxuICAgICAgICA6IHRoaXMubGlua3BhdGgsXG4gICAgICAgIHNpemU6IHRoaXMuaGVhZGVyLnNpemUsXG4gICAgICAgIHVpZDogdGhpcy5wb3J0YWJsZSA/IG51bGwgOiB0aGlzLmhlYWRlci51aWQsXG4gICAgICAgIHVuYW1lOiB0aGlzLnBvcnRhYmxlID8gbnVsbCA6IHRoaXMuaGVhZGVyLnVuYW1lLFxuICAgICAgICBkZXY6IHRoaXMucG9ydGFibGUgPyBudWxsIDogdGhpcy5zdGF0LmRldixcbiAgICAgICAgaW5vOiB0aGlzLnBvcnRhYmxlID8gbnVsbCA6IHRoaXMuc3RhdC5pbm8sXG4gICAgICAgIG5saW5rOiB0aGlzLnBvcnRhYmxlID8gbnVsbCA6IHRoaXMuc3RhdC5ubGlua1xuICAgICAgfSkuZW5jb2RlKCkpXG4gICAgfVxuICAgIHN1cGVyLndyaXRlKHRoaXMuaGVhZGVyLmJsb2NrKVxuICB9XG5cbiAgW0RJUkVDVE9SWV0gKCkge1xuICAgIGlmICh0aGlzLnBhdGguc3Vic3RyKC0xKSAhPT0gJy8nKVxuICAgICAgdGhpcy5wYXRoICs9ICcvJ1xuICAgIHRoaXMuc3RhdC5zaXplID0gMFxuICAgIHRoaXNbSEVBREVSXSgpXG4gICAgdGhpcy5lbmQoKVxuICB9XG5cbiAgW1NZTUxJTktdICgpIHtcbiAgICBmcy5yZWFkbGluayh0aGlzLmFic29sdXRlLCAoZXIsIGxpbmtwYXRoKSA9PiB7XG4gICAgICBpZiAoZXIpXG4gICAgICAgIHJldHVybiB0aGlzLmVtaXQoJ2Vycm9yJywgZXIpXG4gICAgICB0aGlzW09OUkVBRExJTktdKGxpbmtwYXRoKVxuICAgIH0pXG4gIH1cblxuICBbT05SRUFETElOS10gKGxpbmtwYXRoKSB7XG4gICAgdGhpcy5saW5rcGF0aCA9IG5vcm1QYXRoKGxpbmtwYXRoKVxuICAgIHRoaXNbSEVBREVSXSgpXG4gICAgdGhpcy5lbmQoKVxuICB9XG5cbiAgW0hBUkRMSU5LXSAobGlua3BhdGgpIHtcbiAgICB0aGlzLnR5cGUgPSAnTGluaydcbiAgICB0aGlzLmxpbmtwYXRoID0gbm9ybVBhdGgocGF0aC5yZWxhdGl2ZSh0aGlzLmN3ZCwgbGlua3BhdGgpKVxuICAgIHRoaXMuc3RhdC5zaXplID0gMFxuICAgIHRoaXNbSEVBREVSXSgpXG4gICAgdGhpcy5lbmQoKVxuICB9XG5cbiAgW0ZJTEVdICgpIHtcbiAgICBpZiAodGhpcy5zdGF0Lm5saW5rID4gMSkge1xuICAgICAgY29uc3QgbGlua0tleSA9IHRoaXMuc3RhdC5kZXYgKyAnOicgKyB0aGlzLnN0YXQuaW5vXG4gICAgICBpZiAodGhpcy5saW5rQ2FjaGUuaGFzKGxpbmtLZXkpKSB7XG4gICAgICAgIGNvbnN0IGxpbmtwYXRoID0gdGhpcy5saW5rQ2FjaGUuZ2V0KGxpbmtLZXkpXG4gICAgICAgIGlmIChsaW5rcGF0aC5pbmRleE9mKHRoaXMuY3dkKSA9PT0gMClcbiAgICAgICAgICByZXR1cm4gdGhpc1tIQVJETElOS10obGlua3BhdGgpXG4gICAgICB9XG4gICAgICB0aGlzLmxpbmtDYWNoZS5zZXQobGlua0tleSwgdGhpcy5hYnNvbHV0ZSlcbiAgICB9XG5cbiAgICB0aGlzW0hFQURFUl0oKVxuICAgIGlmICh0aGlzLnN0YXQuc2l6ZSA9PT0gMClcbiAgICAgIHJldHVybiB0aGlzLmVuZCgpXG5cbiAgICB0aGlzW09QRU5GSUxFXSgpXG4gIH1cblxuICBbT1BFTkZJTEVdICgpIHtcbiAgICBmcy5vcGVuKHRoaXMuYWJzb2x1dGUsICdyJywgKGVyLCBmZCkgPT4ge1xuICAgICAgaWYgKGVyKVxuICAgICAgICByZXR1cm4gdGhpcy5lbWl0KCdlcnJvcicsIGVyKVxuICAgICAgdGhpc1tPTk9QRU5GSUxFXShmZClcbiAgICB9KVxuICB9XG5cbiAgW09OT1BFTkZJTEVdIChmZCkge1xuICAgIHRoaXMuZmQgPSBmZFxuICAgIGlmICh0aGlzW0hBRF9FUlJPUl0pXG4gICAgICByZXR1cm4gdGhpc1tDTE9TRV0oKVxuXG4gICAgdGhpcy5ibG9ja0xlbiA9IDUxMiAqIE1hdGguY2VpbCh0aGlzLnN0YXQuc2l6ZSAvIDUxMilcbiAgICB0aGlzLmJsb2NrUmVtYWluID0gdGhpcy5ibG9ja0xlblxuICAgIGNvbnN0IGJ1ZkxlbiA9IE1hdGgubWluKHRoaXMuYmxvY2tMZW4sIHRoaXMubWF4UmVhZFNpemUpXG4gICAgdGhpcy5idWYgPSBCdWZmZXIuYWxsb2NVbnNhZmUoYnVmTGVuKVxuICAgIHRoaXMub2Zmc2V0ID0gMFxuICAgIHRoaXMucG9zID0gMFxuICAgIHRoaXMucmVtYWluID0gdGhpcy5zdGF0LnNpemVcbiAgICB0aGlzLmxlbmd0aCA9IHRoaXMuYnVmLmxlbmd0aFxuICAgIHRoaXNbUkVBRF0oKVxuICB9XG5cbiAgW1JFQURdICgpIHtcbiAgICBjb25zdCB7IGZkLCBidWYsIG9mZnNldCwgbGVuZ3RoLCBwb3MgfSA9IHRoaXNcbiAgICBmcy5yZWFkKGZkLCBidWYsIG9mZnNldCwgbGVuZ3RoLCBwb3MsIChlciwgYnl0ZXNSZWFkKSA9PiB7XG4gICAgICBpZiAoZXIpIHtcbiAgICAgICAgLy8gaWdub3JpbmcgdGhlIGVycm9yIGZyb20gY2xvc2UoMikgaXMgYSBiYWQgcHJhY3RpY2UsIGJ1dCBhdFxuICAgICAgICAvLyB0aGlzIHBvaW50IHdlIGFscmVhZHkgaGF2ZSBhbiBlcnJvciwgZG9uJ3QgbmVlZCBhbm90aGVyIG9uZVxuICAgICAgICByZXR1cm4gdGhpc1tDTE9TRV0oKCkgPT4gdGhpcy5lbWl0KCdlcnJvcicsIGVyKSlcbiAgICAgIH1cbiAgICAgIHRoaXNbT05SRUFEXShieXRlc1JlYWQpXG4gICAgfSlcbiAgfVxuXG4gIFtDTE9TRV0gKGNiKSB7XG4gICAgZnMuY2xvc2UodGhpcy5mZCwgY2IpXG4gIH1cblxuICBbT05SRUFEXSAoYnl0ZXNSZWFkKSB7XG4gICAgaWYgKGJ5dGVzUmVhZCA8PSAwICYmIHRoaXMucmVtYWluID4gMCkge1xuICAgICAgY29uc3QgZXIgPSBuZXcgRXJyb3IoJ2VuY291bnRlcmVkIHVuZXhwZWN0ZWQgRU9GJylcbiAgICAgIGVyLnBhdGggPSB0aGlzLmFic29sdXRlXG4gICAgICBlci5zeXNjYWxsID0gJ3JlYWQnXG4gICAgICBlci5jb2RlID0gJ0VPRidcbiAgICAgIHJldHVybiB0aGlzW0NMT1NFXSgoKSA9PiB0aGlzLmVtaXQoJ2Vycm9yJywgZXIpKVxuICAgIH1cblxuICAgIGlmIChieXRlc1JlYWQgPiB0aGlzLnJlbWFpbikge1xuICAgICAgY29uc3QgZXIgPSBuZXcgRXJyb3IoJ2RpZCBub3QgZW5jb3VudGVyIGV4cGVjdGVkIEVPRicpXG4gICAgICBlci5wYXRoID0gdGhpcy5hYnNvbHV0ZVxuICAgICAgZXIuc3lzY2FsbCA9ICdyZWFkJ1xuICAgICAgZXIuY29kZSA9ICdFT0YnXG4gICAgICByZXR1cm4gdGhpc1tDTE9TRV0oKCkgPT4gdGhpcy5lbWl0KCdlcnJvcicsIGVyKSlcbiAgICB9XG5cbiAgICAvLyBudWxsIG91dCB0aGUgcmVzdCBvZiB0aGUgYnVmZmVyLCBpZiB3ZSBjb3VsZCBmaXQgdGhlIGJsb2NrIHBhZGRpbmdcbiAgICAvLyBhdCB0aGUgZW5kIG9mIHRoaXMgbG9vcCwgd2UndmUgaW5jcmVtZW50ZWQgYnl0ZXNSZWFkIGFuZCB0aGlzLnJlbWFpblxuICAgIC8vIHRvIGJlIGluY3JlbWVudGVkIHVwIHRvIHRoZSBibG9ja1JlbWFpbiBsZXZlbCwgYXMgaWYgd2UgaGFkIGV4cGVjdGVkXG4gICAgLy8gdG8gZ2V0IGEgbnVsbC1wYWRkZWQgZmlsZSwgYW5kIHJlYWQgaXQgdW50aWwgdGhlIGVuZC4gIHRoZW4gd2Ugd2lsbFxuICAgIC8vIGRlY3JlbWVudCBib3RoIHJlbWFpbiBhbmQgYmxvY2tSZW1haW4gYnkgYnl0ZXNSZWFkLCBhbmQga25vdyB0aGF0IHdlXG4gICAgLy8gcmVhY2hlZCB0aGUgZXhwZWN0ZWQgRU9GLCB3aXRob3V0IGFueSBudWxsIGJ1ZmZlciB0byBhcHBlbmQuXG4gICAgaWYgKGJ5dGVzUmVhZCA9PT0gdGhpcy5yZW1haW4pIHtcbiAgICAgIGZvciAobGV0IGkgPSBieXRlc1JlYWQ7IGkgPCB0aGlzLmxlbmd0aCAmJiBieXRlc1JlYWQgPCB0aGlzLmJsb2NrUmVtYWluOyBpKyspIHtcbiAgICAgICAgdGhpcy5idWZbaSArIHRoaXMub2Zmc2V0XSA9IDBcbiAgICAgICAgYnl0ZXNSZWFkKytcbiAgICAgICAgdGhpcy5yZW1haW4rK1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHdyaXRlQnVmID0gdGhpcy5vZmZzZXQgPT09IDAgJiYgYnl0ZXNSZWFkID09PSB0aGlzLmJ1Zi5sZW5ndGggP1xuICAgICAgdGhpcy5idWYgOiB0aGlzLmJ1Zi5zbGljZSh0aGlzLm9mZnNldCwgdGhpcy5vZmZzZXQgKyBieXRlc1JlYWQpXG5cbiAgICBjb25zdCBmbHVzaGVkID0gdGhpcy53cml0ZSh3cml0ZUJ1ZilcbiAgICBpZiAoIWZsdXNoZWQpXG4gICAgICB0aGlzW0FXQUlURFJBSU5dKCgpID0+IHRoaXNbT05EUkFJTl0oKSlcbiAgICBlbHNlXG4gICAgICB0aGlzW09ORFJBSU5dKClcbiAgfVxuXG4gIFtBV0FJVERSQUlOXSAoY2IpIHtcbiAgICB0aGlzLm9uY2UoJ2RyYWluJywgY2IpXG4gIH1cblxuICB3cml0ZSAod3JpdGVCdWYpIHtcbiAgICBpZiAodGhpcy5ibG9ja1JlbWFpbiA8IHdyaXRlQnVmLmxlbmd0aCkge1xuICAgICAgY29uc3QgZXIgPSBuZXcgRXJyb3IoJ3dyaXRpbmcgbW9yZSBkYXRhIHRoYW4gZXhwZWN0ZWQnKVxuICAgICAgZXIucGF0aCA9IHRoaXMuYWJzb2x1dGVcbiAgICAgIHJldHVybiB0aGlzLmVtaXQoJ2Vycm9yJywgZXIpXG4gICAgfVxuICAgIHRoaXMucmVtYWluIC09IHdyaXRlQnVmLmxlbmd0aFxuICAgIHRoaXMuYmxvY2tSZW1haW4gLT0gd3JpdGVCdWYubGVuZ3RoXG4gICAgdGhpcy5wb3MgKz0gd3JpdGVCdWYubGVuZ3RoXG4gICAgdGhpcy5vZmZzZXQgKz0gd3JpdGVCdWYubGVuZ3RoXG4gICAgcmV0dXJuIHN1cGVyLndyaXRlKHdyaXRlQnVmKVxuICB9XG5cbiAgW09ORFJBSU5dICgpIHtcbiAgICBpZiAoIXRoaXMucmVtYWluKSB7XG4gICAgICBpZiAodGhpcy5ibG9ja1JlbWFpbilcbiAgICAgICAgc3VwZXIud3JpdGUoQnVmZmVyLmFsbG9jKHRoaXMuYmxvY2tSZW1haW4pKVxuICAgICAgcmV0dXJuIHRoaXNbQ0xPU0VdKC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0IC0gbGVnYWN5ICovXG4gICAgICAgIGVyID0+IGVyID8gdGhpcy5lbWl0KCdlcnJvcicsIGVyKSA6IHRoaXMuZW5kKCkpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMub2Zmc2V0ID49IHRoaXMubGVuZ3RoKSB7XG4gICAgICAvLyBpZiB3ZSBvbmx5IGhhdmUgYSBzbWFsbGVyIGJpdCBsZWZ0IHRvIHJlYWQsIGFsbG9jIGEgc21hbGxlciBidWZmZXJcbiAgICAgIC8vIG90aGVyd2lzZSwga2VlcCBpdCB0aGUgc2FtZSBsZW5ndGggaXQgd2FzIGJlZm9yZS5cbiAgICAgIHRoaXMuYnVmID0gQnVmZmVyLmFsbG9jVW5zYWZlKE1hdGgubWluKHRoaXMuYmxvY2tSZW1haW4sIHRoaXMuYnVmLmxlbmd0aCkpXG4gICAgICB0aGlzLm9mZnNldCA9IDBcbiAgICB9XG4gICAgdGhpcy5sZW5ndGggPSB0aGlzLmJ1Zi5sZW5ndGggLSB0aGlzLm9mZnNldFxuICAgIHRoaXNbUkVBRF0oKVxuICB9XG59KVxuXG5jbGFzcyBXcml0ZUVudHJ5U3luYyBleHRlbmRzIFdyaXRlRW50cnkge1xuICBjb25zdHJ1Y3RvciAocGF0aCwgb3B0KSB7XG4gICAgc3VwZXIocGF0aCwgb3B0KVxuICB9XG5cbiAgW0xTVEFUXSAoKSB7XG4gICAgdGhpc1tPTkxTVEFUXShmcy5sc3RhdFN5bmModGhpcy5hYnNvbHV0ZSkpXG4gIH1cblxuICBbU1lNTElOS10gKCkge1xuICAgIHRoaXNbT05SRUFETElOS10oZnMucmVhZGxpbmtTeW5jKHRoaXMuYWJzb2x1dGUpKVxuICB9XG5cbiAgW09QRU5GSUxFXSAoKSB7XG4gICAgdGhpc1tPTk9QRU5GSUxFXShmcy5vcGVuU3luYyh0aGlzLmFic29sdXRlLCAncicpKVxuICB9XG5cbiAgW1JFQURdICgpIHtcbiAgICBsZXQgdGhyZXcgPSB0cnVlXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHsgZmQsIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgsIHBvcyB9ID0gdGhpc1xuICAgICAgY29uc3QgYnl0ZXNSZWFkID0gZnMucmVhZFN5bmMoZmQsIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgsIHBvcylcbiAgICAgIHRoaXNbT05SRUFEXShieXRlc1JlYWQpXG4gICAgICB0aHJldyA9IGZhbHNlXG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIC8vIGlnbm9yaW5nIHRoZSBlcnJvciBmcm9tIGNsb3NlKDIpIGlzIGEgYmFkIHByYWN0aWNlLCBidXQgYXRcbiAgICAgIC8vIHRoaXMgcG9pbnQgd2UgYWxyZWFkeSBoYXZlIGFuIGVycm9yLCBkb24ndCBuZWVkIGFub3RoZXIgb25lXG4gICAgICBpZiAodGhyZXcpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aGlzW0NMT1NFXSgoKSA9PiB7fSlcbiAgICAgICAgfSBjYXRjaCAoZXIpIHt9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgW0FXQUlURFJBSU5dIChjYikge1xuICAgIGNiKClcbiAgfVxuXG4gIFtDTE9TRV0gKGNiKSB7XG4gICAgZnMuY2xvc2VTeW5jKHRoaXMuZmQpXG4gICAgY2IoKVxuICB9XG59XG5cbmNvbnN0IFdyaXRlRW50cnlUYXIgPSB3YXJuZXIoY2xhc3MgV3JpdGVFbnRyeVRhciBleHRlbmRzIE1pbmlQYXNzIHtcbiAgY29uc3RydWN0b3IgKHJlYWRFbnRyeSwgb3B0KSB7XG4gICAgb3B0ID0gb3B0IHx8IHt9XG4gICAgc3VwZXIob3B0KVxuICAgIHRoaXMucHJlc2VydmVQYXRocyA9ICEhb3B0LnByZXNlcnZlUGF0aHNcbiAgICB0aGlzLnBvcnRhYmxlID0gISFvcHQucG9ydGFibGVcbiAgICB0aGlzLnN0cmljdCA9ICEhb3B0LnN0cmljdFxuICAgIHRoaXMubm9QYXggPSAhIW9wdC5ub1BheFxuICAgIHRoaXMubm9NdGltZSA9ICEhb3B0Lm5vTXRpbWVcblxuICAgIHRoaXMucmVhZEVudHJ5ID0gcmVhZEVudHJ5XG4gICAgdGhpcy50eXBlID0gcmVhZEVudHJ5LnR5cGVcbiAgICBpZiAodGhpcy50eXBlID09PSAnRGlyZWN0b3J5JyAmJiB0aGlzLnBvcnRhYmxlKVxuICAgICAgdGhpcy5ub010aW1lID0gdHJ1ZVxuXG4gICAgdGhpcy5wcmVmaXggPSBvcHQucHJlZml4IHx8IG51bGxcblxuICAgIHRoaXMucGF0aCA9IG5vcm1QYXRoKHJlYWRFbnRyeS5wYXRoKVxuICAgIHRoaXMubW9kZSA9IHRoaXNbTU9ERV0ocmVhZEVudHJ5Lm1vZGUpXG4gICAgdGhpcy51aWQgPSB0aGlzLnBvcnRhYmxlID8gbnVsbCA6IHJlYWRFbnRyeS51aWRcbiAgICB0aGlzLmdpZCA9IHRoaXMucG9ydGFibGUgPyBudWxsIDogcmVhZEVudHJ5LmdpZFxuICAgIHRoaXMudW5hbWUgPSB0aGlzLnBvcnRhYmxlID8gbnVsbCA6IHJlYWRFbnRyeS51bmFtZVxuICAgIHRoaXMuZ25hbWUgPSB0aGlzLnBvcnRhYmxlID8gbnVsbCA6IHJlYWRFbnRyeS5nbmFtZVxuICAgIHRoaXMuc2l6ZSA9IHJlYWRFbnRyeS5zaXplXG4gICAgdGhpcy5tdGltZSA9IHRoaXMubm9NdGltZSA/IG51bGwgOiBvcHQubXRpbWUgfHwgcmVhZEVudHJ5Lm10aW1lXG4gICAgdGhpcy5hdGltZSA9IHRoaXMucG9ydGFibGUgPyBudWxsIDogcmVhZEVudHJ5LmF0aW1lXG4gICAgdGhpcy5jdGltZSA9IHRoaXMucG9ydGFibGUgPyBudWxsIDogcmVhZEVudHJ5LmN0aW1lXG4gICAgdGhpcy5saW5rcGF0aCA9IG5vcm1QYXRoKHJlYWRFbnRyeS5saW5rcGF0aClcblxuICAgIGlmICh0eXBlb2Ygb3B0Lm9ud2FybiA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgIHRoaXMub24oJ3dhcm4nLCBvcHQub253YXJuKVxuXG4gICAgaWYgKCF0aGlzLnByZXNlcnZlUGF0aHMpIHtcbiAgICAgIGNvbnN0IHMgPSBzdHJpcEFic29sdXRlUGF0aCh0aGlzLnBhdGgpXG4gICAgICBpZiAoc1swXSkge1xuICAgICAgICB0aGlzLndhcm4oXG4gICAgICAgICAgJ3N0cmlwcGluZyAnICsgc1swXSArICcgZnJvbSBhYnNvbHV0ZSBwYXRoJyxcbiAgICAgICAgICB0aGlzLnBhdGhcbiAgICAgICAgKVxuICAgICAgICB0aGlzLnBhdGggPSBzWzFdXG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5yZW1haW4gPSByZWFkRW50cnkuc2l6ZVxuICAgIHRoaXMuYmxvY2tSZW1haW4gPSByZWFkRW50cnkuc3RhcnRCbG9ja1NpemVcblxuICAgIHRoaXMuaGVhZGVyID0gbmV3IEhlYWRlcih7XG4gICAgICBwYXRoOiB0aGlzW1BSRUZJWF0odGhpcy5wYXRoKSxcbiAgICAgIGxpbmtwYXRoOiB0aGlzLnR5cGUgPT09ICdMaW5rJyA/IHRoaXNbUFJFRklYXSh0aGlzLmxpbmtwYXRoKVxuICAgICAgOiB0aGlzLmxpbmtwYXRoLFxuICAgICAgLy8gb25seSB0aGUgcGVybWlzc2lvbnMgYW5kIHNldHVpZC9zZXRnaWQvc3RpY2t5IGJpdGZsYWdzXG4gICAgICAvLyBub3QgdGhlIGhpZ2hlci1vcmRlciBiaXRzIHRoYXQgc3BlY2lmeSBmaWxlIHR5cGVcbiAgICAgIG1vZGU6IHRoaXMubW9kZSxcbiAgICAgIHVpZDogdGhpcy5wb3J0YWJsZSA/IG51bGwgOiB0aGlzLnVpZCxcbiAgICAgIGdpZDogdGhpcy5wb3J0YWJsZSA/IG51bGwgOiB0aGlzLmdpZCxcbiAgICAgIHNpemU6IHRoaXMuc2l6ZSxcbiAgICAgIG10aW1lOiB0aGlzLm5vTXRpbWUgPyBudWxsIDogdGhpcy5tdGltZSxcbiAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgIHVuYW1lOiB0aGlzLnBvcnRhYmxlID8gbnVsbCA6IHRoaXMudW5hbWUsXG4gICAgICBhdGltZTogdGhpcy5wb3J0YWJsZSA/IG51bGwgOiB0aGlzLmF0aW1lLFxuICAgICAgY3RpbWU6IHRoaXMucG9ydGFibGUgPyBudWxsIDogdGhpcy5jdGltZVxuICAgIH0pXG5cbiAgICBpZiAodGhpcy5oZWFkZXIuZW5jb2RlKCkgJiYgIXRoaXMubm9QYXgpXG4gICAgICBzdXBlci53cml0ZShuZXcgUGF4KHtcbiAgICAgICAgYXRpbWU6IHRoaXMucG9ydGFibGUgPyBudWxsIDogdGhpcy5hdGltZSxcbiAgICAgICAgY3RpbWU6IHRoaXMucG9ydGFibGUgPyBudWxsIDogdGhpcy5jdGltZSxcbiAgICAgICAgZ2lkOiB0aGlzLnBvcnRhYmxlID8gbnVsbCA6IHRoaXMuZ2lkLFxuICAgICAgICBtdGltZTogdGhpcy5ub010aW1lID8gbnVsbCA6IHRoaXMubXRpbWUsXG4gICAgICAgIHBhdGg6IHRoaXNbUFJFRklYXSh0aGlzLnBhdGgpLFxuICAgICAgICBsaW5rcGF0aDogdGhpcy50eXBlID09PSAnTGluaycgPyB0aGlzW1BSRUZJWF0odGhpcy5saW5rcGF0aClcbiAgICAgICAgOiB0aGlzLmxpbmtwYXRoLFxuICAgICAgICBzaXplOiB0aGlzLnNpemUsXG4gICAgICAgIHVpZDogdGhpcy5wb3J0YWJsZSA/IG51bGwgOiB0aGlzLnVpZCxcbiAgICAgICAgdW5hbWU6IHRoaXMucG9ydGFibGUgPyBudWxsIDogdGhpcy51bmFtZSxcbiAgICAgICAgZGV2OiB0aGlzLnBvcnRhYmxlID8gbnVsbCA6IHRoaXMucmVhZEVudHJ5LmRldixcbiAgICAgICAgaW5vOiB0aGlzLnBvcnRhYmxlID8gbnVsbCA6IHRoaXMucmVhZEVudHJ5LmlubyxcbiAgICAgICAgbmxpbms6IHRoaXMucG9ydGFibGUgPyBudWxsIDogdGhpcy5yZWFkRW50cnkubmxpbmtcbiAgICAgIH0pLmVuY29kZSgpKVxuXG4gICAgc3VwZXIud3JpdGUodGhpcy5oZWFkZXIuYmxvY2spXG4gICAgcmVhZEVudHJ5LnBpcGUodGhpcylcbiAgfVxuXG4gIFtQUkVGSVhdIChwYXRoKSB7XG4gICAgcmV0dXJuIHByZWZpeFBhdGgocGF0aCwgdGhpcy5wcmVmaXgpXG4gIH1cblxuICBbTU9ERV0gKG1vZGUpIHtcbiAgICByZXR1cm4gbW9kZUZpeChtb2RlLCB0aGlzLnR5cGUgPT09ICdEaXJlY3RvcnknKVxuICB9XG5cbiAgd3JpdGUgKGRhdGEpIHtcbiAgICBjb25zdCB3cml0ZUxlbiA9IGRhdGEubGVuZ3RoXG4gICAgaWYgKHdyaXRlTGVuID4gdGhpcy5ibG9ja1JlbWFpbilcbiAgICAgIHRocm93IG5ldyBFcnJvcignd3JpdGluZyBtb3JlIHRvIGVudHJ5IHRoYW4gaXMgYXBwcm9wcmlhdGUnKVxuICAgIHRoaXMuYmxvY2tSZW1haW4gLT0gd3JpdGVMZW5cbiAgICByZXR1cm4gc3VwZXIud3JpdGUoZGF0YSlcbiAgfVxuXG4gIGVuZCAoKSB7XG4gICAgaWYgKHRoaXMuYmxvY2tSZW1haW4pXG4gICAgICBzdXBlci53cml0ZShCdWZmZXIuYWxsb2ModGhpcy5ibG9ja1JlbWFpbikpXG4gICAgcmV0dXJuIHN1cGVyLmVuZCgpXG4gIH1cbn0pXG5cbldyaXRlRW50cnkuU3luYyA9IFdyaXRlRW50cnlTeW5jXG5Xcml0ZUVudHJ5LlRhciA9IFdyaXRlRW50cnlUYXJcblxuY29uc3QgZ2V0VHlwZSA9IHN0YXQgPT5cbiAgc3RhdC5pc0ZpbGUoKSA/ICdGaWxlJ1xuICA6IHN0YXQuaXNEaXJlY3RvcnkoKSA/ICdEaXJlY3RvcnknXG4gIDogc3RhdC5pc1N5bWJvbGljTGluaygpID8gJ1N5bWJvbGljTGluaydcbiAgOiAnVW5zdXBwb3J0ZWQnXG5cbm1vZHVsZS5leHBvcnRzID0gV3JpdGVFbnRyeVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/tar/lib/write-entry.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/tar/node_modules/mkdirp/index.js":
/*!***********************************************************!*\
  !*** ../../node_modules/tar/node_modules/mkdirp/index.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var path = __webpack_require__(/*! path */ \"path\");\nvar fs = __webpack_require__(/*! fs */ \"fs\");\nvar _0777 = parseInt('0777', 8);\n\nmodule.exports = mkdirP.mkdirp = mkdirP.mkdirP = mkdirP;\n\nfunction mkdirP (p, opts, f, made) {\n    if (typeof opts === 'function') {\n        f = opts;\n        opts = {};\n    }\n    else if (!opts || typeof opts !== 'object') {\n        opts = { mode: opts };\n    }\n    \n    var mode = opts.mode;\n    var xfs = opts.fs || fs;\n    \n    if (mode === undefined) {\n        mode = _0777\n    }\n    if (!made) made = null;\n    \n    var cb = f || /* istanbul ignore next */ function () {};\n    p = path.resolve(p);\n    \n    xfs.mkdir(p, mode, function (er) {\n        if (!er) {\n            made = made || p;\n            return cb(null, made);\n        }\n        switch (er.code) {\n            case 'ENOENT':\n                /* istanbul ignore if */\n                if (path.dirname(p) === p) return cb(er);\n                mkdirP(path.dirname(p), opts, function (er, made) {\n                    /* istanbul ignore if */\n                    if (er) cb(er, made);\n                    else mkdirP(p, opts, cb, made);\n                });\n                break;\n\n            // In the case of any other error, just see if there's a dir\n            // there already.  If so, then hooray!  If not, then something\n            // is borked.\n            default:\n                xfs.stat(p, function (er2, stat) {\n                    // if the stat fails, then that's super weird.\n                    // let the original error be the failure reason.\n                    if (er2 || !stat.isDirectory()) cb(er, made)\n                    else cb(null, made);\n                });\n                break;\n        }\n    });\n}\n\nmkdirP.sync = function sync (p, opts, made) {\n    if (!opts || typeof opts !== 'object') {\n        opts = { mode: opts };\n    }\n    \n    var mode = opts.mode;\n    var xfs = opts.fs || fs;\n    \n    if (mode === undefined) {\n        mode = _0777\n    }\n    if (!made) made = null;\n\n    p = path.resolve(p);\n\n    try {\n        xfs.mkdirSync(p, mode);\n        made = made || p;\n    }\n    catch (err0) {\n        switch (err0.code) {\n            case 'ENOENT' :\n                made = sync(path.dirname(p), opts, made);\n                sync(p, opts, made);\n                break;\n\n            // In the case of any other error, just see if there's a dir\n            // there already.  If so, then hooray!  If not, then something\n            // is borked.\n            default:\n                var stat;\n                try {\n                    stat = xfs.statSync(p);\n                }\n                catch (err1) /* istanbul ignore next */ {\n                    throw err0;\n                }\n                /* istanbul ignore if */\n                if (!stat.isDirectory()) throw err0;\n                break;\n        }\n    }\n\n    return made;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL3Rhci9ub2RlX21vZHVsZXMvbWtkaXJwL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBLFdBQVcsbUJBQU8sQ0FBQyxrQkFBTTtBQUN6QixTQUFTLG1CQUFPLENBQUMsY0FBSTtBQUNyQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9iYXJiL2FhL0Fzc29jaWF0ZWRBY2NvdW50cy9ub2RlX21vZHVsZXMvdGFyL25vZGVfbW9kdWxlcy9ta2RpcnAvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG52YXIgZnMgPSByZXF1aXJlKCdmcycpO1xudmFyIF8wNzc3ID0gcGFyc2VJbnQoJzA3NzcnLCA4KTtcblxubW9kdWxlLmV4cG9ydHMgPSBta2RpclAubWtkaXJwID0gbWtkaXJQLm1rZGlyUCA9IG1rZGlyUDtcblxuZnVuY3Rpb24gbWtkaXJQIChwLCBvcHRzLCBmLCBtYWRlKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGYgPSBvcHRzO1xuICAgICAgICBvcHRzID0ge307XG4gICAgfVxuICAgIGVsc2UgaWYgKCFvcHRzIHx8IHR5cGVvZiBvcHRzICE9PSAnb2JqZWN0Jykge1xuICAgICAgICBvcHRzID0geyBtb2RlOiBvcHRzIH07XG4gICAgfVxuICAgIFxuICAgIHZhciBtb2RlID0gb3B0cy5tb2RlO1xuICAgIHZhciB4ZnMgPSBvcHRzLmZzIHx8IGZzO1xuICAgIFxuICAgIGlmIChtb2RlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbW9kZSA9IF8wNzc3XG4gICAgfVxuICAgIGlmICghbWFkZSkgbWFkZSA9IG51bGw7XG4gICAgXG4gICAgdmFyIGNiID0gZiB8fCAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyBmdW5jdGlvbiAoKSB7fTtcbiAgICBwID0gcGF0aC5yZXNvbHZlKHApO1xuICAgIFxuICAgIHhmcy5ta2RpcihwLCBtb2RlLCBmdW5jdGlvbiAoZXIpIHtcbiAgICAgICAgaWYgKCFlcikge1xuICAgICAgICAgICAgbWFkZSA9IG1hZGUgfHwgcDtcbiAgICAgICAgICAgIHJldHVybiBjYihudWxsLCBtYWRlKTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKGVyLmNvZGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ0VOT0VOVCc6XG4gICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICAgICAgaWYgKHBhdGguZGlybmFtZShwKSA9PT0gcCkgcmV0dXJuIGNiKGVyKTtcbiAgICAgICAgICAgICAgICBta2RpclAocGF0aC5kaXJuYW1lKHApLCBvcHRzLCBmdW5jdGlvbiAoZXIsIG1hZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICAgICAgICAgIGlmIChlcikgY2IoZXIsIG1hZGUpO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIG1rZGlyUChwLCBvcHRzLCBjYiwgbWFkZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIC8vIEluIHRoZSBjYXNlIG9mIGFueSBvdGhlciBlcnJvciwganVzdCBzZWUgaWYgdGhlcmUncyBhIGRpclxuICAgICAgICAgICAgLy8gdGhlcmUgYWxyZWFkeS4gIElmIHNvLCB0aGVuIGhvb3JheSEgIElmIG5vdCwgdGhlbiBzb21ldGhpbmdcbiAgICAgICAgICAgIC8vIGlzIGJvcmtlZC5cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgeGZzLnN0YXQocCwgZnVuY3Rpb24gKGVyMiwgc3RhdCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGUgc3RhdCBmYWlscywgdGhlbiB0aGF0J3Mgc3VwZXIgd2VpcmQuXG4gICAgICAgICAgICAgICAgICAgIC8vIGxldCB0aGUgb3JpZ2luYWwgZXJyb3IgYmUgdGhlIGZhaWx1cmUgcmVhc29uLlxuICAgICAgICAgICAgICAgICAgICBpZiAoZXIyIHx8ICFzdGF0LmlzRGlyZWN0b3J5KCkpIGNiKGVyLCBtYWRlKVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGNiKG51bGwsIG1hZGUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5cbm1rZGlyUC5zeW5jID0gZnVuY3Rpb24gc3luYyAocCwgb3B0cywgbWFkZSkge1xuICAgIGlmICghb3B0cyB8fCB0eXBlb2Ygb3B0cyAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgb3B0cyA9IHsgbW9kZTogb3B0cyB9O1xuICAgIH1cbiAgICBcbiAgICB2YXIgbW9kZSA9IG9wdHMubW9kZTtcbiAgICB2YXIgeGZzID0gb3B0cy5mcyB8fCBmcztcbiAgICBcbiAgICBpZiAobW9kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG1vZGUgPSBfMDc3N1xuICAgIH1cbiAgICBpZiAoIW1hZGUpIG1hZGUgPSBudWxsO1xuXG4gICAgcCA9IHBhdGgucmVzb2x2ZShwKTtcblxuICAgIHRyeSB7XG4gICAgICAgIHhmcy5ta2RpclN5bmMocCwgbW9kZSk7XG4gICAgICAgIG1hZGUgPSBtYWRlIHx8IHA7XG4gICAgfVxuICAgIGNhdGNoIChlcnIwKSB7XG4gICAgICAgIHN3aXRjaCAoZXJyMC5jb2RlKSB7XG4gICAgICAgICAgICBjYXNlICdFTk9FTlQnIDpcbiAgICAgICAgICAgICAgICBtYWRlID0gc3luYyhwYXRoLmRpcm5hbWUocCksIG9wdHMsIG1hZGUpO1xuICAgICAgICAgICAgICAgIHN5bmMocCwgb3B0cywgbWFkZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIC8vIEluIHRoZSBjYXNlIG9mIGFueSBvdGhlciBlcnJvciwganVzdCBzZWUgaWYgdGhlcmUncyBhIGRpclxuICAgICAgICAgICAgLy8gdGhlcmUgYWxyZWFkeS4gIElmIHNvLCB0aGVuIGhvb3JheSEgIElmIG5vdCwgdGhlbiBzb21ldGhpbmdcbiAgICAgICAgICAgIC8vIGlzIGJvcmtlZC5cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdmFyIHN0YXQ7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdCA9IHhmcy5zdGF0U3luYyhwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycjEpIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICAgICAgaWYgKCFzdGF0LmlzRGlyZWN0b3J5KCkpIHRocm93IGVycjA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbWFkZTtcbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/tar/node_modules/mkdirp/index.js\n");

/***/ })

};
;