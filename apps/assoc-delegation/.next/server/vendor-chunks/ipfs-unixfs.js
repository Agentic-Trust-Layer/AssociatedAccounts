"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/ipfs-unixfs";
exports.ids = ["vendor-chunks/ipfs-unixfs"];
exports.modules = {

/***/ "(rsc)/../../node_modules/ipfs-unixfs/dist/src/errors.js":
/*!*********************************************************!*\
  !*** ../../node_modules/ipfs-unixfs/dist/src/errors.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InvalidTypeError: () => (/* binding */ InvalidTypeError),\n/* harmony export */   InvalidUnixFSMessageError: () => (/* binding */ InvalidUnixFSMessageError)\n/* harmony export */ });\nclass InvalidTypeError extends Error {\n    static name = 'InvalidTypeError';\n    static code = 'ERR_INVALID_TYPE';\n    name = InvalidTypeError.name;\n    code = InvalidTypeError.code;\n    constructor(message = 'Invalid type') {\n        super(message);\n    }\n}\nclass InvalidUnixFSMessageError extends Error {\n    static name = 'InvalidUnixFSMessageError';\n    static code = 'ERR_INVALID_MESSAGE';\n    name = InvalidUnixFSMessageError.name;\n    code = InvalidUnixFSMessageError.code;\n    constructor(message = 'Invalid message') {\n        super(message);\n    }\n}\n//# sourceMappingURL=errors.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2lwZnMtdW5peGZzL2Rpc3Qvc3JjL2Vycm9ycy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9iYXJiL2FhL0Fzc29jaWF0ZWRBY2NvdW50cy9ub2RlX21vZHVsZXMvaXBmcy11bml4ZnMvZGlzdC9zcmMvZXJyb3JzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjbGFzcyBJbnZhbGlkVHlwZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIHN0YXRpYyBuYW1lID0gJ0ludmFsaWRUeXBlRXJyb3InO1xuICAgIHN0YXRpYyBjb2RlID0gJ0VSUl9JTlZBTElEX1RZUEUnO1xuICAgIG5hbWUgPSBJbnZhbGlkVHlwZUVycm9yLm5hbWU7XG4gICAgY29kZSA9IEludmFsaWRUeXBlRXJyb3IuY29kZTtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlID0gJ0ludmFsaWQgdHlwZScpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIEludmFsaWRVbml4RlNNZXNzYWdlRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgc3RhdGljIG5hbWUgPSAnSW52YWxpZFVuaXhGU01lc3NhZ2VFcnJvcic7XG4gICAgc3RhdGljIGNvZGUgPSAnRVJSX0lOVkFMSURfTUVTU0FHRSc7XG4gICAgbmFtZSA9IEludmFsaWRVbml4RlNNZXNzYWdlRXJyb3IubmFtZTtcbiAgICBjb2RlID0gSW52YWxpZFVuaXhGU01lc3NhZ2VFcnJvci5jb2RlO1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UgPSAnSW52YWxpZCBtZXNzYWdlJykge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lcnJvcnMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/ipfs-unixfs/dist/src/errors.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/ipfs-unixfs/dist/src/index.js":
/*!********************************************************!*\
  !*** ../../node_modules/ipfs-unixfs/dist/src/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InvalidTypeError: () => (/* reexport safe */ _errors_js__WEBPACK_IMPORTED_MODULE_1__.InvalidTypeError),\n/* harmony export */   InvalidUnixFSMessageError: () => (/* reexport safe */ _errors_js__WEBPACK_IMPORTED_MODULE_1__.InvalidUnixFSMessageError),\n/* harmony export */   UnixFS: () => (/* binding */ UnixFS)\n/* harmony export */ });\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./errors.js */ \"(rsc)/../../node_modules/ipfs-unixfs/dist/src/errors.js\");\n/* harmony import */ var _unixfs_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./unixfs.js */ \"(rsc)/../../node_modules/ipfs-unixfs/dist/src/unixfs.js\");\n/**\n * @packageDocumentation\n *\n * This module contains the protobuf definition of the UnixFS data structure found at the root of all UnixFS DAGs.\n *\n * The UnixFS spec can be found in the [ipfs/specs repository](http://github.com/ipfs/specs)\n *\n * @example Create a file composed of several blocks\n *\n * ```TypeScript\n * import { UnixFS } from 'ipfs-unixfs'\n *\n * const data = new UnixFS({ type: 'file' })\n * data.addBlockSize(256n) // add the size of each block\n * data.addBlockSize(256n)\n * // ...\n * ```\n *\n * @example Create a directory that contains several files\n *\n * Creating a directory that contains several files is achieve by creating a unixfs element that identifies a MerkleDAG node as a directory. The links of that MerkleDAG node are the files that are contained in this directory.\n *\n * ```TypeScript\n * import { UnixFS } from 'ipfs-unixfs'\n *\n * const data = new UnixFS({ type: 'directory' })\n * ```\n *\n * @example Create an unixfs Data element\n *\n * ```TypeScript\n * import { UnixFS } from 'ipfs-unixfs'\n *\n * const data = new UnixFS({\n *   // ...options\n * })\n * ```\n *\n * `options` is an optional object argument that might include the following keys:\n *\n * - type (string, default `file`): The type of UnixFS entry.  Can be:\n *   - `raw`\n *   - `directory`\n *   - `file`\n *   - `metadata`\n *   - `symlink`\n *   - `hamt-sharded-directory`\n * - data (Uint8Array): The optional data field for this node\n * - blockSizes (Array, default: `[]`): If this is a `file` node that is made up of multiple blocks, `blockSizes` is a list numbers that represent the size of the file chunks stored in each child node. It is used to calculate the total file size.\n * - mode (Number, default `0644` for files, `0755` for directories/hamt-sharded-directories) file mode\n * - mtime (`Date`, `{ secs, nsecs }`, `{ Seconds, FractionalNanoseconds }`, `[ secs, nsecs ]`): The modification time of this node\n *\n * @example Add and remove a block size to the block size list\n *\n * ```TypeScript\n * import { UnixFS } from 'ipfs-unixfs'\n *\n * const data = new UnixFS({ type: 'file' })\n * const sizeInBytes = 100n\n * data.addBlockSize(sizeInBytes)\n * ```\n *\n * ```TypeScript\n * import { UnixFS } from 'ipfs-unixfs'\n *\n * const data = new UnixFS({ type: 'file' })\n *\n * const index = 0\n * data.removeBlockSize(index)\n * ```\n *\n * @example Get total fileSize\n *\n * ```TypeScript\n * import { UnixFS } from 'ipfs-unixfs'\n *\n * const data = new UnixFS({ type: 'file' })\n * data.fileSize() // => size in bytes\n * ```\n *\n * @example Marshal and unmarshal\n *\n * ```TypeScript\n * import { UnixFS } from 'ipfs-unixfs'\n *\n * const data = new UnixFS({ type: 'file' })\n * const marshaled = data.marshal()\n * const unmarshaled = UnixFS.unmarshal(marshaled)\n * ```\n *\n * @example Is this UnixFS entry a directory?\n *\n * ```TypeScript\n * import { UnixFS } from 'ipfs-unixfs'\n *\n * const dir = new UnixFS({ type: 'directory' })\n * dir.isDirectory() // true\n *\n * const file = new UnixFS({ type: 'file' })\n * file.isDirectory() // false\n * ```\n *\n * @example Has an mtime been set?\n *\n * If no modification time has been set, no `mtime` property will be present on the `Data` instance:\n *\n * ```TypeScript\n * import { UnixFS } from 'ipfs-unixfs'\n *\n * const file = new UnixFS({ type: 'file' })\n * file.mtime // undefined\n *\n * Object.prototype.hasOwnProperty.call(file, 'mtime') // false\n *\n * const dir = new UnixFS({ type: 'directory', mtime: { secs: 5n } })\n * dir.mtime // { secs: Number, nsecs: Number }\n * ```\n */\n\n\nconst types = {\n    Raw: 'raw',\n    Directory: 'directory',\n    File: 'file',\n    Metadata: 'metadata',\n    Symlink: 'symlink',\n    HAMTShard: 'hamt-sharded-directory'\n};\nconst dirTypes = [\n    'directory',\n    'hamt-sharded-directory'\n];\nconst DEFAULT_FILE_MODE = parseInt('0644', 8);\nconst DEFAULT_DIRECTORY_MODE = parseInt('0755', 8);\n// https://github.com/ipfs/boxo/blob/364c5040ec91ec8e2a61446e9921e9225704c34d/ipld/unixfs/hamt/hamt.go#L778\nconst MAX_FANOUT = BigInt(1 << 10);\nclass UnixFS {\n    /**\n     * Decode from protobuf https://github.com/ipfs/specs/blob/master/UNIXFS.md\n     */\n    static unmarshal(marshaled) {\n        const message = _unixfs_js__WEBPACK_IMPORTED_MODULE_0__.Data.decode(marshaled);\n        if (message.fanout != null && message.fanout > MAX_FANOUT) {\n            throw new _errors_js__WEBPACK_IMPORTED_MODULE_1__.InvalidUnixFSMessageError(`Fanout size was too large - ${message.fanout} > ${MAX_FANOUT}`);\n        }\n        const data = new UnixFS({\n            type: types[message.Type != null ? message.Type.toString() : 'File'],\n            data: message.Data,\n            blockSizes: message.blocksizes,\n            mode: message.mode,\n            mtime: message.mtime != null\n                ? {\n                    secs: message.mtime.Seconds ?? 0n,\n                    nsecs: message.mtime.FractionalNanoseconds\n                }\n                : undefined,\n            fanout: message.fanout\n        });\n        // make sure we honour the original mode\n        data._originalMode = message.mode ?? 0;\n        return data;\n    }\n    type;\n    data;\n    blockSizes;\n    hashType;\n    fanout;\n    mtime;\n    _mode;\n    _originalMode;\n    constructor(options = {\n        type: 'file'\n    }) {\n        const { type, data, blockSizes, hashType, fanout, mtime, mode } = options;\n        if (type != null && !Object.values(types).includes(type)) {\n            throw new _errors_js__WEBPACK_IMPORTED_MODULE_1__.InvalidTypeError('Type: ' + type + ' is not valid');\n        }\n        this.type = type ?? 'file';\n        this.data = data;\n        this.hashType = hashType;\n        this.fanout = fanout;\n        this.blockSizes = blockSizes ?? [];\n        this._originalMode = 0;\n        this.mode = mode;\n        this.mtime = mtime;\n    }\n    set mode(mode) {\n        if (mode == null) {\n            this._mode = this.isDirectory() ? DEFAULT_DIRECTORY_MODE : DEFAULT_FILE_MODE;\n        }\n        else {\n            this._mode = (mode & 0xFFF);\n        }\n    }\n    get mode() {\n        return this._mode;\n    }\n    isDirectory() {\n        return dirTypes.includes(this.type);\n    }\n    addBlockSize(size) {\n        this.blockSizes.push(size);\n    }\n    removeBlockSize(index) {\n        this.blockSizes.splice(index, 1);\n    }\n    /**\n     * Returns `0n` for directories or `data.length + sum(blockSizes)` for everything else\n     */\n    fileSize() {\n        if (this.isDirectory()) {\n            // dirs don't have file size\n            return 0n;\n        }\n        let sum = 0n;\n        this.blockSizes.forEach((size) => {\n            sum += size;\n        });\n        if (this.data != null) {\n            sum += BigInt(this.data.length);\n        }\n        return sum;\n    }\n    /**\n     * encode to protobuf Uint8Array\n     */\n    marshal() {\n        let type;\n        switch (this.type) {\n            case 'raw':\n                type = _unixfs_js__WEBPACK_IMPORTED_MODULE_0__.Data.DataType.Raw;\n                break;\n            case 'directory':\n                type = _unixfs_js__WEBPACK_IMPORTED_MODULE_0__.Data.DataType.Directory;\n                break;\n            case 'file':\n                type = _unixfs_js__WEBPACK_IMPORTED_MODULE_0__.Data.DataType.File;\n                break;\n            case 'metadata':\n                type = _unixfs_js__WEBPACK_IMPORTED_MODULE_0__.Data.DataType.Metadata;\n                break;\n            case 'symlink':\n                type = _unixfs_js__WEBPACK_IMPORTED_MODULE_0__.Data.DataType.Symlink;\n                break;\n            case 'hamt-sharded-directory':\n                type = _unixfs_js__WEBPACK_IMPORTED_MODULE_0__.Data.DataType.HAMTShard;\n                break;\n            default:\n                throw new _errors_js__WEBPACK_IMPORTED_MODULE_1__.InvalidTypeError(`Type: ${type} is not valid`);\n        }\n        let data = this.data;\n        if (this.data == null || this.data.length === 0) {\n            data = undefined;\n        }\n        let mode;\n        if (this.mode != null) {\n            mode = (this._originalMode & 0xFFFFF000) | (this.mode ?? 0);\n            if (mode === DEFAULT_FILE_MODE && !this.isDirectory()) {\n                mode = undefined;\n            }\n            if (mode === DEFAULT_DIRECTORY_MODE && this.isDirectory()) {\n                mode = undefined;\n            }\n        }\n        let mtime;\n        if (this.mtime != null) {\n            mtime = {\n                Seconds: this.mtime.secs,\n                FractionalNanoseconds: this.mtime.nsecs\n            };\n        }\n        return _unixfs_js__WEBPACK_IMPORTED_MODULE_0__.Data.encode({\n            Type: type,\n            Data: data,\n            filesize: this.isDirectory() ? undefined : this.fileSize(),\n            blocksizes: this.blockSizes,\n            hashType: this.hashType,\n            fanout: this.fanout,\n            mode,\n            mtime\n        });\n    }\n}\n\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2lwZnMtdW5peGZzL2Rpc3Qvc3JjL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQSw2QkFBNkIsY0FBYztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQjtBQUNBLDZCQUE2QixtQkFBbUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixhQUFhLE1BQU0sZ0NBQWdDO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCO0FBQ0EsNkJBQTZCLGNBQWM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQjtBQUNBLDZCQUE2QixjQUFjO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQSw2QkFBNkIsY0FBYztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQSw2QkFBNkIsY0FBYztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQjtBQUNBLDRCQUE0QixtQkFBbUI7QUFDL0M7QUFDQTtBQUNBLDZCQUE2QixjQUFjO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQSw2QkFBNkIsY0FBYztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qiw0QkFBNEIsWUFBWTtBQUNwRSxrQkFBa0I7QUFDbEI7QUFDQTtBQUMwRTtBQUM3QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsNENBQU07QUFDOUI7QUFDQSxzQkFBc0IsaUVBQXlCLGdDQUFnQyxnQkFBZ0IsSUFBSSxXQUFXO0FBQzlHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsZ0JBQWdCLHdEQUF3RDtBQUN4RTtBQUNBLHNCQUFzQix3REFBZ0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsNENBQU07QUFDN0I7QUFDQTtBQUNBLHVCQUF1Qiw0Q0FBTTtBQUM3QjtBQUNBO0FBQ0EsdUJBQXVCLDRDQUFNO0FBQzdCO0FBQ0E7QUFDQSx1QkFBdUIsNENBQU07QUFDN0I7QUFDQTtBQUNBLHVCQUF1Qiw0Q0FBTTtBQUM3QjtBQUNBO0FBQ0EsdUJBQXVCLDRDQUFNO0FBQzdCO0FBQ0E7QUFDQSwwQkFBMEIsd0RBQWdCLFVBQVUsTUFBTTtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsNENBQU07QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ2tCO0FBQ1U7QUFDNUIiLCJzb3VyY2VzIjpbIi9ob21lL2JhcmIvYWEvQXNzb2NpYXRlZEFjY291bnRzL25vZGVfbW9kdWxlcy9pcGZzLXVuaXhmcy9kaXN0L3NyYy9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBwYWNrYWdlRG9jdW1lbnRhdGlvblxuICpcbiAqIFRoaXMgbW9kdWxlIGNvbnRhaW5zIHRoZSBwcm90b2J1ZiBkZWZpbml0aW9uIG9mIHRoZSBVbml4RlMgZGF0YSBzdHJ1Y3R1cmUgZm91bmQgYXQgdGhlIHJvb3Qgb2YgYWxsIFVuaXhGUyBEQUdzLlxuICpcbiAqIFRoZSBVbml4RlMgc3BlYyBjYW4gYmUgZm91bmQgaW4gdGhlIFtpcGZzL3NwZWNzIHJlcG9zaXRvcnldKGh0dHA6Ly9naXRodWIuY29tL2lwZnMvc3BlY3MpXG4gKlxuICogQGV4YW1wbGUgQ3JlYXRlIGEgZmlsZSBjb21wb3NlZCBvZiBzZXZlcmFsIGJsb2Nrc1xuICpcbiAqIGBgYFR5cGVTY3JpcHRcbiAqIGltcG9ydCB7IFVuaXhGUyB9IGZyb20gJ2lwZnMtdW5peGZzJ1xuICpcbiAqIGNvbnN0IGRhdGEgPSBuZXcgVW5peEZTKHsgdHlwZTogJ2ZpbGUnIH0pXG4gKiBkYXRhLmFkZEJsb2NrU2l6ZSgyNTZuKSAvLyBhZGQgdGhlIHNpemUgb2YgZWFjaCBibG9ja1xuICogZGF0YS5hZGRCbG9ja1NpemUoMjU2bilcbiAqIC8vIC4uLlxuICogYGBgXG4gKlxuICogQGV4YW1wbGUgQ3JlYXRlIGEgZGlyZWN0b3J5IHRoYXQgY29udGFpbnMgc2V2ZXJhbCBmaWxlc1xuICpcbiAqIENyZWF0aW5nIGEgZGlyZWN0b3J5IHRoYXQgY29udGFpbnMgc2V2ZXJhbCBmaWxlcyBpcyBhY2hpZXZlIGJ5IGNyZWF0aW5nIGEgdW5peGZzIGVsZW1lbnQgdGhhdCBpZGVudGlmaWVzIGEgTWVya2xlREFHIG5vZGUgYXMgYSBkaXJlY3RvcnkuIFRoZSBsaW5rcyBvZiB0aGF0IE1lcmtsZURBRyBub2RlIGFyZSB0aGUgZmlsZXMgdGhhdCBhcmUgY29udGFpbmVkIGluIHRoaXMgZGlyZWN0b3J5LlxuICpcbiAqIGBgYFR5cGVTY3JpcHRcbiAqIGltcG9ydCB7IFVuaXhGUyB9IGZyb20gJ2lwZnMtdW5peGZzJ1xuICpcbiAqIGNvbnN0IGRhdGEgPSBuZXcgVW5peEZTKHsgdHlwZTogJ2RpcmVjdG9yeScgfSlcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlIENyZWF0ZSBhbiB1bml4ZnMgRGF0YSBlbGVtZW50XG4gKlxuICogYGBgVHlwZVNjcmlwdFxuICogaW1wb3J0IHsgVW5peEZTIH0gZnJvbSAnaXBmcy11bml4ZnMnXG4gKlxuICogY29uc3QgZGF0YSA9IG5ldyBVbml4RlMoe1xuICogICAvLyAuLi5vcHRpb25zXG4gKiB9KVxuICogYGBgXG4gKlxuICogYG9wdGlvbnNgIGlzIGFuIG9wdGlvbmFsIG9iamVjdCBhcmd1bWVudCB0aGF0IG1pZ2h0IGluY2x1ZGUgdGhlIGZvbGxvd2luZyBrZXlzOlxuICpcbiAqIC0gdHlwZSAoc3RyaW5nLCBkZWZhdWx0IGBmaWxlYCk6IFRoZSB0eXBlIG9mIFVuaXhGUyBlbnRyeS4gIENhbiBiZTpcbiAqICAgLSBgcmF3YFxuICogICAtIGBkaXJlY3RvcnlgXG4gKiAgIC0gYGZpbGVgXG4gKiAgIC0gYG1ldGFkYXRhYFxuICogICAtIGBzeW1saW5rYFxuICogICAtIGBoYW10LXNoYXJkZWQtZGlyZWN0b3J5YFxuICogLSBkYXRhIChVaW50OEFycmF5KTogVGhlIG9wdGlvbmFsIGRhdGEgZmllbGQgZm9yIHRoaXMgbm9kZVxuICogLSBibG9ja1NpemVzIChBcnJheSwgZGVmYXVsdDogYFtdYCk6IElmIHRoaXMgaXMgYSBgZmlsZWAgbm9kZSB0aGF0IGlzIG1hZGUgdXAgb2YgbXVsdGlwbGUgYmxvY2tzLCBgYmxvY2tTaXplc2AgaXMgYSBsaXN0IG51bWJlcnMgdGhhdCByZXByZXNlbnQgdGhlIHNpemUgb2YgdGhlIGZpbGUgY2h1bmtzIHN0b3JlZCBpbiBlYWNoIGNoaWxkIG5vZGUuIEl0IGlzIHVzZWQgdG8gY2FsY3VsYXRlIHRoZSB0b3RhbCBmaWxlIHNpemUuXG4gKiAtIG1vZGUgKE51bWJlciwgZGVmYXVsdCBgMDY0NGAgZm9yIGZpbGVzLCBgMDc1NWAgZm9yIGRpcmVjdG9yaWVzL2hhbXQtc2hhcmRlZC1kaXJlY3RvcmllcykgZmlsZSBtb2RlXG4gKiAtIG10aW1lIChgRGF0ZWAsIGB7IHNlY3MsIG5zZWNzIH1gLCBgeyBTZWNvbmRzLCBGcmFjdGlvbmFsTmFub3NlY29uZHMgfWAsIGBbIHNlY3MsIG5zZWNzIF1gKTogVGhlIG1vZGlmaWNhdGlvbiB0aW1lIG9mIHRoaXMgbm9kZVxuICpcbiAqIEBleGFtcGxlIEFkZCBhbmQgcmVtb3ZlIGEgYmxvY2sgc2l6ZSB0byB0aGUgYmxvY2sgc2l6ZSBsaXN0XG4gKlxuICogYGBgVHlwZVNjcmlwdFxuICogaW1wb3J0IHsgVW5peEZTIH0gZnJvbSAnaXBmcy11bml4ZnMnXG4gKlxuICogY29uc3QgZGF0YSA9IG5ldyBVbml4RlMoeyB0eXBlOiAnZmlsZScgfSlcbiAqIGNvbnN0IHNpemVJbkJ5dGVzID0gMTAwblxuICogZGF0YS5hZGRCbG9ja1NpemUoc2l6ZUluQnl0ZXMpXG4gKiBgYGBcbiAqXG4gKiBgYGBUeXBlU2NyaXB0XG4gKiBpbXBvcnQgeyBVbml4RlMgfSBmcm9tICdpcGZzLXVuaXhmcydcbiAqXG4gKiBjb25zdCBkYXRhID0gbmV3IFVuaXhGUyh7IHR5cGU6ICdmaWxlJyB9KVxuICpcbiAqIGNvbnN0IGluZGV4ID0gMFxuICogZGF0YS5yZW1vdmVCbG9ja1NpemUoaW5kZXgpXG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZSBHZXQgdG90YWwgZmlsZVNpemVcbiAqXG4gKiBgYGBUeXBlU2NyaXB0XG4gKiBpbXBvcnQgeyBVbml4RlMgfSBmcm9tICdpcGZzLXVuaXhmcydcbiAqXG4gKiBjb25zdCBkYXRhID0gbmV3IFVuaXhGUyh7IHR5cGU6ICdmaWxlJyB9KVxuICogZGF0YS5maWxlU2l6ZSgpIC8vID0+IHNpemUgaW4gYnl0ZXNcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlIE1hcnNoYWwgYW5kIHVubWFyc2hhbFxuICpcbiAqIGBgYFR5cGVTY3JpcHRcbiAqIGltcG9ydCB7IFVuaXhGUyB9IGZyb20gJ2lwZnMtdW5peGZzJ1xuICpcbiAqIGNvbnN0IGRhdGEgPSBuZXcgVW5peEZTKHsgdHlwZTogJ2ZpbGUnIH0pXG4gKiBjb25zdCBtYXJzaGFsZWQgPSBkYXRhLm1hcnNoYWwoKVxuICogY29uc3QgdW5tYXJzaGFsZWQgPSBVbml4RlMudW5tYXJzaGFsKG1hcnNoYWxlZClcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlIElzIHRoaXMgVW5peEZTIGVudHJ5IGEgZGlyZWN0b3J5P1xuICpcbiAqIGBgYFR5cGVTY3JpcHRcbiAqIGltcG9ydCB7IFVuaXhGUyB9IGZyb20gJ2lwZnMtdW5peGZzJ1xuICpcbiAqIGNvbnN0IGRpciA9IG5ldyBVbml4RlMoeyB0eXBlOiAnZGlyZWN0b3J5JyB9KVxuICogZGlyLmlzRGlyZWN0b3J5KCkgLy8gdHJ1ZVxuICpcbiAqIGNvbnN0IGZpbGUgPSBuZXcgVW5peEZTKHsgdHlwZTogJ2ZpbGUnIH0pXG4gKiBmaWxlLmlzRGlyZWN0b3J5KCkgLy8gZmFsc2VcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlIEhhcyBhbiBtdGltZSBiZWVuIHNldD9cbiAqXG4gKiBJZiBubyBtb2RpZmljYXRpb24gdGltZSBoYXMgYmVlbiBzZXQsIG5vIGBtdGltZWAgcHJvcGVydHkgd2lsbCBiZSBwcmVzZW50IG9uIHRoZSBgRGF0YWAgaW5zdGFuY2U6XG4gKlxuICogYGBgVHlwZVNjcmlwdFxuICogaW1wb3J0IHsgVW5peEZTIH0gZnJvbSAnaXBmcy11bml4ZnMnXG4gKlxuICogY29uc3QgZmlsZSA9IG5ldyBVbml4RlMoeyB0eXBlOiAnZmlsZScgfSlcbiAqIGZpbGUubXRpbWUgLy8gdW5kZWZpbmVkXG4gKlxuICogT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGZpbGUsICdtdGltZScpIC8vIGZhbHNlXG4gKlxuICogY29uc3QgZGlyID0gbmV3IFVuaXhGUyh7IHR5cGU6ICdkaXJlY3RvcnknLCBtdGltZTogeyBzZWNzOiA1biB9IH0pXG4gKiBkaXIubXRpbWUgLy8geyBzZWNzOiBOdW1iZXIsIG5zZWNzOiBOdW1iZXIgfVxuICogYGBgXG4gKi9cbmltcG9ydCB7IEludmFsaWRUeXBlRXJyb3IsIEludmFsaWRVbml4RlNNZXNzYWdlRXJyb3IgfSBmcm9tICcuL2Vycm9ycy5qcyc7XG5pbXBvcnQgeyBEYXRhIGFzIFBCRGF0YSB9IGZyb20gJy4vdW5peGZzLmpzJztcbmNvbnN0IHR5cGVzID0ge1xuICAgIFJhdzogJ3JhdycsXG4gICAgRGlyZWN0b3J5OiAnZGlyZWN0b3J5JyxcbiAgICBGaWxlOiAnZmlsZScsXG4gICAgTWV0YWRhdGE6ICdtZXRhZGF0YScsXG4gICAgU3ltbGluazogJ3N5bWxpbmsnLFxuICAgIEhBTVRTaGFyZDogJ2hhbXQtc2hhcmRlZC1kaXJlY3RvcnknXG59O1xuY29uc3QgZGlyVHlwZXMgPSBbXG4gICAgJ2RpcmVjdG9yeScsXG4gICAgJ2hhbXQtc2hhcmRlZC1kaXJlY3RvcnknXG5dO1xuY29uc3QgREVGQVVMVF9GSUxFX01PREUgPSBwYXJzZUludCgnMDY0NCcsIDgpO1xuY29uc3QgREVGQVVMVF9ESVJFQ1RPUllfTU9ERSA9IHBhcnNlSW50KCcwNzU1JywgOCk7XG4vLyBodHRwczovL2dpdGh1Yi5jb20vaXBmcy9ib3hvL2Jsb2IvMzY0YzUwNDBlYzkxZWM4ZTJhNjE0NDZlOTkyMWU5MjI1NzA0YzM0ZC9pcGxkL3VuaXhmcy9oYW10L2hhbXQuZ28jTDc3OFxuY29uc3QgTUFYX0ZBTk9VVCA9IEJpZ0ludCgxIDw8IDEwKTtcbmNsYXNzIFVuaXhGUyB7XG4gICAgLyoqXG4gICAgICogRGVjb2RlIGZyb20gcHJvdG9idWYgaHR0cHM6Ly9naXRodWIuY29tL2lwZnMvc3BlY3MvYmxvYi9tYXN0ZXIvVU5JWEZTLm1kXG4gICAgICovXG4gICAgc3RhdGljIHVubWFyc2hhbChtYXJzaGFsZWQpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IFBCRGF0YS5kZWNvZGUobWFyc2hhbGVkKTtcbiAgICAgICAgaWYgKG1lc3NhZ2UuZmFub3V0ICE9IG51bGwgJiYgbWVzc2FnZS5mYW5vdXQgPiBNQVhfRkFOT1VUKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFVuaXhGU01lc3NhZ2VFcnJvcihgRmFub3V0IHNpemUgd2FzIHRvbyBsYXJnZSAtICR7bWVzc2FnZS5mYW5vdXR9ID4gJHtNQVhfRkFOT1VUfWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRhdGEgPSBuZXcgVW5peEZTKHtcbiAgICAgICAgICAgIHR5cGU6IHR5cGVzW21lc3NhZ2UuVHlwZSAhPSBudWxsID8gbWVzc2FnZS5UeXBlLnRvU3RyaW5nKCkgOiAnRmlsZSddLFxuICAgICAgICAgICAgZGF0YTogbWVzc2FnZS5EYXRhLFxuICAgICAgICAgICAgYmxvY2tTaXplczogbWVzc2FnZS5ibG9ja3NpemVzLFxuICAgICAgICAgICAgbW9kZTogbWVzc2FnZS5tb2RlLFxuICAgICAgICAgICAgbXRpbWU6IG1lc3NhZ2UubXRpbWUgIT0gbnVsbFxuICAgICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgICBzZWNzOiBtZXNzYWdlLm10aW1lLlNlY29uZHMgPz8gMG4sXG4gICAgICAgICAgICAgICAgICAgIG5zZWNzOiBtZXNzYWdlLm10aW1lLkZyYWN0aW9uYWxOYW5vc2Vjb25kc1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGZhbm91dDogbWVzc2FnZS5mYW5vdXRcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIG1ha2Ugc3VyZSB3ZSBob25vdXIgdGhlIG9yaWdpbmFsIG1vZGVcbiAgICAgICAgZGF0YS5fb3JpZ2luYWxNb2RlID0gbWVzc2FnZS5tb2RlID8/IDA7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICB0eXBlO1xuICAgIGRhdGE7XG4gICAgYmxvY2tTaXplcztcbiAgICBoYXNoVHlwZTtcbiAgICBmYW5vdXQ7XG4gICAgbXRpbWU7XG4gICAgX21vZGU7XG4gICAgX29yaWdpbmFsTW9kZTtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge1xuICAgICAgICB0eXBlOiAnZmlsZSdcbiAgICB9KSB7XG4gICAgICAgIGNvbnN0IHsgdHlwZSwgZGF0YSwgYmxvY2tTaXplcywgaGFzaFR5cGUsIGZhbm91dCwgbXRpbWUsIG1vZGUgfSA9IG9wdGlvbnM7XG4gICAgICAgIGlmICh0eXBlICE9IG51bGwgJiYgIU9iamVjdC52YWx1ZXModHlwZXMpLmluY2x1ZGVzKHR5cGUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFR5cGVFcnJvcignVHlwZTogJyArIHR5cGUgKyAnIGlzIG5vdCB2YWxpZCcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGUgPz8gJ2ZpbGUnO1xuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgICB0aGlzLmhhc2hUeXBlID0gaGFzaFR5cGU7XG4gICAgICAgIHRoaXMuZmFub3V0ID0gZmFub3V0O1xuICAgICAgICB0aGlzLmJsb2NrU2l6ZXMgPSBibG9ja1NpemVzID8/IFtdO1xuICAgICAgICB0aGlzLl9vcmlnaW5hbE1vZGUgPSAwO1xuICAgICAgICB0aGlzLm1vZGUgPSBtb2RlO1xuICAgICAgICB0aGlzLm10aW1lID0gbXRpbWU7XG4gICAgfVxuICAgIHNldCBtb2RlKG1vZGUpIHtcbiAgICAgICAgaWYgKG1vZGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fbW9kZSA9IHRoaXMuaXNEaXJlY3RvcnkoKSA/IERFRkFVTFRfRElSRUNUT1JZX01PREUgOiBERUZBVUxUX0ZJTEVfTU9ERTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX21vZGUgPSAobW9kZSAmIDB4RkZGKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgbW9kZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21vZGU7XG4gICAgfVxuICAgIGlzRGlyZWN0b3J5KCkge1xuICAgICAgICByZXR1cm4gZGlyVHlwZXMuaW5jbHVkZXModGhpcy50eXBlKTtcbiAgICB9XG4gICAgYWRkQmxvY2tTaXplKHNpemUpIHtcbiAgICAgICAgdGhpcy5ibG9ja1NpemVzLnB1c2goc2l6ZSk7XG4gICAgfVxuICAgIHJlbW92ZUJsb2NrU2l6ZShpbmRleCkge1xuICAgICAgICB0aGlzLmJsb2NrU2l6ZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBgMG5gIGZvciBkaXJlY3RvcmllcyBvciBgZGF0YS5sZW5ndGggKyBzdW0oYmxvY2tTaXplcylgIGZvciBldmVyeXRoaW5nIGVsc2VcbiAgICAgKi9cbiAgICBmaWxlU2l6ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNEaXJlY3RvcnkoKSkge1xuICAgICAgICAgICAgLy8gZGlycyBkb24ndCBoYXZlIGZpbGUgc2l6ZVxuICAgICAgICAgICAgcmV0dXJuIDBuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzdW0gPSAwbjtcbiAgICAgICAgdGhpcy5ibG9ja1NpemVzLmZvckVhY2goKHNpemUpID0+IHtcbiAgICAgICAgICAgIHN1bSArPSBzaXplO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHRoaXMuZGF0YSAhPSBudWxsKSB7XG4gICAgICAgICAgICBzdW0gKz0gQmlnSW50KHRoaXMuZGF0YS5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdW07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGVuY29kZSB0byBwcm90b2J1ZiBVaW50OEFycmF5XG4gICAgICovXG4gICAgbWFyc2hhbCgpIHtcbiAgICAgICAgbGV0IHR5cGU7XG4gICAgICAgIHN3aXRjaCAodGhpcy50eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdyYXcnOlxuICAgICAgICAgICAgICAgIHR5cGUgPSBQQkRhdGEuRGF0YVR5cGUuUmF3O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZGlyZWN0b3J5JzpcbiAgICAgICAgICAgICAgICB0eXBlID0gUEJEYXRhLkRhdGFUeXBlLkRpcmVjdG9yeTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2ZpbGUnOlxuICAgICAgICAgICAgICAgIHR5cGUgPSBQQkRhdGEuRGF0YVR5cGUuRmlsZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ21ldGFkYXRhJzpcbiAgICAgICAgICAgICAgICB0eXBlID0gUEJEYXRhLkRhdGFUeXBlLk1ldGFkYXRhO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnc3ltbGluayc6XG4gICAgICAgICAgICAgICAgdHlwZSA9IFBCRGF0YS5EYXRhVHlwZS5TeW1saW5rO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnaGFtdC1zaGFyZGVkLWRpcmVjdG9yeSc6XG4gICAgICAgICAgICAgICAgdHlwZSA9IFBCRGF0YS5EYXRhVHlwZS5IQU1UU2hhcmQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkVHlwZUVycm9yKGBUeXBlOiAke3R5cGV9IGlzIG5vdCB2YWxpZGApO1xuICAgICAgICB9XG4gICAgICAgIGxldCBkYXRhID0gdGhpcy5kYXRhO1xuICAgICAgICBpZiAodGhpcy5kYXRhID09IG51bGwgfHwgdGhpcy5kYXRhLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgZGF0YSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbW9kZTtcbiAgICAgICAgaWYgKHRoaXMubW9kZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBtb2RlID0gKHRoaXMuX29yaWdpbmFsTW9kZSAmIDB4RkZGRkYwMDApIHwgKHRoaXMubW9kZSA/PyAwKTtcbiAgICAgICAgICAgIGlmIChtb2RlID09PSBERUZBVUxUX0ZJTEVfTU9ERSAmJiAhdGhpcy5pc0RpcmVjdG9yeSgpKSB7XG4gICAgICAgICAgICAgICAgbW9kZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtb2RlID09PSBERUZBVUxUX0RJUkVDVE9SWV9NT0RFICYmIHRoaXMuaXNEaXJlY3RvcnkoKSkge1xuICAgICAgICAgICAgICAgIG1vZGUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG10aW1lO1xuICAgICAgICBpZiAodGhpcy5tdGltZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBtdGltZSA9IHtcbiAgICAgICAgICAgICAgICBTZWNvbmRzOiB0aGlzLm10aW1lLnNlY3MsXG4gICAgICAgICAgICAgICAgRnJhY3Rpb25hbE5hbm9zZWNvbmRzOiB0aGlzLm10aW1lLm5zZWNzXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQQkRhdGEuZW5jb2RlKHtcbiAgICAgICAgICAgIFR5cGU6IHR5cGUsXG4gICAgICAgICAgICBEYXRhOiBkYXRhLFxuICAgICAgICAgICAgZmlsZXNpemU6IHRoaXMuaXNEaXJlY3RvcnkoKSA/IHVuZGVmaW5lZCA6IHRoaXMuZmlsZVNpemUoKSxcbiAgICAgICAgICAgIGJsb2Nrc2l6ZXM6IHRoaXMuYmxvY2tTaXplcyxcbiAgICAgICAgICAgIGhhc2hUeXBlOiB0aGlzLmhhc2hUeXBlLFxuICAgICAgICAgICAgZmFub3V0OiB0aGlzLmZhbm91dCxcbiAgICAgICAgICAgIG1vZGUsXG4gICAgICAgICAgICBtdGltZVxuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnQgeyBVbml4RlMgfTtcbmV4cG9ydCAqIGZyb20gJy4vZXJyb3JzLmpzJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/ipfs-unixfs/dist/src/index.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/ipfs-unixfs/dist/src/unixfs.js":
/*!*********************************************************!*\
  !*** ../../node_modules/ipfs-unixfs/dist/src/unixfs.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Data: () => (/* binding */ Data),\n/* harmony export */   Metadata: () => (/* binding */ Metadata),\n/* harmony export */   UnixTime: () => (/* binding */ UnixTime)\n/* harmony export */ });\n/* harmony import */ var protons_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! protons-runtime */ \"(rsc)/../../node_modules/protons-runtime/dist/src/index.js\");\n\nvar Data;\n(function (Data) {\n    let DataType;\n    (function (DataType) {\n        DataType[\"Raw\"] = \"Raw\";\n        DataType[\"Directory\"] = \"Directory\";\n        DataType[\"File\"] = \"File\";\n        DataType[\"Metadata\"] = \"Metadata\";\n        DataType[\"Symlink\"] = \"Symlink\";\n        DataType[\"HAMTShard\"] = \"HAMTShard\";\n    })(DataType = Data.DataType || (Data.DataType = {}));\n    let __DataTypeValues;\n    (function (__DataTypeValues) {\n        __DataTypeValues[__DataTypeValues[\"Raw\"] = 0] = \"Raw\";\n        __DataTypeValues[__DataTypeValues[\"Directory\"] = 1] = \"Directory\";\n        __DataTypeValues[__DataTypeValues[\"File\"] = 2] = \"File\";\n        __DataTypeValues[__DataTypeValues[\"Metadata\"] = 3] = \"Metadata\";\n        __DataTypeValues[__DataTypeValues[\"Symlink\"] = 4] = \"Symlink\";\n        __DataTypeValues[__DataTypeValues[\"HAMTShard\"] = 5] = \"HAMTShard\";\n    })(__DataTypeValues || (__DataTypeValues = {}));\n    (function (DataType) {\n        DataType.codec = () => {\n            return (0,protons_runtime__WEBPACK_IMPORTED_MODULE_0__.enumeration)(__DataTypeValues);\n        };\n    })(DataType = Data.DataType || (Data.DataType = {}));\n    let _codec;\n    Data.codec = () => {\n        if (_codec == null) {\n            _codec = (0,protons_runtime__WEBPACK_IMPORTED_MODULE_0__.message)((obj, w, opts = {}) => {\n                if (opts.lengthDelimited !== false) {\n                    w.fork();\n                }\n                if (obj.Type != null) {\n                    w.uint32(8);\n                    Data.DataType.codec().encode(obj.Type, w);\n                }\n                if (obj.Data != null) {\n                    w.uint32(18);\n                    w.bytes(obj.Data);\n                }\n                if (obj.filesize != null) {\n                    w.uint32(24);\n                    w.uint64(obj.filesize);\n                }\n                if (obj.blocksizes != null) {\n                    for (const value of obj.blocksizes) {\n                        w.uint32(32);\n                        w.uint64(value);\n                    }\n                }\n                if (obj.hashType != null) {\n                    w.uint32(40);\n                    w.uint64(obj.hashType);\n                }\n                if (obj.fanout != null) {\n                    w.uint32(48);\n                    w.uint64(obj.fanout);\n                }\n                if (obj.mode != null) {\n                    w.uint32(56);\n                    w.uint32(obj.mode);\n                }\n                if (obj.mtime != null) {\n                    w.uint32(66);\n                    UnixTime.codec().encode(obj.mtime, w);\n                }\n                if (opts.lengthDelimited !== false) {\n                    w.ldelim();\n                }\n            }, (reader, length) => {\n                const obj = {\n                    blocksizes: []\n                };\n                const end = length == null ? reader.len : reader.pos + length;\n                while (reader.pos < end) {\n                    const tag = reader.uint32();\n                    switch (tag >>> 3) {\n                        case 1:\n                            obj.Type = Data.DataType.codec().decode(reader);\n                            break;\n                        case 2:\n                            obj.Data = reader.bytes();\n                            break;\n                        case 3:\n                            obj.filesize = reader.uint64();\n                            break;\n                        case 4:\n                            obj.blocksizes.push(reader.uint64());\n                            break;\n                        case 5:\n                            obj.hashType = reader.uint64();\n                            break;\n                        case 6:\n                            obj.fanout = reader.uint64();\n                            break;\n                        case 7:\n                            obj.mode = reader.uint32();\n                            break;\n                        case 8:\n                            obj.mtime = UnixTime.codec().decode(reader, reader.uint32());\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                    }\n                }\n                return obj;\n            });\n        }\n        return _codec;\n    };\n    Data.encode = (obj) => {\n        return (0,protons_runtime__WEBPACK_IMPORTED_MODULE_0__.encodeMessage)(obj, Data.codec());\n    };\n    Data.decode = (buf) => {\n        return (0,protons_runtime__WEBPACK_IMPORTED_MODULE_0__.decodeMessage)(buf, Data.codec());\n    };\n})(Data || (Data = {}));\nvar UnixTime;\n(function (UnixTime) {\n    let _codec;\n    UnixTime.codec = () => {\n        if (_codec == null) {\n            _codec = (0,protons_runtime__WEBPACK_IMPORTED_MODULE_0__.message)((obj, w, opts = {}) => {\n                if (opts.lengthDelimited !== false) {\n                    w.fork();\n                }\n                if (obj.Seconds != null) {\n                    w.uint32(8);\n                    w.int64(obj.Seconds);\n                }\n                if (obj.FractionalNanoseconds != null) {\n                    w.uint32(21);\n                    w.fixed32(obj.FractionalNanoseconds);\n                }\n                if (opts.lengthDelimited !== false) {\n                    w.ldelim();\n                }\n            }, (reader, length) => {\n                const obj = {};\n                const end = length == null ? reader.len : reader.pos + length;\n                while (reader.pos < end) {\n                    const tag = reader.uint32();\n                    switch (tag >>> 3) {\n                        case 1:\n                            obj.Seconds = reader.int64();\n                            break;\n                        case 2:\n                            obj.FractionalNanoseconds = reader.fixed32();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                    }\n                }\n                return obj;\n            });\n        }\n        return _codec;\n    };\n    UnixTime.encode = (obj) => {\n        return (0,protons_runtime__WEBPACK_IMPORTED_MODULE_0__.encodeMessage)(obj, UnixTime.codec());\n    };\n    UnixTime.decode = (buf) => {\n        return (0,protons_runtime__WEBPACK_IMPORTED_MODULE_0__.decodeMessage)(buf, UnixTime.codec());\n    };\n})(UnixTime || (UnixTime = {}));\nvar Metadata;\n(function (Metadata) {\n    let _codec;\n    Metadata.codec = () => {\n        if (_codec == null) {\n            _codec = (0,protons_runtime__WEBPACK_IMPORTED_MODULE_0__.message)((obj, w, opts = {}) => {\n                if (opts.lengthDelimited !== false) {\n                    w.fork();\n                }\n                if (obj.MimeType != null) {\n                    w.uint32(10);\n                    w.string(obj.MimeType);\n                }\n                if (opts.lengthDelimited !== false) {\n                    w.ldelim();\n                }\n            }, (reader, length) => {\n                const obj = {};\n                const end = length == null ? reader.len : reader.pos + length;\n                while (reader.pos < end) {\n                    const tag = reader.uint32();\n                    switch (tag >>> 3) {\n                        case 1:\n                            obj.MimeType = reader.string();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                    }\n                }\n                return obj;\n            });\n        }\n        return _codec;\n    };\n    Metadata.encode = (obj) => {\n        return (0,protons_runtime__WEBPACK_IMPORTED_MODULE_0__.encodeMessage)(obj, Metadata.codec());\n    };\n    Metadata.decode = (buf) => {\n        return (0,protons_runtime__WEBPACK_IMPORTED_MODULE_0__.decodeMessage)(buf, Metadata.codec());\n    };\n})(Metadata || (Metadata = {}));\n//# sourceMappingURL=unixfs.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2lwZnMtdW5peGZzL2Rpc3Qvc3JjL3VuaXhmcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQXFGO0FBQzlFO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxpREFBaUQ7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssNENBQTRDO0FBQ2pEO0FBQ0E7QUFDQSxtQkFBbUIsNERBQVc7QUFDOUI7QUFDQSxLQUFLLGlEQUFpRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsd0RBQU8sbUJBQW1CO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSw4REFBYTtBQUM1QjtBQUNBO0FBQ0EsZUFBZSw4REFBYTtBQUM1QjtBQUNBLENBQUMsb0JBQW9CO0FBQ2Q7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix3REFBTyxtQkFBbUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSw4REFBYTtBQUM1QjtBQUNBO0FBQ0EsZUFBZSw4REFBYTtBQUM1QjtBQUNBLENBQUMsNEJBQTRCO0FBQ3RCO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsd0RBQU8sbUJBQW1CO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDhEQUFhO0FBQzVCO0FBQ0E7QUFDQSxlQUFlLDhEQUFhO0FBQzVCO0FBQ0EsQ0FBQyw0QkFBNEI7QUFDN0IiLCJzb3VyY2VzIjpbIi9ob21lL2JhcmIvYWEvQXNzb2NpYXRlZEFjY291bnRzL25vZGVfbW9kdWxlcy9pcGZzLXVuaXhmcy9kaXN0L3NyYy91bml4ZnMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZW51bWVyYXRpb24sIGVuY29kZU1lc3NhZ2UsIGRlY29kZU1lc3NhZ2UsIG1lc3NhZ2UgfSBmcm9tICdwcm90b25zLXJ1bnRpbWUnO1xuZXhwb3J0IHZhciBEYXRhO1xuKGZ1bmN0aW9uIChEYXRhKSB7XG4gICAgbGV0IERhdGFUeXBlO1xuICAgIChmdW5jdGlvbiAoRGF0YVR5cGUpIHtcbiAgICAgICAgRGF0YVR5cGVbXCJSYXdcIl0gPSBcIlJhd1wiO1xuICAgICAgICBEYXRhVHlwZVtcIkRpcmVjdG9yeVwiXSA9IFwiRGlyZWN0b3J5XCI7XG4gICAgICAgIERhdGFUeXBlW1wiRmlsZVwiXSA9IFwiRmlsZVwiO1xuICAgICAgICBEYXRhVHlwZVtcIk1ldGFkYXRhXCJdID0gXCJNZXRhZGF0YVwiO1xuICAgICAgICBEYXRhVHlwZVtcIlN5bWxpbmtcIl0gPSBcIlN5bWxpbmtcIjtcbiAgICAgICAgRGF0YVR5cGVbXCJIQU1UU2hhcmRcIl0gPSBcIkhBTVRTaGFyZFwiO1xuICAgIH0pKERhdGFUeXBlID0gRGF0YS5EYXRhVHlwZSB8fCAoRGF0YS5EYXRhVHlwZSA9IHt9KSk7XG4gICAgbGV0IF9fRGF0YVR5cGVWYWx1ZXM7XG4gICAgKGZ1bmN0aW9uIChfX0RhdGFUeXBlVmFsdWVzKSB7XG4gICAgICAgIF9fRGF0YVR5cGVWYWx1ZXNbX19EYXRhVHlwZVZhbHVlc1tcIlJhd1wiXSA9IDBdID0gXCJSYXdcIjtcbiAgICAgICAgX19EYXRhVHlwZVZhbHVlc1tfX0RhdGFUeXBlVmFsdWVzW1wiRGlyZWN0b3J5XCJdID0gMV0gPSBcIkRpcmVjdG9yeVwiO1xuICAgICAgICBfX0RhdGFUeXBlVmFsdWVzW19fRGF0YVR5cGVWYWx1ZXNbXCJGaWxlXCJdID0gMl0gPSBcIkZpbGVcIjtcbiAgICAgICAgX19EYXRhVHlwZVZhbHVlc1tfX0RhdGFUeXBlVmFsdWVzW1wiTWV0YWRhdGFcIl0gPSAzXSA9IFwiTWV0YWRhdGFcIjtcbiAgICAgICAgX19EYXRhVHlwZVZhbHVlc1tfX0RhdGFUeXBlVmFsdWVzW1wiU3ltbGlua1wiXSA9IDRdID0gXCJTeW1saW5rXCI7XG4gICAgICAgIF9fRGF0YVR5cGVWYWx1ZXNbX19EYXRhVHlwZVZhbHVlc1tcIkhBTVRTaGFyZFwiXSA9IDVdID0gXCJIQU1UU2hhcmRcIjtcbiAgICB9KShfX0RhdGFUeXBlVmFsdWVzIHx8IChfX0RhdGFUeXBlVmFsdWVzID0ge30pKTtcbiAgICAoZnVuY3Rpb24gKERhdGFUeXBlKSB7XG4gICAgICAgIERhdGFUeXBlLmNvZGVjID0gKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGVudW1lcmF0aW9uKF9fRGF0YVR5cGVWYWx1ZXMpO1xuICAgICAgICB9O1xuICAgIH0pKERhdGFUeXBlID0gRGF0YS5EYXRhVHlwZSB8fCAoRGF0YS5EYXRhVHlwZSA9IHt9KSk7XG4gICAgbGV0IF9jb2RlYztcbiAgICBEYXRhLmNvZGVjID0gKCkgPT4ge1xuICAgICAgICBpZiAoX2NvZGVjID09IG51bGwpIHtcbiAgICAgICAgICAgIF9jb2RlYyA9IG1lc3NhZ2UoKG9iaiwgdywgb3B0cyA9IHt9KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKG9wdHMubGVuZ3RoRGVsaW1pdGVkICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICB3LmZvcmsoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG9iai5UeXBlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdy51aW50MzIoOCk7XG4gICAgICAgICAgICAgICAgICAgIERhdGEuRGF0YVR5cGUuY29kZWMoKS5lbmNvZGUob2JqLlR5cGUsIHcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAob2JqLkRhdGEgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB3LnVpbnQzMigxOCk7XG4gICAgICAgICAgICAgICAgICAgIHcuYnl0ZXMob2JqLkRhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAob2JqLmZpbGVzaXplICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdy51aW50MzIoMjQpO1xuICAgICAgICAgICAgICAgICAgICB3LnVpbnQ2NChvYmouZmlsZXNpemUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAob2JqLmJsb2Nrc2l6ZXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIG9iai5ibG9ja3NpemVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3LnVpbnQzMigzMik7XG4gICAgICAgICAgICAgICAgICAgICAgICB3LnVpbnQ2NCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG9iai5oYXNoVHlwZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHcudWludDMyKDQwKTtcbiAgICAgICAgICAgICAgICAgICAgdy51aW50NjQob2JqLmhhc2hUeXBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG9iai5mYW5vdXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB3LnVpbnQzMig0OCk7XG4gICAgICAgICAgICAgICAgICAgIHcudWludDY0KG9iai5mYW5vdXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAob2JqLm1vZGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB3LnVpbnQzMig1Nik7XG4gICAgICAgICAgICAgICAgICAgIHcudWludDMyKG9iai5tb2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG9iai5tdGltZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHcudWludDMyKDY2KTtcbiAgICAgICAgICAgICAgICAgICAgVW5peFRpbWUuY29kZWMoKS5lbmNvZGUob2JqLm10aW1lLCB3KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG9wdHMubGVuZ3RoRGVsaW1pdGVkICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICB3LmxkZWxpbSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIChyZWFkZXIsIGxlbmd0aCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9iaiA9IHtcbiAgICAgICAgICAgICAgICAgICAgYmxvY2tzaXplczogW11cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGNvbnN0IGVuZCA9IGxlbmd0aCA9PSBudWxsID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iai5UeXBlID0gRGF0YS5EYXRhVHlwZS5jb2RlYygpLmRlY29kZShyZWFkZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iai5EYXRhID0gcmVhZGVyLmJ5dGVzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqLmZpbGVzaXplID0gcmVhZGVyLnVpbnQ2NCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iai5ibG9ja3NpemVzLnB1c2gocmVhZGVyLnVpbnQ2NCgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmouaGFzaFR5cGUgPSByZWFkZXIudWludDY0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqLmZhbm91dCA9IHJlYWRlci51aW50NjQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmoubW9kZSA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmoubXRpbWUgPSBVbml4VGltZS5jb2RlYygpLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9jb2RlYztcbiAgICB9O1xuICAgIERhdGEuZW5jb2RlID0gKG9iaikgPT4ge1xuICAgICAgICByZXR1cm4gZW5jb2RlTWVzc2FnZShvYmosIERhdGEuY29kZWMoKSk7XG4gICAgfTtcbiAgICBEYXRhLmRlY29kZSA9IChidWYpID0+IHtcbiAgICAgICAgcmV0dXJuIGRlY29kZU1lc3NhZ2UoYnVmLCBEYXRhLmNvZGVjKCkpO1xuICAgIH07XG59KShEYXRhIHx8IChEYXRhID0ge30pKTtcbmV4cG9ydCB2YXIgVW5peFRpbWU7XG4oZnVuY3Rpb24gKFVuaXhUaW1lKSB7XG4gICAgbGV0IF9jb2RlYztcbiAgICBVbml4VGltZS5jb2RlYyA9ICgpID0+IHtcbiAgICAgICAgaWYgKF9jb2RlYyA9PSBudWxsKSB7XG4gICAgICAgICAgICBfY29kZWMgPSBtZXNzYWdlKChvYmosIHcsIG9wdHMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChvcHRzLmxlbmd0aERlbGltaXRlZCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdy5mb3JrKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChvYmouU2Vjb25kcyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHcudWludDMyKDgpO1xuICAgICAgICAgICAgICAgICAgICB3LmludDY0KG9iai5TZWNvbmRzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG9iai5GcmFjdGlvbmFsTmFub3NlY29uZHMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB3LnVpbnQzMigyMSk7XG4gICAgICAgICAgICAgICAgICAgIHcuZml4ZWQzMihvYmouRnJhY3Rpb25hbE5hbm9zZWNvbmRzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG9wdHMubGVuZ3RoRGVsaW1pdGVkICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICB3LmxkZWxpbSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIChyZWFkZXIsIGxlbmd0aCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICAgICAgICAgIGNvbnN0IGVuZCA9IGxlbmd0aCA9PSBudWxsID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iai5TZWNvbmRzID0gcmVhZGVyLmludDY0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqLkZyYWN0aW9uYWxOYW5vc2Vjb25kcyA9IHJlYWRlci5maXhlZDMyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9jb2RlYztcbiAgICB9O1xuICAgIFVuaXhUaW1lLmVuY29kZSA9IChvYmopID0+IHtcbiAgICAgICAgcmV0dXJuIGVuY29kZU1lc3NhZ2Uob2JqLCBVbml4VGltZS5jb2RlYygpKTtcbiAgICB9O1xuICAgIFVuaXhUaW1lLmRlY29kZSA9IChidWYpID0+IHtcbiAgICAgICAgcmV0dXJuIGRlY29kZU1lc3NhZ2UoYnVmLCBVbml4VGltZS5jb2RlYygpKTtcbiAgICB9O1xufSkoVW5peFRpbWUgfHwgKFVuaXhUaW1lID0ge30pKTtcbmV4cG9ydCB2YXIgTWV0YWRhdGE7XG4oZnVuY3Rpb24gKE1ldGFkYXRhKSB7XG4gICAgbGV0IF9jb2RlYztcbiAgICBNZXRhZGF0YS5jb2RlYyA9ICgpID0+IHtcbiAgICAgICAgaWYgKF9jb2RlYyA9PSBudWxsKSB7XG4gICAgICAgICAgICBfY29kZWMgPSBtZXNzYWdlKChvYmosIHcsIG9wdHMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChvcHRzLmxlbmd0aERlbGltaXRlZCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdy5mb3JrKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChvYmouTWltZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB3LnVpbnQzMigxMCk7XG4gICAgICAgICAgICAgICAgICAgIHcuc3RyaW5nKG9iai5NaW1lVHlwZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChvcHRzLmxlbmd0aERlbGltaXRlZCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdy5sZGVsaW0oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCAocmVhZGVyLCBsZW5ndGgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgICAgICAgICBjb25zdCBlbmQgPSBsZW5ndGggPT0gbnVsbCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICAgICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmouTWltZVR5cGUgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9jb2RlYztcbiAgICB9O1xuICAgIE1ldGFkYXRhLmVuY29kZSA9IChvYmopID0+IHtcbiAgICAgICAgcmV0dXJuIGVuY29kZU1lc3NhZ2Uob2JqLCBNZXRhZGF0YS5jb2RlYygpKTtcbiAgICB9O1xuICAgIE1ldGFkYXRhLmRlY29kZSA9IChidWYpID0+IHtcbiAgICAgICAgcmV0dXJuIGRlY29kZU1lc3NhZ2UoYnVmLCBNZXRhZGF0YS5jb2RlYygpKTtcbiAgICB9O1xufSkoTWV0YWRhdGEgfHwgKE1ldGFkYXRhID0ge30pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVuaXhmcy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/ipfs-unixfs/dist/src/unixfs.js\n");

/***/ })

};
;